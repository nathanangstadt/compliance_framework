/**
 * @license
 * Copyright (c) 2014, 2025, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

/* jslint regexp: true */
/* jslint browser: true*/
/* global define: false */

/**
 * This plugin handles i18n! prefixed modules. It does the following:
 *
 * 1) A regular module can have a dependency on an i18n bundle, but the regular
 * module does not want to specify what locale to load. So it just specifies
 * the top-level bundle, like "i18n!nls/colors".
 *
 * This plugin will load the i18n bundle at nls/colors, see that it is a root/master
 * bundle since it does not have a locale in its name. It will then try to find
 * the best match locale available in that master bundle, then request all the
 * locale pieces for that best match locale. For instance, if the locale is "en-us",
 * then the plugin will ask for the "en-us", "en" and "root" bundles to be loaded
 * (but only if they are specified on the master bundle).
 *
 * Once all the bundles for the locale pieces load, then it mixes in all those
 * locale pieces into each other, then finally sets the context.defined value
 * for the nls/colors bundle to be that mixed in locale.
 *
 * 2) A regular module specifies a specific locale to load. For instance,
 * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle
 * first, at nls/colors, then figure out what the best match locale is for fr-fr,
 * since maybe only fr or just root is defined for that locale. Once that best
 * fit is found, all of its locale pieces need to have their bundles loaded.
 *
 * Once all the bundles for the locale pieces load, then it mixes in all those
 * locale pieces into each other, then finally sets the context.defined value
 * for the nls/fr-fr/colors bundle to be that mixed in locale.
 */
(function () {
  'use strict';

  // regexp for reconstructing the master bundle name from parts of the regexp match
  // nlsRegExp.exec("foo/bar/baz/nls/en-ca/foo") gives:
  // ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
  // nlsRegExp.exec("foo/bar/baz/nls/foo") gives:
  // ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
  // so, if match[5] is blank, it means this is the top bundle definition.
  var nlsRegExp = /(^.*(^|\/)nls(\/|$))([^/]*)\/?([^/]*)/;

  // Helper function to avoid repeating code. Lots of arguments in the
  // desire to stay functional and support RequireJS contexts without having
  // to know about the RequireJS contexts.
  function _addPart(locale, master, needed, toLoad, prefix, suffix, localePrefix) {
    if (!master[locale]) {
      // Try the same language/region without script for zh
      // We are removing a Hans or Hant between the two dashes
      // eslint-disable-next-line no-param-reassign
      locale = locale.replace(/^zh-(Hans|Hant)-([^-]+)$/, 'zh-$2');
    }

    if (master[locale]) {
      needed.push(locale);
      if (master[locale] === true || master[locale] === 1) {
        var loc = localePrefix ? localePrefix + locale : locale;
        toLoad.push(prefix + loc + '/' + suffix);
      }
      return true;
    }
    return false;
  }

  function _isObject(val) {
    return typeof val === 'object';
  }

  /**
   * Fixes up locale to comply with BCP47 spec and returns parts that should be used for mathching the bundles
   */
  function _getLocaleParts(locale) {
    var tokens = locale.toLowerCase().split(/-|_/);
    var parts = [tokens[0]];
    var phase = 1;
    var i; // script

    for (i = 1; i < tokens.length; i++) {
      var t = tokens[i];
      var len = t.length;

      if (len === 1) {
        // extension
        break;
      }

      switch (phase) {
        case 1:
          phase = 2;
          if (len === 4) {
            // this is a script tag
            // capitalize the first letter
            parts.push(t.charAt(0).toUpperCase() + t.slice(1));
            break;
          }
        // fall through to the next case
        case 2: // region
          phase = 3;
          parts.push(t.toUpperCase());
          break;
        default: // variant
          parts.push(t);
      }
    }

    _normalizeLocaleParts(parts);

    return parts;
  }

  /**
   * 'Normalizes' locale by inserting script tag according to the following rules:
   *  zh -> zh-Hans,
   *  zh-TW -> zh-Hant-TW,
   *  zh-MO -> zh-Hant-MO,
   *  zh-HK -> zh-Hant-HK,
   *  zh-XX (except above) -> zh-Hans-XX
   */
  function _normalizeLocaleParts(parts) {
    // do nothing if the language is not 'zh' or a script tag is already
    // present
    if (parts[0] !== 'zh' || (parts.length > 1 && parts[1].length === 4)) {
      return;
    }

    var scriptTag = 'Hans';

    var region = parts.length > 1 ? parts[1] : null;

    if (region === 'TW' || region === 'MO' || region === 'HK') {
      scriptTag = 'Hant';
    }

    parts.splice(1, 0, scriptTag);
  }

  /**
   * Simple function to mix in properties from source into target,
   * but only if target does not already have a property of the same name.
   * This is not robust in IE for transferring methods that match
   * Object.prototype names, but the uses of mixin here seem unlikely to
   * trigger a problem related to that.
   */
  function _mixin(target, source) {
    var props = Object.keys(source);
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (target[prop] == null) {
        // eslint-disable-next-line no-param-reassign
        target[prop] = source[prop];
      } else if (_isObject(source[prop]) && _isObject(target[prop])) {
        _mixin(target[prop], source[prop]);
      }
    }
  }

  define('ojL10n',['module'], function (module) {
    var masterConfig = module.config ? module.config() : {};

    return {
      version: '2.0.1+',
      /**
       * Called when a dependency needs to be loaded.
       * @private
       */
      load: function (name, req, onLoad, config) {
        // eslint-disable-next-line no-param-reassign
        config = config || {};

        if (config.locale) {
          masterConfig.locale = config.locale;
        }

        var masterName;
        var match = nlsRegExp.exec(name);
        var prefix = match[1];
        var locale;
        var suffix = match[5];
        var parts;
        var toLoad = [];
        var value = {};
        var i;
        var part;
        var current = '';
        var noOverlay;
        var backup;
        var extraBundle;
        var ebPrefix;
        var ebSuffix;
        var merge;
        var locales;
        var roots;

        // If match[5] is blank, it means this is the top bundle definition,
        // so it does not have to be handled. Locale-specific requests
        // will have a match[4] value but no match[5]
        if (match[5]) {
          // locale-specific bundle
          prefix = match[1];
          masterName = prefix + suffix;
          locale = match[4];
        } else {
          // Top-level bundle.
          masterName = name;
          suffix = match[4];
          locale = masterConfig.locale;

          //  - check if the document object is available
          // Note that the 'typeof' check  is required
          if (typeof document !== 'undefined') {
            if (!locale) {
              locale = config.isBuild ? 'root' : document.documentElement.lang;
              if (!locale) {
                // navigator may be undefined in web workers
                locale =
                  navigator === undefined
                    ? 'root'
                    : // E11 reports incorrect navigator.language, so we are checking OS language first
                      // as a lame susbstitute for the server-side inspection of accept-language headers.
                      // This should not affect other browsers because that navigator.systemLanguage
                      // should be present in IE11 only
                      navigator.systemLanguage ||
                      navigator.language ||
                      navigator.userLanguage ||
                      'root';
              }
            }
            masterConfig.locale = locale;
          } else {
            locale = 'root';
          }
        }

        parts = _getLocaleParts(locale);

        noOverlay = masterConfig.noOverlay;
        backup = masterConfig.defaultNoOverlayLocale;

        var localePrefix = masterConfig.localePrefix;

        // Optional name of the bundle that should be merged with the requested bundle

        merge = masterConfig.merge;
        if (merge) {
          extraBundle = merge[prefix + suffix];
          if (extraBundle) {
            match = nlsRegExp.exec(extraBundle);
            // assume top-level bundle for the merged extra bundle
            ebPrefix = match[1];
            ebSuffix = match[4];
          }
        }

        locales = [];

        for (i = 0; i < parts.length; i++) {
          part = parts[i];
          current += (current ? '-' : '') + part;
          locales.push(current);
        }

        if (config.isBuild) {
          // Assume that  only the root bundle should be added at build time, as the user locale
          // normally cannot be predicted

          toLoad.push(masterName);

          if (extraBundle) {
            toLoad.push(extraBundle);
          }

          req(toLoad, function () {
            onLoad();
          });
        } else {
          if (masterConfig.includeLocale === 'query') {
            masterName = req.toUrl(masterName + '.js');
            masterName += (masterName.indexOf('?') === -1 ? '?' : '&') + 'loc=' + locale;
          }

          roots = [masterName];
          if (extraBundle) {
            roots.push(extraBundle);
          }

          // First, fetch the master bundle, it knows what locales are available.
          req(roots, function (master, extra) {
            var needed = [];

            var _addParts = function (masterBundle, pref, suff) {
              var noMerge = noOverlay || masterBundle.__noOverlay === true;
              var backupBundle = backup || masterBundle.__defaultNoOverlayLocale;

              var matched = false;

              for (var lo = locales.length - 1; lo >= 0 && !(matched && noMerge); lo--) {
                matched = _addPart(
                  locales[lo],
                  masterBundle,
                  needed,
                  toLoad,
                  pref,
                  suff,
                  localePrefix
                );
              }

              var rootOnly = locales.length === 1 && locales[0] === 'root';

              if (noMerge && (rootOnly || !matched) && backupBundle) {
                _addPart(backupBundle, masterBundle, needed, toLoad, pref, suff, localePrefix);
              }

              if (!rootOnly) {
                _addPart('root', masterBundle, needed, toLoad, pref, suff, localePrefix);
              }
            };

            _addParts(master, prefix, suffix);

            var mainBundleCount = needed.length;

            if (extra) {
              _addParts(extra, ebPrefix, ebSuffix);
            }

            // Load all the parts missing.
            req(toLoad, function () {
              var _mixinBundle = function (bundle, start, end /* exclusive*/, pref, suff) {
                for (var j = start; j < end && needed[j]; j++) {
                  var _part = needed[j];
                  var prefixedLoc = localePrefix ? localePrefix + _part : _part;
                  var partBundle = bundle[_part];
                  if (partBundle === true || partBundle === 1) {
                    partBundle = req(pref + prefixedLoc + '/' + suff);
                  }
                  _mixin(value, partBundle || {});
                }
              };

              // Start with the 'extra', as it is supposed to be overriding the entire main bundle
              _mixinBundle(extra, mainBundleCount, needed.length, ebPrefix, ebSuffix);

              _mixinBundle(master, 0, mainBundleCount, prefix, suffix);

              // Stash away the locale on the bundle itself to make the framework aware of the locale used
              // by Require.js

              value._ojLocale_ = parts.join('-');

              // All done, notify the loader.
              onLoad(value);
            });
          });
        }
      }
    };
  });
})();

define('ojtranslations/nls/ojtranslations',{root:{"oj-message":{fatal:"Fatal",error:"Error",warning:"Warning",info:"Info",confirmation:"Confirmation","compact-type-summary":"{0}: {1}"},"oj-converter":{summary:"Value is not in the expected format.",detail:"Enter a value in the expected format.","plural-separator":", ",hint:{summary:"Example: {exampleValue}",detail:"Try again using a format like this: {exampleValue}.","detail-plural":"Enter a value in these formats: {exampleValue}."},optionHint:{detail:"An accepted value for option '{propertyName}' is '{propertyValueValid}'.","detail-plural":"Accepted values for option '{propertyName}' are '{propertyValueValid}'."},optionTypesMismatch:{summary:"A value for the option '{requiredPropertyName}' is required when the option '{propertyName}' is set to '{propertyValue}'."},optionTypeInvalid:{summary:"A value of the expected type was not provided for option '{propertyName}'."},optionOutOfRange:{summary:"Value {propertyValue} is out of range for the option '{propertyName}'."},optionValueInvalid:{summary:"An invalid value '{propertyValue}' was specified for the option '{propertyName}'."},number:{decimalFormatMismatch:{summary:"The provided value is not in the expected number format."},shortLongUnsupportedParse:{summary:"'short' and 'long' are not supported for converter parsing.",detail:"Change component to readonly. readonly fields do not call the converter's parse function."},currencyFormatMismatch:{summary:"The provided value is not in the expected currency format."},percentFormatMismatch:{summary:"The provided value is not in the expected percent format."},invalidNumberFormat:{summary:"The provided value is not a valid number.",detail:"Please provide valid number."},parseError:{detail:"Enter a number."}},color:{invalidFormat:{summary:"Invalid color format.",detail:"Invalid color format option specification."},invalidSyntax:{summary:"Invalid color specification.",detail:"Enter a color value that conforms to the CSS3 standard."}},datetime:{datetimeOutOfRange:{summary:"Value '{value}' is out of range for the '{propertyName}'.",detail:"Enter a value between '{minValue}' and '{maxValue}'.",hour:"hour",minute:"minute",second:"second",millisec:"millisec",month:"month",day:"day",year:"year","month name":"month name",weekday:"weekday"},dateFormatMismatch:{summary:"The provided value is not in the expected date format."},invalidTimeZoneID:{summary:"Invalid timezone id {timeZoneID} provided."},nonExistingTime:{summary:"The input time does not exist because it falls during the transition to daylight saving time."},missingTimeZoneData:{summary:"TimeZone data is missing. Please call require 'ojs/ojtimezonedata' in order to load the TimeZone data."},timeFormatMismatch:{summary:"The provided value is not in the expected time format."},datetimeFormatMismatch:{summary:"The provided value is not in the expected date and time format."},dateToWeekdayMismatch:{summary:"Day '{date}' does not fall on a '{weekday}'.",detail:"Enter a weekday that corresponds with the date."},invalidISOString:{invalidRangeSummary:"The value '{value}' is out of range for the '{propertyName}' field in the ISO 8601 string '{isoStr}'.",summary:"The provided '{isoStr}' is not a valid ISO 8601 string.",detail:"Please provide valid ISO 8601 string."}}},"oj-validator":{length:{hint:{min:"Enter {min} or more characters.",max:"Enter {max} or fewer characters.",inRange:"Enter {min} to {max} characters.",exact:"Enter {length} characters."},messageDetail:{tooShort:"Enter {min} or more characters.",tooLong:"Enter no more than {max} characters."},messageSummary:{tooShort:"There are too few characters.",tooLong:"There are too many characters."}},range:{number:{hint:{min:"Enter a number greater than or equal to {min}.",max:"Enter a number less than or equal to {max}.",inRange:"Enter a number between {min} and {max}.",exact:"Enter the number {num}."},messageDetail:{rangeUnderflow:"Enter a number that's {min} or higher.",rangeOverflow:"Enter a number that's {max} or lower.",exact:"Enter the number {num}."},messageSummary:{rangeUnderflow:"The number is too low.",rangeOverflow:"The number is too high."}},datetime:{hint:{min:"Enter a date and time on or after {min}.",max:"Enter a date and time on or before {max}.",inRange:"Enter a date and time between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a date and time that's on or after {min}.",rangeOverflow:"Enter a date and time that's on or before {max}."},messageSummary:{rangeUnderflow:"Date and time is earlier than the minimum date and time.",rangeOverflow:"Date and time is later than the maximum date and time."}},date:{hint:{min:"Enter a date on or after {min}.",max:"Enter a date on or before {max}.",inRange:"Enter a date between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a date that's on or after {min}.",rangeOverflow:"Enter a date that's on or before {max}."},messageSummary:{rangeUnderflow:"Date is earlier than the minimum date.",rangeOverflow:"Date is later than the maximum date."}},time:{hint:{min:"Enter a time on or after {min}.",max:"Enter a time on or before {max}.",inRange:"Enter a time between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a time that's {min} or later.",rangeOverflow:"Enter a time that's {max} or earlier."},messageSummary:{rangeUnderflow:"Time is earlier than the minimum time.",rangeOverflow:"Time is later than the maximum time."}}},restriction:{date:{messageSummary:"Date {value} is of a disabled entry.",messageDetail:"The date you selected isn't available. Try another date."}},regExp:{summary:"Format is incorrect.",detail:"Enter allowable values described in this regular expression: '{pattern}'."},required:{summary:"Value is required.",detail:"Enter a value."}},"oj-ojEditableValue":{loading:"Loading",requiredText:"Required",helpSourceText:"Learn more..."},"oj-ojInputDate":{done:"Done",cancel:"Cancel",time:"Time",accessibleClearIconAltText:"Clear input",prevText:"Previous",nextText:"Next",currentText:"Today",weekHeader:"Wk",tooltipCalendar:"Select Date.",tooltipCalendarTime:"Select Date Time.",tooltipCalendarDisabled:"Select Date Disabled.",tooltipCalendarTimeDisabled:"Select Date Time Disabled.",setTime:"Set Time",setDate:"Set Date",picker:"Picker",weekText:"Week",datePicker:"Date Picker",dateTimePicker:"Date and Time Picker",inputHelp:"Press Key down or Key up for access to Calendar.",inputHelpBoth:"Press Key down or Key up for access to Calendar and Shift + Key down or Shift Key up for access to time drop down.",dateTimeRange:{hint:{min:"",max:"",inRange:""},messageDetail:{rangeUnderflow:"",rangeOverflow:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}},dateRestriction:{hint:"",messageSummary:"",messageDetail:""},accessibleMaxLengthExceeded:"Maximum length {len} exceeded.",accessibleMaxLengthRemaining:"{chars} characters left.",regexp:{messageSummary:"",messageDetail:""},required:{hint:""}},"oj-ojInputTime":{accessibleClearIconAltText:"Clear input",cancelText:"Cancel",okText:"OK",currentTimeText:"Now",hourWheelLabel:"Hour",minuteWheelLabel:"Minute",ampmWheelLabel:"AMPM",tooltipTime:"Select Time.",tooltipTimeDisabled:"Select Time Disabled.",inputHelp:"Press Key down or Key up for access to time drop down.",dateTimeRange:{hint:{min:"",max:"",inRange:""},messageDetail:{rangeUnderflow:"",rangeOverflow:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}}},"oj-inputBase":{required:{hint:"",messageSummary:"",messageDetail:""},regexp:{messageSummary:"",messageDetail:""},accessibleMaxLengthExceeded:"Maximum length {len} exceeded.",accessibleMaxLengthRemaining:"{chars} characters left."},"oj-ojInputText":{accessibleClearIcon:"Clear"},"oj-ojInputPassword":{regexp:{messageDetail:"Value must match this pattern: '{pattern}'."},accessibleShowPassword:"Show password.",accessibleHidePassword:"Hide password."},"oj-ojFilmStrip":{labelAccFilmStrip:"Displaying page {pageIndex} of {pageCount}",labelAccArrowNextPage:"Select Next to display next page",labelAccArrowPreviousPage:"Select Previous to display previous page",tipArrowNextPage:"Next",tipArrowPreviousPage:"Previous"},"oj-ojDataGrid":{accessibleSortAscending:"{id} sorted in ascending order",accessibleSortDescending:"{id} sorted in descending order",accessibleSortable:"{id} sortable",accessibleActionableMode:"Enter actionable mode.",accessibleNavigationMode:"Enter navigation mode, press F2 to enter edit or actionable mode.",accessibleEditableMode:"Enter editable mode, press escape to navigate outside the data grid.",accessibleSummaryExact:"This is a data grid with {rownum} rows and {colnum} columns",accessibleSummaryEstimate:"This is a data grid with unknown number of rows and columns",accessibleSummaryExpanded:"There are currently {num} rows expanded",accessibleRowExpanded:"Row expanded",accessibleExpanded:"Expanded",accessibleRowCollapsed:"Row collapsed",accessibleCollapsed:"Collapsed",accessibleRowSelected:"Row {row} selected",accessibleColumnSelected:"Column {column} selected",accessibleStateSelected:"selected",accessibleMultiCellSelected:"{num} cells selected",accessibleColumnSpanContext:"{extent} wide",accessibleRowSpanContext:"{extent} high",accessibleRowContext:"Row {index}",accessibleColumnContext:"Column {index}",accessibleRowHeaderContext:"Row Header {index}",accessibleColumnHeaderContext:"Column Header {index}",accessibleRowEndHeaderContext:"Row End Header {index}",accessibleColumnEndHeaderContext:"Column End Header {index}",accessibleRowHeaderLabelContext:"Row Header Label {level}",accessibleColumnHeaderLabelContext:"Column Header Label {level}",accessibleRowEndHeaderLabelContext:"Row End Header Label {level}",accessibleColumnEndHeaderLabelContext:"Column End Header Label {level}",accessibleLevelContext:"Level {level}",accessibleRangeSelectModeOn:"Add selected range of cells mode on.",accessibleRangeSelectModeOff:"Add selected range of cells mode off.",accessibleFirstRow:"You have reached the first row.",accessibleLastRow:"You have reached the last row.",accessibleFirstColumn:"You have reached the first column",accessibleLastColumn:"You have reached the last column.",accessibleEndOfDataGrid:"End of data grid.",accessibleSelectionAffordanceTop:"Top selection handle.",accessibleSelectionAffordanceBottom:"Bottom selection handle.",accessibleLevelHierarchicalContext:"Level {level}",accessibleRowHierarchicalFull:"Row {posInSet} of {setSize} rows",accessibleRowHierarchicalPartial:"Row {posInSet} of at least {setSize} rows",accessibleRowHierarchicalUnknown:"At least row {posInSet} of at least {setSize} rows",accessibleColumnHierarchicalFull:"Column {posInSet} of {setSize} columns",accessibleColumnHierarchicalPartial:"Column {posInSet} of at least {setSize} columns",accessibleColumnHierarchicalUnknown:"At least column {posInSet} of at least {setSize} columns",accessibleFilterable:"Filterable",accessibleFiltered:"Filtered",msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",msgReadOnly:"This cell is read-only and can't be edited.",labelHideColumns:"Hide Columns",labelHideRows:"Hide Rows",labelUnhideColumns:"Unhide Columns",labelUnhideRows:"Unhide Rows",labelResize:"Resize",labelResizeWidth:"Resize Width",labelResizeHeight:"Resize Height",labelSortAsc:"Sort Ascending",labelSortDsc:"Sort Descending",labelSortRow:"Sort Row",labelSortRowAsc:"Sort Row Ascending",labelSortRowDsc:"Sort Row Descending",labelSortCol:"Sort Column",labelSortColAsc:"Sort Column Ascending",labelSortColDsc:"Sort Column Descending",labelFilter:"Filter",labelFilterCol:"Filter Column",labelCut:"Cut",labelPaste:"Paste",labelCutCells:"Cut",labelPasteCells:"Paste",labelCopyCells:"Copy",labelAutoFill:"Autofill",labelEnableNonContiguous:"Enable Non-Contiguous Selection",labelDisableNonContiguous:"Disable Non-Contiguous Selection",labelResizeDialogSubmit:"OK",labelResizeDialogCancel:"Cancel",accessibleContainsControls:"Contains Controls",labelSelectMultiple:"Select Multiple",labelResizeDialogApply:"Apply",labelResizeFitToContent:"Resize to Fit",columnWidth:"Width in Pixels",rowHeight:"Height in Pixels",labelResizeColumn:"Resize Column",labelResizeRow:"Resize Row",resizeColumnDialog:"Resize column",resizeRowDialog:"Resize row",labelFreezeRow:"Freeze Rows",labelFreezeCol:"Freeze Columns",labelUnfreezeRow:"Unfreeze Rows",labelUnfreezeCol:"Unfreeze Columns",collapsedText:"Collapse",expandedText:"Expand",tooltipRequired:"Required"},"oj-ojRowExpander":{accessibleLevelDescription:"Level {level}",accessibleRowDescription:"Level {level}, Row {num} of {total}",accessibleRowDescriptionAtLeast:"Level {level}, Row {num} of at least {total}",accessibleRowExpanded:"Row expanded",accessibleRowCollapsed:"Row collapsed",accessibleStateExpanded:"expanded",accessibleStateCollapsed:"collapsed"},"oj-ojStreamList":{msgFetchingData:"Fetching Data..."},"oj-ojListView":{msgFetchingData:"Loading",msgNoData:"No items to display.",msgItemsAppended:"{count} items appended to the end.",msgFetchCompleted:"Loaded",indexerCharacters:"A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z",accessibleExpandCollapseInstructionText:"Use arrow keys to expand and collapse.",accessibleGroupExpand:"Expanded",accessibleGroupCollapse:"Collapsed",accessibleReorderTouchInstructionText:"Double tap and hold.  Wait for the sound then drag to rearrange.",accessibleReorderBeforeItem:"Before {item}",accessibleReorderAfterItem:"After {item}",accessibleReorderInsideItem:"Into {item}",accessibleNavigateSkipItems:"Skipping {numSkip} items",accessibleSuggestion:"Suggestion",labelCut:"Cut",labelCopy:"Copy",labelPaste:"Paste",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After"},"oj-ojWaterfallLayout":{msgFetchingData:"Fetching Data..."},"oj-_ojLabel":{tooltipHelp:"Help",tooltipRequired:"Required"},"oj-ojLabel":{tooltipHelp:"Help",tooltipRequired:"Required"},"oj-ojInputNumber":{required:{hint:"",messageSummary:"",messageDetail:""},numberRange:{hint:{min:"",max:"",inRange:"",exact:""},messageDetail:{rangeUnderflow:"",rangeOverflow:"",exact:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}},tooltipDecrement:"Decrement",tooltipIncrement:"Increment"},"oj-ojTable":{accessibleAddRow:"Enter data to add a new row.",accessibleColumnContext:"Column {index}",accessibleColumnFooterContext:"Column Footer {index}",accessibleColumnHeaderContext:"Column Header {index}",accessibleContainsControls:"Contains Controls",accessibleColumnsSpan:"Spans {count} Columns",accessibleEditableSummary:"Press F2 to focus read only controls or enter to begin editing",accessibleRowContext:"Row {index}",accessibleSortable:"{id} sortable",accessibleSortAscending:"{id} sorted in ascending order",accessibleSortDescending:"{id} sorted in descending order",accessibleStateSelected:"selected",accessibleStateUnselected:"unselected",accessibleSummaryEstimate:"Table with {colnum} columns and more than {rownum} rows",accessibleSummaryExact:"Table with {colnum} columns and {rownum} rows",labelAccSelectionAffordanceTop:"Top selection handle",labelAccSelectionAffordanceBottom:"Bottom selection handle",labelEnableNonContiguousSelection:"Enable Non-Contiguous Selection",labelDisableNonContiguousSelection:"Disable Non-Contiguous Selection",labelResize:"Resize",labelResizeColumn:"Resize Column",labelResizePopupSubmit:"OK",labelResizePopupCancel:"Cancel",labelResizePopupSpinner:"Resize Column",labelResizeColumnDialog:"Resize column",labelColumnWidth:"Width in Pixels",labelResizeDialogApply:"Apply",labelSelectRow:"Select Row",labelSelectAllRows:"Select All Rows",labelEditRow:"Edit Row",labelSelectAndEditRow:"Select And Edit Row",labelSelectColumn:"Select Column",labelSort:"Sort",labelSortAsc:"Sort Ascending",labelSortDsc:"Sort Descending",msgFetchingData:"Fetching Data...",msgNoData:"No data to display.",msgInitializing:"Initializing...",msgColumnResizeWidthValidation:"Width value must be an integer.",msgScrollPolicyMaxCountSummary:"Exceeded maximum rows for table scrolling.",msgScrollPolicyMaxCountDetail:"Please reload with smaller data set.",msgStatusSortAscending:"{0} sorted in ascending order.",msgStatusSortDescending:"{0} sorted in descending order.",tooltipRequired:"Required",tooltipSeparator:" - "},"oj-ojTabs":{labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After",labelRemove:"Remove",labelReorder:"Reorder",removeCueText:"Removable"},"oj-ojCheckboxset":{readonlyNoValue:"",required:{hint:"",messageSummary:"",messageDetail:"Select a value."}},"oj-ojRadioset":{readonlyNoValue:"",required:{hint:"",messageSummary:"",messageDetail:"Select a value."}},"oj-ojSelect":{required:{hint:"",messageSummary:"",messageDetail:"Select a value."},searchField:"{label} search",noMatchesFound:"No matches found",noMoreResults:"No more results",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found",filterFurther:"More results available, please filter further."},"oj-ojSwitch":{SwitchON:"On",SwitchOFF:"Off"},"oj-ojCombobox":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",noMoreResults:"No more results",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found",filterFurther:"More results available, please filter further."},"oj-ojSelectSingle":{required:{hint:"",messageSummary:"",messageDetail:"Select a value."},noMatchesFound:"No matches found",oneMatchFound:"One match found",multipleMatchesFound:"{num} matches found",nOrMoreMatchesFound:"{num} or more matches found",cancel:"Cancel",labelAccOpenDropdown:"expand",labelAccClearValue:"clear value",noResultsLine1:"No results found",noResultsLine2:"We can't find anything matching your search."},"oj-ojInputSearch2":{cancel:"Cancel",noSuggestionsFound:"No suggestions found"},"oj-ojInputSearch":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found"},"oj-ojTreeView":{treeViewSelectorAria:"TreeView Selector {rowKey}",retrievingDataAria:"Retrieving data for node: {nodeText}",receivedDataAria:"Received data for node: {nodeText}"},"oj-ojTree":{stateLoading:"Loading...",labelNewNode:"New Node",labelMultiSelection:"Multiple Selection",labelEdit:"Edit",labelCreate:"Create",labelCut:"Cut",labelCopy:"Copy",labelPaste:"Paste",labelPasteAfter:"Paste After",labelPasteBefore:"Paste Before",labelRemove:"Remove",labelRename:"Rename",labelNoData:"No data"},"oj-ojPagingControl":{labelAccPaging:"Pagination",labelAccPageNumber:"Page {pageNum} content loaded",labelAccNavFirstPage:"First Page",labelAccNavLastPage:"Last Page",labelAccNavNextPage:"Next Page",labelAccNavPreviousPage:"Previous Page",labelAccNavPage:"Page",labelLoadMore:"Show More...",labelLoadMoreMaxRows:"Reached Maximum Limit of {maxRows} rows",labelNavInputPage:"Page",labelNavInputPageMax:"of {pageMax}",fullMsgItemRange:"{pageFrom}-{pageTo} of {pageMax} items",fullMsgItemRangeAtLeast:"{pageFrom}-{pageTo} of at least {pageMax} items",fullMsgItemRangeApprox:"{pageFrom}-{pageTo} of approx {pageMax} items",msgItemRangeNoTotal:"{pageFrom}-{pageTo} items",fullMsgItem:"{pageTo} of {pageMax} items",fullMsgItemAtLeast:"{pageTo} of at least {pageMax} items",fullMsgItemApprox:"{pageTo} of approx {pageMax} items",msgItemNoTotal:"{pageTo} items",msgItemRangeCurrent:"{pageFrom}-{pageTo}",msgItemRangeCurrentSingle:"{pageFrom}",msgItemRangeOf:"of",msgItemRangeOfAtLeast:"of at least",msgItemRangeOfApprox:"of approx.",msgItemRangeItems:"items",tipNavInputPage:"Go To Page",tipNavPageLink:"Go To Page {pageNum}",tipNavNextPage:"Next",tipNavPreviousPage:"Previous",tipNavFirstPage:"First",tipNavLastPage:"Last",pageInvalid:{summary:"The page value entered is invalid.",detail:"Please enter a value greater than 0."},maxPageLinksInvalid:{summary:"Value for maxPageLinks is invalid.",detail:"Please enter a value greater than 4."}},"oj-ojMasonryLayout":{labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After"},"oj-panel":{labelAccButtonExpand:"Expand",labelAccButtonCollapse:"Collapse",labelAccButtonRemove:"Remove",labelAccFlipForward:"Flip forward",labelAccFlipBack:"Flip back",tipDragToReorder:"Drag to reorder",labelAccDragToReorder:"Drag to reorder, context menu available"},"oj-ojChart":{labelDefaultGroupName:"Group {0}",labelSeries:"Series",labelGroup:"Group",labelDate:"Date",labelValue:"Value",labelDataLabel:"Label",labelTargetValue:"Target",labelX:"X",labelY:"Y",labelZ:"Z",labelPercentage:"Percentage",labelLow:"Low",labelHigh:"High",labelOpen:"Open",labelClose:"Close",labelVolume:"Volume",labelQ1:"Q1",labelQ2:"Q2",labelQ3:"Q3",labelMin:"Min",labelMax:"Max",labelOther:"Other",tooltipPan:"Pan",tooltipSelect:"Marquee select",tooltipZoom:"Marquee zoom",stateLoading:"Loading",stateLoaded:"Loaded",componentName:"Chart"},"oj-dvtBaseGauge":{componentName:"Gauge"},"oj-ojDiagram":{promotedLink:"{0} link",promotedLinks:"{0} links",promotedLinkAriaDesc:"Indirect",componentName:"Diagram"},"oj-ojGantt":{componentName:"Gantt",accessibleDurationDays:"{0} days",accessibleDurationHours:"{0} hours",accessibleTaskInfo:"Start time is {0}, end time is {1}, duration is {2}",accessibleMilestoneInfo:"Time is {0}",accessibleRowInfo:"Row {0}",accessibleTaskTypeMilestone:"Milestone",accessibleTaskTypeSummary:"Summary",accessiblePredecessorInfo:"{0} predecessors",accessibleSuccessorInfo:"{0} successors",accessibleDependencyInfo:"Dependency type {0}, connects {1} to {2}",startStartDependencyAriaDesc:"start to start",startFinishDependencyAriaDesc:"start to finish",finishStartDependencyAriaDesc:"finish to start",finishFinishDependencyAriaDesc:"finish to finish",tooltipZoomIn:"Zoom In",tooltipZoomOut:"Zoom Out",labelLevel:"Level",labelRow:"Row",labelStart:"Start",labelEnd:"End",labelDate:"Date",labelBaselineStart:"Baseline Start",labelBaselineEnd:"Baseline End",labelBaselineDate:"Baseline Date",labelDowntimeStart:"Downtime Start",labelDowntimeEnd:"Downtime End",labelOvertimeStart:"Overtime Start",labelOvertimeEnd:"Overtime End",labelAttribute:"Attribute",labelLabel:"Label",labelProgress:"Progress",labelMoveBy:"Move By",labelResizeBy:"Resize By",taskMoveInitiated:"Task move initiated",rowAxisLabel:"Row labels",taskResizeEndInitiated:"Task resize end initiated",taskResizeStartInitiated:"Task resize start initiated",taskMoveSelectionInfo:"{0} others selected",taskResizeSelectionInfo:"{0} others selected",taskMoveInitiatedInstruction:"Use the arrow keys to move",taskResizeInitiatedInstruction:"Use the arrow keys to resize",taskMoveFinalized:"Task move finalized",taskResizeFinalized:"Task resize finalized",taskMoveCancelled:"Task move cancelled",taskResizeCancelled:"Task resize cancelled",taskResizeStartHandle:"Task resize start handle",taskResizeEndHandle:"Task resize end handle"},"oj-ojLegend":{componentName:"Legend",tooltipExpand:"Expand",tooltipCollapse:"Collapse",labelInvalidData:"Invalid data",labelNoData:"No data to display",labelClearSelection:"Clear Selection",stateSelected:"Selected",stateUnselected:"Unselected",stateMaximized:"Maximized",stateMinimized:"Minimized",stateIsolated:"Isolated",labelCountWithTotal:"{0} of {1}",accessibleContainsControls:"Contains Controls"},"oj-ojNBox":{highlightedCount:"{0}/{1}",labelOther:"Other",labelGroup:"Group",labelSize:"Size",labelAdditionalData:"Additional Data",componentName:"{0} Box"},"oj-ojPictoChart":{componentName:"Picture Chart"},"oj-ojSparkChart":{componentName:"Chart"},"oj-ojSunburst":{labelColor:"Color",labelSize:"Size",tooltipExpand:"Expand",tooltipCollapse:"Collapse",stateLoading:"Loading",stateLoaded:"Loaded",componentName:"Sunburst"},"oj-ojTagCloud":{componentName:"Tag Cloud",accessibleContainsControls:"Contains Controls",labelCountWithTotal:"{0} of {1}",labelInvalidData:"Invalid data",stateCollapsed:"Collapsed",stateDrillable:"Drillable",stateExpanded:"Expanded",stateIsolated:"Isolated",stateHidden:"Hidden",stateMaximized:"Maximized",stateMinimized:"Minimized",stateVisible:"Visible"},"oj-ojThematicMap":{componentName:"Thematic Map",areasRegion:"Areas",linksRegion:"Links",markersRegion:"Markers"},"oj-ojTimeAxis":{componentName:"Time Axis"},"oj-ojTimeline":{componentName:"Timeline",stateMinimized:"Minimized",stateMaximized:"Maximized",stateIsolated:"Isolated",stateHidden:"Hidden",stateExpanded:"Expanded",stateVisible:"Visible",stateDrillable:"Drillable",stateCollapsed:"Collapsed",labelCountWithTotal:"{0} of {1}",accessibleItemDesc:"Description is {0}.",accessibleItemEnd:"End time is {0}.",accessibleItemStart:"Start time is {0}.",accessibleItemTitle:"Title is {0}.",labelSeries:"Series",tooltipZoomIn:"Zoom In",tooltipZoomOut:"Zoom Out",labelStart:"Start",labelEnd:"End",labelAccNavNextPage:"Next Page",labelAccNavPreviousPage:"Previous Page",tipArrowNextPage:"Next",tipArrowPreviousPage:"Previous",navArrowDisabledState:"Disabled",labelDate:"Date",labelTitle:"Title",labelDescription:"Description",labelMoveBy:"Move By",labelResizeBy:"Resize By",itemMoveInitiated:"Event move initiated",itemResizeEndInitiated:"Event resize end initiated",itemResizeStartInitiated:"Event resize start initiated",itemMoveSelectionInfo:"{0} others selected",itemResizeSelectionInfo:"{0} others selected",itemMoveInitiatedInstruction:"Use the arrow keys to move",itemResizeInitiatedInstruction:"Use the arrow keys to resize",itemMoveFinalized:"Event move finalized",itemResizeFinalized:"Event resize finalized",itemMoveCancelled:"Event move cancelled",itemResizeCancelled:"Event resize cancelled",itemResizeStartHandle:"Event resize start handle",itemResizeEndHandle:"Event resize end handle"},"oj-ojTreemap":{labelColor:"Color",labelSize:"Size",tooltipIsolate:"Isolate",tooltipRestore:"Restore",stateLoading:"Loading",stateLoaded:"Loaded",componentName:"Treemap"},"oj-dvtBaseComponent":{labelScalingSuffixThousand:"K",labelScalingSuffixMillion:"M",labelScalingSuffixBillion:"B",labelScalingSuffixTrillion:"T",labelScalingSuffixQuadrillion:"Q",labelInvalidData:"Invalid data",labelNoData:"No data to display",labelClearSelection:"Clear Selection",labelDataVisualization:"Data Visualization",stateSelected:"Selected",stateUnselected:"Unselected",stateMaximized:"Maximized",stateMinimized:"Minimized",stateExpanded:"Expanded",stateCollapsed:"Collapsed",stateIsolated:"Isolated",stateHidden:"Hidden",stateVisible:"Visible",stateDrillable:"Drillable",labelAndValue:"{0}: {1}",labelCountWithTotal:"{0} of {1}",accessibleContainsControls:"Contains Controls"},"oj-ojRatingGauge":{labelClearSelection:"Clear Selection",stateSelected:"Selected",stateUnselected:"Unselected",stateMaximized:"Maximized",stateMinimized:"Minimized",stateExpanded:"Expanded",stateCollapsed:"Collapsed",stateIsolated:"Isolated",stateHidden:"Hidden",stateVisible:"Visible",stateDrillable:"Drillable",labelCountWithTotal:"{0} of {1}",accessibleContainsControls:"Contains Controls"},"oj-ojStatusMeterGauge":{labelClearSelection:"Clear Selection",stateSelected:"Selected",stateUnselected:"Unselected",stateMaximized:"Maximized",stateMinimized:"Minimized",stateExpanded:"Expanded",stateCollapsed:"Collapsed",stateIsolated:"Isolated",stateHidden:"Hidden",stateVisible:"Visible",stateDrillable:"Drillable",labelCountWithTotal:"{0} of {1}",accessibleContainsControls:"Contains Controls"},"oj-ojNavigationList":{defaultRootLabel:"Navigation List",hierMenuBtnLabel:"Hierarchical Menu button",selectedLabel:"selected",previousIcon:"Previous",msgFetchingData:"Fetching Data...",msgNoData:"",overflowItemLabel:"More Tabs",accessibleReorderTouchInstructionText:"Double tap and hold.  Wait for the sound then drag to rearrange.",accessibleReorderBeforeItem:"Before {item}",accessibleReorderAfterItem:"After {item}",labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After",labelRemove:"Remove",removeCueText:"Removable",accessibleExpandCollapseInstructionText:"Use arrow keys to expand and collapse.",labelActions:"Actions",labelMoveLeft:"Move Left",labelMoveRight:"Move Right",labelContextMenu:"has context menu"},"oj-ojSlider":{noValue:"ojSlider has no value",maxMin:"Max must not be less than or equal to min",startEnd:"value.start must not be greater than value.end",valueRange:"Value must be within min to max range",optionNum:"{option} option is not a number",invalidStep:"Invalid step; step must be > 0",lowerValueThumb:"lower value thumb",higherValueThumb:"higher value thumb"},"oj-ojDialog":{labelCloseIcon:"Close"},"oj-ojPopup":{ariaLiveRegionInitialFocusFirstFocusable:"Entering pop-up. Press F6 to navigate between the pop-up and associated control.",ariaLiveRegionInitialFocusNone:"Pop-up opened. Press F6 to navigate between the pop-up and associated control.",ariaLiveRegionInitialFocusFirstFocusableTouch:"Entering pop-up. Pop-up can be closed by navigating to the last link within the pop-up.",ariaLiveRegionInitialFocusNoneTouch:"Pop-up opened. Navigate to the next link to establish focus within the pop-up.",ariaFocusSkipLink:"Double tap to navigate to the open pop-up.",ariaCloseSkipLink:"Double tap to close the open pop-up."},"oj-ojRefresher":{ariaRefreshLink:"Activate link to refresh content",ariaRefreshingLink:"Refreshing content",ariaRefreshCompleteLink:"Refresh complete"},"oj-ojSwipeActions":{ariaShowStartActionsDescription:"Show start actions",ariaShowEndActionsDescription:"Show end actions",ariaHideActionsDescription:"Hide actions"},"oj-ojIndexer":{indexerCharacters:"A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z",indexerOthers:"#",ariaDisabledLabel:"No matching group header",ariaOthersLabel:"number",ariaInBetweenText:"Between {first} and {second}",ariaKeyboardInstructionText:"Press enter to select value.",ariaTouchInstructionText:"Double tap and hold to enter gesture mode, then drag up or down to adjust value."},"oj-ojMenu":{labelCancel:"Cancel",ariaFocusSkipLink:"Focus is within the menu, double tap or swipe to move focus to the first menu item."},"oj-ojColorSpectrum":{labelHue:"Hue",labelOpacity:"Opacity",labelSatLum:"Saturation/Luminance",labelThumbDesc:"Color spectrum four way slider."},"oj-ojColorPalette":{labelNone:"None"},"oj-ojColorPicker":{labelSwatches:"Swatches",labelCustomColors:"Custom Colors",labelPrevColor:"Previous Color",labelDefColor:"Default Color",labelDelete:"Delete",labelDeleteQ:"Delete?",labelAdd:"Add",labelAddColor:"Add color",labelMenuHex:"HEX",labelMenuRgba:"RGBa",labelMenuHsla:"HSLa",labelSliderHue:"Hue",labelSliderSaturation:"Saturation",labelSliderSat:"Sat",labelSliderLightness:"Lightness",labelSliderLum:"Luminosity",labelSliderAlpha:"Alpha",labelOpacity:"Opacity",labelSliderRed:"Red",labelSliderGreen:"Green",labelSliderBlue:"Blue"},"oj-ojFilePicker":{dropzoneText:"Drop files here or click to upload",singleFileUploadError:"Upload one file at a time.",singleFileTypeUploadError:"You can't upload files of type {fileType}.",multipleFileTypeUploadError:"You can't upload files of type: {fileTypes}.",dropzonePrimaryText:"Drag and Drop",secondaryDropzoneText:"Select a file or drop one here.",secondaryDropzoneTextMultiple:"Select or drop files here.",unknownFileType:"unknown"},"oj-ojProgressbar":{ariaIndeterminateProgressText:"In Progress"},"oj-ojMessage":{labelCloseIcon:"Close",categories:{error:"Error",warning:"Warning",info:"Information",confirmation:"Confirmation",none:"None"}},"oj-ojMessages":{labelLandmark:"Messages",ariaLiveRegion:{navigationFromKeyboard:"Entering messages region. Press F6 to navigate back to prior focused element.",navigationToTouch:"Messages region has new messages.",navigationToKeyboard:"Messages region has new messages. Press F6 to navigate.",newMessage:"Message category {category}. {summary}. {detail}.",noDetail:"Detail is not available"}},"oj-ojMessageBanner":{close:"Close",navigationFromMessagesRegion:"Entering messages region. Press F6 to navigate back to prior focused element.",navigationToMessagesRegion:"Messages region has new messages. Press F6 to navigate.",navigationToTouch:"Messages region has new messages.",error:"Error",warning:"Warning",info:"Information",confirmation:"Confirmation"},"oj-ojConveyorBelt":{tipArrowNext:"Next",tipArrowPrevious:"Previous"},"oj-ojTrain":{stepInfo:"Step {index} out of {count}.",stepStatus:"Status: {status}.",stepCurrent:"Current",stepVisited:"Visited",stepNotVisited:"Not visited",stepDisabled:"Disabled",stepMessageType:"Message type: {messageType}.",stepMessageConfirmation:"Confirmed",stepMessageInfo:"Info",stepMessageWarning:"Warning",stepMessageError:"Error"}},ar:1,"ar-XB":1,bg:1,bs:1,"bs-Cyrl":1,cs:1,da:1,de:1,el:1,"en-XA":1,"en-XC":1,es:1,et:1,fi:1,fr:1,"fr-CA":1,he:1,hr:1,hu:1,is:1,it:1,ja:1,ko:1,lt:1,lv:1,ms:1,nl:1,no:1,pl:1,pseudo:1,pt:1,"pt-PT":1,ro:1,ru:1,sk:1,sl:1,sr:1,"sr-Latn":1,sv:1,th:1,tr:1,uk:1,vi:1,"zh-Hans":1,"zh-Hant":1});

define('ojs/ojlogger',['exports', '@oracle/oraclejet-preact/utils/UNSAFE_logger'], function (exports, PreactLogger) { 'use strict';

  /**
   * @namespace
   * @name oj.Logger
   * @hideconstructor
   * @ojtsmodule
   * @since 1.0.0
   *
   * @classdesc
   * <h3>JET Logger</h3>
   *
   * <p>Logger object writes into the native browser console or a custom writer, if a custom writer is set as an option.
   * To use a custom writer, implement the following writer methods: log(), info(), warn(), error()
   *
   * <p>When any of the logging methods is called, it compares the requested log level with the value of a log level option
   * and logs the message if the log level is sufficient.
   *
   * <p>If the logging options are changed at a later point, the Logger will use the modified options for the subsequent log operations.
   *
   * <p>The logging level can be overridden via sessionStorage.setItem() call for the current browser session.
   * Use 'ojet.logLevel' as the key with one of the following values: 'none' (least verbose), 'error', 'warning', 'info', 'log' (most verbose).
   * Set the value in the browser console and refresh the browser in order for the value to take effect.
   * </p>
   * <h3> Session storage usage : </h3>
   * <pre class="prettyprint">
   * <code>
   * // override logging level for the current session
   * sessionStorage.setItem('ojet.logLevel', 'log');
   * </code></pre>
   *
   * <p>All the logging methods support string formatting, accept variable number of arguments and accept a function as a parameter.
   * When a callback function is specified as a parameter the function will be called if the log level is sufficient.
   *
   * <h3> Logger usage : </h3>
   * <pre class="prettyprint">
   * <code>
   * //optional calls, see defaults
   * Logger.option("level",  Logger.LEVEL_INFO);
   * Logger.option("writer",  customWriter);  //an object that implements the following methods: log(), info(), warn(), error()
   *
   * // logging a message
   * Logger.info("My log level is %d", Logger.option("level"));  // string formatting
   * Logger.warn("Beware of bugs", "in the above code");            // multiple parameters
   *
   * // using a callback function as a parameter
   * Logger.info(function(){
   *    var foo = "This ";
   *    var bar = "is ";
   *    var zing = "a function";
   *    return foo + bar + zing;
   * });
   * </code></pre>
   *
   * @desc oj.Logger cannot be instantiated
   * @export
   */
  const Logger = {};

  /**
   * Log level none
   * @const
   * @export
   * @type {number}
   * @memberof oj.Logger
   * @alias LEVEL_NONE
   */
  Logger.LEVEL_NONE = 0;
  /**
   * Log level error
   * @const
   * @type {number}
   * @export
   * @memberof oj.Logger
   * @alias LEVEL_ERROR
   */
  Logger.LEVEL_ERROR = 1;
  /**
   * Log level warning
   * @const
   * @type {number}
   * @export
   * @memberof oj.Logger
   * @alias LEVEL_WARN
   */
  Logger.LEVEL_WARN = 2;
  /**
   * Log level info
   * @const
   * @type {number}
   * @export
   * @memberof oj.Logger
   * @alias LEVEL_INFO
   */
  Logger.LEVEL_INFO = 3;
  /**
   * Log level - general message
   * @const
   * @type {number}
   * @export
   * @memberof oj.Logger
   * @alias LEVEL_LOG
   */
  Logger.LEVEL_LOG = 4;

  /* private constants*/
  Logger._defaultOptions = { level: Logger.LEVEL_ERROR, writer: null };
  Logger._options = Logger._defaultOptions;

  /* public members*/
  /**
   * Writes an error message.
   * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
   *                      See examples in the overview section above.
   * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
   * @return {void}
   * @export
   * @memberof oj.Logger
   * @method error
   * @since 1.0.0
   * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
   */
  Logger.error = PreactLogger.error.bind(PreactLogger);

  /**
   * Writes an informational  message.
   * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
   *                      See examples in the overview section above.
   * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
   * @return {void}
   * @export
   * @memberof oj.Logger
   * @method info
   * @since 1.0.0
   * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
   */
  Logger.info = PreactLogger.info.bind(PreactLogger);

  /**
   * Writes a warning message.
   * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
   *                      See examples in the overview section above.
   * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
   * @export
   * @return {void}
   * @memberof oj.Logger
   * @method warn
   * @since 1.0.0
   * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
   */
  Logger.warn = PreactLogger.warn.bind(PreactLogger);

  /**
   * Writes a general message.
   * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
   *                      See examples in the overview section above.
   * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
   * @return {void}
   * @export
   * @memberof oj.Logger
   * @method log
   * @since 1.0.0
   * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
   */
  Logger.log = PreactLogger.log.bind(PreactLogger);

  /**
   * Method for setting and getting logger option/options
   * <p>Sets/gets logger configuration - level and/or writer. Accepts variable number of arguments.
   * <p><h5>Defaults:</h5>
   * Default level: oj.Logger.LEVEL_ERROR<br/>
   * Default writer: null; writes to the console
   * <p><h5>Usages:</h5>
   * <i>oj.Logger.option(optionName)</i> gets the value associated the the specified optionName<br/>
   * <i>oj.Logger.option()</i> gets an object containing key/value pairs representing the logger options hash<br/>
   * <i>oj.Logger.option(optionName, value)</i> sets  the option value associated with optionName<br/>
   * <i>oj.Logger.option(options)</i> sets  one or more options for the logger
   *
   * @example <caption>Overriding default options</caption>
   * oj.Logger.option("level",  oj.Logger.LEVEL_INFO);
   * oj.Logger.option("writer",  customWriter);  //an object that implements the following methods: log(), info(), warn(), error()
   *
   * @param {Object|string} [key]
   * @param {any} [value]
   * @return {any}
   * @export
   * @memberof oj.Logger
   * @method option
   * @since 1.0.0
   * @ojsignature {target: "Type", for: "key", value: "'level'|'writer'|{level?: any, writer?: any}"}
   */
  Logger.option = function (key, value) {
    // getters
    var ret = {};
    var i;
    var keys;

    if (arguments.length === 0) {
      keys = Object.keys(Logger._options);
      for (i = 0; i < keys.length; i++) {
        ret[keys[i]] = keys[i] === 'level' ? PreactLogger.getLogLevel() : Logger._options[keys[i]];
      }
      return ret;
    }
    if (typeof key === 'string' && value === undefined) {
      let optValue;
      switch (key) {
        case 'level':
          optValue = PreactLogger.getLogLevel();
          break;
        case 'writer':
          optValue = Logger._options.writer;
          break;
        default:
          optValue = null;
      }
      return optValue;
    }

    // setters
    if (typeof key === 'string') {
      if (key === 'level') {
        PreactLogger.setLogLevel(value);
      } else if (key === 'writer') {
        PreactLogger.setLogWriter(value);
        // Keep the writer since PreactLogger does not have getLogWriter() method
        Logger._options[key] = value;
      }
    } else {
      // case when all options are set in one call
      var options = key;
      keys = Object.keys(options);
      for (i = 0; i < keys.length; i++) {
        Logger.option(keys[i], options[keys[i]]);
      }
    }

    return undefined;
  };

  const info = Logger.info;
  const error = Logger.error;
  const warn = Logger.warn;
  const log = Logger.log;
  const option = Logger.option;
  const LEVEL_ERROR = Logger.LEVEL_ERROR;
  const LEVEL_INFO = Logger.LEVEL_INFO;
  const LEVEL_LOG = Logger.LEVEL_LOG;
  const LEVEL_NONE = Logger.LEVEL_NONE;
  const LEVEL_WARN = Logger.LEVEL_WARN;

  exports.LEVEL_ERROR = LEVEL_ERROR;
  exports.LEVEL_INFO = LEVEL_INFO;
  exports.LEVEL_LOG = LEVEL_LOG;
  exports.LEVEL_NONE = LEVEL_NONE;
  exports.LEVEL_WARN = LEVEL_WARN;
  exports.error = error;
  exports.info = info;
  exports.log = log;
  exports.option = option;
  exports.warn = warn;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojwebdrivertest-proxy',['require', 'exports'], function (require, exports) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) { return e; } else {
            var n = {};
            if (e) {
                Object.keys(e).forEach(function (k) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                });
            }
            n['default'] = e;
            return n;
        }
    }

    /**
     * This proxy is used by JET's test adapters to access runtime modules that are needed to perform
     * testing actions.
     */
    const TEST_OBJ_NAME = '__ojwebdrivertest_proxy';
    const modules = {
        BusyContext: () => new Promise(function (resolve, reject) { require(['ojs/ojcontext'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then(({ default: Context }) => Context.getPageContext().getBusyContext()),
        Chai: () => new Promise(function (resolve, reject) { require(['chai'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then(({ default: Chai }) => Chai),
        Core: () => new Promise(function (resolve, reject) { require(['ojs/ojcore-base'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then(({ default: Core }) => Core),
        CspExpressionEvaluator: () => new Promise(function (resolve, reject) { require(['ojs/ojcspexpressionevaluator'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then(({ default: CspExpressionEvaluator }) => CspExpressionEvaluator),
        CustomElementUtils: () => new Promise(function (resolve, reject) { require(['ojs/ojcustomelement-utils'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then(({ CustomElementUtils }) => CustomElementUtils),
        KeySet: () => new Promise(function (resolve, reject) { require(['ojs/ojkeyset'], function (m) { resolve(_interopNamespace(m)); }, reject) }),
        KeyUtils: () => new Promise(function (resolve, reject) { require(['ojs/ojcore-base'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then(({ default: { KeyUtils } }) => KeyUtils),
        Knockout: () => new Promise(function (resolve, reject) { require(['knockout'], function (m) { resolve(_interopNamespace(m)); }, reject) })
    };
    const cachedModules = {};
    /**
     * Get the modules defined by names. Modules will be returned in a Promise.
     * await getProxy('ModuleA', 'ModuleB', ...).then(modules => ...)
     * @param moduleNames The module names to fetch
     * @returns {Promise<object[]>} A Promise resolving to all of the requested modules
     */
    function getProxy(...moduleNames) {
        return Promise.all(moduleNames.map((name) => {
            if (!modules[name]) {
                throw Error(`module "${name}" does not exist in test proxy`);
            }
            const cache = cachedModules[name];
            if (cache) {
                return Promise.resolve(cache);
            }
            else {
                // call the getter for each module to invoke its dynamic import.
                console.log(`getProxy importing ${name}`);
                return modules[name]().then((result) => {
                    cachedModules[name] = result;
                    return result;
                });
            }
        }));
    }
    /**
     * Get the modules defined by names.  Assumes that getProxy has been previously called.
     * This function simply looks up previously imported modules from the cache.
     * @param moduleNames The module names to fetch
     * @returns {object[]} The requested modules
     */
    function getCachedModules(...moduleNames) {
        return moduleNames.map((name) => cachedModules[name]);
    }
    // Guard for webworkers w/o window access
    typeof window !== 'undefined' && (window[TEST_OBJ_NAME] = { getProxy, getCachedModules });

    exports.getCachedModules = getCachedModules;
    exports.getProxy = getProxy;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcore-base',['ojs/ojlogger', 'ojs/ojwebdrivertest-proxy'], function (Logger, ojwebdrivertestProxy) { 'use strict';

  /**
   * Defines the oj namespace
   */

  /**
   * @private
   */
  let _scope = {};

  //  - check if the window object is available
  // Note that the 'typeof' check  is required
  if (typeof window !== 'undefined') {
    _scope = window;
    // eslint-disable-next-line no-restricted-globals
  } else if (typeof self !== 'undefined') {
    // eslint-disable-next-line no-restricted-globals
    _scope = self;
  }

  /**
   * @private
   */
  var _oldVal = _scope.oj;

  // eslint-disable-next-line no-unused-vars
  const oj = {
    /**
     * @global
     * @member {string} version JET version numberr
     */
    version: '19.0.0',
    /**
     * @global
     * @member {string} revision JET source code revision number
     */
    revision: '2025-08-12_09-40-56',

    // This function is only meant to be used outside the library, so quoting the name
    // to avoid renaming is appropriate
    noConflict: function () {
      _scope.oj = _oldVal;
    },

    /**
     * Adds a property to the "oj" namespace. This is used by ES6 modules to set
     * legacy exported objects onto the import "oj" namespace, since modifying the
     * original imported object isn't allowed under ES6.
     * @param {string} name The property name, such as "PopupService"
     * @param {object} value The value to set for the property
     * @private
     */
    _registerLegacyNamespaceProp: function (name, value) {
      this[name] = value;
    }
  };

  _scope.oj = oj;

  /**
   * String utilities.
   * @class oj.StringUtils
   * @export
   * @ignore
   */
  const StringUtils = {};
  oj._registerLegacyNamespaceProp('StringUtils', StringUtils);

  StringUtils._TRIM_ALL_RE = /^\s*|\s*$/g;

  /**
   * Returns true if the value is null or if the trimmed value is of zero length.
   *
   * @param {Object|string|null} value
   * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
   * @export
   * @memberof oj.StringUtils
   */
  StringUtils.isEmpty = function (value) {
    if (value === null) {
      return true;
    }

    var trimValue = StringUtils.trim(value);

    return trimValue.length === 0;
  };

  /**
   * Returns true if the value is null, undefined or if the trimmed value is of zero length.
   *
   * @param {Object|string|null=} value
   * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
   * @export
   * @memberof oj.StringUtils
   */
  StringUtils.isEmptyOrUndefined = function (value) {
    if (value === undefined || StringUtils.isEmpty(value)) {
      return true;
    }

    return false;
  };

  /**
   * Test if an object is a string (either a string constant or a string object)
   * @param {Object|string|null} obj object to test
   * @return {boolean} true if a string constant or string object
   * @export
   * @memberof oj.StringUtils
   */
  StringUtils.isString = function (obj) {
    return obj !== null && (typeof obj === 'string' || obj instanceof String);
  };

  /**
   * Remove leading and trailing whitespace
   * @param {Object|string|null} data to trim
   * @return {Object|string|null}
   * @export
   * @memberof oj.StringUtils
   */
  StringUtils.trim = function (data) {
    if (StringUtils.isString(data)) {
      return data.replace(StringUtils._TRIM_ALL_RE, '');
    }

    return data;
  };

  /**
   * Port of the Java String.hashCode method.
   * http://erlycoder.com/49/javascript-hash-functions-to-convert-string-into-integer-hash-
   *
   * @param {string} str
   * @returns {number}
   * @public
   * @memberof oj.StringUtils
   */
  StringUtils.hashCode = function (str) {
    var hash = 0;
    if (str.length === 0) {
      return hash;
    }

    for (var i = 0; i < str.length; i++) {
      var c = str.charCodeAt(i);
      // eslint-disable-next-line no-bitwise
      hash = (hash << 5) - hash + c;
      // eslint-disable-next-line no-bitwise
      hash &= hash;
    }
    return hash;
  };

  /**
   * @ojtsignore
   * @class oj.AgentUtils
   * @classdesc Utilities for qualifying the user agent string.
   * @public
   * @ignore
   */
  const AgentUtils = function () {};
  oj._registerLegacyNamespaceProp('AgentUtils', AgentUtils);

  /**
   * Identity of the target browser.
   * @enum {string}
   * @public
   * @memberof oj.AgentUtils
   */
  AgentUtils.BROWSER = {
    IE: 'ie',
    FIREFOX: 'firefox',
    SAFARI: 'safari',
    CHROME: 'chrome',
    EDGE: 'edge',
    EDGE_CHROMIUM: 'edge-chromium',
    UNKNOWN: 'unknown'
  };
  /**
   * Browser layout engine identity.
   * @enum {string}
   * @public
   * @memberof oj.AgentUtils
   */
  AgentUtils.ENGINE = {
    TRIDENT: 'trident',
    WEBKIT: 'webkit',
    GECKO: 'gecko',
    BLINK: 'blink',
    EDGE_HTML: 'edgehtml',
    UNKNOWN: 'unknown'
  };
  /**
   * Operating system identity.
   * @enum {string}
   * @public
   * @memberof oj.AgentUtils
   */
  AgentUtils.OS = {
    WINDOWS: 'Windows',
    SOLARIS: 'Solaris',
    MAC: 'Mac',
    UNKNOWN: 'Unknown',
    ANDROID: 'Android',
    IOS: 'IOS',
    WINDOWSPHONE: 'WindowsPhone',
    LINUX: 'Linux'
  };
  /**
   * Device type identity.
   * @enum {string}
   * @public
   * @memberof oj.AgentUtils
   */
  AgentUtils.DEVICETYPE = {
    PHONE: 'phone',
    TABLET: 'tablet',
    OTHERS: 'others'
  };

  /**
   * Parses the browser user agent string determining what browser and layout engine
   * is being used.
   *
   * @param {Object|null|string=} userAgent a specific agent string but defaults to navigator userAgent if not provided
   * @return {{os: oj.AgentUtils.OS, browser: oj.AgentUtils.BROWSER, browserVersion: number, deviceType: oj.AgentUtils.DEVICETYPE,
   *          engine: oj.AgentUtils.ENGINE, engineVersion: number, hashCode: number}}
   * @public
   * @memberof oj.AgentUtils
   */
  AgentUtils.getAgentInfo = function (userAgent) {
    if (StringUtils.isEmptyOrUndefined(userAgent)) {
      // eslint-disable-next-line no-param-reassign
      userAgent = navigator.userAgent;
    }
    // eslint-disable-next-line no-param-reassign
    userAgent = userAgent.toLowerCase();
    /** @type {number} */
    var hashCode = StringUtils.hashCode(userAgent);
    var currAgentInfo = AgentUtils._currAgentInfo;
    if (currAgentInfo && currAgentInfo.hashCode === hashCode) {
      return {
        os: currAgentInfo.os,
        browser: currAgentInfo.browser,
        browserVersion: currAgentInfo.browserVersion,
        deviceType: currAgentInfo.deviceType,
        engine: currAgentInfo.engine,
        engineVersion: currAgentInfo.engineVersion,
        hashCode: currAgentInfo.hashCode
      };
    }
    /** @type {oj.AgentUtils.OS} */
    var os = AgentUtils.OS.UNKNOWN;
    /** @type {oj.AgentUtils.BROWSER} */
    var browser = AgentUtils.BROWSER.UNKNOWN;
    /** @type {number} */
    var browserVersion = 0;
    /** @type {oj.AgentUtils.DEVICETYPE} */
    var deviceType = AgentUtils.DEVICETYPE.OTHERS;
    /** @type {oj.AgentUtils.ENGINE} */
    var engine = AgentUtils.ENGINE.UNKNOWN;
    /** @type {number} */
    var engineVersion = 0;
    if (
      userAgent.indexOf('iphone') > -1 ||
      userAgent.indexOf('ipad') > -1 ||
      // handle iPad/iPhone safari requesting desktop version of site
      (userAgent.indexOf('macintosh') > -1 && navigator.maxTouchPoints > 0)
    ) {
      os = AgentUtils.OS.IOS;
    } else if (userAgent.indexOf('macintosh') > -1) {
      os = AgentUtils.OS.MAC;
    } else if (userAgent.indexOf('sunos') > -1) {
      os = AgentUtils.OS.SOLARIS;
    } else if (userAgent.indexOf('android') > -1) {
      os = AgentUtils.OS.ANDROID;
    } else if (userAgent.indexOf('linux') > -1) {
      os = AgentUtils.OS.LINUX;
    } else if (userAgent.indexOf('windows phone') > -1) {
      os = AgentUtils.OS.WINDOWSPHONE;
    } else if (userAgent.indexOf('windows') > -1) {
      os = AgentUtils.OS.WINDOWS;
    }

    if (os === AgentUtils.OS.ANDROID) {
      // This works for Chrome, Firefox, and Edge on Android, even though only Chrome is officially supported.
      // This also works for Edge on Windows 10 Mobile, which announces itself as android-compatible user agent.
      deviceType =
        userAgent.indexOf('mobile') > -1 ? AgentUtils.DEVICETYPE.PHONE : AgentUtils.DEVICETYPE.TABLET;
    } else if (os === AgentUtils.OS.IOS) {
      // This works for Safari, Chrome, Firefox, and Edge on iOS, even though only Safari is officially supported.
      deviceType =
        userAgent.indexOf('iphone') > -1 ? AgentUtils.DEVICETYPE.PHONE : AgentUtils.DEVICETYPE.TABLET;
    }

    if (userAgent.indexOf('msie') > -1) {
      browser = AgentUtils.BROWSER.IE;
      browserVersion = AgentUtils._parseFloatVersion(userAgent, /msie (\d+[.]\d+)/);
      if (userAgent.indexOf('trident')) {
        engine = AgentUtils.ENGINE.TRIDENT;
        engineVersion = AgentUtils._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
      }
    } else if (userAgent.indexOf('trident') > -1) {
      browser = AgentUtils.BROWSER.IE;
      browserVersion = AgentUtils._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);
      if (userAgent.indexOf('trident')) {
        engine = AgentUtils.ENGINE.TRIDENT;
        engineVersion = AgentUtils._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
      }
    } else if (userAgent.indexOf('edge') > -1) {
      browser = AgentUtils.BROWSER.EDGE;
      engineVersion = AgentUtils._parseFloatVersion(userAgent, /edge\/(\d+[.]\d+)/);
      browserVersion = engineVersion;
      engine = AgentUtils.ENGINE.EDGE_HTML;
    } else if (userAgent.indexOf('edg') > -1) {
      browser = AgentUtils.BROWSER.EDGE_CHROMIUM;
      browserVersion = AgentUtils._parseFloatVersion(userAgent, /edg\/(\d+[.]\d+)/);
      engine = AgentUtils.ENGINE.BLINK;
      engineVersion = browserVersion;
    } else if (userAgent.indexOf('chrome') > -1) {
      browser = AgentUtils.BROWSER.CHROME;
      browserVersion = AgentUtils._parseFloatVersion(userAgent, /chrome\/(\d+[.]\d+)/);
      if (browserVersion >= 28) {
        engine = AgentUtils.ENGINE.BLINK;
        engineVersion = browserVersion;
      } else {
        engine = AgentUtils.ENGINE.WEBKIT;
        engineVersion = AgentUtils._parseFloatVersion(userAgent, /applewebkit\/(\d+[.]\d+)/);
      }
    } else if (userAgent.indexOf('safari') > -1) {
      browser = AgentUtils.BROWSER.SAFARI;
      browserVersion = AgentUtils._parseFloatVersion(userAgent, /version\/(\d+[.]\d+)/);
      engine = AgentUtils.ENGINE.WEBKIT;
      engineVersion = AgentUtils._parseFloatVersion(userAgent, /applewebkit\/(\d+[.]\d+)/);
    } else if (userAgent.indexOf('firefox') > -1) {
      browser = AgentUtils.BROWSER.FIREFOX;
      browserVersion = AgentUtils._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);
      engine = AgentUtils.ENGINE.GECKO;
      engineVersion = AgentUtils._parseFloatVersion(userAgent, /gecko\/(\d+)/);
    }

    currAgentInfo = {
      hashCode: hashCode,
      os: os,
      browser: browser,
      browserVersion: browserVersion,
      deviceType: deviceType,
      engine: engine,
      engineVersion: engineVersion
    };
    AgentUtils._currAgentInfo = currAgentInfo;

    return {
      os: currAgentInfo.os,
      browser: currAgentInfo.browser,
      browserVersion: currAgentInfo.browserVersion,
      deviceType: currAgentInfo.deviceType,
      engine: currAgentInfo.engine,
      engineVersion: currAgentInfo.engineVersion,
      hashCode: currAgentInfo.hashCode
    };
  };
  /**
   * @param {string!} userAgent
   * @param {RegExp!} versionNumberPattern
   * @return {number}
   * @private
   * @memberof oj.AgentUtils
   */
  AgentUtils._parseFloatVersion = function (userAgent, versionNumberPattern) {
    var matches = userAgent.match(versionNumberPattern);
    if (matches) {
      var versionString = matches[1];
      if (versionString) {
        return parseFloat(versionString);
      }
    }

    return 0;
  };

  /**
   * Assertion utilities.
   * The container is expected to have already initialized the oj.Assert Object before this
   * code is executed and initialized the oj.Assert.DEBUG flag/
   * @class
   * @export
   * @ignore
   */
  const Assert = {};
  oj._registerLegacyNamespaceProp('Assert', Assert);

  /**
   * @private
   */
  var _DEBUG = 'DEBUG';

  /**
   * @private
   */
  const _NO_PROTO = "' doesn't match prototype ";

  /**
   * Forces DEBUG to be set to true
   * @export
   * @memberof oj.Assert
   */
  Assert.forceDebug = function () {
    Assert[_DEBUG] = true;
  };

  /**
   * Forces DEBUG to be set to false
   * @export
   * @memberof oj.Assert
   */
  Assert.clearDebug = function () {
    Assert[_DEBUG] = false;
  };

  /**
   * Determines whether oj.Assert is running in debug mode
   * @return {boolean} true for debug mode, false otherwise
   * @export
   * @memberof oj.Assert
   */
  Assert.isDebug = function () {
    return Assert[_DEBUG] === true;
  };

  /**
   * Asserts that a condition is true.  If the condition does not
   * evaluate to true, an exception is thrown with the optional message
   * and reason
   * @param {boolean} condition condition to test
   * @param {string=} message message to display
   * @export
   * @memberof oj.Assert
   */
  Assert.assert = function (condition, message) {
    if (Assert[_DEBUG] && !condition) {
      var myMessage = message || '';

      if (arguments.length > 2) {
        myMessage += '(';
        for (var i = 2; i < arguments.length; i += 1) {
          myMessage += arguments[i];
        }
        myMessage += ')';
      }
      Assert.assertionFailed(myMessage, 1);
    }
  };

  /**
   * Convenience function for asserting when an abstact function is called
   * @export
   * @memberof oj.Assert
   */
  Assert.failedInAbstractFunction = function () {
    if (Assert[_DEBUG]) {
      Assert.assertionFailed('Abstract function called', 1);
    }
  };

  /**
   * Asserts that the the target object has the same prototype as the example
   * type
   * @param {Object} target description
   * @param {Function} theConstructor
   * @param {string=} reason
   * @export
   * @memberof oj.Assert
   */
  Assert.assertPrototype = function (target, theConstructor, reason) {
    if (Assert[_DEBUG]) {
      var thePrototype = theConstructor.prototype;

      if (target != null) {
        Assert.assertType(theConstructor, 'function', null, 1, false);

        var isPrototypeOf = Object.prototype.isPrototypeOf;
        if (!isPrototypeOf.call(thePrototype, target)) {
          Assert.assertionFailed("object '" + target + _NO_PROTO + thePrototype, 1, reason);
        }
      } else {
        Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
      }
    }
  };

  /**
   * Asserts that the the target object has the same prototype as the example
   * type or is null.
   * @export
   * @memberof oj.Assert
   */
  Assert.assertPrototypeOrNull = function (target, theConstructor, reason) {
    if (Assert[_DEBUG] && target != null) {
      Assert.assertType(theConstructor, 'function', null, 1, false);
      var thePrototype = theConstructor.prototype;

      var isPrototypeOf = Object.prototype.isPrototypeOf;
      if (!isPrototypeOf.call(thePrototype, target)) {
        Assert.assertionFailed("object '" + target + _NO_PROTO + thePrototype, 1, reason);
      }
    }
  };

  /**
   * Asserts that the the target object has the same prototype as the example
   * types
   * @export
   * @memberof oj.Assert
   */
  Assert.assertPrototypes = function (target, instanceOne, instanceTwo, reason) {
    if (Assert[_DEBUG]) {
      var thePrototype = instanceOne.prototype;
      var thePrototypeTwo = instanceTwo.prototype;

      var isPrototypeOf = Object.prototype.isPrototypeOf;
      if (
        !(isPrototypeOf.call(thePrototype, target) || isPrototypeOf.call(thePrototypeTwo, target))
      ) {
        Assert.assertionFailed(
          "object '" + target + _NO_PROTO + thePrototype + ' or ' + thePrototypeTwo,
          1,
          reason
        );
      }
    }
  };

  /**
   * Asserts that the target is a DOM Node or Null
   * @export
   * @memberof oj.Assert
   */
  Assert.assertDomNodeOrNull = function (target, depth) {
    if (Assert[_DEBUG] && target) {
      if (target.nodeType === undefined) {
        Assert.assertionFailed(target + ' is not a DOM Node', depth + 1);
      }
    }
  };

  /**
   * Asserts that the target is a DOM Node
   * @export
   * @memberof oj.Assert
   */
  Assert.assertDomNode = function (target, depth) {
    if (Assert[_DEBUG]) {
      if (!target || target.nodeType === undefined) {
        Assert.assertionFailed(target + ' is not a DOM Node', depth + 1);
      }
    }
  };

  /**
   * Asserts that the target is a DOM Element and optionally has the specified
   * element name
   * @param {Object} target target object
   * @param {string=} nodeName name of the element
   * @export
   * @memberof oj.Assert
   */
  Assert.assertDomElement = function (target, nodeName) {
    if (Assert[_DEBUG]) {
      Assert.assertDomNode(target, 1);

      if (target.nodeType !== 1) {
        Assert.assertionFailed(target + ' is not a DOM Element', 1);
      } else if (nodeName && target.nodeName !== nodeName) {
        Assert.assertionFailed(target + ' is not a ' + nodeName + ' Element', 1);
      }
    }
  };

  /**
   * Asserts that the target is a DOM Element and optionally has the specified
   * element name
   * @export
   * @memberof oj.Assert
   */
  Assert.assertDomElementOrNull = function (target, nodeName) {
    if (Assert[_DEBUG] && target != null) {
      Assert.assertDomNode(target, 1);

      if (target.nodeType !== 1) {
        Assert.assertionFailed(target + ' is not a DOM Element', 1);
      } else if (nodeName && target.nodeName !== nodeName) {
        Assert.assertionFailed(target + ' is not a ' + nodeName + ' Element', 1);
      }
    }
  };

  /**
   * Asserts that the target object has the typeof specified
   *
   * @param {Object|null|string|undefined} target
   * @param {string} type typeof type that statisfies this condition
   * @param {string|undefined|null} prefix
   * @param {number} depth stack depth to skip when printing stack traces
   * @param {boolean} nullOK true if a null value satisfies this condition
   * @export
   * @memberof oj.Assert
   */
  Assert.assertType = function (target, type, prefix, depth, nullOK) {
    if (Assert[_DEBUG]) {
      // either the target is null and null is OK, or the target better
      // be of the correct type
      var targetType = typeof target;
      if (!((target == null && nullOK) || targetType === type)) {
        var message = target + ' is not of type ' + type;

        if (prefix) {
          message = prefix + message;
        }

        if (!depth) {
          // eslint-disable-next-line no-param-reassign
          depth = 0;
        }

        Assert.assertionFailed(message, depth + 1);
      }
    }
  };

  /**
   * Asserts that the target is an Object
   * @param {Object} target description
   * @param {string=} prefix
   * @export
   * @memberof oj.Assert
   */
  Assert.assertObject = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'object', prefix, 1, false);
    }
  };

  /**
   * Asserts that the target is an Object or null
   * @param {Object} target description
   * @param {string=} prefix
   * @export
   * @memberof oj.Assert
   */
  Assert.assertObjectOrNull = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'object', prefix, 1, true);
    }
  };

  /**
   * Asserts that the target is a non-empty String
   * @export
   * @memberof oj.Assert
   */
  Assert.assertNonEmptyString = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'string', prefix, 1, false);
      Assert.assert(target.length > 0, 'empty string');
    }
  };

  /**
   * Asserts that the target is a String
   * @param target target object
   * @param {string=} prefix prefix string
   * @export
   * @memberof oj.Assert
   */
  Assert.assertString = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'string', prefix, 1, false);
    }
  };

  /**
   * Asserts that the target is a String or null
   * @param {string|null|undefined|Object} target target object
   * @param {string=} prefix prefix string
   * @export
   * @memberof oj.Assert
   */
  Assert.assertStringOrNull = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'string', prefix, 1, true);
    }
  };

  /**
   * Asserts that the target is a Function
   * @param {Object} target target object
   * @param {string=} prefix prefix string
   * @export
   * @memberof oj.Assert
   */
  Assert.assertFunction = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'function', prefix, 1, false);
    }
  };

  /**
   * Asserts that the target is a Function or null
   * @param {Object} target target object
   * @param {string=} prefix prefix
   * @export
   * @memberof oj.Assert
   */
  Assert.assertFunctionOrNull = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'function', prefix, 1, true);
    }
  };

  /**
   * Asserts that the target is a boolean
   * @param {Object} target description
   * @param {string=} prefix
   * @export
   * @memberof oj.Assert
   */
  Assert.assertBoolean = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'boolean', prefix, 1, false);
    }
  };

  /**
   * Asserts that the target is a number
   * @export
   * @memberof oj.Assert
   */
  Assert.assertNumber = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'number', prefix, 1, false);
    }
  };

  /**
   * Asserts that the target is a number or Null
   * @export
   * @memberof oj.Assert
   */
  Assert.assertNumberOrNull = function (target, prefix) {
    if (Assert[_DEBUG]) {
      Assert.assertType(target, 'number', prefix, 1, true);
    }
  };

  /**
   * Asserts that the target object is an Array
   * @param {Object} target target object
   * @param {string=} message optional message
   * @export
   * @memberof oj.Assert
   */
  Assert.assertArray = function (target, message) {
    if (Assert[_DEBUG]) {
      if (!Array.isArray(target)) {
        if (message === undefined) {
          // eslint-disable-next-line no-param-reassign
          message = target + ' is not an array';
        }

        Assert.assertionFailed(message, 1);
      }
    }
  };

  /**
   * Asserts that the target object is an Array or null
   * @param {Object} target target object
   * @param {string=} message optional message
   * @export
   * @memberof oj.Assert
   */
  Assert.assertArrayOrNull = function (target, message) {
    if (Assert[_DEBUG] && target != null) {
      if (!Array.isArray(target)) {
        if (message === undefined) {
          // eslint-disable-next-line no-param-reassign
          message = target + ' is not an array';
        }

        Assert.assertionFailed(message, 1);
      }
    }
  };

  /**
   * Asserts that the target object is not either a number, or convertible to a number
   * @param {Object} target target object
   * @param {string=} message optional message
   * @export
   * @memberof oj.Assert
   */
  Assert.assertNonNumeric = function (target, message) {
    if (Assert[_DEBUG]) {
      if (!isNaN(target)) {
        if (message === undefined) {
          // eslint-disable-next-line no-param-reassign
          message = target + ' is convertible to a number';
        }

        Assert.assertionFailed(message, 1);
      }
    }
  };

  /**
   * Asserts that the target object is either a number, or convertible to a number
   * @param {Object} target target object
   * @param {string=} message optional message
   * @export
   * @memberof oj.Assert
   */
  Assert.assertNumeric = function (target, message) {
    if (Assert[_DEBUG]) {
      if (isNaN(target)) {
        if (message === undefined) {
          // eslint-disable-next-line no-param-reassign
          message = target + ' is not convertible to a number';
        }

        Assert.assertionFailed(message, 1);
      }
    }
  };

  /**
   * Asserts that value String is in the Set
   * @param {Object} value value to check
   * @param {Object} set set to check
   * @param {string=} message optional message
   * @export
   * @memberof oj.Assert
   */
  Assert.assertInSet = function (value, set, message) {
    if (value == null || set[value.toString()] === undefined) {
      if (message === undefined) {
        var keyString = ' is not in set: {';

        var keys = Object.keys(set);
        for (var k = 0; k < keys.length; k++) {
          var key = keys[k];
          keyString += key;
          keyString += ',';
        }

        keyString += '}';

        // eslint-disable-next-line no-param-reassign
        message = value + keyString;
      }

      Assert.assertionFailed(message, 1);
    }
  };

  /**
   * Base assertion failure support that supports specifying the stack skipping
   * level
   * @param {string} message Message to display
   * @param {number} skipLevel assertion level
   * @param {string=} reason reason to display
   * @export
   * @memberof oj.Assert
   */
  Assert.assertionFailed = function (message, skipLevel, reason) {
    if (!skipLevel) {
      // eslint-disable-next-line no-param-reassign
      skipLevel = 0;
    }

    var errorMessage = 'Assertion';

    if (reason) {
      errorMessage += ' (' + reason + ')';
    }

    errorMessage += ' failed: ';

    if (message !== undefined) {
      errorMessage += message;
    }

    throw new Error(errorMessage);
  };

  /**
   * @private
   * @memberof oj.Assert
   */
  var _assertSetting = _scope.__oj_Assert_DEBUG;

  if (_assertSetting !== undefined) {
    Assert[_DEBUG] = _assertSetting;
  }

  /**
   * Log an error if IE11 is detected.
   */
  (function () {
    const agentInfo = AgentUtils.getAgentInfo();
    if (agentInfo.browser === AgentUtils.BROWSER.IE) {
      Logger.error('Internet Explorer is not supported with this version of JET.');
    }
  })();

  /**
   * Utilities for working with collections
   * @ignore
   */
  const CollectionUtils = {};
  oj._registerLegacyNamespaceProp('CollectionUtils', CollectionUtils);

  /**
   * Copies all of the properties of source into the target and returns the target
   *
   * @param {Object} target - target collection
   * @param {Object} source - source collection
   * @param {function(string)=} keyConverter a callback for converting the key
   * @param {boolean=} recurse - true if this method should recurse into plain Javascript object properties
   * @param {number=} maxRecursionDepth - the maximum depth of the recursion into plain Javascript object properties
   * @return target collection
   * @export
   * @memberof! oj.CollectionUtils
   */
  CollectionUtils.copyInto = function (target, source, keyConverter, recurse, maxRecursionDepth) {
    return CollectionUtils._copyIntoImpl(target, source, keyConverter, recurse, maxRecursionDepth, 0);
  };

  /**
   * A simpler alternative to copyInto()
   * @param {Object} target - target collection
   * @param Array{Object} - one or more sources to merge into the target
   * @ignore
   */
  CollectionUtils.mergeDeep = function (target, ...sources) {
    if (!sources.length) return target;
    const isPlain = CollectionUtils.isPlainObject;
    const merge = CollectionUtils.mergeDeep;
    const source = sources.shift();
    if (isPlain(target) && isPlain(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlain(source[key])) {
          if (!target[key]) Object.assign(target, { [key]: {} });
          merge(target[key], source[key]);
        } else {
          Object.assign(target, { [key]: source[key] });
        }
      });
    }
    return merge(target, ...sources);
  };

  /**
   * Checks whether the object is a direct instance of Object
   * @param {Object} obj - object to test
   *
   * @return {boolean} true if the object is a direct instance of Object, false otherwise
   * @export
   * @memberof! oj.CollectionUtils
   */
  CollectionUtils.isPlainObject = function (obj) {
    if (obj !== null && typeof obj === 'object') {
      try {
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        if (obj.constructor && hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return true;
        }
      } catch (e) {
        // Ignore errors
      }
    }

    return false;
  };

  /**
   * @private
   * @memberof! oj.CollectionUtils
   */
  CollectionUtils._copyIntoImpl = function (
    target,
    source,
    keyConverter,
    recurse,
    maxRecursionDepth,
    currentLevel
  ) {
    var targetKey;

    if (maxRecursionDepth === undefined || maxRecursionDepth === null) {
      // eslint-disable-next-line no-param-reassign
      maxRecursionDepth = Number.MAX_VALUE;
    }

    if (target && source && target !== source) {
      var keys = Object.keys(source);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        // allow the key mapping to be overridden
        if (keyConverter) {
          targetKey = keyConverter(k);
        } else {
          targetKey = k;
        }

        var sourceVal = source[k];

        var recursed = false;

        if (recurse && currentLevel < maxRecursionDepth) {
          var targetVal = target[targetKey];
          if (
            CollectionUtils.isPlainObject(sourceVal) &&
            (targetVal == null || CollectionUtils.isPlainObject(targetVal))
          ) {
            recursed = true;
            // eslint-disable-next-line no-param-reassign
            target[targetKey] = targetVal || {};
            CollectionUtils._copyIntoImpl(
              target[targetKey],
              sourceVal,
              keyConverter,
              true,
              maxRecursionDepth,
              currentLevel + 1
            );
          }
        }
        if (!recursed) {
          // eslint-disable-next-line no-param-reassign
          target[targetKey] = sourceVal;
        }
      }
    }

    return target;
  };

  /**
   * NOTE: When adding a new polyfill, please include a description of what the
   * polyfill is for, the source and any copyright info, along with the browsers
   * it is needed for.
   */

  (function () {
    if (typeof window === 'undefined') {
      return;
    }
    // polyfill for Element.closest()
    if (window.Element && !Element.prototype.closest) {
      Element.prototype.closest = function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s);
        var i;
        var el = this;

        do {
          // eslint-disable-line no-cond-assign
          i = matches.length;
          while (--i >= 0 && matches.item(i) !== el) {} // eslint-disable-line no-plusplus, no-empty
        } while (i < 0 && (el = el.parentElement)); // eslint-disable-line no-cond-assign
        return el;
      };
    }
  })();

  (function () {
    // Polyfill for addEventListener & removeEventListener in browsers
    // that do not support an options object. The polyfilled methods accept
    // an options object, extract the capture option and pass it on as useCapture

    /**
     * Detect if options object is supported by checking if
     * browser looks for passive option. Code taken from
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * under "Safely detecting option support"
     * @ignore
     * @return {boolean} true if option object is supported,
     * false otherwise
     */
    function browserSupportsOptionObject() {
      let supportsOptionsObject = false;
      try {
        var opts = Object.defineProperty({}, 'passive', {
          get: function () {
            supportsOptionsObject = true;
            return supportsOptionsObject;
          }
        });
        window.addEventListener('testPassive', null, opts);
        window.removeEventListener('testPassive', null, opts);
        // eslint-disable-next-line no-empty
      } catch (e) {}
      return supportsOptionsObject;
    }

    /**
     * If option is object, extract capture and pass on
     * as useCapture. Otherwise simply pass on useCapture
     * @ignore
     * @param {Object|boolean} option option object or useCapture
     * @return {boolean} value for useCapture
     */
    function getCaptureOption(option) {
      if (typeof option === 'boolean') {
        return option;
      }
      return option ? option.capture : false;
    }

    /**
     * Helper for creating polyfilled addEventListener
     * or removeEventListener
     * @ignore
     * @param {Function} native addEventlister or
     * removeEventListener
     * @return {Function} polyfilled addEventListenr or
     * removeEventListener that accepts either options
     * object or useCapture.
     */
    function polyfill(native) {
      /**
       * @ignore
       * @param {string} event
       * @param {Function} handler
       * @param {Object|boolean} option options object or useCapture
       */
      return function (event, handler, option) {
        return native.call(this, event, handler, getCaptureOption(option));
      };
    }
    if (typeof window !== 'undefined' && !browserSupportsOptionObject()) {
      let nativePrototype;
      if (window.EventTarget) {
        // modern browsers define addEventListener and
        // removeEventListener on EventTarget
        nativePrototype = EventTarget.prototype;
      } else if (window.Node) {
        // IE defines addEventListener and removeEventListener
        // on Node
        nativePrototype = Node.prototype;
      }
      if (nativePrototype) {
        nativePrototype.addEventListener = polyfill(nativePrototype.addEventListener);
        nativePrototype.removeEventListener = polyfill(nativePrototype.removeEventListener);
      }
    }
  })();

  (function () {
    /**
     * @license
     * Code taken from
     * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask
     * under "When queueMicrotask() isn't available".
     * @ignore
     */
    if (typeof window !== 'undefined' && typeof window.queueMicrotask !== 'function') {
      // check for window being undefined for WebWorker cases
      window.queueMicrotask = function (callback) {
        Promise.resolve()
          .then(callback)
          .catch(function (e) {
            setTimeout(function () {
              throw e;
            });
          });
      };
    }
  })();

  /* The custom element (webcomponents) support requires the native CustomEvent
   * object.  This polyfill provides CustomEvent implementation for browsers that
   * don't support it yet.
   */
  (function () {
    if (typeof window === 'undefined') {
      return;
    }

    // defaultPrevented is broken in IE.
    // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called
    var workingDefaultPrevented = (function () {
      var e = document.createEvent('Event');
      e.initEvent('foo', true, true);
      e.preventDefault();
      return e.defaultPrevented;
    })();

    if (!workingDefaultPrevented) {
      var origPreventDefault = Event.prototype.preventDefault;
      Event.prototype.preventDefault = function () {
        if (!this.cancelable) {
          return;
        }

        origPreventDefault.call(this);

        Object.defineProperty(this, 'defaultPrevented', {
          get: function () {
            return true;
          },
          configurable: true
        });
      };
    }

    if (typeof window.CustomEvent === 'function') {
      return;
    }

    function CustomEvent(event, params) {
      // eslint-disable-next-line no-param-reassign
      params = params || { bubbles: false, cancelable: false, detail: undefined };

      var evt = document.createEvent('CustomEvent');

      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = Object.getPrototypeOf(new CustomEvent('bogusEvent'));

    window.CustomEvent = CustomEvent;
  })();

  /**
   * Polyfill FocusEvent constructor for IE.
   */
  (function () {
    if (typeof window === 'undefined' || typeof window.FocusEvent === 'function') {
      return;
    }

    // Note that since we can only use initEvent, we don't have a way to
    // polyfill the optional param to specify a relatedTarget for the FocusEvent.
    function FocusEvent(type) {
      var evt = document.createEvent('FocusEvent');
      evt.initEvent(type, false, false);
      return evt;
    }

    FocusEvent.prototype = Object.getPrototypeOf(new FocusEvent('focus'));
    window.FocusEvent = FocusEvent;
  })();

  /* This polyfill implements a proposed Microsoft standard [1] for effective yielding.
   * With the setImmediate global function, developers can yield control flow to the
   * user agent before running script.  The yield is similar to the setTimeout function
   * in that it is evaluated in the macrotask queue.  However, the setTimeout often has
   * a minimum delay and is also subject to long delays when the browser is placed in the
   * background.  The setImmediate function implemented by this polyfill invokes the
   * callback in the "next-tick" after the current macrotask queue has been exhausted.
   *
   * [1] https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
   *
   * The strategy for the polyfill implementation uses the window.postMessage API for
   * creating a context for calling the target function evaulated as a macrotask. This
   * plugin will not work in a webworker where the window object doesn't exist.
   */
  (function () {
    if (typeof window === 'undefined' || window.setImmediate || !window.postMessage) {
      return;
    }

    var _setImmediateMap;

    var _setImmediateCounter;
    function _nextId() {
      if (isNaN(_setImmediateCounter)) {
        _setImmediateCounter = 0;
      }

      _setImmediateCounter += 1;
      return _setImmediateCounter;
    }

    // postMessage "message" event listener for the setImmediate impl
    function _nextTickHandler(event) {
      var data = event.data;
      if (!data || data.message !== 'oj-setImmediate') {
        return;
      }

      var id = data.id;
      var entry = _setImmediateMap.get(id);
      clearImmediateImpl(id);

      if (entry) {
        var callback = entry.callback;
        var args = entry.args;
        callback.apply(window, args);
      }
    }

    function setImmediateImpl() {
      var callback = arguments[0];
      var slice = Array.prototype.slice;
      var args = slice.call(arguments, 1);

      Assert.assertFunction(callback);

      var id = _nextId();

      if (!_setImmediateMap) {
        _setImmediateMap = new Map();
      }

      _setImmediateMap.set(id, { callback: callback, args: args });

      if (_setImmediateMap.size === 1) {
        window.addEventListener('message', _nextTickHandler);
      }

      window.postMessage({ id: id, message: 'oj-setImmediate' }, '*');
      return id;
    }

    function clearImmediateImpl(id) {
      if (!_setImmediateMap) {
        return;
      }

      _setImmediateMap.delete(id);

      if (_setImmediateMap.size < 1) {
        window.removeEventListener('message', _nextTickHandler);
        _setImmediateMap = null;
      }
    }

    window.setImmediate = setImmediateImpl;
    window.clearImmediate = clearImmediateImpl;
  })();

  (function () {
    if (typeof window === 'undefined') {
      return;
    }
    if (window.Symbol) {
      if (!window.Symbol.asyncIterator) {
        window.Symbol.asyncIterator = 'asyncIterator';
      }

      if (!window.Symbol.iterator) {
        window.Symbol.iterator = 'iterator';
      }
    } else {
      window.Symbol = {};
      window.Symbol.asyncIterator = 'asyncIterator';
      window.Symbol.iterator = 'iterator';
    }
  })();

  (function () {
    if (typeof window === 'undefined') {
      return;
    }

    if (new window.Set([0]).size === 0) {
      var NativeSet = window.Set;
      // eslint-disable-next-line no-inner-declarations
      function Set(iterable) {
        var set = new NativeSet();
        if (iterable) {
          iterable.forEach(set.add, set);
        }
        return set;
      }
      Set.prototype = NativeSet.prototype;
      // eslint-disable-next-line no-extend-native
      Set.prototype.constructor = Set;
      window.Set = Set;
    }
  })();

  (function () {
    if (typeof window === 'undefined') {
      return;
    }

    // IE11 supports Array.forEach
    if (window.NodeList && !NodeList.prototype.forEach) {
      NodeList.prototype.forEach = Array.prototype.forEach;
    }

    if (window.DOMTokenList && !DOMTokenList.prototype.forEach) {
      DOMTokenList.prototype.forEach = Array.prototype.forEach;
    }
  })();

  /**
   * Node.isConnected polyfill for IE and EdgeHTML
   * 2020-02-04
   * By Eli Grey, https://eligrey.com
   * Public domain.
   * From: https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected
   */
  (function () {
    if (typeof window === 'undefined' || window.Node === 'undefined') {
      return;
    }

    if (!('isConnected' in Node.prototype)) {
      Object.defineProperty(Node.prototype, 'isConnected', {
        get() {
          return (
            !this.ownerDocument ||
            // eslint-disable-next-line no-bitwise
            !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED)
          );
        }
      });
    }
  })();

  /**
   * Base class of all OJET Objects.
   * <p>
   * To create a subclass of another oj.Object, use oj.Object.createSubclass.
   * The subclass can specify class-level initialization by implementing an
   * <code>InitClass()</code> method on its constructor.  <code>InitClass</code>
   * is guaranteed to be called only once per class.  Further, a class'
   * <code>InitClass</code> method is guranteed to be called only after its
   * superclass' class initialization has been called.  When <code>InitClass</code>
   * is called, <code>this</code> is the class' constructor.  This allows class
   * initialization implementations to be shared in some cases.
   * </p>
   */

  /**
   * @constructor oj.Object
   * @final
   * @ojtsignore
   * @since 1.0
   * @export
   */
  const OjObject = function () {
    this.Init();
  };
  oj._registerLegacyNamespaceProp('Object', OjObject);

  OjObject.superclass = null;

  /**
   * @private
   */
  OjObject._typeName = 'oj.Object';

  // regular expressicloneon for stripping out the name of a function
  /**
   * @private
   */
  OjObject._GET_FUNCTION_NAME_REGEXP = /function\s+([\w$][\w$\d]*)\s*\(/;

  OjObject.prototype = {};
  OjObject.prototype.constructor = OjObject;

  /**
   * Creates a subclass of a baseClass
   * @method createSubclass
   * @memberof oj.Object
   * @param {Object} extendingClass The class to extend from the base class
   * @param {Object} baseClass class to make the superclass of extendingClass
   * @param {string=} typeName to use for new class.  If not specified, the typeName will be extracted from the
   * baseClass's function if possible
   * @return {void}
   * @export
   */
  OjObject.createSubclass = function (extendingClass, baseClass, typeName) {
    // optional name to name this class
    Assert.assertFunction(extendingClass);
    Assert.assertFunctionOrNull(baseClass);
    Assert.assertStringOrNull(typeName);

    if (baseClass === undefined) {
      // assume oj.Object
      // eslint-disable-next-line no-param-reassign
      baseClass = OjObject;
    }

    Assert.assert(extendingClass !== baseClass, "Class can't extend itself");

    // use a temporary constructor to get our superclass as our prototype
    // without out having to initialize the superclass
    /**
     * @private
     * @constructor
     */
    var TempConstructor = OjObject._tempSubclassConstructor;

    TempConstructor.prototype = baseClass.prototype;
    // eslint-disable-next-line no-param-reassign
    extendingClass.prototype = new TempConstructor();

    // eslint-disable-next-line no-param-reassign
    extendingClass.prototype.constructor = extendingClass;
    // eslint-disable-next-line no-param-reassign
    extendingClass.superclass = baseClass.prototype;

    if (typeName) {
      // eslint-disable-next-line no-param-reassign
      extendingClass._typeName = typeName;
    }
  };

  /**
   * Copies properties from the source object to the prototype of the target class
   * Only properties 'owned' by the source object will be copied, i.e. the properties
   * from the source object's prototype chain will not be included.
   * To copy properties from another class with methods defined on the prototype, pass
   * otherClass.prototype as the source.
   * @method copyPropertiesForClass
   * @memberof oj.Object
   * @param {Object} targetClass - the function whose prototype will be used a
   * copy target
   * @param {Object} source - object whose properties will be copied
   * @return {void}
   * @export
   */
  OjObject.copyPropertiesForClass = function (targetClass, source) {
    Assert.assertFunction(targetClass);
    Assert.assert(source != null, 'source object cannot be null');

    var props = Object.keys(source);
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      // eslint-disable-next-line no-param-reassign
      targetClass.prototype[prop] = source[prop];
    }
  };

  /**
   * @private
   */
  OjObject._tempSubclassConstructor = function () {};

  /**
   * Returns the class object for the instance
   * @method getClass
   * @memberof oj.Object
   * @instance
   * @param {Object=} otherInstance - if specified, the instance whose type
   * should be returned. Otherwise the type of this instance will be returned
   * @return {Object} the class object for the instance
   * @final
   * @export
   */
  OjObject.prototype.getClass = function (otherInstance) {
    if (otherInstance === undefined) {
      // eslint-disable-next-line no-param-reassign
      otherInstance = this;
    } else if (otherInstance === null) {
      return null;
    }
    return otherInstance.constructor;
  };

  /**
   * Returns a clone of this object.  The default implementation is a shallow
   * copy.  Subclassers can override this method to implement a deep copy.
   * @method clone
   * @memberof oj.Object
   * @instance
   * @return {Object} a clone of this object
   * @export
   */
  OjObject.prototype.clone = function () {
    var clone = new this.constructor();

    CollectionUtils.copyInto(clone, this);

    return clone;
  };

  /**
   * @export
   * @method toString
   * @memberof oj.Object
   * @instance
   * @return {string}
   */
  OjObject.prototype.toString = function () {
    return this.toDebugString();
  };

  /**
   * @export
   * @method toDebugString
   * @memberof oj.Object
   * @instance
   * @return {string}
   */
  OjObject.prototype.toDebugString = function () {
    return this.getTypeName() + ' Object';
  };

  /**
   * Returns the type name for a class derived from oj.Object
   * @method getTypeName
   * @memberof oj.Object
   * @instance
   * @param {Object|null} clazz Class to get the name of
   * @return {string} name of the Class
   * @export
   */
  OjObject.getTypeName = function (clazz) {
    Assert.assertFunction(clazz);

    var typeName = clazz._typeName;

    if (typeName == null) {
      var constructorText = clazz.toString();
      var matches = OjObject._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

      if (matches) {
        typeName = matches[1];
      } else {
        typeName = 'anonymous';
      }

      // cache the result on the function
      // eslint-disable-next-line no-param-reassign
      clazz._typeName = typeName;
    }

    return typeName;
  };

  /**
   * Returns the type name for this instance
   * @method getTypeName
   * @memberof oj.Object
   * @return {string} name of the Class
   * @final
   * @export
   */
  OjObject.prototype.getTypeName = function () {
    return OjObject.getTypeName(this.constructor);
  };

  /**
   * Initializes the instance.  Subclasses of oj.Object must call
   * their superclass' Init
   * @export
   * @method Init
   * @return {void}
   * @memberof oj.Object
   * @instance
   */
  OjObject.prototype.Init = function () {
    if (Assert.isDebug()) {
      Assert.assert(this.getTypeName, 'Not an oj.Object');
    }

    // do any class initialization.  This code is duplicated from
    // oj.Object.ensureClassInitialization()

    var currClass = this.constructor;
    if (!currClass._initialized) {
      OjObject._initClasses(currClass);
    }
  };

  /**
   * Ensures that a class is initialized.  Although class initialization occurs
   * by default the first time that an instance of a class is created, classes that
   * use static factory methods to create their instances may
   * still need to ensure that their class has been initialized when the factory
   * method is called.
   *
   * @method ensureClassInitialization
   * @memberof oj.Object
   * @param {Object} clazz The class to ensure initialization of
   * @return {void}
   * @export
   */
  OjObject.ensureClassInitialization = function (clazz) {
    Assert.assertFunction(clazz);

    if (!clazz._initialized) {
      OjObject._initClasses(clazz);
    }
  };

  /**
   * Indicates whether some other oj.Object is "equal to" this one.
   * Method is equivalent to java ".equals()" method.
   * @method equals
   * @memberof oj.Object
   * @instance
   * @param {Object} object - comparison target
   * @return {boolean} true if if the comparison target is equal to this object, false otherwise
   * @export
   */
  OjObject.prototype.equals = function (object) {
    return this === object;
  };

  /**
   * Binds the supplied callback function to an object
   * @method createCallback
   * @memberof oj.Object
   * @param {!OjObject} obj - object that will be available to the supplied callback
   * function as 'this'
   * @param {!OjObject} func - the original callback
   * @return {function()} a function that will be invoking the original callback with
   * 'this' object assigned to obj
   * @ojsignature {target: "Type", for: "returns", value: "()=>any"}
   * @export
   */
  OjObject.createCallback = function (obj, func) {
    Assert.assertFunction(func);

    // All browsers supported by JET support bind() method
    return func.bind(obj);
  };

  /**
   * @private
   */
  OjObject._initClasses = function (currClass) {
    if (Assert.isDebug()) {
      Assert.assertFunction(currClass);
      Assert.assert(!currClass._initialized);
    }

    // eslint-disable-next-line no-param-reassign
    currClass._initialized = true;

    var superclass = currClass.superclass;

    // initialize the superclass if necessary
    if (superclass) {
      var superclassConstructor = superclass.constructor;

      if (superclassConstructor && !superclassConstructor._initialized) {
        OjObject._initClasses(superclassConstructor);
      }
    }

    // if the class has an initialization function, call it
    var InitClassFunc = currClass.InitClass;

    if (InitClassFunc) {
      InitClassFunc.call(currClass);
    }
  };

  /**
   * Compares 2 values using strict equality except for the case of
   * <ol>
   *   <li> Array [order matters]; will traverse through the arrays and compare oj.Object.compareValues(array[i], array2[i]) </li>
   *   <li> Instances that support valueOf [i.e. Boolean, String, Number, Date, and etc] will be compared by usage of that function </li>
   * </ol>
   * @param {any} obj1 The first value to compare.
   * @param {any} obj2 The second value to compare.
   * @return {boolean}
   * @public
   * @export
   * @method compareValues
   * @memberof oj.Object
   */
  OjObject.compareValues = function (obj1, obj2) {
    if (obj1 === obj2) {
      return true;
    }

    var obj1Type = typeof obj1;
    var obj2Type = typeof obj2;

    if (obj1Type !== obj2Type) {
      // of different type so consider them unequal
      return false;
    }

    // At this point means the types are equal

    // note that if the operand is an array or a null then typeof is an object
    // check if either is null and if so return false [i.e. case where one might be a null and another an object]
    // and one wishes to avoid the null pointer in the following checks. Note that null === null has been already tested
    if (obj1 === null || obj2 === null) {
      return false;
    }

    // Wrap compare into try/catch to support custom data types. See JET-52967.
    try {
      // now check for constructor since I think by here one has ruled out primitive values and if the constructors
      // aren't equal then return false
      if (obj1.constructor === obj2.constructor) {
        // these are special cases and will need to be modded on a need to have basis
        if (Array.isArray(obj1)) {
          return OjObject._compareArrayValues(obj1, obj2);
        } else if (obj1.constructor === Object) {
          // create new Set for cyclic detection. This may also be passed in from
          // __innerEquals
          const set = arguments[2] || new Set();
          // for now invoke innerEquals and in the future if there are issues then resolve them
          return OjObject.__innerEquals(obj1, obj2, set);
        } else if (obj1.valueOf && typeof obj1.valueOf === 'function') {
          // test cases for Boolean, String, Number, Date
          // Note if some future JavaScript constructors
          // do not impl it then it's their fault
          return obj1.valueOf() === obj2.valueOf();
        }
      }
    } catch (e) {
      Logger.log('Object.compareValues() exception', e);
    }

    return false;
  };

  OjObject._compareArrayValues = function (array1, array2) {
    if (array1.length !== array2.length) {
      return false;
    }

    for (var i = 0, j = array1.length; i < j; i++) {
      // recurse on each of the values, order does matter for our case since do not wish to search
      // for the value [expensive]
      if (!OjObject.compareValues(array1[i], array2[i])) {
        return false;
      }
    }
    return true;
  };

  // Comparion of two Objects containing id and or index properties.
  // Note: it returns false if one is an id and other is an index
  // if ids are the same, index will be ignored if there is only one is provided
  OjObject._compareIdIndexObject = function (obj1, obj2) {
    if (
      (typeof obj1 === 'number' && typeof obj2 === 'number') ||
      (typeof obj1 === 'string' && typeof obj2 === 'string')
    ) {
      return obj1 === obj2;
    }

    if (typeof obj1 === 'object' && typeof obj2 === 'object') {
      if (obj1.id && obj2.id) {
        if (obj1.id !== obj2.id) {
          return false;
        }

        if (obj1.index && obj2.index) {
          return obj1.index === obj2.index;
        }

        return true;
      } else if (obj1.index && obj2.index) {
        return obj1.index === obj2.index;
      }
    }

    return false;
  };

  // Comparion of two arrays containing ids, indexes, or objects where each object has id,
  // index or both properties.
  // order needn't be same but no duplicates
  OjObject._compareArrayIdIndexObject = function (array1, array2) {
    // null and [] are equals
    if (!array1) {
      return !array2 || array2.length === 0;
    }

    if (!array2) {
      return !array1 || array1.length === 0;
    }

    if (array1.length !== array2.length) {
      return false;
    }

    for (var i = 0; i < array1.length; i++) {
      var found = false;
      for (var j = 0; j < array2.length; j++) {
        if (OjObject._compareIdIndexObject(array1[i], array2[j])) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }

    return true;
  };

  OjObject.__innerEquals = function (obj1, obj2, set = new Set()) {
    if (obj1 === obj2) {
      return true;
    }

    // Catch cyclic comparisons
    if (set.has(obj1) || set.has(obj2)) {
      Logger.warn('cyclic dependency detected', obj1, obj2);
      return false;
    }
    set.add(obj1);
    set.add(obj2);

    if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
      return false;
    }

    if (obj1.constructor !== obj2.constructor) {
      return false;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var props1 = Object.keys(obj1);
    var prop;
    var i;

    for (i = 0; i < props1.length; i++) {
      prop = props1[i];

      if (hasOwnProperty.call(obj1, prop)) {
        if (!hasOwnProperty.call(obj2, prop)) {
          return false;
        }

        if (obj1[prop] !== obj2[prop]) {
          if (typeof obj1[prop] !== 'object') {
            return false;
          }

          if (!OjObject.compareValues(obj1[prop], obj2[prop], set)) {
            return false;
          }
        }
      }
    }

    var props2 = Object.keys(obj2);
    for (i = 0; i < props2.length; i++) {
      prop = props2[i];

      if (hasOwnProperty.call(obj2, prop) && !hasOwnProperty.call(obj1, prop)) {
        return false;
      }
    }

    if (props1.length === 0 && props2.length === 0) {
      // we are dealing with objects that have no properties like Number or Date.
      return JSON.stringify(obj1) === JSON.stringify(obj2);
    }

    return true;
  };

  /**
   * @method isEmpty
   * @return {boolean}
   * @memberof oj.Object
   */
  OjObject.isEmpty = function (object) {
    var prop;
    // Test if an object is empty
    if (object === undefined || object === null) {
      return true;
    }

    // eslint-disable-next-line no-restricted-syntax
    for (prop in object) {
      // eslint-disable-next-line no-prototype-builtins
      if (object.hasOwnProperty(prop)) {
        return false;
      }
    }
    return true;
  };

  /**
   * @export
   * @class EventSource
   * @classdesc Object which supports subscribing to and firing events
   * @constructor
   * @final
   * @since 1.1
   * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
   */
  const EventSource = function () {
    this.Init();
  };

  // Subclass from oj.Object
  OjObject.createSubclass(EventSource, OjObject, 'oj.EventSource');
  oj._registerLegacyNamespaceProp('EventSource', EventSource);

  /**
   * Initializes the instance.
   * @export
   */
  EventSource.prototype.Init = function () {
    this._eventHandlers = [];
    EventSource.superclass.Init.call(this);
  };

  /**
   * Attach an event handler.
   * <p>Application can call this if it wants to be notified of an event.  It can call the <code class="prettyprint">off</code> method to detach the handler when it no longer wants to be notified.</p>
   * @param {string} eventType eventType
   * @param {function(Object)} eventHandler event handler function
   * @return {void}
   * @memberof EventSource
   * @export
   */
  EventSource.prototype.on = function (eventType, eventHandler) {
    var foundEventHandler = false;

    for (var i = 0; i < this._eventHandlers.length; i++) {
      if (
        this._eventHandlers[i].eventType === eventType &&
        this._eventHandlers[i].eventHandlerFunc === eventHandler
      ) {
        foundEventHandler = true;
        break;
      }
    }
    if (!foundEventHandler) {
      this._eventHandlers.push({ eventType: eventType, eventHandlerFunc: eventHandler });
    }
  };

  /**
   * Detach an event handler.
   * <p>Application can call this if it no longer wants to be notified of an event that it has attached an handler to using the <code class="prettyprint">on</code> method.</p>
   * @param {string} eventType eventType
   * @param {function(Object)} eventHandler event handler function
   * @return {void}
   * @memberof EventSource
   * @export
   */
  EventSource.prototype.off = function (eventType, eventHandler) {
    for (var i = this._eventHandlers.length - 1; i >= 0; i--) {
      if (
        this._eventHandlers[i].eventType === eventType &&
        this._eventHandlers[i].eventHandlerFunc === eventHandler
      ) {
        this._eventHandlers.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Handle the event
   * @param {string} eventType  event type
   * @param {Object} event  event
   * @return {boolean} Returns false if event is cancelled
   * @memberof EventSource
   * @export
   */
  // eslint-disable-next-line no-unused-vars
  EventSource.prototype.handleEvent = function (eventType, event) {
    var returnValue;

    for (var i = 0; i < this._eventHandlers.length; i++) {
      var eventHandler = this._eventHandlers[i];
      if (eventHandler.eventType === eventType) {
        returnValue = eventHandler.eventHandlerFunc.apply(
          this,
          Array.prototype.slice.call(arguments).slice(1)
        );

        if (returnValue === false) {
          // event cancelled
          return false;
        }
      }
    }

    return true;
  };

  /**
   * Key utilities.
   * @class oj.KeyUtils
   * @export
   * @ignore
   */
  const KeyUtils = {};
  oj._registerLegacyNamespaceProp('KeyUtils', KeyUtils);

  /**
   * Determine whether the two keys specified are considered equal.
   *
   * @param {any} key1 first key to compare
   * @param {any} key2 second key to compare
   * @returns {boolean} true if the keys are considered the same, false otherwise.
   * @export
   * @memberof oj.KeyUtils
   */
  KeyUtils.equals = function (key1, key2) {
    // algorithm for key equality:
    // if the keys are of type primitive, then do === comparison
    // if the keys are object, then do deep comparison of properties
    // for now, this is the same as compareValues, but this allows us to diverge in the future
    // ex: generate hash with key and compare hash value instead
    return OjObject.compareValues(key1, key2);
  };

  /**
   * @private
   */
  var _checkpointManagerDelegate = _scope.__ojCheckpointManager;

  /**
   * Global Checkpoint Manager Instance
   * @const
   * @export
   * @ignore
   */
  const CHECKPOINT_MANAGER = {};
  oj._registerLegacyNamespaceProp('CHECKPOINT_MANAGER', CHECKPOINT_MANAGER);

  /**
   * Starts a checkpoint
   * @param {!string} name - the name of the checkpoint
   * @param {string=} description - optional description of the checkpoint
   * @export
   * @memberof! oj.CHECKPOINT_MANAGER
   */
  CHECKPOINT_MANAGER.startCheckpoint = function (name, description) {
    if (_checkpointManagerDelegate) {
      _checkpointManagerDelegate.startCheckpoint(name, description);
    }
  };

  /**
   * Ends a checkpoint
   * @param {!string} name - the name of the checkpoint
   * @export
   * @memberof! oj.CHECKPOINT_MANAGER
   */
  CHECKPOINT_MANAGER.endCheckpoint = function (name) {
    if (_checkpointManagerDelegate) {
      _checkpointManagerDelegate.endCheckpoint(name);
    }
  };

  /**
   * Retrieves a checkpoint record for a given name
   * @param {!string} name - the name of the checkpoint
   * @return {undefined|{start: number, end: number, duration: number, name: {string}, description: (string|undefined)}}
   * @export
   * @memberof! oj.CHECKPOINT_MANAGER
   */
  CHECKPOINT_MANAGER.getRecord = function (name) {
    return _checkpointManagerDelegate ? _checkpointManagerDelegate.getRecord(name) : undefined;
  };

  /**
   * Retrieves all checkpoint records matching a regular expression
   * @param {!RegExp} regexp - regular expression to match.
   * @return Array.{{start: number, end: number, duration: number, name: {string}, description: (string|undefined)}}
   * @export
   * @memberof! oj.CHECKPOINT_MANAGER
   */
  CHECKPOINT_MANAGER.matchRecords = function (regexp) {
    return _checkpointManagerDelegate ? _checkpointManagerDelegate.matchRecords(regexp) : [];
  };

  /**
   * Dumps matched records into oj.Logger
   * @param {!RegExp} regexp - regular expression for the records to dump.
   * @export
   * @memberof! oj.CHECKPOINT_MANAGER
   */
  CHECKPOINT_MANAGER.dump = function (regexp) {
    Logger.info(function () {
      var logMsg = 'Checkpoint Records:';
      var records = CHECKPOINT_MANAGER.matchRecords(regexp);
      for (var i = 0; i < records.length; i++) {
        var record = records[i];
        logMsg = logMsg + '\n' + record.name;
        var desc = record.description;
        if (desc != null) {
          logMsg = logMsg + ' (' + desc + ')';
        }
        logMsg += ':\n';
        logMsg = logMsg + 'start: ' + record.start + '\tduration: ' + record.duration;
      }
      return logMsg;
    });
  };

  return oj;

});


define('ojs/ojcustomelement-registry',['exports'], function (exports) { 'use strict';

    const _CUSTOM_ELEMENT_REGISTRY = {};
    /**
     * Registers a custom element within the JET custom element registry.
     * The register is case insensitive when performing lookups.
     * This method does not register a custom element with the browser's customElements
     * API and should not be called directly by a JET component. Returns true
     * if the element is successfully registered.
     * @param tagName
     * @param regObj
     * @ignore
     */
    function registerElement(tagName, regObj, constructor) {
        const tagNameUpper = tagName.toUpperCase();
        if (!_CUSTOM_ELEMENT_REGISTRY[tagNameUpper]) {
            if (!regObj.descriptor) {
                throw new Error(`Custom element ${tagName} must be registered with a descriptor.`);
            }
            // Register custom element under passed in tag name and an all upper version
            // so we can avoid a toUpperCase() call for each registry lookup.
            _CUSTOM_ELEMENT_REGISTRY[tagName] = regObj;
            _CUSTOM_ELEMENT_REGISTRY[tagNameUpper] = regObj;
            Object.defineProperty(constructor, 'name', {
                value: tagNameToElementClassName(tagName)
            });
            customElements.define(tagName, constructor);
        }
    }
    /**
     * Converts a custom element tag name to the name used for the
     * element type and class name, e.g. oj-some-component -> SomeComponentElement
     * @param tagName
     * @ignore
     */
    function tagNameToElementClassName(tagName) {
        return (tagName
            .toLowerCase()
            .match(/-(?<match>.*)/)[0]
            .replace(/-(.)/g, (match, group1) => group1.toUpperCase()) + 'Element');
    }
    /**
     * Returns true if the given tag name is registered as a Composite component
     * within the case insensitive JET custom element registry.
     * @param tagName
     * @ignore
     */
    function isComposite(tagName) {
        return getElementRegistration(tagName)?.composite ?? false;
    }
    /**
     * Returns true if the given tag name is registered as a VComponent
     * within the case insensitive JET custom element registry.
     * @param tagName
     * @ignore
     */
    function isVComponent(tagName) {
        return getElementRegistration(tagName)?.vcomp ?? false;
    }
    /**
     * Returns true if a given tag name is registered within the case insensitive
     * JET custom element registry.
     * @param tagName
     * @ignore
     */
    function isElementRegistered(tagName) {
        return _CUSTOM_ELEMENT_REGISTRY[tagName] != null;
    }
    /**
     * Returns the registration object for a tag name within the case insensitive
     * JET custom element registry or null if not found.
     * @param tagName
     * @ignore
     */
    function getElementRegistration(tagName) {
        return _CUSTOM_ELEMENT_REGISTRY[tagName] ?? null;
    }
    /**
     * Returns the descriptor for a given tag name within the case insensitive
     * JET custom element registry
     * or an empty object if not found.
     * @param tagName
     * @ignore
     */
    function getElementDescriptor(tagName) {
        return getElementRegistration(tagName)?.descriptor || {};
    }
    /**
     * Returns the component properties for a given element
     * JET custom element registry
     * or an empty object if not found.
     * @param element
     * @ignore
     */
    function getElementProperties(element) {
        return getPropertiesForElementTag(element.tagName);
    }
    /**
     * Returns the component metadata for a given uppercase tag name within the case insensitive
     * JET custom element registry or an empty object if not found.
     * @param tagName uppercase tag name
     * @ignore
     */
    function getMetadata(tagName) {
        // Composites add event listener metadata and store in _metadata so check there first
        const descriptor = getElementDescriptor(tagName);
        return descriptor['_metadata'] ?? descriptor.metadata ?? {};
    }
    /**
     * Returns the component properties for a given the uppercase tag name within the case insensitive
     * JET custom element registry
     * or an empty object if not found.
     * @param tagName uppercase tag name
     * @ignore
     */
    function getPropertiesForElementTag(tagName) {
        return getMetadata(tagName).properties ?? {};
    }

    exports.getElementDescriptor = getElementDescriptor;
    exports.getElementProperties = getElementProperties;
    exports.getElementRegistration = getElementRegistration;
    exports.getMetadata = getMetadata;
    exports.getPropertiesForElementTag = getPropertiesForElementTag;
    exports.isComposite = isComposite;
    exports.isElementRegistered = isElementRegistered;
    exports.isVComponent = isVComponent;
    exports.registerElement = registerElement;
    exports.tagNameToElementClassName = tagNameToElementClassName;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcontext',['ojs/ojcore-base', 'ojs/ojlogger', 'ojs/ojcustomelement-registry'], function (oj, Logger, ojcustomelementRegistry) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * Internally used by the {@link oj.BusyContext} to track a components state
   * while it is performing a task such as animation or fetching data.
   *
   * @hideconstructor
   * @ignore
   * @protected
   * @constructor
   * @param {Function|Object|undefined} description of the component and cause
   *        of the busy state
   */
  const BusyState = function (description, stack) {
    /**
     * @ignore
     * @private
     * @type {?}
     */
    this._description = description;

    /**
     * @ignore
     * @private
     * @type {string}
     */
    this._stack = stack;

    /**
     * @ignore
     * @private
     * @type {number}
     */
    this._addedWaitTs = BusyState._getTs();

    /**
     * @ignore
     * @private
     * @type {string}
     */
    this._id = this._addedWaitTs.toString(36) + '_' + Math.random().toString(36); // @RandomNumberOK -
    // random number concatinated to the current timestamp is used for a unique id for a local Map
    // key. This random number is not used use as a cryptography key.
  };

  oj._registerLegacyNamespaceProp('BusyState', BusyState);

  Object.defineProperties(BusyState.prototype, {
    /**
     * Identifies the usage instance of a busy state.
     * @memberof oj.BusyState
     * @instance
     * @property {!string} id
     */
    id: {
      get: function () {
        return this._id;
      },
      enumerable: true
    },
    /**
     * Further definition of the busy state instance.
     * @memberof oj.BusyState
     * @instance
     * @property {?string} description
     */
    description: {
      get: function () {
        if (this._description) {
          if (this._description instanceof Function) {
            return this._description();
          }
          return this._description.toString();
        }
        return undefined;
      },
      enumerable: true
    },
    /**
     * The stack trace that added the BusyState. See {@link oj.BusyContext} to enable
     * capturing.
     * @memberof oj.BusyState
     * @instance
     * @property {?string} stack
     */
    stack: {
      get: function () {
        if (this._stack) {
          return this._stack;
        }
        return undefined;
      },
      enumerable: true
    }
  });

  /**
   * @override
   * @returns {string} returns the value of the object as a string
   */
  BusyState.prototype.toString = function () {
    var buff = 'Busy state: [description=';

    var description = this.description;

    if (description !== null) {
      buff += description;
    }
    if (this.stack) {
      buff += `\n${this.stack}`;
    }

    var elapsed = BusyState._getTs() - this._addedWaitTs;
    buff += ', elapsed=' + elapsed + ']';

    return buff;
  };

  /**
   * @private
   * @returns {number} current date represented by a number
   */
  BusyState._getTs = function () {
    // Safari V9.1.1 doesn't yet support performance.now
    return window.performance ? window.performance.now() : new Date().getTime();
  };

  /**
   * <p>The purpose of the BusyContext API is to accommodate sequential dependencies of asynchronous
   * operations. A common use cases defining the API is for automation testing (qunit and webdriver).
   * Automation test developers can use this API to wait until components finish animation effects
   * or data fetch before trying to interact with components. The BusyContext is not limited to
   * test automation developers usages. It is also needed by page developers for waiting on run-time
   * operation readiness.</p>
   *
   * The Busy Context API will wait until busy states have resolved or a timeout period has elapsed.
   * There are several primary wait scenarios:
   * <ol>
   *   <li>Component creation and page bindings applied.</li>
   *   <li>Components that implement animation effects.</li>
   *   <li>Components that must fetch data from a REST endpoint.</li>
   *   <li>General wait conditions that are not specific to the Jet framework. The customer might
   *       choose to register some busy condition associated with application domain logic such
   *       as REST endpoints.</li>
   *   <li>Wait until the bootstrap of the page has completed - jet libraries loaded via requireJS.</li>
   * </ol>
   *
   * <p>The first step for waiting on a busy context is to determine what conditions are of interest
   *   to wait on. The granularity of a busy context can be scoped for the entirety of the page or
   *   for a specific DOM element. Busy contexts have hierarchical dependencies mirroring the
   *   document's DOM structure with the root being the page context. Depending on the particular
   *   scenario, developers might need to target one of the following busy context scopes:</p>
   * <ul>
   *   <li>Scoped for the Page - Automation test developers will more commonly choose the page busy
   *     context. This context represents the page as a whole. Automation developers commonly need
   *     to wait until the page is fully loaded before starting automation. More commonly, automation
   *     developers are interesting in testing the functionality of an application having multiple
   *     JET components versus just a single component.
   *
   *     <pre class="prettyprint">
   *     <code>
   *     var busyContext = Context.getPageContext().getBusyContext();
   *     </code></pre>
   *
   *   </li>
   *   <li>Scoped for the nearest DOM Element - Application developers sometime need a mechanism to
   *     wait until a specific component operation has complete. For example, it might be desirable
   *     to wait until a component has been created and bindings applied before setting a property or
   *     calling a method on the component. Another scenario, waiting for a popup to finish
   *     open or close animation before initiating the next action in their application flow.
   *     For this problem space developers would need to obtain a busy context scoped for a DOM node.
   *     The "data-oj-context" marker attribute is used to define a busy context for a dom subtree.
   *
   *     <pre class="prettyprint">
   *     <code>
   *     <!-- subtree assigned a marker 'data-oj-context' attribute -->
   *     &lt;div id="mycontext" data-oj-context&gt;
   *        ...
   *        &lt;!-- JET content --&gt;
   *        ...
   *     &lt;/div&gt;
   *
   *     var node = document.querySelector("#mycontext");
   *     var busyContext = Context.getContext(node).getBusyContext();
   *     busyContext.whenReady().then(function ()
   *     {
   *       var component = document.querySelector("#myInput");
   *       component.value = "foo";
   *       component.validate().then(function (isValid)
   *       {
   *         if (!isValid)
   *           component.value = "foobar";
   *       });
   *     });
   *     </code></pre>
   *
   *   </li>
   * </ul>
   *
   * The BusyContext API utilizes {@link oj.Logger.LEVEL_LOG} to log detail busy state activity.
   * <pre class="prettyprint">
   * <code>
   *  Logger.option("level", Logger.LEVEL_LOG);
   * </code></pre>
   *
   * <b>This constructor should never be invoked by the application code directly.</b>
   * @hideconstructor
   * @param {Element=} hostNode DOM element associated with this busy context
   * @param {Context} context The oj.Context instance
   * @export
   * @constructor oj.BusyContext
   * @ojtsmodule
   * @ojtsnoexport
   * @ojtsexportastype Context
   * @since 2.1.0
   * @classdesc Framework service for querying the busy state of components on the page.
   * <h3> Session storage usage : </h3>
   * <pre class="prettyprint">
   * <code>
   * // enable BusyContext tracing of BusyState creation
   * sessionStorage.setItem('ojet.busyContextTracing', 'on');
   * </code></pre>
   *
   * <p>Setting this key in sessionStorage will cause BusyStates to be created with an
   * additional `stack` property containing the call stack at the time of creation.
   * </p>
   */
  const BusyContext = function (hostNode, context) {
    this.Init(hostNode, context);
  };

  oj.Object.createSubclass(BusyContext, oj.Object, 'oj.BusyContext');
  oj._registerLegacyNamespaceProp('BusyContext', BusyContext);

  /**
   * see oj.BusyContext#setDefaultTimeout
   * @type {number}
   * @ignore
   * @private
   */
  BusyContext._defaultTimeout = Number.NaN;

  /**
   * Used for debounce and requestAnimationFrame promises for Preact
   * @ignore
   * @private
   */
  BusyContext.__preactPromisesMap = new Map();

  /**
   * Sets a default for the optional <code>timeout</code> argument of the {@link oj.BusyContext#whenReady}
   * for all BusyContext instances. The default value will be implicitly used if a timeout argument is not
   * provided.
   *
   * @export
   * @see oj.BusyContext#whenReady
   * @since 3.1.0
   * @memberof oj.BusyContext
   * @method setDefaultTimeout
   * @param {number} timeout in milliseconds
   * @ojdeprecated {since: '6.0.0', description: 'Use oj.Context.setBusyContextDefaultTimeout instead.'}
   * @return {undefined}
   */
  BusyContext.setDefaultTimeout = function (timeout) {
    if (!isNaN(timeout)) {
      BusyContext._defaultTimeout = timeout;
    }
  };

  let _nextTickPromise;
  /**
   * @private
   * @ignore
   * @return {Promise} resolves on the next-tick using setImmediate.
   */
  function getNextTickPromise() {
    if (!_nextTickPromise) {
      _nextTickPromise = new Promise(function (resolve) {
        window.setImmediate(function () {
          _nextTickPromise = null;
          resolve(true);
        });
      });
    }

    return _nextTickPromise;
  }

  /**
   * @param {Element=} hostNode DOM element associated with this busy context
   * @param {Context=} context The oj.Context object
   * @instance
   * @protected
   */
  BusyContext.prototype.Init = function (hostNode, context) {
    BusyContext.superclass.Init.call(this);

    this._hostNode = hostNode;
    this._context = context;

    /**
     * Busy states cache.
     *
     * @type {?}
     * @ignore
     * @private
     */
    this._statesMap = new Map();

    /**
     * The set of pending Preact Promises - debounce or requestAnimationFrame - that already have a busy state associated with them.
     *
     * @ignore
     * @private
     */
    this._preactSet = new Set();

    /**
     * Coordinates resolution of the master when ready promise with one or more slave
     * when ready promises having a timeout period.
     *
     * @type {Object}
     * @ignore
     * @private
     */
    this._mediator = {
      /**
       * Returns a master primise that will resolve when all busy states have been resolved.
       *
       * @returns {Promise}
       * @ignore
       * @private
       */
      getMasterWhenReadyPromise: function () {
        if (!this._masterWhenReadyPromise) {
          this._masterWhenReadyPromise = new Promise(
            this._captureWhenReadyPromiseResolver.bind(this)
          );
        }
        return this._masterWhenReadyPromise;
      },
      /**
       * Triggers resolution of the master promise and clears all timeouts associated with slave
       * when ready promises.
       *
       * @returns {void}
       * @ignore
       * @private
       */
      resolveMasterWhenReadyPromise: function () {
        if (this._masterWhenReadyPromiseResolver) {
          this._masterWhenReadyPromiseResolver(true);
        }
        this._masterWhenReadyPromise = null;
        this._masterWhenReadyPromiseResolver = null;
        this._masterWhenReadyPromiseRejecter = null;
      },
      /**
       * Triggers rejections of the master promise.
       * @param {Object=} error
       * @returns {void}
       * @ignore
       * @private
       */
      rejectMasterWhenReadyPromise: function (error) {
        if (this._masterWhenReadyPromiseRejecter) {
          this._masterWhenReadyPromiseRejecter(error);
        }
        this._masterWhenReadyPromise = null;
        this._masterWhenReadyPromiseRejecter = null;
        this._masterWhenReadyPromiseResolver = null;
      },
      /**
       * Returns a promise that will resolve when the master promise resolves or reject when
       * the slave timeout promise rejects.
       *
       * @param {Promise} master
       * @param {Function} generateErrorCallback
       * @param {number} timeout
       * @returns {Promise}
       * @ignore
       * @private
       */
      getSlaveTimeoutPromise: function (master, generateErrorCallback, timeout) {
        var timer;
        var slaveTimeoutPromise = new Promise(function (resolve, reject) {
          timer = window.setTimeout(function () {
            reject(generateErrorCallback());
          }, timeout);
        });
        this._slaveTimeoutPromiseTimers.push(timer);

        // When the master promise is completed, all timers may be cleared
        // Note that we have to add the 'catch' block to avoid unhandled promise rejections.
        // The master promise is still used in the race() call below, so the app will be able to handle
        // any possible rejection there
        master.catch(() => {}).finally(() => this._clearAllSlaveTimeouts());

        return Promise.race([master, slaveTimeoutPromise]);
      },

      /**
       * Clears all window timeout timeers that are slave when ready promises.
       *
       * @returns {boolean}
       * @ignore
       * @private
       */
      _clearAllSlaveTimeouts: function () {
        var slaveTimeoutPromiseTimers = this._slaveTimeoutPromiseTimers;
        this._slaveTimeoutPromiseTimers = [];
        for (var i = 0; i < slaveTimeoutPromiseTimers.length; i++) {
          window.clearTimeout(slaveTimeoutPromiseTimers[i]);
        }

        return true;
      },
      /**
       * Promise executor function passed as the single master promise constructor.  Captures the
       * promise resolve callback function.  The resolve promise function will be called when all the
       * busy states have been removed.
       *
       * @param {Function} resolve
       * @param {Function} reject
       * @returns {void}
       * @ignore
       * @private
       */
      // eslint-disable-next-line no-unused-vars
      _captureWhenReadyPromiseResolver: function (resolve, reject) {
        this._masterWhenReadyPromiseResolver = resolve;
        this._masterWhenReadyPromiseRejecter = reject;
      },
      /**
       * Array of setTimeout timers that should be cancled when the busy state resolves.
       *
       * @type {Array.<number>}
       * @ignore
       * @private
       */
      _slaveTimeoutPromiseTimers: []
      /**
       * The master when ready promise that will resovle when all busy states resolve.
       *
       * @type {Promise|undefined}
       * @ignore
       * @private
       */
      // _masterWhenReadyPromise : undefined,
      /**
       * The resolve function of the masterWhenReadyPromise.
       *
       * @type {Function|undefined}
       * @ignore
       * @private
       */
      // _masterWhenReadyPromiseResolver : undefined,
      /**
       * The reject function of the masterWhenReadyPromise.
       *
       * @type {Function|undefined}
       * @ignore
       * @private
       */
      // _masterWhenReadyPromiseRejecter : undefined,
      /**
       * Promise evaluated next-tick.
       *
       * @type {Promise|undefined}
       * @ignore
       * @private
       */
      // _nextTickPromise : undefined
    };
  };

  /**
   * Logs the current registered busy states ordered acceding by the order they were added.
   * The cost of compiling the list is only made if the logger level is Logger.LEVEL_LOG.
   * @param {?} statesMap busy states
   * @returns {void}
   * @private
   */
  BusyContext._log = function (statesMap) {
    if (Logger.option('level') !== Logger.LEVEL_LOG) {
      return;
    }

    Logger.log('>> Busy states: %d', statesMap.size);

    var busyStates = BusyContext._values(statesMap);
    if (busyStates.length > 0) {
      Logger.log(busyStates.join('\n'));
    }
  };

  /**
   * @param {?} statesMap busy states
   * @return {Array.<oj.BusyState>} Returns an array of busy states entries from the states map
   * @private
   */
  BusyContext._values = function (statesMap) {
    var busyStates = [];
    statesMap.forEach(function (value) {
      busyStates.push(value);
    });

    return busyStates;
  };

  class BusyStateTrace extends Error {
    constructor(message) {
      super(message);
      this.name = 'BusyStateTrace';
    }
  }

  /**
   * <p>Called by components or services performing a task that should be considered
   * in the overall busy state of the page. An example would be animation or fetching data.</p>
   *
   * Caveats:
   * <ul>
   *   <li>Busy context dependency relationships are determined at the point the first busy state
   *       is added.  If the DOM node is re-parented after a busy context was added, the context will
   *       maintain dependencies with any parent DOM contexts.</li>
   *   <li>The application logic creating busy states is responsible for ensuring these busy states
   *       are resolved. Busy states added internally by JET are automatically accounted for.
   *       The busy states added by the application logic must manage a reference to the resolve
   *       function associated with a busy state and it must be called to release the busy state.</li>
   * </ul>
   *
   * <pre class="prettyprint">
   * <code>// apply the marker attribute to the element
   * &lt;div id="context1" data-oj-context ... &gt;&lt;/&gt;
   * ...
   * ...
   * var context1 = document.querySelector("#context1");
   *
   * // obtain a busy context scoped for the target node
   * var busyContext1 = Context.getContext(context1).getBusyContext();
   * // add a busy state to the target context
   * var options = {"description": "#context1 fetching data"};
   * var resolve = busyContext1.addBusyState(options);
   * ...
   * ...  // perform asynchronous operation that needs guarded by a busy state
   * ...
   * // resolve the busy state after the operation completes
   * resolve();
   * </code></pre>
   *
   * @since 2.1.0
   * @export
   * @memberof oj.BusyContext
   * @instance
   * @method addBusyState
   * @param {Object} options object that describes the busy state being registered.<br/>
   * @param {Object|function():string} options.description
   *         description: Option additional information of what is registering a busy state. Added to
   *                      logging and handling rejected status. Can be supplied as a Object or a
   *                      function.  If the type is an object the toString function needs to be
   *                      implemented.
   * @ojsignature [{target: "Type",
   *                value: "{
   *                         toString: ()=>string;
   *                         [propName: string]: any;
   *                       } | (() => string) | string",
   *                for: "options.description"}]
   * @returns {function():void} resolve function called by the registrant when the busy state completes.
   *                     The resultant function will throw an error if the busy state is no longer
   *                     registered.
   */
  BusyContext.prototype.addBusyState = function (options) {
    Logger.log("BusyContext.addBusyState: start scope='%s'", this._getDebugScope());

    const storageKey = 'ojet.busyContextTracing';
    let stack;
    if (window?.sessionStorage?.getItem(storageKey) === 'on') {
      try {
        throw new BusyStateTrace('');
      } catch (ex) {
        stack = ex.stack;
      }
    }

    /** @type {oj.BusyState} */
    var busyState = new BusyState(options[BusyContext._DESCRIPTION], stack);

    Logger.log('>> ' + busyState);

    this._statesMap.set(busyState.id, busyState);

    this._addBusyStateToParent();

    Logger.log("BusyContext.addBusyState: end scope='%s'", this._getDebugScope());

    return this._removeBusyState.bind(this, busyState);
  };

  /**
   * Logs all active busy states to the {@link oj.Logger} at {Logger.LEVEL_INFO}.
   * <pre class="prettyprint">
   * <code>
   *  Logger.option("level", Logger.LEVEL_INFO);
   *  Context.getPageContext().getBusyContext().dump("before popup open");
   * </code></pre>
   *
   * @export
   * @since 3.1.0
   * @memberof oj.BusyContext
   * @instance
   * @method dump
   * @param {string=} message optional text used to further denote a debugging point
   * @return {undefined}
   */
  BusyContext.prototype.dump = function (message) {
    Logger.info("BusyContext.dump: start scope='%s' %s", this._getDebugScope(), message || '');

    var statesMap = this._statesMap;
    Logger.info('>> Busy states: %d', statesMap.size);

    var busyStates = BusyContext._values(statesMap);
    if (busyStates.length > 0) {
      Logger.info(busyStates.join('\n'));
    }

    Logger.info("BusyContext.dump: start scope='%s' %s", this._getDebugScope(), message || '');
  };

  /**
   * Returns an array of states representing the active busy states managed by the instance.
   *
   * @export
   * @since 3.1.0
   * @method getBusyStates
   * @memberof oj.BusyContext
   * @instance
   * @return {Array.<{id:string, description:string}>} active busy states managed by the context
   *         instance
   */
  BusyContext.prototype.getBusyStates = function () {
    /** @type {?} */
    return BusyContext._values(this._statesMap);
  };

  /**
   * Forces all busy states per context instance to release.
   * Use with discretion - last course of action.
   *
   * @since 3.1.0
   * @method clear
   * @memberof oj.BusyContext
   * @instance
   * @export
   * @return {undefined}
   */
  BusyContext.prototype.clear = function () {
    Logger.log("BusyContext.clear: start scope='%s'", this._getDebugScope());

    var busyStates = BusyContext._values(this._statesMap);
    for (var i = 0; i < busyStates.length; i++) {
      /** @type {?} **/
      var busyState = busyStates[i];
      try {
        this._removeBusyState(busyState);
      } catch (e) {
        Logger.log('BusyContext.clear: %o', e);
      }

      Object.defineProperty(busyState, BusyContext._OJ_RIP, { value: true, enumerable: false });
    }

    Logger.log("BusyContext.clear: end scope='%s'", this._getDebugScope());
  };

  /**
   * <p>Returns a Promise that will resolve when all registered busy states have completed or a maximum
   * timeout period has elapsed. The promise will be rejected if all the busy states are not resolved
   * within the timeout period. The busyness of the whenReady promsie is evaluated in the next-tick
   * of resolving a busy state.</p>
   *
   * "next-tick" is at the macrotask level. "whenReady" is waiting for the microtask queue to be exhausted,
   * yielding control flow to the user agent, before resolving busyness.
   *
   * @see oj.BusyContext#applicationBootstrapComplete
   * @since 2.1.0
   * @export
   * @memberof oj.BusyContext
   * @instance
   * @method whenReady
   * @param {number=} timeout "optional" maximum period in milliseconds the resultant promise
   *        will wait. Also see {@link oj.BusyContext.setDefaultTimeout}.
   * @returns {Promise.<boolean|Error>}
   */
  BusyContext.prototype.whenReady = function (timeout) {
    var debugScope = this._getDebugScope();

    Logger.log("BusyContext.whenReady: start, scope='%s', timeout=%d", debugScope, timeout);
    /** @type {?} */
    var statesMap = this._statesMap;

    var mediator = this._mediator;
    var bootstrapPromise = BusyContext._BOOTSTRAP_MEDIATOR.whenReady();
    const master = mediator.getMasterWhenReadyPromise();
    var promise = bootstrapPromise.then(
      function () {
        Logger.log('BusyContext.whenReady: bootstrap mediator ready scope=%s', debugScope);

        this._evalBusyness();

        Logger.log('BusyContext.whenReady: busy states returning master scope=%s', debugScope);
        return master;
      }.bind(this)
    );

    // if a timeout argument is not provided, check the default timeout
    if (isNaN(timeout) && !isNaN(BusyContext._defaultTimeout)) {
      // eslint-disable-next-line no-param-reassign
      timeout = BusyContext._defaultTimeout;
    }

    if (!isNaN(timeout)) {
      var handleTimeout = function () {
        var error;
        var expiredText = 'whenReady timeout of ' + timeout + 'ms expired ';

        BusyContext._log(statesMap);
        var busyStates = BusyContext._values(statesMap);

        if (!BusyContext._BOOTSTRAP_MEDIATOR.isReady()) {
          error = new Error(
            expiredText +
              'while the application is loading.' +
              ' Busy state enabled by setting the "window.oj_whenReady = true;" global variable.' +
              ' Application bootstrap busy state is released by calling' +
              ' "oj.Context.getPageContext().getBusyContext().applicationBootstrapComplete();".'
          );
        } else {
          error = new Error(expiredText + 'with the following busy states: ' + busyStates.join(', '));
        }

        error.busyStates = busyStates;

        Logger.log("BusyContext.whenReady: rejected scope='%s'\n%s", debugScope, error.message);
        return error;
      };
      promise = mediator.getSlaveTimeoutPromise(promise, handleTimeout, timeout);
    }

    Logger.log("BusyContext.whenReady: end scope='%s'", this._getDebugScope());
    return promise;
  };

  /**
   * <p>Describes the busyness of the context. The busyness is evaluated in the "next-tick" of a busy
   * state being resolved, meaning the number of busy states doesn't necessarily equate to readiness.
   * The readiness is in sync with the {@link oj.BusyContext#whenReady} resultant promise resolution.</p>
   *
   * @see oj.BusyContext#getBusyStates
   * @since 2.1.0
   * @export
   * @memberof oj.BusyContext
   * @instance
   * @method isReady
   * @returns {boolean} <code>true</code> if the context is not busy
   */
  BusyContext.prototype.isReady = function () {
    Logger.log("BusyContext.isReady: start scope='%s'", this._getDebugScope());
    var rtn = false;

    if (BusyContext._BOOTSTRAP_MEDIATOR.isReady() && !this._doubleCheckPend) {
      rtn = this._hasNoBusyStates();
      BusyContext._log(this._statesMap);
    }

    Logger.log("BusyContext.isReady: end scope='%s'", this._getDebugScope());
    return rtn;
  };

  /**
   * @private
   * @param {oj.BusyState} busyState added busy state
   * @returns {void}
   * @throws {Error} Busy state has already been resolved
   */
  BusyContext.prototype._removeBusyState = function (busyState) {
    var debugScope = this._getDebugScope();

    Logger.log("BusyContext._removeBusyState: start scope='%s'", debugScope);

    // The BusyState object is passed here instead of just the generated id to provide a more
    // descriptive message when the busy state is removed twice. The description (if provided) of
    // the busy state will be captured in the error message.

    if (busyState[BusyContext._OJ_RIP]) {
      Logger.log('Busy state has been forcefully resolved via clear:\n' + busyState);
      return;
    } else if (!this._statesMap.delete(busyState.id)) {
      throw new Error('Busy state has already been resolved:\n' + busyState);
    }

    Logger.log('BusyContext._removeBusyState: resolving busy state:\n' + busyState);

    this._evalBusyness();

    Logger.log("BusyContext._removeBusyState: end scope='%s'", debugScope);
  };

  /**
   * Checks busyness
   * @ignore
   * @private
   */

  BusyContext.prototype._evalBusyness = function () {
    var debugScope = this._getDebugScope();
    Logger.log("BusyContext._evalBusyness: begin scope='%s'", debugScope);

    if (this._hasNoBusyStates() && !this._doubleCheckPend) {
      Logger.log(
        "BusyContext._evalBusyness: macrotask to double-check busyness, scope='%s'",
        debugScope
      );
      this._doubleCheckPend = true;
      getNextTickPromise().then(this._doubleCheckBusyness.bind(this));
    }

    Logger.log("BusyContext._evalBusyness: end scope='%s'", debugScope);
  };

  /**
   * @ignore
   * @private
   */
  BusyContext.prototype._hasNoBusyStates = function () {
    this._syncDebounceBusyness();
    return this._statesMap.size === 0;
  };

  /**
   * @ignore
   * @private
   */
  BusyContext.prototype._syncDebounceBusyness = function () {
    const preactPromises = BusyContext.__preactPromisesMap;
    preactPromises.forEach((promiseDesc, preactPromise) => {
      // Add a busy state for Preact Promise (debounce or RAF). Note that we are using a Set
      // to add just one busy state for a particuar Promise instance
      if (preactPromise && !this._preactSet.has(preactPromise)) {
        this._preactSet.add(preactPromise);
        const resolver = this.addBusyState({ description: promiseDesc });
        preactPromise.then(() => {
          this._preactSet.delete(preactPromise);
          resolver();
        });
      }
    });
  };

  /**
   * Deouble-checks that there is stil no busyness after a macrotask.
   * @private
   */
  BusyContext.prototype._doubleCheckBusyness = function () {
    var debugScope = this._getDebugScope();

    Logger.log("BusyContext._doubleCheckBusyness: begin scope='%s'", debugScope);

    try {
      // Since we are executing this code on 'next tick', it is safe to flush any JET throttled updates.
      // Doing so will allow us to take into account any busy states added in response to the pending updates
      BusyContext._deliverThrottledUpdates();
    } catch (e) {
      Logger.error('Fatal exception delivering binding updates: %o', e);
      this._doubleCheckPend = false;
      this._rejectWhenReadyPromises(e);
      return;
    }

    // "appears" the Edge promise invokes the resolve callback immediately after
    // resolving versus waiting next micro tick.  Toggle the flag here so if
    // isReady() is called from the promise resolve callback, it returns true.
    this._doubleCheckPend = false;

    if (this._hasNoBusyStates()) {
      Logger.log('BusyContext._doubleCheckBusyness: resolving whenReady promises');

      this._mediator.resolveMasterWhenReadyPromise();
      this._resolveBusyStateForParent();
    } else {
      BusyContext._log(this._statesMap);
    }

    Logger.log("BusyContext._doubleCheckBusyness: end scope='%s'", debugScope);
  };

  /**
   * <p>This function should be invoke by application domain logic to indicate all application
   * libraries are loaded and bootstrap processes complete.  The assumed strategy is that the
   * application will set a single global variable "oj_whenReady" from its "main.js"
   * script, indicating that the {@link oj.BusyContext#whenReady}
   * should {@link oj.BusyContext#addBusyState} until the application determines its bootstrap
   * sequence has completed.</p>
   *
   * main.js Script Example:
   * <pre class="prettyprint">
   * main.js:
   * <code>
   *     // The "oj_whenReady" global variable enables a strategy that the busy context whenReady,
   *     // will implicitly add a busy state, until the application calls applicationBootstrapComplete
   *     // on the busy state context.
   *     window["oj_whenReady"] = true;
   * ...
   * ...
   * </code></pre>
   *
   * Requirejs callback Example:
   * <pre class="prettyprint">
   * <code>
   * require(['knockout', 'jquery', 'app', 'ojs/ojcontext', 'ojs/ojknockout', 'ojs/ojselectcombobox' ...],
   *   function(ko, $, app, Context)
   *   {
   *     // release the application bootstrap busy state
   *     Context.getPageContext().getBusyContext().applicationBootstrapComplete();
   *     ...
   *     ...
   *   });
   * </code></pre>
   *
   * @since 3.2.0
   * @export
   * @memberof oj.BusyContext
   * @instance
   * @method applicationBootstrapComplete
   * @returns {undefined}
   */
  BusyContext.prototype.applicationBootstrapComplete = function () {
    var debugScope = this._getDebugScope();
    Logger.log("BusyContext.applicationBootstrapComplete: begin scope='%s'", debugScope);

    BusyContext._BOOTSTRAP_MEDIATOR.notifyComplete();

    Logger.log("BusyContext.applicationBootstrapComplete: end scope='%s'", debugScope);
  };

  /**
   * @ignore
   * @private
   * @return {oj.BusyContext} returns the nearest parent context
   */
  BusyContext.prototype._getParentBusyContext = function () {
    var parentContext = this._context.getParentContext();
    if (parentContext) {
      return parentContext.getBusyContext();
    }

    return null;
  };

  /**
   * Links a child context to its parent by registering a busy state with the parent
   * that will recursively register with its parent.
   *
   * @ignore
   * @private
   */
  BusyContext.prototype._addBusyStateToParent = function () {
    if (!this._parentNotified) {
      this._parentNotified = true;

      var parentContext = this._getParentBusyContext();
      if (parentContext) {
        var opts = {};
        opts[BusyContext._DESCRIPTION] = this.toString.bind(this);
        this._parentResolveCallback = parentContext.addBusyState(opts);
      }
    }
  };

  /**
   * Resolves the busy state linking a child context with its parent.
   *
   * @ignore
   * @private
   */
  BusyContext.prototype._resolveBusyStateForParent = function () {
    this._parentNotified = false;
    if (this._parentResolveCallback) {
      this._parentResolveCallback();
      this._parentResolveCallback = null;
    }
  };

  /**
   * Rejects the whenReady Promises from this child context and its parent
   *
   * @ignore
   * @private
   */
  BusyContext.prototype._rejectWhenReadyPromises = function (error) {
    this._mediator.rejectMasterWhenReadyPromise(error);
    const parentContext = this._getParentBusyContext();
    if (parentContext) {
      parentContext._rejectWhenReadyPromises(error);
      this._resolveBusyStateForParent();
    }
  };

  /**
   * @private
   * @ignore
   * @return {string} description of all active busy states held by the context.
   */
  BusyContext.prototype._getCompoundDescription = function () {
    var busyStates = BusyContext._values(this._statesMap);
    return '[' + busyStates.join(', ') + ']';
  };

  /**
   * @private
   * @ignore
   * @return {string} context debug scope
   */
  BusyContext.prototype._getDebugScope = function () {
    function toSelector(node) {
      var selector = 'undefined';
      if (node) {
        if (node.id && node.id.length > 0) {
          selector = '#' + node.id;
        } else {
          selector = node.nodeName;
          if (node.hasAttribute('data-oj-context')) {
            selector += '[data-oj-context]';
          }

          var clazz = node.getAttribute('class');
          if (clazz) {
            selector += '.' + clazz.split(' ').join('.');
          }
        }
      }

      return selector;
    }

    if (!this._debugScope) {
      if (this._hostNode) {
        this._debugScope =
          toSelector(this._hostNode.parentElement) + ' > ' + toSelector(this._hostNode);
      } else {
        this._debugScope = 'page';
      }
    }

    return this._debugScope;
  };

  /**
   * @since 3.1.0
   * @override
   * @memberof oj.BusyContext
   * @instance
   * @method toString
   * @returns {string} returns the value of the object as a string
   */
  BusyContext.prototype.toString = function () {
    var msg = 'Busy Context: [scope=';
    msg += this._getDebugScope();
    msg += ' states=' + this._getCompoundDescription() + ']';
    return msg;
  };

  /**
   * @ignore
   * @private
   */
  BusyContext._deliverThrottledUpdates = function () {
    // Dynamically check for the presence of ojs/ojknockout
    if (oj.ComponentBinding) {
      oj.ComponentBinding.deliverChanges();
    }
  };

  /**
   * @private
   * @ignore
   * @const
   * attribute name describing a busystate
   * @type {string}
   */
  BusyContext._DESCRIPTION = 'description';

  /**
   * @ignore
   * @private
   * @constant
   * {@link oj.BusyState} property name indicating the instance is dead
   * @type {string}
   */
  BusyContext._OJ_RIP = '__ojRip';

  /**
   * @ojtsignore
   * @private
   * @ignore
   */
  BusyContext._BOOTSTRAP_MEDIATOR = new /** @constructor */ (function () {
    var _tracking;
    var _readyPromise;
    var _resolveCallback;

    if (typeof window !== 'undefined') {
      _tracking = window.oj_whenReady;
    }

    this.whenReady = function () {
      if (_readyPromise) {
        return _readyPromise;
      }

      if (!_tracking) {
        _readyPromise = Promise.resolve(true);
      } else {
        _readyPromise = new Promise(function (resolve) {
          _resolveCallback = resolve;
        });
      }
      return _readyPromise;
    };

    this.isReady = function () {
      return !_tracking;
    };

    this.notifyComplete = function () {
      if (_resolveCallback) {
        // resovle the promise in the next-tick.
        getNextTickPromise().then(function () {
          _tracking = false;
          // Check that function hasn't been nullified after next-tick
          // Can happen if multiple calls to applicationBootstrapComplete() on
          // page load (esp during WebDriver testing)
          if (typeof _resolveCallback === 'function') {
            _resolveCallback(true);
          }
          _resolveCallback = null;
        });
      } else {
        _tracking = false;
      }
    };
  })();

  const _OJ_CONTEXT_INSTANCE = Symbol();

  /**
   * <b>The constructor should never be invoked by an application directly</b>. Use
   * {@link oj.Context.getPageContext} and {@link oj.Context.getContext} APIs to
   * retrieve an instance of the context.
   * @param {Element=} node DOM node where the context should be created
   * @export
   * @hideconstructor
   * @ojtsmodule
   * @constructor oj.Context
   * @since 2.1.0
   * @classdesc This is a general purpose context. Initially it only exposes the BusyContext
   * that keeps track of components that are currently animating or fetching data.
   * In the future this context might be expanded for other purposes.
   */
  const Context = function (node) {
    this.Init(node);
  };

  oj.Object.createSubclass(Context, oj.Object, 'oj.Context');

  /**
   * @method Init
   * @param {Element=} node DOM node where the context should be created
   * @instance
   * @memberof oj.Context
   * @instance
   * @protected
   */
  Context.prototype.Init = function (node) {
    Context.superclass.Init.call(this);
    this._node = node;
  };

  /**
   * Get the parent context given the element
   * @ignore
   * @private
   * @param {Element} element
   * @return Context The parent context
   */
  Context.prototype.getParentContext = function () {
    if (this._node) {
      return Context.getContext(Context.getParentElement(this._node));
    }
    return null;
  };

  /**
    * Returns the closest enclosing JET context for a node.
    * Any DOM element may be designated by the page author as a host of JET context.
    * The designation must be expressed in HTML markup by specifying the "data-oj-context"
    * attribute on the host element:

    * <pre class="prettyprint">
    * &lt;div data-oj-context>&lt;div>
    * </pre>
    *
    * <p>This method will walk up the element hierarchy starting with the source node to
    * find an element that has the data-oj-context attribute. If no such element is found,
    * the page context will be returned.</p>
    *
    * If the JET context is established on a particular element, the {@link oj.BusyContext}
    * associated with that context will be tracking busy states for that element and
    * its subtree
    *
    * @see oj.BusyContext for code examples
    * @method getContext
    * @memberof oj.Context
    * @param {Element} node DOM element whose enclosing context will be provided
    * @return {oj.Context} context object scoped per the target node
    * @since 2.2.0
    * @export
    */
  Context.getContext = function (node) {
    let n = node;
    while (n) {
      let context = n[_OJ_CONTEXT_INSTANCE];
      if (context) {
        return context;
      }
      if (n.hasAttribute(Context._OJ_CONTEXT_ATTRIBUTE)) {
        return Context._createContext(n);
      }

      const parent = Context.getParentElement(n);

      // This code is related to the implicit busy context feature for custom
      // element slots. If a slot has the 'implicitBusyContext' metadata, then any
      // busy state reported from within the slot's subtree should be accumulated
      // on the Context instance associated with the slot node, i.e. slots with the
      // 'implicitBusyContext' metadata behave as if they were explicitly marked with
      // the data-oj-context attribute. This feature allows telemetry code to detect
      // when the slot content is ready without requiring that the application mark
      // the slot with the data-oj-context attribute.
      //
      // This check is meant to handle the case where a busy state
      // is being added within a slot before that slot has been distriubuted into the View.
      //
      // The opposite case is handled in the custom element code by placing data-oj-context
      // on each 'implicit context' slot at the time when the slot map is created.
      if (Context._hasImplicitSlotContext(parent, n)) {
        return Context._createContext(n);
      }

      n = parent;
    }

    return Context.getPageContext();
  };

  /**
   * Static factory method that returns the page context.
   * @see oj.BusyContext for code examples
   * @export
   * @since 2.1.0
   * @method getPageContext
   * @return {oj.Context} context scoped for the page
   * @memberof oj.Context
   */
  Context.getPageContext = function () {
    if (!Context._pageContext) {
      Context._pageContext = new Context();
    }

    return Context._pageContext;
  };

  /**
   * @see oj.BusyContext for code examples
   * @since 2.1.0
   * @export
   * @method getBusyContext
   * @memberof oj.Context
   * @instance
   * @returns {oj.BusyContext} busy state context
   */
  Context.prototype.getBusyContext = function () {
    if (!this._busyContext) {
      this._busyContext = new BusyContext(this._node, this);
    }

    return this._busyContext;
  };

  /**
   * Sets a default for the optional <code>timeout</code> argument of the {@link oj.BusyContext#whenReady}
   * for all BusyContext instances. The default value will be implicitly used if a timeout argument is not
   * provided.
   *
   * @see oj.BusyContext#whenReady
   * @since 6.0.0
   * @memberof oj.Context
   * @method setBusyContextDefaultTimeout
   * @param {number} timeout in milliseconds
   */
  Context.setBusyContextDefaultTimeout = function (timeout) {
    BusyContext.setDefaultTimeout(timeout);
  };

  /**
   * @ignore
   * @private
   * @constant
   * Element marker attribute defining a context
   * @type {string}
   */
  Context._OJ_CONTEXT_ATTRIBUTE = 'data-oj-context';

  /**
   * @ignore
   * @private
   * @constant
   * attribute identifying an open popup
   * @type {string}
   */
  Context._OJ_SURROGATE_ATTR = 'data-oj-surrogate-id';

  /**
   * @ignore
   * @private
   * @param {Element} element target
   * @return {Element} the logical parent of an element accounting for open popups
   * @memberof oj.Context
   */
  Context.getParentElement = function (element) {
    // @see ZOrderUtils._SURROGATE_ATTR in "ojpopupcore/PopupService.js" for the details on how
    // this attribute is used by the popup service. The constant was re-declared to simplify module
    // dependencies.

    if (element && element.hasAttribute(Context._OJ_SURROGATE_ATTR)) {
      var surrogate = document.getElementById(element.getAttribute(Context._OJ_SURROGATE_ATTR));
      if (surrogate) {
        return surrogate.parentElement;
      }
    }

    // _ojReportBusy expando will be set by the TemplateEngine if busy states need to bubble
    // up to an alternate parent
    return element._ojReportBusy || element.parentElement;
  };

  /**
   * Determines whether slot metadata instructs us to create an implicit context
   * for the slot node
   * @param {Element} parent
   * @param {Node} slot
   */
  Context._hasImplicitSlotContext = function (parent, slot) {
    // We won't be creating context for a text node since it cannot ever have busy states
    if (slot && slot.nodeType === Node.ELEMENT_NODE) {
      // Bail out if the parent element is in 'complete' state because the slot would
      // have already got the data-oj-context attribute set by the parent element itself.
      // Doing otherswise would result in creation of an implicit Context for any top element
      // of an already-created component
      const meta =
        parent && !parent.classList.contains('oj-complete') ? ojcustomelementRegistry.getMetadata(parent.localName) : null;

      if (meta) {
        const slotName = slot.getAttribute('slot') || '';
        const slotsMeta = meta.slots;
        const slotMeta = slotsMeta ? slotsMeta[slotName] : null;
        return slotMeta && slotMeta.implicitBusyContext;
      }
    }
    return false;
  };

  Context._createContext = function (n) {
    const ctx = new Context(n);
    // eslint-disable-next-line no-param-reassign
    n[_OJ_CONTEXT_INSTANCE] = ctx;
    return ctx;
  };

  /**
   * @ignore
   * @private
   */
  Context.__addPreactPromise = function (promise, description) {
    BusyContext.__preactPromisesMap.set(promise, description);
  };

  /**
   * @ignore
   * @private
   */
  Context.__removePreactPromise = function (promise) {
    BusyContext.__preactPromisesMap.delete(promise);
  };

  return Context;

});



define('ojs/ojthemeutils',['exports', 'ojs/ojcore-base', 'ojs/ojlogger'], function (exports, oj, Logger) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  const _OJ_THEME_JSON = 'oj-theme-json';

  /**
   * @namespace oj.ThemeUtils
   * @classdesc Services for getting information from the theme
   * @since 1.2.0
   * @ojtsmodule
   * @export
   */
  const ThemeUtils = {};

  /**
   * get the name of the current theme
   * @method getThemeName
   * @memberof oj.ThemeUtils
   * @export
   * @static
   * @memberof oj.ThemeUtils
   *
   * @return {string|null} the name of the theme
   */
  ThemeUtils.getThemeName = function () {
    // get the map of theme info
    var themeMap = ThemeUtils.parseJSONFromFontFamily(_OJ_THEME_JSON) || {};

    return themeMap.name;
  };

  /**
   * <p>Get the target platform of the current theme. </p>
   * <p>This API does not look at the user agent and therefore it
   *    tells you nothing about the current platform you are actually on.
   *    Instead it tells you the target platform the theme was written
   *    for so that programmatic behaviors that match the theme's UI can be written.
   *    This can be useful when writing a cross platform hybrid mobile app.  </p>
   *
   * <p>Example</p>
   * <pre class="prettyprint">
   * <code>
   * var themeTargetPlatform = oj.ThemeUtils.getThemeTargetPlatform();
   *
   * if (themeTargetPlatform == 'ios')
   *    // code for a behavior familiar in ios
   * else if (themeTargetPlatform == 'android')
   *    // code for a behavior familiar on android
   * else
   *    // code for the default behavior
   * </code></pre>
   * @export
   * @static
   * @method getThemeTargetPlatform
   * @memberof oj.ThemeUtils
   * @return {string|null} the target platform can be any string the theme
   * wants to send down, but common values are 'all', 'web', 'ios', 'android', 'windows'
   */
  ThemeUtils.getThemeTargetPlatform = function () {
    // get the map of theme info
    var themeMap = ThemeUtils.parseJSONFromFontFamily(_OJ_THEME_JSON) || {};

    return themeMap.targetPlatform;
  };

  /**
   * clear values cached in  [oj.ThemeUtils.parseJSONFromFontFamily]{@link oj.ThemeUtils.parseJSONFromFontFamily}
   * @export
   * @static
   * @method clearCache
   * @return {void}
   * @memberof oj.ThemeUtils
   */
  ThemeUtils.clearCache = function () {
    ThemeUtils._cache = null;
    ThemeUtils._cssVarCache = null;
  };

  /**
   *
   * <p>json can be sent down as the font family in classes
   * that look something like this
   * (on the sass side of things see the file
   * scss/utilities/_oj.utilities.json.scss
   * for information on jet mixins available to generate json):<p>
   *
   * <p>Example CSS</p>
   * <pre class="prettyprint">
   * <code>
   * .demo-map-json {
   *    font-family: '{"foo":"bar", "binky": 4}';
   * }
   *
   * .demo-list-json {
   *    font-family: '["foo","bar","binky"}';
   * }
   * </code></pre>
   * <p>Example Usage</p>
   * <pre class="prettyprint">
   * <code>
   * var mymap = oj.ThemeUtils.parseJSONFromFontFamily("demo-map-json");
   * var myarray = oj.ThemeUtils.parseJSONFromFontFamily("demo-list-json");
   * </code></pre>
   *
   * This function
   * <ul>
   *   <li>Gets the font family string by creating a dom element,
   *      applying the selector passed in, calling getcomputedstyle,
   *      and then reading the value for font-family.
   *   </li>
   *   <li>Parses the font family value by calling JSON.pars.</li>
   *   <li>Caches the parsed value because calling getComputedStyle is a perf hit.
   *       Subsequent requests for the same selector will return the cached value.
   *       Call [oj.ThemeUtils.clearCache]{@link oj.ThemeUtils.clearCache} if new css is loaded.</li>
   *   <li>Return the parsed value.</li>
   * </ul>
   *
   * <p>
   * If new css is loaded call oj.ThemeUtils.clearCache to clear the cache</p>
   *
   * @method parseJSONFromFontFamily
   * @memberof oj.ThemeUtils
   * @param {string} selector a class selector name, for example 'demo-map-json';
   * @return {any} the result of parsing the font family with JSON.parse.
   *      The returned value is cached, so if you modify the returned
   *      value it will be reflected in the cache.
   * @throws {SyntaxError} If JSON.parse throws a SyntaxError exception we will log an error and rethrow
   * @export
   * @static
   */
  ThemeUtils.parseJSONFromFontFamily = function (selector) {
    // NOTE: I first tried code inspired by
    // https://css-tricks.com/making-sass-talk-to-javascript-with-json/
    // so I was using :before and content, for example
    //   .oj-button-option-defaults:before {
    //     content: '{"foo":"bar", "binky": 4}';
    //    }
    //
    //  however IE 11 has a bug where the computed style doesn't actually
    //  seem to be computed when it comes to :before,
    //  so if you set a class that affects :before after the page loads
    //  on IE getComputedStyle doesn't work.
    //  See the pen below, the yellow box has the class applied in js,
    //  computedstyle works on chrome, doesn't work on IE11 for
    //  class applied after page load.
    //     http://codepen.io/gabrielle/pen/OVOwev

    // if needed create the cache and initialize some things
    if (ThemeUtils._cache == null) {
      ThemeUtils._cache = {};

      // magic value that means null in the cache
      ThemeUtils._null_cache_value = {};

      // font family is inherited, so even if no selector/json
      // is sent down we will get a string like
      // 'HelveticaNeue',Helvetica,Arial,sans-serif' off of our generated element.
      // So save off the font family from the head
      // element to compare to what we read off our generated element.
      ThemeUtils._headfontstring = window
        .getComputedStyle(document.head)
        .getPropertyValue('font-family');
    }

    // see if we already have a map for this component's option defaults
    var jsonval = ThemeUtils._cache[selector];

    // if there's something already cached return it
    if (jsonval === ThemeUtils._null_cache_value) {
      return null;
    } else if (jsonval != null) {
      return jsonval;
    }

    // there's nothing cached, so we need to create a dom element to apply the class to.
    // We're creating a meta element,
    // the hope is that the browser is smart enough to realize the
    // meta element isn't visible and therefore we avoid perf issues of calling
    // getcomputedstyle
    if (typeof document === 'undefined') {
      return null;
    }
    var elem = document.createElement('meta');
    elem.className = selector;
    document.head.appendChild(elem); // @HTMLUpdateOK
    var rawfontstring = window.getComputedStyle(elem).getPropertyValue('font-family');

    if (rawfontstring != null) {
      // if the raw font string is the same value as the saved header
      // font value then log a warning that no value was sent down.

      if (rawfontstring === ThemeUtils._headfontstring) {
        Logger.warn(
          'parseJSONFromFontFamily: When the selector ',
          selector,
          ' is applied the font-family read off the dom element is ',
          rawfontstring,
          '. The parent dom elment has the same font-family value.',
          ' This is interpreted to mean that no value was sent down for selector ',
          selector,
          '. Null will be returned.'
        );
      } else {
        // remove inconsistent quotes
        var fontstring = rawfontstring.replace(/^['"]+|\s+|\\|(;\s?})+|['"]$/g, '');

        if (fontstring) {
          try {
            jsonval = JSON.parse(fontstring);
          } catch (e) {
            // In Firefox you can turn off the page font
            // Options -> Content -> Fonts and Colors -> Advanced
            // Uncheck the "Allow pages to choose their own fonts, instead of my selections above"
            // In that case they stick something like 'serif,"'at the front of the font family,
            // so search for the first comma, add 2, and try parsing again.
            var commaindex = fontstring.indexOf(',');
            var reparseSuccess = false;

            if (commaindex > -1) {
              fontstring = fontstring.substring(commaindex + 2);

              try {
                jsonval = JSON.parse(fontstring);
                reparseSuccess = true;
              } catch (e2) {
                // Ignore Error
              }
            }

            if (reparseSuccess === false) {
              Logger.error(
                'Error parsing json for selector ' +
                  selector +
                  '.\nString being parsed is ' +
                  fontstring +
                  '. Error is:\n',
                e
              );

              // remove the meta tag
              document.head.removeChild(elem);
              throw e;
            }
          }
        }
      }
    }

    // remove the meta tag
    document.head.removeChild(elem);

    // cache the result
    if (jsonval == null) {
      ThemeUtils._cache[selector] = ThemeUtils._null_cache_value;
    } else {
      ThemeUtils._cache[selector] = jsonval;
    }

    return jsonval;
  };
  /**
   * Returns the root css var values
   * @private
   * @method getRootCssVarValue
   * @argument {string} key
   * @return {string} The property value for the key
   * @memberof oj.ThemeUtils
   */
  const getRootCssVarValue = (key) => {
    if (!ThemeUtils._rootCSSStyles) {
      ThemeUtils._rootCSSStyles = window.getComputedStyle(document.documentElement);
    }
    // remove inconsistent quotes
    return ThemeUtils._rootCSSStyles
      .getPropertyValue(key)
      .replace(/^['"\s]+|\s+|\\|(;\s?})+|['"\s]$/g, '');
  };
  /**
   * Returns the css var values
   * @private
   * @method getCachedValueForKey
   * @argument {string} key
   * @return {string} The property value for the key
   * @memberof oj.ThemeUtils
   */
  var getCachedValueForKey = (key) => {
    if (!ThemeUtils._cssVarCache) {
      ThemeUtils._cssVarCache = new Map();
    }
    if (!ThemeUtils._cssVarCache.has(key)) {
      ThemeUtils._cssVarCache.set(key, getRootCssVarValue(key));
    }
    return ThemeUtils._cssVarCache.get(key);
  };
  /**
   * Returns the css var values
   * @ignore
   * @static
   * @method getCachedCSSVarValues
   * @argument {Array} cssVarArray An array of the CSS Vars
   * @return {Array} An Array containing the computed values of the css vars in the cssVarArray
   * @memberof oj.ThemeUtils
   */
  ThemeUtils.getCachedCSSVarValues = (cssVarArray) => {
    return cssVarArray.map((cssVar) => getCachedValueForKey(cssVar));
  };

  /**
   * Validates the CSS version against the JS version the first time it's called.
   * @ignore
   * @static
   * @method verifyThemeVersion
   * @return {void}
   * @memberof oj.ThemeUtils
   */
  ThemeUtils.verifyThemeVersion = (() => {
    // Using an IIFE here to store verified in closure scope
    // The returned function will get called when custom elements
    // try to resolve their binding provider Promises (and will
    // only do anything interesting the first time it's called
    // since it will short-circuit on verified for subsuquent calls).
    let verified = false;
    return () => {
      if (!verified && typeof window !== 'undefined' && true) {
        verified = true;
        if (ThemeUtils.getThemeName() === 'alta') {
          const message =
            'The Alta theme has been deprecated since JET 10.0 (January 2021), please move to either the Redwood or Stable theme ASAP. All Alta CSS and SCSS files will be removed in JET 21.0 (August 2026)';
          Logger.warn(message);
        }
        // Compare JET version with theme version
        const jetVersions = oj.version.split('.');
        let themeMap;
        try {
          themeMap = (ThemeUtils.parseJSONFromFontFamily(_OJ_THEME_JSON) || {}).jetReleaseVersion;
        } catch (err) {
          // Either CSS wasn't found at all, or the CSS is old enough to not contain oj-theme-json
          // Setting themeMap to undefined will let this fall through to the Logger.error case below
          themeMap = undefined;
        }
        const themeVersions = (themeMap || '')
          .replace(/^v/, '') // Remove leading 'v'
          .split('.');

        // Log error if major/minor mismatch, warning for patch mismatch
        const message = `Your CSS file is incompatible with this version of JET (${oj.version}).
      Please see the Migration section of the Developer's Guide for how to update it.
        `;
        if (jetVersions[0] !== themeVersions[0] || jetVersions[1] !== themeVersions[1]) {
          Logger.error(message);
        } else if (jetVersions[2] !== themeVersions[2]) {
          Logger.warn(message);
        }
      }
    };
  })();

  const clearCache = ThemeUtils.clearCache;
  const getThemeName = ThemeUtils.getThemeName;
  const getThemeTargetPlatform = ThemeUtils.getThemeTargetPlatform;
  const parseJSONFromFontFamily = ThemeUtils.parseJSONFromFontFamily;
  const verifyThemeVersion = ThemeUtils.verifyThemeVersion;
  const getCachedCSSVarValues = ThemeUtils.getCachedCSSVarValues;

  exports.clearCache = clearCache;
  exports.getCachedCSSVarValues = getCachedCSSVarValues;
  exports.getThemeName = getThemeName;
  exports.getThemeTargetPlatform = getThemeTargetPlatform;
  exports.parseJSONFromFontFamily = parseJSONFromFontFamily;
  exports.verifyThemeVersion = verifyThemeVersion;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcustomelement-utils',['exports', 'ojs/ojcore-base', 'ojs/ojcustomelement-registry', 'ojs/ojcontext', 'ojs/ojlogger', 'ojs/ojthemeutils'], function (exports, oj, ojcustomelementRegistry, Context, Logger, ThemeUtils) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

    const _SUPPORTED_TYPES_MAP = {};
    /**
     * Element utilities.
     * @class ElementUtils
     * @ignore
     */
    class ElementUtils {
        /**
         * Custom element name check
         * @param {String} localName Element name
         * @return {boolean}
         * @ignore
         */
        static isValidCustomElementName(localName) {
            const reserved = ElementUtils._RESERVED_TAGS.has(localName);
            const validForm = ElementUtils._ELEMENT_NAME_REGEXP.test(localName);
            return !reserved && validForm && !localName.startsWith('oj-bind-', 0);
        }
        /**
         * Returns an object containing the parsed types from the input
         * type string. The return object will return truthy values for the
         * following types: any, boolean, number, string, array, object, null.
         * @param {string} typeStr
         * @return {object}
         * @ignore
         */
        static getSupportedTypes(typeStr) {
            if (!typeStr)
                return {};
            let supportedTypes = _SUPPORTED_TYPES_MAP[typeStr];
            if (!supportedTypes) {
                // Generate the supported types map
                supportedTypes = {};
                const lowerTypeStr = typeStr.toLowerCase();
                const types = lowerTypeStr.match(/(?=[^|])(?:[^|]*<[^>]+>)*[^|]*/g);
                let numTypes = 0;
                types.forEach((untrimmedType) => {
                    const type = untrimmedType.trim();
                    if (type === 'any' ||
                        type === 'boolean' ||
                        type === 'number' ||
                        type === 'string' ||
                        type === 'array' ||
                        type === 'object' ||
                        type === 'null') {
                        supportedTypes[type] = 1;
                    }
                    else if (type.indexOf('array<') === 0) {
                        // array<string>
                        supportedTypes.array = 1;
                    }
                    else if (type.indexOf('object<') === 0) {
                        // object<string, number>
                        supportedTypes.object = 1;
                    }
                    else {
                        // Skip checking of other types and just bucket them
                        // all under one category
                        supportedTypes.other = 1;
                    }
                    // eslint-disable-next-line no-plusplus
                    numTypes++;
                });
                supportedTypes.typeCount = numTypes;
                // A union type is only cached with the given type, e.g. 'string|number'
                // so 'number|string' will be a miss in the cache
                _SUPPORTED_TYPES_MAP[lowerTypeStr] = supportedTypes;
            }
            return supportedTypes;
        }
        /**
         * Returns either the passed id or a unique string that can be used for
         * a custom element id.
         * @ignore
         * @param {string} id
         * @return {string}
         * @private
         */
        static getUniqueId(id) {
            if (id) {
                return id;
            }
            const ret = ElementUtils._UNIQUE + ElementUtils._UNIQUE_INCR;
            ElementUtils._UNIQUE_INCR += 1;
            return ret;
        }
        /**
         * Compares two values, returning true if they are equal. Does a deeper check for writeback values
         * because we can't prevent knockout from triggering a second property set with the same values
         * when writing back, but we do want to prevent the addtional update and property changed event.
         * @ignore
         */
        static comparePropertyValues(isWriteback, value1, value2) {
            if (isWriteback) {
                return oj.Object.compareValues(value1, value2);
            }
            return value1 === value2;
        }
    }
    ElementUtils._UNIQUE_INCR = 0;
    ElementUtils._UNIQUE = '_oj';
    ElementUtils._RESERVED_TAGS = new Set([
        'annotation-xml',
        'color-profile',
        'font-face',
        'font-face-src',
        'font-face-uri',
        'font-face-format',
        'font-face-name',
        'missing-glyph'
    ]);
    ElementUtils._ELEMENT_NAME_REGEXP = /^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/;

    /**
     * This list should be kept in sync with GlobalProps from "ojs/ojvcomponent"
     *
     * This list provides a map of global property to attribute names
     * where the attribute name is used for both key and value if no property
     * exists. We start with the list of global attributes found here:
     * https://html.spec.whatwg.org/multipage/dom.html#global-attributes
     * and check those against the Element and HTMLElement specs to determine
     * the property name if different:
     * https://dom.spec.whatwg.org/#interface-element
     * https://html.spec.whatwg.org/multipage/dom.html#htmlelement
     * This list is not exhaustive of all Element and HTMLElement properties.
     * @ignore
     */
    // eslint-disable-next-line no-unused-vars
    const GLOBAL_PROPS = {
        accessKey: 'accesskey',
        autocapitalize: 'autocapitalize',
        autofocus: 'autofocus',
        class: 'class', // We support class instead of className for JSX
        contentEditable: 'contenteditable',
        dir: 'dir',
        draggable: 'draggable',
        enterKeyHint: 'enterkeyhint',
        hidden: 'hidden',
        id: 'id',
        inputMode: 'inputmode',
        lang: 'lang',
        role: 'role',
        slot: 'slot',
        spellcheck: 'spellcheck',
        style: 'style',
        tabIndex: 'tabindex',
        translate: 'translate',
        title: 'title'
    };

    class JetElementError extends Error {
        constructor(element, message) {
            super(`${element.localName} with id '${element.id || ''}': ${message}`);
            // Maintains proper stack trace for where error was thrown (only available on V8)
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, JetElementError);
            }
            this.name = 'JetElementError';
        }
    }

    const _ARRAY_VALUE_EXP = /^\s*\[[^]*\]\s*$/;
    const _OBJ_VALUE_EXP = /^\s*\{[^]*\}\s*$/;
    // Check for {{..}} and [[..]] at the beginning of strings to avoid matching
    // any usages mid string
    const _ATTR_EXP = /^(?:\{\{)([^]+)(?:\}\})$/;
    const _ATTR_EXP_RO = /^(?:\[\[)([^]+)(?:\]\])$/;
    /**
     * This map includes attribute to property names for
     * all global attributes where the two differ.
     * @ignore
     */
    const _GLOBAL_ATTRS = {};
    Object.keys(GLOBAL_PROPS).forEach(function (prop) {
        const attr = GLOBAL_PROPS[prop];
        if (prop !== attr) {
            _GLOBAL_ATTRS[attr] = prop;
        }
    });
    /**
     * @ignore
     * @private
     */
    class AttributeUtils {
        /**
         * @ignore
         * @return {{expr: (null|string), downstreamOnly: boolean}}
         * @private
         */
        static getExpressionInfo(attrValue) {
            let downstreamOnly = false;
            let expr;
            if (attrValue) {
                const trimmedVal = attrValue.trim();
                let expArr = _ATTR_EXP.exec(trimmedVal);
                expr = expArr?.[1];
                if (!expr) {
                    downstreamOnly = true;
                    expArr = _ATTR_EXP_RO.exec(trimmedVal);
                    expr = expArr?.[1];
                }
            }
            return { downstreamOnly, expr };
        }
        static attributeToPropertyValue(elem, attr, val, propMeta) {
            if (val == null)
                return undefined;
            // TODO handle complex properties
            try {
                return AttributeUtils.coerceValue(elem, attr, val, propMeta.type);
            }
            catch (err) {
                throw new JetElementError(elem, `Error while parsing parsing attribute ${attr}. ${err.stack || err}`);
            }
        }
        /**
         * Parses attribute values to the specified metadata type. Throws
         * an error if the value cannot be parsed to the metadata type
         * or if no type was provided.
         * @ignore
         * @param {string} tagName lowercase tag name
         * @param {string} attr attribute
         * @param {string} value attribute value
         * @param {string} type property type
         * @param {string} [id] optional element Id
         * @return {any} coerced value
         * @private
         */
        static parseAttributeValue(tagName, attr, value, type, id = null) {
            if (!type) {
                throw new Error(`Unable to parse ${attr}='${value}' for ${tagName} with id '${id}'. \
        This attribute only supports data bound values. Check the API doc for supported types`);
            }
            // We only support primitive types and JSON objects for coerced properties.
            const supportedTypes = ElementUtils.getSupportedTypes(type);
            // The below checks ignore the couble {{}} [[]] cases since expression checking occurs
            // before attribute value coercion
            // Tests to see if the value starts and ends with matched [...] ignoring whitespace
            const isValueArray = _ARRAY_VALUE_EXP.test(value);
            // Tests to see if the value starts and ends with matched {...} ignoring whitespace
            const isValueObj = _OBJ_VALUE_EXP.test(value);
            if ((supportedTypes.array && isValueArray) ||
                (supportedTypes.object && isValueObj) ||
                (supportedTypes.any && (isValueArray || isValueObj))) {
                try {
                    return JSON.parse(value);
                }
                catch (ex) {
                    throw new Error(`Unable to parse ${attr}='${value}' for ${tagName} with id '${id}' \
          to a JSON Object. Check the value for correct JSON syntax, e.g. double quoted strings. ${ex}`);
                }
            }
            else if (supportedTypes.string || supportedTypes.any) {
                // If the supported type(s) contain string or any we won't know
                // whether to coerce the type further, e.g. if boolean is also supported
                // so we will always return a string. For the non string type, data binding
                // needs to be used instead.
                return value;
            }
            else if (supportedTypes.boolean) {
                return AttributeUtils.parseBooleanValue(tagName, attr, value, type, id);
            }
            else if (supportedTypes.number && !isNaN(value)) {
                return Number(value);
            }
            throw new Error(`Unable to parse ${attr}='${value}' for ${tagName} with id '${id}' \
      to a ${type}.`);
        }
        /**
         * Parses boolean attribute values. Throws
         * an error if the value cannot be parsed.
         * @ignore
         * @param {string} tagName lowercase tag name
         * @param {string} attr attribute
         * @param {string} value attribute value
         * @param {string} type property type
         * @param {string} [id] optional element Id
         * @return {boolean} coerced value
         * @private
         */
        static parseBooleanValue(tagName, attr, value, type, id) {
            // Boolean attributes are considered true if the attribute is:
            // 1) Set to the empty string
            // 2) Present in the DOM without a value assignment
            // 3) Set to the 'true' string
            // 4) Set to the case-insensitive attribute name
            // Boolean values are considered false if set to the false string.
            // An error is thrown for all other values and the attribute value will not be set.
            if (value == null || value === 'true' || value === '' || value.toLowerCase() === attr) {
                return true;
            }
            else if (value === 'false') {
                return false;
            }
            throw new Error(`Unable to parse ${attr}='${value}' for ${tagName} with id '${id}' to a ${type}.`);
        }
        /**
         * Parses attribute values to the specified metadata type. Throws
         * an error if the value cannot be parsed to the metadata type
         * or if no type was provided.
         * @ignore
         * @param {Element} elem The element whose value we are parsing
         * @param {string} attr attribute
         * @param {string} value attribute value
         * @param {string} type property type
         * @return {any} coerced value
         * @private
         */
        static coerceValue(elem, attr, value, type) {
            const tagName = elem.tagName.toLowerCase();
            return AttributeUtils.parseAttributeValue(tagName, attr, value, type, elem.id);
        }
        /**
         * Parses boolean attribute values. Throws
         * an error if the value cannot be parsed.
         * @ignore
         * @param {Element} elem The element whose value we are parsing
         * @param {string} attr attribute
         * @param {string} value attribute value
         * @param {string} type property type
         * @return {boolean} coerced value
         * @private
         */
        static coerceBooleanValue(elem, attr, value, type) {
            return AttributeUtils.parseBooleanValue(elem.tagName.toLowerCase(), attr, value, type, elem.id);
        }
        /**
         * Returns true if the given property name maps to a global attribute.
         * For global attributes with no property getter, this method will check
         * the attribute name and handle data- and aria- dash cases.
         * @param {string} prop The property name to check
         * @return {boolean}
         * @private
         * @ignore
         */
        static isGlobalOrData(prop) {
            // TODO: watch out for performance of hasOwnProperty given how often we expect isGlobal to be called
            return (Object.prototype.hasOwnProperty.call(GLOBAL_PROPS, prop) ||
                prop.startsWith('data-') ||
                prop.startsWith('aria-'));
        }
        /**
         * This method assumes that the given property name has already been confirmed to
         * be global and will return the attribute syntax or the original value which could be
         * the global attribute name that does not have a property equivalent, e.g.
         * data- or aria-.
         * @ignore
         * @param {string} prop The property name to check
         * @return {string}
         * @private
         */
        static getGlobalAttrForProp(prop) {
            return GLOBAL_PROPS[prop] || prop;
        }
        /**
         * This method assumes that the given attribute name has already been confirmed
         * to be global and will return the attribute syntax or the original value which could be
         * the global attribute name that does not have a property equivalent, e.g.
         * data- or aria-.
         * @ignore
         * @param {string} attr The attribute name to check
         * @return {string}
         * @private
         */
        static getGlobalPropForAttr(attr) {
            return _GLOBAL_ATTRS[attr] || attr;
        }
        /**
         * The purpose of this method is to get a property name that should be used
         * for retrieving a property value.
         * The method is similar to AttributeUtils.getGlobalPropForAttr() with one difference - it handles
         * 'contenteditable' attribute as a special case. The value type for the property is 'string',
         * but it is defined as 'boolean' in preact.JSX.HTMLAttributes. Using 'isContentEditable' name
         * as a replacement gives us the correct boolean value for the 'contentEditable' property.
         * @ignore
         * @param {string} attr The attribute name to check
         * @returns {string}
         */
        static getGlobalValuePropForAttr(attr) {
            if (attr.toLowerCase() === 'contenteditable') {
                return 'isContentEditable';
            }
            return AttributeUtils.getGlobalPropForAttr(attr);
        }
    }
    /**
     * @ignore
     * @param {string} attr attribute name
     * @return {string} property name
     * @private
     */
    AttributeUtils.attributeToPropertyName = cacheHelper.bind(null, (attr) => attr.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase()));
    /**
     * @ignore
     * @param {string} name property name
     * @return {string} attribute name
     * @private
     */
    AttributeUtils.propertyNameToAttribute = cacheHelper.bind(null, (name) => name.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`));
    /**
     * @ignore
     * @param {string} type event type (e.g. ojBeforeExpand)
     * @return {string} event listener property name (e.g. onOjBeforeExpand)
     * @private
     */
    AttributeUtils.eventTypeToEventListenerProperty = cacheHelper.bind(null, (type) => 'on' + type.substr(0, 1).toUpperCase() + type.substr(1));
    AttributeUtils.isEventListenerProperty = cacheHelper.bind(null, (property) => /^on[A-Z]/.test(property));
    AttributeUtils.isEventListenerAttr = cacheHelper.bind(null, (attr) => /^on-[a-z]/.test(attr));
    /**
     * @ignore
     * @param {string} property event listener property name (e.g. onOjBeforeExpand)
     * @return {string|null} event type (e.g. ojBeforeExpand)
     * @private
     */
    AttributeUtils.eventListenerPropertyToEventType = cacheHelper.bind(null, (property) => property.substr(2, 1).toLowerCase() + property.substr(3));
    /**
     * @ignore
     * @param {string} name property name (e.g. expanded)
     * @return {string} change event type (e.g. expandedChanged)
     * @private
     */
    AttributeUtils.propertyNameToChangeEventType = cacheHelper.bind(null, (name) => `${name}Changed`);
    /**
     * @ignore
     * @param {string} prop Property name (e.g. value)
     * @return {string} property changed callback (e.g. onValueChanged)
     * @private
     */
    AttributeUtils.propertyNameToChangedCallback = cacheHelper.bind(null, (prop) => `on${prop[0].toUpperCase()}${prop.substr(1)}Changed`);
    /**
     * @ignore
     * @param {string} trigger event trigger (e.g. beforeExpand)
     * @return {string} event type (e.g. ojBeforeExpand)
     * @private
     */
    AttributeUtils.eventTriggerToEventType = cacheHelper.bind(null, (trigger) => `oj${trigger.substr(0, 1).toUpperCase()}${trigger.substr(1)}`);
    /**
     * @ignore
     * @param {string} attr attribute for a custom event (e.g. on-value-changed)
     * @return {string} custom event in the form of on[eventType] - Preact style (e.g. onvalueChanged)
     * @private
     */
    AttributeUtils.eventAttrToPreactPropertyName = cacheHelper.bind(null, (attr) => {
        const capitalize = (chunk) => chunk.charAt(0).toUpperCase() + chunk.substr(1);
        const chunks = attr.toLowerCase().split('-');
        return chunks.reduce((acc, curr, index) => {
            return index > 1 ? acc + capitalize(curr) : acc + curr;
        }, '');
    });
    function cacheHelper(converter, key) {
        // Check for cache stored on the converter function and create one
        // if not found
        let cache = converter['cache'];
        if (!cache) {
            cache = new Map();
            converter['cache'] = cache;
        }
        if (!cache.has(key)) {
            cache.set(key, converter(key));
        }
        return cache.get(key);
    }

    /**
     * Utility class with methods used to convert oj-bind-[element] into comment nodes.
     * The methods are shared between oj-knockout-base and ojtemplateengine-utils modules.
     * @ignore
     * @private
     */
    class KoBindingUtils {
        /**
         * Creates ko handler for oj-bind-fo-each element.
         * @param node
         * @returns
         * @ignore
         * @private
         */
        static createBindForEachHandlerStr(node) {
            const dataValue = node.getAttribute('data');
            let dataExp = AttributeUtils.getExpressionInfo(dataValue).expr;
            if (!dataExp) {
                try {
                    const literalValue = JSON.parse(dataValue);
                    if (Array.isArray(literalValue)) {
                        dataExp = dataValue;
                    }
                    else {
                        throw new Error(`Literal value must be an array, actual value: ${dataValue}`);
                    }
                }
                catch (e) {
                    throw new Error(`The value on the oj-bind-for-each data attribute should be either a JSON array or an expression : ${e}`);
                }
            }
            if (!dataExp) {
                return undefined;
            }
            const asExp = KoBindingUtils.getExpressionForAttr(node, 'as', true);
            const closing = asExp ? `,as:${asExp}}` : '}';
            return `ko _ojBindForEach_:{data:${dataExp}${closing}`;
        }
        /**
         * Builds a string for a wrapper comment around ko comment node
         * with all of the attribute info that was on the original DOM node.
         * The wrapper comment is used to help identifying oj-bind-[element] that
         * was converted into a comment node.
         * @param node
         * @returns
         * @ignore
         * @private
         */
        static getNodeReplacementCommentStr(node) {
            var commentText = node.tagName.toLowerCase();
            var attrs = node.attributes;
            for (var i = 0; i < attrs.length; i++) {
                // jsperf says string concat is faster than array join, but
                // varies across browsers whether text += or text = text + is faster
                // the below method is fastest on Chrome and not bad on FF
                var attr = attrs[i];
                commentText += ' ';
                commentText += attr.name;
                commentText += "='";
                commentText += attr.value;
                commentText += "'";
            }
            return commentText;
        }
        /**
         * Gets an expression for the specified attribute;
         * stringifies it if it is necessary.
         * @param node
         * @param attr
         * @param stringify
         * @returns
         * @ignore
         * @private
         */
        static getExpressionForAttr(node, attr, stringify) {
            const attrValue = node.getAttribute(attr);
            if (attrValue != null) {
                let exp = AttributeUtils.getExpressionInfo(attrValue).expr;
                if (exp == null) {
                    exp = stringify ? `'${attrValue}'` : attrValue;
                }
                return exp;
            }
            return null;
        }
    }

    const CHILD_BINDING_PROVIDER = Symbol('childBindingProvider');
    const CACHED_BINDING_PROVIDER = Symbol('cachedBindingProvider');
    const EMPTY_SET = new Set();
    const _OJ_SUBTREE_HIDDEN_CLASS = 'oj-subtree-hidden';
    const _OJ_PENDING_SUBTREE_HIDDEN_CLASS = 'oj-pending-subtree-hidden';
    const _OJ_SLOT_WHITESPACE = Symbol('ojSlotWhitespace');
    /**
     * Utility class used with JET custom elements.
     * @ignore
     */
    class CustomElementUtils {
        /**
         * Notifies JET framework that a subtree possibly containing JET components is no longer hidden with display:none style
         * This method should be used when subtree shown travsersal is initiated outside of legacy jQueryUI widgets
         * @param elem The element at the root of the subtree shown traversal
         * @param initialRender true if a component performs subtree shown traversal during its intial rendering
         * @param {boolean} skipDeferActivation true if oj-defer elements should not be activated during subtree shown traversal.
         * We ony want to perform oj-defer activation when a component starts displaying a subtree FOR THE FIRST TIME
         * (a collapsible is expanded, a tab is revealed, etc...) For cases when we are temporarily hiding the already-displayed
         * content and are then making it visible again, we do not want to activate oj-defer.
         * @ignore
         */
        static subtreeShown(elem, initialRender, skipDeferActivation) {
            // legacySubtreeShownOnceCB fixes up resize listeners
            CustomElementUtils._legacySubtreeShownOnceCB?.(elem, initialRender);
            _unmarkSubtreeHidden(elem);
            const legacyShowCB = CustomElementUtils._legacySubtreeShownInstanceCB;
            const instanceCB = legacyShowCB
                ? _executeWithSlotRelocationOn((elem) => legacyShowCB(elem, initialRender))
                : null;
            _applyHideShowToComponents(elem, instanceCB, skipDeferActivation ? null : _ojDeferCallback);
        }
        /**
         * Returns a string including the element tag name and id for use in error messages and logging.
         * @param element The element to get the information for.
         * @ignore
         */
        static getElementInfo(element) {
            if (element) {
                return `${element.tagName.toLowerCase()} with id '${element.id}'`;
            }
            return '';
        }
        /**
         * Returns an instance of ElementState for a given element within the case insensitive
         * JET custom element registry or null if not found.
         * @param element
         */
        static getElementState(element) {
            let state = element[CustomElementUtils._ELEMENT_STATE_KEY];
            if (!state && ojcustomelementRegistry.isElementRegistered(element.tagName)) {
                const StateClass = ojcustomelementRegistry.getElementRegistration(element.tagName).stateClass;
                state = new StateClass(element);
                Object.defineProperty(element, CustomElementUtils._ELEMENT_STATE_KEY, { value: state });
            }
            return state ?? null;
        }
        /**
         * Returns an instance of BaseCustomElementBridge for a given element
         * within the case insensitive JET custom element registry or null if not found.
         * @param element
         */
        static getElementBridge(element) {
            let bridge = element[CustomElementUtils._ELEMENT_BRIDGE_KEY];
            if (bridge === undefined && ojcustomelementRegistry.isElementRegistered(element.tagName)) {
                bridge = null;
                const bridgeProto = ojcustomelementRegistry.getElementRegistration(element.tagName).bridgeProto;
                if (bridgeProto !== undefined) {
                    bridge = Object.create(bridgeProto);
                    const descriptor = ojcustomelementRegistry.getElementDescriptor(element.tagName);
                    bridge.initializeBridge(element, descriptor);
                }
                Object.defineProperty(element, CustomElementUtils._ELEMENT_BRIDGE_KEY, { value: bridge });
            }
            return bridge ?? null;
        }
        /**
         * Returns the slot map of slot name to slotted child elements for a given custom element.
         * If the given element has no children, this method returns an empty object.
         * Note that the default slot name is mapped to the empty string.
         * @param element
         */
        static getSlotMap(element) {
            const slotMap = {};
            const childNodeList = element.childNodes;
            const metadata = childNodeList.length > 0 ? ojcustomelementRegistry.getMetadata(element.localName) : null;
            for (let i = 0; i < childNodeList.length; i++) {
                const child = childNodeList[i];
                // Only assign Text and Element nodes to a slot
                if (CustomElementUtils.isSlotable(child)) {
                    const slot = CustomElementUtils.getSlotAssignment(child);
                    if (!slotMap[slot]) {
                        slotMap[slot] = [];
                    }
                    // Create implict Context for slots that have 'implicitBusyContext=true' in their metadata.
                    //
                    // Note that it is possible that a busy state will be registered from the slot
                    // subtree BEFEORE the slot is distributed. In that case, the implicit context will
                    // be added by the Context.getContext() implementation, and the busy state will still
                    // be captured accordingly. Calling _possiblyApplyImplicitContext() after that will
                    // still add a data-oj-context attribute, but it won't affect anything.
                    CustomElementUtils._possiblyApplyImplicitContext(child, slot, metadata);
                    slotMap[slot].push(child);
                    // Set a binding provider for the slot subtree. See details in the method description.
                    child[CACHED_BINDING_PROVIDER] = CustomElementUtils._getBindingProviderTypeForSlot(element, child);
                }
            }
            return slotMap;
        }
        /**
         * Returns the slot that the node should get assigned to.
         * Note that the default slot name is mapped to the empty string.
         * @param node
         */
        static getSlotAssignment(node) {
            // Text nodes and elements with no slot attribute map to the default slot.
            // __oj_slots is the slot attribute saved from an oj-bind-slot or oj-bind-template-slot element
            // Remember that the slot name can be the empty string so we should do a null check instead of just using || directly
            const slot = node['__oj_slots'] != null
                ? node['__oj_slots']
                : node.getAttribute && node.getAttribute('slot');
            if (!slot)
                return '';
            return slot;
        }
        /**
         * Returns true if an element is slot assignable.
         * @param node
         */
        static isSlotable(node) {
            // Ignore text nodes that only contain whitespace
            const isSlotable = node.nodeType === 1 || (node.nodeType === 3 && !!node.nodeValue.trim());
            if (!isSlotable) {
                // Mark the node as a part of a slot to offset preact behavior
                // during rerender when the slot content is reparented back.
                node[_OJ_SLOT_WHITESPACE] = true;
            }
            return isSlotable;
        }
        /**
         * Returns the property value for an element, used by the WebElement test adapters.
         * For most cases, this method just returns the property directly from the element.
         * For VComponent-first custom elements, this method returns the property from the
         * component instance's props variable.
         */
        static getElementProperty(element, property) {
            // TODO: May want to refactor once we design out additional test related APIs
            if (ojcustomelementRegistry.isElementRegistered(element.tagName)) {
                let vInst = element[CustomElementUtils.VCOMP_INSTANCE];
                // For VComponent-first instances, we need to get the value from the props
                if (vInst) {
                    return CustomElementUtils.getPropertyValue(vInst.props, property);
                }
                // For all other component types, we can just use the element getProperty() method
                return element.getProperty(property);
            }
            return element[property];
        }
        /**
         * Retrieves the property or subproperty value from the given props object,
         * walking complex properties to return the nested value as needed
         * @param allProps Either a property bag or the element to retrieve properties from
         * @param property The property to retrieve, which can include dot notation for complex properties
         */
        static getPropertyValue(allProps, property) {
            let propObj = allProps;
            const propPath = property.split('.');
            try {
                propPath.forEach((subprop) => (propObj = propObj[subprop]));
            }
            catch {
                // We return undefined for invalid properties, so return undefined if an
                // invalid complex property path is given
                return undefined;
            }
            return propObj;
        }
        /**
         * Sets a flag used by our custom element appendChild and insertBefore overrides
         * to determine whether we can relocate a child node. This flag is used to work
         * around preact .
         * @param allow True if an appendChild/inertB
         */
        static allowSlotRelocation(allow) {
            CustomElementUtils._ALLOW_RELOCATION_COUNT += allow ? 1 : -1;
        }
        /**
         * A check used by our custom element appendChild and insertBefore overrides
         * to determine whether we can relocate a child node. This check is used to work
         * around preact .
         * @param element
         * @param node
         */
        static canRelocateNode(element, node) {
            const state = CustomElementUtils.getElementState(element);
            const slotMap = state.getSlotMap();
            // If no SlotMap has been cached, the component has not rendered
            // for the first time yet so we can safely relocate nodes
            if (!slotMap || CustomElementUtils._ALLOW_RELOCATION_COUNT > 0) {
                return true;
            }
            const slotSet = state.getSlotSet();
            if (state.isPostCreateCallbackOrComplete() &&
                (slotSet.has(node) || node[_OJ_SLOT_WHITESPACE])) {
                if (element.hasAttribute('data-oj-preact')) {
                    throw new JetElementError(element, `${node.localName} cannot be relocated as a child of this element.`);
                }
                else if (state.getBindingProviderType() === 'preact') {
                    return false;
                }
            }
            return true;
        }
        /**
         * Cleans ko bindings from an element if they were applied on the element;
         * noop otherwise.
         * @param element
         */
        static cleanComponentBindings(element) {
            CustomElementUtils.getElementState(element)?.getBindingProviderCleanNode()(element);
        }
        /**
         * Returns a Set containing the individual classNames specified in the (possibly null) passed-in string
         * @param strClass
         * @returns
         */
        static getClassSet(strClass) {
            if (strClass) {
                const arClasses = strClass.split(/\s+/).filter((cls) => cls.length > 0);
                if (arClasses.length > 0) {
                    return new Set(arClasses);
                }
            }
            return EMPTY_SET;
        }
        static _possiblyApplyImplicitContext(child, slot, metadata) {
            if (child?.nodeType === Node.ELEMENT_NODE) {
                if (metadata.slots?.[slot]?.implicitBusyContext) {
                    child.setAttribute('data-oj-context', '');
                }
            }
        }
        /**
         * Get binding provider type for slot elements.
         * The provider should match the provider of the parent element unless
         * the slot child has been redistributed and already has CACHED_BINDING_PROVIDER property or
         * the provider is explicitly set with 'data-oj-binding-provider' attribute.
         * The method is added to support conditional rendering of composite components inside VComponent.
         * See JET-57970 for details.
         * @param element
         * @param child
         * @returns
         */
        static _getBindingProviderTypeForSlot(element, child) {
            return (child[CACHED_BINDING_PROVIDER] ||
                (child.nodeType === 1 && child.getAttribute('data-oj-binding-provider')) ||
                CustomElementUtils.getElementState(element)?.getBindingProviderType());
        }
        static markPendingSubtreeHidden(element) {
            element.classList.add(_OJ_PENDING_SUBTREE_HIDDEN_CLASS);
        }
        static unmarkPendingSubtreeHidden(element) {
            element.classList.remove(_OJ_PENDING_SUBTREE_HIDDEN_CLASS);
        }
        /**
         * @ignore
         */
        static registerLegacySubtreeCallbacks(instanceShown, shownOnce, instanceHidden) {
            CustomElementUtils._legacySubtreeShownInstanceCB = instanceShown;
            CustomElementUtils._legacySubtreeShownOnceCB = shownOnce;
            CustomElementUtils._legacySubtreeHiddenInstanceCB = instanceHidden;
        }
        /**
         * Returns the coerced attribute value using a custom parse function or the framework default.
         * @ignore
         */
        static parseAttrValue(elem, attr, prop, val, metadata) {
            if (val == null) {
                return val;
            }
            function _coerceVal(value) {
                return AttributeUtils.attributeToPropertyValue(elem, attr, value, metadata);
            }
            var parseFunction = ojcustomelementRegistry.getElementDescriptor(elem.tagName)['parseFunction'];
            if (parseFunction) {
                return parseFunction(val, prop, metadata, function (value) {
                    return _coerceVal(value);
                });
            }
            return _coerceVal(val);
        }
    }
    CustomElementUtils._ELEMENT_STATE_KEY = '_ojElementState';
    CustomElementUtils._ELEMENT_BRIDGE_KEY = '_ojBridge';
    CustomElementUtils._ALLOW_RELOCATION_COUNT = 0;
    CustomElementUtils.VCOMP_INSTANCE = Symbol('vcompInstance');
    /**
     * Notifies JET framework that a subtree possibly containing JET components is being hidden with display:none style
     * This method should be used when subtree hidden travsersal is initiated outside of legacy jQueryUI widgets
     * @param elem The element at the root of the subtree hidden traversal
     * @ignore
     */
    CustomElementUtils.subtreeHidden = function (elem) {
        const legacyHideCB = CustomElementUtils._legacySubtreeHiddenInstanceCB;
        const instanceCB = legacyHideCB ? _executeWithSlotRelocationOn(legacyHideCB) : null;
        _applyHideShowToComponents(elem, instanceCB, null);
        _markSubtreeHidden(elem);
    };
    // Non-member function helpers
    const _deferTag = 'oj-defer';
    function _markSubtreeHidden(element) {
        element.classList.add(_OJ_SUBTREE_HIDDEN_CLASS);
    }
    function _unmarkSubtreeHidden(element) {
        element.classList.remove(_OJ_SUBTREE_HIDDEN_CLASS);
    }
    function _ojDeferCallback(elem) {
        if (elem.localName !== _deferTag) {
            return;
        }
        if (elem._activate) {
            elem._activate();
        }
        else {
            throw new Error('subtreeShown called before module ojs/ojdefer was loaded');
        }
    }
    function _executeWithSlotRelocationOn(callback) {
        return (elem) => {
            CustomElementUtils.allowSlotRelocation(true);
            try {
                callback(elem);
            }
            finally {
                CustomElementUtils.allowSlotRelocation(false);
            }
        };
    }
    function _applyHideShowToComponents(rootElem, instanceCB, activateDeferCB) {
        if (!instanceCB && !activateDeferCB) {
            return;
        }
        // Detect hidden without forcing a layout.
        function isHidden(elem) {
            let curr = elem;
            while (curr) {
                if (curr.nodeType === Node.DOCUMENT_NODE) {
                    return false; // Walked up to document.  Not hidden
                }
                if (curr.nodeType === Node.ELEMENT_NODE &&
                    curr.classList.contains(_OJ_SUBTREE_HIDDEN_CLASS)) {
                    return true;
                }
                curr = curr.parentNode;
            }
            return true; // Didn't find document, so it must be detached and therefore hidden.
        }
        /**
         * Both node lists must be in document order.
         * Return new array containing nodes in 'allNodes' that are not in 'hiddenNodes'
         * @private
         */
        function filterHidden(allNodes, hiddenNodes) {
            const shownNodes = [];
            let j = 0;
            for (var i = 0; i < hiddenNodes.length; i++) {
                var hidden = hiddenNodes[i];
                while (j < allNodes.length && allNodes[j] !== hidden) {
                    shownNodes.push(allNodes[j]);
                    j += 1;
                }
                j += 1;
            }
            while (j < allNodes.length) {
                shownNodes.push(allNodes[j]);
                j += 1;
            }
            return shownNodes;
        }
        function processFunc(element) {
            instanceCB?.(element);
            activateDeferCB?.(element);
        }
        if (!isHidden(rootElem)) {
            processFunc(rootElem);
            // Create selectors for jquery components and oj-defer as needed.
            const selectors = ['.oj-component-initnode'];
            if (activateDeferCB) {
                selectors.push(_deferTag);
            }
            const hiddenSelectors = [];
            selectors.forEach(function (s) {
                hiddenSelectors.push(`.${_OJ_SUBTREE_HIDDEN_CLASS} ${s}`);
                hiddenSelectors.push(`.${_OJ_PENDING_SUBTREE_HIDDEN_CLASS} ${s}`);
            });
            if (activateDeferCB) {
                // treat oj-defer nodes with the _OJ_SUBTREE_HIDDEN_CLASS class on them
                // the same way as the oj-defer nodes contained by an element with that class
                hiddenSelectors.push(`${_deferTag}.${_OJ_SUBTREE_HIDDEN_CLASS}`);
            }
            // Assemble a selector that gets all matches and the subset that are hidden
            const selector = selectors.join(',');
            const hiddenSelector = hiddenSelectors.join(',');
            // Fetch all matching elements and those that are hidden.
            // Use the second list to filter out hidden elements.
            const allNodes = rootElem.querySelectorAll(selector);
            const hiddenNodes = rootElem.querySelectorAll(hiddenSelector);
            var shownNodes = filterHidden(allNodes, hiddenNodes);
            shownNodes.forEach((el) => processFunc(el));
        }
    }

    /**
     * Handles instantiating and tracking the component lifecycle for a custom element.
     * A specific component model implementation may have a subclass with special logic.
     * See the ComponentState enum for descriptions of the component lifecycle.
     * @ignore
     */
    class ElementState {
        constructor(element) {
            // Set of properties that have been updated so we can check attribute
            // changes against to get the actual value since we don't reflect property sets back
            // to the DOM
            this.dirtyProps = new Set();
            // Keeps track of where the compnent is in the creation lifecycle
            this._componentState = ComponentState.WaitingToCreate;
            this._outerClasses = new Set();
            this.Element = element;
        }
        /**
         * Starts the component creation cycle. Called by the custom element when it is
         * connected to the DOM and not in a terminal state.
         */
        startCreationCycle() {
            if (this._isInErrorState())
                return;
            // If the component is being created for the first time, update state the state,
            // otherwise pickup where the component last left off. Note that the component state
            // could be at ApplyingBindings before it's connected to the DOM so we need to also check
            // if the preCreatedPromise has ever been created
            if (this._preCreatedPromise == null ||
                this._componentState === ComponentState.WaitingToCreate) {
                this._updateComponentState(ComponentState.Creating);
            }
            this._registerBusyState();
        }
        /**
         * Used to resolve busy states when the custom element is disconnected from the DOM before the
         * component has been created. Called by the custom element when it is
         * disconnected to the DOM and not in a terminal state.
         */
        pauseCreationCycle() {
            // If the component creation did not complete (either successfully or unsuccessfully),
            // resolve the busy state and save where the component last left off
            this._resolveBusyState();
        }
        /**
         * Resets the creation cycle so the component can be recreated as is the case for
         * VComponents when disconnected and reconnected.
         */
        resetCreationCycle() {
            // This is currently only used for VComponents.
            // No other component model re-creates the component on reconnect
            this._updateComponentState(ComponentState.WaitingToCreate);
            // Reset the creation promises so that the ComponentState gets updated properly
            this._bindingProviderPromise = null;
            this._preCreatedPromise = null;
            this._createdPromise = null;
        }
        /**
         * Returns true if the component has successfully been created and has
         * the oj-complete class applied.
         */
        isComplete() {
            return this._componentState === ComponentState.Complete;
        }
        /**
         * Returns true if the component creation cycle has already started.
         */
        isCreating() {
            return this._componentState === ComponentState.Creating;
        }
        /**
         * Returns true if the component has succcessfully passed
         * create component callback invocation or reached the complete
         * state.
         */
        isPostCreateCallbackOrComplete() {
            return this._componentState === ComponentState.PostCreateCallback || this.isComplete();
        }
        /**
         * Returns true if the component creation cycle is not in a terminal state and
         * not waiting to create. This helper is only used by the BaseCustomElementBridge
         * as there's an ordering issue in some components that prevent us from initializing
         * properties from DOM and playing back properties in the same callback as rendering
         * the component.
         */
        canHandleAttributes() {
            return !this._isInErrorState() && this._componentState !== ComponentState.WaitingToCreate;
        }
        /**
         * Indicates that bindings are being applied and called by the CustomElementBinding class.
         * Note that this could be called while the component is waiting to be created as in the case
         * of an oj-bind-for-each.
         */
        beginApplyingBindings() {
            // The component may not have a binding provider, but its parent may have a knockout
            // binding provider which could trigger this call after the component is complete
            if (!this.isComplete()) {
                // skip walking binding providers and set directly to knockout
                this._bindingProviderType = 'knockout';
                this._updateComponentState(ComponentState.ApplyingBindings);
            }
        }
        /**
         * Returns true if the custom element should accept property sets vs saving
         * them to be played back after data bound attribute values are resolved.
         */
        allowPropertySets() {
            // We can accept property sets w/o saving them to an early property sets queue
            // when we first initialize properties on connect, when applying bindings, and then
            // after bindings are applied and the component is created
            return (this._componentState === ComponentState.Creating ||
                this._componentState === ComponentState.ApplyingBindings ||
                this._componentState === ComponentState.BindingsApplied ||
                this._componentState === ComponentState.PostCreateCallback ||
                this._componentState === ComponentState.Complete);
        }
        /**
         * Returns true if the custom element should fire property changed events.
         * Property changed events are not fired for initial custom element values set
         * via attributes.
         */
        allowPropertyChangedEvents() {
            // We should fire property changed events for property sets after component is created
            return (this._componentState === ComponentState.BindingsApplied ||
                this._componentState === ComponentState.PostCreateCallback ||
                this._componentState === ComponentState.Complete);
        }
        /**
         * Returns the component child tracking option: 'none', 'immediate', or 'nearestCustomElement'.
         */
        getTrackChildrenOption() {
            // This setting is involved in tracking child elements used for slots
            // for VComponents created as custom elements. The method is called when the
            // element is connected to the DOM, but it is not created yet.
            // Tracking children is prevented for vcomp-first elements, since such elements are
            // rendered first and children are already passed to them through props.
            // The getTrackChildrenOption() is called on mount operation for already rendered component.
            // If tracking is not prevented at this point, the component would wait for its internal content.
            const metadata = ojcustomelementRegistry.getElementDescriptor(this.Element.tagName).metadata;
            return metadata?.extension?.['_TRACK_CHILDREN'] ?? 'none';
        }
        /**
         * Sets a callback to instantiate the component. The callback will be
         * called after the chain of promises for the binding provider,
         * child tracking, and any other component specific
         * (e.g. template engine promise) logic are resolved. The callback
         * should return a Promise if the component is created asynchronously
         * @param createComponentCallback
         */
        setCreateCallback(createComponentCallback) {
            // If we are in an error, e.g. bindings have been disposed, do not
            // try to start component creation
            if (this._isInErrorState())
                return;
            this._updateComponentState(ComponentState.WaitingForBindings);
            // Cache the pre create Promise for cases
            // where the component is removed and later reattached to the
            // DOM and we need to recreate the component (e.g. Preact Component)
            if (!this._preCreatedPromise) {
                this._preCreatedPromise = this.GetPreCreatedPromise();
            }
            // The createdPromise is used for child tracking and does not neet to wait on the
            // oj-complete class to be applied, just for the component to have been created so
            // properties can be inspected
            this._createdPromise = this._preCreatedPromise.then(() => {
                // Bindings may have been disposed causing the component to end up in a
                // error state after the creation process has begun so we need to check here as well
                if (!this._isInErrorState()) {
                    const createVal = createComponentCallback();
                    this._updateComponentState(ComponentState.PostCreateCallback);
                    return createVal;
                }
                return Promise.reject();
            });
            // When the created promise resolves/rejects we will resolve the busy state and set a class
            this._createdPromise.then(() => {
                this._updateComponentState(ComponentState.Complete);
            }, (error) => {
                this._updateComponentState(ComponentState.Incomplete);
                // If the binding provider is disposed, we will reject the binding provider promise,
                // but not throw an error so check to see if one was passed before rethrowing.
                if (error)
                    throw error;
            });
        }
        /**
         * Stores a callback that will be invoked when bindings are disposed for an
         * already-created component
         * @param callback
         */
        setBindingsDisposedCallback(callback) {
            this._disposedCallback = callback;
        }
        /**
         * Resolves the binding provider Promise.
         * @param provider
         */
        resolveBindingProvider(provider) {
            this._bpClean = provider.__CleanNode;
            if (this._resolveBindingProviderCallback) {
                this._bindingsApplied();
                this._resolveBindingProviderCallback(provider);
                this._resolveBindingProviderCallback = null;
                this._rejectBindingProviderCallback = null;
            }
            this._bindingProvider = provider;
        }
        /**
         * Rejects the binding provider Promise.
         * @param message
         */
        rejectBindingProvider(error) {
            if (this._rejectBindingProviderCallback) {
                this._rejectBindingProviderCallback(error);
                this._resolveBindingProviderCallback = null;
                this._rejectBindingProviderCallback = null;
            }
        }
        /**
         * Disposes a binding provider
         */
        disposeBindingProvider() {
            if (!this.isComplete()) {
                // The reject callback will check to see if the binding provider promise has previously been
                // rejected or resolved before rejecting since disposal can occur after the binding
                // provider has been resolved
                this.rejectBindingProvider();
                this._updateComponentState(ComponentState.BindingsDisposed);
            }
            else {
                this._disposedCallback?.();
            }
        }
        /**
         * Sets a callback that's called right before the binding
         * provider is resolved.
         * @param callback
         */
        setBindingProviderCallback(callback) {
            this._bindingProviderCallback = callback;
        }
        /**
         * Returns the binding provider Promise
         */
        getBindingProviderPromise() {
            const bpType = this.getBindingProviderType();
            if (!this._bindingProviderPromise) {
                // This call is totally unrelated to everything, but it's the best
                // chokepoint we have to validate the CSS version against the JET version
                // at a point where we should be guaranteed that the CSS has been loaded.
                ThemeUtils.verifyThemeVersion();
                if (bpType === 'none' || bpType === 'preact') {
                    this._bindingsApplied();
                    this._bindingProviderPromise = Promise.resolve(null);
                }
                else if (bpType === 'knockout') {
                    if (this._bindingProvider) {
                        this._bindingsApplied();
                        this._bindingProviderPromise = Promise.resolve(this._bindingProvider);
                    }
                    else {
                        this._bindingProviderPromise = new Promise((resolve, reject) => {
                            this._resolveBindingProviderCallback = resolve;
                            this._rejectBindingProviderCallback = reject;
                        });
                    }
                }
                else {
                    throw new JetElementError(this.Element, `Unknown binding provider '${bpType}'.`);
                }
            }
            return this._bindingProviderPromise;
        }
        /**
         * Returns the binding provider. This method should be called after GetPreCreatedPromise() is resolved.
         */
        getBindingProvider() {
            return this._bindingProvider;
        }
        /**
         * Returns the binding provider type, either 'none', 'knockout', or preact
         */
        getBindingProviderType() {
            if (!this._bindingProviderType) {
                this._bindingProviderType = ElementState._walkBindingProviders(this.Element);
            }
            return this._bindingProviderType;
        }
        getUseKoFlag() {
            if (this._useKoFlag === undefined) {
                this._useKoFlag = ElementState._findKoUseFlag(this.Element);
            }
            return this._useKoFlag;
        }
        /**
         * Returns binding provider's clean node function
         */
        getBindingProviderCleanNode() {
            return this._bpClean || ElementState._NOOP;
        }
        /**
         * Returns the label or descriptive text for Tracing.
         */
        getDescriptiveText() {
            let text = this.GetDescriptiveValue('aria-label') ||
                this.GetDescriptiveValue('title') ||
                this.GetDescriptiveLabelByValue('labelled-by') ||
                this.GetDescriptiveValue('label-hint') ||
                this.GetDescriptiveLabelByValue('aria-labelledby');
            if (text) {
                // Normalize whitespace to a single space
                text = text.trim().replace(/\s+/g, ' ');
            }
            else {
                text = '';
            }
            return text;
        }
        /**
         * Gets the stored slot map, creating one if the flag is specified.
         */
        getSlotMap(bCreate) {
            if (!this._slotMap && bCreate) {
                this._slotMap = CustomElementUtils.getSlotMap(this.Element);
            }
            return this._slotMap;
        }
        /**
         * Returns a set of the nodes representing top-level slot content
         * Guaranteed to be called after the slotMap has been created + stored
         */
        getSlotSet() {
            if (!this._slotSet) {
                // Cache a set of slot map nodes for faster look up.
                // Slot nodes should not be changing after initial render so this
                // should be safe.
                const keys = Object.keys(this._slotMap);
                let nodes = [];
                keys.forEach((key) => (nodes = nodes.concat(this._slotMap[key])));
                this._slotSet = new Set(nodes);
            }
            return this._slotSet;
        }
        /**
         * Updates the element classList based on the specified set of outer classes (i.e. classes
         * specified by the application or parent component)
         * @param outerClasses
         */
        setOuterClasses(outerClasses) {
            this.PatchClasses(this._outerClasses, outerClasses);
            this._outerClasses = outerClasses;
        }
        /**
         * Diffs two Sets of styleClass strings and updates the element classList accordingly
         * @param oldClasses
         * @param newClasses
         */
        PatchClasses(oldClasses, newClasses) {
            oldClasses.forEach((oldClass) => {
                if (!newClasses.has(oldClass)) {
                    this.Element.classList.remove(oldClass);
                }
            });
            newClasses.forEach((newClass) => {
                if (!oldClasses.has(newClass)) {
                    this.Element.classList.add(newClass);
                }
            });
        }
        /**
         * Returns a Promise that will be resolved when the component has been initialized
         * and property values can be inspected. Note that oj-complete/oj-incomplete classes
         * will have not yet be added to the custom element.
         * @return {Promise}
         */
        GetCreatedPromise() {
            return this._createdPromise;
        }
        /**
         * Returns a Promise that resolves when it's safe to call the create component callback.
         */
        GetPreCreatedPromise() {
            let preCreatePromise = this.getBindingProviderPromise();
            const trackOption = this.getTrackChildrenOption();
            if (trackOption !== 'none') {
                // this will return a Promise that will get automatically chained to the binding provider Promise
                preCreatePromise = preCreatePromise.then((bindingProvider) => {
                    return this._getTrackedChildrenPromises(bindingProvider);
                });
            }
            return preCreatePromise;
        }
        /**
         * Returns true if the given attribute is one that is moved
         * from the root element to a child element.
         * @param attrName
         */
        IsTransferAttribute(attrName) {
            return false;
        }
        /**
         * Returns the descriptive text of an attribute
         * @param attrName
         */
        GetDescriptiveValue(attrName) {
            const propName = AttributeUtils.attributeToPropertyName(attrName);
            const properties = ojcustomelementRegistry.getElementProperties(this.Element);
            // Get the descriptive value from:
            // 1. If the attribute is a declared property of the component, return the property
            // 2. If the atrribite gets moved off of the root element, fetch it from the new location
            // 3. Otherwise just return the attribute value.
            let value;
            if (properties && properties[propName]) {
                value = this.Element[propName];
            }
            else if (this.IsTransferAttribute(attrName)) {
                value = this.GetDescriptiveTransferAttributeValue(attrName);
            }
            else {
                value = this.Element.getAttribute(attrName);
            }
            return value;
        }
        /**
         * Returns the descritive text for a transfer attribute
         * @param attrName
         */
        GetDescriptiveTransferAttributeValue(attrName) {
            return '';
        }
        /**
         * Returns the label value of a "labelled-by" like attribute
         * @param attrName
         */
        GetDescriptiveLabelByValue(attrName) {
            const LabelBy = this.GetDescriptiveValue(attrName);
            if (LabelBy) {
                const label = document.getElementById(LabelBy);
                if (label) {
                    return label.textContent;
                }
            }
            return null;
        }
        /**
         * Updates the internal component state
         * @param state The new state
         */
        _updateComponentState(state) {
            // When bindings are disposed, the component is in a terminal,
            // error state that cannot be reset when disconnected/reconnected
            if (this._componentState !== ComponentState.BindingsDisposed) {
                switch (state) {
                    case ComponentState.WaitingToCreate:
                        // Reset flags so we can recreate the component
                        this.Element.classList.remove('oj-complete');
                        this._createdPromise = null;
                        break;
                    case ComponentState.Complete:
                        // Add marker class to unhide components
                        this.Element.classList.add('oj-complete');
                        this._resolveBusyState();
                        break;
                    case ComponentState.BindingsDisposed:
                    case ComponentState.Incomplete:
                        // Add marker class to mark that there was an error during upgrade so consumers like
                        // VBCS can apply their own styling to incorrectly setup custom elements.
                        this.Element.classList.add('oj-incomplete');
                        this._resolveBusyState();
                        break;
                    default:
                        break;
                }
                this._componentState = state;
            }
        }
        /**
         * Updates state to indicate that bindings have been applied and call
         * the binding provider callback as needed.
         */
        _bindingsApplied() {
            this._updateComponentState(ComponentState.BindingsApplied);
            this._bindingProviderCallback?.();
        }
        /**
         * Registers a busy state for while the component is waiting to be created.
         */
        _registerBusyState() {
            const busyContext = Context.getContext(this.Element).getBusyContext();
            if (this._resolveCreatedBusyState) {
                throw new JetElementError(this.Element, 'Registering busy state before previous state is resolved.');
            }
            this._resolveCreatedBusyState = busyContext.addBusyState({
                description: CustomElementUtils.getElementInfo(this.Element) + ' is being upgraded.'
            });
        }
        /**
         * Resolves the busy state stashed while the component is waiting to be created.
         */
        _resolveBusyState() {
            // If the component is disconnected, the busy state
            // must be already resolved
            if (this._resolveCreatedBusyState) {
                this._resolveCreatedBusyState();
                this._resolveCreatedBusyState = null;
            }
        }
        /**
         * Walks down the DOM tree looking for the data-oj-use-ko attribute on template that might be set
         * by VTemplateEngine on a nested template.
         * @param element The current element whose useKoFlag is being asked for
         * @returns
         */
        static _findKoUseFlag(element) {
            const template = element.querySelector(':scope > template[data-oj-use-ko]');
            return !!template;
        }
        /**
         * Walks up the DOM tree looking for the closest binding provider.
         * @param element The current element whose binding provider is being asked for
         * @param startElement The element that began this recursive walk, used for reporting errors
         */
        static _walkBindingProviders(element, startElement = element) {
            // If not defined on the current node, find the binding provider by walking up the
            // DOM tree. The binding provider could be set for the following cases:
            // 1) The current element could have an implicit binding provider due to being
            //    rendered by the parent as would be the case for elements inside of a composite view or
            //    a Preact render.
            // 2) The node could be stamped by the template engine and have knockout as its binding provider
            //    which may be different than the parent node's binding provider.
            // 3) The node could be rendered in the same context as the parent with the binding provider, e.g.
            //    slot content or the general case of elements in the same html page.
            let name = element[CACHED_BINDING_PROVIDER];
            if (name) {
                return name;
            }
            name = element.getAttribute('data-oj-binding-provider');
            if (!name) {
                const parent = element.parentElement;
                if (parent == null) {
                    if (element === document.documentElement) {
                        name = 'knockout'; // the default
                    }
                    else {
                        throw new JetElementError(startElement, 'Cannot determine binding provider for a disconnected subtree.');
                    }
                }
                else {
                    name =
                        parent[CHILD_BINDING_PROVIDER] ??
                            ElementState._walkBindingProviders(parent, startElement);
                }
            }
            // cache provider name as a non-enumerable property
            element[CACHED_BINDING_PROVIDER] = name;
            return name;
        }
        /**
         * Returns a Promise for tracked children which resolves when the children
         * are created which means on waiting for Promises from:
         * o customElements.whenDefined() for unloaded custom elements
         * o component created Promise
         * @param bindingProvider
         */
        _getTrackedChildrenPromises(bindingProvider) {
            const _UPGRADE_MESSAGE_INTERVAL = 20000;
            const trackOption = this.getTrackChildrenOption();
            const busyContext = Context.getContext(this.Element).getBusyContext();
            const trackedElements = this._getChildrenToTrack(this.Element, trackOption, []);
            // map tracked elements to Promises
            const promises = trackedElements.map((trackedElement) => {
                // 1) if bindingProvider is null, then we don't expect to discover knockout custom components -
                //    wait for all components to be defined, then wait for JET components to be created
                // 2) if bindingProvider is knockout, then child JET components should already be registered -
                //    no need to wait for whenDefined, just wait for JET components to be created
                if (!bindingProvider) {
                    // register busy state for the element
                    const resolveElementDefinedBusyState = busyContext.addBusyState({
                        description: `Waiting for element ${trackedElement.localName} to be defined.`
                    });
                    // setup a timer to log 'waiting' message for an element
                    const timer = setInterval(() => {
                        Logger.warn(`Waiting for element ${trackedElement.localName} to be defined.`);
                    }, _UPGRADE_MESSAGE_INTERVAL);
                    // return a Promise that will be resolved, when element is defined and created
                    return customElements
                        .whenDefined(trackedElement.localName)
                        .then(() => {
                        resolveElementDefinedBusyState();
                        clearInterval(timer);
                        if (ojcustomelementRegistry.isElementRegistered(trackedElement.tagName)) {
                            return CustomElementUtils.getElementState(trackedElement).GetCreatedPromise();
                        }
                        return null;
                    })
                        .catch((error) => {
                        resolveElementDefinedBusyState();
                        clearInterval(timer);
                        throw new Error(`Error defining element ${trackedElement.localName} : ${error}`);
                    });
                }
                else if (ojcustomelementRegistry.isElementRegistered(trackedElement.tagName)) {
                    return CustomElementUtils.getElementState(trackedElement).GetCreatedPromise();
                }
                return null; // knockout binding provider, but the component is not JET component
            });
            return Promise.all(promises);
        }
        /**
         * Returns a list of children to track.
         * @param element
         * @param trackOption
         * @param trackedElements
         */
        _getChildrenToTrack(element, trackOption, trackedElements) {
            const children = element.childNodes;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (ElementUtils.isValidCustomElementName(child.localName)) {
                    trackedElements.push(child);
                }
                else if (trackOption === 'nearestCustomElement') {
                    this._getChildrenToTrack(child, trackOption, trackedElements);
                }
            }
            return trackedElements;
        }
        _isInErrorState() {
            return (this._componentState === ComponentState.Incomplete ||
                this._componentState === ComponentState.BindingsDisposed);
        }
    }
    ElementState._NOOP = () => { };
    var ComponentState;
    (function (ComponentState) {
        /* The initial and reset state of the component */
        ComponentState[ComponentState["WaitingToCreate"] = 0] = "WaitingToCreate";
        /* The component can accept property sets in this state while it initializes
          properties from the current DOM */
        ComponentState[ComponentState["Creating"] = 1] = "Creating";
        /* A state mainly used to indicate that property sets should be saved to playback
          after bindings are applied */
        ComponentState[ComponentState["WaitingForBindings"] = 2] = "WaitingForBindings";
        /* A component can jump to this state directly from WaitingToCreate since
          bindings can be applied to disconnected DOM as in the case of oj-bind-for-each.
          Also note that non data bound components may skip this state. */
        ComponentState[ComponentState["ApplyingBindings"] = 3] = "ApplyingBindings";
        /* Indicates bindings have been applied (applies to none binding providers as well)
          and that it is safe to accept property sets as they come in and fire property changed events */
        ComponentState[ComponentState["BindingsApplied"] = 4] = "BindingsApplied";
        /* Indicates that the createComponentCallback has been invoked.  We need to track this in
           order to know when it is safe to enable our Preact slot management hacks.  Note that
           reaching this state does not necessarily mean that the component has rendered its content, as
           composite components can delay rendering by returning a Promise from the activated lifecycle
           method.  However, slot maps are populated synchronously in response to the
           createComponentCallback being innvoked, and once we are past that it is safe to enable
           our Preact workarounds.  */
        ComponentState[ComponentState["PostCreateCallback"] = 5] = "PostCreateCallback";
        /* A terminal state (unless reset) where a component has successfully been created */
        ComponentState[ComponentState["Complete"] = 6] = "Complete";
        /* A terminal state (unless reset) where an error was thrown during component creation */
        ComponentState[ComponentState["Incomplete"] = 7] = "Incomplete";
        /* A non resettable terminal state. Once the binding provider has been disposed during creation,
          the component cannot be reset from this error state unlike for the Complete and Incomplete
          terminal states*/
        ComponentState[ComponentState["BindingsDisposed"] = 8] = "BindingsDisposed";
    })(ComponentState || (ComponentState = {}));

    /**
     * Extends ElementState with functionality needed by VComponentState and CompositeState.
     * Composite components as well VComponents have customer defined implementation
     * and need additional steps to cleanup and restore components on lifecycle events.
     * @ignore
     */
    class LifecycleElementState extends ElementState {
        constructor() {
            super(...arguments);
            this._connectCallbacks = [];
            this._disconnectCallbacks = [];
        }
        /**
         * Specify connect/disconnect callbacks that will
         * be called on _verifiedConnect() and _verifiedDisconnect()
         * @param connectFunc
         * @param disconnectFunc
         */
        addLifecycleCallbacks(connectFunc, disconnectFunc) {
            if (connectFunc) {
                this._connectCallbacks.push(connectFunc);
            }
            if (disconnectFunc) {
                this._disconnectCallbacks.push(disconnectFunc);
            }
        }
        /**
         * Remove connect/disconnect callbacks that will
         * be called on _verifiedConnect() and _verifiedDisconnect().
         * @param connectFunc
         * @param disconnectFunc
         */
        removeLifecycleCallbacks(connectFunc, disconnectFunc) {
            if (connectFunc) {
                this._connectCallbacks = this._connectCallbacks.filter((item) => item != connectFunc);
            }
            if (disconnectFunc) {
                this._disconnectCallbacks = this._disconnectCallbacks.filter((item) => item != disconnectFunc);
            }
        }
        /**
         * Used by _verifiedConnect() and _verifiedDisconnect() to execute
         * specified callbacks.
         * @param isConnected true for connected state
         */
        executeLifecycleCallbacks(isConnected) {
            const callbacks = isConnected ? this._connectCallbacks : this._disconnectCallbacks;
            callbacks.forEach((callback) => callback());
        }
    }

    const NULL_SYMBOL = Symbol('custom element null');
    const EMPTY_STRING_SYMBOL = Symbol('custom element empty string');
    const UNDEFINED_SYMBOL = Symbol('custom element undefined');
    const PRIVATE_VALUE_KEY = '__oj_private_do_not_use_value';
    const PRIVATE_CHECKED_KEY = '__oj_private_do_not_use_checked';
    const publicToPrivateName = new Map([
        ['value', PRIVATE_VALUE_KEY],
        ['checked', PRIVATE_CHECKED_KEY]
    ]);
    const toSymbolizedValue = (value) => {
        if (value === null) {
            return NULL_SYMBOL;
        }
        if (value === '') {
            return EMPTY_STRING_SYMBOL;
        }
        if (value === undefined) {
            return UNDEFINED_SYMBOL;
        }
        return value;
    };
    /**
     * The method is used exclusively by private 'value'/'checked' setters that
     * are used by Preact. Note that Preact will pass an empty string for
     * a skipped property which should be recognized as undefined.
     * @param value
     * @returns
     */
    const fromSymbolizedValue = (value) => {
        if (value === NULL_SYMBOL) {
            return null;
        }
        if (value === EMPTY_STRING_SYMBOL) {
            return '';
        }
        if (value === UNDEFINED_SYMBOL || value === '') {
            return undefined;
        }
        return value;
    };
    /**
     * Handles JET-42984 where Preact will convert null/undefined values to
     * the empty string and set them as property values. We will convert empty strings
     * to undefined if the property does not support string types or is an enum.
     * @param element the HTML element
     * @param propertyMeta The property metadata
     * @param value The value
     * @returns The original value or undefined
     */
    const convertEmptyStringToUndefined = (element, propertyMeta, value) => {
        if (!element ||
            CustomElementUtils.getElementState(element).getBindingProviderType() === 'preact') {
            const types = ElementUtils.getSupportedTypes(propertyMeta.type);
            if (!types.string || propertyMeta.enumValues) {
                return undefined;
            }
        }
        return value;
    };
    /**
     * Transforms values from preact renders to their original values for use by JET
     * custom elements
     *
     * @param element (optional) JET custom element.  If an element is passed, empty string conversion will only be done
     * for preact binding providers.  If no element is passed, empty string conversion will be done unconditionally
     * @param propertyName The property name
     * @param propertyMeta The property metadata
     * @param originalValue The value
     * @returns The transformed value
     */
    const transformPreactValue = (element, propertyName, propertyMeta, originalValue) => {
        let value = originalValue;
        // Note that conversion of symbolized values for 'value' and 'checked' properties happen in private
        // setters added to component prototypes.
        if (propertyName !== 'value' && propertyName !== 'checked') {
            // We only want to do this transformation for empty strings that preact's diffing code
            // passing via direct property assignment
            if (value === '') {
                value = convertEmptyStringToUndefined(element, propertyMeta, value);
            }
        }
        return value;
    };
    /**
     * Utility method used by resolveVDomTemplateProps() on TemplateEngine to resolve
     * properties for DVT component templates. The method converts both name and value
     * of private props ('value' and 'checked') into its original form.
     * @param prop
     * @param value
     * @returns
     */
    const convertPrivatePropFromPreact = (prop, value) => {
        if (prop === PRIVATE_VALUE_KEY) {
            return { prop: 'value', value: fromSymbolizedValue(value) };
        }
        if (prop === PRIVATE_CHECKED_KEY) {
            return { prop: 'checked', value: fromSymbolizedValue(value) };
        }
        return { prop, value };
    };
    /**
     * Utility method that defines private property setters and getters
     * on the component prototype for the 'value' and 'checked' properties
     * that are treated differently in Preact.
     * The goal is to convert those properties to private and force Preact
     * to handle them as regular properties.
     * @param proto
     * @param property
     */
    const addPrivatePropGetterSetters = (proto, property) => {
        if (property === 'value' || property === 'checked') {
            Object.defineProperty(proto, publicToPrivateName.get(property), {
                get() {
                    return this[property];
                },
                set(newValue) {
                    this[property] = fromSymbolizedValue(newValue);
                }
            });
        }
    };

    const OJ_BIND_CONVERTED_NODE = Symbol('ojBindConvertedNode');

    exports.AttributeUtils = AttributeUtils;
    exports.CACHED_BINDING_PROVIDER = CACHED_BINDING_PROVIDER;
    exports.CHILD_BINDING_PROVIDER = CHILD_BINDING_PROVIDER;
    exports.CustomElementUtils = CustomElementUtils;
    exports.ElementState = ElementState;
    exports.ElementUtils = ElementUtils;
    exports.JetElementError = JetElementError;
    exports.KoBindingUtils = KoBindingUtils;
    exports.LifecycleElementState = LifecycleElementState;
    exports.OJ_BIND_CONVERTED_NODE = OJ_BIND_CONVERTED_NODE;
    exports.addPrivatePropGetterSetters = addPrivatePropGetterSetters;
    exports.convertPrivatePropFromPreact = convertPrivatePropFromPreact;
    exports.publicToPrivateName = publicToPrivateName;
    exports.toSymbolizedValue = toSymbolizedValue;
    exports.transformPreactValue = transformPreactValue;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojconfig',['require', 'exports', 'ojs/ojcore-base', 'ojL10n!ojtranslations/nls/ojtranslations', 'ojs/ojcustomelement-utils'], function (require, exports, oj, ojt, ojcustomelementUtils) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = {};
      if (e) {
        Object.keys(e).forEach(function (k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        });
      }
      n['default'] = e;
      return n;
    }
  }

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  ojt = ojt && Object.prototype.hasOwnProperty.call(ojt, 'default') ? ojt['default'] : ojt;

  /**
   * @namespace oj.Config
   * @hideconstructor
   * @classdesc Services for setting and retrieving configuration options
   * @since 1.0
   * @ojtsmodule
   * @export
   * @ojtsimport {module: "ojcspexpressionevaluator", type: "AMD", importName: "CspExpressionEvaluator"}
   */
  const Config = {};

  const TEMPLATE_ENGINE_KO = Symbol();
  const PREACT_TEMPLATE_PROMISE = Symbol();

  let trans = ojt;
  let deploymentMode = 'production';

  /**
   * Retrieves the render mode the application should use.  This allows the application to render content
   * differently based on the type of device.
   * <p>By default, this function returns the value from getDeviceType.</p>
   * <p>An application can override it by adding a "data-oj-device-render-mode" attribute with the desired value
   * to the document body.  This may be useful in simulating the look of one device type on a different device type,
   * such as simulating the look of "phone" on a destop computer.</p>
   *
   * @memberof oj.Config
   * @method getDeviceRenderMode
   * @return {"phone" | "tablet" | "others"} The render mode
   * @export
   */
  Config.getDeviceRenderMode = function () {
    return document.body.getAttribute('data-oj-device-render-mode') || Config.getDeviceType();
  };

  /**
   * Retrieves the type of device the application is running on.  This allows the application to behave
   * differently based on the type of device.
   * <p>This function always return the actual device type.  Use getDeviceRenderMode if the application wants
   * to render content differently based on the device type, including simulated device type.</p>
   *
   * @memberof oj.Config
   * @method getDeviceType
   * @return {"phone" | "tablet" | "others"} The device type
   * @export
   */
  Config.getDeviceType = function () {
    return oj.AgentUtils.getAgentInfo().deviceType;
  };

  /**
   * Retrieves the current locale
   * @memberof oj.Config
   * @method getLocale
   * @return {string} current locale
   * @export
   */
  Config.getLocale = function () {
    const rl = trans._ojLocale_;

    // If Require.js internationalziation plugin resolved the locale to "root" (presumably because "lang" attribute was not
    // set, and neither navigator.language or navigator.userLanguage were not available), return "en"
    return rl === 'root' ? 'en' : rl;
  };

  /**
   * Changes the current locale dynamically.
   * Dynamically changing the UI locale often ends up with the UI in mixed languages
   * or locales because the application may have cached data that are locale sensitive.
   * <p>
   * The preferred method to change the locale is to reload the page
   * and either set the 'lang' attribute on the html element of the page
   * generated on the server, or set the 'locale' option for the
   * ojL10n plugin on the client when requireJS is configured.
   * </p>
   * @method setLocale
   * @param {string} locale (language code and subtags separated by dash)
   * @param {function(): void} [callback] this optional callback will be invoked when the framework is done loading
   * its translated resources and Locale Elements for the newly specified locale.
   * @return {undefined}
   * @export
   * @memberof oj.Config
   */
  Config.setLocale = function (locale, callback) {
    var prefix = 'ojL10n!ojtranslations/nls/';
    var translationBundle = prefix + locale + '/ojtranslations';
    /* ojWebpackError: 'Config.setLocale() is not supported when the ojs/ojcore module has been bundled by Webpack' */
    const translationPromise = new Promise(function (resolve, reject) { require([translationBundle], function (m) { resolve(_interopNamespace(m)); }, reject) }).then((translations) => {
      trans = translations;
    });
    var promises = [translationPromise];

    // Request LocaleElements only if the ojs/ojlocaledata module is loaded;
    // oj.LocaleData will exist in that case.
    // Validators/Converters that need locale data import ojs/ojlocaledata
    // themselves.
    // If you're just using Config.setLocale to change your
    // translation bundle, this code will do that without
    // incurring the download hit of the ojs/ojlocaledata module.
    if (oj.LocaleData) {
      var localeBundle = prefix + locale + '/localeElements';
      const localePromise = new Promise(function (resolve, reject) { require([localeBundle], function (m) { resolve(_interopNamespace(m)); }, reject) }).then((localeElements) => {
        if (localeElements) {
          oj.LocaleData.__updateBundle(Object.assign({}, localeElements.default));
        }
      });
      promises.push(localePromise);
      if (oj.TimezoneData) {
        var tzBundlesPromises = oj.TimezoneData.__getBundleNames().map((bundleName) =>
          new Promise(function (resolve, reject) { require([`${prefix}${locale}${bundleName}`], function (m) { resolve(_interopNamespace(m)); }, reject) })
        );
        promises.push(
          Promise.all(tzBundlesPromises).then((timezoneBundles) => {
            timezoneBundles.forEach(oj.TimezoneData.__mergeIntoLocaleElements);
          })
        );
      }
    }
    Promise.all(promises).then(() => {
      if (callback) {
        callback();
      }
    });
  };

  /**
   * Retrieves a URL for loading a component-specific resource.
   * The URL is resolved as follows:
   * 1. If the application has specified a base URL with setResourceBaseUrl(), the return values will be
   * a relative path appended to the base URL.
   * 2. Otherwise, if the application running with an AMD Loader (such as Require.js), the parent folder of a
   * module with ojs/ mapping will be used as a base URL.
   * 3. Otherwise, the original relative path will be returned.
   * @method getResourceUrl
   * @param {string} relativePath resource path
   * @return {string} resource URL
   * @see oj.Config.setResourceBaseUrl
   * @export
   * @memberof oj.Config
   */
  Config.getResourceUrl = function (relativePath) {
    // Returning null and full URLs (containing protocol or a leading slash) as is
    var fullUrlExp = /^\/|:/;

    if (relativePath == null || fullUrlExp.test(relativePath)) {
      return relativePath;
    }

    var base = Config._resourceBaseUrl;

    if (base == null) {
      base = Config._getOjBaseUrl() || '';
    }

    var len = base.length;
    return base + (len === 0 || base.charAt(len - 1) === '/' ? '' : '/') + relativePath;
  };

  /**
   * Sets the base URL for retrieving component-specific resources
   * @method setResourceBaseUrl
   * @param {string} baseUrl base URL
   * @return {undefined}
   * @see oj.Config.getResourceUrl
   * @export
   * @memberof oj.Config
   */
  Config.setResourceBaseUrl = function (baseUrl) {
    Config._resourceBaseUrl = baseUrl;
  };

  /**
   * Sets the automation mode.
   * @method setAutomationMode
   * @param {string} mode "enabled" for running in automation mode
   * @return {undefined}
   * @see oj.Config.getAutomationMode
   * @export
   * @memberof oj.Config
   */
  Config.setAutomationMode = function (mode) {
    Config._automationMode = mode;
  };

  /**
   * Gets the automation mode.
   * @method getAutomationMode
   * @return {string} automation mode
   * @see oj.Config.setAutomationMode
   * @export
   * @memberof oj.Config
   */
  Config.getAutomationMode = function () {
    return Config._automationMode;
  };

  /**
   * Return a string containing important version information about JET and the libraries
   * it has loaded
   * @method getVersionInfo
   * @return {string}
   * @export
   * @memberof oj.Config
   */
  Config.getVersionInfo = function () {
    // JET information
    var info = 'Oracle JET Version: ' + oj.version + '\n';
    info += 'Oracle JET Revision: ' + oj.revision + '\n';

    var windowDefined = typeof window !== 'undefined';

    // Browser information
    if (windowDefined && window.navigator) {
      info += 'Browser: ' + window.navigator.userAgent + '\n';
      info += 'Browser Platform: ' + window.navigator.platform + '\n';
    }

    // 3rd party libraries
    if ($) {
      if ($.fn) {
        info += 'jQuery Version: ' + $.fn.jquery + '\n';
      }
      if ($.ui && $.ui.version) {
        info += 'jQuery UI Version: ' + $.ui.version + '\n';
      }
    }
    if (oj.ComponentBinding) {
      info += 'Knockout Version: ' + oj.ComponentBinding.__getKnockoutVersion() + '\n';
    }

    // Local require doesn't have version #
    if (windowDefined && window.require) {
      info += 'Require Version: ' + window.require.version + '\n';
    }

    return info;
  };

  /**
   * Dump information to the browser's console containing important version information about JET and
   * the libraries it has loaded
   * @method logVersionInfo
   * @return {undefined}
   * @memberof oj.Config
   * @export
   */
  Config.logVersionInfo = function () {};

  /**
   * This method gets replaced at build time. For AMD, RequireJS is used. For ESM,
   * it remains blank.
   * When bundled with Webpack, JET's WebpackRequireFixupPlugin will replace the
   * contents to return the correct relative path for the base.
   * @private
   * @ignore
   */
  
  Config._getOjBaseUrl = function () {
    var base = null;
    if (typeof require !== 'undefined' && require.toUrl) {
      // : use ojs/_foo_ instead of ojs/ojcore to handle the case when ojs.core ends up in a partition bundle
      // in a different location
      var modulePath = require.toUrl('ojs/_foo_');
      base = modulePath.replace(/[^/]*$/, '../');
    }
    return base;
  };

  /**
   * Returns specified template engine promise.
   * Dynamically loads and stores the engine on Config object at the first request.
   * @private
   * @ignore
   */
  Config._getEngineByType = function (templateProp) {
    if (!Config[templateProp]) {
      let promise;
      switch (templateProp) {
        case PREACT_TEMPLATE_PROMISE:
          promise = new Promise(function (resolve, reject) { require(['ojs/ojtemplateengine-preact'], function (m) { resolve(_interopNamespace(m)); }, reject) });
          break;
        case TEMPLATE_ENGINE_KO:
        default:
          promise = new Promise(function (resolve, reject) { require(['ojs/ojtemplateengine-ko'], function (m) { resolve(_interopNamespace(m)); }, reject) });
      }
      Config[templateProp] = promise.then((engine) => engine.default);
    }
    return Config[templateProp];
  };

  /**
   * Retrives JET's template engine for dealing with inline templates (currently internal only).
   * The method checks whether component might need 'knockout' module and loads the corresponding
   * TemplateEngine.
   * @param {Object} options An object with the following props:
   *  - customElement - Element - root custom element
   *  - needsTrackableProperties - boolean - optional property that indicates a need for tracking observables
   * @ignore
   * @memberof oj.Config
   * @private
   */
  Config.__getTemplateEngine = function (options) {
    let enginePromise;
    const state = ojcustomelementUtils.CustomElementUtils.getElementState(options.customElement);
    const bpType = state.getBindingProviderType();
    if (bpType !== 'preact' || options.needsTrackableProperties || state.getUseKoFlag()) {
      // legacy component or Preact component that needs knockout - lets use template engine with knockout
      enginePromise = Config._getEngineByType(TEMPLATE_ENGINE_KO);
    } else {
      // Preact component without knockout - lets use plain preact template engine that does not track observables.
      enginePromise = Config._getEngineByType(PREACT_TEMPLATE_PROMISE);
    }

    return enginePromise;
  };

  /**
   * Returns ojtranslation module. Called by oj.Translations, in this way we can make sure that the ojtranslation module
   * instance is shared between Config and Translations.
   * @ignore
   * @memberof oj.Config
   * @private
   */
  Config.getConfigBundle = function () {
    return trans;
  };

  /**
   * Returns expression evaluator
   * @return {undefined | Object}
   * @ignore
   * @export
   * @memberof oj.Config
   * @since 7.1.0
   */
  Config.getExpressionEvaluator = function () {
    return Config._expressionEvaluator;
  };

  /**
   * Sets an optional CSP-compliant expression evaluator for the JET binding provider and JET ExpressionUtils.
   * This method can only be called once and must be called before applying
   * knockout bindings in the application for the first time.
   * @see <a href="oj.CspExpressionEvaluator.html">CspExpressionEvaluator</a>
   * @method setExpressionEvaluator
   * @param {Object} expressionEvaluator An instance of CspExpressionEvaluator class
   * @return {undefined}
   * @memberof oj.Config
   * @ojshortdesc Sets a CSP-compliant expression evaluator.
   * @export
   * @ojsignature {target:"Type", value: "oj.CspExpressionEvaluator", for: "expressionEvaluator"}
   * @since 7.1.0
   */
  Config.setExpressionEvaluator = function (expressionEvaluator) {
    if (Config._expressionEvaluator) {
      throw new Error("JET Expression evaluator can't be set more than once.");
    }

    Config._expressionEvaluator = expressionEvaluator;
  };

  /**
   * Sets mode value for the application deployment.
   * @method setDeploymentMode
   * @param {string} mode Accepted values 'production' or 'development'
   * @return {undefined}
   * @memberof oj.Config
   * @ojshortdesc Sets mode value for the application deployment.
   * @export
   * @ojsignature {target:"Type", value: "'production'|'development'", for: "mode"}
   * @since 16.0.0
   */
  Config.setDeploymentMode = function (mode) {
    if (mode === 'production' || mode === 'development') {
      deploymentMode = mode;
    } else {
      throw new Error("Expected values for deployment mode are 'production' or 'development'.");
    }
  };

  /**
   * Gets application deployment mode.
   * @method getDeploymentMode
   * @return {string} 'production' or 'development'
   * @memberof oj.Config
   * @ojshortdesc Gets application deployment mode.
   * @export
   * @ojsignature {target:"Type", value: "'production'|'development'", for: "returns"}
   * @since 16.0.0
   */
  Config.getDeploymentMode = function () {
    return deploymentMode;
  };

  const getDeviceRenderMode = Config.getDeviceRenderMode;
  const getDeviceType = Config.getDeviceType;
  const getLocale = Config.getLocale;
  const setLocale = Config.setLocale;
  const getResourceUrl = Config.getResourceUrl;
  const setResourceBaseUrl = Config.setResourceBaseUrl;
  const setAutomationMode = Config.setAutomationMode;
  const getAutomationMode = Config.getAutomationMode;
  const getVersionInfo = Config.getVersionInfo;
  const logVersionInfo = Config.logVersionInfo;
  const setExpressionEvaluator = Config.setExpressionEvaluator;
  const getExpressionEvaluator = Config.getExpressionEvaluator;
  const getConfigBundle = Config.getConfigBundle;
  const __getTemplateEngine = Config.__getTemplateEngine;
  const setDeploymentMode = Config.setDeploymentMode;
  const getDeploymentMode = Config.getDeploymentMode;

  exports.__getTemplateEngine = __getTemplateEngine;
  exports.getAutomationMode = getAutomationMode;
  exports.getConfigBundle = getConfigBundle;
  exports.getDeploymentMode = getDeploymentMode;
  exports.getDeviceRenderMode = getDeviceRenderMode;
  exports.getDeviceType = getDeviceType;
  exports.getExpressionEvaluator = getExpressionEvaluator;
  exports.getLocale = getLocale;
  exports.getResourceUrl = getResourceUrl;
  exports.getVersionInfo = getVersionInfo;
  exports.logVersionInfo = logVersionInfo;
  exports.setAutomationMode = setAutomationMode;
  exports.setDeploymentMode = setDeploymentMode;
  exports.setExpressionEvaluator = setExpressionEvaluator;
  exports.setLocale = setLocale;
  exports.setResourceBaseUrl = setResourceBaseUrl;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojresponsiveutils',['exports', 'ojs/ojcore-base', 'ojs/ojlogger'], function (exports, oj, Logger) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @namespace
   * @classdesc Utilities for working with the framework's responsive screen widths
   * and ranges. Often used in conjunction with {@link oj.ResponsiveKnockoutUtils}
   * to create knockout observables that can be used to drive responsive page behavior.
   * See the method doc below for specific examples.
   * @ojtsmodule
   * @since 1.1.0
   * @hideconstructor
   * @export
   */
  const ResponsiveUtils = {};
  oj._registerLegacyNamespaceProp('ResponsiveUtils', ResponsiveUtils);
  /**
   * Enum type that defines the framework query key.
   * @typedef {Object} ResponsiveUtils.FrameworkQueryKey
   * @ojvalue {string} 'sm-up'
   * @ojvalue {string} 'md-up'
   * @ojvalue {string} 'lg-up'
   * @ojvalue {string} 'xl-up'
   * @ojvalue {string} 'xxl-up'
   * @ojvalue {string} 'sm-only'
   * @ojvalue {string} 'md-only'
   * @ojvalue {string} 'lg-only'
   * @ojvalue {string} 'xl-only'
   * @ojvalue {string} 'md-down'
   * @ojvalue {string} 'lg-down'
   * @ojvalue {string} 'xl-down'
   * @ojvalue {string} 'high-resolution'
   */

  /**
   * Enum type that defines the screen range.
   * @typedef {Object} ResponsiveUtils.ScreenRange
   * @ojvalue {string} "sm"
   * @ojvalue {string} "md"
   * @ojvalue {string} "lg"
   * @ojvalue {string} "xl"
   * @ojvalue {string} "xxl"
   */

  /**
   * <p>In the jet sass files there are variables for
   * responsive screen widths, these look something like</p>
   *  <ul>
   *    <li>$screenSmallRange: 0, 599.9px;</li>
   *    <li>$screenMediumRange: 600px, 1023.9px;</li>
   *    <li>$screenLargeRange: 1024px, 1439.9px;</li>
   *    <li>$screenXlargeRange: 1440px, null;</li>
   *  </ul>
   *
   * <p>These constants are used to identify these ranges.</p>
   * @memberof ResponsiveUtils
   * @alias SCREEN_RANGE
   * @type {Object}
   * @constant
   * @property {ResponsiveUtils.ScreenRange} SM
   * @property {ResponsiveUtils.ScreenRange} MD
   * @property {ResponsiveUtils.ScreenRange} LG
   * @property {ResponsiveUtils.ScreenRange} XL
   * @property {ResponsiveUtils.ScreenRange} XXL
   * @export
   */
  ResponsiveUtils.SCREEN_RANGE = {
    SM: 'sm',
    MD: 'md',
    LG: 'lg',
    XL: 'xl',
    XXL: 'xxl'
  };

  /**
   * <p>In the jet sass files there are variables for
   * responsive screen widths,
   * see {@link ResponsiveUtils.SCREEN_RANGE} for details.
   * The jet sass files also has variables for
   * responsive queries like $responsiveQuerySmallUp,
   * $responsiveQuerySmallOnly, $responsiveQueryMediumUp, etc.</p>
   *
   * <p>These constants are used to identify these queries.</p>
   * @memberof ResponsiveUtils
   * @alias FRAMEWORK_QUERY_KEY
   * @type {Object}
   * @constant
   * @property {ResponsiveUtils.FrameworkQueryKey} SM_UP Matches screen width small and wider
   * @property {ResponsiveUtils.FrameworkQueryKey} MD_UP Matches screen width medium and wider
   * @property {ResponsiveUtils.FrameworkQueryKey} LG_UP Matches screen width large and wider
   * @property {ResponsiveUtils.FrameworkQueryKey} XL_UP Matches screen width extra-large and wider
   * @property {ResponsiveUtils.FrameworkQueryKey} XXL_UP Matches screen width extra-extra-large and wider
   * @property {ResponsiveUtils.FrameworkQueryKey} SM_ONLY Matches screen width small only
   * @property {ResponsiveUtils.FrameworkQueryKey} MD_ONLY Matches screen width medium only
   * @property {ResponsiveUtils.FrameworkQueryKey} LG_ONLY Matches screen width smalargell only
   * @property {ResponsiveUtils.FrameworkQueryKey} XL_ONLY Matches screen width extra-large only
   * @property {ResponsiveUtils.FrameworkQueryKey} MD_DOWN Matches screen width medium and narrower
   * @property {ResponsiveUtils.FrameworkQueryKey} LG_DOWN Matches screen width large and narrower
   * @property {ResponsiveUtils.FrameworkQueryKey} XL_DOWN Matches screen width extra-large and narrower
   * @property {ResponsiveUtils.FrameworkQueryKey} HIGH_RESOLUTION matches high resolution screens
   * @export
   */
  ResponsiveUtils.FRAMEWORK_QUERY_KEY = {
    SM_UP: 'sm-up',
    MD_UP: 'md-up',
    LG_UP: 'lg-up',
    XL_UP: 'xl-up',
    XXL_UP: 'xxl-up',
    SM_ONLY: 'sm-only',
    MD_ONLY: 'md-only',
    LG_ONLY: 'lg-only',
    XL_ONLY: 'xl-only',
    MD_DOWN: 'md-down',
    LG_DOWN: 'lg-down',
    XL_DOWN: 'xl-down',
    HIGH_RESOLUTION: 'high-resolution'
  };

  // used by the compare function
  ResponsiveUtils._RANGE = {};
  ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.SM] = 0;
  ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.MD] = 1;
  ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.LG] = 2;
  ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.XL] = 3;
  ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.XXL] = 4;

  /**
   * This idea/code is from zurb foundation, thanks zurb!
   *
   * In the jet sass files there are variables for
   * responsive screen sizes, these look something like

   *  <ul>
   *    <li>$screenSmallRange:  0, 767px;</li>
   *    <li>$screenMediumRange: 768px, 1023px;</li>
   *    <li>$screenLargeRange:  1024px, 1280px;</li>
   *    <li>$screenXlargeRange: 1281px, null;</li>
   *  </ul>
   *
   * <p>These variables in turn are used to generate responsive media queries in variables like
   * $responsiveQuerySmallUp, $responsiveQueryMediumUp, etc.</p>
   *
   * <p>we send down these media queries as the font family in classes
   * that look something like this:<p>
   *
   * <pre class="prettyprint">
   * <code>
   * .oj-mq-md {
   *    font-family: "/screen and (min-width: 768px)/";
   * }
   * </code></pre>
   *
   * <p>This function applies the class and then reads the font family off a dom
   * element to get the media query string</p>
   *
   * @param {string} selector a class selector name, for example 'oj-mq-md';
   * @return {string} the media query sent down for that class
   * @private
   */
  ResponsiveUtils._getMediaQueryFromClass = function (selector) {
    var elem = /** @type {(Element | null)} */ (document.getElementsByClassName(selector).item(0));

    if (elem === null) {
      elem = document.createElement('meta');
      elem.className = selector;
      document.head.appendChild(elem); // @HTMLUpdateOK
    }

    var fontFamily = window.getComputedStyle(elem).getPropertyValue('font-family');

    return fontFamily.replace(/^[/\\'"]+|(;\s?})+|[/\\'"]+$/g, '');
  };

  /**
   * Get a framework (built in) media query string,
   * see {@link ResponsiveUtils.FRAMEWORK_QUERY_KEY} for details on framework queries.
   * The media query string returned can be passed to
   * {@link oj.ResponsiveKnockoutUtils.createMediaQueryObservable} to create a knockout
   * observable, which in turn can be used to drive responsive page behavior.
   *
   * <p>Example:</p>
   * <pre class="prettyprint">
   * <code>
   *
   *     var lgQuery = oj.ResponsiveUtils.getFrameworkQuery(
   *                             oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP);
   *
   *     self.large = oj.ResponsiveKnockoutUtils.createMediaQueryObservable(lgQuery);
   * </code></pre>
   *
   *
   * @method getFrameworkQuery
   * @memberof ResponsiveUtils
   * @param {ResponsiveUtils.FrameworkQueryKey} frameworkQueryKey one of the FRAMEWORK_QUERY_KEY constants,
   *                       for example oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.MD_UP
   * @return {string | null} the media query to use for the framework query key passed in
   * @export
   * @static
   */
  ResponsiveUtils.getFrameworkQuery = function (frameworkQueryKey) {
    var selector = 'oj-mq-' + frameworkQueryKey;
    var query = ResponsiveUtils._getMediaQueryFromClass(selector);

    if (query === 'null') {
      Logger.warn(
        'Framework query not found. Please check that the value of the theming variable' +
          '$includeResponsiveMediaQueryClasses is set to true, if it' +
          'is set to false the media queries are not sent down to the browser.'
      );
      return null;
    }
    return query;
  };

  /**
   * <p> Compare can be used in conjunction with
   * {@link oj.ResponsiveKnockoutUtils.createScreenRangeObservable}</p>
   *
   *
   * <p>Example:</p>
   * <pre class="prettyprint">
   * <code>
   *        // create an observable which returns the current screen range
   *        self.screenRange = oj.ResponsiveKnockoutUtils.createScreenRangeObservable();
   *
   *        self.label2 = ko.computed(function() {
   *          var range = self.screenRange();
   *
   *          if ( oj.ResponsiveUtils.compare(
   *                       range, oj.ResponsiveUtils.SCREEN_RANGE.MD) <= 0)
   *          {
   *            // code for when screen is in small or medium range
   *          }
   *          else if (range == oj.ResponsiveUtils.SCREEN_RANGE.XL)
   *          {
   *            // code for when screen is in XL range
   *          }
   *        });
   * </code></pre>
   *
   * @method compare
   * @memberof ResponsiveUtils
   * @param {ResponsiveUtils.ScreenRange} size1 one of the screen size constants,
   * for example oj.ResponsiveUtils.SCREEN_RANGE.MD
   * @param {ResponsiveUtils.ScreenRange} size2 one of the screen size constants,
   * for example oj.ResponsiveUtils.SCREEN_RANGE.LG
   * @return {number} a negative integer if the first
   * argument is less than the second. Zero if the two are equal.
   * 1 or greater if the first argument is more than the second.
   *
   * @export
   * @static
   */
  ResponsiveUtils.compare = function (size1, size2) {
    var range1 = ResponsiveUtils._RANGE[size1];
    var range2 = ResponsiveUtils._RANGE[size2];

    if (range1 == null) {
      throw new Error(
        'size1 param ' +
          size1 +
          ' illegal, please use one of the screen size constants like oj.ResponsiveUtils.SCREEN_RANGE.MD'
      );
    }
    if (range2 == null) {
      throw new Error(
        'size2 param ' +
          size2 +
          ' illegal, please use one of the screen size constants like oj.ResponsiveUtils.SCREEN_RANGE.MD'
      );
    }

    return range1 - range2;
  };

  const compare = ResponsiveUtils.compare;
  const getFrameworkQuery = ResponsiveUtils.getFrameworkQuery;
  const SCREEN_RANGE = ResponsiveUtils.SCREEN_RANGE;
  const FRAMEWORK_QUERY_KEY = ResponsiveUtils.FRAMEWORK_QUERY_KEY;

  exports.FRAMEWORK_QUERY_KEY = FRAMEWORK_QUERY_KEY;
  exports.SCREEN_RANGE = SCREEN_RANGE;
  exports.compare = compare;
  exports.getFrameworkQuery = getFrameworkQuery;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtimerutils',['exports'], function (exports) { 'use strict';

  /**
   * Timing related utilities
   * @namespace
   * @name oj.TimerUtils
   * @since 4.1.0
   *
   * @ojtsignore
   */
  const TimerUtils = {};

  /**
   * A Timer encapsulates a Promise associated with a deferred function execution
   * and the ability to cancel the timer before timeout.
   * @interface Timer
   * @ojtsignore
   */
  function Timer() {}
  /**
   * Get the Promise assocaited with this timer.  Promise callbacks will be
   * passed a single boolean value indicating if the timer's timeout expired
   * normally (without being canceled/cleared).  If the timer is left to expire
   * after its configured timeout has been exceeded, then it will pass
   * boolean(true) to the callbacks.  If the timer's {@link Timer#clear} method is
   * called before its configured timeout has been reached, then the callbacks
   * will receive boolean(false).
   * @memberof Timer
   * @return {Promise.<boolean>} This timer's Promise
   */
  Timer.prototype.getPromise = function () {};
  /**
   * Clears the timer and resolves the Promise.  If the normal timeout hasn't
   * yet expired, the value passed to the Promise callbacks will be boolean(false).
   * If the timeout has already expired, this function will do nothing, and all of
   * its Promise callbacks will receive boolean(true).
   * @return {void}
   * @memberof Timer
   */
  Timer.prototype.clear = function () {};

  /**
   * Get a Timer object with the given timeout in milliseconds.  The Promise
   * associated with the timer is resolved when the timeout window expires, or if
   * the clear() function is called.
   * This is useful for when code needs to be executed on timeout (setTimeout) and
   * must handle cleanup tasks such as clearing {@link BusyState} when the timer
   * expires or is canceled.
   *
   * @param  {number} timeout The timeout value in milliseconds to wait before the
   * promise is resolved.
   * @return {Timer}
   * A Timer object which encapsulates the Promise that will be
   * resolved once the timeout has been exceeded or cleared.
   * @export
   * @memberof oj.TimerUtils
   * @alias getTimer
   * @example <caption>Get a timer to execute code on normal timeout and
   * cancelation.  If the timeout occurs normally (not canceled), both
   * callbacks are executed and the value of the 'completed' parameter will be
   * true.</caption>
   * var timer = oj.TimerUtils.getTimer(1000);
   * timer.getPromise().then(function(completed) {
   *     if (completed) {
   *       // Delayed code
   *     }
   *   })
   * timer.getPromise().then(function() {
   *   // Code always to be run
   * })
   *
   * @example <caption>Get a timer to execute code on normal timeout and cancelation.
   * In this example, the timer is canceled before its timeout expires, and the
   * value of the 'completed' parameter will be false.</caption>
   * var timer = oj.TimerUtils.getTimer(1000);
   * timer.getPromise()
   *   .then(function(completed) {
   *     if (completed) {
   *       // Delayed code
   *     }
   *   })
   * timer.getPromise()
   *   .then(function() {
   *     // Code always to be run
   *   })
   * ...
   * timer.clear(); // timer cleared before timeout expires
   */
  TimerUtils.getTimer = function (timeout) {
    return new TimerUtils._TimerImpl(timeout);
  };

  /**
   * @constructor
   * @implements {Timer}
   * @param  {number} timeout The timeout value in milliseconds.
   * @private
   */
  TimerUtils._TimerImpl = function (timeout) {
    var _promise;
    var _resolve;
    var _timerId;

    this.getPromise = function () {
      return _promise;
    };
    this.clear = function () {
      window.clearTimeout(_timerId);
      _timerId = null;
      _timerDone(false);
    };

    /**
     * Called on normal and early timeout (cancelation)
     */
    function _timerDone(completed) {
      _timerId = null;
      _resolve(completed);
    }

    if (typeof window === 'undefined') {
      _promise = Promise.reject();
    } else {
      _promise = new Promise(function (resolve) {
        _resolve = resolve;
        _timerId = window.setTimeout(_timerDone.bind(null, true), timeout); // @HTMLUpdateOK
      });
    }
  };

  const getTimer = TimerUtils.getTimer;

  exports.getTimer = getTimer;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtranslation',['exports', 'ojs/ojcore-base', 'ojs/ojconfig'], function (exports, oj, Config) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @namespace oj.Translations
   * @classdesc Services for Retrieving Translated Resources
   * @export
   * @since 1.0
   * @ojtsmodule
   * @hideconstructor
   */
  const Translations = {};

  /**
   * Sets the translation bundle used by JET
   * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
   * translated strings for JET.
   * This method may also be used by an application that wants to completely replace the resource bundle that is automatically
   * fetched by an AMD loader.
   * @method setBundle
   * @memberof oj.Translations
   * @param {Object} bundle resource bundle that should be used by the framework
   * @return {void}
   * @export
   */
  Translations.setBundle = function (bundle) {
    Translations._bundle = bundle;
  };

  /**
   * Retrives a translated resource for a given key
   * @method getResource
   * @memberof oj.Translations
   * @param {string} key resource key The dot character (.) within the key string
   * is interpreted as a separator for the name of a sub-section within the bundle.
   * For example, 'components.chart', would be read as the 'chart' section within
   * 'components'. Thus the key name for an individual section should never contain a dot.
   * @return {Object|string|null} resource associated with the key or null if none was found
   * @export
   */
  Translations.getResource = function (key) {
    return Translations._getResourceString(key);
  };

  /**
   * Applies parameters to a format pattern
   * @method applyParameters
   * @memberof oj.Translations
   * @param {string} pattern pattern that may contain tokens like {0}, {1}, {name}. These tokens
   * will be used to define string keys for retrieving values from the parameters
   * object. Token strings should not contain comma (,)
   * or space characters, since they are reserved for future format type enhancements.
   * The reserved characters within a pattern are:
   * $ { } [ ]
   * These characters will not appear in the formatted output unless they are escaped
   * with a dollar character ('$').
   *
   * @param {Object|Array} parameters parameters to be inserted into the string. Both arrays and
   * Javascript objects with string keys are accepted.
   *
   * @return {string} The formatted message string, or an empty string if the pattern is either null or an empty string.
   * @export
   */
  Translations.applyParameters = function (pattern, parameters) {
    return pattern == null ? '' : Translations._format(pattern, parameters);
  };

  /**
   * Retrieves a translated string after inserting optional parameters.
   * The method uses a key to retrieve a format pattern from the resource bundle.
   * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
   * for the optional parameters.  Token strings should not contain comma (,)
   * or space characters, since they are reserved for future format type enhancements.
   * The reserved characters within a pattern are:
   * $ { } [ ]
   * These characters will not appear in the formatted output unless they are escaped
   * with a dollar character ('$').
   * @method getTranslatedString
   * @memberof oj.Translations
   * @param {string} key  translations resource key. The dot character (.) within the key string
   * is interpreted as a separator for the name of a sub-section within the bundle.
   * For example, 'components.chart', would be read as the 'chart' section within
   * 'components'. Thus the key name for an individual section should never contain a dot.
   *
   * @param {...(string|Object|Array)} var_args  - optional parameters to be inserted into the
   * translated pattern.
   *
   * If more than one var_args arguments are passed, they will be treated as an array
   * for replacing positional tokens like {0}, {1}, etc.
   * If a single argument is passed, it will be treated as a Javascript Object whose
   * keys will be matched to tokens within the pattern. Note that an Array is just
   * a special kind of such an Object.
   *
   * For backward compatibility, a var_args argument whose type is neither
   * Object or Array will be used to replace {0} in the pattern.
   *
   * @return formatted translated string
   * @ojsignature {target: "Type", for:"returns", value: "string"}
   * @export
   */
  // eslint-disable-next-line camelcase, no-unused-vars
  Translations.getTranslatedString = function (key, var_args) {
    var val = Translations._getResourceString(key);

    if (val == null) {
      return key;
    }

    var params = {};

    if (arguments.length > 2) {
      params = Array.prototype.slice.call(arguments, 1);
    } else if (arguments.length === 2) {
      params = arguments[1];
      if (typeof params !== 'object' && !(params instanceof Array)) {
        params = [params];
      }
    }

    return Translations.applyParameters(val, params);
  };

  /**
   * Provides a key-to-value map of the translated resources for a given component name
   * @method getComponentTranslations
   * @memberof oj.Translations
   * @param {string} componentName name of the component
   * @return {Object} a map of translated resources
   * @export
   */
  Translations.getComponentTranslations = function (componentName) {
    var bundle = Translations._getBundle()[componentName];

    if (bundle == null) {
      return {};
    }

    // Assume that the set of keys remains constant regardless of the current locale
    var translations = {};
    var keys = Object.keys(bundle);
    for (var k = 0; k < keys.length; k++) {
      var key = keys[k];
      translations[key] = bundle[key];
    }

    return translations;
  };

  /**
   * Retrives a translated resource for a given key, accounting for nested keys
   * @param {string} key
   * @return {string|null} resource associated with the key or null if none was found
   * @private
   */
  Translations._getResourceString = function (key) {
    // Account for dot separated nested keys
    var keys = key ? key.split('.') : [];
    var bundle = Translations._getBundle();
    oj.Assert.assertObject(bundle);

    // even though we start with a valid bundle it's possible that part or all of the key is invalid,
    // so check we have a valid bundle in the for loop
    // if we have a key like a.b.c
    for (var index = 0; index < keys.length && bundle != null; index++) {
      var subkey = keys[index];
      bundle = bundle[subkey];
    }

    return bundle != null ? bundle : null;
  };

  Translations._format = function (formatString, parameters) {
    var formatLength = formatString.length;

    // Use the javascript StringBuffer technique.
    var buffer = [];

    var token = null;

    var escaped = false;
    var isToken = false;
    var isGroup = false;
    var isExcluded = false;

    var tokenTerminated; // this will be set to true when a comma or space is
    // encountered in teh token
    var i;

    for (i = 0; i < formatLength; i++) {
      var ch = formatString.charAt(i);

      var accumulate = false;

      if (!escaped) {
        switch (ch) {
          case '$':
            escaped = true;
            break;

          case '{':
            if (!isExcluded) {
              if (!isToken) {
                tokenTerminated = false;
                token = [];
              }
              isToken = true;
            }
            break;

          case '}':
            if (isToken && token.length > 0) {
              var val = parameters[token.join('')];
              buffer.push(val === undefined ? 'null' : val);
            }
            isToken = false;
            break;

          case '[':
            if (!isToken) {
              if (isGroup) {
                isExcluded = true;
              } else {
                isGroup = true;
              }
            }
            break;

          case ']':
            if (isExcluded) {
              isExcluded = false;
            } else {
              isGroup = false;
            }
            break;

          default:
            accumulate = true;
        }
      } else {
        accumulate = true;
        escaped = false;
      }

      if (accumulate) {
        if (isToken) {
          if (ch === ',' || ch === ' ') {
            tokenTerminated = true;
          } else if (!tokenTerminated) {
            token.push(ch);
          }
        } else if (!isExcluded) {
          buffer.push(ch);
        }
      }
    }

    // Use the javascript StringBuffer technique for toString()
    return buffer.join('');
  };

  Translations._getBundle = function () {
    var b = Translations._bundle;
    if (b) {
      return b;
    }
    return Config.getConfigBundle();
  };

  const setBundle = Translations.setBundle;
  const getResource = Translations.getResource;
  const applyParameters = Translations.applyParameters;
  const getTranslatedString = Translations.getTranslatedString;
  const getComponentTranslations = Translations.getComponentTranslations;

  exports.applyParameters = applyParameters;
  exports.getComponentTranslations = getComponentTranslations;
  exports.getResource = getResource;
  exports.getTranslatedString = getTranslatedString;
  exports.setBundle = setBundle;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcore',['ojs/ojcore-base', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojresponsiveutils', 'ojs/ojthemeutils', 'ojs/ojtimerutils', 'ojs/ojtranslation'], function (oj, Logger, Context, Config, ResponsiveUtils, ThemeUtils, TimerUtils, Translations) { 'use strict';

	oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
	Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

	/**
	 * @ojoverviewdoc ModuleLoadingOverview - [5]JET Module Loading
	 * @classdesc
	 * {@ojinclude "name":"moduleLoadingOverviewDoc"}
	 */
	/**
	 * <h2 id="usage">Overview
	 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
	 * </h2>
	 * <p>
	 *  JET classes and components are delivered via a set of <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">asynchronous module definitions</a> (AMDs or more informally, modules).
	 *  JET applications typically use <a href="https://requirejs.org/">RequireJS</a> to load the necessary modules and call API as required.  The values returned from JET modules come in one of three forms:
	 * </p>
	 * <h4>No return value</h4>
	 *  <p>Some modules may not return any value at all.  The purpose of these modules is simply to load the associated JavaScript into memory,
	 *     but the application typically does not directly interact with or instantiate this code. For example, modules that define
	 *     JET Web Components typically would not have return values.
	 *  </p>
	 * <pre class="prettyprint"><code>
	 * //Loading a JET component in your Typescript code
	 *
	 * //To typecheck the element APIs, import as below.
	 * import {ojAccordion} from "ojs/ojaccordion";
	 *
	 * //For the transpiled javascript to load the element's module, import as below
	 * import "ojs/ojaccordion";</code></pre>
	 * <h4>One return value</h4>
	 *  <p>Some modules directly return a single object or constructor function.  Applications would typically call functions on the returned
	 *     object or instantiate new objects via the constructor function.  For example, the 'ojs/ojcontext' module
	 *     has a single return value:
	 *  </p>
	 * <pre class="prettyprint"><code>
	 * //Javascript example
	 * define(['ojs/ojcontext'], function(Context) {
	 *   var pageContext = Context.getPageContext();
	 * })</code></pre>
	 * <pre class="prettyprint"><code>
	 * //TypeScript example
	 * import Context = require('ojs/ojcontext');
	 *   let pageContext = Context.getPageContext();
	 * </code></pre>
	 * <h4>Multiple return values</h4>
	 *  <p>Some modules package several objects or constructor functions inside a single JavaScript object.  Applications would typically retrieve the relevant object or constructor function via a
	 *     documented property on this object and then either call functions or instantiate new objects as appropriate.  For example, the 'ojs/ojattributegrouphandler' module has multiple return values.
	 *  </p>
	 * <pre class="prettyprint"><code>
	 * //TypeScript example
	 * import {ColorAttributeGroupHandler, ShapeAttributeGroupHandler} from "ojs/ojattributegrouphandler";
	 *  let colorHandler = new ColorAttributeGroupHandler();
	 *  let shapeHandler = new ShapeAttributeGroupHandler({'0-2 years': 'triangleDown',
	 *                                                     '3-5 years': 'circle',
	 *                                                     '6+ years': 'triangleUp'});
	 *  var getLegendData = function(data, colorHandler) {
	 *     var items = [];
	 *     for (var i = 0; i < data.length; i++)
	 *     {
	 *       items.push({
	 *         value: data[i].value,
	 *         text: data[i].category,
	 *         color: colorHandler.getValue(data[i].category),
	 *       });
	 *     }
	 *     return [{items: items}];
	 *   };
	 *
	 * //Another example
	 * import * as Logger from "ojs/ojlogger";
	 *  Logger.log("Please enter a valid input");
	 * </code></pre>
	 *
	 * @ojfragment moduleLoadingOverviewDoc
	 * @memberof ModuleLoadingOverview
	 */

	oj._registerLegacyNamespaceProp('Logger', Logger);
	oj._registerLegacyNamespaceProp('Context', Context);
	oj._registerLegacyNamespaceProp('Config', Config);
	oj._registerLegacyNamespaceProp('ResponsiveUtils', ResponsiveUtils);
	oj._registerLegacyNamespaceProp('ThemeUtils', ThemeUtils);
	oj._registerLegacyNamespaceProp('TimerUtils', TimerUtils);
	oj._registerLegacyNamespaceProp('Translations', Translations);

	return oj;

});


define('ojs/ojmessaging',['ojs/ojcore-base'], function (oj) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * Constructs a message object.
   * <p><strong>NOTE:</strong>  Instead of using the constructor, please use an Object
   * that duck-types Message - has summary, detail, and severity properties.
   * Creating an Message Object provides no additional value than
   * the duck-typed Object.
   * </p>
   * @param {string} summary - Localized summary message text
   * @param {string} detail - Localized detail message text
   * @param {(number|string)=} severity - An optional severity for this message. Use constants
   * Message.SEVERITY_LEVEL for number types and Message.SEVERITY_TYPE for string types. Default
   * is SEVERITY_ERROR if no severity is specified
   * @constructor
   * @final
   * @ojtsmodule
   * @export
   * @since 0.6.0
   * @example <caption>Set application messages using the
   * <code class="prettyprint">messages-custom</code> attribute. This example creates messages
   * the recommended way, by creating an Object that duck-types Message.</caption>
   * --- HTML ---
   * &lt;oj-input-text messages-custom="{{appMessages}}");>&lt;/oj-input-text>
   *
   * --- Javascript ---
   * // for messagesCustom property
   * self.appMessages = ko.observable();
   * var msgs = [];
   * msgs.push({summary: "Error Summary", detail: "Error Detail",
   *  severity: Message.SEVERITY_TYPE['CONFIRMATION']});
   * self.appMessages(msgs);
   * @ojsignature [{target: "Type",
   *                value: "Message.SEVERITY_TYPE| Message.SEVERITY_LEVEL",
   *                for: "severity"}]
   */
  const Message = function (summary, detail, severity) {
    this.Init(summary, detail, severity);
  };
  oj._registerLegacyNamespaceProp('Message', Message);

  /**
   * Indicates the type of severity that the message represents.
   * @enum {string}
   * @export
   */
  Message.SEVERITY_TYPE = {
    /**
     * Indicates a confirmation that an operation or task was completed. This is the lowest severity
     * level.
     */
    CONFIRMATION: 'confirmation',

    /**
     * Indicates information or operation messages. This has a lower severity level than warning.
     */
    INFO: 'info',

    /**
     * Indicates an application condition or situation that might require users' attention. This has a
     * lower severity than error.
     */
    WARNING: 'warning',

    /**
     * Used when data inaccuracies occur when completing a field and that needs fixing before user can
     * continue. This has a lower severity level than fatal.
     */
    ERROR: 'error',

    /**
     * Used when a critical application error or an unknown failure occurs. This is the highest
     * severity level.
     * @const
     * @export
     * @ojdeprecated {since: '11.0.0', description: 'Both "FATAL" and "ERROR" apply the same marker style. Use "ERROR" instead.'}
     */
    FATAL: 'fatal'
  };

  /**
   * Message severity level
   * @enum {number}
   * @export
   */
  Message.SEVERITY_LEVEL = {
    /**
     * @ojdeprecated {since: '11.0.0', description: 'Both "FATAL" and "ERROR" apply the same marker style. Use "ERROR" instead.'}
     */
    FATAL: 5,
    ERROR: 4,
    WARNING: 3,
    INFO: 2,
    CONFIRMATION: 1
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(Message, oj.Object, 'Message');

  /**
   * Localized summary text.
   *
   * @member
   * @name summary
   * @memberof Message
   * @instance
   * @type {string}
   * @default ""
   */

  /**
   * Localized detail text.
   *
   * @member
   * @name detail
   * @memberof Message
   * @instance
   * @type {string}
   * @default ""
   */

  /**
   * Severity type of message. See Message.SEVERITY_TYPE for string types and Message.SEVERITY_LEVEL for number types.
   *
   * @member
   * @name severity
   * @memberof Message
   * @instance
   * @type {string|number}
   * @ojsignature [{target: "Type",
   *                value: "Message.SEVERITY_TYPE| Message.SEVERITY_LEVEL"}]
   * @default Message.SEVERITY_TYPE.ERROR
   */

  /**
   * Initializes Message instance with the set options
   * @param {string} summary a localized summary message text
   * @param {string} detail a localized detail message text
   * @param {number|string=} severity - An optional severity for this message.  Use constants
   * Message.SEVERITY_LEVEL for number types and Message.SEVERITY_TYPE for string types.
   *
   * @export
   * @ignore
   */
  Message.prototype.Init = function (summary, detail, severity) {
    Message.superclass.Init.call(this);
    this.summary = summary;
    this.detail = detail;
    this.severity = severity || Message.SEVERITY_TYPE.ERROR; // defaults to ERROR
  };

  /**
   * A convenience method that returns the severity level when given either a severity level of type
   * number or a severity type of string.
   * If severity level is not provided or is not valid this returns a severity error.
   * @param {(string|number)=} severity
   * @return {number}
   * @memberof Message
   * @ojsignature [{target: "Type",
   *                value: "Message.SEVERITY_LEVEL",
   *                for: "returns"},
   *               {target: "Type",
   *                value: "Message.SEVERITY_TYPE|Message.SEVERITY_LEVEL",
   *                for: "severity"}]
   * @public
   * @export
   */
  Message.getSeverityLevel = function (severity) {
    var _severity = severity;
    if (_severity) {
      if (typeof severity === 'string') {
        var index = Message._LEVEL_TO_TYPE.indexOf(_severity, 1);
        if (index === -1) {
          _severity = Message.SEVERITY_LEVEL.ERROR;
        } else {
          _severity = index;
        }
      } else if (
        typeof _severity === 'number' &&
        (_severity < Message.SEVERITY_LEVEL.CONFIRMATION || _severity > Message.SEVERITY_LEVEL.FATAL)
      ) {
        _severity = Message.SEVERITY_LEVEL.ERROR;
      }
    }

    return _severity || Message.SEVERITY_LEVEL.ERROR;
  };

  /**
   * A convenience method that returns the severity type when given either a severity level of type
   * number or a severity type of string.
   * If severity level is not provided or is not valid this return a severity error.
   * @param {(string|number)=} level
   * @return {string}
   * @ojsignature [{target: "Type",
   *                value: "Message.SEVERITY_TYPE",
   *                for: "returns"},
   *               {target: "Type",
   *                value: "Message.SEVERITY_TYPE|Message.SEVERITY_LEVEL",
   *                for: "level"}]
   * @memberof Message
   * @public
   * @export
   */
  Message.getSeverityType = function (level) {
    var _level = level;
    if (_level) {
      if (typeof _level === 'string') {
        var index = Message._LEVEL_TO_TYPE.indexOf(_level, 1);
        if (index === -1) {
          // when given an unrecognized type return "error"
          _level = Message.SEVERITY_TYPE.ERROR;
        }
      } else if (typeof _level === 'number') {
        if (_level < Message.SEVERITY_LEVEL.CONFIRMATION || _level > Message.SEVERITY_LEVEL.FATAL) {
          _level = Message.SEVERITY_TYPE.ERROR;
        } else {
          _level = Message._LEVEL_TO_TYPE[level];
        }
      }
    }
    return _level || Message.SEVERITY_TYPE.ERROR;
  };

  /**
   * Returns the max severity level in a array of message objects.
   *
   * @param {Array.<Message>=} messages an array of message instances or duck typed messages
   * @returns {number} -1 if none can be determined; otherwise a severity level as defined by
   * Message.SEVERITY_LEVEL.
   * @export
   * @memberof Message
   * @ojsignature [{target: "Type",
   *                value: "Message.SEVERITY_LEVEL| -1",
   *                for: "returns"}]
   * @public
   */
  Message.getMaxSeverity = function (messages) {
    if (!messages || messages.length === 0) {
      return -1;
    }

    const severityLevels = messages.map((message) => Message.getSeverityLevel(message.severity));
    return Math.max(...severityLevels);
  };

  /**
   * Returns false if messages are of severity error or greater.
   *
   * @param {Array.<Message>} messages an array of message instances or duck-typed messages
   * @returns {boolean} true if none of the messages are of severity error or greater. false otherwise
   * @export
   * @memberof Message
   * @public
   */
  Message.isValid = function (messages) {
    var maxSeverity = Message.getMaxSeverity(messages);
    if (maxSeverity >= Message.SEVERITY_LEVEL.ERROR) {
      return false;
    }

    return true;
  };

  /**
   * @private
   * @type Array
   */
  Message._LEVEL_TO_TYPE = [
    'none', // this can never be set
    Message.SEVERITY_TYPE.CONFIRMATION,
    Message.SEVERITY_TYPE.INFO,
    Message.SEVERITY_TYPE.WARNING,
    Message.SEVERITY_TYPE.ERROR,
    Message.SEVERITY_TYPE.FATAL
  ];

  /**
   * Extends Message to represent a component specific message, this defines options that control
   * how the message will display.
   *
   * @param {string} summary - Localized summary message text
   * @param {string} detail - Localized detail message text
   * @param {number|string} severity - An optional severity for this message. Use constants
   * Message.SEVERITY_LEVEL for number types and Message.SEVERITY_TYPE for string types. Default
   * is SEVERITY_ERROR if no severity is specified
   * @param {Object} options - an Object literal that defines the following properties
   * @property {string} display - whether the message needs to be displayed immediately or not.
   * Accepted values are 'immediate', 'deferred'. The default is 'immediate'.
   * @property {string} context - the context the component was in when the validation messages was
   * added.<p>
   *
   * NOTE: messages added to the component directly by applications are unknown context and always
   * shown {display: 'immediate', context: ''}. </p>
   * @private
   * @constructor
   * @since 0.7.0
   */
  const ComponentMessage = function (summary, detail, severity, options) {
    this.Init(summary, detail, severity, options);
  };

  // Subclass from Message
  oj.Object.createSubclass(ComponentMessage, Message, 'ComponentMessage');

  /**
   * Determines whether the message is displayed immediately or not. Deferred messages are not shown
   * to the user right away but are deferred until component explicitly does. See
   * {@link oj.editableValue#showMessages}.
   * @private
   * @const
   * @type {Object}
   */
  ComponentMessage.DISPLAY = { SHOWN: 'shown', HIDDEN: 'hidden' };

  /**
   * The default display options to use when none set.
   *
   * @type {Object}
   * @private
   */
  ComponentMessage._DEFAULT_OPTIONS = {
    display: ComponentMessage.DISPLAY.SHOWN,
    context: ''
  };

  /**
   * Initializes the strategy based on the display options that specify the messaging artifacts that
   * will be displayed by this strategy.
   *
   * @param {string} summary - Localized summary message text
   * @param {string} detail - Localized detail message text
   * @param {number|string} severity - An optional severity for this message. Use constants
   * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
   * is SEVERITY_ERROR if no severity is specified
   * @param {Object} options - an Object literal that defines the following properties
   * @memberof! oj.ComponentMessage
   * @instance
   * @protected
   * @ignore
   */
  ComponentMessage.prototype.Init = function (summary, detail, severity, options) {
    ComponentMessage.superclass.Init.call(this, summary, detail, severity);

    this._options = { ...ComponentMessage._DEFAULT_OPTIONS, ...options };
  };

  /**
   * Clones this and returns the new instance.
   *
   * @memberof! oj.ComponentMessage
   * @instance
   * @protected
   * @ignore
   * @returns {Object}
   */
  ComponentMessage.prototype.clone = function () {
    return new ComponentMessage(this.summary, this.detail, this.severity, this._options);
  };

  /**
   * Whether a message can display on the UI.
   *
   * @memberof! oj.ComponentMessage
   * @returns {boolean} true if messages can be displayed; false if marked as deferred by component.
   * @instance
   * @protected
   * @ignore
   */
  ComponentMessage.prototype.canDisplay = function () {
    return !(this._options && this._options.display
      ? this._options.display === ComponentMessage.DISPLAY.HIDDEN
      : false);
  };

  /**
   *
   * Called by framework when the message needs to be shown
   *
   * @returns {boolean} true if shown; false if message display was already shown
   *
   * @memberof! oj.ComponentMessage
   * @instance
   * @private
   */
  ComponentMessage.prototype._forceDisplayToShown = function () {
    if (this._options && ComponentMessage.DISPLAY.HIDDEN === this._options.display) {
      this._options.display = ComponentMessage.DISPLAY.SHOWN;
      return true;
    }

    return false;
  };

  /**
   * Called by framework to determine if message was added by component versus app.
   *
   * @returns {boolean} true if messages was added by component. Usually the context is set.
   *
   * @memberof! oj.ComponentMessage
   * @instance
   * @private
   */
  ComponentMessage.prototype._isMessageAddedByComponent = function () {
    if (this._options && this._options.context) {
      return true;
    }

    return false;
  };

  // use default export here for Message to retain same content that was previously returned from AMD.
  // Default export will wrap the exported functions and properties. In case non-es6 modules won't go down the default export,
  // only use default export here instead of both named export and default export.
  // So put ComponentMessage as a property under Message then the reference to ComponentMessage will be Message.ComponentMessage.
  // Can't put this inside Message.js which will cause circular dependency.
  Message.ComponentMessage = ComponentMessage;

  return Message;

});


define('ojs/ojmetadatautils',['exports', 'ojs/ojcore-base', 'ojs/ojcustomelement-utils'], function (exports, oj, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * Component Metadata utilities.
   * @class MetadataUtils
   * @export
   * @ignore
   */
  const MetadataUtils = {};

  /**
   * Default values can be specified at the top level or at leaf subproperties.
   * This utility walks complex property subproperties to generate default value.
   * @property {object} metadata property-level metadata
   * @property {boolean?} shouldFreeze Contol whether we copy or freeze Object/Array types
   * @memberof MetadataUtils
   * @ignore
   */
  MetadataUtils.getDefaultValue = function (metadata, shouldFreeze) {
    let defaultValue = metadata.value;
    if (defaultValue === undefined) {
      // If top level metadata isn't specified, check subproperties.
      // Note that we are not handling cases where both top level and subproperty
      // default values are provided, leaving that to auditing and build tools to check.
      const subMeta = metadata.properties;
      if (subMeta) {
        const complexValue = {};
        const keys = Object.keys(subMeta);
        for (let i = 0; i < keys.length; i++) {
          const subpropDefault = MetadataUtils.getDefaultValue(subMeta[keys[i]]);
          if (subpropDefault !== undefined) {
            complexValue[keys[i]] = subpropDefault;
          }
        }
        // Cache the default value on the top level property. This is ok
        // because we make a copy of the metadata when we process it for
        // event listener properties
        if (Object.keys(complexValue).length > 0) {
          // eslint-disable-next-line no-param-reassign
          metadata.value = complexValue;
          defaultValue = complexValue;
        }
      }
    }
    if (defaultValue !== undefined) {
      // For object/array types, either freeze or make a copy of the value
      // to prevent modification
      if (Array.isArray(defaultValue)) {
        defaultValue = shouldFreeze ? MetadataUtils.deepFreeze(defaultValue) : defaultValue.slice();
      } else if (defaultValue !== null && typeof defaultValue === 'object') {
        defaultValue = shouldFreeze
          ? MetadataUtils.deepFreeze(defaultValue)
          : oj.CollectionUtils.copyInto({}, defaultValue, undefined, true);
      }
    }
    return defaultValue;
  };

  /**
   * Default values can be specified at the top level or at leaf subproperties.
   * This utility creates an object containing the default values for all properties
   * in the metadata (including rolling up subproperty defaults).  Returns null if no
   * default values are found
   * @property {object} metadata properties metadata (i.e. the value of the 'properties' property in component.json)
   * @property {boolean?} shouldFreeze Contol whether we copy or freeze Object/Array types
   * @memberof MetadataUtils
   * @ignore
   */
  MetadataUtils.getDefaultValues = function (metadata, shouldFreeze) {
    const defaults = {};
    const propNames = Object.keys(metadata);
    let hasDefaults = false;
    propNames.forEach(function (propName) {
      // would be nice if this could be done lazily via defineProperty, but this causes
      // Object.assign to fail because the property has no setter
      const defaultValue = MetadataUtils.getDefaultValue(metadata[propName], shouldFreeze);
      if (defaultValue !== undefined) {
        defaults[propName] = defaultValue;
        hasDefaults = true;
      }
    });
    return hasDefaults ? defaults : null;
  };

  /**
   * Helper to deep freeze object literals. This method will walk arrays and
   * freeze array contents as needed. If anything other than a plain old object,
   * we will not attempt to freeze it so the owner should ensure that the
   * object is immutable.
   * @param {any} value The value to freeze
   * @return {any}
   * @ignore
   */
  MetadataUtils.deepFreeze = function (value) {
    if (Object.isFrozen(value)) {
      return value;
    } else if (Array.isArray(value)) {
      // eslint-disable-next-line no-param-reassign
      value = value.map((item) => MetadataUtils.deepFreeze(item));
      Object.freeze(value);
    } else if (value !== null && typeof value === 'object') {
      // We should only recurse/freeze if value is a pojo.
      // proto will be null if Object.create(null) was used
      const proto = Object.getPrototypeOf(value);
      // We want to freeze all POJOs except for VNodes
      if ((proto === null || proto === Object.prototype) && !isVNode(value)) {
        // Retrieve the property names defined on object
        Object.keys(value).forEach(function (name) {
          // eslint-disable-next-line no-param-reassign
          value[name] = MetadataUtils.deepFreeze(value[name]);
        });
        Object.freeze(value);
      }
    }
    return value;
  };

  function isVNode(obj) {
    // we know preact/compat is in the stack and its options.vnode hook
    // injects a $$typeof property into every VNode so we'll use that
    // as a heuristic for identifying VNodes
    return Object.prototype.hasOwnProperty.call(obj, '$$typeof');
  }

  /**
   * Gets property metadata for the specified property or subproperty.
   * @param {*} propPath
   * @param {*} metadata
   * @returns {object}
   * @ignore
   */
  MetadataUtils.getPropertyMetadata = function (propPath, metadata) {
    const { subProp } = MetadataUtils.getComplexPropertyMetadata(propPath, metadata);
    return subProp;
  };

  /**
   * Retrieves an object that contains two values - metadata for the top level property and for the subproperty.
   * The top level property is needed for writeback and readonly checks for complex properties.
   * The values will be identical if the property is already top level.
   * @param {*} propPath
   * @param {*} metadata
   * @returns {object}
   * @ignore
   */
  MetadataUtils.getComplexPropertyMetadata = function (propPath, metadata) {
    let subProp = metadata;
    let prop = metadata;

    if (subProp) {
      const namePath = propPath.split('.');
      for (let i = 0; i < namePath.length; i++) {
        subProp = subProp[namePath[i]];
        if (i === 0) {
          prop = subProp;
        }
        if (!subProp || namePath.length === 1 || i === namePath.length - 1 || !subProp.properties) {
          break;
        }
        subProp = subProp.properties;
      }
    }
    return { prop, subProp };
  };

  /**
   * Checks to see whether a value is valid for an element property's enum and throws an error if not.
   * @param  {Element}  element The custom element
   * @param  {string}  property The property to check
   * @param  {string}  value The property value
   * @param  {Object}  metadata The property metadata
   * @ignore
   */
  MetadataUtils.checkEnumValues = function (element, property, value, metadata) {
    // Only check enum values for string types
    if (typeof value === 'string' && metadata) {
      const enums = metadata.enumValues;
      if (enums && enums.indexOf(value) === -1) {
        throw new Error(
          `Invalid value '${value}' found for property '${property}'.\
Expected one of the following '${enums.toString()}'.`
        );
      }
    }
  };

  /**
   * Returns the attributes including the flattened dot notation versions of all complex properties.
   * @param {Object} props The properties object
   * @return {Array}
   * @ignore
   */
  MetadataUtils.getFlattenedAttributes = function (props) {
    const attrs = [];
    MetadataUtils._getAttributesFromProperties('', props, attrs);
    return attrs;
  };

  /**
   * Helper method which returns the attributes including the dot notation versions of all complex attributes
   * stored on a bridge instance
   * @param {string} parentPath The path from any parent complex property or empty string if evaluating a top level property
   * @param {Object} props The properties metadata object
   * @param {Array} attrs The attribute array to add to
   * @ignore
   */
  MetadataUtils._getAttributesFromProperties = function (parentPath, props, attrs) {
    if (props) {
      const propKeys = Object.keys(props);
      propKeys.forEach((prop) => {
        const propMeta = props[prop];
        const concatName = parentPath + prop;
        attrs.push(ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(concatName));
        if (propMeta.properties) {
          MetadataUtils._getAttributesFromProperties(concatName + '.', propMeta.properties, attrs);
        }
      });
    }
  };

  const getDefaultValue = MetadataUtils.getDefaultValue;
  const getDefaultValues = MetadataUtils.getDefaultValues;
  const deepFreeze = MetadataUtils.deepFreeze;
  const getPropertyMetadata = MetadataUtils.getPropertyMetadata;
  const getComplexPropertyMetadata = MetadataUtils.getComplexPropertyMetadata;
  const checkEnumValues = MetadataUtils.checkEnumValues;
  const getFlattenedAttributes = MetadataUtils.getFlattenedAttributes;

  exports.checkEnumValues = checkEnumValues;
  exports.deepFreeze = deepFreeze;
  exports.getComplexPropertyMetadata = getComplexPropertyMetadata;
  exports.getDefaultValue = getDefaultValue;
  exports.getDefaultValues = getDefaultValues;
  exports.getFlattenedAttributes = getFlattenedAttributes;
  exports.getPropertyMetadata = getPropertyMetadata;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdefaultsutils',['exports', 'ojs/ojmetadatautils'], function (exports, MetadataUtils) { 'use strict';

    /**
     * Utility methods for handling defaults coming from metadata,
     * Props classes, and dynamic defaults for various JET component
     * models.
     * @private
     */
    function getFrozenDefault(property, constr, metadata) {
        const defaults = getDefaults(constr, metadata, true);
        // Default values must be either:
        // 1. primitives
        // 2. immutable classes, e.g. KeySetImpl
        // 3. Object/Arrays composed of #1 or #2
        return MetadataUtils.deepFreeze(defaults[property]);
    }
    function getDefaults(constr, metadata, shouldFreeze) {
        // Defaults are created once and stashed on the constructor
        let defaults = constr['_defaults'];
        if (defaults === undefined) {
            // Adding the optional shouldFreeze param for definitional elements so we don't break
            // backwards compatibility, but our preference is to freeze the defaults and clone internally
            // where needed instead (e.g. dot notation sets).
            const staticDefaults = getStaticDefaults(constr, metadata, shouldFreeze);
            // If staticDefaults is null Object.create will return an empty object
            defaults = Object.create(staticDefaults);
            // Metadata defaults always override dynamic defaults
            applyDynamicDefaults(constr, defaults);
            constr['_defaults'] = defaults;
        }
        return defaults;
    }
    function getStaticDefaults(constr, metadata, shouldFreeze) {
        // Defaults are created once and stashed on the constructor
        let defaults = constr['_staticDefaults'];
        if (defaults === undefined) {
            // Instantiate defaults to null in case we don't have metadata or properties
            // so when we call Object.create(null) we'll get an empty {} back vs an error for
            // Object.create(undefined);
            defaults = null;
            if (metadata) {
                const propertiesMetadata = metadata.properties;
                const PropDefaults = metadata.extension?._DEFAULTS;
                if (PropDefaults) {
                    // For VComponents, use the Props class stashed in the metadata and instantiate
                    // it in order to get the properties and default values.
                    const defaultsInstance = new PropDefaults();
                    defaults = Object.create(defaultsInstance);
                }
                else if (propertiesMetadata) {
                    defaults = Object.create(
                    // Adding the optional shouldFreeze param for definitional elements so we don't break
                    // backwards compatibility, but our preference is to freeze the defaults and clone internally
                    // where needed instead (e.g. dot notation sets).
                    MetadataUtils.getDefaultValues(propertiesMetadata, shouldFreeze));
                }
            }
            constr['_staticDefaults'] = defaults;
        }
        return defaults;
    }
    // Keep for oj-form-layout which is the only usage
    function applyDynamicDefaults(constr, props) {
        if (constr['getDynamicDefaults']) {
            const dynamicDefaults = constr['getDynamicDefaults']();
            if (dynamicDefaults) {
                // Dyanmic getters specified via the es6 get function() syntax
                // will be added to the object prototype instead of instance so we
                // use a for...in loop here instead of Object.keys
                // eslint-disable-next-line no-restricted-syntax
                for (let key in dynamicDefaults) {
                    if (props[key] === undefined) {
                        props[key] = dynamicDefaults[key];
                    }
                }
            }
        }
    }

    var DefaultsUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getFrozenDefault: getFrozenDefault,
        getDefaults: getDefaults,
        getStaticDefaults: getStaticDefaults,
        applyDynamicDefaults: applyDynamicDefaults
    });

    exports.DefaultsUtils = DefaultsUtils;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbootstrap',['exports'], function (exports) { 'use strict';

  /**
   * Contains utility functions intended to be used during application bootstrapping
   *
   * @namespace
   * @name Bootstrap
   * @ojtsmodule
   * @since 7.0.0
   */

  const Bootstrap = {
    /**
     * Returns a Promise that is resolved when document.readyState is no longer 'loading'
     * i.e. when it is 'interactive' or 'complete'.  This may be used to delay an application's
     * initial applyBindings call until DOM elements are accessible.
     *
     * @static
     * @memberof Bootstrap
     * @method
     * @return {Promise} a Promise that is resolved when document.readyState is no longer 'loading'
     * @ojsignature {target:"Type", value: "Promise<void>", for: "returns", jsdocOverride: true}
     */
    whenDocumentReady: (function () {
      var documentReadyPromise;
      return function () {
        if (!documentReadyPromise) {
          if (document.readyState === 'loading') {
            documentReadyPromise = new Promise(function (resolve) {
              var eventListener = function () {
                document.removeEventListener('DOMContentLoaded', eventListener);
                resolve();
              };
              document.addEventListener('DOMContentLoaded', eventListener);
            });
          } else {
            documentReadyPromise = Promise.resolve();
          }
        }
        return documentReadyPromise;
      };
    })()
  };

  const whenDocumentReady = Bootstrap.whenDocumentReady;

  exports.whenDocumentReady = whenDocumentReady;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcustomelement',['ojs/ojcore', 'ojs/ojlogger', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry', 'ojs/ojmetadatautils', 'ojs/ojbootstrap', 'ojs/ojcore-base'], function (oj, Logger, ojcustomelementUtils, ojcustomelementRegistry, MetadataUtils, Bootstrap, oj$1) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;

  /**
   * Custom element bridge prototype.
   *
   * @class
   * @ignore
   */
  const BaseCustomElementBridge = {};

  /**
   * Prototype for subclasses
   * @ignore
   */
  BaseCustomElementBridge.proto = {
    getClass: function (descriptor) {
      var proto = Object.create(HTMLElement.prototype);
      this.InitializePrototype(proto);

      var metadata = this.GetMetadata(descriptor);
      // Add __oj_private_identifier_to_* properties to ensure correct behavior
      // during VComponentTemplate compilation. These properties help preserve
      // non-primitive property values on the JET components that remain essentially
      // unchanged when templates are updated.
      if (!metadata.properties) {
        metadata.properties = {};
      }
      metadata.properties.__oj_private_identifier_to_prop = {
        type: 'object',
        writeback: true // set writeback key to true to force deep compare in comparePropertyValues().
      };
      metadata.properties.__oj_private_identifier_to_value = {
        type: 'object',
        writeback: true // set writeback key to true to force deep compare in comparePropertyValues().
      };

      // Enumerate metadata to define the prototype properties, methods, and events
      BaseCustomElementBridge._enumerateMetadataForKey(
        proto,
        metadata,
        'properties',
        this.DefinePropertyCallback.bind(this)
      );
      BaseCustomElementBridge._enumerateMetadataForKey(
        proto,
        metadata,
        'methods',
        this.DefineMethodCallback.bind(this)
      );

      // Add additional element methods not defined in metadata, e.g. getNodeBySubId/getSubIdByNode or get/setProperty
      this.AddComponentMethods(proto);

      proto.setProperties = function (props) {
        ojcustomelementUtils.CustomElementUtils.getElementBridge(this).SetProperties(this, props);
      };

      // The set/unset methods are used for TypeScript only so we should define these as non enumerated properties
      Object.defineProperty(proto, 'set', {
        value: function (prop, value) {
          this.setProperty(prop, value);
        }
      });
      Object.defineProperty(proto, 'unset', {
        value: function (prop) {
          this.setProperty(prop, undefined);
        }
      });

      // Add lifecycle listeners
      proto.attributeChangedCallback = this.AttributeChangedCallback;
      proto.connectedCallback = this._connectedCallback;
      proto.disconnectedCallback = this._detachedCallback;

      // Override appendChild/insertBefore to work around JET-43356 issue w/ Preact
      const origAppendChild = proto.appendChild;
      proto.appendChild = function (newNode) {
        if (ojcustomelementUtils.CustomElementUtils.canRelocateNode(this, newNode)) {
          return origAppendChild.call(this, newNode);
        }
        return newNode;
      };
      const origInsertBefore = proto.insertBefore;
      proto.insertBefore = function (newNode, refNode) {
        if (ojcustomelementUtils.CustomElementUtils.canRelocateNode(this, newNode)) {
          // In case of slot nodes the refNode might be moved by the parent component
          // and it is not a direct child of that parent component anymore.
          // Preact is not aware of this movement so it uses incorrect parent for inserting a node.
          // Lets use the insertBefore parent of refNode to insert newNode before it.
          if (refNode && refNode.parentNode !== this) {
            Logger.info(
              `Using insertBefore where ${this.tagName} is not a parent of ${refNode.tagName}`
            );
          }
          if (refNode && refNode.parentNode) {
            return origInsertBefore.call(refNode.parentNode, newNode, refNode);
          }
          return origInsertBefore.call(this, newNode, refNode);
        }
        return newNode;
      };

      // Override set/removeAttribute to only allow toggling of classes applied by application/parent component
      // This is necessary to work with Preact's class patching logic
      proto.setAttribute = function (qualifiedName, value) {
        if (qualifiedName === 'class') {
          const outerClasses = ojcustomelementUtils.CustomElementUtils.getClassSet(value);
          ojcustomelementUtils.CustomElementUtils.getElementState(this).setOuterClasses(outerClasses);
        } else {
          HTMLElement.prototype.setAttribute.call(this, qualifiedName, value);
        }
      };

      proto.removeAttribute = function (qualifiedName) {
        if (qualifiedName === 'class') {
          this.setAttribute('class', '');
        } else {
          HTMLElement.prototype.removeAttribute.call(this, qualifiedName);
        }
      };
      var constructorFunc = function () {
        var reflect = window.Reflect;
        var ret;
        if (typeof reflect !== 'undefined') {
          ret = reflect.construct(HTMLElement, [], this.constructor);
        } else {
          ret = HTMLElement.call(this);
        }
        return ret;
      };

      var bridge = this;
      Object.defineProperty(constructorFunc, 'observedAttributes', {
        get: function () {
          return bridge.GetAttributes(metadata);
        }
      });

      Object.defineProperty(proto, 'constructor', {
        value: constructorFunc,
        writable: true,
        configurable: true
      });
      constructorFunc.prototype = proto;
      Object.setPrototypeOf(constructorFunc, HTMLElement);

      return constructorFunc;
    },

    initializeBridge: function (element, descriptor) {
      // Initialize property storage and other variables needed for property sets.
      // Since early property sets can occur before the element's connected callback
      // is triggered we can't rely on performing this logic there. The cases where
      // the connected callback isn't called before a property set can occur if the
      // custom element is programatically created and sets are done before adding
      // the element to the DOM or if the element is stamped by knockout and its expressions
      // processed disconnected as in the case for oj-bind-for-each.
      this.METADATA = this.GetMetadata(descriptor);
      this._eventListeners = {};
      this.State = ojcustomelementUtils.CustomElementUtils.getElementState(element);
    },

    // eslint-disable-next-line no-unused-vars
    AddComponentMethods: function (proto) {},

    AttributeChangedCallback: function (attr, oldValue, newValue) {
      // The browser triggers this callback even if old and new values are the same
      // so we should do an equality check ourselves to prevent extra work.
      // Note that we need to check whether the property has been set and marked dirty
      // as well since we don't reflect property values back to the DOM attribute.
      const prop = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attr);
      const bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
      if (oldValue !== newValue || bridge.State.dirtyProps.has(prop)) {
        bridge.State.dirtyProps.delete(prop.split('.')[0]);
        // Due to  where IE11 disables child inputs for a parent with the disabled attribute,
        // we will remove the disabled attribute after we save the value and will ignore all disabled
        // attribute sets after component initialization when the application can just as easily use the property
        // setter instead. Expressions will be handled in the CustomElementBinding.
        if (
          attr === 'disabled' &&
          bridge.ShouldRemoveDisabled() &&
          bridge._isDisabledAttributeRemoved()
        ) {
          // Always remove the disabled attribute even after component initialization and log warning.
          // A null value indicates that the value was removed already.
          if (newValue != null) {
            Logger.warn(
              "Ignoring 'disabled' attribute change after component initialization. Use element property setter instead."
            );
            bridge._removeDisabledAttribute(this);
          }
          return;
        }

        if (bridge.ShouldHandleAttributeChanged(this)) {
          BaseCustomElementBridge.__CheckOverlappingAttribute(this, attr);

          // removeAttribute calls return null as the newValue which we want to treat as
          // a property unset and convert to undefined. We allow property null sets as an
          // actual property override.
          if (newValue === null) {
            // eslint-disable-next-line no-param-reassign
            newValue = undefined;
          }

          var params = {
            detail: { attribute: attr, value: newValue, previousValue: oldValue }
          };
          this.dispatchEvent(new CustomEvent('attribute-changed', params));

          var expression = ojcustomelementUtils.AttributeUtils.getExpressionInfo(newValue).expr;
          if (!expression) {
            const propMeta = MetadataUtils.getPropertyMetadata(prop, ojcustomelementRegistry.getElementProperties(this));
            if (propMeta) {
              this.setProperty(
                prop,
                ojcustomelementUtils.CustomElementUtils.parseAttrValue(this, attr, prop, newValue, propMeta)
              );
            }
            // This allows subclasses to handle special cases like global transfer
            // attributes for JET components or controlled properties for virtual components
            bridge.HandleAttributeChanged(this, attr, oldValue, newValue);
          }
        }
      }
    },

    // eslint-disable-next-line no-unused-vars
    CreateComponent: function (element) {},

    // eslint-disable-next-line no-unused-vars
    DefineMethodCallback: function (proto, method, methodMeta) {},

    // eslint-disable-next-line no-unused-vars
    DefinePropertyCallback: function (proto, property, propertyMeta) {},

    GetAttributes: function (metadata) {
      return metadata ? MetadataUtils.getFlattenedAttributes(metadata.properties) : [];
    },

    GetMetadata: function (descriptor) {
      return descriptor[BaseCustomElementBridge.DESC_KEY_META] || {};
    },

    /**
     * Returns the aliased component property for a given custom element property,
     * e.g. readOnly for oj-switch's readonly custom element property.
     * Will return the original property if there is no aliasing.
     * @param {string} property The property to check
     */
    GetAliasForProperty: function (property) {
      return property;
    },

    /**
     * Tests whether attribute changed processing should be performed.
     */
    // eslint-disable-next-line no-unused-vars
    ShouldHandleAttributeChanged: function (element) {
      return this.State.canHandleAttributes();
    },

    /**
     * Tests whether the HandleAttributeChanged callback should be called.
     * This is only needed in the VirtualElementBridge case when a VComponent
     * is patching and updates a controlled property on the root element which we
     * want to update our internal _CONTROLLED_PROPS object with, but not cause a
     * rerender.
     */
    // eslint-disable-next-line no-unused-vars
    ShouldCallHandleAttributeChanged: function (element) {
      return this.ShouldHandleAttributeChanged();
    },

    // eslint-disable-next-line no-unused-vars
    HandleAttributeChanged: function (element, attr, oldValue, newValue) {},

    // eslint-disable-next-line no-unused-vars
    HandleBindingsApplied: function (element, bindingContext) {},

    // eslint-disable-next-line no-unused-vars
    HandleDetached: function (element) {},

    // eslint-disable-next-line no-unused-vars
    HandleAttached: function (element) {},

    // eslint-disable-next-line no-unused-vars
    HandleReattached: function (element) {},

    // eslint-disable-next-line no-unused-vars
    InitializeElement: function (element) {},

    // eslint-disable-next-line no-unused-vars
    InitializePrototype: function (proto) {},

    BatchedPropertySet: function (elem, props) {
      var keys = Object.keys(props);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        elem.setProperty(key, props[key]);
      }
    },

    GetEventListenerProperty: function (property) {
      var event = ojcustomelementUtils.AttributeUtils.eventListenerPropertyToEventType(property);
      // Get event listener
      var eventListener = this._eventListeners[event];
      if (eventListener) {
        return eventListener.getListener();
      }
      return undefined;
    },

    GetProperty: function (element, prop, props) {
      var meta = MetadataUtils.getPropertyMetadata(prop, ojcustomelementRegistry.getElementProperties(element));

      // For event listener and non component properties, retrieve the value directly stored on the element.
      // For top level properties, this will delegate to our 'set' methods so we can handle default values.
      // props is the properties object we pass the definitional element or composite ViewModel
      if (ojcustomelementUtils.AttributeUtils.isEventListenerProperty(prop) || !meta || prop.indexOf('.') === -1) {
        return props[prop];
      }
      return ojcustomelementUtils.CustomElementUtils.getPropertyValue(props, prop);
    },

    // VComponent hook to queue property change events to be fired asynchronously
    HandlePropertyChanged: function (element, property, value, previousValue, isOuter, subprop) {
      var updatedFrom = isOuter ? 'external' : 'internal';
      BaseCustomElementBridge.__FirePropertyChangeEvent(
        element,
        property,
        value,
        previousValue,
        updatedFrom,
        subprop
      );
    },

    PlaybackEarlyPropertySets: function (element) {
      // Once the binding provider has resolved and we are about
      // to render the component, we no longer need to track early
      // property sets to avoid overriding data bound DOM attributes
      if (this._earlySets) {
        const descriptor = ojcustomelementRegistry.getElementDescriptor(element.tagName);
        const propertyMeta = this.GetMetadata(descriptor);
        while (this._earlySets.length) {
          const setObj = this._earlySets.shift();
          const updatedValue = ojcustomelementUtils.transformPreactValue(
            element,
            setObj.property,
            propertyMeta.properties[setObj.property],
            setObj.value
          );
          element.setProperty(setObj.property, updatedValue);
        }
      }
    },

    /**
     * Returns true if this property set was handled as an early property set.
     * An early property set is any set that occurs before the component is created.
     * These sets do not trigger [property]Changed events.
     * @param {Element} element
     * @param {string} prop
     * @param {any} value
     * @return {boolean}
     */
    SaveEarlyPropertySet: function (element, prop, value) {
      // Do not save sets that occur during BaseCustomElementBridge.__InitProperties
      // or expression evaluation. We can process these as normal. Playback occurs before the
      // binding provider promise is resolved leading to component creation.
      if (this.State.allowPropertySets()) {
        return false;
      }

      if (!this._earlySets) {
        this._earlySets = [];
      }

      this._earlySets.push({ property: prop, value: value });
      return true;
    },

    SetEventListenerProperty: function (element, property, value) {
      var event = ojcustomelementUtils.AttributeUtils.eventListenerPropertyToEventType(property);
      // Get event listener
      var eventListener = this._eventListeners[event];
      if (!eventListener) {
        // Create the wrapper
        eventListener = this._createEventListenerWrapper();
        this._eventListeners[event] = eventListener;
        element.addEventListener(event, eventListener);
      }
      if (value == null || value instanceof Function) {
        eventListener.setListener(value);
      } else {
        BaseCustomElementBridge.__ThrowTypeError(element, property, value, 'function');
      }
    },

    SetProperty: function (element, prop, value, props, bOuter) {
      // Check value against any defined enums
      var meta = MetadataUtils.getPropertyMetadata(prop, ojcustomelementRegistry.getElementProperties(element));
      if (ojcustomelementUtils.AttributeUtils.isEventListenerProperty(prop) || !meta) {
        // eslint-disable-next-line no-param-reassign
        element[prop] = value;
      } else {
        // props is the properties object we pass the definitional element or composite ViewModel
        var previousValue = element.getProperty(prop);
        var propPath = prop.split('.');
        var topProp = propPath[0];
        // If the top level property is an object, make a copy otherwise the old/new values
        // will be the same.
        var topPropPrevValue = props[topProp];
        if (oj.CollectionUtils.isPlainObject(topPropPrevValue)) {
          topPropPrevValue = oj.CollectionUtils.copyInto({}, topPropPrevValue, undefined, true);
        }

        // If the new value is undefined, check whether default value exists and use it to compare props.
        // We want to do it for top level prop only and keep undefined for subprops to preserve old behavior.
        // See JET-53415 for subprops issue.
        var valueToCompare = value === undefined && propPath.length === 1 ? meta.value : value;
        if (!ojcustomelementUtils.ElementUtils.comparePropertyValues(meta.writeback, valueToCompare, previousValue)) {
          var isSubprop = prop.indexOf('.') !== -1;
          if (isSubprop) {
            // Set a flag for the case a subproperty results in a set of the top level property
            // which was not instantiated to an empty object to avoid firing two events.
            this._SKIP_PROP_CHANGE_EVENT = true;
          }

          if (bOuter) {
            // This ultimately triggers our element defined property setter
            this.ValidateAndSetProperty(
              this.GetAliasForProperty.bind(this),
              props,
              prop,
              value,
              element
            );
          } else {
            // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
            BaseCustomElementBridge.__SetProperty(
              this.GetAliasForProperty.bind(this),
              props,
              prop,
              value
            );
          }

          this._SKIP_PROP_CHANGE_EVENT = false;
          // Property change events for top level properties will be triggered by ValidateAndSetProperty so avoid firing twice
          if (isSubprop) {
            var subprop = {
              path: prop,
              value,
              previousValue
            };
            this.HandlePropertyChanged(
              element,
              topProp,
              props[topProp],
              topPropPrevValue,
              bOuter,
              subprop
            );
          }
          this.State.dirtyProps.add(topProp);
          return { property: topProp, propertySet: true, isSubproperty: isSubprop };
        }
      }
      // We return true if a component property is updated with a different value and false
      // for other cases like on[Event] property updates
      return { property: null, propertySet: false, isSubproperty: false };
    },

    ShouldRemoveDisabled: function () {
      // Subclasses should override if the disabled attribute shouldn't be unconditionally removed
      // from the DOM, e.g. definitional and composite components
      return true;
    },

    ValidateAndSetProperty: function (propNameFun, componentProps, property, value, element) {
      var _value = this.ValidatePropertySet(element, property, value);
      BaseCustomElementBridge.__SetProperty(propNameFun, componentProps, property, _value);
    },

    ValidatePropertySet: function (element, property, value) {
      var propsMeta = ojcustomelementRegistry.getElementProperties(element);
      var propMeta = MetadataUtils.getPropertyMetadata(property, propsMeta);
      var propAr = property.split('.');

      if (!propMeta) {
        Logger.warn(
          ojcustomelementUtils.CustomElementUtils.getElementInfo(element) +
            ": Ignoring property set for undefined property '" +
            property +
            "'."
        );
        return undefined;
      }

      // Check readOnly property for top level property
      if (propsMeta[propAr[0]].readOnly) {
        throw new ojcustomelementUtils.JetElementError(element, `Read-only property '${property}' cannot be set.`);
      }
      try {
        MetadataUtils.checkEnumValues(element, property, value, propMeta);
      } catch (error) {
        throw new ojcustomelementUtils.JetElementError(element, error.message);
      }

      if (value != null) {
        return BaseCustomElementBridge.checkType(element, property, value, propMeta);
      }

      return value;
    },

    PostCreate: function (element) {
      // After parsing the DOM attribute values and initializing properties, remove the disabled
      // property if it exists due to 
      if (
        element.hasAttribute('disabled') &&
        this.ShouldRemoveDisabled() &&
        !this._isDisabledAttributeRemoved()
      ) {
        this._removeDisabledAttribute(element);
      }
    },

    _connected: function (element) {
      const state = this.State;
      // If the component has not finished its creation cycle,
      // attempt to create it vs handling as a reattached since
      // the component could have finished in an error state.
      // The element state will no-op the creation process if
      // the component is already in an error state.
      if (!state.isComplete()) {
        state.startCreationCycle();
        if (state.isCreating()) {
          // initial attach
          // Initializing props from DOM needs to be called
          // before we playback properties so we cannot call this
          // inside the createComponentCallback
          this.InitializeElement(element);

          // Should be able to call PlaybackEarlyPropertySets inside
          // createComponentCallback, but ojradioset/ojcheckboxset rely on
          // on a side effect of the flow where we playback early property sets
          // before resolving the binding provider. In those components the parent
          // renders the oj-option instead of the ojOption's own render method.
          state.setBindingProviderCallback(this.PlaybackEarlyPropertySets.bind(this, element));

          const createComponentCallback = () => {
            try {
              // Cache the slot map since we don't support adding new
              // slot content after initial render
              state.getSlotMap(true);

              const createPromise = this.CreateComponent(element) || Promise.resolve();
              return createPromise.then(this.PostCreate.bind(this, element));
            } catch (error) {
              return Promise.reject(error);
            }
          };

          state.setCreateCallback(createComponentCallback);
          this.HandleAttached(element);
        }
      } else {
        this.HandleReattached(element);
      }
    },

    _connectedCallback: function () {
      var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
      bridge._connected(this);
    },

    _detachedCallback: function () {
      const bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
      const state = bridge.State;
      if (!state.isComplete()) {
        state.pauseCreationCycle();
      } else {
        bridge.HandleDetached(this);
      }
    },

    // This wrapper does not provide any additional functionality to event listener functions
    // It exists solely to preserve event listener order
    _createEventListenerWrapper: function () {
      var eventListener;
      var domListener = function (event) {
        if (eventListener) {
          eventListener(event);
        }
      };
      domListener.setListener = function (listener) {
        eventListener = listener;
      };
      domListener.getListener = function () {
        return eventListener;
      };
      return domListener;
    },

    // Not using default values in case of undefined is an oversight
    // but we also don't want to change the existing behavior of this popular method.
    // Adding useDefaultsWhenUndefined flag for default values, that will be set to true in CustomElementBridge
    // property setter, when the setter is used by Preact.
    SetProperties: function (elem, props, useDefaultsWhenUndefined) {
      var mutationKeys = []; // keys for the 'dot mutation' properties
      var regularProps = {}; // the rest of the properties
      var hasRegularProps = false;

      var keys = Object.keys(props);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.indexOf('.') >= 0) {
          mutationKeys.push(key);
        } else {
          let value = props[key];
          if (useDefaultsWhenUndefined && value === undefined) {
            const meta = MetadataUtils.getPropertyMetadata(key, ojcustomelementRegistry.getElementProperties(elem));
            value = MetadataUtils.getDefaultValue(meta);
          }
          regularProps[key] = value;
          hasRegularProps = true;
        }
      }

      // Regular property updates may be batched
      if (hasRegularProps) {
        this.BatchedPropertySet(elem, regularProps);
      }

      // 'Dot notation' properties can only be set individually for now
      for (var p = 0; p < mutationKeys.length; p++) {
        var mkey = mutationKeys[p];
        elem.setProperty(mkey, props[mkey]);
      }
    },

    /**
     * Returns true if the disabled attribute has already been removed by the bridge.
     * @return  {boolean}
     * @private
     */
    _isDisabledAttributeRemoved: function () {
      return this._disabledProcessed === true;
    },

    /**
     * Removes the disabled attribute from an element and marks the bridge as having
     * processed the value to prevent evaluation of additional attribute sets.
     * @param  {Element} element The custom element
     * @private
     */
    _removeDisabledAttribute: function (element) {
      this._disabledProcessed = true;
      element.removeAttribute('disabled');
    }
  };

  /** ***************************/
  /* NON PUBLIC STATIC METHODS */
  /** ***************************/

  /**
   * @ignore
   */
  BaseCustomElementBridge._enumerateMetadataForKey = function (proto, metadata, key, callback) {
    if (!metadata || !metadata[key]) {
      return;
    }

    var values = metadata[key];
    var names = Object.keys(values);
    names.forEach(function (name) {
      callback(proto, name, values[name]);
    });
  };

  /**
   * Checks to see whether a value is valid for an element property and throws an error if not.
   * @param  {Element}  element The custom element
   * @param  {string}  property The property to check
   * @param  {string}  value The property value
   * @param  {Object}  metadata The property metadata
   * @ignore
   */
  BaseCustomElementBridge.checkType = function (element, property, value, metadata) {
    // Only check non union primitive, array, and object types
    const type = metadata.type;
    const supportedTypes = ojcustomelementUtils.ElementUtils.getSupportedTypes(type);
    if (supportedTypes.typeCount === 1 && !supportedTypes.any && !supportedTypes.other) {
      const valueType = typeof value;
      if (
        (supportedTypes.array && !Array.isArray(value)) ||
        (supportedTypes.object && !(valueType === 'object')) ||
        (supportedTypes.string && !(valueType === 'string')) ||
        (supportedTypes.number && !(valueType === 'number' && isFinite(value)))
      ) {
        BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
      } else if (supportedTypes.boolean) {
        // Treat boolean property sets like the DOM does where any value that passes
        // 'if (boolVal)' results in a true prop set
        return !!value;
      }
    }
    return value;
  };

  /**
   * @ignore
   */
  BaseCustomElementBridge.__ThrowTypeError = function (element, property, value, type) {
    throw new ojcustomelementUtils.JetElementError(
      element,
      `Invalid type '${typeof value}' found for property '${property}'.\
 Expected value of type '${type}'.`
    );
  };

  /**
   * Checks to see if there are any overlapping attribute for the given element and attribute
   * @ignore
   */
  BaseCustomElementBridge.__CheckOverlappingAttribute = function (element, attr) {
    var attrPath = attr.split('.');
    if (attrPath.length > 1) {
      attrPath.pop();
      while (attrPath.length) {
        var attrSubPath = attrPath.join('.');
        if (element.hasAttribute(attrSubPath)) {
          throw new ojcustomelementUtils.JetElementError(
            element,
            `Cannot set overlapping attributes '${attr}' and '${attrSubPath}'.`
          );
        }
        attrPath.pop();
      }
    }
  };

  /**
   * @ignore
   */
  BaseCustomElementBridge.__InitProperties = function (element, componentProps) {
    const bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    var metaProps = ojcustomelementRegistry.getElementProperties(element);
    if (metaProps) {
      var attrs = element.attributes; // attrs is a NodeList
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        var property = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attr.nodeName);

        // See if attribute is a component property
        var meta = MetadataUtils.getPropertyMetadata(property, metaProps);
        if (meta && !meta.readOnly) {
          // If complex property, check if there are any overlapping attributes
          BaseCustomElementBridge.__CheckOverlappingAttribute(element, attr.nodeName);

          var info = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attr.value);
          if (!info.expr) {
            var value = ojcustomelementUtils.CustomElementUtils.parseAttrValue(
              element,
              attr.nodeName,
              property,
              attr.value,
              meta
            );
            bridge.ValidateAndSetProperty(
              bridge.GetAliasForProperty.bind(bridge),
              componentProps,
              property,
              value,
              element
            );
          }
        }
      }
    }
  };

  /**
   * @param {function} propNameFun A function that returns the actual property name to use, e.g. an alias
   * @param {Object} componentProps The object to set the new property value on which is the
   *                                element for outer property sets and the property bag for inner sets.
   * @param {string} property The property name
   * @param {Object} value The value to set for the property
   * @ignore
   */
  BaseCustomElementBridge.__SetProperty = function (propNameFun, componentProps, property, value) {
    var propsObj = componentProps;
    var propPath = property.split('.');
    var branchedProps;
    // Set subproperty, initializing parent objects along the way unless the top level
    // property is not defined since setting it to an empty object will trigger a property changed
    // event. Instead, branch and set at the end. We only have listeners on top level properties
    // so setting a subproperty will not trigger a property changed event along the way.
    var topProp = propNameFun(propPath[0]);
    if (propPath.length > 1 && !componentProps[topProp]) {
      branchedProps = {};
      propsObj = branchedProps;
    }

    // Walk to the correct location
    for (var i = 0; i < propPath.length; i++) {
      var subprop = propNameFun(propPath[i]);
      if (i === propPath.length - 1) {
        propsObj[subprop] = value;
      } else if (!propsObj[subprop]) {
        propsObj[subprop] = {};
      }
      propsObj = propsObj[subprop];
    }

    // Update the original component properties if we branched
    if (branchedProps) {
      // eslint-disable-next-line no-param-reassign
      componentProps[topProp] = branchedProps[topProp];
    }
  };

  /**
   * @ignore
   */
  BaseCustomElementBridge.__ProcessEventListeners = function (_metadata) {
    var metadata = oj.CollectionUtils.copyInto({}, _metadata, undefined, true, 1);
    metadata.properties = metadata.properties || {};
    BaseCustomElementBridge._enumerateMetadataForKey(
      null,
      metadata,
      'properties',
      function (proto, property) {
        var eventName = ojcustomelementUtils.AttributeUtils.propertyNameToChangeEventType(property);
        var eventListenerProperty = ojcustomelementUtils.AttributeUtils.eventTypeToEventListenerProperty(eventName);
        metadata.properties[eventListenerProperty] = { _derived: true, _eventListener: true };
      }
    );
    BaseCustomElementBridge._enumerateMetadataForKey(
      null,
      metadata,
      'events',
      function (proto, event) {
        var eventListenerProperty = ojcustomelementUtils.AttributeUtils.eventTypeToEventListenerProperty(event);
        metadata.properties[eventListenerProperty] = { _derived: true, _eventListener: true };
      }
    );
    return metadata;
  };

  /**
   * @ignore
   * @param {Element} element
   * @param {string} name
   * @param {Object} value
   * @param {Object} previousValue
   * @param {string} updatedFrom
   * @param {Object=} subprop
   */
  BaseCustomElementBridge.__FirePropertyChangeEvent = function (
    element,
    name,
    value,
    previousValue,
    updatedFrom,
    subprop
  ) {
    var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    // There are cases where a subproperty set can trigger a top level property set
    // if the top level property was not instantiated to an empty object. We don't want
    // to fire two events for that case. The BaseCustomElementBridge has logic to fire
    // the subproperty change event there.
    if (!bridge._SKIP_PROP_CHANGE_EVENT) {
      var detail = {};
      if (subprop) {
        detail.subproperty = subprop;
      }
      detail.value = value;
      detail.previousValue = previousValue;
      detail.updatedFrom = updatedFrom;

      // Check if the subclass needs to do anything before we fire the property change event,
      // e.g. composites that need to call the propertyChanged ViewModel callback.
      if (bridge.beforePropertyChangedEvent) {
        bridge.beforePropertyChangedEvent(element, name, detail);
      }
      // The bridge sets the ready to fire flag after the component has been instantiated.
      // We shouldn't fire property changed events before then unless the update comes from internally
      // for cases like readOnly property updates.
      if (updatedFrom !== 'external' || bridge.State.isComplete()) {
        element.dispatchEvent(new CustomEvent(name + 'Changed', { detail: detail }));
      }
    }
  };

  /**
   * @ignore
   */
  BaseCustomElementBridge.__DefineDynamicObjectProperty = function (obj, property, getter, setter) {
    Object.defineProperty(obj, property, {
      enumerable: true,
      get: getter,
      set: setter
    });
  };

  /** @ignore */
  BaseCustomElementBridge.DESC_KEY_META = 'metadata';

  oj._registerLegacyNamespaceProp('BaseCustomElementBridge', BaseCustomElementBridge);

  /**
   * in some OS/browser combinations you can attempt to detect high contrast mode
   * in javascript, go to the url below and look for "High Contrast"
   * https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/
   *
   * This function uses a variation of the code in the "High Contrast" section of
   * the site above to try and detect high contrast mode
   * by script, but it by no means definitively tells you whether or not you
   * are actually in high contrast mode. As discussed at the url above you
   * may need to have a user preference setting for high contrast.
   *
   * If the script is able to detect high contrast mode it sets the class
   * "oj-hicontrast" on the body tag. When "oj-high-contrast" is present
   * JET provides alternate informational images that are specially designed
   * for high contrast users.
   * @private
   */
  function _ojHighContrast() {
    // using a data uri, I googled for shortest uri to get this one since
    // I don't care about the actual image, but I do want a legit image
    // otherwise I see an error in chrome and I don't want users to be
    // confused by seeing any error.
    var div = document.createElement('div');
    div.style.border = '1px solid';
    div.style.borderColor = 'red green';
    div.style.position = 'absolute';
    div.style.top = '-999px';
    div.style.backgroundImage =
      'url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=)';
    var body = document.body;
    body.appendChild(div); // @HTMLUpdateOK safe manipulation
    var computedStyles = window.getComputedStyle(div);

    var bki = computedStyles.backgroundImage;

    if (
      computedStyles.borderTopColor === computedStyles.borderRightColor ||
      (bki != null && (bki === 'none' || bki === 'url (invalid-url:)'))
    ) {
      body.classList.add('oj-hicontrast');
    }

    body.removeChild(div);
  }

  Bootstrap.whenDocumentReady().then(function () {
    _ojHighContrast();
  });

  /**
   * @ojoverviewdoc CustomElementOverview - [2]JET Web Components
   * @classdesc
   * {@ojinclude "name":"customElementOverviewDoc"}
   */

  /**
   * <h2 id="ce-overview-section">
   *   Overview<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-section"></a>
   * </h2>
   * <p>
   *   JET components and <a href="CompositeOverview.html">custom components</a>, collectively referred to as <b>JET Web Components</b>,
   *   are implemented as <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">custom HTML elements</a>
   *   and extend the <a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement">HTMLElement</a> interface. This means that
   *   JET custom elements automatically inherit
   *   <a href=https://html.spec.whatwg.org/multipage/dom.html#global-attributes>global attributes</a>
   *   and programmatic access to these components is similar to interacting with native HTML elements.
   *   All JET components live in the "oj" namespace and have HTML element names starting with "oj-". We will use
   *   the term "JET component" to refer to both native JET custom elements and custom elements implemented using the
   *   <a href="Composite.html">Composite</a> component APIs after this point.
   * </p>
   * <h2 id="ce-overview-upgrade-section" class="subsection-title">
   *   Upgrading a Custom Element<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-upgrade-section"></a>
   * </h2>
   * <p>
   *   The upgrade process will begin for current JET custom elements in the DOM when the component module is loaded,
   *   registering a class constructor with its tag name using the
   *   <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define">CustomElementRegistry</a>
   *   <code>define()</code> API. Existing elements matching the registered tag name will be updated to inherit the new
   *   class definition and all of the component properties and methods will be available on the custom element after
   *   this process completes. Additionally, JET components will resolve any data bindings during the upgrade process.
   *   The application is responsible for calling their binding provider to apply bindings or for adding a
   *   <code>data-oj-binding-provider="none"</code> attribute in their page to indicate that no data bindings exist.
   *   If an application is rendered using Preact, <code>data-oj-binding-provider="preact"</code> should be set instead.
   *   Note that the JET custom element upgrade process will not complete until data bindings
   *   are resolved or no binding provider is indicated using the <code>data-oj-binding-provider</code> attribute.
   *   Also, due to JET components' data binding support, all JET component upgrades will occur asynchronously regardless
   *   of whether a binding provider is used.
   *   Please see the <a href="#ce-databind-section">data binding</a> section for more details on binding providers and data binding.
   *   The application should not interact with the JET custom element except to  programmatically set properties until the
   *   custom element upgrade is complete. The recommended way to wait on the asynchronous upgrade process is to use an
   *   element-scoped or page-level <a href="oj.BusyContext.html">BusyContext</a>.
   * </p>
   * <h2 id="ce-overview-usage-section" class="subsection-title">
   *   Using a JET Custom Element<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-usage-section"></a>
   * </h2>
   * <p>
   *   Custom elements can be used declaratively in HTML by using the component tag name and attributes. They are not self closing
   *   elements and applications should include a closing tag. To interact with them  programmatically, DOM APIs can be used to
   *   retrieve the element and then access properties and methods directly on the element instance. JET custom elements can also fire
   *   <code>CustomEvents</code> for which the application can attach event listeners both declaratively and  programmatically.
   *   The rest of this document discusses these features in more detail.
   * </p>
   *
   * <h2 id="ce-attributes-section" class="subsection-title">
   *   Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attributes-section"></a>
   * </h2>
   * <p>
   *   Attribute values set as string literals will be parsed and coerced to the property type. JET currently
   *   only supports the following string literal type coercions: boolean, number, string, Object and Array, where
   *   Object and Array types must use JSON notation with double quoted strings. A special "any" type is also supported
   *   and is described <a href="#ce-attrs-any-section">below</a>. All other types should to be set using
   *   <a href="#ce-databind-section">expression syntax</a> in the DOM or using the element's property setters or <code>setProperty</code>
   *   and <code>setProperties</code> methods programmatically. Unless updates are done via the DOM element.setAttribute(),
   *   the DOM's attribute value will not reflect changes like those done via the property setters or the setProperty and
   *   setProperties methods. Attribute removals are treated as unsetting of a property where the component default value will be used if one exists.
   * </p>
   * <p>
   *   As described <a href="#ce-databind-section">below</a>, JET uses [[...]] and {{...}} syntax to represent data bound expressions.
   *   JET does not currently provide any escaping syntax for "[[" or "{{" appearing at the beginning of the attribute
   *   value. You will need to add a space character to avoid having the string literal value interpreted as a binding
   *   expression (e.g. &lt;oj-some-element some-attribute='[ ["arrayValue1", "arrayValue2", ... ] ]'>&lt;/oj-some-element>).
   * </p>
   * <h2 id="ce-attrs-boolean-section" class="subsection-title">
   *   Boolean Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-boolean-section"></a>
   * </h2>
   * <p>
   *   JET components treat boolean attributes differently than HTML5. Since a common application use case
   *   is to toggle a data bound boolean attribute, JET will coerce the string literal "false" to the boolean
   *   false for boolean attributes. The absence of a boolean attribute in the DOM will also be interpreted as false.
   *   JET will coerce the following string literal values to the boolean true and throw an Error for all other
   *   invalid values.
   *   <ul>
   *    <li>No value assignment (e.g. &lt;oj-some-element boolean-attribute>&lt;/oj-some-element>)</li>
   *    <li>Empty string (e.g. &lt;oj-some-element boolean-attribute="">&lt;/oj-some-element>)</li>
   *    <li>The "true" string literal (e.g. &lt;oj-some-element boolean-attribute="true">&lt;/oj-some-element>)</li>
   *    <li>The case-insensitive attribute name (e.g. &lt;oj-some-element boolean-attribute="boolean-attribute">&lt;/oj-some-element>)</li>
   *   </ul>
   * </p>
   * <h2 id="ce-attrs-object-section" class="subsection-title">
   *   Object-Typed Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-object-section"></a>
   * </h2>
   * <p>
   *   Attributes that support Object type can be declaratively set using dot notation.
   *   Note that applications should not set overlapping attributes as these will cause an error to be thrown.
   *   <pre class="prettyprint">
   *   <code>
   * &lt;!-- person is an Object typed attribute with a firstName subproperty -->
   * &lt;oj-some-element person.first-name="{{name}}">&lt;/oj-some-element>
   *
   * &lt;!-- overlapping attributes will throw an error -->
   * &lt;oj-some-element person="{{personInfo}}" person.first-name="{{name}}">&lt;/oj-some-element>
   *   </code>
   *   </pre>
   *   If applications need to programmatically set subproperties, they can call the JET components's <code>setProperty</code>
   *   method with dot notation using the camelCased property syntax (e.g. element.setProperty("person.firstName", "Sally")).
   * </p>
   * <h2 id="ce-attrs-any-section" class="subsection-title">
   *   Any-Typed Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-any-section"></a>
   * </h2>
   * <p>
   *   Attributes that support any type are documented with type {any} in the API doc and will be coerced as
   *   Objects, Arrays, or strings when set in HTML as a string literal. Numeric types are not supported due
   *   to the fact that we cannot determine whether value="2" on a property supporting any type should be
   *   coerced to a string or a number. The application should use data binding for all other value types and ensure
   *   that when linking any-typed attributes across multiple components, that the resolved types will match, e.g.
   *   do not data bind an <oj-select-one> <code>value</code> attribute to a numeric value and use a string literal
   *   number for its child <oj-option> <code>value</code> attributes since those would evaluate to strings.
   * </p>
   *
   * <h2 id="ce-databind-section" class="subsection-title">
   *   Data Binding<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-section"></a>
   * </h2>
   * <p>
   *   Applications can use the JET data binding syntax in order to use expressions or a non coercible attribute
   *   type (e.g. a type other than boolean, number, string, Object or Array) declaratively in HTML.
   *   This syntax can be used on both JET custom elements and native HTML elements.
   *   The application is responsible for applying bindings using a supported binding provider which then notifies
   *   JET framework code that the bindings have been resolved and to finish the custom element upgrade process.
   * </p>
   * <h2 id="ce-databind-bindingprovider-section" class="subsection-title">
   *   Binding Providers<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-bindingprovider-section"></a>
   * </h2>
   * <p>
   *   The binding provider is responsible for setting and updating attribute
   *   expressions and any custom elements within its managed subtree will not finish upgrading until it
   *   applies bindings on that subtree. By default, there is a single binding provider for a page,
   *   but subtree specific binding providers can be added by using the <code>data-oj-binding-provider</code>
   *   attribute with values of "none" and "knockout". The default binding provider is knockout, but if a
   *   page or DOM subtree does not use any expression syntax or knockout, the application can set
   *   <code>data-oj-binding-provider="none"</code> on that element so its dependent JET custom elements
   *   do not need to wait for bindings to be applied to finish upgrading. Note that regardless of whether a
   *   binding provider is used, the custom element upgrade process will be asynchronous. <b>When using the
   *   knockout binding provider, applications should require the ojknockout module.</b>
   * </p>
   * <h2 id="ce-databind-syntax-section" class="subsection-title">
   *   Data Binding Syntax for JET Components<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-syntax-section"></a>
   * </h2>
   * <p>
   *   Data binding syntax can be used directly on component attributes. See the specific component API doc
   *   for the complete list of component attributes. Global HTML attributes inherited from HTMLElement can also be
   *   data bound, but require special syntax described below. JET detects data bound attributes by looking for values
   *   wrapped with {{...}} or [[...]]. Please note that there should be no spaces between the braces
   *   when using the data bind syntax (e.g. some-attribute="[ [...] ]"). The {{...}} wrapped expression indicates that the
   *   application is allowing the component to update the expression which can be a knockout observable. Attributes
   *   bound using [[...]] will not be updated or "written back" to by the component. Unless the component attribute documents
   *   that it supports "writeback", we recommend that the [[...]] syntax be used, e.g. selection-mode="[[currentSelectionMode]]".
   * </p>
   * <h2 id="ce-databind-writeback-section" class="subsection-title">
   *   Writeback<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-writeback-section"></a>
   * </h2>
   * <p>
   *   Certain properties such as "value" on editable components support updating the associated expression
   *   automatically whenever their value changes. This usually occurs after user interaction such as with selection
   *   or typing into an input field. This expression update functionality is also known as "writeback".
   *   Applications can control expression writeback by using the {{...}} syntax for two-way writable
   *   binding expressions or [[...]] for one-way only expressions. The one-way expressions should
   *   be used when the application needs expressions strictly for "downstream-only" purposes, e.g. only for
   *   updating a component property. Note that if a writeback attribute is bound using the "downstream-only"
   *   syntax, the application and component states can become out of sync. This is different from the
   *   read-only properties, which are "upstream-only", e.g. they are used only to monitor component state.
   *   Thus an expression associated with a read-only property should always use the {{}} syntax.
   *   Most component properties do not writeback and those that do will indicate it in their API doc.
   * </p>
   * <p>
   * Note that nested brackets are not supported within writeback expressions, e.g. <code>obj1[obj2['prop']]</code>.
   * Dot notation should be used where possible in place of bracket notation. In cases where dot notation is
   * not applicable, consider moving logic into the view model to simplify expressions.
   * <p>
   * <pre class="prettyprint">
   *   <code>
   *   &lt;oj-some-element value="[[currentValue]]" selection={{currentSelection}}>&lt;/oj-some-element>
   *   </code>
   * </pre>
   * <h2 id="ce-databind-global-section" class="subsection-title">
   *   Data Binding Syntax for Native HTML Elements and Global Attributes
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-global-section"></a>
   * </h2>
   * <p>
   *   JET's data binding syntax can also be used on native HTML elements and
   *   <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes">global attributes</a>
   *   to create one-way bindings by prefixing the attribute
   *   name with ":" (e.g. :id="[[idVar]]"). The attribute binding syntax results in the attribute being set in the DOM
   *   with the evaluated expression. Since global HTML attributes are always string typed, expressions using the ":"
   *   prefixing should resolve to strings with the exception of the style and class attributes which support additional types
   *   and are described in more detail below. In the case of component attributes, applications are recommended to bind
   *   the attribute names directly and avoid the use of the ":" prefix.
   * </p>
   * <h2 id="ce-databind-class-section" class="subsection-title">
   *   :Class Attribute<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-class-section"></a>
   * </h2>
   * <p>
   *   The class attribute binding supports a space delimited string of classes, an Array of classes, or an Object whose keys are
   *   individual style classes and whose values are booleans to determine whether those style classes should be present in the DOM
   *   (e.g. :class="[[{errorClass: hasErrors}]]"). Note that the Array and string types will override existing values in the class
   *   attribute when updates occur, whereas the Object type will only add and remove the classes specified. Since JET custom elements
   *   add their own classes, we recommend using the Object type when using the class attribute binding on JET custom elements.
   * </p>
   * <h2 id="ce-databind-style-section" class="subsection-title">
   *   :Style Attribute<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-style-section"></a>
   * </h2>
   * <p>
   *   When using the style attribute binding with an Object type, the style Object names should be the JavaScript
   *   names for that style (e.g. "fontWeight" instead of "font-weight" style='{"fontWeight": "..."}').
   *   Since the style attribute supports Object types, it also supports dot notation for setting style subproperties
   *   directly (e.g. :style.font-weight="[[...]]").
   * </p>
   *
   * <h2 id="ce-properties-section" class="subsection-title">
   *   Properties<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-section"></a>
   * </h2>
   * <p>
   *   In addition to properties inherited from the HTMLElement prototype, attributes listed
   *   in the component API doc will also be exposed as properties on the JET custom element.
   *   See the <a href="#ce-proptoattr-section">property to attribute mapping</a>
   *   section below to see the syntax difference between setting attributes and properties.
   *   These properties can be set at any time, but can only be retrieved once the HTML element
   *   is fully upgraded. Early property sets before the component has been upgraded
   *   will not result in [property]Changed events and will be passed to the component as part of its initial state.
   * </p>
   * <h2 id="ce-properties-readonlywriteback-section" class="subsection-title">
   *   Read-only and Writeback Properties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-readonlywriteback-section"></a>
   * </h2>
   * <p>
   *   Some properties are specially marked as read-only or supporting writeback in the component API doc.
   *   Read-only properties can only be read and not set by the application and generally support writeback.
   *   Writeback properties support automatic updates if they are bound using two way data binding syntax to an
   *   expression, e.g. value="{{valueObservable}}".
   *   Applications can bind an expression to a read-only attribute in HTML by using the {{..}} to ensure
   *   that updates will be reflected in the observable, but should not use this syntax to try and push a
   *   value to the read-only attribute which will result in an error state.
   *   Similarly, property sets using the setProperty, setProperties, or the element property setters should also
   *   be avoided for a read-only property.
   * </p>
   * <h2 id="ce-properties-subproperties-section" class="subsection-title">Subproperties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-subproperties-section"></a>
   * </h2>
   * <p>
   *   Some JET components support complex properties where the top level property is of type Object and it
   *   contains additional subproperties. If the application needs to set a single subproperty
   *   instead of the entire complex property, the <code>setProperty</code> method should be used
   *   instead to ensure that [property]Changed events will be fired with the subproperty changes.
   *   Note that directly updating the subproperty via dot notation (e.g. element.topProp.subProp = newValue)
   *   will not result in a [property]Changed event being fired.
   * </p>
   * <h2 id="ce-properties-unset-section" class="subsection-title">Unsetting of a Property
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-unset-section"></a>
   * </h2>
   * <p>
   *   The undefined value is treated as unsetting of a property when passed to the
   *   property setter and will result in the component using the default value if one exists. Unsetting of
   *   subproperties using the element's <code>setProperty</code> is not supported. Subproperties can only
   *   only be unset when the top level property is unset.
   *   Property sets will not result in DOM attribute updates and after the custom
   *   element is upgraded, the application should use the custom element properties, not attributes to check
   *   the current value.
   * </p>
   * <h2 id="ce-properties-changed-section" class="subsection-title">[property]Changed Events
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-changed-section"></a>
   * </h2>
   * <p>
   *   When a property or attribute value changes, a non-bubbling [property]Changed <code>CustomEvent</code>
   *   will be fired with the following properties in the event's detail property.
   *   <table class="props">
   *     <thead>
   *       <tr>
   *         <th>Name</th>
   *         <th>Type</th>
   *         <th>Description</th>
   *       </tr>
   *     </thead>
   *     <tbody>
   *       <tr>
   *      <td>value</td>
   *      <td>any</td>
   *      <td>The current value of the property that changed.</td>
   *    </tr>
   *    <tr>
   *      <td>previousValue</td>
   *      <td>any</td>
   *      <td>The previous value of the property that changed.</td>
   *    </tr>
   *    <tr>
   *      <td>updatedFrom</td>
   *      <td>string</td>
   *      <td>
   *        Where the property was updated from. Supported values are:
   *        <ul>
   *          <li>external - By the application, using either the element's property setter, setAttribute, or external data binding.</li>
   *          <li>internal - By the component, e.g. after user interaction with a text field or selection.</li>
   *        </ul>
   *      </td>
   *    </tr>
   *    <tr>
   *      <td>subproperty</td>
   *      <td>Object</td>
   *      <td>An object holding information about the subproperty that changed.
   *        <table class="props">
   *          <thead>
   *            <tr>
   *              <th>Name</th>
   *              <th>Type</th>
   *              <th>Description</th>
   *            </tr>
   *          </thead>
   *        <tbody>
   *          <tr>
   *            <td>path</td>
   *            <td>string</td>
   *            <td>
   *              The subproperty path that changed, starting from the top level
   *              property with subproperties delimited by ".".
   *            </td>
   *          </tr>
   *          <tr>
   *            <td>value</td>
   *            <td>any</td>
   *            <td>The current value of the subproperty that changed.</td>
   *          </tr>
   *          <tr>
   *            <td>previousValue</td>
   *            <td>any</td>
   *            <td>The previous value of the subproperty that changed.</td>
   *            </tr>
   *            </tbody>
   *          </table>
   *        </td>
   *      </tr>
   *    </tbody>
   *   </table>
   * </p>
   * <p>
   *   Please note that in order for components to be notified of a property change for Array properties, the
   *   value should be data bound and updated using an expression, setting the property to an updated copy
   *   by calling slice(), or by refreshing the component after an in place Array mutation.
   * </p>
   * <p>
   *   See <a href="#ce-events-section">Events and Listeners</a> for additional information on how to listen for
   *   these events.
   * </p>
   * <p>
   * Note as well that in cases where a component property that supports writeback is bound to a writable expression,
   * the relative order of expression writing and invocation of property change listeners is not guaranteed.
   * For this reason, it is not recommended to write logic that depends both on component/event state and application
   * view model state.
   * </p>
   * <h2 id="ce-proptoattr-section" class="subsection-title">Property-to-Attribute Mapping
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-proptoattr-section"></a>
   * </h2>
   * <p>
   *   The following rules apply when mapping property to attribute names:
   *   <ul>
   *     <li>Attribute names are case insensitive. CamelCased properties are mapped to
   *   kebab-cased attribute names by inserting a dash before the uppercase letter and converting that letter to lower case
   *   (e.g. a "chartType" property will be mapped to a "chart-type" attribute).</li>
   *     <li> The reverse occurs when mapping a property name from an attribute name.</li>
   *   </ul>
   * </p>
   *
   * <h2 id="ce-methods-section" class="subsection-title">
   *   Methods<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-methods-section"></a>
   * </h2>
   * <p>
   *   Methods can be accessed on the JET component after the element is fully upgraded. See
   *   the component API doc for specifics.
   * </p>
   *
   * <h2 id="ce-events-section" class="subsection-title">
   *   Events and Listeners<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-events-section"></a>
   * </h2>
   * <p>
   *   JET Web Components, like other custom HTML elements, may fire <code>CustomEvents</code>.  These
   *   events will be described in component documentation, including whether they bubble, are cancelable and any
   *   event detail payloads. In addition, JET components
   *   fire non-bubbling, non-cancelable [property]Changed (e.g. valueChanged) <code>CustomEvents</code>
   *   whenever a property is updated. See the <a href="#ce-properties-section">properties section</a> above
   *   for details on the event payload.
   * </p>
   *  <p>
   *   JET <code>CustomEvents</code> can be listened to using the standard addEventListener mechanism:
   *   <pre class="prettyprint">
   *   <code>
   * someElement.addEventListener("eventName", function(event) {...});
   *   </code>
   *   </pre>
   * </p>
   * <p>
   *   Additionally, JET custom elements and native HTML elements within JET pages support declarative specification of event
   *   listeners via <code>on-[event-name]</code> attributes (e.g. <code>on-click</code>,
   *   <code>on-value-changed</code> or <code>on-oj-expand</code>). The attributes ultimately delegate to the standard
   *   <code>addEventListener</code> mechanism and only support data bound expressions
   *   that evaluate to functions; arbitrary JavaScript will not be accepted.
   * </p>
   * <p>
   *   Please note that event listeners specified using this syntax can only be set during component initialization.
   *   Subsequent setAttribute calls for the event listener attributes will be ignored.
   *   There is no associated <code>on[EventName]</code> property on the JET custom element for the equivalent
   *   <code>on-[event-name]</code> attribute.
   * </p>
   * <p>
   *   In addition to the event parameter, event listeners specified via <code>on-[event-name]</code>
   *   attributes will receive two additional parameters when they are invoked: <code>data</code> and <code>bindingContext</code>.
   *   The <code>bindingContext</code> parameter provides the listener with the entire data binding context that
   *   was applied to the element while the data parameter provides convenient access to relevant data.
   *   When in an iteration context (e.g. inside an <code>oj-bind-for-each</code>), the <code>data</code> parameter
   *   is equal to <code>bindingContext["$current"]</code>; otherwise, it is equal to <code>bindingContext["$data"]</code>.
   *   These declarative event listeners should take the form:
   *   <pre class="prettyprint">
   *   <code>
   * &lt;oj-some-element on-event-name="[[eventListener]]">&lt;/oj-some-element>
   *
   *
   * function eventListener(event, data, bindingContext) {
   *   ...
   * }
   *   </code>
   *   </pre>
   * </p>
   *
   * <h2 id="ce-slots-section" class="subsection-title">
   *   Slots<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-slots-section"></a>
   * </h2>
   * <p>
   *  Some JET components allow application provided child content. This child content will be moved by the JET component to
   *  a designated "slot" and is referred to as slot content. Slot content can have one of two characteristics:
   *  <ul>
   *    <li>
   *      Named slot content - Any direct child element with a slot attribute will be moved into that named slot, e.g.  &lt;span slot='startIcon'>... &lt;/span>.
   *      All supported named slots are described in the API Doc. Child elements with unsupported named slots will be removed from the DOM.
   *    </li>
   *    <li>
   *      Default slot content - Any direct child element lacking a slot attribute will be moved to the default slot, also known as a regular child.
   *    </li>
   *  </ul>
   *  Bindings are applied to slot content in the application's context with the exception of template slots which are described
   *  below. Slot content are moved to their designated component slots after bindings are applied. <b>Please note that only text and
   *  element nodes can be assigned to a slot. Comment nodes are not eligible, so oj-bind-* elements which resolve to comment nodes
   *  after bindings are applied should be wrapped in a span or other element node for slotting.</b>
   * </p>
   * <h3 id="ce-slots-template-section" class="subsection-title">
   *   Template Slots<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-slots-template-section"></a>
   * </h3>
   * <p>
   *  Some components support template slots which allow the application to pass a template element with a DOM fragment that
   *  will be stamped out by the component. Bindings are not applied to template slot content until they are stamped out by the
   *  component. All template slot children will have access to the following variables:
   *  <ul>
   *    <li>$current - Default variable that contains component exposed subproperties as documented in the component's API doc.</li>
   *    <li>component-level template alias - Set by the application if the component has provided a component-level alias attribute
   *        as part of its API. Provides a template alias available to all template slot binding contexts and has the same
   *        subproperties as the $current variable.</li>
   *    <li>template-level alias - Set by the application on the template element via the 'data-oj-as' attribute. Provides an alias
   *        for a specific template instance and has the same subproperties as the $current variable.</li>
   *  </ul>
   *  Note that $current is always availble on the binding context regardless of whether any application provided aliases are set.
   * </p>
   *
   * @ojfragment customElementOverviewDoc - General description doc fragment that shows up in every component's page via a link.
   * @memberof CustomElementOverview
   */

  /**
   * Add's the os and browser agent classes to the body tag
   * @private
   */
  function _ojApplyAgentClasses() {
    let classes = [];
    const ai = oj$1.AgentUtils.getAgentInfo();
    classes.push(`oj-agent-os-${ai.os.toLowerCase()}`);
    classes.push(`oj-agent-browser-${ai.browser.toLowerCase()}`);
    var html = document.documentElement;
    html.classList.add(...classes);
  }

  Bootstrap.whenDocumentReady().then(function () {
    _ojApplyAgentClasses();
  });

});


define('ojs/ojdomutils',['exports', 'ojs/ojthemeutils', 'ojs/ojcore-base', 'jquery'], function (exports, ThemeUtils, oj, $) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * DOM utilities.
   * @ignore
   */
  const DomUtils = {
    _HTML_START_TAG: '\x3chtml\x3e',
    _HTML_END_TAG: '\x3c/html\x3e',
    _LEGAL_ELEMENTS: {
      SPAN: 1,
      B: 1,
      I: 1,
      EM: 1,
      BR: 1,
      HR: 1,
      LI: 1,
      OL: 1,
      UL: 1,
      P: 1,
      TT: 1,
      BIG: 1,
      SMALL: 1,
      PRE: 1
    },
    _LEGAL_ATTRIBUTES: { class: 1, style: 1 }
  };

  /**
   * Returns true if the value is null or if the trimmed value is of zero length.
   *
   * @param {string|null} content
   * @return {boolean} true if the string is wrapped in <html> tag.
   */
  DomUtils.isHTMLContent = function (content) {
    if (
      content.indexOf(DomUtils._HTML_START_TAG) === 0 &&
      content.lastIndexOf(DomUtils._HTML_END_TAG) === content.length - 7
    ) {
      return true;
    }

    return false;
  };

  DomUtils.cleanHtml = function (value) {
    var offSpan = $(document.createElement('span')).get(0);
    offSpan.innerHTML = value; // @HTMLUpdateOK safe manipulation
    if (value && value.indexOf('\x3c') >= 0) {
      DomUtils._cleanElementHtml(offSpan);
    }
    return offSpan;
  };

  DomUtils._cleanElementHtml = function (node) {
    var children = node.childNodes;

    for (var count = children.length - 1; count >= 0; count--) {
      var child = children.item(count);
      if (child && child.nodeType === 1) {
        if (DomUtils._LEGAL_ELEMENTS[child.nodeName]) {
          var attrs = child.attributes;
          for (var i = attrs.length - 1; i >= 0; i--) {
            var attr = attrs[i];
            // jquery - the .attr() method returns undefined for attributes that have not been set.
            var childHasAttr = $(child).attr(attr.name) !== undefined;
            if (childHasAttr) {
              if (!DomUtils._LEGAL_ATTRIBUTES[attr.name]) {
                child.removeAttribute(attr.nodeName);
              }
            }
          }
          DomUtils._cleanElementHtml(child);
        } else if (child) {
          node.removeChild(child);
        }
      }
    }
  };

  /**
   * Checks to see if the "ancestorNode" is a ancestor of "node".
   *
   * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
   * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
   * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node".
   */
  DomUtils.isAncestor = function (ancestorNode, node) {
    // These can cause problems in IE11: sometimes the node is just an "empty" object
    // oj.Assert.assertDomElement(ancestorNode);
    // oj.Assert.assertDomElement(node);

    var parentNode = node.parentNode;

    while (parentNode) {
      if (parentNode === ancestorNode) {
        return true;
      }

      parentNode = parentNode.parentNode;
    }

    return false;
  };

  /**
   * Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
   *
   * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
   * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
   * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node" or if they are the same
   */
  DomUtils.isAncestorOrSelf = function (ancestorNode, node) {
    // These can cause problems in IE11: sometimes the node is just an "empty" object
    // oj.Assert.assertDomElement(ancestorNode);
    // oj.Assert.assertDomElement(node);

    return node === ancestorNode ? true : DomUtils.isAncestor(ancestorNode, node);
  };

  /**
   * Adds a resize listener for a block or inline-block element
   * @param {!Element} elem - node where the listener should be added
   * @param {!Function} listener - listener to be added. The listener will receive
   * two parameters: 1) the new width in pixels; 2) the new height in pixels
   * @param {number=} collapseEventTimeout - timeout in milliseconds for collapsing
   * multiple resize events into one
   * @param {boolean=} useResizeObserver - use ResizeObserver-based implementation if supported by the browser
   * @export
   */
  DomUtils.addResizeListener = function (elem, listener, collapseEventTimeout, useResizeObserver) {
    let map = DomUtils._RSZ_TRKR;
    if (useResizeObserver) {
      map = DomUtils._RSZ_TRKR_OBS;
      // remember that this particular listener is associated with a resize observer-based tracker
      DomUtils._OBS_BASED.set(listener, true);
    }
    let tracker = map.get(elem);
    if (tracker == null) {
      tracker = new DomUtils._ResizeTracker(elem, useResizeObserver);
      map.set(elem, tracker);
      tracker.start();
    }
    tracker.addListener(listener, collapseEventTimeout);
  };

  /**
   * Removes a resize listener
   * @param {!Element} elem - node whose listener should be removed
   * @param {!Function} listener - listener to be removed
   * @export
   */
  DomUtils.removeResizeListener = function (elem, listener) {
    const useResizeObserver = DomUtils._OBS_BASED.get(listener);
    const map = useResizeObserver ? DomUtils._RSZ_TRKR_OBS : DomUtils._RSZ_TRKR;
    const tracker = map.get(elem);
    if (tracker != null) {
      tracker.removeListener(listener);
      if (tracker.isEmpty()) {
        tracker.stop();
        map.delete(elem);
      }
    }
  };

  /**
   * Fixes resize listeners after a subtree has been connected to the DOM or after
   * its display:none stayle has been removed
   * @param {!Element} subtreeRoot - subtree root
   */
  DomUtils.fixResizeListeners = function (subtreeRoot) {
    $(subtreeRoot)
      .find('.oj-helper-detect-expansion')
      .parent()
      .each(function (index, div) {
        var tracker = DomUtils._RSZ_TRKR.get(div);
        if (tracker != null) {
          tracker.init(true);
        }
      });
  };

  /**
   * Determines whether a special 'meta' key was pressed when the event was fired.
   * For Mac OS, the 'meta' key is mapped to the 'Command' key, for all other platforms it is mapped
   * to the 'Control' key.
   * Note that this method will only work for the events that support .ctrlKey and .metaKey fields.
   * @param {!Object} evt - the event
   * @return true if the meta key is pressed, false otherwise
   */
  DomUtils.isMetaKeyPressed = function (evt) {
    var agentInfo = oj.AgentUtils.getAgentInfo();
    return oj.AgentUtils.OS.MAC === agentInfo.os ? evt.metaKey : evt.ctrlKey;
  };

  /**
   * Dispatches an event on the element
   * @param {!Element} element
   * @param {!Event} evt event object
   */
  DomUtils.dispatchEvent = function (element, evt) {
    // Workaround for Mozilla issue #329509 - dispatchEvent() throws an error if
    // the element is disabled and disconnected
    // Also, IE simply ignores the .dispatchEvent() call for disabled elements
    var dis = 'disabled';
    var oldDisabled = element[dis];
    try {
      // eslint-disable-next-line no-param-reassign
      element[dis] = false;
      element.dispatchEvent(evt);
    } finally {
      // eslint-disable-next-line no-param-reassign
      element[dis] = oldDisabled;
    }
  };

  /**
   * @private
   */
  DomUtils._invokeAfterPaint = (
    window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function (fn) {
      return window.setTimeout(fn, 0); // @HTMLUpdateOK
    }
  ).bind(window);

  /**
   * @private
   */
  DomUtils._cancelInvokeAfterPaint = (
    window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    function (id) {
      return window.clearTimeout(id);
    }
  ).bind(window);

  /**
   * Utility class for tracking resize events for a given element and  sispatching them
   * to listeners
   * @constructor
   * @ignore
   * @private
   */
  DomUtils._ResizeTracker = function (div, useResizeObserver) {
    // Normalize div to an actual DOM element. Many qUnit
    // tests are incorrectly passing jQuery locators instead
    if (div instanceof $) {
      // eslint-disable-next-line no-param-reassign
      div = div[0];
    }

    // The 'data-oj-resize-notify' attribute has been added to be used in qunit tests.
    // Previously a test added a resize listener called on timeout, which made the test brittle.
    // Now a resize test might add the 'data-oj-resize-notify' attribute to the component
    // and get notified when the component receives resize notification.
    var _fireResizeDomEvent = div.hasAttribute('data-oj-resize-notify');
    var _listeners = $.Callbacks();
    var _collapsingManagers = [];
    var _collapsingListeners = [];

    var _RETRY_MAX_COUNT = 2;
    var _retrySetScroll = 0;
    var _invokeId = null;
    var _oldWidth = null;
    var _oldHeight = null;
    var _detectExpansion = null;
    var _detectContraction = null;
    var _scrollListener = null;
    var _resizeObserver = null;

    this.addListener = function (listener, collapseEventTimeout) {
      if (
        collapseEventTimeout === undefined ||
        isNaN(collapseEventTimeout) ||
        collapseEventTimeout === 0
      ) {
        _listeners.add(listener);
      } else {
        // See comments above for _fireResizeDomEvent.
        var _wrappedOrigListener = () => {
          listener.apply(null, arguments);
          div.dispatchEvent(new Event('oj-resize'));
        };
        _collapsingManagers.push(
          new DomUtils._collapsingListenerManager(
            _fireResizeDomEvent ? _wrappedOrigListener : listener,
            collapseEventTimeout
          )
        );
        _collapsingListeners.push(listener);
      }
    };

    this.removeListener = function (listener) {
      var index = _collapsingListeners.indexOf(listener);
      if (index >= 0) {
        _collapsingListeners.splice(index, 1);
        var removed = _collapsingManagers.splice(index, 1);
        removed[0].stop();
      } else {
        _listeners.remove(listener);
      }
    };

    this.isEmpty = function () {
      return !_listeners.has() && _collapsingListeners.length === 0;
    };

    this.start = function () {
      if (useResizeObserver && window.ResizeObserver instanceof Function) {
        _resizeObserver = new ResizeObserver(_resizeObserverCallback);
        _resizeObserver.observe(div, { box: 'border-box' });
      } else {
        _scrollListener = _handleScroll;

        var firstChild = div.childNodes[0];

        // This child DIV will track expansion events. It is meant to be 1px taller and wider than the DIV
        // whose resize events we are tracking. After we set its scrollTop and scrollLeft to 1, any increate in size
        // will fire a scroll event
        _detectExpansion = document.createElement('div');
        _detectExpansion.className = 'oj-helper-detect-expansion';
        var expansionChild = document.createElement('div');
        _detectExpansion.appendChild(expansionChild); // @HTMLUpdateOK expansionChild constructed by the code above
        if (firstChild != null) {
          div.insertBefore(_detectExpansion, firstChild); // @HTMLUpdateOK _detectExpansion constructed by the code above
        } else {
          div.appendChild(_detectExpansion); // @HTMLUpdateOK _detectExpansion constructed by the code above
        }

        _detectExpansion.addEventListener('scroll', _scrollListener, false);

        // This child DIV will track contraction events. Its height and width are set to 200%. After we set its scrollTop and
        // scrollLeft to the current height and width of its parent, any decrease in size will fire a scroll event
        _detectContraction = document.createElement('div');
        _detectContraction.className = 'oj-helper-detect-contraction';

        var contractionChild = document.createElement('div');
        contractionChild.style.width = '200%';
        contractionChild.style.height = '200%';
        _detectContraction.appendChild(contractionChild); // @HTMLUpdateOK contractionChild constructed by the code above
        div.insertBefore(_detectContraction, _detectExpansion); // @HTMLUpdateOK _detectContraction constructed by the code above

        _detectContraction.addEventListener('scroll', _scrollListener, false);

        this.init(false);
      }
    };

    this.stop = function () {
      if (_invokeId != null) {
        DomUtils._cancelInvokeAfterPaint(_invokeId);
        _invokeId = null;
      }
      if (_resizeObserver != null) {
        _resizeObserver.disconnect();
        _resizeObserver = null;
      } else if (_detectExpansion != null) {
        _detectExpansion.removeEventListener('scroll', _scrollListener);
        _detectContraction.removeEventListener('scroll', _scrollListener);
        // Check before removing to prevent CustomElement polyfill from throwing
        // a NotFoundError when removeChild is called with an element not in the DOM
        if (_detectExpansion.parentNode) {
          div.removeChild(_detectExpansion);
        }
        if (_detectContraction.parentNode) {
          div.removeChild(_detectContraction);
        }
      }
    };

    this.init = function (isFixup) {
      if (_detectExpansion) {
        var adjusted = _checkSize(isFixup);
        if (isFixup && !adjusted && _detectExpansion.offsetParent != null) {
          _adjust(_oldWidth, _oldHeight);
        }
      }
    };

    function _checkSize(fireEvent) {
      var adjusted = false;
      if (_detectExpansion.offsetParent != null) {
        var newWidth = _detectExpansion.offsetWidth;
        var newHeight = _detectExpansion.offsetHeight;

        if (_oldWidth !== newWidth || _oldHeight !== newHeight) {
          _retrySetScroll = _RETRY_MAX_COUNT;
          _adjust(newWidth, newHeight);
          adjusted = true;

          if (fireEvent) {
            _notifyListeners(true);
          }
        }
      }

      return adjusted;
    }

    function _resizeObserverCallback(entries) {
      // we are observing only one element, so there should be a single entry
      const outer = entries[0].borderBoxSize;
      // MDN states that borderBoxSize may be either a direct entry (true for Firefox) or
      // an array of entries (true for Chrome)
      const newWidth = outer ? (outer[0] || outer).inlineSize : div.offsetWidth;
      const newHeight = outer ? (outer[0] || outer).blockSize : div.offsetHeight;
      _notifyListeners(false, [newWidth, newHeight]);
    }

    // the size parameter will be dfined only for ResizeObserver
    function _notifyListeners(useAfterPaint, size) {
      var newWidth = size ? size[0] : div.offsetWidth;
      var newHeight = size ? size[1] : div.offsetHeight;
      var listenersWrapper = (width, height) => {
        _listeners.fire(width, height);
        if (_fireResizeDomEvent) {
          div.dispatchEvent(new Event('oj-resize'));
        }
      };
      if (_listeners.has()) {
        if (!useAfterPaint) {
          listenersWrapper(newWidth, newHeight);
        } else {
          if (_invokeId !== null) {
            DomUtils._cancelInvokeAfterPaint(_invokeId);
          }

          _invokeId = DomUtils._invokeAfterPaint(function () {
            _invokeId = null;
            listenersWrapper(newWidth, newHeight);
          });
        }
      }

      for (var i = 0; i < _collapsingManagers.length; i++) {
        _collapsingManagers[i].getCallback()(newWidth, newHeight);
      }
    }

    function _handleScroll(evt) {
      evt.stopPropagation();
      if (!_checkSize(true)) {
        // Workaround for the WebKit issue where scrollLeft gets reset to 0 without the DIV being expanded
        // We will retry to the set the scrollTop only twice to avoid infinite loops
        if (
          _retrySetScroll > 0 &&
          _detectExpansion.offsetParent != null &&
          (_detectExpansion.scrollLeft === 0 || _detectExpansion.scrollTop === 0)
        ) {
          _retrySetScroll -= 1;
          _adjust(_oldWidth, _oldHeight);
        }
      }
    }

    function _adjust(width, height) {
      _oldWidth = width;
      _oldHeight = height;

      var expansionChildStyle = _detectExpansion.firstChild.style;

      var delta = 1;

      // The following loop is a workaround for the WebKit issue with zoom < 100% -
      // the scrollTop/Left gets reset to 0 because it gets computed to a value less than 1px.
      // We will try up to the delta of 5 to support scaling down to 20% of the original size
      do {
        expansionChildStyle.width = width + delta + 'px';
        expansionChildStyle.height = height + delta + 'px';
        _detectExpansion.scrollLeft = delta;
        _detectExpansion.scrollTop = delta;
        delta += 1;
      } while ((_detectExpansion.scrollTop === 0 || _detectExpansion.scrollLeft === 0) && delta <= 5);

      _detectContraction.scrollLeft = width;
      _detectContraction.scrollTop = height;
    }
  };

  // a weak element-to-legacy-tracker map
  DomUtils._RSZ_TRKR = new WeakMap();
  // a weak element-observer-based-tracker map
  DomUtils._RSZ_TRKR_OBS = new WeakMap();
  // a weak map with true values for observer-based resize listeners
  DomUtils._OBS_BASED = new WeakMap();

  /**
   * Returns true if the name is a valid identifier
   *
   * @param {string} name
   * @return {boolean} true if the name is a valid identifier
   */
  DomUtils.isValidIdentifier = function (name) {
    return /^[A-Za-z][0-9A-Z_a-z-]*$/.test(name);
  };

  /**
   * @constructor
   * @ignore
   */

  DomUtils._collapsingListenerManager = function (originalCallback, timeout) {
    var _lastArgs = null;
    var _timerId = null;

    var _timerCallback = function () {
      originalCallback.apply(null, _lastArgs);
      _timerId = null;
    };

    var _callback = function () {
      _lastArgs = Array.prototype.slice.call(arguments);
      if (_timerId == null) {
        _timerId = window.setTimeout(_timerCallback, timeout);
      }
    };

    this.getCallback = function () {
      return _callback;
    };

    this.stop = function () {
      if (_timerId != null) {
        window.clearTimeout(_timerId);
        _timerId = null;
      }
    };
  };

  /**
   * @return {boolean} true if touch is supported
   */
  DomUtils.isTouchSupported = function () {
    return (
      'ontouchstart' in window || // C, FF, Safari, Edge
      navigator.msMaxTouchPoints > 0 || // IE10
      navigator.maxTouchPoints > 0
    ); // IE11
  };

  /**
   * @ignore
   */
  DomUtils.setInKoCleanExternal = function (node) {
    DomUtils._koCleanNode = node;
  };

  /**
   * Delegates to JQuery's unwrap() if the component's node is not currently
   * being removed by Knockout
   * @param {Object} locator
   * @param {Object=} replaceLocator - locator to be replaced. I fthis parameter is ommitted,
   * the parent node will be replaced
   * @ignore
   */
  DomUtils.unwrap = function (locator, replaceLocator) {
    var koCleanNode = DomUtils._koCleanNode;

    if (koCleanNode) {
      if (locator.get(0) === koCleanNode) {
        // skip unwrap
        return;
      }
    }

    if (replaceLocator) {
      replaceLocator.replaceWith(locator); // @HTMLUpdateOK
    } else {
      locator.unwrap();
    }
  };

  /**
   * Determines if the mouse event target is on browser chrome - i.e. "scrollbar".
   * If the event is not a mouse event with a clientX and clientY, the resultant will
   * be false.
   *
   * @param {Event} event native dom event
   * @returns {boolean} <code>true</code> if the target of the mouse event is browser
   *          chrome such as scrollbars.
   * @public
   */
  DomUtils.isChromeEvent = function (event) {
    // verify event is a mouse event
    if (!('clientX' in event) || !('clientY' in event)) {
      return false;
    }

    var agentInfo = oj.AgentUtils.getAgentInfo();

    if (oj.AgentUtils.OS.ANDROID === agentInfo.os || oj.AgentUtils.OS.IOS === agentInfo.os) {
      return false;
    }

    if (
      agentInfo.engine !== oj.AgentUtils.ENGINE.GECKO &&
      agentInfo.engine !== oj.AgentUtils.ENGINE.WEBKIT &&
      agentInfo.engine !== oj.AgentUtils.ENGINE.BLINK &&
      agentInfo.browser !== oj.AgentUtils.BROWSER.IE
    ) {
      // unknown engine/browser
      return false;
    }

    var isLTR = DomUtils.getReadingDirection() === 'ltr';
    // Safari puts the main scrollbar on the left in RTL
    var isMainScrollbarOnTheLeft = !isLTR && agentInfo.browser === oj.AgentUtils.BROWSER.SAFARI;

    var domTarget = event.target;
    var target = $(domTarget);

    var pos = domTarget.getBoundingClientRect();
    var sbw = DomUtils.getScrollBarWidth();

    if (
      isLTR &&
      (domTarget.nodeName === 'HTML' || target.css('overflow-x') !== 'visible') &&
      event.clientX > pos.right - sbw
    ) {
      // ltr scrollbar is always on the right
      return true;
    } else if (
      !isLTR &&
      !isMainScrollbarOnTheLeft &&
      domTarget.nodeName === 'HTML' &&
      event.clientX > pos.right - sbw
    ) {
      // RTL scrollbar on the document is still on the right
      return true;
    } else if (!isLTR && target.css('overflow-x') !== 'visible' && event.clientX < pos.left + sbw) {
      // RTL scrollbar is on the left
      return true;
    } else if (
      (domTarget.nodeName === 'HTML' || target.css('overflow-y') !== 'visible') &&
      event.clientY > pos.bottom - sbw
    ) {
      // below the scrollbar
      return true;
    }
    return false;
  };

  /**
   * @returns {number} width of the browser scrollbar
   */
  DomUtils.getScrollBarWidth = function () {
    // delegate to our (CSP compliant) version of jqueryUI's $.position.scrollBarWidth
    return $.position.scrollbarWidth();
  };

  /**
   * @returns {string!} "rtl" or "ltr"
   */
  DomUtils.getReadingDirection = function () {
    var dir = document.documentElement.getAttribute('dir');
    if (dir) {
      dir = dir.toLowerCase();
    }
    return dir === 'rtl' ? 'rtl' : 'ltr';
  };

  /**
   * Sets the bidi independent position of the horizontal scroll position that
   * is consistent across all browsers.
   * @param {Element} elem the element to set the scrollLeft on
   * @param {number} scrollLeft the element's new scrollLeft
   */
  DomUtils.setScrollLeft = function (elem, scrollLeft) {
    // eslint-disable-next-line no-param-reassign
    elem.scrollLeft = DomUtils.calculateScrollLeft(scrollLeft);
  };
  /**
   * Calculates the bidi independent position of the horizontal scroll position that
   * is consistent across all browsers.
   * @param {number} scrollLeft the element's new scrollLeft
   * @returns {number} new scroll left value
   */
  DomUtils.calculateScrollLeft = function (scrollLeft) {
    // eslint-disable-next-line no-param-reassign
    var resultScrollLeft = scrollLeft;
    if (DomUtils.getReadingDirection() === 'rtl') {
      var browser = oj.AgentUtils.getAgentInfo().browser;
      if (browser !== oj.AgentUtils.BROWSER.IE && browser !== oj.AgentUtils.BROWSER.EDGE) {
        // old ie/edge still have positive values for scrollLeft
        // webkit used to not support -scrollLeft and had to be calculated, chromium 
        // mozilla always supported this a -scrollLeft, mozilla 
        // expect a negative value for RTL
        // eslint-disable-next-line no-param-reassign
        resultScrollLeft = -scrollLeft;
      }
    }
    return resultScrollLeft;
  };

  /**
   * Converts a CSS length attribute into a integer value.
   * Conversion errors or non-number will result in a zero
   * resultant.
   *
   * @param {?} cssLength style attribute
   * @return {number} value as integer
   */
  DomUtils.getCSSLengthAsInt = function (cssLength) {
    if (!isNaN(cssLength)) {
      return parseInt(cssLength, 10);
    }

    if (cssLength && cssLength.length > 0 && cssLength !== 'auto') {
      var intLength = parseInt(cssLength, 10);

      if (isNaN(intLength)) {
        intLength = 0;
      }

      return intLength;
    }

    return 0;
  };

  /**
   * Converts a CSS attribute into a float value.
   * Conversion errors or non-number will result in a zero
   * resultant.
   *
   * @param {?} cssLength style attribute
   * @return {number} value as integer
   */
  DomUtils.getCSSLengthAsFloat = function (cssLength) {
    if (!isNaN(cssLength)) {
      return parseFloat(cssLength);
    }

    if (cssLength && cssLength.length > 0) {
      var floatLength = parseFloat(cssLength);

      if (isNaN(floatLength)) {
        floatLength = 0;
      }

      return floatLength;
    }

    return 0;
  };

  /**
   * Converts a CSS time unit (s, ms) into milliseconds.
   *
   * @param {?} cssTimeUnit value in css time unit
   * @return {number} value in milliseconds
   */
  DomUtils.getCSSTimeUnitAsMillis = function (cssTimeUnit) {
    if (!isNaN(cssTimeUnit)) {
      // assume time is already in milliseconds
      return parseInt(cssTimeUnit, 10);
    }

    if (cssTimeUnit && cssTimeUnit.length > 0) {
      var timeValue = parseFloat(cssTimeUnit);

      if (isNaN(timeValue)) {
        timeValue = 0;
      } else {
        var str = cssTimeUnit + '';
        var lastDigit;
        if (str.length > 2 && str.endsWith('ms')) {
          lastDigit = str.slice(-3, -2);
        } else if (str.length > 1 && str.endsWith('s')) {
          lastDigit = str.slice(-2, -1);
        }

        if (isNaN(lastDigit)) {
          // all bogus value that isn't in the format of [number]['s'|'ms']
          timeValue = 0;
        } else if (!str.endsWith('ms') && str.endsWith('s')) {
          timeValue *= 1000;
        }
      }

      return timeValue;
    }

    return 0;
  };

  /**
   * Key used to store the logical parent of the popup element
   * as a jQuery data property. The logical parent refers the launcher of a popup.
   * @const
   * @private
   * @type {string}
   */
  DomUtils._LOGICAL_PARENT_DATA = 'oj-logical-parent';

  const LOGICAL_PARENT = Symbol.for('oj-logical-parent');

  /**
   * This method returns the launcher of a popup when it's open.
   * Returns undefined otherwise.
   *
   * @param {jQuery} element jquery element
   * @returns {any}
   * @see #setLogicalParent
   */
  DomUtils.getLogicalParent = function (element) {
    if (element) {
      return element.data(DomUtils._LOGICAL_PARENT_DATA);
    }

    return undefined;
  };

  /**
   * Set the logical parent as a jQuery data property
   *
   * @param {jQuery} element jquery element
   * @param {jQuery | null} parent jquery element
   * @see #getLogicalParent
   */
  DomUtils.setLogicalParent = function (element, parent) {
    if (!element) {
      return;
    }
    var domElem = element[0];
    if (!domElem) {
      return;
    }

    if (parent === null) {
      element.removeData(DomUtils._LOGICAL_PARENT_DATA);
      delete domElem[LOGICAL_PARENT];
    } else {
      element.data(DomUtils._LOGICAL_PARENT_DATA, parent);
      domElem[LOGICAL_PARENT] = parent[0];
    }
  };

  /**
   * Checks to see if the "ancestorNode" is a logical ancestor of "node"
   *
   * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
   * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
   * @return {boolean} <code>true</code> if the "ancestorNode" is a logical ancestor of "node" or if they are the same
   */
  DomUtils.isLogicalAncestorOrSelf = function (ancestorNode, node) {
    oj.Assert.assertDomElement(ancestorNode);
    oj.Assert.assertDomElement(node);

    var parentNode = node;
    while (parentNode) {
      if (parentNode === ancestorNode) {
        return true;
      }

      var logicalParent = DomUtils.getLogicalParent($(parentNode));
      if (logicalParent) {
        parentNode = logicalParent[0];
      } else {
        parentNode = parentNode.parentNode;
      }
    }

    return false;
  };

  /**
   * Checks whether the href represents a safe URL
   * @param {!string} href - HREF to test
   * @param {Array=} whitelist - optional list of the allowed protocols. Protocol name has to use lowercase letters and
   * be followed by a ':'. If the parameter is ommitted, ['http:', 'https:'] will be used
   * @throws {Exception} an error if the HREF represents an invalid URL
   * @ignore
   */
  DomUtils.validateURL = function (href, whitelist) {
    var allowed = whitelist || ['http:', 'https:'];

    var link = document.createElement('a');
    link.href = href;

    var protocol = link.protocol;
    if (protocol != null) {
      protocol = protocol.toLowerCase();
    }
    // if it isn't on the allowed list and it isn't '', throw an error.
    // IE11 returns '' for hrefs like 'abc', other browsers return 'https'
    // and we want to allow hrefs like 'abc' since those are relative urls.
    if (allowed.indexOf(protocol) < 0 && protocol !== '') {
      throw new Error(protocol + ' is not a valid URL protocol');
    }
  };

  /**
   * Cancels native context menu events for hybrid mobile applications.
   * @private
   */
  DomUtils._suppressNativeContextMenu = function () {
    if (
      $(document.body).hasClass('oj-hybrid') &&
      !$(document.body).hasClass('oj-hybrid-show-context-menu')
    ) {
      document.body.addEventListener(
        'contextmenu',
        function (event) {
          if (event.target.nodeName !== 'INPUT' && event.target.nodeName !== 'TEXTAREA') {
            event.preventDefault();
          }
        },
        true
      );
    }
  };
  DomUtils._suppressNativeContextMenu();

  // standard duration of a pressHold gesture.  Point of reference: default
  // JQ Mobile threshold to be a press-and-hold is 750ms.
  DomUtils.PRESS_HOLD_THRESHOLD = 750;

  // ------------------------------------------------------------------------------------------------
  // Recent touch end
  // ------------------------------------------------------------------------------------------------

  /**
   * Returns true if a touchend or touchcancel has been detected anywhere in the document in the last 500 ms.
   * Note: This function adds event listeners only once per document load.
   *
   * @return {boolean} boolean indicating whether a touch has recently been detected
   */
  DomUtils.recentTouchEnd = (function () {
    // This function is immediately executed and returns the recentTouchEnd function
    // and therefore only execute once per document load.

    var touchTimestamp = 0;
    var TOUCH_THRESHOLD = 500;

    function _touchEndHandler() {
      touchTimestamp = Date.now();
    }

    // --- Document listeners ---
    document.addEventListener('touchend', _touchEndHandler, true);
    document.addEventListener('touchcancel', _touchEndHandler, true);

    // --- The function assigned to DomUtils.recentTouchEnd ---

    return function () {
      // must be at least 300 for the "300ms" delay
      return Date.now() - touchTimestamp < TOUCH_THRESHOLD;
    };
  })();

  /**
   * Returns true if a touchstart has been detected anywhere in the document in the last 800 ms.
   * Note: This function adds event listeners only once per document load.
   *
   * @return {boolean} boolean indicating whether a touch has recently been detected
   */
  DomUtils.recentTouchStart = (function () {
    // This function is immediately executed and returns the recentTouchStart function
    // and therefore only execute once per document load.

    var touchTimestamp = 0;
    // 800 because this is used to ignore mouseenter and focusin on 'press', and a 'press'
    // is usually detected after 750ms.
    var TOUCH_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD + 50;

    function _touchStartHandler() {
      touchTimestamp = Date.now();
    }

    // --- Document listeners ---
    document.addEventListener('touchstart', _touchStartHandler, { passive: true, capture: true });

    // --- The function assigned to DomUtils.recentTouchStart ---

    return function () {
      // must be at least TOUCH_THRESHOLD for the  delay
      return Date.now() - touchTimestamp < TOUCH_THRESHOLD;
    };
  })();

  // ------------------------------------------------------------------------------------------------
  // Recent pointer
  // ------------------------------------------------------------------------------------------------

  /**
   * Returns true if a touchstart, touchend, mousedown, or mouseup has been detected anywhere in the
   * document in the last n ms, where n is calibrated across a variety of platforms to make this API
   * a maximally reliable indicator of whether the code now running was likely "caused by" the
   * specified touch and mouse interaction, vs. some other thing (e.g. mousemove, keyboard, or page
   * load).  E.g. the makeFocusable() / _focusable() mechanism uses this API to vary the focus theming
   * depending on whether the element was focused via keyboard or pointer.
   *
   * @return {boolean} boolean indicating whether a mouse button or finger has recently been down or up
   */
  DomUtils.recentPointer = (function () {
    // The comments in this function are tailored to the makeFocusable() usage.

    // - Let "pointer down" mean mousedown or touchstart, and "pointer up" likewise.  (Not MS pointer events.)
    // - Event order can be 1) mousedown>focus>mouseup (like push buttons) or 2) mousedown>mouseup>focus (like toggle buttons).
    // - For 2, semantics for "focus caused by pointer" must be "if pointer interaction in last n ms," rather than "if pointer is currently down".
    // - Those "last n ms" semantics are preferred for 1 as well, rather than relying on pointer up to cancel a state set by pointer down,
    //   since if the pointer up is never received, we'd get stuck in an inaccessible state.
    // - So both pointer down and pointer up set a timestamp, and recentPointer() returns true if Date.now() is within n ms of that timestamp,
    //   where n is higher for touchstart per below.

    // Timestamp of last mousedown/up or touchstart/end. Initial value of 0 (1/1/1970) guarantees that if element is focused before any
    // mouse/touch interaction, then recentPointer() is false, so focus ring appears as desired.
    var pointerTimestamp = 0;

    var pointerTimestampIsTouchStart; // whether the latest timestamp is for touchstart vs. touchend/mouse

    // On Edge (Surface Win10), the lag from the up event to resulting programmatic focus is routinely ~350ms, even when the 300ms "tap delay" has
    // been prevented and confirmed to be absent.  (In Chrome on same device the same lag is ~10 ms.)  So use 600ms to be safe.  Even on Chrome,
    // the lag from the down/up event to natively induced focus can routinely be well into the 1xx ms range. Can exceed 600 if needed. There is no
    // need for a tight bound; if there was pointer interaction in the last second or so, it's perfectly reasonable to suppress the focus ring.
    var POINTER_THRESHOLD_CUSHION = 600;

    // If the number of millis since the last pointer down or up is < this threshold, then recentPointer() considers it recent and returns true.
    // See also TOUCHSTART_THRESHOLD.
    var POINTER_THRESHOLD = POINTER_THRESHOLD_CUSHION;

    // For touchstart only, use 750+600ms so that focus set by a 750ms pressHold gesture (e.g. context menu) is recognized as touch-related.  Same
    // 600ms padding as for POINTER_THRESHOLD.  A high threshold is OK, as it is used only for actual pressHolds (and the unusual case where the
    // pointer up is never received), since for normal clicks and taps, the pointerUp replaces the "1350ms after touchstart" policy with a "600ms
    // after pointerUp" policy. On Edge and desktop FF (desktop version runs on hybrid devices like Surface), which lack touchstart, context menus
    // are launched by the contextmenu event, which happen after the pointer up in both browsers, so the fact that we're using the higher
    // threshold only for touchstart should not be a problem there.
    var TOUCHSTART_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD + POINTER_THRESHOLD_CUSHION;

    // --- Document listeners ---

    // Use capture phase to make sure we hear the events before someone cancels them
    document.addEventListener(
      'mousedown',
      function () {
        // If the mousedown immediately follows a touchstart, i.e. if it seems to be the compatibility mousedown
        // corresponding to the touchstart, then we want to consider it a "recent pointer activity" until the end time
        // that is max(touchstartTime + TOUCHSTART_THRESHOLD, now + POINTER_THRESHOLD), where now is mousedownTime in this
        // case.  (I.e. it would defeat the purpose if the inevitable mousedown replaced the longer touchstart threshold with
        // a shorter one.)  We don't do this in the touchend/mouseup listeners, as those obviously happen after the pressHold
        // is over, in which case the following analysis applies:
        // - If the pressHold was < PRESS_HOLD_THRESHOLD ms,
        // - then the higher TOUCHSTART_THRESHOLD is not needed or relevant, since anything focused on pressHold
        //   (like a context menu) never happened,
        // - else the touchend/mouseup happened > PRESS_HOLD_THRESHOLD ms after the touchstart, so in the max() above,
        //   the 2nd quantity is always bigger (later).
        var now = Date.now();
        if (!pointerTimestampIsTouchStart || now > pointerTimestamp + DomUtils.PRESS_HOLD_THRESHOLD) {
          pointerTimestamp = now;
          pointerTimestampIsTouchStart = false;
        }
      },
      true
    );

    document.addEventListener(
      'touchstart',
      function () {
        pointerTimestamp = Date.now();
        pointerTimestampIsTouchStart = true;
      },
      { passive: true, capture: true }
    );

    document.addEventListener(
      'mouseup',
      function () {
        pointerTimestamp = Date.now();
        pointerTimestampIsTouchStart = false;
      },
      true
    );

    document.addEventListener(
      'touchend',
      function () {
        pointerTimestamp = Date.now();
        pointerTimestampIsTouchStart = false;
      },
      true
    );

    // --- The function assigned to DomUtils.recentPointer ---

    return function () {
      var millisSincePointer = Date.now() - pointerTimestamp;
      var threshold = pointerTimestampIsTouchStart ? TOUCHSTART_THRESHOLD : POINTER_THRESHOLD;
      return millisSincePointer < threshold;
    };
  })();

  // ------------------------------------------------------------------------------------------------
  // Utility for suppressing focus ring for mouse/touch interaction, but not KB or other interaction:
  // ------------------------------------------------------------------------------------------------

  /**
   * This API works like baseComponent's _focusable() API (see its detailed JSDoc), with the
   * similarities and differences listed below.  This API is intended for non-component callers;
   * components should typically call the baseComponent API via this._focusable().
   *
   * Comparison to baseComponent._focusable() :
   *
   * - This function's "options" param must be an object.  Only baseComponent._focusable()
   *   supports the backward-compatibility syntax where the options param can be the element.
   * - Same usage of oj-focus, oj-focus-highlight, and $focusHighlightPolicy.
   * - Same required invariant that oj-focus-highlight must not be set if oj-focus is not set.
   * - Same parameters with same semantics, plus the additional "component" and "remove" params
   *   discussed below.
   * - New options.component param, which takes a JET component instance.  (When a component is
   *   involved, typically that component should call this._focusable() rather than calling this
   *   version of the method directly.)
   *
   * If options.component is specified, then the following things work like the baseComponent
   * version of this API:
   *
   * - If the specified element is in the component subtree,
   *   then the classes will automatically be removed when the component is
   *   destroyed/disabled/detached, as detailed in the baseComponent JSDoc,
   *   else the caller has the same responsibility to remove the classes at those times.
   * - Same rules as to whether listeners are automatically cleaned up, or suppressed when the
   *   component is disabled, vs. being the caller's responsibility to handle those things.
   *
   * If options.component is NOT specified (for non-component callers), then those things are
   * the caller's responsibility.  Specifically:
   *
   * - Class removal can be done directly, as needed.
   * - To remove the listeners, see the following.
   *
   * Listener removal:
   *
   * - If options.component was specified, see above.
   * - Else if options.setupHandlers was specified, then only the caller knows what listeners were
   *   registered and how, so it is the caller's responsibility to remove them directly when needed.
   * - The remaining case is that options.component and options.setupHandlers were not specified.
   *   To remove from element e both the 2 classes and all listeners applied to e by all previous
   *   invocations of makeFocusable() where these options were not specified,
   *   call makeFocusable( {'element': e, 'remove': true} ).
   */
  // If this is named focusable(), Closure Compiler generates a warning, and fails to rename the function in minified code,
  // which suggests that focusable (not just _focusable) is apparently externed somewhere (although not in
  // 3rdparty\jquery\externs\jquery-1.8.js, main\javascript\externs.js, or build\tools\closure\compiler.jar\externs.zip\),
  // perhaps for JQUI's :focusable selector.  So name it makeFocusable().
  DomUtils.makeFocusable = (function () {
    var nextId = 0; // used for unique namespace, for "remove" functionality

    // This private var is shared by all callers that use makeFocusable() and don't supply their own focus highlight policy.
    // If the oj-focus-config SASS object ever acquires a 2nd field, should continue to call pJFFF() only once, statically.
    var FOCUS_HIGHLIGHT_POLICY = (ThemeUtils.parseJSONFromFontFamily('oj-focus-config') || {})
      .focusHighlightPolicy;

    /**
     * @param {function()} focusPolicyCallback Optional getter passed to makeFocusable() by callers wishing to get use a caller-
     *   specific focus policy mechanism instead of the built-in mechanism.
     * @param {function()} recentPointerCallback Optional function passed to makeFocusable() by callers wishing to use a caller-
     *   specific mechanism in addition to the built-in mechanism.
     * @return {boolean} boolean indicating whether it is appropriate to apply the <code class="prettyprint">oj-focus-highlight</code>
     *   CSS class for a focus happening at the time of this method call.
     */
    var shouldApplyFocusHighlight = function (focusPolicyCallback, recentPointerCallback) {
      var focusHighlightPolicy = focusPolicyCallback ? focusPolicyCallback() : FOCUS_HIGHLIGHT_POLICY;
      switch (focusHighlightPolicy) {
        case 'all':
          return true;
        case 'none':
          return false;
        default: // "nonPointer" or no value provided (e.g. SASS var missing)
          return !(DomUtils.recentPointer() || (recentPointerCallback && recentPointerCallback()));
      }
    };

    // the function assigned to DomUtils.makeFocusable
    var makeFocusable = function (options) {
      var element = options.element;

      var dataKey = 'ojFocusable';
      var namespacePrefix = '.' + dataKey;
      var namespaceSeparator = ' ' + namespacePrefix;

      if (options.remove) {
        element.removeClass('oj-focus oj-focus-highlight');

        // id's of listeners needing removal
        var ids = element.data(dataKey);
        if (ids == null) {
          return;
        }

        // map ids to namespaces.  "2" -> ".ojFocusable2".  "2,7" -> ".ojFocusable2 .ojFocusable7"
        var namespaces = namespacePrefix + ('' + ids).split(',').join(namespaceSeparator);
        element
          .off(namespaces) // remove the listeners
          .removeData(dataKey); // clear list of listener id's needing removal
        return;
      }

      var afterToggle = options.afterToggle || $.noop;

      function applyOnlyFocus(_element) {
        _element.addClass('oj-focus');
        afterToggle('focusin');
      }

      function applyBothClasses(_element) {
        _element.addClass('oj-focus');
        if (shouldApplyFocusHighlight(options.getFocusHighlightPolicy, options.recentPointer)) {
          _element.addClass('oj-focus-highlight');
        }
        afterToggle('focusin');
      }

      var addClasses = options.applyHighlight ? applyBothClasses : applyOnlyFocus;

      function removeClasses(_element) {
        _element.removeClass('oj-focus oj-focus-highlight');
        afterToggle('focusout');
      }

      var hasFocus = false;
      var setupHandlers =
        options.setupHandlers ||
        function (focusInHandler, focusOutHandler) {
          var component = options.component;
          var focusInListener = function (event) {
            focusInHandler($(event.currentTarget));
            hasFocus = true;
          };
          var focusOutListener = function (event) {
            // We should only do this once, even though this event may fire multiple times.
            if (hasFocus) {
              focusOutHandler($(event.currentTarget));
              hasFocus = false;
            }
          };

          if (component) {
            component._on(element, {
              focusin: focusInListener,
              focusout: focusOutListener
            });
          } else {
            // neither options.component nor options.setupHandlers were passed, so we must provide a
            // way for the caller to remove the listeners.  That's done via the "remove" param, which
            // uses the namespaces that we stash via data().
            var id = nextId;
            nextId += 1;

            // list of id's of existing listeners needing removal
            var _ids = element.data(dataKey);

            // append id to that list, or start new list if first one
            element.data(dataKey, _ids == null ? id : _ids + ',' + id);

            // add listeners namespaced by that id
            var handlers = {};
            var namespace = namespacePrefix + id;
            handlers['focusin' + namespace] = focusInListener;
            handlers['focusout' + namespace] = focusOutListener;
            element.on(handlers);
          }
        };

      setupHandlers(addClasses, removeClasses);
    };

    return makeFocusable;
  })();

  // ------------------------------------------------------------------------------------------------
  // Utility for supporting makeFocusable by providing setupHandlers in and out handlers
  // ------------------------------------------------------------------------------------------------
  DomUtils.getNoJQFocusHandlers = function (focusIn, focusOut) {
    var noJQFocusInHandler = function (element) {
      return focusIn($(element));
    };

    var noJQFocusOutHandler = function (element) {
      return focusOut($(element));
    };

    return { focusIn: noJQFocusInHandler, focusOut: noJQFocusOutHandler };
  };

  const isHTMLContent = DomUtils.isHTMLContent;
  const cleanHtml = DomUtils.cleanHtml;
  const isAncestor = DomUtils.isAncestor;
  const isAncestorOrSelf = DomUtils.isAncestorOrSelf;
  const addResizeListener = DomUtils.addResizeListener;
  const removeResizeListener = DomUtils.removeResizeListener;
  const fixResizeListeners = DomUtils.fixResizeListeners;
  const isMetaKeyPressed = DomUtils.isMetaKeyPressed;
  const dispatchEvent = DomUtils.dispatchEvent;
  const isValidIdentifier = DomUtils.isValidIdentifier;
  const isTouchSupported = DomUtils.isTouchSupported;
  const setInKoCleanExternal = DomUtils.setInKoCleanExternal;
  const unwrap = DomUtils.unwrap;
  const isChromeEvent = DomUtils.isChromeEvent;
  const getScrollBarWidth = DomUtils.getScrollBarWidth;
  const getReadingDirection = DomUtils.getReadingDirection;
  const setScrollLeft = DomUtils.setScrollLeft;
  const calculateScrollLeft = DomUtils.calculateScrollLeft;
  const getCSSLengthAsInt = DomUtils.getCSSLengthAsInt;
  const getCSSLengthAsFloat = DomUtils.getCSSLengthAsFloat;
  const getCSSTimeUnitAsMillis = DomUtils.getCSSTimeUnitAsMillis;
  const getLogicalParent = DomUtils.getLogicalParent;
  const setLogicalParent = DomUtils.setLogicalParent;
  const isLogicalAncestorOrSelf = DomUtils.isLogicalAncestorOrSelf;
  const validateURL = DomUtils.validateURL;
  const PRESS_HOLD_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD;
  const recentTouchEnd = DomUtils.recentTouchEnd;
  const recentTouchStart = DomUtils.recentTouchStart;
  const recentPointer = DomUtils.recentPointer;
  const getNoJQFocusHandlers = DomUtils.getNoJQFocusHandlers;
  const makeFocusable = DomUtils.makeFocusable;

  exports.PRESS_HOLD_THRESHOLD = PRESS_HOLD_THRESHOLD;
  exports.addResizeListener = addResizeListener;
  exports.calculateScrollLeft = calculateScrollLeft;
  exports.cleanHtml = cleanHtml;
  exports.dispatchEvent = dispatchEvent;
  exports.fixResizeListeners = fixResizeListeners;
  exports.getCSSLengthAsFloat = getCSSLengthAsFloat;
  exports.getCSSLengthAsInt = getCSSLengthAsInt;
  exports.getCSSTimeUnitAsMillis = getCSSTimeUnitAsMillis;
  exports.getLogicalParent = getLogicalParent;
  exports.getNoJQFocusHandlers = getNoJQFocusHandlers;
  exports.getReadingDirection = getReadingDirection;
  exports.getScrollBarWidth = getScrollBarWidth;
  exports.isAncestor = isAncestor;
  exports.isAncestorOrSelf = isAncestorOrSelf;
  exports.isChromeEvent = isChromeEvent;
  exports.isHTMLContent = isHTMLContent;
  exports.isLogicalAncestorOrSelf = isLogicalAncestorOrSelf;
  exports.isMetaKeyPressed = isMetaKeyPressed;
  exports.isTouchSupported = isTouchSupported;
  exports.isValidIdentifier = isValidIdentifier;
  exports.makeFocusable = makeFocusable;
  exports.recentPointer = recentPointer;
  exports.recentTouchEnd = recentTouchEnd;
  exports.recentTouchStart = recentTouchStart;
  exports.removeResizeListener = removeResizeListener;
  exports.setInKoCleanExternal = setInKoCleanExternal;
  exports.setLogicalParent = setLogicalParent;
  exports.setScrollLeft = setScrollLeft;
  exports.unwrap = unwrap;
  exports.validateURL = validateURL;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojfocusutils',['jquery', 'ojs/ojcore-base', 'ojs/ojdomutils'], function ($, oj, DomUtils) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * Focus utilities.
   * @ignore
   */
  const FocusUtils = { _TABBABLE: ':tabbable,iframe' };

  // These functions inspired by AdfFocusUtils

  /**
   * Tests whether the specified element contains the keyboard focus.
   * @param {!Element} element Element for which to check if it contains focus.
   * @returns {boolean} True if the element contains focus, false otherwise.
   */
  FocusUtils.containsFocus = function (element) {
    var activeElem = document.activeElement;
    // FIX : if either elem is undefined, just return false
    if (!element || !activeElem) {
      return false;
    }

    return DomUtils.isAncestorOrSelf(element, activeElem);
  };

  /**
   * Sets focus to the specified element.
   * @param {!Element} element Element to focus.
   */
  FocusUtils.focusElement = function (element) {
    element.focus();
  };

  /**
   * Sets focus to the first tabbable element inside the given element, which
   * may be the given element itself.
   * @param {!Element} element Element to start searching for a tabbable element in.
   * @returns {Element} The DOM element that was focused, if any.
   */
  FocusUtils.focusFirstTabStop = function (element) {
    var focusElement = FocusUtils.getFirstTabStop(element);

    if (focusElement) {
      FocusUtils.focusElement(focusElement);
    }

    return focusElement;
  };

  /**
   * Return true if the activeElement is the first tabbable. Used to ensure that tabbing cycles through dialogs/popups.
   * @param {!Element} element Element containing tabbable elements.
   * @returns {boolean} <code>true</code> if the active element is the first tabbable.
   */
  FocusUtils.isFirstActiveElement = function (element) {
    var jqElem = $(element);
    var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

    if (jqFocusables == null || jqFocusables.length === 0) return false;
    var first = jqFocusables[0];

    if (document.activeElement === first) return true;

    //
    // Return true if the activeElement is in the "first tabble set".
    // Check to see if the first tabbable and the active element are members
    // of the same radio set.
    // If this is the case, then return true.
    //
    if (
      first.name === document.activeElement.name &&
      first.type === 'radio' &&
      document.activeElement.type === 'radio'
    ) {
      return true;
    }
    return false;
  };

  /**
   * Return true if the activeElement is the last tabbable. Used to ensure that tabbing cycles through dialogs/popups.
   * @param {!Element} element Element containing tabbable elements.
   * @returns {boolean} <code>true</code> if the active element is the last tabbable.
   */
  FocusUtils.isLastActiveElement = function (element) {
    var jqElem = $(element);
    var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

    if (jqFocusables == null || jqFocusables.length === 0) return false;
    var last = jqFocusables[jqFocusables.length - 1];

    if (document.activeElement === last) return true;

    //
    // Return true if the activeElement is in the "first tabble set".
    // Check to see if the last tabbable and the active element are members
    // of the same radio set.
    // If this is the case, then return true.
    //
    if (
      last.name === document.activeElement.name &&
      last.type === 'radio' &&
      document.activeElement.type === 'radio'
    ) {
      return true;
    }
    return false;
  };

  /**
   * Get the first tabbable element inside the given element, which may be the
   * given element itself.
   * @param {!Element} element Element to start searching for a tabbable element in.
   * @returns {Element} The first tabbable element inside the given element.
   */
  FocusUtils.getFirstTabStop = function (element) {
    var jqElem = $(element);
    if (jqElem.is(FocusUtils._TABBABLE)) {
      return element;
    }
    var jqFocusables = jqElem.find(FocusUtils._TABBABLE);
    if (jqFocusables && jqFocusables.length > 0) {
      //
      // Handle set-based content (radiosets).
      // Return the first selected radioset item.
      // Note that there are two cases
      //   Common case - a single radioset
      //   Other case - multiple radiosets
      // In both cases we return the first selected radioset item.
      //
      if (jqFocusables[0].classList.contains('oj-radio')) {
        var selectedItem = jqFocusables.filter('.oj-selected.oj-radio');
        if (selectedItem && selectedItem.length) {
          return selectedItem[0];
        }
        return jqFocusables[0];
      }
      return jqFocusables[0];
    }
    return null;
  };

  /**
   * Get the last tabbable element inside the given element, which may be the
   * given element itself.
   * @param {!Element} element Element to start searching for a tabbable element in.
   * @returns {Element} The last tabbable element inside the given element.
   */
  FocusUtils.getLastTabStop = function (element) {
    var jqElem = $(element);
    var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

    if (jqFocusables && jqFocusables.length > 0) {
      //
      // Handle set-based content (radiosets).
      // Return the last selected radioset item.
      //
      if (jqFocusables[jqFocusables.length - 1].classList.contains('oj-radio')) {
        var selectedItem = jqFocusables.filter('.oj-selected.oj-radio');
        if (selectedItem && selectedItem.length) {
          return selectedItem[selectedItem.length - 1];
        }
        return jqFocusables[jqFocusables.length - 1];
      }
      return jqFocusables[jqFocusables.length - 1];
    }
    return null;
  };

  /**
   * Extends the jquery ":focusable" pseudo selector check for a Safari browser specific
   * exception - an anchor element not having a tabindex attribute.
   *
   * @param {Element} element target dom element to test if it will take focus
   * @returns {boolean} <code>true</code> if the target element is focusable
   */
  FocusUtils.isFocusable = function (element) {
    if ($(element).is(':focusable')) {
      // An anchor element in safari will not take focus unless it has a tabindex.
      // http://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#Clicking_and_focus
      if (
        element.nodeName === 'A' &&
        !element.hasAttribute('tabindex') &&
        oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.SAFARI
      ) {
        return false;
      }
      return true;
    }

    return false;
  };

  return FocusUtils;

});


define('ojs/ojgestureutils',['exports', 'jquery', 'ojs/ojdomutils', 'ojs/ojcore-base'], function (exports, $, DomUtils, oj) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /* jslint browser: true*/

  /**
   * Gesture utilities provided internally for JET components, currently only context menu gesture are available.
   * Moved from ojcomponentcore and made into static methods.
   * @ignore
   */
  const GestureUtils = {};

  /**
   * Event namespace used by context menu internal event registration.
   * Previously we got the namespace from the widget.
   */
  GestureUtils._EVENT_NAMESPACE = '.contextMenu';

  /**
   * Utility method to tear down any artifacts created by GestureUtils.startDetectContextMenuGesture
   * @param {Element} rootNode the root element of the component
   */
  GestureUtils.stopDetectContextMenuGesture = function (rootNode) {
    const isIOS = oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS;
    const isAllowBrowserContextMenu = rootNode._allowBrowserContextMenu;

    if (rootNode._touchStartListener) {
      document.removeEventListener('touchstart', rootNode._touchStartListener, { passive: true });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._touchStartListener;
    }
    if (rootNode._touchCancelListener) {
      document.removeEventListener('touchcancel', rootNode._touchCancelListener, { passive: true });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._touchCancelListener;
    }
    if (rootNode._touchEndListener) {
      document.removeEventListener('touchend', rootNode._touchEndListener, { passive: false });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._touchEndListener;
    }
    if (rootNode._browserSelectionChangeListener) {
      document.removeEventListener('selectionchange', rootNode._browserSelectionChangeListener, {
        passive: true
      });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._browserSelectionChangeListener;
    }
    if (rootNode._touchMoveListener) {
      if (isAllowBrowserContextMenu && isIOS) {
        document.removeEventListener('touchmove', rootNode._touchMoveListener, {
          passive: true
        });
      } else {
        rootNode.removeEventListener('touchmove', rootNode._touchMoveListener, { passive: true });
      }
      // eslint-disable-next-line no-param-reassign
      delete rootNode._touchMoveListener;
    }
    if (rootNode._clickListener) {
      $(rootNode)
        .off(GestureUtils._EVENT_NAMESPACE)
        .removeClass('oj-menu-context-menu-launcher')[0]
        .removeEventListener('click', rootNode._clickListener, true);

      // the other 2 contextMenu timeouts don't need to be cleared here
      clearTimeout(rootNode._contextMenuPressHoldTimer);

      // eslint-disable-next-line no-param-reassign
      delete rootNode._clickListener;
      // eslint-disable-next-line no-param-reassign
      delete rootNode._contextMenuPressHoldTimer;
    }
    if (rootNode._touchStartAndMouseDownListener) {
      rootNode.removeEventListener('touchstart', rootNode._touchStartAndMouseDownListener, {
        passive: false
      });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._touchStartAndMouseDownListener;
    }
    if (rootNode._browserSelectStartListener) {
      document.removeEventListener('selectstart', rootNode._browserSelectStartListener, {
        passive: true
      });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._browserSelectStartListener;
      // eslint-disable-next-line no-param-reassign
      delete rootNode._webKitUserSelectValue;
      // eslint-disable-next-line no-param-reassign
      delete rootNode._userSelectValue;
    }
    if (rootNode._dragListener) {
      rootNode.removeEventListener('drag', rootNode._dragListener, { passive: false });
      // eslint-disable-next-line no-param-reassign
      delete rootNode._dragListener;
    }
  };

  /**
   * Utility method to setup context menu gesture detection on a component
   * @param {Element} rootNode the root node of the component
   * @param {function(Event, string)} callback callback to invoke on the component when context menu gesture is detected
   * @param {HTMLElement} contextMenu context menu element
   * @param {Object} contextMenuOptions options components can pass in to change default gestureUtils behavior.
   */
  GestureUtils.startDetectContextMenuGesture = function (
    rootNode,
    callback,
    contextMenu,
    contextMenuOptions
  ) {
    // Note: Whether or not we use Hammer to detect press-hold, this code would need to do the following things seen below:
    //
    // (1) Prevent the compatibility mousedown event from triggering Menu's clickAway logic.
    // (2) Prevent press-hold from also generating a click (unless Hammer does this automatically; I'm guessing it doesn't).
    // (3) Ensure we don't respond to *both* press-hold and contextmenu events on Android.
    //
    // So the only thing that Hammer would replace is:
    //
    // (4) Detecting the press-hold.
    //
    // Not currently using Hammer for (4), since:
    //
    // - This code predates Hammer, and was already stable after extensive iteration / fine-tuning.
    // - We use the same listeners for parts of 1-4. If moved 4 off to Hammer (separate listener), just need to ensure that
    //   we don't introduce any race conditions, etc.  (May be easy or hard, just need to look.)
    // - Hammer only wants to have one instance per DOM node, else they fight to control some things like touch-action. So
    //   a pre-req for having this baseComponent logic put Hammer on components is to work out a protocol for super- and sub-
    //   classes to share the same instance and not step on each other.  Not insurmountable; just need to have the conversation.
    //   Tracked by ER 21357133, which links to detailed wiki.
    var pressHoldThreshold = DomUtils.PRESS_HOLD_THRESHOLD; // launch CM at 750ms per UX spec
    var maxAllowedMovement = 5;
    var touchPageX;
    var touchPageY;
    var _touchMoveListener;
    var _isSelectionPending;
    var _getIsSelectionPending;
    let isMenuOpenedTouching;

    // Does 2 things:
    // 1) Prevents native context menu / callout from appearing in Mobile Safari.  E.g. for links, native CM has "Open in New Tab".
    // 2) In Mobile Safari and Android Chrome, prevents pressHold from selecting the text and showing the selection handles and (in Safari) the Copy/Define callout.
    // In UX discussion, we decided to prevent both of these things for all JET components for now.  If problems, can always, say, add protected method allowing
    // subclass to opt out (e.g. if they need 1 and/or 2 to work).
    // Per discussion with architects, do #2 only for touch devices, so that text selection isn't prevented on desktop.  Since #1
    // is a no-op for non-touch, we can accomplish this by omitting the entire style class, which does 1 and 2, for non-touch.
    // Per comments in scss file, the suppression of 1 and 2 has issues in old versions of Mobile Safari.
    if (DomUtils.isTouchSupported()) {
      $(rootNode).addClass('oj-menu-context-menu-launcher');
    }

    var isPressHold = false; // to prevent pressHold from generating a click
    var contextMenuPressHoldTimer;

    var touchInProgress = false;

    // 5px is Hammer default.  (Didn't check whether they apply that separately to x and y like us, or to the hypotenuse,
    // but it's within a couple px either way -- think 3-4-5 triangle.)

    var doubleOpenTimer; // to prevent double open.  see usage below.
    var doubleOpenThreshold = 300; // made up this number.  TBD: Tweak as needed to make all platforms happy.
    var doubleOpenType = null; // "touchstart" or "contextmenu"

    var namespace = GestureUtils._EVENT_NAMESPACE;

    var contextMenuPressHoldJustEnded = false;
    const launch = function (event, eventType, pressHold) {
      // ensure that pressHold doesn't result in a click.  Set this before the bailouts below.
      isPressHold = pressHold;

      // In Mobile Safari only, mousedown fires *after* the touchend, which causes at least 2 problems:
      // 1) CM launches after 750ms (good), then disappears when lift finger (bad), because touchend -->
      // mousedown, which calls Menu's "clickAway" mousedown listener, which dismisses Menu.
      // 2) The isPressHold logic needs to reset the isPressHold ivar on any event that can start a click,
      // including mousedown.  This problem causes the mousedown listener to incorrectly clear the ivar
      // after a pressHold, which broke the whole mechanism.
      // SOLUTION FOR 1-2:  On each launch (at 750ms), set a one-time touchend listener that will set a
      // var and clear it 50ms later.  While the var is set, both mousedown listeners can disregard the
      // mousedown.  Make the var a static var in Menu, since Menu's listener is static, and since this
      // launcher component can get/set it via an (effectively static) menu method.
      // NON-SOLUTIONS:  Cancelling touchstart or touchend, via pD() and sP(), doesn't cancel iPad's mousedown.
      // Cancelling mousedown from here doesn't work even if capture phase, since ojMenu's listener is capture phase.
      // TIMING: The following block should be before the doubleOpen bailout.
      if (isPressHold) {
        $(rootNode).one('touchend' + namespace, function () {
          var touchendMousedownThreshold = 50; // 50ms.  Make as small as possible to prevent unwanted side effects.
          contextMenuPressHoldJustEnded = true;
          setTimeout(function () {
            contextMenuPressHoldJustEnded = false;
          }, touchendMousedownThreshold);
        });
      }

      // On platforms like Android Chrome where long presses already fire the contextmenu event, the pressHold
      // logic causes the menu to open twice, once for the pressHold, once for the contextmenu.  There's no
      // guarantee which will happen first, but as long as they happen within doubleOpenThreshold ms
      // of each other, this logic should prevent the double open.
      // Note: Another option is a platform-specific solution where we only use pressHold for platforms that need
      // it (that don't already fire a contextmenu event for pressHold), but architectural preference is to avoid
      // platform-specific solutions if possible.
      if (
        (doubleOpenType === 'touchstart' && event.type === 'contextmenu') ||
        (doubleOpenType === 'contextmenu' && event.type === 'touchstart') ||
        (doubleOpenType === 'keydown' && event.type === 'contextmenu')
      ) {
        // FF 60.2.2esr (32-bit) Win fires a rogue contextmenu event following the prevented keydown. What's odd is
        // preventing the keydown for shift+F10 prevents keypress but still files the contextmenu event.
        // Seems like "fallout" (behavior not yet correct) from bug https://bugzilla.mozilla.org/show_bug.cgi?id=1382199
        // For this case, prevent the native context menu within double open timeout window
        if (doubleOpenType === 'keydown' && event.type === 'contextmenu') event.preventDefault();
        doubleOpenType = null;
        clearTimeout(doubleOpenTimer);
        return;
      }

      // If a nested element or component already showed a JET context menu for this event, don't replace it with ours.
      // Hack: must check defaultPrevented on the nested event too, because for touchstart events on iOS7 at least, when
      // the outer component reaches this point, event is a different JQ wrapper event than the one on which the inner
      // component previously called preventDefault, although they both wrap the same native originalEvent.  The new wrapper
      // never had its isDefaultPrevented field set to the returnTrue method, so must check the nested originalEvent.
      // This never seems to happen with right-click and Shift-F10 events.  Has nothing to do with the setTimeout: the events
      // received by the rootNode.on("touchstart"...) code are different (firstWrapper==secondWrapper returns false).
      // TODO: link to JQ bug once filed.
      if (
        (event.isDefaultPrevented && event.isDefaultPrevented()) ||
        (event.originalEvent && event.originalEvent.defaultPrevented) ||
        event.defaultPrevented
      ) {
        return;
      }

      // for downstream modules still dependent on originalEvent that used
      // to be added by JQuery
      if (event.type === 'touchstart' || event.type === 'touchmove') {
        // eslint-disable-next-line no-param-reassign
        event.originalEvent = event;
      }

      if (contextMenuOptions?.allowBrowserContextMenu && _getIsSelectionPending()) {
        return;
      }

      callback(event, eventType);

      // if _NotifyContextMenuGesture() (or subclass override of it) actually opened the CM, and if that launch wasn't
      // cancelled by a beforeOpen listener...
      if ((event.isDefaultPrevented && event.isDefaultPrevented()) || event.defaultPrevented) {
        // see double-open comments above
        if (event.type === 'touchstart' || event.type === 'contextmenu' || event.type === 'keydown') {
          doubleOpenType = event.type;
          doubleOpenTimer = setTimeout(function () {
            doubleOpenType = null;
          }, doubleOpenThreshold);
        }
      }
    };

    $(rootNode).on('keydown' + namespace + ' contextmenu' + namespace, function (event) {
      // right-click.  pressHold for Android but not iOS
      if (
        event.type === 'contextmenu' ||
        ((event.key === 'F10' || event.keyCode === 121) && event.shiftKey)
      ) {
        // Shift-F10
        var eventType;
        if (touchInProgress) {
          eventType = 'touch';
        } else if (event.type === 'keydown') {
          eventType = 'keyboard';
        } else {
          eventType = 'mouse';
        }

        launch(event, eventType, false);
      }

      return true;
    });

    const isIOS = oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS;
    const isAllowBrowserContextMenu = contextMenuOptions?.allowBrowserContextMenu;

    if (isAllowBrowserContextMenu) {
      // eslint-disable-next-line no-param-reassign
      rootNode._allowBrowserContextMenu = true;
      rootNode.classList.add('oj-menu-allow-browser-context-menu');
      _isSelectionPending = false;

      _getIsSelectionPending = function () {
        if (_isSelectionPending) {
          return true;
        }
        const selection = document.getSelection();
        return !(
          selection.type === 'None' ||
          (selection.anchorNode === selection.focusNode &&
            selection.anchorOffset === selection.focusOffset)
        );
      };

      const _browserSelectStartListener = function (event) {
        if (event.target.nodeName === '#text') {
          _isSelectionPending = true;
          // we want to reset isSelectionPending if we don't get a contextmenu event. 10ms seems to be enough time tweak as needed.
          setTimeout(() => {
            _isSelectionPending = false;
          }, 10);
        } else {
          _isSelectionPending = false;
        }
      };
      // eslint-disable-next-line no-param-reassign
      rootNode._browserSelectStartListener = _browserSelectStartListener;
      document.addEventListener('selectstart', _browserSelectStartListener, { passive: true });

      if (isIOS) {
        let _iosOpenedContextMenu;
        let _timeNeededForSelection;
        let _iosStartTime;
        let _touchStartEvent;
        let _iosContextMenuTimeout;

        const _iosLaunch = function (event) {
          event.preventDefault();
          _iosOpenedContextMenu = true;
          // eslint-disable-next-line no-param-reassign
          rootNode._webKitUserSelectValue = document.body.style[`-webkit-user-select`];
          document.body.style[`-webkit-user-select`] = 'none';
          // eslint-disable-next-line no-param-reassign
          rootNode._userSelectValue = document.body.style.userSelect;
          document.body.style.userSelect = 'none';
          document.getSelection().empty();
          callback(event, 'touch');
        };

        const _touchStartListener = function (event) {
          const firstTouch = event.touches[0];
          touchPageX = firstTouch.pageX;
          touchPageY = firstTouch.pageY;
          let timeDelay = pressHoldThreshold * 2;
          if (_timeNeededForSelection == null) {
            _iosStartTime = Date.now();
            _touchStartEvent = event;
          } else {
            timeDelay = _timeNeededForSelection + pressHoldThreshold;
          }
          // prettier-ignore
          _iosContextMenuTimeout = setTimeout( // @HTMLUpdateOK
            _iosLaunch.bind(null, event),
            timeDelay
          );
        };
        // eslint-disable-next-line no-param-reassign
        rootNode._touchStartListener = _touchStartListener;
        document.addEventListener('touchstart', _touchStartListener, { passive: true });

        const _touchEndListener = function (event) {
          clearTimeout(_iosContextMenuTimeout);
          if (_iosOpenedContextMenu) {
            event.preventDefault();
            // 500 comes from testing behavior on real devices, seems like enough time to allow user to lift finger. UX approved.
            setTimeout(() => {
              document.body.style[`-webkit-user-select`] = rootNode._webKitUserSelectValue;
              document.body.style.userSelect = rootNode._userSelectValue;
              _iosOpenedContextMenu = false;
            }, 500);

            // We added this timeout since when there is text selection allowed ios opens a popup and set focus there
            setTimeout(() => {
              if (contextMenu) {
                contextMenu.focus();
              }
            }, 1000);
          }
        };
        // eslint-disable-next-line no-param-reassign
        rootNode._touchEndListener = _touchEndListener;
        document.addEventListener('touchend', _touchEndListener, { passive: false });

        const _touchCancelListener = function () {
          clearTimeout(_iosContextMenuTimeout);
          if (_iosOpenedContextMenu) {
            document.body.style[`-webkit-user-select`] = rootNode._webKitUserSelectValue;
            document.body.style.userSelect = rootNode._userSelectValue;
            _iosOpenedContextMenu = false;
          }
        };
        // eslint-disable-next-line no-param-reassign
        rootNode._touchCancelListener = _touchCancelListener;
        document.addEventListener('touchcancel', _touchCancelListener, { passive: true });

        _touchMoveListener = function (event) {
          const firstTouch = event.touches[0];
          if (
            Math.abs(touchPageX - firstTouch.pageX) > maxAllowedMovement ||
            Math.abs(touchPageY - firstTouch.pageY) > maxAllowedMovement
          ) {
            clearTimeout(_iosContextMenuTimeout);
          }
        };
        // eslint-disable-next-line no-param-reassign
        rootNode._touchMoveListener = _touchMoveListener;
        document.addEventListener('touchmove', _touchMoveListener, { passive: true });

        const _browserSelectionChangeListener = function () {
          if (
            _iosStartTime != null &&
            _timeNeededForSelection == null &&
            document.getSelection().type === 'Range'
          ) {
            clearTimeout(_iosContextMenuTimeout);
            _timeNeededForSelection = Date.now() - _iosStartTime;
            // prettier-ignore
            _iosContextMenuTimeout = setTimeout( // @HTMLUpdateOK
              _iosLaunch.bind(null, _touchStartEvent),
              pressHoldThreshold
            );
          }
        };
        // eslint-disable-next-line no-param-reassign
        rootNode._browserSelectionChangeListener = _browserSelectionChangeListener;
        document.addEventListener('selectionchange', _browserSelectionChangeListener, {
          passive: true
        });
        return;
      }
    } else {
      const _touchEndListener = function () {
        setTimeout(() => {
          if (isMenuOpenedTouching) {
            if (contextMenu) {
              // We check if focus was moved for some reason from menu. Looks like focus is moved when anchor is the last one that has focus after touch end
              if (!contextMenu.contains(document.activeElement)) {
                contextMenu.focus();
              }
            }
            isMenuOpenedTouching = false;
          }
        }, 1000);
      };
      // eslint-disable-next-line no-param-reassign
      rootNode._touchEndListener = _touchEndListener;
      document.addEventListener('touchend', _touchEndListener, { passive: false });
    }
    // At least some of the time, the pressHold gesture also fires a click event same as a short tap.  Prevent that here.
    var _clickListener = function (event) {
      if (isPressHold) {
        // For Mobile Safari capture phase at least, returning false doesn't work; must use pD() and sP() explicitly.
        event.preventDefault();
        event.stopPropagation();
        isPressHold = false;
      }
    };

    // eslint-disable-next-line no-param-reassign
    rootNode._clickListener = _clickListener;

    // Use capture phase to make sure we cancel it before any regular bubble listeners hear it.
    rootNode.addEventListener('click', _clickListener, true);

    var _touchStartAndMouseDownListener = function (event) {
      // for mousedown-after-touchend Mobile Safari issue explained above where __contextMenuPressHoldJustEnded is set.
      if (event.type === 'mousedown' && contextMenuPressHoldJustEnded) {
        return undefined;
      }

      // reset isPressHold flag for all events that can start a click.
      isPressHold = false;

      // start a pressHold timer on touchstart.  If not cancelled before 750ms by touchend/etc., will launch the CM.
      // isolate the context menu long tap to a single touch point.
      if (event.type === 'touchstart' && event.touches.length === 1) {
        // note starting position so touchmove handler can tell if touch moved too much
        var firstTouch = event.touches[0];
        touchPageX = firstTouch.pageX;
        touchPageY = firstTouch.pageY;

        touchInProgress = true;
        // prettier-ignore
        contextMenuPressHoldTimer = setTimeout( // @HTMLUpdateOK
          () => {
            launch.bind(undefined, event, 'touch', true)();
            isMenuOpenedTouching = true;
          },
          pressHoldThreshold
        );
        // eslint-disable-next-line no-param-reassign
        rootNode._contextMenuPressHoldTimer = contextMenuPressHoldTimer;
      }

      return true;
    };

    // eslint-disable-next-line no-param-reassign
    rootNode._touchStartAndMouseDownListener = _touchStartAndMouseDownListener;
    rootNode.addEventListener('touchstart', _touchStartAndMouseDownListener, { passive: false });

    _touchMoveListener = function (event) {
      var firstTouch = event.touches[0];
      if (
        Math.abs(touchPageX - firstTouch.pageX) > maxAllowedMovement ||
        Math.abs(touchPageY - firstTouch.pageY) > maxAllowedMovement
      ) {
        touchInProgress = false;
        clearTimeout(contextMenuPressHoldTimer);
      }
      return true;
    };

    // eslint-disable-next-line no-param-reassign
    rootNode._touchMoveListener = _touchMoveListener;
    rootNode.addEventListener('touchmove', _touchMoveListener, { passive: true });

    const _dragListener = function (event) {
      // Each time we are dragging, we need to check if the finger has moved. This is because
      // on phones drag is triggered just holding your finger
      if (
        Math.abs(touchPageX - event.pageX) > maxAllowedMovement ||
        Math.abs(touchPageY - event.pageY) > maxAllowedMovement
      ) {
        touchInProgress = false;
        clearTimeout(contextMenuPressHoldTimer);
      }
      return true;
    };

    // eslint-disable-next-line no-param-reassign
    rootNode._dragListener = _dragListener;
    rootNode.addEventListener('drag', _dragListener, { passive: true });

    // if the touch moves too much, it's not a pressHold
    // if the touch ends before the 750ms is up, it's not a long enough pressHold to show the CM
    $(rootNode)
      .on('touchend' + namespace + ' touchcancel' + namespace, function () {
        touchInProgress = false;
        clearTimeout(contextMenuPressHoldTimer);
        return true;
      })
      .on('mousedown' + namespace, _touchStartAndMouseDownListener);
  };

  const startDetectContextMenuGesture = GestureUtils.startDetectContextMenuGesture;
  const stopDetectContextMenuGesture = GestureUtils.stopDetectContextMenuGesture;

  exports.startDetectContextMenuGesture = startDetectContextMenuGesture;
  exports.stopDetectContextMenuGesture = stopDetectContextMenuGesture;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcomponentcore',['exports', 'jqueryui-amd/widget', 'jqueryui-amd/unique-id', 'jqueryui-amd/keycode', 'jqueryui-amd/focusable', 'jqueryui-amd/tabbable', 'ojs/ojcore', 'jquery', 'ojs/ojmessaging', 'ojs/ojlogger', 'ojs/ojmetadatautils', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojcustomelement', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry', 'ojs/ojdefaultsutils', 'ojs/ojtranslation', 'ojs/ojfocusutils', 'ojs/ojgestureutils'], function (exports, widget, uniqueId, keycode, focusable, tabbable, oj, $, Message, Logger, MetadataUtils, oj$1, DomUtils, ojcustomelement, ojcustomelementUtils, ojcustomelementRegistry, ojdefaultsutils, Translations, ojfocusutils, GestureUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Message = Message && Object.prototype.hasOwnProperty.call(Message, 'default') ? Message['default'] : Message;
  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;

  /**
   * This picks a strategy for where to put each piece of information
   * that is on a component. It started out being messaging pieces: like
   * placeholder, converter hints, validator hints, error messages. In v8.0
   * we added labelEdge which could be top or inside the text field or inside
   * a non-text-field (like a radioset).
   * @param {Object} component instance
   * @protected
   * @constructor
   * @since 0.6.0
   * @ignore
   */
  const ComponentMessaging = function (component) {
    this.Init(component);
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(ComponentMessaging, oj.Object, 'oj.ComponentMessaging');
  oj._registerLegacyNamespaceProp('ComponentMessaging', ComponentMessaging);

  /**
   * Default strategy types supported for component messaging.
   * Think of these as places in the dom you want things.
   * Labels are the only things you put into the 'label-edge' positions,
   * so you will have only one of these at a time.
   * @memberof! oj.ComponentMessaging
   * @const
   * @protected
   * @ignore
   */
  ComponentMessaging._STRATEGY_TYPE = {
    NONE: 'none',
    NOTEWINDOW: 'notewindow',
    PLACEHOLDER: 'placeholder',
    INLINE: 'inline',
    LABEL_EDGE_INSIDE: 'inside',
    LABEL_EDGE_INSIDE_FORM_CNTRL: 'insideformcontrol',
    USER_ASSISTANCE_INLINE: 'userassistanceinline'
  };

  /**
   * Tracks the messaging strategy callback function by type, used to instantiate messaging strategies.
   * Implementations register by type.
   * @memberof! oj.ComponentMessaging
   * @const
   * @protected
   * @ignore
   */
  ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK = {};

  /**
   * @private
   */
  const _DESCBY = 'aria-describedby';

  /**
   * Stores the constructor function callback object used to constuct a strategy object for the
   * specified type.
   *
   * @param {string} type
   * @param {Function} strategyConstructorCallback a constructor callback that can be used to constuct
   * a strategy object for the specified type
   * @ignore
   */
  ComponentMessaging.registerMessagingStrategy = function (type, strategyConstructorCallback) {
    if (type && typeof strategyConstructorCallback === 'function') {
      ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[type] = strategyConstructorCallback;
    }
  };

  /**
   * Initializes the strategy based on the display options that specify the messaging artifacts that
   * will be displayed by this strategy.
   *
   * @param {Object} component widget instance
   * @memberof! oj.ComponentMessaging
   * @instance
   * @protected
   */
  ComponentMessaging.prototype.Init = function (component) {
    ComponentMessaging.superclass.Init.call(this);

    this._component = component;
    this._activated = false;

    // sets up this._strategies, which is a list of what we will display in each type of
    // displayOption. E.g., 'inline': 'messages', 'notewindow': converterHint, validatorHint, etc.
    // See EditableValues displayOption attribute jsdoc for more details.
    this._initializeMessagingStrategies();
  };

  /**
   * Utility function that activates messaging on the component using the strategy provided.
   * @param {Object} launcher element(s) to which messaging applies
   * @param {Object} contentElement  The wrapper element for all component messages
   * @param {Object} content an object containing the messages and the converter hint
   * @param {Array<string>} severitiesAllowedWhenReadonly an array of message severities that are allowed when readonly
   * @private
   */
  ComponentMessaging.prototype.activate = function (
    launcher,
    contentElement,
    content,
    severitiesAllowedWhenReadonly
  ) {
    var that = this;
    oj.Assert.assertObject(content);
    this._launcher = launcher;
    this._contentElement = contentElement;
    this._severitiesAllowedWhenReadonly = severitiesAllowedWhenReadonly;

    this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);

    // if already active, reinitialize strategies based on new messagingDisplay
    // and labelEdge preferences.
    if (!this._isActive()) {
      // for each 'messaging strategy' (e.g., inline == InlineMessagingStrategy,
      // notewindow == PopupMessagingStrategy, etc), call .activate which initializes
      // the strategy.
      $.each(this._strategies, function (i, strategy) {
        strategy.activate(that);
      });
      this._activated = true;
    } else {
      this._reactivate();
    }
  };

  /**
   * Utility function that updates messaging on the component for the content provided, using the
   * strategies.
   *
   * @param {Object} content
   * @private
   */
  // TODO: component messaging could take the component instance
  ComponentMessaging.prototype.update = function (content) {
    oj.Assert.assertObject(content);
    oj.Assert.assertBoolean(this._activated);

    this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);

    if (this._activated) {
      $.each(this._strategies, function (i, strategy) {
        if (strategy.shouldUpdate(content)) {
          strategy.update();
        }
      });
    }
  };

  /**
   * Utility function that deactivates messaging on the component using the strategy provided.
   * @private
   */
  ComponentMessaging.prototype.deactivate = function () {
    $.each(this._strategies, function (i, strategy) {
      strategy.deactivate();
    });

    this._activated = false;
    this._component = null;
    this._launcher = null;
    this._contentElement = null;
    this._strategies = {};
  };

  /**
   * Utility function that closes anything that needs to be closed when oj.Components.subtreeHidden
   * is called. e.g, popup.
   * @private
   */
  ComponentMessaging.prototype.close = function () {
    if (this._activated) {
      $.each(this._strategies, function (i, strategy) {
        strategy.close();
      });
    }
  };

  /**
   * Releases resources that would otherwise leak memory if they were not released
   * when the component's dom is removed.
   * For example, Hammer events are put on the document and will result in
   * detached dom memory leak if not removed.
   * @private
   */
  ComponentMessaging.prototype.releaseResources = function () {
    if (this._activated) {
      $.each(this._strategies, function (i, strategy) {
        strategy.releaseResources();
      });
    }
  };

  /**
   * Symmetrical method to releaseResources. Sets up resources that get
   * removed in releaseResources.
   * @private
   */
  ComponentMessaging.prototype.setupResources = function () {
    if (this._activated) {
      $.each(this._strategies, function (i, strategy) {
        strategy.setupResources();
      });
    }
  };

  /**
   * Creates a messaging strategy for the specified type, initializing it with the options provided.
   * @param {string|number} type defined by oj.ComponentMessaging._STRATEGY_TYPE. For example,
   * a strategyType of 'notewindow' creates a PopupComponentMessaging strategy. See
   * registerMessagingStrategy where we register the type and the callback to call for a given type.
   * We currently have PopupMessagingStrategy, DefaultMessagingStrategy, PlaceholderMessagingStrategy,
   * and InlineComponentStrategy.
   * e.g., In PopupComponentMessaging.js:
   *  oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW,
   *                              oj.PopupMessagingStrategy
   * @param {Array.<string>|undefined} artifactsForType (e.g., 'messages', 'helpInstruction', 'validatorHints')
   *
   * @private
   * @instance
   * @memberof !oj.ComponentMessaging
   */
  ComponentMessaging.prototype._createMessagingStrategy = function (type, artifactsForType) {
    var Callback =
      ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[type] ||
      ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[ComponentMessaging._STRATEGY_TYPE.NONE];

    // dynamically instantiate the strategy objects.
    return new Callback(artifactsForType);
  };

  /**
   * Returns the component instance or null
   *
   * @return {Object|null}
   * @private
   * @instance
   * @memberof !oj.ComponentMessaging
   */
  ComponentMessaging.prototype._getComponent = function () {
    return this._component || null;
  };

  /**
   * Returns the launcher jquery element. This is the element on the component to which messaging
   * applies.
   *
   * @return {Object|null} null if messaging is not activated.
   * @private
   * @instance
   * @memberof !oj.ComponentMessaging
   */
  ComponentMessaging.prototype._getLauncher = function () {
    return this._launcher || null;
  };

  /**
   * Returns the jquery element on the component to which aria-invalid
   * applies. This is either the launcher itself or the inputs
   * within the launcher dom.  JAWS only reads aria-invalid when it is on the input/textara/select.
   * <p>
   * In the case of radioset/checkboxset, for example, where the launcher
   * is the root dom element and the inputs are with it, we return the inputs.
   *
   * </p>
   *
   * @return {Object|null} null if launcher is null
   * @private
   * @instance
   * @memberof !oj.ComponentMessaging
   */
  ComponentMessaging.prototype._getContentElement = function () {
    return this._contentElement || null;
  };

  /**
   * Returns the last saved messagingContent object.
   *
   * @return {Object}
   * @private
   * @instance
   * @memberof !oj.ComponentMessaging
   */
  ComponentMessaging.prototype._getMessagingContent = function () {
    return this._messagingContent || {};
  };

  /**
   * Useful for on-demand messaging content, like validation hints.
   *
   * @param {Object} content
   * @private
   * @memberof !oj.ComponentMessaging
   */
  ComponentMessaging.prototype._setMessagingContent = function (content) {
    oj.Assert.assertObject(content);
    this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);
  };

  /**
   * Whether the component messaging is activated.
   * @return {boolean}
   * @private
   */
  ComponentMessaging.prototype._isActive = function () {
    return this._activated;
  };

  /**
   * Returns a key/value array: strategyTypes -> array of artifacts using that strategyType.
   * where artifacts is 'messages', 'converterHint', 'validatorHint', 'helpInstruction';
   * e.g.,
   * strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW] = ['messages', 'converterHints']
   * strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NONE] = ['validatorHints']
   * The types of messaging content for which displayOptions can be configured include
   * messages, converterHint, validatorHint and helpInstruction.
   * The displayOptions for each type is specified either as an array of strings or a string.
   * When an array is specified the first display option takes precedence over the second and so on,
   * so we will only have ONE display type per artifact.
   */
  ComponentMessaging.prototype._getResolvedMessagingDisplayOptions = function (messagingPreferences) {
    var strategyToArtifacts = {};
    var artifactStrategyTypeResolved = false;
    var options = this._component.options;
    var $messagingPreferences = {};
    var self = this;

    // first resolve primary display options for each artifact.
    // E.g. at the end of this loop you should have something like this
    // {messages: 'notewindow', converterHint: 'placeholder', validatorHint: 'notewindow', helpInstruction: 'none'}
    var keys = Object.keys(messagingPreferences);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var strategyTypes = messagingPreferences[key];
      // loop over array of strategyTypes preferred for artifact.
      // artifacts are 'messages', 'converterHint', 'validatorHint', 'helpInstruction'
      artifactStrategyTypeResolved = false;
      var artifact = key + '';
      // we take either array or string values for displayOptions.
      if (Array.isArray(strategyTypes)) {
        for (var j = 0; j < strategyTypes.length; j++) {
          var strategyType = strategyTypes[j];
          if (!artifactStrategyTypeResolved) {
            artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(
              artifact,
              strategyType,
              options,
              $messagingPreferences
            );
          }
        }
      } else if (typeof strategyTypes === 'string') {
        if (!artifactStrategyTypeResolved) {
          artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(
            artifact,
            strategyTypes,
            options,
            $messagingPreferences
          );
        }
      }

      // if we couldn't resolve then use "none". E.g., validationHint: ['none']
      if (!artifactStrategyTypeResolved) {
        $messagingPreferences[artifact] = ComponentMessaging._STRATEGY_TYPE.NONE;
      }
    }

    // update the label creation strategy
    // at this point, $messagingPreferences may have an Object like:
    // {converterHint:'notewindow',
    // helpInstruction:'notewindow', messages:'inline', validatorHint:'notewindow}
    // After the call to _addLabelStrategy, it might be added
    // labelEdge:'top'
    self._addLabelStrategy($messagingPreferences);

    // collate by strategyType -> artifact. but first reset
    $.each(ComponentMessaging._STRATEGY_TYPE, function (type, name) {
      strategyToArtifacts[name] = [];
    });

    $.each($messagingPreferences, function (_artifact, _strategyType) {
      // an artifact eventually resolves to one strategyType.
      strategyToArtifacts[_strategyType].push(_artifact);
    });
    // The keys to the object is the DisplayType, like inline, inside,
    // insideFormControl, none, notewindow, placeholder.
    // The artifacts are things like converterHint, label.
    return strategyToArtifacts;
  };

  /**
   * This function is used when the component's user assistance option should be used.
   * The component.display-options is used only to see if 'none' is specified.
   * display-options is ignored otherwise for the Redwood theme (via a theming variable).
   *
   * This function returns a key/value array: strategyTypes -> array of artifacts
   * using that strategyType. where artifacts is
   * 'messages', 'converterHint', 'validatorHint', 'helpInstruction';
   * e.g., {userAssistanceInline: ['messages', 'helpInstruction'],
   *        none: ['validationHint']
   * Note: the only strategies for inline are userAssistanceInline and none (and the label strategies)
   * The types of messaging content that can be configured include
   * messages, converterHint, validatorHint and helpInstruction.
   */
  ComponentMessaging.prototype._getUserAssistanceStrategyToArtifactsObj = function () {
    var strategyToArtifacts = {};
    var options = this._component.options;
    var componentDisplayOptions = options.displayOptions || {};
    var artifactPiecesToStrategyObj = {};
    var self = this;

    // componentDisplayOptions will be an Object like this:
    // {messages:['inline'], converterHint:['placeholder','notewindow'],
    // validatorHint:['notewindow], helpInstruction:['notewindow']
    // If we are looking at the user-assistance-density attribute on the component,
    // then all we care about from the displayOptions attribute is whether or not there
    // is a 'none' for any of these 'artifacts'. Like, is validatorHint:'none'? If so, do not
    // render the validatorHint. Otherwise render it how the user-assistance-density says to.
    //
    // first resolve primary display options for each artifact.
    // E.g. at the end of this loop you should have something like this
    // {messages: 'userassistanceinline', validatorHint:
    // 'userassistanceinline', helpInstruction: 'none'}
    var keys = Object.keys(componentDisplayOptions);
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let strategyTypes = componentDisplayOptions[key];
      // loop over array of strategyTypes preferred for artifact.
      // artifacts are 'messages', 'converterHint', 'validatorHint', 'helpInstruction'
      let artifact = key + '';
      // we only look at 'string' for 'none'.
      if (typeof strategyTypes === 'string' && strategyTypes === 'none') {
        artifactPiecesToStrategyObj[artifact] = ComponentMessaging._STRATEGY_TYPE.NONE;
      } else {
        // put it in the user assistance inline
        artifactPiecesToStrategyObj[artifact] =
          ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE;
      }
    }

    // update the label creation strategy
    // at this point, artifactPiecesToStrategyObj may have an Object like:
    // {converterHint:'none',
    // helpInstruction:'userassistanceinline', messages:'userassistanceinline', validatorHint:'none'}
    // After the call to _addLabelStrategy, it might be added
    // labelEdge:'top'
    self._addLabelStrategy(artifactPiecesToStrategyObj);

    // collate by strategyType -> artifact. but first reset
    Object.keys(ComponentMessaging._STRATEGY_TYPE).forEach(function (key) {
      let value = ComponentMessaging._STRATEGY_TYPE[key];
      strategyToArtifacts[value] = [];
    });

    Object.keys(artifactPiecesToStrategyObj).forEach(function (key) {
      let _strategyType = artifactPiecesToStrategyObj[key];
      strategyToArtifacts[_strategyType].push(key);
    });

    // This returns an Object with all the StrategyTypes as keys and the
    // 'artifacts' as values, like {none:['validationHint'], 'userAssistanceInline':['messages', 'helpInstruction']
    // inside:['labelEdge']}
    return strategyToArtifacts;
  };

  // Note:
  // Each LabelStrategy is self-registering., e.g., InsideFormControlLabelStrategy registers itself
  // by calling oj.ComponentMessaging.registerMessagingStrategy.
  // this adds the label strategy for the component by the same type.
  ComponentMessaging.prototype._addLabelStrategy = function ($messagingPreferences) {
    var self = this;
    var artifactKey = 'labelEdge';
    // The strategyTypeLabelEdge will be one of these: oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE*
    var strategyTypeLabelEdge = this._component._ResolveLabelEdgeStrategyType();
    var artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(
      artifactKey,
      strategyTypeLabelEdge,
      this._component.options,
      $messagingPreferences
    );

    if (!artifactStrategyTypeResolved) {
      // eslint-disable-next-line no-param-reassign
      $messagingPreferences[artifactKey] = ComponentMessaging._STRATEGY_TYPE.NONE;
    }
  };

  ComponentMessaging.prototype._resolveStrategyTypeForArtifact = function (
    artifact,
    strategyType,
    options,
    $messagingPreferences
  ) {
    var artifactStrategyTypeResolved = false;
    var compPH = options.placeholder;
    switch (strategyType) {
      // placeholder display is special in that it's only supported on 'converterHint'.
      case ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER:
        if (artifact === 'converterHint') {
          // if placeholder is the first preference for converterHint, it's used under certain
          // conditions
          // if options.placeholder is not set then use 'converterHint' as the default
          // 'placeholder'
          // alternately if (options.placeholder), i.e., a custom placeholder is set, then
          // ignore the placeholder strategyType and use the next display type as the default
          // for the artifact. We may have a fallback strategyType in which case we use it,
          // otherwise we use 'none'. E.g.,
          // {'converterHint': ['placeholder', 'notewindow']} // use notewindow
          // {'converterHint': ['placeholder']}               // use none

          if (!artifactStrategyTypeResolved) {
            if (!compPH) {
              // eslint-disable-next-line no-param-reassign
              $messagingPreferences[artifact] = strategyType;
              artifactStrategyTypeResolved = true;
            }
          }
        } else {
          // strategyType 'placeholder' is not supported on other artifacts
          // ignore if present
        }

        break;
      // inline display is special in that it's only supported on 'messages'.
      case ComponentMessaging._STRATEGY_TYPE.INLINE:
        if (artifact === 'messages') {
          if (!artifactStrategyTypeResolved) {
            // eslint-disable-next-line no-param-reassign
            $messagingPreferences[artifact] = strategyType;
            artifactStrategyTypeResolved = true;
          }
        } else {
          // strategyType 'inline' is not supported on other artifacts
          // ignore if present
        }

        break;

      case ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE:
      case ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL:
        if (
          artifact === 'labelEdge' &&
          !artifactStrategyTypeResolved &&
          !oj.StringUtils.isEmptyOrUndefined(options.labelHint)
        ) {
          // eslint-disable-next-line no-param-reassign
          $messagingPreferences[artifact] = strategyType;
          artifactStrategyTypeResolved = true;
        }

        break;

      default:
        if (!artifactStrategyTypeResolved && artifact !== 'labelEdge') {
          // eslint-disable-next-line no-param-reassign
          $messagingPreferences[artifact] = strategyType;
          artifactStrategyTypeResolved = true;
        }
        break;
    }

    return artifactStrategyTypeResolved;
  };

  /**
   * Creates messaging strategies for the component.
   * As of v9.0 form components have a user-assistance-density attribute in addition
   * to the existing display-options. For Redwood UX we look at the user-assistance-density
   * which is efficient or compact and the app will have all its 'user assistance' (i.e., help instruction,
   * hint, messages) inline, or if compact it is in popups.
   * For bw compatibility/Alta we continue to look at display-options
   * like display-options.help-instruction that could be notewindow,
   * and for display-options.messages that could be inline, etc.
   * BOTH will look at display-options for validationHint/messages for 'none'
   * because we still want to be able to turn these off.
   * @private
   */
  ComponentMessaging.prototype._initializeMessagingStrategies = function () {
    var strategyToArtifacts = this._strategyToArtifacts();
    var displayInNoteWindow = strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW];
    var displayNone = strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.NONE];
    var displayInPlaceholder = strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER];
    var displayInline = strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.INLINE];
    // these are input components
    var displayLabelEdgeInsideTextField =
      strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE];
    // these are form controls that aren't inputs, like radioset
    var displayLabelEdgeInsideFormControl =
      strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL];
    // these are for user assistance inline that is used in the Redwood theme
    var displayUserAssistanceInline =
      strategyToArtifacts[ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE];

    var messagingStrategies = {};

    if (displayInNoteWindow.length > 0) {
      // displayInNoteWindow is an array of the artifacts that want to be displayed in the note window
      // e.g., 'messages', 'converterHints', etc.
      messagingStrategies[ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW] =
        this._createMessagingStrategy(
          ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW,
          displayInNoteWindow
        );
    }

    if (displayInPlaceholder.length > 0 && displayLabelEdgeInsideTextField.length === 0) {
      // displayInPlaceholder is an array of the artifacts that want to be displayed in placeholder
      // e.g., 'converterHints'
      messagingStrategies[ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER] =
        this._createMessagingStrategy(
          ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER,
          displayInPlaceholder
        );
    }

    if (displayInline.length > 0) {
      // displayInline is an array of the artifacts that want to be displayed in inline
      // e.g., 'messages'
      messagingStrategies[ComponentMessaging._STRATEGY_TYPE.INLINE] = this._createMessagingStrategy(
        ComponentMessaging._STRATEGY_TYPE.INLINE,
        displayInline
      );
    }

    if (displayUserAssistanceInline.length > 0) {
      messagingStrategies[ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE] =
        this._createMessagingStrategy(
          ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE,
          displayUserAssistanceInline
        );
    }

    // Create one of these strategies for whatever labelEdge we are using currently
    if (displayLabelEdgeInsideTextField.length > 0) {
      messagingStrategies[ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE] =
        this._createMessagingStrategy(
          ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE,
          displayLabelEdgeInsideTextField
        );
    } else if (displayLabelEdgeInsideFormControl.length > 0) {
      messagingStrategies[ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL] =
        this._createMessagingStrategy(
          ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL,
          displayLabelEdgeInsideFormControl
        );
    }

    messagingStrategies[ComponentMessaging._STRATEGY_TYPE.NONE] = this._createMessagingStrategy(
      ComponentMessaging._STRATEGY_TYPE.NONE,
      displayNone
    );

    this._strategies = messagingStrategies;
  };

  /**
   * Reinitializes component messaging.
   *
   * @private
   */
  ComponentMessaging.prototype._reactivate = function () {
    var strategyToArtifacts = this._strategyToArtifacts();

    var strategy;
    var cm = this;

    // for every strategyType being requested either create the messaging strategy for the type or
    // reuse existing strategy if it has already been created.
    $.each(strategyToArtifacts, function (type, artifactsForType) {
      // eslint-disable-next-line no-param-reassign
      type += ''; // coerce to avoid GCC warning
      strategy = cm._strategies[type];
      if (artifactsForType && artifactsForType.length > 0) {
        if (!strategy) {
          // create a strategy if one doesn't exist for the type
          strategy = cm._createMessagingStrategy(type, artifactsForType);
          cm._strategies[type] = strategy;
          strategy.activate(cm);
        } else if (strategy) {
          // update strategy with the latest displayOptions if already present. we don;t
          // want to remove it once activated.
          strategy.reactivate(artifactsForType);
        }
      } else if (strategy && ComponentMessaging._STRATEGY_TYPE.NONE !== type) {
        // if we have no artifacts to show for a type, then remove the strategy.
        // only if its other than the DefaultMessagingStrategy as it's always needed to theme
        // component.
        strategy.deactivate();
        delete cm._strategies[type];
      }
    });
  };

  /**
   * get strategy to artifacts
   * we do different things depending on whether we are using displayOptions
   * or the user-assistance-density attribute.
   *
   * @private
   */
  ComponentMessaging.prototype._strategyToArtifacts = function () {
    let strategyToArtifacts;
    let resolvedUserAssistance = this._component._getResolvedUserAssistance();

    if (resolvedUserAssistance !== 'compact' && resolvedUserAssistance !== 'displayOptions') {
      strategyToArtifacts = this._getUserAssistanceStrategyToArtifactsObj();
    } else {
      let options = this._component.options;
      let messagingPreferences = options.displayOptions ? { ...options.displayOptions } : {};
      if (resolvedUserAssistance === 'compact' && !options.readOnly) {
        // for 'compact' set displayOptions.messages, validator-hint and converter hint to notewindow.
        messagingPreferences.messages =
          messagingPreferences.messages === 'none' ? 'none' : 'notewindow';
        messagingPreferences.validatorHint =
          messagingPreferences.validatorHint === 'none' ? 'none' : 'notewindow';
        messagingPreferences.converterHint =
          messagingPreferences.converterHint === 'none' ? 'none' : 'notewindow';
        strategyToArtifacts = this._getResolvedMessagingDisplayOptions(messagingPreferences);
      } else {
        if (options.readOnly) {
          // JET-74517 For compact, we don't want to show inline messages when readonly
          // This brings legacy inline with core pack behavior for compact readonly.
          if (
            options.readonlyUserAssistanceShown === 'confirmationAndInfoMessages' &&
            resolvedUserAssistance !== 'compact'
          ) {
            messagingPreferences.messages = ComponentMessaging._STRATEGY_TYPE.INLINE;
          } else {
            messagingPreferences.messages = ComponentMessaging._STRATEGY_TYPE.NONE;
          }
          messagingPreferences.validatorHint = ComponentMessaging._STRATEGY_TYPE.NONE;
          messagingPreferences.converterHint = ComponentMessaging._STRATEGY_TYPE.NONE;
        }
        strategyToArtifacts = this._getResolvedMessagingDisplayOptions(messagingPreferences);
      }
    }
    return strategyToArtifacts;
  };

  /**
   * A base messaging strategy class that is initialized with a set of displayOptions. This object
   * also provides helper methods for its subclasses.
   *
   * @param {Array.<string>} displayOptions an array of messaging artifacts displayed.
   *
   * @constructor
   * @class oj.MessagingStrategy
   * @private
   */
  const MessagingStrategy = function (displayOptions) {
    this.Init(displayOptions);
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(MessagingStrategy, oj.Object, 'oj.MessagingStrategy');
  oj._registerLegacyNamespaceProp('MessagingStrategy', MessagingStrategy);

  /**
   * Initializes the strategy based on the display options that specify the messaging artifacts that
   * will be displayed by this strategy.
   *
   * @param {Array.<string>} displayOptions an array of messaging artifacts displayed.
   * @private
   */
  MessagingStrategy.prototype.Init = function (displayOptions) {
    oj.Assert.assertArray(displayOptions);
    MessagingStrategy.superclass.Init.call(this);

    this._displayOptions = displayOptions;
  };

  MessagingStrategy.prototype.activate = function (cm) {
    this._componentMessaging = cm;
  };

  /**
   * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any
   * widgets it created, removes styles added etc.
   *
   * @private
   */
  MessagingStrategy.prototype.deactivate = function () {};

  /**
   * Utility function that closes anything that needs to be closed when oj.Components.subtreeHidden
   * is called. e.g, popup.
   *
   * @private
   */
  MessagingStrategy.prototype.close = function () {};

  /**
   *
   * @private
   */
  MessagingStrategy.prototype.setupResources = function () {};

  /**
   *
   * @private
   */
  MessagingStrategy.prototype.releaseResources = function () {};

  /**
   * Reinitializes with the new display options and updates component messaging using the new content.
   *
   * @param {Array.<string>} newDisplayOptions
   * @private
   */
  MessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
    this.Init(newDisplayOptions);
  };

  /**
   * Returns true always. Subclasses can override to ignore updates.
   *
   * @param {Object=} content the messaging content that is being updated
   * @return {boolean}
   *
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  MessagingStrategy.prototype.shouldUpdate = function (content) {
    return true;
  };

  /**
   * Updates component with instance using the content provided.
   *
   * @private
   */
  MessagingStrategy.prototype.update = function () {};

  // P R O T E C T E D  M E T H O D S
  /**
   * Gets the launcher element for which the messaging is applied.
   * @return {Object} the jquery element of the form element.
   * @private
   */
  MessagingStrategy.prototype.GetLauncher = function () {
    return this._componentMessaging._getLauncher();
  };

  /**
   * @return {Object} the jquery element of the form element.
   * @private
   */
  MessagingStrategy.prototype.GetContentElement = function () {
    return this._componentMessaging._getContentElement();
  };

  /**
   * Gets the component (widget).
   * @return {Object} the jet component instance
   * @private
   */
  MessagingStrategy.prototype.GetComponent = function () {
    return this._componentMessaging._getComponent();
  };

  /**
   * This is simply a flag.
   * Set to true when we get the validator hints from the component the first time.
   * Then use getHasValidatorHints to check if it is true. If so we
   * know we've already gotten the validator hints the first time and
   * won't get them from the component again.
   * @param {boolean} hasValidatorHints true if we have the validator hints
   * @private
   */
  MessagingStrategy.prototype.setHasValidatorHints = function (hasValidatorHints) {
    this._hasValidatorHints = hasValidatorHints;
  };

  /**
   * If true, it means we have already retrieved the validator hints from the
   * component.
   * @private
   * @return {boolean} true if we already have the validator hints, else false
   */
  MessagingStrategy.prototype.getHasValidatorHints = function () {
    return this._hasValidatorHints === true;
  };

  /**
   * Generates a unique id if the element doesn't have one already assigned.
   * @param {Element} element requiring an id
   * @private
   */
  MessagingStrategy.prototype.GenerateIdIfNeeded = function (element) {
    if (isNaN(MessagingStrategy._uidCounter)) {
      MessagingStrategy._uidCounter = 0;
    }

    var e = element;
    if (!e.id) {
      e.id = 'ojms_' + MessagingStrategy._uidCounter;
      MessagingStrategy._uidCounter += 1;
    }
  };

  /**
   * Returns an array of messages.
   *
   * @return {Array} of messages each an instance of oj.Message
   * @private
   */
  MessagingStrategy.prototype.GetMessages = function () {
    const unfilteredMessages = this.GetValidityState().getMessages();
    // if we don't have a _severitiesAllowedWhenReadonly filter array, just return the unfiltered messages.
    const severitiesAllowedWhenReadonly = this._componentMessaging._severitiesAllowedWhenReadonly;
    const filteredMessages = severitiesAllowedWhenReadonly
      ? unfilteredMessages.filter((message) =>
          severitiesAllowedWhenReadonly.includes(message.severity)
        )
      : unfilteredMessages;
    if (filteredMessages.length < unfilteredMessages.length) {
      const filteredOutMessages = unfilteredMessages.filter(
        (message) => !severitiesAllowedWhenReadonly.includes(message.severity)
      );
      filteredOutMessages.forEach((message) => {
        Logger.info(
          'The following message severity is not allowed when readonly: severity:' +
            message.severity +
            ', message detail:' +
            message.detail
        );
      });
    }
    return filteredMessages;
  };

  MessagingStrategy.prototype.GetMaxSeverity = function () {
    return this.GetValidityState().getMaxSeverity();
  };

  /**
   * Gets the converter hint.
   *
   * @return {Array} an array of hints, each a string.
   * @private
   */
  MessagingStrategy.prototype.GetConverterHint = function () {
    var hints = [];
    var mc = this._getMessagingContent();
    var converterHint = mc && mc.converterHint;
    if (converterHint) {
      hints.push(converterHint);
    }

    return hints;
  };

  /**
   * ValidatorHints are retrieved on-demand. The first time they are requested,
   * we get them and set the mc.validatorHints.
   * @return {string} helpInstruction or ""
   * @private
   */
  MessagingStrategy.prototype.GetValidatorHints = function () {
    if (!this.getHasValidatorHints()) {
      this.setHasValidatorHints(true);
      let component = this.GetComponent();
      // get the sync validator hints from the component, then set the messaging content.
      this._setMessagingContent(component._getValidatorHintsMC());

      component._initAsyncValidatorMessagingHint();
    }

    // Eventually the messagingContent will have all the validatorHints, even the async ones.
    // The async validators call componentMessaging.update(cm) when each hint Promise resolves with
    // all the validator hints it has so far, sync/async.
    // The first time through, before update, this will return the sync validator hints.
    // Every time the componentMessaging.update(cm) is called after, it will have the sync hints
    // plus any new async hints. The most common use case is to have only one validator per
    // form component but this supports multiple and sync and async.
    var mc = this._getMessagingContent();
    return (mc && mc.validatorHint) || [];
  };

  /**
   * Gets the short description.
   * @return {string} helpInstruction or ""
   * @private
   */
  MessagingStrategy.prototype.GetTitle = function () {
    var mc = this._getMessagingContent();
    return (mc && mc.title) || '';
  };

  /**
   * Gets the validityState, an instance of oj.ComponentValidity or null.
   * @private
   */
  MessagingStrategy.prototype.GetValidityState = function () {
    var mc = this._getMessagingContent();
    return (mc && mc.validityState) || null;
  };

  /**
   * Whether the strategy is displaying messages or not.
   * @return {boolean} true if strategy has messages to display
   * @private
   */
  MessagingStrategy.prototype.HasMessages = function () {
    var messages = this.GetMessages();
    return !!(messages && messages.length > 0);
  };

  /**
   * The following explains what this._displayOptions is in the following methods --
   * When the Strategy is created, like the PopupComponentMessaging strategy, it gets passed
   * in what artifacts it needs to display, like 'messages' or 'validatorHint'.
   * The default in alta is to show 'helpInstruction' and 'validatorHint' in 'notewindow'.
   * The api is displayOptions.helpInstruction = 'notewindow' and
   * displayOptions.validatorHint = 'notewindow', and this gets consolidated the other way,
   * notewindow: [helpInstruction, validatorHint], where notewindow is the PopupComponentStrategy.
   * For Redwood, we look at the user-assistance-density attribute, and by default the displayOptions
   * will be 'messages', 'helpInstruction' and 'validatorHint'.
   * 'helpInstruction', 'helpDefinition' and 'helpSource' are
   * shown if the attributes are set.
   * The user can turn off helpInstruction by not having a help instruction option.
   * The user can turn off messages and/or validationHint by setting its display-options to none, like
   * display-options.validatorHint = 'none'.
   */
  MessagingStrategy.prototype.ShowMessages = function () {
    return this._displayOptions.indexOf('messages') !== -1;
  };

  MessagingStrategy.prototype.ShowConverterHint = function () {
    return this._displayOptions.indexOf('converterHint') !== -1;
  };

  MessagingStrategy.prototype.ShowValidatorHint = function () {
    return this._displayOptions.indexOf('validatorHint') !== -1;
  };

  MessagingStrategy.prototype.ShowTitle = function () {
    return (
      this._displayOptions.indexOf('title') !== -1 ||
      this._displayOptions.indexOf('helpInstruction') !== -1
    );
  };

  /**
   * Returns true if we have invalid messages; false otherwise.
   *
   * @return {boolean}
   * @private
   */
  MessagingStrategy.prototype.IsInvalid = function () {
    return this.GetValidityState().isInvalid();
  };

  /**
   * Create an id to put on the root dom element that holds the inline messaging content,
   * then add aria-describedby on the component on the appropriate dom node(s).
   * This makes it so the screen reader user knows the messaging content is connected to the launcher.
   * @memberof oj.MessagingStrategy
   * @param {Element} containerRoot
   * @instance
   * @private
   */
  MessagingStrategy.prototype.AddAriaDescribedByForInlineMessaging = function (containerRoot) {
    // create an id on the div holding the inline messaging.
    // add aria-describedby to the launcher to associate the launcher and the inline message
    let $contentElems = this.GetContentElement();

    oj.Assert.assertPrototype($contentElems, $);

    let containerRootId = $(containerRoot).uniqueId()[0].getAttribute('id');

    $contentElems.each(function () {
      // get ariaAttr that is on the content element(s)
      let ariaAttributeValue = this.getAttribute(_DESCBY);
      // split into tokens
      let tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : [];
      // Get index that id is in the tokens, if at all.
      let index = tokens.indexOf(containerRootId);
      // push id into tokens if it isn't already there
      if (index === -1) {
        tokens.push(containerRootId);
      }
      // join the tokens together
      let newValue = tokens.join(' ').trim();
      this.setAttribute(_DESCBY, newValue); // @HTMLUpdateOK
    });
  };

  /**
   * @memberof oj.MessagingStrategy
   * @param {Element} containerRoot
   * @instance
   * @private
   */
  MessagingStrategy.prototype.AddDescribedByToElement = function (elem, id) {
    const attr = 'described-by';
    const currentAttributeValue = elem.getAttribute(attr);
    let newAttributeValue;

    let tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : [];
    // Get index that id is in the tokens, if at all.
    let index = tokens.indexOf(id);
    // add id if it isn't already there
    if (index === -1) {
      tokens.push(id);
    }
    newAttributeValue = tokens.join(' ').trim();
    elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
  };

  /**
   * @memberof oj.MessagingStrategy
   * @param {Element} containerRoot
   * @instance
   * @private
   */
  MessagingStrategy.prototype.RemoveDescribedByFromElement = function (elem, id) {
    const attr = 'described-by';
    const currentAttributeValue = elem.getAttribute(attr);

    // space deliminated string.
    let tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : [];

    // remove id if it is already there
    const filteredArray = tokens.filter((token) => token !== id);
    let newValue = filteredArray.join(' ').trim();
    if (newValue) {
      elem.setAttribute(attr, newValue); // @HTMLUpdateOK
    } else {
      elem.removeAttribute(attr);
    }
  };

  /**
   * Removes the aria-describedby from the launcher that was added by AddAriaDescribedByForInlineMessaging
   * @param {Element} containerRoot
   * @memberof oj.MessagingStrategy
   * @instance
   * @private
   */
  MessagingStrategy.prototype.RemoveAriaDescribedByForInlineMessaging = function (containerRoot) {
    let $contentElems = this.GetContentElement();
    oj.Assert.assertPrototype($contentElems, $);

    let containerRootId = containerRoot.getAttribute('id');

    $contentElems.each(function () {
      // get ariaAttr that is on the content element(s)
      let ariaAttributeValue = this.getAttribute(_DESCBY);
      // split into tokens
      let tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : [];
      // Get index that id is in the tokens, if at all.
      let index = tokens.indexOf(containerRootId);
      // remove id if it is there.
      if (index !== -1) {
        // remove that from the tokens array
        tokens.splice(index, 1);
      }
      let newValue = tokens.join(' ').trim();
      if (newValue) {
        this.setAttribute(_DESCBY, newValue); // @HTMLUpdateOK
      } else {
        this.removeAttribute(_DESCBY);
      }
    });
  };

  /**
   * Gets the messagingContent stored in ComponentMessaging instance
   * @return {Object}
   * @private
   */
  MessagingStrategy.prototype._getMessagingContent = function () {
    if (this._componentMessaging) {
      return this._componentMessaging._getMessagingContent();
    }

    return {};
  };

  /**
   * Gets the messagingContent stored in ComponentMessaging instance
   * @param {Object} messaging content.
   * @private
   */
  MessagingStrategy.prototype._setMessagingContent = function (content) {
    if (this._componentMessaging) {
      return this._componentMessaging._setMessagingContent(content);
    }

    return {};
  };

  /**
   * A messaging strategy that updates the component theming and accessibility attributes.
   *
   * @param {Array.<string>} displayOptions .
   * @constructor
   * @extends {oj.MessagingStrategy}
   * @private
   */
  const DefaultMessagingStrategy = function (displayOptions) {
    this.Init(displayOptions);
  };

  ComponentMessaging.registerMessagingStrategy(
    ComponentMessaging._STRATEGY_TYPE.NONE,
    DefaultMessagingStrategy
  );

  // TODO: Need to retrieve style selectors from a Style Manager
  DefaultMessagingStrategy._SELECTOR_STATE_INVALID = 'oj-invalid';
  DefaultMessagingStrategy._SELECTOR_STATE_WARNING = 'oj-warning';

  oj.Object.createSubclass(
    DefaultMessagingStrategy,
    MessagingStrategy,
    'oj.DefaultMessagingStrategy'
  );
  oj._registerLegacyNamespaceProp('DefaultMessagingStrategy', DefaultMessagingStrategy);

  /**
   * Updates component theming, a11y attributes using the latest component state and its messaging
   * content.
   *
   * @private
   */
  DefaultMessagingStrategy.prototype.update = function () {
    DefaultMessagingStrategy.superclass.update.call(this);

    var launcher = this.GetLauncher();
    var maxSeverity = this.GetMaxSeverity();
    var removeClasses = [];
    var addClasses = [];
    var invalid = false;
    var component = this.GetComponent();
    var jqRoot = component.widget();

    if (!launcher) {
      return;
    }

    // apply element error styling if invalid
    if (this.IsInvalid()) {
      // enable tooltip; set invalid class and aria invalid
      // TODO: oj classes should be set on the root DOM
      removeClasses.push(DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
      addClasses.push(DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
      invalid = true;
    } else if (this.HasMessages() && maxSeverity === Message.SEVERITY_LEVEL.WARNING) {
      // TODO: add warning or other severity state
      removeClasses.push(DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
      addClasses.push(DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    } else {
      // for all other messages we remove selectors
      removeClasses.push(DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
      removeClasses.push(DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    }

    jqRoot.removeClass(removeClasses.join(' ')).addClass(addClasses.join(' ')); // classes added to root
    // aria-invalid needs to be on an input/textarea
    this.GetContentElement().attr({ 'aria-invalid': invalid });
  };

  /**
   * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any
   * widgets it created, removes styles added etc.
   *
   * @private
   */
  DefaultMessagingStrategy.prototype.deactivate = function () {
    var jqRoot = this.GetComponent().widget();

    jqRoot
      .removeClass(DefaultMessagingStrategy._SELECTOR_STATE_INVALID)
      .removeClass(DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    this.GetContentElement().removeAttr('aria-invalid');
    DefaultMessagingStrategy.superclass.deactivate.call(this);
  };

  /**
   * A messaging strategy that uses html5 placeholder (for now) to set/remove placeholder content.
   *
   * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the placeholder.
   * @constructor
   * @extends {oj.MessagingStrategy}
   * @private
   */
  const PlaceholderMessagingStrategy = function (displayOptions) {
    this.Init(displayOptions);
  };

  ComponentMessaging.registerMessagingStrategy(
    ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER,
    PlaceholderMessagingStrategy
  );

  // Subclass from oj.MessagingStrategy
  oj.Object.createSubclass(
    PlaceholderMessagingStrategy,
    MessagingStrategy,
    'oj.PlaceholderMessagingStrategy'
  );
  oj._registerLegacyNamespaceProp('PlaceholderMessagingStrategy', PlaceholderMessagingStrategy);

  /**
   * Initializer
   *
   * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the notewindow.
   * @private
   */
  PlaceholderMessagingStrategy.prototype.Init = function (displayOptions) {
    PlaceholderMessagingStrategy.superclass.Init.call(this, displayOptions);
  };

  /**
   * Sets up a placeholder for the component instance using the converter hint.
   *
   * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
   * the latest messaging content.
   *
   * @private
   */
  PlaceholderMessagingStrategy.prototype.activate = function (cm) {
    PlaceholderMessagingStrategy.superclass.activate.call(this, cm);
    this._refreshPlaceholder();
  };

  PlaceholderMessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
    PlaceholderMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);
    this._refreshPlaceholder();
  };

  /**
   * Returns true if the content being updated includes converterHint prop. This method is an
   * optimization because the update() method is called too often and any time any content changes.
   * The only time PlaceholderMessagingStrategy#update needs to execute is when the converter hint
   * changes.
   *
   * @param {Object=} content the messaging content that is being updated
   * @return {boolean}
   *
   * @private
   */
  PlaceholderMessagingStrategy.prototype.shouldUpdate = function (content) {
    return !!(content && content.converterHint !== undefined);
  };

  PlaceholderMessagingStrategy.prototype.update = function () {
    PlaceholderMessagingStrategy.superclass.update.call(this);
    this._refreshPlaceholder();
  };

  // a default placeholder is set on the component, and that is typically the converter hint
  PlaceholderMessagingStrategy.prototype._refreshPlaceholder = function () {
    var launcher = this.GetLauncher();

    if (this.ShowPlaceholderContent() && launcher) {
      var hints = this.GetConverterHint();
      var content = hints.length ? hints[0] : '';

      // don't override the placeholder with the converter hint if it's empty
      if (oj.StringUtils.isEmptyOrUndefined(content)) return;

      var context = { internalMessagingSet: true };
      // set from messaging module
      this.GetComponent().option({ placeholder: content }, { _context: context });
    }
  };

  PlaceholderMessagingStrategy.prototype.ShowPlaceholderContent = function () {
    // we have a placeholder to set/show if we have converterHint set.
    return this.ShowConverterHint();
  };

  /**
   * The ComponentValidity object represent a component's current validity state. The instance
   * provides specific methods to retrieve info such as <p>
   *  - whether the component is valid <p>
   *  - the messages currently tracked on the component.<p>
   *  - the max severity level of the messages, e.g., fatal, error etc. See oj.Message for details
   *
   * @param {boolean} valid
   * @param {Array} messages
   * @constructor
   * @private
   */
  const ComponentValidity = function (valid, messages) {
    // TODO: provide methods that allow model implementations to instruct the elements to showMessages,
    // especially the ones marked for 'lazy' notification.
    this.Init(valid, messages);
  };

  /**
   * whether there are invalid messages among the list of messages.
   *
   * @param {Array} messages list of messages
   * @returns {boolean} true if we have invalid messages; false otherwise
   */
  ComponentValidity.isInvalid = function (messages) {
    var maxLevel = Message.getMaxSeverity(messages);
    if (maxLevel >= Message.SEVERITY_LEVEL.ERROR) {
      return true;
    }

    return false;
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(ComponentValidity, oj.Object, 'oj.ComponentValidity');
  oj._registerLegacyNamespaceProp('ComponentValidity', ComponentValidity);

  /**
   * The jquery element whose validity this object describes
   * @param {boolean} valid
   * @param {Array} messages instances of oj.Message
   */
  ComponentValidity.prototype.Init = function (valid, messages) {
    ComponentValidity.superclass.Init.call(this);
    this._initialize(valid, messages);
  };

  /**
   * Returns a boolean true if valid; false if element not valid
   * @returns {boolean}
   * @private
   */
  ComponentValidity.prototype.isInvalid = function () {
    return this._invalid;
  };

  /**
   * Returns an Array or messages that we are marked for immediate display or an empty array.
   * @private
   * @returns {Array}
   */
  ComponentValidity.prototype.getMessages = function () {
    return this._messages;
  };

  /**
   * Returns the max severity level.
   * @return {number}
   * @private
   */
  ComponentValidity.prototype.getMaxSeverity = function () {
    return this._maxSeverity;
  };

  /**
   * Updates the validity state for the component.
   *
   * @param {boolean} valid
   * @param {Array} messages instances of oj.Message
   * @private
   */
  ComponentValidity.prototype.update = function (valid, messages) {
    this._initialize(valid, messages);
  };

  ComponentValidity.prototype._initialize = function (valid, messages) {
    this._compValid = valid;
    this._compMessages = messages;

    this._messages = this._getImmediateMessages(); // messages currently showing
    this._maxSeverity = Message.getMaxSeverity(this._messages); // max severity of messages currently showing
    this._invalid = ComponentValidity.isInvalid(this._messages);
  };

  /**
   * Returns an array of messages that are marked for immediate display.
   *
   * @return {Array} of messages each an instance of oj.Message
   * @private
   */
  ComponentValidity.prototype._getImmediateMessages = function () {
    var messages = this._compMessages || [];
    var immediateMsgs = [];
    for (var index = 0; index < messages.length; index++) {
      var msg = messages[index];
      // gather component messages marked for immediate display
      if (!(msg instanceof Message.ComponentMessage) || msg.canDisplay()) {
        immediateMsgs.push(msg);
      }
    }

    return immediateMsgs;
  };

  /**
   * @namespace Components
   * @classdesc JET Component services
   * @since 1.0
   * @export
   * @ojtsmodule
   * @hideconstructor
   */
  const Components = {};
  oj$1._registerLegacyNamespaceProp('Components', Components);

  /**
   * @private
   */
  Components._OJ_CONTAINER_ATTR = 'data-oj-container';

  /**
   * @private
   */
  const _OJ_WIDGET_NAMES_DATA = 'oj-component-names';

  /**
   * Marks the element which is a jQueryUI component
   * @private
   */
  const _OJ_COMPONENT_NODE_CLASS = 'oj-component-initnode';

  /**
   * @private
   */
  const _NOT_COMP = 'node is not a component element';

  /**
   * Sets default options values for JET components.
   * @param {!Object} options - property values that will be merged into the values
   * that were previously set using this method. The options object is expected to have the format demonstrated
   * by the following example:
   * <pre>
   * {
   *   'default': // properties for all JET components
   *   {
   *     'option1': 'somevalue'
   *   },
   *   'editableValue': // properties for editableValue components
   *   {
   *     'option1': 'somevalue1',
   *     'option2': Components.createDynamicPropertyGetter(function(context){
   *                                 return context['containers'].indexOf('ojTable') >= 0 ? 'tableValue' : 'normalValue'})
   *   },
   *   'ojText': // properties for instances of ojText
   *   {
   *     'option1': 'somevalue2'
   *   }
   * }
   * </pre>
   * To specify a dynamic getter for the property, pass your callback to Components.createDynamicPropertyGetter(). Note
   * that dynamic getters nested within a complex property value are not supported
   * @see Components.createDynamicPropertyGetter
   * @return {void}
   * @export
   * @ojtsignore
   */
  Components.setDefaultOptions = function (options) {
    var props = Components._defaultProperties || {};

    var keys = Object.keys(options);

    keys.forEach(function (key) {
      var value = options[key];
      if (!oj$1.CollectionUtils.isPlainObject(value)) {
        throw new Error('Invalid default options');
      }
      props[key] = _accumulateValues(props[key] || {}, value, false);
    });

    Components._defaultProperties = props;
  };

  /**
   * Retrieves default option values for JET components. This method should only be used internally by JET.
   * @deprecated since version 2.2
   * @ignore
   * @return {Object} default option values
   * @see Components.setDefaultOptions
   * @export
   */
  Components.getDefaultOptions = function () {
    return Components._defaultProperties || {};
  };

  /**
   * Creates a dynamic getter that can be used as a property value in Components.setDefaultOptions()
   * @param {!Function} callback - dynamic property callback. The callback will receive a context object as a parameter.
   * The following properties are currently supported on the context object:
   * <ul>
   * <li>containers - an array of component names of the current component's containers that require special behavior from
   * their children</li>
   * <li>element - component's host DOM element</li>
   * </ul>
   * The callback should return the computed property value
   *
   * @return {Object} - dynamic property getter
   * @see Components.setDefaultOptions
   * @export
   * @ojtsignore
   */
  Components.createDynamicPropertyGetter = function (callback) {
    return new __ojDynamicGetter(callback);
  };

  /**
   * This method should only be used for JQueryUI components and will return null if used
   * with a custom element. Retrieves widget constructor associated with the HTML element
   * or null if none is found. The returned constructor is already bound to the associated
   * JQuery element, so it can be invoked as a function directly. For example:
   * <pre>
   * widgetConstructor("option", "label", "custom"); // sets label option
   * </pre>
   * If widgetName is not specified, and if more than one widget is associated with the element,
   * the method will a return the widget that was created first.
   * @param {?(Element|Node)} element - HTML element
   * @param {string=} widgetName - optional widget name
   * @return {Function|null} widget constructor
   * @export
   * @ojtsignore
   */
  Components.getWidgetConstructor = function (element, widgetName) {
    if (element && !ojcustomelementRegistry.isElementRegistered(element.tagName)) {
      return Components.__GetWidgetConstructor(element, widgetName);
    }
    return null;
  };

  /**
   * Internal version for components to call which won't return null for
   * custom elements. See public method for jsDoc.
   * @param {?(Element|Node)} element - HTML element
   * @param {string=} widgetName - optional widget name
   * @return {Function|null} widget constructor
   * @ignore
   */
  Components.__GetWidgetConstructor = function (element, widgetName) {
    var jelem = $(element);

    var data = jelem.data(_OJ_WIDGET_NAMES_DATA);
    if (data) {
      if (widgetName == null) {
        // eslint-disable-next-line no-param-reassign
        widgetName = data[0];
      } else if (data.indexOf(widgetName) < 0) {
        // eslint-disable-next-line no-param-reassign
        widgetName = undefined;
      }

      if (widgetName != null) {
        var func = jelem[widgetName];
        if (typeof func === 'function') {
          return func.bind(jelem);
        }
      }
    }
    return null;
  };

  /**
   * Notifies JET framework that a subtree possibly containing JET components has been inserted
   * into the document programmatically.
   *
   * Note that there is no need to call this method when the new DOM is being inserted by the template engine
   * in Knockout.js
   * @param {!Element} node - the root of the subtree
   * @see Components.subtreeDetached
   * @return {void}
   * @export
   * @alias Components.subtreeAttached
   */
  Components.subtreeAttached = function (node) {
    DomUtils.fixResizeListeners(node);
    _applyToComponents(node, function (instance) {
      instance.__handleSubtreeAttached();
    });
  };

  /**
   * Notifies JET framework that a subtree possibly containing JET components has been removed
   * from the document programmatically.
   *
   * Note that calling this method is not needs after calling JQuery's .remove() because all JET components would have been
   * already destroyed in that case. Similarly, there is no need to call this method after the subtree has been removed by
   * Knockout.js
   * @param {!Element} node - the root of the subtree
   * @see Components.subtreeAttached
   * @return {void}
   * @export
   * @alias Components.subtreeDetached
   */
  Components.subtreeDetached = function (node) {
    _applyToComponents(node, function (instance) {
      instance.__handleSubtreeDetached();
    });
  };

  /**
   * Notifies JET framework that a subtree possibly containing JET components is no longer hidden with display:none style
   * This method should be called by the application if the 'display' style is being changed from 'hidden' programmatically,
   * such as when JQuery's .show() method is called.
   * For cases where subtree is shown on initial render, this method should be called with the options parameter set to
   * {'initialRender':true}, that will result in _NotifyInitShown() calls to the subtree components.
   * All oj-defer elements in the entire subtree will be activated. Note that subtreeShown currently notifies the entire
   * subtree as well. This generally means that only non-nested oj-defer elements make sense in a subtree.
   *
   * @param {!Node} node - the root of the subtree
   * @param {Object=} options Options to control subtreeShown
   * @param {boolean} options.initialRender The index at which to start fetching records.
   * @see Components.subtreeHidden
   * @return {void}
   * @export
   * @alias Components.subtreeShown
   */
  Components.subtreeShown = function (node, options) {
    const _node = $(node)[0]; // Strip possible jQuery wrapper
    if (_node.nodeType !== Node.ELEMENT_NODE) {
      return;
    }
    const isInitialRender = !!options?.initialRender;
    ojcustomelementUtils.CustomElementUtils.subtreeShown(_node, isInitialRender);
  };

  /**
   * Notifies JET framework that a subtree possibly containing JET components has been hidden  with display:none style
   * This method should be called by the application after the subtree has been hidden programmatically, such as
   * when JQuery's .hide() method is called.
   *
   * @param {!Node} node - the root of the subtree
   * @see Components.subtreeShown
   * @return {void}
   * @export
   * @alias Components.subtreeHidden
   */
  Components.subtreeHidden = function (node) {
    const _node = $(node)[0]; // Strip possible jQuery wrapper
    if (_node.nodeType !== Node.ELEMENT_NODE) {
      return;
    }

    ojcustomelementUtils.CustomElementUtils.subtreeHidden(_node);
  };

  /**
   * Called by CCAs and certain custom elements when they are first connected
   * to indicate that this component is initializing and will control
   * whether its child subtrees are hidden.
   *
   * @ignore
   */
  Components.markPendingSubtreeHidden = function (element) {
    ojcustomelementUtils.CustomElementUtils.markPendingSubtreeHidden(element);
  };

  /**
   * Called by CCAs and certain custom elements right before they are first rendered.
   * This component will control whether its child subtrees are hidden.
   *
   * @ignore
   */
  Components.unmarkPendingSubtreeHidden = function (element) {
    ojcustomelementUtils.CustomElementUtils.unmarkPendingSubtreeHidden(element);
  };

  /**
   * Determines if a component identified by the <code>widgetName</code> has been
   * bound and initialized on a given <code>jelement</code>.
   *
   * @param {jQuery} jelement to which the component is bound
   * @param {string} widgetName constructor name of the target component.
   * @return {boolean} <code>true</code> if the component identified by the widgetName
   *  has be bound and initialized to the target element.
   * @ojtsignore
   */
  Components.isComponentInitialized = function (jelement, widgetName) {
    /** @type {?} */
    var widgets = jelement.data(_OJ_WIDGET_NAMES_DATA);
    if (
      $.isArray(widgets) &&
      widgets.indexOf(widgetName) > -1 &&
      jelement.is('.' + _OJ_COMPONENT_NODE_CLASS)
    ) {
      return true;
    }
    return false;
  };

  /**
   * @ignore
   */
  Components.__getDefaultOptions = function (hierarchyNames) {
    var defaults = {};
    var allProperties = Components.getDefaultOptions();

    for (var i = hierarchyNames.length - 1; i >= 0; i--) {
      var name = hierarchyNames[i];
      var props = allProperties[name];
      if (props !== undefined) {
        defaults = _accumulateValues(defaults, props, true);
      }
    }

    return defaults;
  };

  /**
   * Retrieves the JET component element that
   * the node is in.
   * @param {?(Element|Node)} node - DOM node
   * @return {?(Element|Node)} componentElement - JET component element
   * A component element is the DOM element on which the JET component is
   * initialized.
   * @export
   * @ojtsignore
   */
  Components.getComponentElementByNode = function (node) {
    // Temporarily exposing this private flag in order to allow
    // MonkeyTalk to access JET components that are part of the
    // composite's implementation. We are not exposing this flag
    // as a public API as a) accessing composite implementation
    // components is bad and b) the need for this method will soon
    // go away. Once our new automation API (recording adapters) are
    // in place, even MonkeyTalk will no longer need this flag. Adding
    // this as a stop-gap measure to allow MonkeyTalk to carry on in the
    // meantime. Callers other than MonkeyTalk must avoid specifying this flag.
    var mtAccessCompositeInternals = !!(arguments.length > 1 && arguments[1]);
    return _getComponentElementByNode(node, mtAccessCompositeInternals);
  };

  /**
   * Private method implementing the functionality of
   * getComponentElementByNode. This was done because Closure
   * throws an error when the private, undocumented flag (mtAccessCompositeInternals)
   * is passed to recursive calls of getComponentElementByNode.
   * @private
   */
  function _getComponentElementByNode(node, mtAccessCompositeInternals) {
    if (node == null) {
      return null;
    }
    // node can be a Node or Element but we call some Element only APIs
    // so we need to do an additional isElement check first
    var isElement = node.nodeType === 1;
    // for upstream or indirect dependency we will still rely components being registered on the oj namespace.
    var containingComposite =
      oj$1.Composite && !mtAccessCompositeInternals ? oj$1.Composite.getContainingComposite(node) : null;
    if (containingComposite) {
      // node is in or is a composite, return composite
      return containingComposite;
    } else if (isElement && node.hasAttribute('data-oj-internal')) {
      // node is an internal component
      if (
        node.parentNode instanceof Element &&
        node.parentNode.hasAttribute('data-oj-surrogate-id')
      ) {
        // internal component is a popup
        // eslint-disable-next-line no-param-reassign
        node = document.querySelector('[data-oj-popup-' + node.id + '-parent]'); // retrieves popups parent element
        return _getComponentElementByNode(node, mtAccessCompositeInternals);
      }
      return _getComponentElementByNode(node.parentNode, mtAccessCompositeInternals);
    } else if (_isComponentElement(node)) {
      // node is a component element
      return node;
    } else if (isElement && node.classList.contains('oj-component')) {
      // node is component wrapper
      // eslint-disable-next-line no-param-reassign
      node = node.querySelector('.oj-component-initnode:not([data-oj-internal])') || node;
      if (_isJQueryUI(node)) {
        return node;
      }
    } else if (isElement && node.hasAttribute('data-oj-containerid')) {
      // node is non-internal component popup e.g listbox
      // eslint-disable-next-line no-param-reassign
      node = document.getElementById(node.getAttribute('data-oj-containerid'));
      return _getComponentElementByNode(node, mtAccessCompositeInternals);
    }
    return _getComponentElementByNode(node.parentNode, mtAccessCompositeInternals);
  }

  /**
   * Retrieves the subId of the node as
   * as part of a locator object i.e. at least
   * {subId: subIdOfNode}
   * @param {?Element} componentElement - JET component element
   * @param {?Element} node - DOM node
   * @return {any} locator - object with at least a subId
   * or null if the node does not have a subId
   * @export
   * @ojtsignore
   */
  Components.getSubIdByNode = function (componentElement, node) {
    return Components.callComponentMethod(componentElement, 'getSubIdByNode', node);
  };

  /**
   * Returns the component DOM node indicated
   * by the locator parameter.
   * @param {?Element} componentElement - JET component element
   * @param {Object} locator - Object containing, at minimum,
   * a subId property, whose value is a string that identifies
   * a particular DOM node in this component.
   * @return {any} node - The DOM node located by
   * the locator, or null if none is found
   * @export
   * @ojtsignore
   */
  Components.getNodeBySubId = function (componentElement, locator) {
    return Components.callComponentMethod(componentElement, 'getNodeBySubId', locator);
  };

  /**
   * Retrieves the specified option of
   * the specified JET component element
   * @param {?Element} componentElement - JET component element
   * @param {string} option - option to retrieve
   * @return {any} value of option
   * @export
   * @ojtsignore
   */
  Components.getComponentOption = function (componentElement, option) {
    if (!_isComponentElement(componentElement)) {
      throw new Error(_NOT_COMP);
    } else if (_isCompositeOrCustom(componentElement)) {
      if (componentElement.getProperty) {
        return componentElement.getProperty.call(componentElement, option);
      }
    } else {
      return Components.__GetWidgetConstructor(componentElement)('option', option);
    }
    return undefined;
  };

  /**
   * Sets the specified option of the specified
   * JET component element to the specified value
   * @param {?Element} componentElement - JET component element
   * @param {string} option - option to set
   * @param {any} value - value to set option to
   * @return {void}
   * @export
   * @ojtsignore
   */
  Components.setComponentOption = function (componentElement, option, value) {
    if (!_isComponentElement(componentElement)) {
      throw new Error(_NOT_COMP);
    } else if (_isCompositeOrCustom(componentElement)) {
      if (componentElement.setProperty) {
        componentElement.setProperty.call(componentElement, option, value);
      }
    } else {
      Components.__GetWidgetConstructor(componentElement)('option', option, value);
    }
  };

  /**
   * Calls the specified JET component element's method
   * with the given arguments
   * @param {?Element} componentElement - JET component element
   * @param {string} method - name of JET component element method to call
   * @param {...*} methodArguments - list of arguments to pass to method call
   * @return {any}
   * @export
   * @ojtsignore
   */
  // eslint-disable-next-line no-unused-vars
  Components.callComponentMethod = function (componentElement, method, methodArguments) {
    if (!_isComponentElement(componentElement)) {
      throw new Error(_NOT_COMP);
    } else if (_isCompositeOrCustom(componentElement)) {
      if (componentElement[method]) {
        return componentElement[method].apply(componentElement, [].slice.call(arguments, 2));
      }
    } else {
      return Components.__GetWidgetConstructor(componentElement).apply(
        $(componentElement),
        [].slice.call(arguments, 1)
      );
    }
    return undefined;
  };

  /**
   * @private
   */
  function _getJetWidgetInstance(jelem) {
    var names = jelem.data(_OJ_WIDGET_NAMES_DATA);
    if (names != null) {
      for (var i = 0; i < names.length; i++) {
        var instance = jelem.data('oj-' + names[i]);
        if (instance != null) {
          return instance;
        }
      }
    }
    return null;
  }

  /**
   * @private
   */
  function _applyToComponents(subtreeRoot, jqCallback) {
    var processFunc = function () {
      const instance = _getJetWidgetInstance($(this));
      if (instance) {
        jqCallback(instance);
      }
    };

    var locator = $(subtreeRoot);

    // Include the root node itself, and not just children ()
    if (locator.hasClass(_OJ_COMPONENT_NODE_CLASS)) {
      processFunc.call(subtreeRoot);
    }

    locator.find('.' + _OJ_COMPONENT_NODE_CLASS).each(processFunc);
  }

  /**
   * @constructor
   * @param {!Function} callback
   * @private
   */
  function __ojDynamicGetter(callback) {
    this.getCallback = function () {
      return callback;
    };
  }

  /**
   * @ignore
   */
  function _accumulateValues(target, source, valueInArray) {
    var keys = Object.keys(source);

    keys.forEach(function (key) {
      var holder = target[key] || [];
      var sourceVal = source[key];
      if (valueInArray) {
        holder = holder.concat(sourceVal);
      } else {
        holder.push(sourceVal);
      }
      // eslint-disable-next-line no-param-reassign
      target[key] = holder;
    });
    return target;
  }

  /**
   * @ignore
   */
  function _isCompositeOrCustom(node) {
    return ojcustomelementRegistry.isElementRegistered(node.tagName);
  }

  /**
   * @ignore
   */
  function _isJQueryUI(node) {
    return !!Components.__GetWidgetConstructor(node);
  }

  /**
   * @ignore
   */
  function _isComponentElement(node) {
    return _isCompositeOrCustom(node) || _isJQueryUI(node);
  }

  // Register legacy subtreeShown/Hidden traversal callbacks on CustomElementUtils
  // The execution code needs to 'live' in CustomElementUtils becasue it needs to activate
  // oj-defer tags even when JET legacy jQueryUI-based custom elements are not being used.
  ojcustomelementUtils.CustomElementUtils.registerLegacySubtreeCallbacks(
    (element, isInitialRender) => {
      const instance = _getJetWidgetInstance($(element));
      if (!instance) {
        return;
      }
      if (isInitialRender) {
        instance._NotifyInitShown();
      } else {
        instance._NotifyShown();
      }
    },
    (element, isInitialRender) => {
      if (!isInitialRender) {
        DomUtils.fixResizeListeners(element);
      }
    },
    (element) => {
      const instance = _getJetWidgetInstance($(element));
      if (instance) {
        instance._NotifyHidden();
      }
    }
  );

  /**
   * A bridge for a custom element that renders using a constructor
   * function. Note that when a constructor function is provided, the new instance isn't
   * created until the CreateComponent method so property changes that occur before the
   * component instance is created will no-op.
   *
   * Components that provide a constructor function should implement the following methods:
   * createDOM - Called when the component is instantiated
   * updateDOM - Called after createDOM and when the component needs to do a full render on
   * refresh and property changes if the component is not handling them separately.
   * handlePropertyChanged - (optional) Called when properties change and should return true if
   * the component has handled the property change and does not need to do a full render. If
   * false is returned, updateDOM will be called to do a full render.
   * static getDynamicDefaults - (optional) An optional method that can return an object with
   * non JSON compatible default values or getters for properties with dynamic default values,
   * e.g. theme dependent properties. If a default for a property is also found in metadata,
   * the dynamic value will be ignored.
   *
   * When the constructor function is called, the bridge will pass a context object
   * with the following keys:
   * element - The custom element
   * props - A proxy for the element properties with setter/getter and setProperty APIs allowing the
   *         component to control writeback.
   * unique - A unique ID that the component can append to the custom element ID to generate unique IDs
   *
   * Note that components supporting the constructor function approach may eventually
   * be refactored into composites once composites support non template rendering.
   *
   * This bridge ensures that JET components with child JET custom elements
   * can access child properties before the child busy state resolves.
   * This bridge does not guarantee that all properties for the child
   * will be available to the application before its busy states resolves,
   * e.g data bound attribute values.
   *
   * Applications should still wait on the element or page level
   * busy context before accessing properties or methods.
   *
   * @class
   * @ignore
   */
  const DefinitionalElementBridge = {};

  /**
   * Prototype for the JET component definitional bridge instance
   */
  DefinitionalElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
  oj.CollectionUtils.copyInto(DefinitionalElementBridge.proto, {
    beforePropertyChangedEvent: function (element, property, detail) {
      // Call the renderer function so the definitional element can refresh its UI
      var changedProp = property;
      var value = detail.value;
      if (detail.subproperty) {
        changedProp = detail.subproperty.path;
        value = detail.subproperty.value;
      }
      this._partialRender(element, changedProp, value);
    },

    AddComponentMethods: function (proto) {
      // Add refresh and subproperty getter/setter methods for all definitional elements
      // eslint-disable-next-line no-param-reassign
      proto.refresh = function () {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        bridge._fullRender(this);
      };
      // eslint-disable-next-line no-param-reassign
      proto.setProperty = function (prop, value) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        if (!bridge.SaveEarlyPropertySet(this, prop, value)) {
          bridge.SetProperty(this, prop, value, this, true);
        }
      };
      // eslint-disable-next-line no-param-reassign
      proto.getProperty = function (prop) {
        // 'this' is the property object we pass to the definitional element contructor to track internal property changes
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        return bridge.GetProperty(this, prop, this);
      };
      // eslint-disable-next-line no-param-reassign
      proto._propsProto.setProperty = function (prop, value) {
        // 'this' is the property object we pass to the definitional element contructor to track internal property changes
        this._BRIDGE.SetProperty(this._ELEMENT, prop, value, this, false);
      };
      // eslint-disable-next-line no-param-reassign
      proto._propsProto.getProperty = function (prop) {
        return this._BRIDGE.GetProperty(this, prop, this);
      };
    },

    CreateComponent: function (element) {
      ojcustomelementUtils.CustomElementUtils.unmarkPendingSubtreeHidden(element);

      if (!this._INSTANCE && this._EXTENSION._CONSTRUCTOR) {
        // We expose a similar set of properties as composites except that props is
        // not a Promise and we don't expose any slot information.
        // At the moment some definitional elements have mutation observers so they don't need
        // to rely on refresh being called to be alerted of new children so any cached slotMap
        // can become out of sync. We should add this once we build in support to auto detect
        // added/removed children to custom elements.
        var unique = ojcustomelementUtils.ElementUtils.getUniqueId();
        this._CONTEXT = {
          element: element,
          props: this._PROPS_PROXY,
          unique: unique
        };
        this._CONTEXT.uniqueId = element.id ? element.id : unique;
        this._INSTANCE = new this._EXTENSION._CONSTRUCTOR(this._CONTEXT);
        // Let the component initialize any additional DOM and then do a full render
        if (this._INSTANCE.createDOM) {
          this._INSTANCE.createDOM();
        }
        if (this._INSTANCE.updateDOM) {
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
          try {
            this._INSTANCE.updateDOM();
          } finally {
            ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
          }
        }
      }
    },

    DefineMethodCallback: function (proto, method, methodMeta) {
      // eslint-disable-next-line no-param-reassign
      proto[method] = function () {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        if (bridge._INSTANCE) {
          var methodName = methodMeta.internalName || method;
          return bridge._INSTANCE[methodName].apply(bridge._INSTANCE, arguments);
        }
        return undefined;
      };
    },

    DefinePropertyCallback: function (proto, property, propertyMeta) {
      function set(value, bOuterSet) {
        // Properties can be set before the component is created. These early
        // sets are actually saved until after component creation and played back.
        if (!this._BRIDGE.SaveEarlyPropertySet(this._ELEMENT, property, value)) {
          if (bOuterSet) {
            // eslint-disable-next-line no-param-reassign
            value = ojcustomelementUtils.transformPreactValue(this._ELEMENT, property, propertyMeta, value);
          }
          var previousValue = this._BRIDGE._PROPS[property];
          if (!ojcustomelementUtils.ElementUtils.comparePropertyValues(propertyMeta.writeback, value, previousValue)) {
            // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
            if (bOuterSet) {
              // eslint-disable-next-line no-param-reassign
              value = this._BRIDGE.ValidatePropertySet(this._ELEMENT, property, value);
            }
            if (propertyMeta._eventListener) {
              this._BRIDGE.SetEventListenerProperty(this._ELEMENT, property, value);
              this._BRIDGE._PROPS[property] = value;
            } else {
              this._BRIDGE._PROPS[property] = value;
              oj.BaseCustomElementBridge.__FirePropertyChangeEvent(
                this._ELEMENT,
                property,
                value,
                previousValue,
                bOuterSet ? 'external' : 'internal'
              );
              this._BRIDGE.State.dirtyProps.add(property);
            }
          } else {
            Logger.info(
              ojcustomelementUtils.CustomElementUtils.getElementInfo(this._ELEMENT) +
                ": Ignoring property set for property '" +
                property +
                "' with same value."
            );
          }
        }
      }

      function innerSet(value) {
        set.bind(this)(value, false);
      }

      // Called on the custom element
      function outerSet(value) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        set.bind(bridge._PROPS_PROXY)(value, true);
      }

      function get() {
        var value = this._BRIDGE._PROPS[property];
        // If the attribute has not been set, return the default value
        if (value === undefined) {
          value = this._BRIDGE._getDefaultValue(property, propertyMeta);

          if (value && oj.CollectionUtils.isPlainObject(value)) {
            this._BRIDGE._PROPS[property] = oj.CollectionUtils.copyInto({}, value, undefined, true);
          } else {
            this._BRIDGE._PROPS[property] = value;
          }
        }
        return value;
      }

      function innerGet() {
        return get.bind(this)();
      }

      // Called on the custom element
      function outerGet() {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        return get.bind(bridge._PROPS_PROXY)();
      }

      // Don't add event listener properties for inner props
      if (!propertyMeta._derived) {
        oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(
          proto._propsProto,
          property,
          innerGet,
          innerSet
        );
      }
      oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto, property, outerGet, outerSet);
      ojcustomelementUtils.addPrivatePropGetterSetters(proto, property);
    },

    InitializeElement: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

      if (this._EXTENSION._CONTROLS_SUBTREE_HIDDEN) {
        ojcustomelementUtils.CustomElementUtils.markPendingSubtreeHidden(element);
      }

      oj.BaseCustomElementBridge.__InitProperties(element, element);
    },

    InitializePrototype: function (proto) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializePrototype.call(this, proto);

      Object.defineProperty(proto, '_propsProto', { value: {} });
    },

    initializeBridge: function (element, descriptor) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.initializeBridge.call(this, element, descriptor);

      this._EXTENSION = this.METADATA.extension || {};

      // For tracking outer property sets
      this._PROPS = {};

      // / For tracking inner property sets
      if (element._propsProto) {
        this._PROPS_PROXY = Object.create(element._propsProto);
        this._PROPS_PROXY._BRIDGE = this;
        this._PROPS_PROXY._ELEMENT = element;
      }
    },

    ShouldRemoveDisabled: function () {
      // Definitional components can opt in to have their disabled attribute removed.
      return this._EXTENSION._SHOULD_REMOVE_DISABLED === true;
    },

    // eslint-disable-next-line no-unused-vars
    _fullRender: function (element) {
      if (this._INSTANCE && this._INSTANCE.updateDOM) {
        ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
        try {
          this._INSTANCE.updateDOM();
        } finally {
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
        }
      }
    },

    _partialRender: function (element, property, value) {
      if (this._INSTANCE) {
        // For partial renders, check to see if the component is handling the property change
        // or if it should do a full render
        var handlePropChangedFun = this._INSTANCE.handlePropertyChanged;
        var fullRender = !handlePropChangedFun || !handlePropChangedFun(property, value);
        if (fullRender && this._INSTANCE.updateDOM) {
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
          try {
            this._INSTANCE.updateDOM();
          } finally {
            ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
          }
        }
      }
    },

    _getDefaultValue: function (property, propertyMeta) {
      if (this._EXTENSION._CONSTRUCTOR) {
        // The defaults object contains metadata and dynamic defaults
        var defaults = ojdefaultsutils.DefaultsUtils.getDefaults(this._EXTENSION._CONSTRUCTOR, this.METADATA, false);
        return defaults[property];
      }
      return MetadataUtils.getDefaultValue(propertyMeta);
    }
  });
  oj._registerLegacyNamespaceProp('DefinitionElementBridge', DefinitionalElementBridge);

  /**
   * @ignore
   */
  class WidgetState extends ojcustomelementUtils.ElementState {
      /**
       * @override
       */
      IsTransferAttribute(attrName) {
          const bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this.Element);
          const transferAttrs = bridge._EXTENSION._GLOBAL_TRANSFER_ATTRS;
          return bridge._WIDGET_ELEM && transferAttrs && transferAttrs.includes(attrName);
      }
      /**
       * @override
       */
      GetDescriptiveTransferAttributeValue(name) {
          const bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this.Element);
          return bridge._WIDGET_ELEM.getAttribute(name);
      }
  }

  const CustomElementBridge = {};

  /**
   * Prototype for the JET component custom element bridge instance
   */
  CustomElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
  oj._registerLegacyNamespaceProp('CustomElementBridge', CustomElementBridge);

  const getFocusEventPropagator = function (element, type) {
    return function (event) {
      // Ensure that the target is the custom element, not the inner element, so create
      // a new event and dispatch on the custom element.
      element.dispatchEvent(new FocusEvent(type, { relatedTarget: event.relatedTarget }));
    };
  };

  const getTeardownFunction = function (element, focusPropagator, blurPropagator) {
    return function () {
      element.removeEventListener('focus', focusPropagator);
      element.removeEventListener('blur', blurPropagator);
    };
  };

  oj.CollectionUtils.copyInto(CustomElementBridge.proto, {
    // Provides a promise for JET's Knockout throttling timeout
    // when knockout is used for the component
    getThrottlePromise: function () {
      var throttlePromise = this.State.getBindingProviderPromise();
      throttlePromise = throttlePromise.then(function (bindingProvider) {
        return bindingProvider ? bindingProvider.__GetThrottlePromise() : null;
      });
      return throttlePromise;
    },

    AddComponentMethods: function (proto) {
      // Add subproperty getter/setter
      // eslint-disable-next-line no-param-reassign
      proto.setProperty = function (prop, value) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        if (!bridge.SaveEarlyPropertySet(this, prop, value)) {
          if (
            !bridge._setEventProperty(this, prop, value) &&
            !bridge._validateAndSetCopyProperty(this, prop, value, null)
          ) {
            // If not an event or copy property, check to see if it's a component specific property
            var meta = MetadataUtils.getPropertyMetadata(prop, ojcustomelementRegistry.getElementProperties(this));
            // For non component specific properties, just set directly on the element instead.
            if (!meta) {
              this[prop] = value;
            } else {
              bridge._setOption(prop, value, meta, this);
              bridge.State.dirtyProps.add(prop.split('.')[0]);
            }
          }
        }
      };
      // eslint-disable-next-line no-param-reassign
      proto.getProperty = function (prop) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        var meta = MetadataUtils.getPropertyMetadata(prop, ojcustomelementRegistry.getElementProperties(this));

        bridge._deliverPropertyUpdates(this);

        // For event listeners and non component specific properties, return the property from the element.
        // Otherwise, return the widget property and let the widget handle dot notation for subproperties.
        if (ojcustomelementUtils.AttributeUtils.isEventListenerProperty(prop) || !meta) {
          return this[prop];
        }

        var ext = meta ? meta.extension : null;

        if (ext && ext._COPY_TO_INNER_ELEM) {
          return bridge._getCopyProperty(this, prop, meta);
        }
        return CustomElementBridge._getPropertyAccessor(this, prop)();
      };
      // Override HTMLELement's focus/blur methods so we can call focus/blur on an inner element if needed.
      // eslint-disable-next-line no-param-reassign
      proto.focus = function () {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        // If focus is called before the component has been created there
        // will be no saved widget instance yet so call the HTMLElement
        // focus instead.
        if (bridge._WIDGET_INSTANCE) {
          var focusElem = bridge._WIDGET_INSTANCE.__getFocusElement();
          if (focusElem) {
            if (focusElem !== this) {
              focusElem.focus();
            } else {
              HTMLElement.prototype.focus.call(this);
            }
          }
        } else {
          HTMLElement.prototype.focus.call(this);
        }
      };
      // eslint-disable-next-line no-param-reassign
      proto.blur = function () {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        if (bridge._WIDGET_INSTANCE) {
          var focusElem = bridge._WIDGET_INSTANCE.__getFocusElement();
          if (focusElem) {
            if (focusElem !== this) {
              focusElem.blur();
            } else {
              HTMLElement.prototype.blur.call(this);
            }
          }
        } else {
          HTMLElement.prototype.blur.call(this);
        }
      };
    },

    BatchedPropertySet: function (elem, props) {
      var keys = Object.keys(props);
      var processedMap = {};
      var i;

      for (i = 0; i < keys.length; i++) {
        var property = keys[i];
        var value = props[property];

        // exclude event proprties and transfer attributes from batch updates
        if (
          !this._setEventProperty(elem, property, value) &&
          !this._validateAndSetCopyProperty(elem, property, value, null)
        ) {
          value = this.ValidatePropertySet(elem, property, value);

          property = this.GetAliasForProperty(property);
          processedMap[property] = value;
        }
      }
      // Skip batched property sets if widget constructor isn't available meaning
      // the widget wasn't instantiated due to an error on creation or destroyed.
      var widgetConstructor = Components.__GetWidgetConstructor(this._WIDGET_ELEM);
      if (widgetConstructor) {
        if (this._WIDGET_INSTANCE) {
          processedMap = this._WIDGET_INSTANCE._MergeOptionsWithDefaults(processedMap);
        }
        widgetConstructor('option', processedMap);
      } else {
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          elem.setProperty(key, props[key]);
        }
      }
    },

    CreateComponent: function (element) {
      var innerDomFun = this._INNER_DOM_FUNCTION;
      this._WIDGET_ELEM = CustomElementBridge._getWidgetElement(
        element,
        innerDomFun ? innerDomFun(element) : this._EXTENSION._INNER_ELEM
      );

      // Transfer global attributes and copy tagged properties to child element if one exists
      if (this._WIDGET_ELEM !== element) {
        var transferAttrs = this._EXTENSION._GLOBAL_TRANSFER_ATTRS || [];
        for (var i = 0; i < transferAttrs.length; i++) {
          var attr = transferAttrs[i];
          if (element.hasAttribute(attr)) {
            this._WIDGET_ELEM.setAttribute(attr, element.getAttribute(attr)); // @HTMLUpdateOK
            // Remove attribute from custom element after transfering value to inner element
            // Set a flag so we know that we're removing the attribute, not app so
            // that on attribute changed we don't remove it again
            this._removingTransfer = true;
            element.removeAttribute(attr);
          }
        }

        this._copyProperties();
      }

      ojcustomelementUtils.CustomElementUtils.unmarkPendingSubtreeHidden(element);

      // Initialize jQuery object with options and pass element as wrapper if needed
      var locator = $(this._WIDGET_ELEM);
      var widgetConstructor = $(this._WIDGET_ELEM)[this._EXTENSION._WIDGET_NAME].bind(locator);
      widgetConstructor(this._PROPS);
      this._WIDGET = widgetConstructor;
      this._WIDGET_INSTANCE = widgetConstructor('instance');

      if (this._WRITEBACK_PROPS) {
        this._WIDGET_INSTANCE.__saveWritebackOptions(this._WRITEBACK_PROPS);
      }

      // Setup blur/focus listeners on inner element so we can trigger on the root custom element for 
      this._setupFocusPropagation(element);
    },

    DefineMethodCallback: function (proto, method, methodMeta) {
      // eslint-disable-next-line no-param-reassign
      proto[method] = function () {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        var methodName = methodMeta.internalName || method;
        bridge._deliverPropertyUpdates(this);
        ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
        try {
          // Pass in null as thisArg to apply since the widget constructor is prebound to the jQuery element
          return bridge._WIDGET.apply(null, [methodName].concat([].slice.call(arguments)));
        } finally {
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
        }
      };
    },

    DefinePropertyCallback: function (proto, property, propertyMeta) {
      var ext = propertyMeta.extension;
      Object.defineProperty(proto, property, {
        enumerable: true,
        get: function () {
          var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
          bridge._deliverPropertyUpdates(this);
          if (propertyMeta._eventListener) {
            return bridge.GetEventListenerProperty(property);
          } else if (ext && ext._COPY_TO_INNER_ELEM) {
            return bridge._getCopyProperty(this, property, propertyMeta);
          }

          return CustomElementBridge._getPropertyAccessor(this, property)();
        },
        set: function (value) {
          const bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
          // Properties can be set before the component is created. These early
          // sets are actually saved until after component creation and played back.
          if (!bridge.SaveEarlyPropertySet(this, property, value)) {
            // eslint-disable-next-line no-param-reassign
            value = ojcustomelementUtils.transformPreactValue(this, property, propertyMeta, value);
            const state = ojcustomelementUtils.CustomElementUtils.getElementState(this);
            const bpType = state.getBindingProviderType();
            if (bpType === 'preact') {
              // Preact sends property updates one by one and
              // this might slow down collection components
              // that might fetch data more than once.
              // We want to accumulate the updates and send them together
              // as its done in knockout version.
              if (!this._isUpdateQueued) {
                this._isUpdateQueued = true;
                this._propertyUpdates = {};
                this._propertyUpdates[property] = value;
                window.queueMicrotask(() => {
                  bridge._deliverPropertyUpdates(this);
                });
              } else {
                this._propertyUpdates[property] = value;
              }
            } else if (propertyMeta._eventListener) {
              bridge.SetEventListenerProperty(this, property, value);
            } else if (!bridge._validateAndSetCopyProperty(this, property, value, propertyMeta)) {
              bridge._setOption(property, value, propertyMeta, this);
              bridge.State.dirtyProps.add(property);
            }
          }
        }
      });
      ojcustomelementUtils.addPrivatePropGetterSetters(proto, property);
    },

    GetAttributes: function (metadata) {
      var attrs = MetadataUtils.getFlattenedAttributes(metadata.properties);
      if (metadata.extension._GLOBAL_TRANSFER_ATTRS) {
        attrs = attrs.concat(metadata.extension._GLOBAL_TRANSFER_ATTRS);
      }
      // Private array based API to allow widget based components to specify any
      // additional attributes they want to get notified about, e.g. data-oj-input-id.
      // These attributes will get passed through to the widget via the
      // __handleWatchedAttribute method.
      if (metadata.extension._WATCHED_ATTRS) {
        attrs = attrs.concat(metadata.extension._WATCHED_ATTRS);
      }
      return attrs;
    },

    GetAliasForProperty: function (property) {
      // Aliasing only supported for top level properties
      var alias = this._EXTENSION._ALIASED_PROPS;
      if (alias && alias[property]) {
        return alias[property];
      }
      return property;
    },

    InitializeElement: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

      if (this._EXTENSION._CONTROLS_SUBTREE_HIDDEN) {
        ojcustomelementUtils.CustomElementUtils.markPendingSubtreeHidden(element);
      }

      oj.BaseCustomElementBridge.__InitProperties(element, this._PROPS);
    },

    HandleAttributeChanged: function (element, attr, oldValue, newValue) {
      var transferAttrs = this._EXTENSION._GLOBAL_TRANSFER_ATTRS;
      var bTransfer = transferAttrs && transferAttrs.indexOf(attr) !== -1;
      var watchedAttrs = this._EXTENSION._WATCHED_ATTRS;
      var bWatchedAttr = watchedAttrs && watchedAttrs.indexOf(attr) !== -1;
      if (bTransfer && this._WIDGET_ELEM) {
        if (!this._removingTransfer) {
          // When we transfer the attribute the app will not be able to remove the
          // attribute from the DOM, we will recommend binding the value if the value
          // needs to be toggled.
          this._WIDGET_ELEM.setAttribute(attr, newValue); // @HTMLUpdateOK
          // Remove attribute from custom element after transfering value to inner element
          // Set a flag so we know that we're removing the attribute, not app so
          // that on attribute changed we don't remove it again
          this._removingTransfer = true;
          element.removeAttribute(attr);
        } else if (this._removingTransfer) {
          this._removingTransfer = false;
        }
      } else if (bWatchedAttr && oldValue !== newValue && this._WIDGET_INSTANCE) {
        // Check to see if this is attribute is being watched by the component
        // in which case we will just pass this through as is without converting
        // the attribute to a property name. Components are responsible for retrieving
        // attribute values on component initialization. This method only handles changes
        // after the fact.
        this._WIDGET_INSTANCE.__handleWatchedAttribute(attr, oldValue, newValue);
      }
    },

    HandleDetached: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.HandleDetached.call(this, element);

      // Only call __handleDisconnected if the component hasn't previously
      // been destroyed which we can check by seeing if the widget constructor is null
      if (Components.__GetWidgetConstructor(this._WIDGET_ELEM) && this._WIDGET_INSTANCE) {
        this._WIDGET_INSTANCE.__handleDisconnected();
      }

      this._teardownFocusPropagation(element);
    },

    HandleReattached: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.HandleReattached.call(this, element);

      this._setupFocusPropagation(element);

      if (this._WIDGET_INSTANCE) {
        this._WIDGET_INSTANCE.__handleConnected();
      }
    },

    initializeBridge: function (element, descriptor) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.initializeBridge.call(this, element, descriptor);

      this._INNER_DOM_FUNCTION = descriptor.innerDomFunction;

      this._EXTENSION = this.METADATA.extension || {};

      this._PROPS =
        this._EXTENSION._INNER_ELEM || this._INNER_DOM_FUNCTION ? { _wrapper: element } : {};
      this._setupPropertyAccumulator(element, this._PROPS);

      // Checks metadata for copy and writeback properties
      this._processProperties(element);
    },

    /**
     * Sets an option value on the widget, handling default values when undefined is set.
     * @param {string} property
     * @param {any} value
     * @param {object} meta
     * @param {HTMLElement} element
     * @private
     */
    _setOption: function (property, value, meta, element) {
      // For widget based components, see if there is a default value assigned in the
      // metadata if application tries to unset the property. Property unsetting is only
      // supported for top level properties and not subproperties. For composites and
      // definitional elements, this is handled in the getter since the bridge handles
      // sets/gets, but for widget based components the bridge only calls through to the
      // widget code which initializes the component to the default value (which should match
      // the metadata default)
      let flags = {};
      if (value === undefined && property.indexOf('.') === -1) {
        flags = { _context: { skipEvent: true } };
        // eslint-disable-next-line no-param-reassign
        value = MetadataUtils.getDefaultValue(meta);
        // Usually the widget logic fires the property changed events, but in this case
        // the app has set undefined, but we're setting the default value on the widget so
        // we'll handle firing the property changed from the bridge code for this case
        // and skip the event in the widget code.
        if (this.State.isComplete()) {
          const previousValue = element[property];
          oj.BaseCustomElementBridge.__FirePropertyChangeEvent(
            element,
            property,
            undefined,
            previousValue,
            'external'
          );
        }
      }
      CustomElementBridge._getPropertyAccessor(element, property, flags)(value);
    },

    _copyProperties: function () {
      // Copies properties from the bridge _PROPS before the widget is instantiated
      // removing copied props from the object
      if (this._COPY_ATTRS) {
        for (var i = 0; i < this._COPY_ATTRS.length; i++) {
          var attr = this._COPY_ATTRS[i];
          var propName = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attr);
          if (Object.prototype.hasOwnProperty.call(this._PROPS, propName)) {
            var value = this._PROPS[propName];
            this._setCopyProperty(attr, value);
            // Delete the attribute we just copied from the options that we
            // instantiate the widget with
            delete this._PROPS[propName];
          }
        }
      }
    },

    // A method used to flush the queued properties at microtask or
    // when property getters or a component method is called
    // (a component method might rely on the updated properties).
    _deliverPropertyUpdates: function (element) {
      if (element._isUpdateQueued) {
        // eslint-disable-next-line no-param-reassign
        element._isUpdateQueued = false;
        try {
          this.SetProperties(element, element._propertyUpdates, true);
        } finally {
          // eslint-disable-next-line no-param-reassign
          element._propertyUpdates = undefined;
        }
      }
    },

    _getCopyProperty: function (elem, prop, propMeta) {
      var attrName = ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(prop);
      var ext = propMeta.extension;
      if (ext._ATTRIBUTE_ONLY) {
        if (this._WIDGET_ELEM.hasAttribute(attrName)) {
          var value = this._WIDGET_ELEM.getAttribute(attrName);
          return ojcustomelementUtils.AttributeUtils.attributeToPropertyValue(elem, attrName, value, propMeta);
        }
        return null;
      }
      return this._WIDGET_ELEM[prop];
    },

    _processProperties: function (element) {
      var props = ojcustomelementRegistry.getElementProperties(element);
      if (props) {
        var propKeys = Object.keys(props);
        for (var i = 0; i < propKeys.length; i++) {
          var propName = propKeys[i];
          var propMeta = props[propName];
          // Store writeback properties on the bridge and set on widget when we instantiate it later
          if (propMeta.writeback) {
            if (!this._WRITEBACK_PROPS) {
              this._WRITEBACK_PROPS = {};
            }
            this._WRITEBACK_PROPS[propName] = true;
          }
          // Store properties to copy to inner element for easy lookup
          var ext = propMeta.extension;
          if (ext && ext._COPY_TO_INNER_ELEM) {
            if (!this._COPY_ATTRS) {
              this._COPY_ATTRS = [];
            }
            this._COPY_ATTRS.push(propName);
          }
        }
      }
    },

    _setCopyProperty: function (attribute, value) {
      if (value == null || value === false) {
        this._WIDGET_ELEM.removeAttribute(attribute);
      } else if (value === true) {
        this._WIDGET_ELEM.setAttribute(attribute, ''); // @HTMLUpdateOK
      } else {
        this._WIDGET_ELEM.setAttribute(attribute, value); // @HTMLUpdateOK
      }
    },

    _setupPropertyAccumulator: function (element, widgetOptions) {
      // Add an element function that will track property values until expressions are all evaluated.
      // This object will be replaced with the actual widget constructor.
      this._WIDGET = function (method, prop, value) {
        // Allow property access before widget is created for element binding and dynamic element creation
        if (method === 'option') {
          if (arguments.length > 2) {
            // option set case
            oj.BaseCustomElementBridge.__SetProperty(
              this.GetAliasForProperty.bind(this),
              widgetOptions,
              prop,
              value
            );
          }
          return widgetOptions[prop];
        }

        // throw is eslint hack to fix consistent-return
        throw new ojcustomelementUtils.JetElementError(element, 'Cannot access methods before element is upgraded.');
      };
    },

    _validateAndSetCopyProperty: function (elem, prop, value, propMeta) {
      // propMeta is could be null so we should retrieve it if not passed in

      var attrName = ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(prop);
      var isCopy = this._COPY_ATTRS && this._COPY_ATTRS.indexOf(attrName) !== -1;
      // If widget hasn't been instantiated skip setting until CreateComponent
      if (isCopy) {
        // We need to validate the value so that we don't copy an invalid value.
        // eslint-disable-next-line no-param-reassign
        value = this.ValidatePropertySet(elem, prop, value);

        if (this._WIDGET_ELEM) {
          if (!propMeta) {
            // eslint-disable-next-line no-param-reassign
            propMeta = MetadataUtils.getPropertyMetadata(prop, ojcustomelementRegistry.getElementProperties(elem));
          }

          var previousValue = this._getCopyProperty(elem, prop, propMeta);
          this._setCopyProperty(attrName, value);
          // Fire a property change event for the copy properties since we don't actually pass
          // these to the widget. The widget will never update these properties themselves so
          // all updates are external.
          oj.BaseCustomElementBridge.__FirePropertyChangeEvent(
            elem,
            prop,
            this._getCopyProperty(elem, prop, propMeta),
            previousValue,
            'external'
          );
        } else {
          // Save the value until inner widget is created and we can copy them over
          this._PROPS[attrName] = value;
        }
      }
      return isCopy;
    },

    _setEventProperty: function (elem, prop, value) {
      var isEvent = ojcustomelementUtils.AttributeUtils.isEventListenerProperty(prop);
      if (isEvent) {
        // eslint-disable-next-line no-param-reassign
        elem[prop] = value;
      }
      return isEvent;
    },

    _setupFocusPropagation: function (element) {
      // Setup blur/focus listeners on inner element so we can trigger on the root custom element for 
      const focusElem = this._WIDGET_INSTANCE.__getFocusElement();
      if (focusElem && focusElem !== element) {
        const focusPropagator = getFocusEventPropagator(element, 'focus');
        const blurPropagator = getFocusEventPropagator(element, 'blur');
        focusElem.addEventListener('focus', focusPropagator);
        focusElem.addEventListener('blur', blurPropagator);
        this._teardownFocus = getTeardownFunction(focusElem, focusPropagator, blurPropagator);
      }
    },

    _teardownFocusPropagation: function () {
      if (this._teardownFocus) {
        this._teardownFocus();
        this._teardownFocus = null;
      }
    }
  });

  /** ***********************/
  /* PUBLIC STATIC METHODS */
  /** ***********************/

  /**
   * Returns the metadata object for the given component.
   * @param  {string} tagName        The component tag name
   * @return {Object}                The component metadata object
   * @ignore
   */
  CustomElementBridge.getMetadata = function (tagName) {
    return CustomElementBridge._METADATA_MAP[tagName.toLowerCase()];
  };

  /**
   * Checks whether the specified event type was declared in the metadata for this custom element
   * @param {Element} element the custom element
   * @param {string} type the event type (e.g. "beforeExpand")
   * @return {boolean} true if the event type was declared in the metadata, false otherwise
   * @ignore
   */
  CustomElementBridge.isKnownEvent = function (element, type) {
    var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    return (bridge.METADATA.events && bridge.METADATA.events[type]) != null;
  };

  /**
   * Checks whether the specified property was declared in the metadata for this custom element
   * @param {Element} element the custom element
   * @param {string} prop the property name (e.g. "selection")
   * @return {boolean} true if the property was declared in the metadata, false otherwise
   * @ignore
   */
  CustomElementBridge.isKnownProperty = function (element, prop) {
    var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    return (bridge.METADATA.properties && bridge.METADATA.properties[prop]) != null;
  };

  /**
   * Returns the custom element property for a given aliased component property which can be used
   * for converting an internal optionChange event, e.g. returning readonly for oj-switch's readOnly
   * property so we can fire a readonly-changed event instead of readOnly-changed.
   * Will return the original property if there is no aliasing.
   * @param {Element} element The custom element
   * @param {string} property The component property
   * @return {string}
   * @ignore
   */
  CustomElementBridge.getPropertyForAlias = function (element, property) {
    // Aliasing only supported for top level properties
    var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    var alias = bridge._EXTENSION._COMPONENT_TO_ELEMENT_ALIASES;
    if (alias && alias[property]) {
      return alias[property];
    }
    return property;
  };

  /**
   * Registers a component as a custom element.
   * @param {string} tagName The component tag name (all lower case), which should contain a dash '-' and not be a reserved tag name.
   * @param {Object} descriptor The registration descriptor. The descriptor will contain keys for metadata and other component overrides.
   * @param {Object} descriptor.metadata The JSON object containing info like the widget name, whether component has an inner element, an outer wrapper, and the component metadata.
   * @param {function(string, string, Object, function(string))} descriptor.parseFunction The function that will be called to parse attribute values.
   * Note that this function is only called for non bound attributes. The parseFunction will take the following parameters:
   * <ul>
   *  <li>{string} value: The value to parse.</li>
   *  <li>{string} name: The name of the attribute.</li>
   *  <li>{Object} meta: The metadata object for the property which can include its type, default value,
   *      and any extensions that the composite has provided on top of the required metadata.</li>
   *  <li>{function(string)} defaultParseFunction: The default parse function for the given attribute
   *      type which is used when a custom parse function isn't provided and takes as its parameters
   *      the value to parse.</li>
   * </ul>
   * @param {Element} descriptor.innerDomFunction The function that will be called to return the tag name of the inner DOM element, e.g. 'button' or 'a'
   * The innerDomFunction will take the following parameters:
   * <ul>
   *  <li>{Element} element: The component custom element.</li>
   * </ul>
   * @ignore
   */
  CustomElementBridge.register = function (tagName, descriptor) {
    var meta = descriptor[oj.BaseCustomElementBridge.DESC_KEY_META];
    meta = oj.BaseCustomElementBridge.__ProcessEventListeners(meta);
    // eslint-disable-next-line no-param-reassign
    descriptor[oj.BaseCustomElementBridge.DESC_KEY_META] = meta;
    CustomElementBridge._METADATA_MAP[tagName.toLowerCase()] = meta;

    var ext = meta.extension;
    // Use the simple definitional element prototype if no real widget is associated with this custom element
    var bridgeProto =
      ext && ext._WIDGET_NAME ? CustomElementBridge.proto : DefinitionalElementBridge.proto;
    const stateClass = ext && ext._WIDGET_NAME ? WidgetState : ojcustomelementUtils.ElementState;

    // Create component to element property alias mapping for easy optionChange lookup and stash it in the extension object
    var aliasMap = ext._ALIASED_PROPS;
    if (aliasMap) {
      ext._COMPONENT_TO_ELEMENT_ALIASES = {};
      var aliases = Object.keys(aliasMap);
      aliases.forEach(function (alias) {
        ext._COMPONENT_TO_ELEMENT_ALIASES[aliasMap[alias]] = alias;
      });
    }

    const registration = { descriptor, bridgeProto, stateClass };
    ojcustomelementRegistry.registerElement(tagName, registration, bridgeProto.getClass(descriptor));
  };

  /** ***************************/
  /* NON PUBLIC STATIC METHODS */
  /** ***************************/

  /**
   * Returns a property accessor for setting/getting options
   * @private
   */
  CustomElementBridge._getPropertyAccessor = function (element, property, flags) {
    function optionAccessor(value) {
      var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
      // option set case
      if (arguments.length === 1) {
        // eslint-disable-next-line no-param-reassign
        value = bridge.ValidatePropertySet(element, property, value);
        // eslint-disable-next-line no-param-reassign
        property = bridge.GetAliasForProperty(property);
        bridge._WIDGET('option', property, value, flags);
        return undefined;
      }
      // option get case
      // eslint-disable-next-line no-param-reassign
      property = bridge.GetAliasForProperty(property);
      return bridge._WIDGET('option', property);
    }

    return optionAccessor.bind(element);
  };

  /**
   * Returns the element that the widget constructor will be instantiated on which can be the custom element or a child element.
   * @private
   */
  CustomElementBridge._getWidgetElement = function (element, innerTagName) {
    // If component widget is bound to an inner child element like <ul> for <oj-list-view>,
    // create one only if the application does not provide it.
    var widgetElem = element;
    if (innerTagName) {
      var firstChild = element.firstElementChild;
      if (firstChild && firstChild.tagName.toLowerCase() === innerTagName) {
        widgetElem = firstChild;
      } else {
        widgetElem = document.createElement(innerTagName); // @HTMLUpdateOK
        // Make a copy of the custom element children before appending the inner element
        var children = [];
        var nodeList = element.childNodes;
        for (var i = 0; i < nodeList.length; i++) {
          children.push(nodeList[i]);
        }

        element.appendChild(widgetElem); // @HTMLUpdateOK
        // If we create the inner child element, check to see if there are any children
        // to move like for <oj-button> which can have a child elements that should be moved to
        // the newly created inner <button> element.
        while (children.length) {
          var child = children.shift();
          // Only move default slot children to inner child element. Default slot children are those
          // that do not explictly set a slot attribute (or have one passed from a composite) or have slot=''.
          // The component will be responsible for moving all named slot children.
          // For example, it does not make sense for <oj-list-view> to move contextMenu slot to its inner <ul> element.
          if (!ojcustomelementUtils.CustomElementUtils.getSlotAssignment(child)) {
            widgetElem.appendChild(child);
          }
        }
      }
      // add data-oj-internal attribute for automation tests
      widgetElem.setAttribute('data-oj-internal', '');
    }
    return widgetElem;
  };

  /**
   * Map of registered custom element names
   * @private
   */
  CustomElementBridge._METADATA_MAP = {};

  /**
   * @private
   */
  var _OJ_TRANSLATIONS_OPTION = 'translations';

  /**
   * @private
   */
  var _OJ_TRANSLATIONS_PREFIX = _OJ_TRANSLATIONS_OPTION + '.';

  /**
   * @private
   */
  const _DISABLED = 'oj-disabled';

  /**
   * @private
   */
  const _START_BOTTOM = 'start bottom';

  /**
   * @private
   */
  var _OJ_COMPONENT_EVENT_OVERRIDES = {
    isDefaultPrevented: function () {
      return false;
    },
    preventDefault: function () {
      this.isDefaultPrevented = _returnTrue;
    },
    stopPropagation: function () {
      this.isPropagationStopped = _returnTrue;
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = _returnTrue;
    }
  };

  (function () {
    // BaseComponent wrapper function, to keep "private static members" private
    /**
     * @private
     */
    var _BASE_COMPONENT = 'baseComponent';
    var _STATE_CONNECTED = 0;
    var _STATE_DISCONNECTED = 1;

    // -----------------------------------------------------------------------------
    // "private static members" shared by all components
    // -----------------------------------------------------------------------------

    var _lastActiveElement;

    /**
     * @ojcomponent oj.baseComponent
     * @abstract
     * @since 0.6.0
     */
    $.widget('oj.' + _BASE_COMPONENT, {
      options: {
        /**
         * <p>There is no restriction on the order in which the JET Menu and the referencing component are initialized.  However, when specifying
         * the Menu via the HTML attribute, the referenced DOM element must be in the document at the time that the referencing component is
         * initialized.
         *
         * @ojfragment contextMenuInitOrderDoc - Decomped to fragment so Tabs, Tree, and MasonryLayout can override the fragment to convey their init order restrictions.
         * @memberof oj.baseComponent
         */
        /**
         * <p>To help determine whether it's appropriate to cancel the launch or customize the menu, the <code class="prettyprint">beforeOpen</code>
         * listener can use component API's to determine which table cell, chart item, etc., is the target of the context menu. See the JSDoc and
         * demos of the individual components for details.  Keep in mind that any such logic must work whether the context menu was launched via right-click,
         * <kbd>Shift-F10</kbd>, <kbd>Press & Hold</kbd>, or component-specific touch gesture.
         *
         * @ojfragment contextMenuTargetDoc - Decomped to fragment so components can override the fragment to convey their specific API's for this.
         * @memberof oj.baseComponent
         */
        /**
         * <p>Identifies the [JET Menu]{@link oj.ojMenu} that the component should launch as a context menu on right-click, <kbd>Shift-F10</kbd>, <kbd>Press & Hold</kbd>,
         * or component-specific gesture. If specified, the browser's native context menu will be replaced by the specified JET Menu.
         *
         * <p>The value can be an HTML element, JQ selector, JQ object, NodeList, or array of elements.  In all cases, the first indicated element is used.
         *
         * <p>To specify a JET context menu on a DOM element that is not a JET component, see the <code class="prettyprint">ojContextMenu</code> binding.
         *
         * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the context menu via the standard
         * HTML5 syntax shown in the below example.  When the component is initialized, the context menu thus specified will be set on the component.
         *
         * {@ojinclude "name":"contextMenuInitOrderDoc"}
         *
         * <p>After create time, the <code class="prettyprint">contextMenu</code> option should be set via this API, not by setting the DOM attribute.
         *
         * <p>The application can register a listener for the Menu's [beforeOpen]{@link oj.ojMenu#event:beforeOpen} event.  The listener can cancel the
         * launch via <code class="prettyprint">event.preventDefault()</code>, or it can customize the menu contents by editing the menu DOM directly,
         * and then calling [refresh()]{@link oj.ojMenu#refresh} on the Menu.
         *
         * {@ojinclude "name":"contextMenuTargetDoc"}
         *
         * @ojfragment contextMenuDoc - Decomped to fragment so subclasses can extend the verbiage as needed, by ojinclude'ing this fragment and then adding their own verbiage.
         * @memberof oj.baseComponent
         */
        /**
         * {@ojinclude "name":"contextMenuDoc"}
         *
         * @ignore
         * @expose
         * @memberof oj.baseComponent
         * @instance
         * @type {Element|Array.<Element>|string|jQuery|NodeList}
         * @default <code class="prettyprint">null</code>
         *
         * @example <caption>Initialize a JET component with a context menu:</caption>
         * // via recommended HTML5 syntax:
         * &lt;div id="myComponent" contextmenu="myMenu" data-bind="ojComponent: { ... }>
         *
         * // via JET initializer (less preferred) :
         * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
         * $( ".selector" ).ojFoo({ "contextMenu": "#myMenu" });
         *
         * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option, after initialization:</caption>
         * // getter
         * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
         * var menu = $( ".selector" ).ojFoo( "option", "contextMenu" );
         *
         * // setter
         * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
         * $( ".selector" ).ojFoo( "option", "contextMenu", ".my-marker-class" );
         *
         * @example <caption>Set a JET context menu on an ordinary HTML element:</caption>
         * &lt;a href="#" id="myAnchor" contextmenu="myMenu" data-bind="ojContextMenu: {}">Some text</a>
         */
        contextMenu: null,

        /**
         * <p>Attributes specified here will be set on the component's root DOM element at creation time.
         * This is particularly useful for components like Dialog that wrap themselves in a new root element
         * at creation time.
         *
         * <p>The supported attributes are <code class="prettyprint">id</code>, which overwrites any existing value,
         * and <code class="prettyprint">class</code> and <code class="prettyprint">style</code>, which are appended
         * to the current class and style, if any.
         *
         * <p>Setting this option after component creation has no effect.  At that time, the root element already
         * exists, and can be accessed directly via the <code class="prettyprint">widget</code> method, per the second example below.
         *
         * @example <caption>Initialize a JET component, specifying a set of attributes to be set
         * on the component's root DOM element:</caption>
         * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
         * $( ".selector" ).ojFoo({ "rootAttributes": {
         *   "id": "myId",
         *   "style": "max-width:100%; color:blue;",
         *   "class": "my-class"
         * }});
         *
         * @example <caption>After initialization, <code class="prettyprint">rootAttributes</code> should not be used.  It is
         * not needed at that time, as attributes of the root DOM element can simply be set directly, using
         * <code class="prettyprint">widget</code>:</caption>
         * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
         * $( ".selector" ).ojFoo( "widget" ).css( "height", "100px" );
         * $( ".selector" ).ojFoo( "widget" ).addClass( "my-class" );
         *
         * @ignore
         * @expose
         * @memberof oj.baseComponent
         * @instance
         * @type {?Object}
         * @default <code class="prettyprint">null</code>
         */
        rootAttributes: null,

        /**
         * <p>A collection of translated resources from the translation bundle, or <code class="prettyprint">null</code> if this
         * component has no resources.  Resources may be accessed and overridden individually or collectively, as seen in the examples.
         *
         * <p> If the component does not contain any translatable resource, the default value of this attribute will be
         * <code class="prettyprint">null</code>. If not, an object containing all resources relevant to the component.
         *
         * <p>If this component has translations, their documentation immediately follows this doc entry.
         *
         * @member
         * @name translations
         * @ojshortdesc A collection of translated resources from the translation bundle, or null if this component has no resources.
         * @memberof oj.baseComponent
         * @instance
         * @ojtranslatable
         * @type {object|null}
         *
         *
         * @example <caption>Initialize the component, overriding some translated resources and leaving the others intact:</caption>
         * &lt;!-- Using dot notation -->
         * &lt;oj-some-element translations.some-key='some value' translations.some-other-key='some other value'>&lt;/oj-some-element>
         *
         * &lt;!-- Using JSON notation -->
         * &lt;oj-some-element translations='{"someKey":"some value", "someOtherKey":"some other value"}'>&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">translations</code> property after initialization:</caption>
         * // Get one
         * var value = myComponent.translations.someKey;
         *
         * // Set one, leaving the others intact. Always use the setProperty API for
         * // subproperties rather than setting a subproperty directly.
         * myComponent.setProperty('translations.someKey', 'some value');
         *
         * // Get all
         * var values = myComponent.translations;
         *
         * // Set all.  Must list every resource key, as those not listed are lost.
         * myComponent.translations = {
         *     someKey: 'some value',
         *     someOtherKey: 'some other value'
         * };
         *
         */
        // translations property is initialized programmatically, so this top-level API doc lives in this virtual comment.
        // Translations for all components are listed and JSDoc'ed in rt\src\main\resources\nls\root\ojtranslations.js.
        // That JSDoc appears in the same generated doc page as this top-level doc.

        // Events
        /**
         * Fired whenever a supported component option changes, whether due to user interaction or programmatic
         * intervention.  If the new value is the same as the previous value, no event will be fired.  The event
         * listener will receive two parameters described below:
         *
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui event payload
         * @property {string} ui.option the name of the option that changed.
         * @property {Object} ui.previousValue - an Object holding the previous value of the option.
         * When previousValue is not a primitive type, i.e., is an Object, it may hold the same value as
         * the value property.
         * @property {Object} ui.value - an Object holding the current value of the option.
         * @property {?Object} ui.subproperty - an Object holding information about the subproperty that changed.
         * @property {string} ui.subproperty.path - the subproperty path that changed.
         * @property {Object} ui.subproperty.previousValue - an Object holding the previous value of the subproperty.
         * @property {Object} ui.subproperty.value - an Object holding the current value of the subproperty.
         * @property {Object} ui.optionMetadata information about the option that changed
         * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
         *  <code class="prettyprint">"shouldNotWrite"</code>. For use by the JET writeback mechanism;
         *  'shouldWrite' indicates that the value should be written to the observable.
         *
         * @example <caption>Initialize component with the <code class="prettyprint">optionChange</code> callback</caption>
         * // Foo is Button, InputText, etc.
         * $(".selector").ojFoo({
         *   'optionChange': function (event, ui) {}
         * });
         * @example <caption>Bind an event listener to the ojoptionchange event</caption>
         * $(".selector").on({
         *   'ojoptionchange': function (event, ui) {
         *       // verify that the component firing the event is a component of interest
         *       if ($(event.target).is(".mySelector")) {
         *           window.console.log("option that changed is: " + ui['option']);
         *       }
         *   };
         * });
         *
         * @ignore
         * @memberof oj.baseComponent
         * @expose
         * @event
         * @instance
         */
        optionChange: undefined,

        /**
         * <p>Triggered before the component is destroyed. This event cannot be canceled; the
         * component will always be destroyed regardless.
         *
         * @example <caption>Initialize component with the <code class="prettyprint">destroy</code> callback</caption>
         * // Foo is Button, InputText, etc.
         * $(".selector").ojFoo({
         *   'destroy': function (event, data) {}
         * });
         * @example <caption>Bind an event listener to the destroy event</caption>
         * $(".selector").on({
         *   'ojdestroy': function (event, data) {
         *       // verify that the component firing the event is a component of interest
         *       if ($(event.target).is(".mySelector")) {
         *           window.console.log("The DOM node id for the destroyed component is : %s", event.target.id);
         *       }
         *   };
         * });
         *
         * @ignore
         * @memberof oj.baseComponent
         * @expose
         * @event
         * @instance
         */
        destroy: undefined
      },

      // TODO: flesh out JSDoc verbiage, re: call after dom changes underneath component...
      /**
       * Refreshes the component.
       * @return {void}
       * @expose
       * @memberof oj.baseComponent
       * @instance
       */
      refresh: function () {
        this._propertyContext = null;
        // if application sets the context menu after initialization, it must refresh the component
        this._SetupContextMenu();
      },

      /**
       * <p>Overridden to save off component's default options and the options passed into the constructor (to be passed into
       * the _InitOptions() call).
       *
       * <p>This method is final. Components should instead override one or more of the overridable create-time methods
       * listed in <a href="#_ComponentCreate">_ComponentCreate</a>.
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       * @final
       */
      _createWidget: function (options, element) {
        // Save wrapper element
        if (options) {
          this.OuterWrapper = options._wrapper;
        }

        // There is no need to clone these objects since they are not modified by the _createWidget() in the base class
        this._originalDefaults = this.options || {};
        this._constructorOptions = options || {};

        this._super(options, element);
        this._AfterCreateEvent();
      },

      /**
       * <p>Reads the <code class="prettyprint">rootAttributes</code> option, and sets the root attributes on the
       * component's root DOM element.  See <a href="#rootAttributes">rootAttributes</a> for the set of supported
       * attributes and how they are handled.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @throws if unsupported attributes are supplied.
       */
      _SetRootAttributes: function () {
        var value = this.options.rootAttributes;
        if (value) {
          var widget = this.widget();
          if (widget == null) {
            return;
          }

          var classValue = value.class;

          if (classValue) {
            widget.addClass(classValue);
          }

          var styleValue = value.style;

          if (styleValue) {
            Logger.error(`The rootAttributes.style option violates the recommended
          Content Security Policy which disallows inline styles and is therefore ignored.
          Use the rootAttributes.class option instead.`);
          }

          // make shallow copy, remove class and style from the copy, and set all
          // remaining attrs on the element.  Currently id is the only remaining attr
          // that we support.
          value = $.extend({}, value);
          delete value.class;
          delete value.style;

          widget.attr(value);

          delete value.id; // remove the remaining supported value
          var unsupportedAttrs = Object.keys(value);
          if (unsupportedAttrs.length) {
            throw new Error(
              'Unsupported values passed to rootAttributes option: ' + unsupportedAttrs.toString()
            );
          }
        }
      },

      /**
       * <p>This method is final in JET. Components should instead override one or more of the overridable create-time methods
       * listed in <a href="#_ComponentCreate">_ComponentCreate</a>.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @final
       */
      _create: function () {
        this._SaveAttributes(this.element);
        this._InitOptions(this._originalDefaults, this._constructorOptions);

        // We no longer need _constructorOptions, but retain _originalDefaults for _MergeOptionsWithDefaults
        delete this._constructorOptions;

        this._ComponentCreate();
        this._AfterCreate();

        // allow subcomponent to setup needed resources
        // after the component is created.
        this._SetupResources();

        // Marker class for all JET components on the init node (as opposed to the outer node)
        // This marker class is used to:
        // 1) find all JET components within a subtree
        // 2) to prevent FOUC:  init nodes NOT yet having this class are hidden.
        this.element.addClass(_OJ_COMPONENT_NODE_CLASS);
      },

      /**
       * <p>This method is not used in JET. Components should instead override <a href="#_InitOptions">_InitOptions</a>.
       *
       * @method
       * @name oj.baseComponent#_getCreateOptions
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @final
       */

      /**
       * <p>This method is called before <a href="#_ComponentCreate">_ComponentCreate</a>, at which point
       * the component has not yet been rendered.  Component options should be initialized in this method,
       * so that their final values are in place when <a href="#_ComponentCreate">_ComponentCreate</a> is called.
       *
       * <p>This includes getting option values from the DOM, where applicable, and coercing option
       * values (however derived) to their appropriate data type if needed.
       *
       * <p>No work other than setting options should be done in this method.  In particular, nothing should be
       * set on the DOM until <a href="#_ComponentCreate">_ComponentCreate</a>, e.g. setting the <code class="prettyprint">disabled</code>
       * DOM attribute from the <code class="prettyprint">disabled</code> option.
       *
       * <p>A given option (like <code class="prettyprint">disabled</code>) appears in the <code class="prettyprint">constructorOptions</code>
       * param iff the app set it in the constructor:
       *
       * <ul>
       *   <li>If it appears in <code class="prettyprint">constructorOptions</code>, it should win over what's in the DOM
       *     (e.g. <code class="prettyprint">disabled</code> DOM attribute).  If for some reason you need to tweak the value
       *     that the app set, then enable writeback when doing so:
       *     <code class="prettyprint">this.option('foo', bar, {'_context': {writeback: true, internalSet: true}})</code>.</li>
       *   <li>If it doesn't appear in <code class="prettyprint">constructorOptions</code>, then that option definitely is not bound,
       *     so writeback is not needed.  So if you need to set the option (e.g. from a DOM attribute), use
       *     <code class="prettyprint">this.option('foo', bar, {'_context': {internalSet: true}})</code>.</li>
       * </ul>
       *
       * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
       *
       * @param {!Object} originalDefaults - original default options defined on the component and its ancestors
       * @param {?Object} constructorOptions - options passed into the widget constructor
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        this._setupDefaultOptions(originalDefaults, constructorOptions);
        this._initContextMenuOption(constructorOptions);
      },

      /**
       * <p>All component create-time initialization lives in this method, except the logic that specifically
       * needs to live in <a href="#_InitOptions">_InitOptions</a>, <a href="#_AfterCreate">_AfterCreate</a>,
       * or <a href="#_AfterCreateEvent">_AfterCreateEvent</a>,
       * per the documentation for those methods.  All DOM creation must happen here, since the intent of
       * <a href="#_AfterCreate">_AfterCreate</a>, which is called next, is to contain superclass logic that must
       * run after that DOM is created.
       *
       * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
       *
       * <p>Summary of create-time methods that components can override, in the order that they are called:
       *
       * <ol>
       *   <li><a href="#_InitOptions">_InitOptions</a></li>
       *   <li><a href="#_ComponentCreate">_ComponentCreate</a> (this method)</li>
       *   <li><a href="#_AfterCreate">_AfterCreate</a></li>
       *   <li>(The <code class="prettyprint">create</code> event is fired here.)</li>
       *   <li><a href="#_AfterCreateEvent">_AfterCreateEvent</a></li>
       * </ol>
       *
       * <p>For all of these methods, the contract is that overrides must call <code class="prettyprint">this._super</code> <i>first</i>, so e.g., the
       * <code class="prettyprint">_ComponentCreate</code> entry means <code class="prettyprint">baseComponent._ComponentCreate</code>,
       * then <code class="prettyprint">_ComponentCreate</code> in any intermediate subclasses, then
       * <code class="prettyprint">_ComponentCreate</code> in the leaf subclass.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _ComponentCreate: function () {
        // Store widget name, so that oj.Components.__GetWidgetConstructor() can get widget from the element
        _storeWidgetName(this.element, this.widgetName);

        // namespace facilitates removing activeable and hoverable handlers handlers separately
        this.activeableEventNamespace = this.eventNamespace + 'activeable';
        this.hoverableEventNamespace = this.eventNamespace + 'hoverable';
      },

      /**
       * <p>This method is called after <a href="#_ComponentCreate">_ComponentCreate</a>, but before the
       * <code class="prettyprint">create</code> event is fired.  The JET base component does
       * tasks here that must happen after the component (subclass) has created itself in its override of
       * <a href="#_ComponentCreate">_ComponentCreate</a>.  Notably, the base component handles the
       * <a href="#rootAttributes">rootAttributes</a> and <a href="#contextMenu">contextMenu</a> options here,
       * since those options operate on the component root node, which for some components is created in their override
       * of <a href="#_ComponentCreate">_ComponentCreate</a>.
       *
       * <p>Subclasses should override this method only if they have tasks that must happen after a superclass's
       * implementation of this method, e.g. tasks that must happen after the context menu is set on the component.
       *
       * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _AfterCreate: function () {
        this._SetRootAttributes(); // do first, since has no dependencies, but other stuff might care about these attrs

        // namespace facilitates removing contextMenu handlers separately, if app clears the "contextMenu" option
        this.contextMenuEventNamespace = this.eventNamespace + 'contextMenu';
        // same for activeable and hoverable handlers
        this.activeableEventNamespace = this.eventNamespace + 'activeable';
        this.hoverableEventNamespace = this.eventNamespace + 'hoverable';
      },

      /**
       * <p>This method is called after the <code class="prettyprint">create</code> event is fired.
       * Components usually should not override this method, as it is rarely correct to wait until after the
       * <code class="prettyprint">create</code> event to perform a create-time task.
       *
       * <p>An example of a correct usage of this method is [Dialog's auto-open behavior]{@link oj.ojDialog#initialVisibility},
       * which needs to happen after the <code class="prettyprint">create</code> event.
       *
       * <p>Only <i>behaviors</i> (like Dialog auto-open behavior) should occur in this method.  Component <i>initialization</i>
       * must occur earlier, before the <code class="prettyprint">create</code> event is fired, so that
       * <code class="prettyprint">create</code> listeners see a fully inited component.
       *
       * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
       *
       * <p>Do not confuse this method with the <a href="#_AfterCreate">_AfterCreate</a> method, which is more commonly used.
       *
       * @method
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _AfterCreateEvent: $.noop,

      /**
       * <p>JET components should almost never implement this JQUI method.  Please consult an architect if you believe you have an exception.  Reasons:
       * <ul>
       *   <li>This method is called at create time, after the <code class="prettyprint">create</code> event is fired.  It is rare
       *       for that to be the appropriate time to perform a create-time task.  For those rare cases, we have the
       *       <a href="#_AfterCreateEvent">_AfterCreateEvent</a> method, which is preferred over this method since it is called only
       *       at that time, not also at re-init time (see next).</li>
       *   <li>This method is also called at "re-init" time, i.e. when the initializer is called after the component has already been created.
       *       JET has not yet identified any desired semantics for re-initing a component.</li>
       * </ul>
       *
       * @method
       * @name oj.baseComponent#_init
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */

      //  - remove JQUI memory leaks and CSS cruft introduced in 1.12 and 1.12.1
      _setOptionClasses: function () {},
      _setOptionDisabled: function () {},
      _classes: function () {
        return '';
      },
      _removeClass: function () {
        return this;
      },
      _addClass: function () {
        return this;
      },
      _toggleClass: function () {
        return this;
      },

      /**
       * <p>Saves the element's attributes. This is called during _create.
       * <a href="#_RestoreAttributes">_RestoreAttributes</a> will restore all these attributes
       * and is called during _destroy.
       * </p>
       * <p> This base class default implementation does nothing.
       * </p>
       * <p>We also have <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and
       * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> methods
       *  that save and restore <i>all</i> the attributes on an element.
       *  Component subclasses can opt into these _SaveAllAttributes/_RestoreAllAttributes
       *  implementations by overriding _SaveAttributes and _RestoreAttributes to call
       *  _SaveAllAttributes/_RestoreAllAttributes. If the subclass wants a different implementation
       *  (like save only the 'class' attribute), it can provide the implementation itself in
       *  _SaveAttributes/_RestoreAttributes.
       *
       *
       * @param {Object} element - jQuery selection to save attributes for
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      _SaveAttributes: function (element) {
        // default implementation does nothing.
      },
      /**
       * <p>Saves all the element's attributes within an internal variable.
       * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> will restore the attributes
       * from this internal variable.</p>
       * <p>
       * This method is final in JET.
       * Subclasses can override _RestoreAttributes and call _RestoreAllAttributes.
       * </p>
       *
       * <p>The JSON variable will be held as:
       *
       * <pre class="prettyprint">
       * <code>[
       *   {
       *   "element" : element[i],
       *   "attributes" :
       *     {
       *       attributes[m]["name"] : {"attr": attributes[m]["value"]
       *     }
       *   }
       * ]
       * </code></pre>
       *
       * @param {Object} element - jQuery selection to save attributes for
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @final
       */
      _SaveAllAttributes: function (element) {
        var self = this;
        this._savedAttributes = [];

        $.each(element, function (index, ele) {
          // need to be able to save for multiple elements
          var saveAttributes = {};
          var save = { element: ele, attributes: saveAttributes };
          var attributes = ele.attributes;

          self._savedAttributes.push(save);

          $.each(attributes, function (index2, attr) {
            // for proper access certain so called attributes should be accessed as properties
            // [i.e. required, disabled] so fetch them initially
            var attrName = attr.name;

            saveAttributes[attrName] = { attr: attr.value };
          });
        });
      },

      /**
       * <p>Gets the saved attributes for the provided element.
       *
       * <p>If you don't override <a href="#_SaveAttributes">_SaveAttributes</a> and
       * <a href="#_RestoreAttributes">_RestoreAttributes</a>, then this will return null.
       * <p>If you override _SaveAttributes to call <a href="#_SaveAllAttributes">_SaveAllAttributes</a>,
       * then this will return all the attributes.
       * If you override _SaveAttributes/_RestoreAttributes to do your own thing, then you may also have
       * to override _GetSavedAttributes to return whatever you saved if you need access to the saved
       * attributes.
       *
       * @param {Object} element - jQuery selection, should be a single entry
       * @return {Object|null} savedAttributes - attributes that were saved for this element
       * in <a href="#_SaveAttributes">_SaveAttributes</a>, or null if none were saved.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _GetSavedAttributes: function (element) {
        var savedAttributes = this._savedAttributes;

        // The component may not have saved any attributes. If so, return.
        if (savedAttributes === undefined) {
          return null;
        }

        var domElement = element[0];

        for (var i = 0, j = savedAttributes.length; i < j; i++) {
          var curr = savedAttributes[i];

          if (curr.element === domElement) {
            return curr.attributes;
          }
        }

        return {};
      },

      /**
       * <p>Restore the attributes saved in <a href="#_SaveAttributes">_SaveAttributes</a>.</p>
       * <p>
       * _SaveAttributes is called during _create. And _RestoreAttributes is called during _destroy.
       * </p>
       * <p> This base class default implementation does nothing.
       * </p>
       * <p>We also have <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and
       * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> methods
       *  that save and restore <i>all</i> the attributes on an element.
       *  Component subclasses can opt into these _SaveAllAttributes/_RestoreAllAttributes
       *  implementations by overriding _SaveAttributes and _RestoreAttributes to call
       *  _SaveAllAttributes/_RestoreAllAttributes. If the subclass wants a different implementation
       *  (like save only the 'class' attribute), it can provide the implementation itself in
       *  _SaveAttributes/_GetSavedAttributes/_RestoreAttributes.
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _RestoreAttributes: function () {
        // default implementation does nothing.
      },
      /**
       * <p>Restores <i>all</i> the element's attributes which were saved in
       * <a href="#_SaveAllAttributes">_SaveAllAttributes</a>.
       * This method is final in JET.</p>
       * <p>
       * If a subclass wants to save/restore all attributes on create/destroy, then the
       * subclass can override <a href="#_SaveAttributes">_SaveAttributes</a>
       *  and call  <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and also
       *  override <a href="#_RestoreAttributes">_RestoreAttributes</a>
       *  and call <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a>.
       *
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @final
       */
      _RestoreAllAttributes: function () {
        $.each(this._savedAttributes, function (index, savedAttr) {
          var element = $(savedAttr.element);
          var attributes = savedAttr.attributes;

          // sanity check
          if (element.length === 1) {
            var currAttr = savedAttr.element.attributes;
            var removeAttr = [];
            var i;
            var j;

            // request is to remove any attributes that didn't exist previously
            // need to store the attributes in an array and remove them afterwards as otherwise there are side affects
            for (i = 0, j = currAttr.length; i < j; i++) {
              if (!(currAttr[i].name in attributes)) {
                removeAttr.push(currAttr[i].name);
              }
            }

            for (i = 0, j = removeAttr.length; i < j; i++) {
              // csp error to removeAttribute('style') (which element.removeAttr will do),
              // so instead set it to null
              if (removeAttr[i] === 'style') {
                element[0].style = null;
              } else {
                element.removeAttr(removeAttr[i]);
              }
            }

            var attributeKeys = Object.keys(attributes);
            for (i = 0; i < attributeKeys.length; i++) {
              var attribute = attributeKeys[i];
              var emptyStyle = attribute === 'style' && attributes[attribute].attr === '';
              if (!emptyStyle) {
                element.attr(attribute, attributes[attribute].attr); // @HTMLUpdateOK
              } else {
                // csp error to setAttribute('style', '') (which element.attr will do),
                // so instead set it to null
                element[0].style = null;
              }
            }
          }
        });
      },

      /**
       * <p>Determines the name of the translation bundle section for this component.
       *
       * @return {string} the name of this component's translations section
       * @memberof oj.baseComponent
       * @protected
       */
      _GetTranslationsSectionName: function () {
        return this.widgetFullName;
      },

      /**
       * Compares 2 option values for equality and returns true if they are equal; false otherwise.
       * This method is called before _setOptions()/_internalSetOptions() to prevent an extra call
       * with the same values when observables are written back. Components should override this
       * method for options with non primitive writeback values like Arrays or Objects and ensure
       * their metadata has writeback properties correctly indicated.
       *
       * @param {String} option - the name of the option
       * @param {Object} value1 first value
       * @param {Object} value2 another value
       * @return {boolean}
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _CompareOptionValues: function (option, value1, value2) {
        // We process the metadata for custom elements for writeback properties and save them on the component.
        // For jQuery syntax, components are expected to override this method to check writeback values since
        // there's not always a straightforward mapping of custom element to jQuery widget name.
        if (this._IsCustomElement() && this._getWritebackOption(option)) {
          return oj.Object.compareValues(value1, value2);
        }

        return value1 === value2;
      },

      /**
       * <p>Retrieves a translated string after inserting optional parameters.
       *
       * @param {string} key the translations resource key
       * The key is used to retrieve a format pattern from the component options, or if none
       * is found - from the translated resource bundle.
       * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
       * for the optional parameters.  Token strings should not contain comma (,)
       * or space characters, since they are reserved for future format type enhancements.
       * The reserved characters within a pattern are:
       * $ { } [ ]
       * These characters will not appear in the formatted output unless they are escaped
       * with a dollar character ('$').
       *
       * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the
       * translated pattern.
       *
       * If more than one var_args arguments are passed, they will be treated as an array
       * for replacing positional tokens like {0}, {1}, etc.
       * If a single argument is passed, it will be treated as a Javascript Object whose
       * keys will be matched to tokens within the pattern. Note that an Array is just
       * a special kind of such an Object.
       *
       * For backward compatibility, a var_args argument whose type is neither
       * Object or Array will be used to replace {0} in the pattern.
       *
       * @return formatted translated string or the key argument if the resource for the
       * key was not found
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      // TODO: non-public methods need to start with "_".  Pinged architect, who thinks this
      // method should become protected post-V1, which would imply a capital _GetTranslatedString
      // eslint-disable-next-line no-unused-vars, camelcase
      getTranslatedString: function (key, var_args) {
        var params = {};

        if (arguments.length > 2) {
          params = Array.prototype.slice.call(arguments, 1);
        } else if (arguments.length === 2) {
          params = arguments[1];
          if (typeof params !== 'object' && !(params instanceof Array)) {
            params = [params];
          }
        }
        var pattern = this.option(_OJ_TRANSLATIONS_PREFIX + key);
        // pattern could be undefined
        return pattern == null ? key : Translations.applyParameters(pattern.toString(), params);
      },

      // Subclasses should doc their sub-id's in the Sub-ID's section, via the ojsubid tag, not by overriding
      // and extending this method doc, which should remain general purpose.
      /**
       * <p>Returns the DOM node indicated by the <code class="prettyprint">locator</code> parameter.
       *
       * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is
       * <code class="prettyprint">null</code>, then this method returns this element.
       *
       * <p>If a non-null <code class="prettyprint">subId</code> is provided but no corresponding node
       * can be located, then this method returns <code class="prettyprint">null</code>.
       *
       * <p>This method is intended for use in test automation only, and should not be used in a production environment.
       *
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @ignore
       *
       * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code>
       * property, whose value is a string that identifies a particular DOM node in this element.
       *
       * <p>If this component has any subIds, then they are documented in the
       * <a href="#subids-section">Sub-ID's</a> section of this document.
       *
       * <p>Some components may support additional fields of the
       * <code class="prettyprint">locator</code> Object, to further specify the desired node.
       *
       * @returns {Element|null} The DOM node located by the
       * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
       *
       * @example <caption>Get the node for a certain subId:</caption>
       * var node = myComponent.getNodeBySubId({'subId': 'oj-some-sub-id'});
       */
      getNodeBySubId: function (locator) {
        if (locator == null || locator.subId == null) {
          return this.element ? this.element[0] : null;
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      /**
       * <p>Returns the subId string for the given DOM node in this element.  For details, see
       * <a href="#getNodeBySubId">getNodeBySubId</a> and the <a href="#subids-section">Sub-ID's</a>
       * section of this document.
       *
       * <p>This method is intended for use in test automation only, and should not be used in a production environment.
       *
       * @ojfragment getSubIdByNodeDesc
       * @memberof oj.baseComponent
       */
      /**
       * DOM node in this element
       *
       * @ojfragment getSubIdByNodeNodeParam
       * @memberof oj.baseComponent
       */
      /**
       * The subId for the DOM node, or <code class="prettyprint">null</code> if none is found.
       *
       * @ojfragment getSubIdByNodeReturn
       * @memberof oj.baseComponent
       */
      /**
       * Get the subId for a certain DOM node:
       *
       * @ojfragment getSubIdByNodeCaption
       * @memberof oj.baseComponent
       */
      /**
       * var locator = myComponent.getSubIdByNode(nodeInsideElement);
       *
       * @ojfragment getSubIdByNodeExample
       * @memberof oj.baseComponent
       */

      // While a subclass could technically extend the verbiage by adding its own verbiage after the ojinclude,
      // please doc sub-id's in the subid's section, not by extending this method doc.
      /**
       * {@ojinclude "name":"getSubIdByNodeDesc"}
       *
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @ignore
       *
       * @param {!Element} node {@ojinclude "name":"getSubIdByNodeNodeParam"}
       * @returns {Object|null} {@ojinclude "name":"getSubIdByNodeReturn"}
       *
       * @example <caption>{@ojinclude "name":"getSubIdByNodeCaption"}</caption>
       * {@ojinclude "name":"getSubIdByNodeExample"}
       */
      // eslint-disable-next-line no-unused-vars
      getSubIdByNode: function (node) {
        return null;
      },

      // Overridden to set oj-hover and oj-focus classes
      // TODO: Move JSDoc from subclasses to here.  Don't include above internal comment.  Make at-final.
      destroy: function () {
        if (this._IsCustomElement()) {
          throw new Error('destroy cannot be called on a custom element');
        }

        // Fire 'destroy' event
        this._trigger('destroy');

        // Since jQuery event listeners get removed before the destroy() method whne jQuery.clean() cleans up the subtree,
        // we need to fire a custom DOM event as well. This will allow component binding to execute destroy callbacks for
        // custom bindings and managed attributes.

        DomUtils.dispatchEvent(this.element[0], new CustomEvent('_ojDestroy'));

        // allow subcomponent to release resources they hold.
        this._ReleaseResources();

        this._super();

        // remove hover and active listeners
        //    this.widget().off(this.eventNamespace);

        // clean up states
        this.element.removeClass(_OJ_COMPONENT_NODE_CLASS);
        this.widget().removeClass(_DISABLED);

        // pass init node (this.element), not root node if different (this.widget()), since all elements in
        // the root node subtree but not the init node subtree should have been removed by the call to _super.
        this._removeStateClasses(this.element);

        _removeWidgetName(this.element, this.widgetName);

        this._RestoreAttributes();

        // TODO: move this to _RestoreAttributes?
        if (this._initialCmDomAttr) {
          this.element.attr('contextmenu', this._initialCmDomAttr);
        } else {
          this.element.removeAttr('contextmenu');
        }

        this._propertyContext = null;
      },

      /*
       * Internal notes:
       * Overridden to pass extra flags to _setOption
       * param {...Object} var_args - key (or map), value, flags
       */
      /**
       * <p>This method has several overloads, which get and set component options and their fields.  The functionality is unchanged from
       * that provided by JQUI.  See the examples for details on each overload.
       *
       * @ignore
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @final
       *
       * @param {string|Object=} optionName the option name (string, first two overloads), or the map (Object, last overload).
       *        Omitted in the third overload.
       * @param {Object=} value a value to set for the option.  Second overload only.
       * @return {Object|undefined} The getter overloads return the retrieved value(s).  When called via the public jQuery syntax, the setter overloads
       *         return the object on which they were called, to facilitate method chaining.
       *
       * @example <caption>First overload: get one option:
       * <p>This overload accepts a (possibly dot-separated) <code class="prettyprint">optionName</code> param as a string, and returns
       * the current value of that option.</caption>
       * var isDisabled = $( ".selector" ).ojFoo( "option", "disabled" ); // Foo is Button, Menu, etc.
       *
       * // For object-valued options, dot notation can be used to get the value of a field or nested field.
       * var startIcon = $( ".selector" ).ojButton( "option", "icons.start" ); // icons is object with "start" field
       *
       * @example <caption>Second overload: set one option:
       * <p>This overload accepts two params: a (possibly dot-separated) <code class="prettyprint">optionName</code> string, and a new value to
       * which that option will be set.</caption>
       * $( ".selector" ).ojFoo( "option", "disabled", true ); // Foo is Button, Menu, etc.
       *
       * // For object-valued options, dot notation can be used to set the value
       * // of a field or nested field, without altering the rest of the object.
       * $( ".selector" ).ojButton( "option", "icons.start", myStartIcon ); // icons is object with "start" field
       *
       * @example <caption>Third overload: get all options:
       * <p>This overload accepts no params, and returns a map of key/value pairs representing all the component
       * options and their values.</caption>
       * var options = $( ".selector" ).ojFoo( "option" ); // Foo is Button, Menu, etc.
       *
       * @example <caption>Fourth overload: set one or more options:
       * <p>This overload accepts a single map of option-value pairs to set on the component.  Unlike the first two
       * overloads, dot notation cannot be used.</caption>
       * $( ".selector" ).ojFoo( "option", { disabled: true, bar: 42 } ); // Foo is Button, Menu, etc.
       */
      option: function (optionName, value) {
        // actually varArgs per comment above the JSDoc, but GCC warns unless matches the @param that we wish to doc
        if (arguments.length === 0) {
          // don't return a reference to the internal hash
          return $.widget.extend({}, this.options);
        }

        var key = arguments[0];

        var options = key;
        var subkey = null;

        var flags = {};
        var i;

        if (typeof key === 'string') {
          // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
          options = {};
          var parts = key.split('.');
          key = parts.shift();
          if (parts.length) {
            subkey = parts.join('.');

            var curOption;
            try {
              // Inform dynamic getters that the subkey is being set
              if (arguments.length > 1) {
                this._settingNestedKey = subkey;
              }

              curOption = $.widget.extend({}, this.options[key]);
              options[key] = curOption;
            } finally {
              this._settingNestedKey = null;
            }

            for (i = 0; i < parts.length - 1; i++) {
              curOption[parts[i]] = curOption[parts[i]] || {};
              curOption = curOption[parts[i]];
            }

            key = parts.pop();
            if (arguments.length === 1) {
              return curOption[key] === undefined ? null : curOption[key];
            }

            curOption[key] = value;
          } else {
            if (arguments.length === 1) {
              return this.options[key] === undefined ? null : this.options[key];
            }
            options[key] = value;
          }

          flags = arguments[2] || flags;
        } else {
          flags = arguments[1] || flags;
        }

        // Store subkey on the flags to let _setOption() know that dot notation was used
        if (subkey != null) {
          var subprop = {
            path: optionName,
            value: value
          };
          flags = $.widget.extend({}, flags, { subkey: subkey, subproperty: subprop });
        }

        var context = flags ? flags._context : null;
        var internalSet = context ? context.internalSet : false;

        // This method can be called twice with the same value for writeback properties
        // so we need to go through the options object and only pass through the changed values
        var newOptions = {};
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i++) {
          var option = optionKeys[i];
          var newValue = options[option];
          var oldValue = this.options[option];
          // The changed flag is set when components have updated an object or array value in place
          var changed = flags && flags.changed;
          if (changed || !this._CompareOptionValues(option, oldValue, newValue)) {
            newOptions[option] = newValue;
          } else if (this._IsCustomElement()) {
            Logger.info(
              ojcustomelementUtils.CustomElementUtils.getElementInfo(this.element[0]) +
                ": Ignoring property set for property '" +
                option +
                "' with same value."
            );
          }
        }

        if (Object.keys(newOptions).length > 0) {
          // Avoid _setOption() calls for internal sets, since component's _setOption()
          // and setOptions() overrides do not expect to be called in that case
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
          try {
            if (internalSet) {
              this._internalSetOptions(newOptions, flags);
            } else {
              this._setOptions(newOptions, flags);
            }
          } finally {
            ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
          }
        }

        return this;
      },

      /**
       * option() calls this rather than _setOption() if the caller was internal.
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _internalSetOptions: function (options, flags) {
        var keys = Object.keys(options);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = options[key];
          var oldValue = this.options[key];
          this.options[key] = value;
          this._optionChanged(key, value, oldValue, flags);
        }
      },

      /**
       * <p>Overridden to pass extra flags to _setOption.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @ignore
       */
      _setOptions: function (options, flags) {
        ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
        try {
          var keys = Object.keys(options);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = options[key];
            this._setOption(key, value, flags);
          }
        } finally {
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
        }
        return this;
      },

      /**
       * Overridden to set oj-hover and oj-focus classes.
       * Components should not call this method directly, but instead call option().
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @ignore
       */
      _setOption: function (key, value, flags) {
        var originalValue = this.options[key];

        if (key === 'disabled') {
          // The JQUI superclass method has hard-coded style classes in the 'if key === "disabled"' block, so unfortunately
          // we must copy that logic here with updated style classes, and NOT call _super() for the disabled case.
          // TBD: keep this logic updated if superclass method changes.
          this.options[key] = value;

          // TBD: widget() is not always the thing that should have aria-disabled on it.  E.g. for the checkbox/radio flavors of ojButton,
          // widget() returns the root node, but aria-disabled belongs on the <input>.  We fixed this JQUI bug in ojButton by having ojButton
          // override this method to remove it from the root node and add it to the input.  Would be better for each component to know which
          // element to apply that to, e.g. an overridable method returning that element, or copying "hoverable" paradigm if appropriate.
          // In the cases where this.element is different than widget(), this.element is more likely to be the right thing, so maybe change
          // default to that.
          // Update: this issue is getting even more awkward now that we have "effectively disabled".  Probably need to refactor this code!
          this.widget().toggleClass(_DISABLED, !!value).attr('aria-disabled', value);

          if (value) {
            this._removeStateClasses(this.widget());
          }
        } else {
          try {
            var subkey = flags == null ? null : flags.subkey;
            if (subkey != null) {
              this._settingNestedKey = subkey;
            }

            this._super(key, value);
          } finally {
            this._settingNestedKey = null;
          }

          // if contextMenu option wasn't set before, we'll need to start detect gesture
          if (key === 'contextMenu') {
            this._SetupContextMenu();
          }
        }

        this._optionChanged(key, value, originalValue, flags);

        return this;
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _optionChanged: function (key, value, originalValue, flags) {
        // Assume that all values are different from originalValues as we do equality
        // checking before calling this method or trust components that have set the
        // 'changed' flag to indicate that they updated in place for an Object or Array
        // since we won't see any difference for those cases.
        // var changed = false;
        var context = null;

        var writeback = false;
        var readOnly = false;
        var originalEvent = null;
        var updatedFrom = 'external';

        var optionMetadata = null;

        var extraData;

        if (flags) {
          context = flags._context;

          if (context) {
            // Skip firing an option changed event for certain cases like
            // custom element default value sets where the bridge interprets an
            // application undefined value set to the property default defined in the
            // metadata.
            if (context.skipEvent) {
              return;
            }

            originalEvent = context.originalEvent;
            writeback = context.writeback === undefined ? originalEvent != null : context.writeback;
            readOnly = context.readOnly;
            optionMetadata = context.optionMetadata;
            extraData = context.extraData;
            if (context.internalSet) {
              updatedFrom = 'internal';
            }
          }
        }

        optionMetadata = optionMetadata || {};
        optionMetadata.writeback = writeback ? 'shouldWrite' : 'shouldNotWrite';

        if (readOnly) {
          optionMetadata.readOnly = true;
        }

        var optionChangeData = {
          option: key,
          previousValue: originalValue,
          value: value,
          optionMetadata: optionMetadata,
          updatedFrom: updatedFrom
        };

        var subkey = flags == null ? null : flags.subkey;
        // Walk previousValue object and find the subproperty previousValue
        if (subkey) {
          var subprops = subkey.split('.');
          var originalSubpropValue = originalValue;
          subprops.forEach(function (subprop) {
            if (!originalSubpropValue) {
              return;
            }
            originalSubpropValue = originalSubpropValue[subprop];
          });
          var subproperty = flags.subproperty;
          subproperty.previousValue = originalSubpropValue;
          optionChangeData.subproperty = subproperty;
        }

        if (extraData != null) {
          optionChangeData = $.extend({}, extraData, optionChangeData);
        }

        this._trigger('optionChange', originalEvent, optionChangeData);
      },

      /**
       * <p>Sets up needed resources for this component, for example, add
       * listeners. This is called during _create.
       * <a href="#_ReleaseResources">_ReleaseResources</a> will release resources
       * help by this component, and is called during destroy.
       * </p>
       *  Component subclasses can opt in by overriding _SetupResources and
       *   _ReleaseResources.
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _SetupResources: function () {
        this._SetupContextMenu();
      },

      /**
       * <p>Release resources held by this component, for example, remove
       * listeners. This is called during destroy.
       * <a href="#_SetupResources">_SetupResources</a> will set up resources
       * needed by this component, and is called during _create.
       * </p>
       *  Component subclasses can opt in by overriding _SetupResources and
       *   _ReleaseResources.
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _ReleaseResources: function () {
        this._ReleaseContextMenu();
      },

      /**
       * <p>Overridden to change the way the component events are treating original events:
       *
       * 1) preventDefault(), stopPropagation() and stopImmediatePropagation() no longer invoke
       *    the corresponding methods on the .originalEvent
       * 2) Properties of the .originalEvent are no longer copied to the new event being
       *    triggered
       *
       * @param {string} type - component event type
       * @param {?Object} event - original event
       * @param {Object=} data - event data
       * @return {boolean} true if the default action has not been prevented, false otherwise
       *
       * @private
       */
      _trigger: function (type, event, data) {
        return this._trigger2(type, event, data).proceed;
      },

      /**
       * <p>Same as _trigger(), but returns an object containing both the "prevented" status and the event.
       *
       * <p>This is useful for event chaining, so that the returned event (e.g. Menu's select event) can be
       * passed as the originalEvent of a subsequent event caused by the first (e.g. Menu's close event).
       *
       * @param {string} type - component event type
       * @param {?Object} event - original event
       * @param {Object=} data - event data
       * @return {!{proceed: boolean, event: ($.Event|CustomEvent)}}
       *     proceed is true if the default action has not been prevented, false otherwise
       *     event is the new event that was triggered
       *
       * @private
       */
      _trigger2: function (type, event, data) {
        var eventData = data || {};

        if (this._IsCustomElement()) {
          return this._triggerCustomEvent(type, event, eventData);
        }

        var callback = this.options[type];

        var jqEvent = $.Event(event, _OJ_COMPONENT_EVENT_OVERRIDES);
        jqEvent.type = (this.widgetEventPrefix + type).toLowerCase();

        // the original event may come from any element
        // so we need to reset the target on the new event
        jqEvent.target = this.element[0];

        this.element.trigger(jqEvent, eventData);

        return {
          proceed: !(
            ($.isFunction(callback) &&
              callback.apply(this.element[0], [jqEvent].concat(eventData)) === false) ||
            jqEvent.isDefaultPrevented()
          ),
          event: jqEvent
        };
      },

      /**
       * <p>Fires a CustomEvent instead of a jQuery event for when this component is created as a custom element.
       *
       * @param {string} type - component event type
       * @param {?Object} event - original event
       * @param {Object} data - event data
       * @return {!{proceed: boolean, event: CustomEvent}}
       *     proceed is true if the default action has not been prevented, false otherwise
       *     event is the new event that was triggered
       *
       * @private
       */
      _triggerCustomEvent: function (type, event, data) {
        var eventName;
        var detail = {};
        var bubbles;
        var cancelable;
        var rootElement = this._getRootElement();

        if (type === 'optionChange') {
          var property = CustomElementBridge.getPropertyForAlias(rootElement, data.option);
          if (!CustomElementBridge.isKnownProperty(rootElement, property)) {
            return { proceed: true, event: null };
          }
          eventName = ojcustomelementUtils.AttributeUtils.propertyNameToChangeEventType(property);

          // Copy over component specific optionChange event properties, promoting those exposed
          // in the optionMetadata to the top level alongside value/previousValue/subproperty.
          var keys = Object.keys(data);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== 'option') {
              if (key === 'optionMetadata') {
                // Do not expose optionMetadata for custom element property change events
                // Instead, promote any component specific metadata to the top level.
                var metaKeys = Object.keys(data[key]);
                for (var j = 0; j < metaKeys.length; j++) {
                  var metaKey = metaKeys[j];
                  if (metaKey !== 'writeback' && metaKey !== 'component') {
                    detail[metaKey] = data[key][metaKey];
                  }
                }
              } else {
                detail[key] = data[key];
              }
            }
          }
        } else {
          eventName = ojcustomelementUtils.AttributeUtils.eventTriggerToEventType(type);
          if (!CustomElementBridge.isKnownEvent(rootElement, eventName)) {
            return { proceed: true, event: null };
          }
          bubbles = true;
          cancelable = true;
          detail = this._resolveJQueryObjects(data);
        }
        if (event) {
          detail.originalEvent = event instanceof $.Event ? event.originalEvent : event;
        }
        var params = { detail: detail };
        if (bubbles) {
          params.bubbles = true;
        }
        if (cancelable) {
          params.cancelable = true;
        }

        var customEvent = new CustomEvent(eventName, params);
        rootElement.dispatchEvent(customEvent);
        return { proceed: !customEvent.defaultPrevented, event: customEvent };
      },

      /**
       * <p>Creates a shallow copy of the passed in object where any top-level JQuery objects have been resolved to their underlying objects.
       * @param {Object} data the original object
       * @return {Object} the resolved object copy
       *
       * @private
       */
      _resolveJQueryObjects: function (data) {
        var resolved = oj.CollectionUtils.copyInto({}, data);
        var keys = Object.keys(resolved);
        for (var k = 0; k < keys.length; k++) {
          var key = keys[k];
          var val = resolved[key];
          if (val && val instanceof $) {
            if (val.length === 0) {
              resolved[key] = null;
            } else if (val.length === 1) {
              resolved[key] = val[0];
            } else {
              resolved = val.toArray();
            }
          }
        }
        return resolved;
      },

      /**
       * <p>Sets contextMenu option from DOM if option not set.
       *
       * <p>Do not override.  To be called only from _InitOptions().
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       * @final
       */
      _initContextMenuOption: function (constructorOptions) {
        var contextMenu = this.element.attr('contextmenu');

        this._initialCmDomAttr = contextMenu; // TODO: remove this after the _RestoreAttributes() call in destroy() is uncommented

        if (contextMenu && !('contextMenu' in constructorOptions)) {
          // if app set DOM attr but not option, then set the option from the DOM
          this.option('contextMenu', document.getElementById(contextMenu), {
            _context: { internalSet: true }
          }); // writeback not needed since "not in constructorOptions" means "not bound"
        }
      },

      /**
       * Handler
       * @param {Element} contextMenu root element of context menu
       * @param {Event} event the dom event
       * @param {string} eventType the type of event
       * @private
       */
      _handleContextMenuGesture: function (contextMenu, event, eventType) {
        // For components like Button where "effectively disabled" --> "not focusable", keyboard CM launch is impossible, so
        // allowing right-click access would be an a11y issue.  If there's ever a need to enable this for focusable effectively
        // disabled components, we can always replace the _IsEffectivelyDisabled() call with a new protected method whose
        // baseComponent impl returns _IsEffectivelyDisabled().
        if (this._IsEffectivelyDisabled()) {
          return;
        }

        // contextMenu should reference the latest one from the scope
        var menu;
        if (contextMenu.tagName === 'OJ-MENU') {
          menu = contextMenu;
        } else {
          var constructor = Components.__GetWidgetConstructor(contextMenu, 'ojMenu');
          menu = constructor && constructor('instance');
          if (!menu) {
            throw new Error('Invalid JET Menu.'); // keeping old behavior
          }
        }

        this._NotifyContextMenuGesture(menu, event, eventType);

        // todo: modify NotifyContextMenuGesture contract so we don't need to check visible
        if ($(contextMenu).is(':visible')) {
          event.preventDefault(); // don't show native context menu
        }
      },

      /**
       * <p>Call this method from _SetupResources().  It sets up listeners needed to detect context menu gestures.
       *
       * <p>We don't look for the menu until context menu gesture has been detected on the first launch,
       * so that the menu needn't be inited before this component.
       *
       * <p>If needed, override <code class="prettyprint">_NotifyContextMenuGesture()</code>, not this private method.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _SetupContextMenu: function (contextMenuOptions) {
        var contextMenu = this._GetContextMenu();
        if (!contextMenu) {
          contextMenu = this._GetDefaultContextMenu();
        }

        if (contextMenu && this._contextMenuGestureInit === undefined) {
          this._contextMenuGestureInit = contextMenu;

          var self = this;
          GestureUtils.startDetectContextMenuGesture(
            this.widget()[0],
            function (event, eventType) {
              self._handleContextMenuGesture(contextMenu, event, eventType);
            },
            contextMenu,
            contextMenuOptions
          );
        }
      },

      /**
       * <p>This method removes contextMenu functionality from the component and specified menu.
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _ReleaseContextMenu: function () {
        this._contextMenuGestureInit = undefined;

        // access menu elem directly, rather than using the widget() of the Menu component, so listener is cleared even if component no longer exists.
        // $(contextMenuOption).off( this.contextMenuEventNamespace );
        GestureUtils.stopDetectContextMenuGesture(this.widget()[0]);
      },

      /**
       * Helper method to retrieve the context menu element
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _GetContextMenu: function () {
        if (this._IsCustomElement()) {
          var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(this._getRootElement());
          var slot = slotMap.contextMenu;
          if (slot && slot.length > 0) {
            return slot[0];
          }
        } else if (this.options.contextMenu) {
          return $(this.options.contextMenu).first()[0];
        }

        return null;
      },

      /**
       * <p>When the <a href="#contextMenu">contextMenu</a> option is set, this method is called when the user invokes the context menu via
       * the default gestures: right-click, <kbd>Press & Hold</kbd>, and <kbd>Shift-F10</kbd>.  Components should not call this method directly.
       *
       * <p>The default implementation simply calls <a href="#_OpenContextMenu">this._OpenContextMenu(event, eventType)</a>.
       * Overrides of this method should call that same method, perhaps with additional params, not [menu.open()]{@link oj.ojMenu#open}.
       *
       * <p>This method may be overridden by components needing to do things like the following:
       *
       * <ul>
       * <li>Customize the [launcher]{@link oj.ojMenu#openOptions.launcher} or [position]{@link oj.ojMenu#openOptions.position} passed to
       * <a href="#_OpenContextMenu">_OpenContextMenu()</a>.  See that method for guidance on these customizations.</li>
       *
       * <li>Customize the menu contents.  E.g. some components need to enable/disable built-in commands like <kbd>Cut</kbd> and <kbd>Paste</kbd>,
       * based on state at launch time.</li>
       *
       * <li>Bail out in some cases.  E.g. components with UX approval to use <kbd>PressHoldRelease</kbd> rather than <kbd>Press & Hold</kbd> can override this method
       * to say <code class="prettyprint">if (eventType !== "touch") this._OpenContextMenu(event, eventType);</code>.  When those components
       * detect the alternate context menu gesture (e.g. <kbd>PressHoldRelease</kbd>), that separate listener should call <a href="#_OpenContextMenu">this._OpenContextMenu()</a>,
       * not this method (<code class="prettyprint">_NotifyContextMenuGesture()</code>), and not [menu.open()]{@link oj.ojMenu#open}.  </li>
       * </ul>
       *
       * <p>Components needing to do per-launch setup like the above tasks should do so in an override of this method, <i>not</i> in
       * a [beforeOpen]{@link oj.ojMenu#event:beforeOpen} listener or an <a href="#_OpenContextMenu">_OpenContextMenu()</a> override.
       * This is discussed more fully <a href="#_OpenContextMenu">here</a>.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       *
       * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
       * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
       * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
       */
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        this._OpenContextMenu(event, eventType);
      },

      /**
       * <p>The only correct way for a component to open its context menu is by calling this method, not by calling [Menu.open()]{@link oj.ojMenu#open} or
       * <a href="#_NotifyContextMenuGesture">_NotifyContextMenuGesture()</a>.  This method should be called in two cases:
       *
       * <ul>
       * <li>This method is called by <a href="#_NotifyContextMenuGesture">_NotifyContextMenuGesture()</a> and its overrides.  That method is
       * called when the baseComponent detects the default context menu gestures: right-click, <kbd>Press & Hold</kbd>, and <kbd>Shift-F10</kbd>.</li>
       *
       * <li>Components with UX-approved support for alternate context menu gestures like <kbd>PressHoldRelease</kbd> should call this method directly
       * when those gestures are detected.</li>
       * </ul>
       *
       * <p>Components needing to customize how the context menu is launched, or do any per-launch setup, should do so in the caller of this method,
       * (which is one of the two callers listed above), often by customizing the params passed to this method
       * (<code class="prettyprint">_OpenContextMenu</code>) per the guidance below.  This setup should <i>not</i> be done in the following ways:
       *
       * <ul>
       * <li>Components should not perform setup in a [beforeOpen]{@link oj.ojMenu#event:beforeOpen} listener, as this can cause a race
       * condition where behavior depends on who got their listener registered first: the component or the app.  The only correct component use
       * of a <code class="prettyprint">beforeOpen</code> listener is when there's a need to detect whether <i>something else</i> launched the menu.</li>
       *
       * <li>Components should not override this method (<code class="prettyprint">_OpenContextMenu</code>), as this method is final.  Instead, customize
       * the params that are passed to it.</li>
       * </ul>
       *
       * <p><b>Guidance on setting OpenOptions fields:</b>
       *
       * <p><b>Launcher:</b>
       *
       * <p>Depending on individual component needs, any focusable element within the component can be the appropriate
       * [launcher]{@link oj.ojMenu#openOptions.launcher} for this launch.
       *
       * <p>Browser focus returns to the launcher on menu dismissal, so the launcher must at least be focusable.  Typically a tabbable (not just
       * focusable) element is safer, since it just focuses something the user could have focused on their own.
       *
       * <p>By default (i.e. if <code class="prettyprint">openOptions</code> is not passed, or if it lacks a <code class="prettyprint">launcher</code>
       * field), the component init node is used as the launcher for this launch.  If that is not focusable or is suboptimal for a given
       * component, that component should pass something else.  E.g. components with a "roving tabstop" (like Toolbar) should typically choose the
       * current tabstop as their launcher.
       *
       * <p>The [:focusable]{@link http://api.jqueryui.com/focusable-selector/} and [:tabbable]{@link http://api.jqueryui.com/tabbable-selector/} selectors
       * may come in handy for choosing a launcher, e.g. something like <code class="prettyprint">this.widget().find(".my-class:tabbable").first()</code>.
       *
       * <p><b>Position:</b>
       *
       * <p>By default, this method applies [positioning]{@link oj.ojMenu#openOptions.position} that differs from Menu's default in the following ways:
       * (The specific settings are subject to change.)
       *
       * <ul>
       * <li>For mouse and touch events, the menu is positioned relative to the event, not the launcher.</li>
       *
       * <li>For touch events, <code class="prettyprint">"my"</code> is set to <code class="prettyprint">"start>40 center"</code>,
       * to avoid having the context menu obscured by the user's finger.</li>
       * </ul>
       *
       * <p>Usually, if <code class="prettyprint">position</code> needs to be customized at all, the only thing that needs changing is its
       * <code class="prettyprint">"of"</code> field, and only for keyboard launches (since mouse/touch launches should almost certainly keep
       * the default <code class="prettyprint">"event"</code> positioning).  This situation arises anytime the element relative to which the menu
       * should be positioned for keyboard launches is different than the <code class="prettyprint">launcher</code> element (the element to which
       * focus should be returned upon dismissal).  For this case, <code class="prettyprint">{ "position": {"of": eventType==="keyboard" ? someElement : "event"} }</code>
       * can be passed as the <code class="prettyprint">openOptions</code> param.
       *
       * <p>Be careful not to clobber useful defaults by specifying too much.  E.g. if you only want to customize <code class="prettyprint">"of"</code>,
       * don't pass other fields like <code class="prettyprint">"my"</code>, since your value will be used for all modalities (mouse, touch, keyboard),
       * replacing the modality-specific defaults that are usually correct.  Likewise, don't forget the
       * <code class="prettyprint">eventType==="keyboard"</code> check if you only want to customize <code class="prettyprint">"of"</code> for keyboard launches.
       *
       * <p><b>InitialFocus:</b>
       *
       * <p>This method forces [initialFocus]{@link oj.ojMenu#openOptions.initialFocus} to <code class="prettyprint">"menu"</code> for this
       * launch, so the caller needn't specify it.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @final
       *
       * @param {!Event} event What triggered the context menu launch.  Must be non-<code class="prettyprint">null</code>.
       * @param {string} eventType "mouse", "touch", or "keyboard".  Must be non-<code class="prettyprint">null</code>.  Passed explicitly since caller
       *        knows what it's listening for, and since events like <code class="prettyprint">contextmenu</code> and
       *        <code class="prettyprint">click</code> can be generated by various input modalities, making it potentially error-prone for
       *        this method to determine how they were generated.
       * @param {Object=} openOptions Options to merge with this method's defaults, which are discussed above.  The result will be passed to
       *        [Menu.open()]{@link oj.ojMenu#open}.  May be <code class="prettyprint">null</code> or omitted.  See also the
       *        <code class="prettyprint">shallow</code> param.
       * @param {Object=} submenuOpenOptions Options to be passed through to [Menu.open()]{@link oj.ojMenu#open}.  May be <code class="prettyprint">null</code>
       *        or omitted.
       * @param {boolean=} shallow Whether to perform a deep or shallow merge of <code class="prettyprint">openOptions</code> with this method's default
       *        value.  The default and most commonly correct / useful value is <code class="prettyprint">false</code>.
       *
       *        <ul>
       *        <li>If <code class="prettyprint">true</code>, a shallow merge is performed, meaning that the caller's <code class="prettyprint">position</code>
       *        object, if passed, will completely replace this method's default <code class="prettyprint">position</code> object.</li>
       *
       *        <li>If <code class="prettyprint">false</code> or omitted, a deep merge is performed.  For example, if the caller wishes to tweak
       *        <code class="prettyprint">position.of</code> while keeping this method's defaults for <code class="prettyprint">position.my</code>,
       *        <code class="prettyprint">position.at</code>, etc., it can pass <code class="prettyprint">{"of": anOfValue}</code> as the
       *        <code class="prettyprint">position</code> value.</li>
       *        </ul>
       *
       *        <p>The <code class="prettyprint">shallow</code> param is n/a for <code class="prettyprint">submenuOpenOptions</code>, since this method doesn't
       *        apply any defaults to that.  (It's a direct pass-through.)
       */
      _OpenContextMenu: function (event, eventType, openOptions, submenuOpenOptions, shallow) {
        var contextMenuNode = this._GetContextMenu();
        if (!contextMenuNode) {
          // the context menu node could have been currently opened with another launcher
          if (this._contextMenuGestureInit && $(this._contextMenuGestureInit).is(':visible')) {
            contextMenuNode = this._contextMenuGestureInit;
          } else {
            contextMenuNode = this._GetDefaultContextMenu();
          }
        }

        if (contextMenuNode) {
          // Note: our touch positioning is similar to that of the iOS touch callout (bubble with "Open in New Tab", etc.), which is offset from the pressHold location as follows:
          // - to the right, vertically centered.  (by default)
          // - to the left, vertically centered.  (if fits better)
          // - above or below, horizontally centered.  (if fits better)
          // An offset like 40 prevents it from opening right under your finger, and is similar to iOS's offset.  It also prevents the issue (on iOS7 at least)
          // where touchend after the pressHold can dismiss the CM b/c the menu gets the touchend.

          var position = {
            mouse: {
              my: 'start top',
              at: _START_BOTTOM,
              of: event,
              collision: 'flipfit'
            },
            touch: {
              my: 'start>40 center',
              at: _START_BOTTOM,
              of: event,
              collision: 'flipfit'
            },
            keyboard: {
              my: 'start top',
              at: _START_BOTTOM,
              of: 'launcher',
              collision: 'flipfit'
            }
          };

          var defaults = { launcher: this.element, position: position[eventType] }; // used for fields caller omitted
          var forcedOptions = { initialFocus: 'menu' };

          var mergedOpenOptions = shallow
            ? $.extend(defaults, openOptions, forcedOptions)
            : $.extend(true, defaults, openOptions, forcedOptions);

          contextMenuNode.__openingContextMenu = true; // Hack.  See todo on this ivar in Menu.open().
          if (contextMenuNode.tagName === 'OJ-MENU') {
            contextMenuNode.open(event, mergedOpenOptions, submenuOpenOptions);
          } else {
            var constructor = Components.__GetWidgetConstructor(contextMenuNode, 'ojMenu');
            var menu = constructor && constructor('instance');
            menu.open(event, mergedOpenOptions, submenuOpenOptions);
            // Open is immediate for jquery UI menus.
            // Win FF will fire a contextmenu event on shift+F10 long after the keypress was prevented.
            // jquery ui needs immediate focus to the menu on open. The contextmenu event is fired on
            // the menu versus the launcher. This logic prevents the context menu event within a 50ms
            // window after the menu is open.
            var eatEventHandler = function (e) {
              e.preventDefault();
            };
            contextMenuNode.addEventListener('contextmenu', eatEventHandler);
            window.setTimeout(function () {
              contextMenuNode.removeEventListener('contextmenu', eatEventHandler);
            }, 50);
          }
          contextMenuNode.__openingContextMenu = false;
        }
      },

      /**
       * Retrieve the default context menu.
       * @return {Element|null} the root element for the default context menu, or null if there is no default context menu.  The default is null.
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _GetDefaultContextMenu: function () {
        return null;
      },

      /**
       * <p>Removes the <code class="prettyprint">oj-hover</code>, <code class="prettyprint">oj-focus</code>,
       * <code class="prettyprint">oj-focus-highlight</code>, and
       * <code class="prettyprint">oj-active</code> classes from the specified element and its subtree.
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       *
       * @param {!jQuery} element The element from whose subtree the 3 classes should be removed
       */
      _removeStateClasses: function (element) {
        element.removeClass('oj-hover oj-focus oj-focus-highlight oj-active');
        element.find('.oj-hover').removeClass('oj-hover');
        element.find('.oj-focus').removeClass('oj-focus');
        element.find('.oj-focus-highlight').removeClass('oj-focus-highlight');
        element.find('.oj-active').removeClass('oj-active');
      },

      /**
       * @private
       * @return {boolean} true if there is no touch detected within the last 500 ms
       */
      _isRealMouseEvent: function () {
        return !DomUtils.recentTouchEnd();
      },

      /**
       * Add mouse listners to toggle oj-hover class
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected

       * @param {(!Object|!jQuery)} options This param can either be the element
       * (convenience syntax for callers needing to
       *   specify only the element(s) that would
       *   otherwise have been passed as <code class="prettyprint">options.element</code>)
       *   or an object supporting the following fields:
       * @param {jQuery} options.element The element(s) to receive the <code class="prettyprint">oj-hover</code> class on hover
       *   Required if <code class="prettyprint">afterToggle</code> is specified.
       * @param {?function(string)} options.afterToggle Optional callback function called each time the hover classes have been toggled,
       *   after the toggle.  The string "mouseenter" or "mouseleave" is passed, indicating whether the classes were added or removed.
       *   Components with consistency requirements, such as "<code class="prettyprint">oj-default</code> must be applied iff no state classes
       *   such as <code class="prettyprint">oj-hover</code> are applied," can enforce those rules in this callback.
       * @see #_RemoveHoverable
       */
      _AddHoverable: function (options) {
        var element;

        if ($.isPlainObject(options)) {
          element = options.element;
        } else {
          element = options;
          // eslint-disable-next-line no-param-reassign
          options = {};
        }

        var afterToggle = options.afterToggle || $.noop;
        var markerClass = 'oj-hover';

        element
          .on(
            'mouseenter' + this.hoverableEventNamespace,
            this._hoverStartHandler.bind(this, afterToggle)
          )
          .on(
            'mouseleave' + this.hoverableEventNamespace,
            this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle)
          );
      },

      /**
       * Remove mouse listners that were registered in _AddHoverable
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @param {!jQuery} element The same element passed to _AddHoverable
       * @see #_AddHoverable
       */
      _RemoveHoverable: function (element) {
        if (element) {
          element.off(this.hoverableEventNamespace);
        }
      },

      /**
       * Add touch and mouse listeners to toggle oj-active class
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected

       * @param {(!Object|!jQuery)} options This parameter can either be the element
       * (convenience syntax for callers needing to
       *   specify only the element(s) that would
       *   otherwise have been passed as <code class="prettyprint">options.element</code>)
       *   or an object supporting the following fields:
       * @param {jQuery} options.element The element(s) to receive the
       * <code class="prettyprint">oj-active</code> class on active
       *   Required if <code class="prettyprint">afterToggle</code> is specified.
       * @param {?function(string)} options.afterToggle Optional callback function called each time
       *   the active classes have been toggled, after the toggle.  The event.type string is passed
       *   and indicates whether the classes were added or removed. The active classes are added on
       *   "touchstart" or "mousedown" or "mouseenter" and the active classes are removed on
       *   "touchend" or "touchcancel" or "mouseup" or "mouseleave".
       *   Components with consistency requirements, such as
       *   "<code class="prettyprint">oj-default</code> must be applied iff no state classes
       *   such as <code class="prettyprint">oj-active</code> are applied,"
       *   can enforce those rules in this callback.
       * @see #_RemoveActiveable
       */
      _AddActiveable: function (options) {
        var element;

        if ($.isPlainObject(options)) {
          element = options.element;
        } else {
          element = options;
          // eslint-disable-next-line no-param-reassign
          options = {};
        }

        var afterToggle = options.afterToggle || $.noop;
        var markerClass = 'oj-active';

        if (DomUtils.isTouchSupported()) {
          // make sure native element exists
          if (element[0]) {
            // register touchstart with passive option
            this._touchstartListener = this._activeStartHandler.bind(this, afterToggle);
            element[0].addEventListener('touchstart', this._touchstartListener, { passive: true });
          }
          element.on(
            'touchend' +
              this.activeableEventNamespace +
              ' ' +
              'touchcancel' +
              this.activeableEventNamespace,
            this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle)
          );
        }

        element
          .on(
            'mousedown' + this.activeableEventNamespace,
            this._activeStartHandler.bind(this, afterToggle)
          )
          .on(
            'mouseup' + this.activeableEventNamespace,
            this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle)
          )
          // mouseenter/mouseleave is for the case where you mousedown, then move mouse
          // out of element, then move mouse back. We want oj-active to disappear when you move
          // outside and reappear when you move back.
          .on(
            'mouseenter' + this.activeableEventNamespace,
            this._activeStartHandler.bind(this, afterToggle)
          )
          .on(
            'mouseleave' + this.activeableEventNamespace,
            this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle)
          );
      },

      /**
       * Remove touch and mouse listeners that were registered in _AddActiveable
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @param {!jQuery} element The same element passed to _AddActiveable
       * @see #_AddActiveable
       */
      _RemoveActiveable: function (element) {
        if (element) {
          // make sure native element exists
          if (element[0]) {
            // remove touchstart registered with passive option
            element[0].removeEventListener('touchstart', this._touchstartListener, { passive: true });
            delete this._touchstartListener;
          }
          element.off(this.activeableEventNamespace);
          _lastActiveElement = null;
        }
      },

      /**
       * Add oj-active style class and call the afterToggleFunction.
       * Set _lastActiveElement to event.currentTarget on mousedown. Clear it on mouseup.
       * _lastActiveElement is used to remove and add back oj-active on mouseleave and mouseenter
       * if the mouse stays down.
       * @private
       */
      _activeStartHandler: function (afterToggleFunction, event) {
        var elem = $(event.currentTarget);

        // do nothing on mouseenter if _lastActiveElement ivar is not the currentTarget or child of
        // currentTarget. Checking for the child is needed in case there are two nested
        // dom nodes that have set_AddActiveable. Since events bubble, the _lastActiveElement will
        // be the outermost dom that got the mousedown event.
        if (event.type === 'mouseenter' && !this._isTargetInActiveElement(event.currentTarget)) {
          return;
        }

        // do this for either touchstart or real mouse events, but not mouse compatibility event
        if (
          !elem.hasClass(_DISABLED) &&
          (event.type === 'touchstart' || this._isRealMouseEvent(event))
        ) {
          elem.addClass('oj-active');
          afterToggleFunction(event.type);

          // If we get mousedown on the element, we want oj-active to be removed on mouseleave
          // and added back on mouseenter if the mouse stays down.
          if (event.type === 'mousedown') {
            _lastActiveElement = event.currentTarget;

            this.document.one('mouseup', function () {
              _lastActiveElement = null;
            });
          }
        }
      },

      /**
       * @private
       */
      _hoverStartHandler: function (afterToggleFunction, event) {
        // do this for real mouseenter, but not mouse compatibility event
        var elem = $(event.currentTarget);
        if (!elem.hasClass(_DISABLED) && this._isRealMouseEvent(event)) {
          elem.addClass('oj-hover');
          afterToggleFunction(event.type);
        }
      },

      /**
       * Remove markerClass and call the afterToggleFunction.
       * @private
       */
      _hoverAndActiveEndHandler: function (markerClass, afterToggleFunction, event) {
        // for oj-active we don't care about mouseleave unless it was triggered when _lastActiveElement
        // was set on the currentTarget. (see _activeStartHandler). If that's not the case, return.
        if (
          markerClass === 'oj-active' &&
          event.type === 'mouseleave' &&
          !this._isTargetInActiveElement(event.currentTarget)
        ) {
          return;
        }
        $(event.currentTarget).removeClass(markerClass);
        afterToggleFunction(event.type);
      },
      /**
       * Returns true if the event target is _lastActiveElement or a child of _lastActiveElement.
       * Checking for the child is needed in case there are two nested dom nodes that have set
       * _AddActiveable. For example, inputDateTime -> the trigger root container and the trigger icon.
       * We are only keeping track of the _lastActiveElement, which means the ancestor element will
       * be stored in _lastActiveElement because the mouseleave event bubbles.
       * @private
       */
      _isTargetInActiveElement: function (currentTarget) {
        return (
          _lastActiveElement === currentTarget ||
          (_lastActiveElement != null && $.contains(_lastActiveElement, currentTarget))
        );
      },

      // We no longer use _hoverable, but should still override it to ensure the JQUI impl is not called.
      _hoverable: function () {},

      // The internal JSDoc of the DomUtils version of this API refers to this doc, so if changes are made here, that doc
      // must be updated as needed.
      /**
       * <p>Sets JET's "focus" CSS classes when the element is focused and removes them when focus is lost.
       *
       * <p>The <code class="prettyprint">oj-focus</code> class is set on all focuses.
       *
       * <p>Some components additionally have an <code class="prettyprint">oj-focus-highlight</code> class, which applies a focus
       * indicator that is appropriate on a subset of the occasions that <code class="prettyprint">oj-focus</code> is appropriate.
       * Those components should pass <code class="prettyprint">true</code> for the <code class="prettyprint">applyHighlight</code>
       * param, in which case the <code class="prettyprint">oj-focus-highlight</code> class is set if appropriate given the
       * current focus highlight policy.
       *
       * <h5>Focus highlight policy</h5>
       *
       * <p>The focus highlight policy supports the 3 values listed below.  By default, it is retrieved from the
       * <code class="prettyprint">$focusHighlightPolicy</code> SASS variable, shared by many components and patterns.  Components
       * with different needs, including those exposing a component-specific SASS variable or other API for this, should see the
       * <code class="prettyprint">getFocusHighlightPolicy</code> parameter below.
       *
       * Valid focus highlight policies:
       *
       * <table class="generic-table">
       *   <thead>
       *     <tr>
       *       <th>Policy</th>
       *       <th>Description</th>
       *     </tr>
       *   </thead>
       *   <tbody>
       *     <tr>
       *       <td>"nonPointer"</td>
       *       <td>Indicates that the component should apply the <code class="prettyprint">oj-focus-highlight</code>
       *           class only for focuses not resulting from pointer (touch or mouse) interaction.  (In the built-in themes, the
       *           SASS variable defaults to this value.)</td>
       *     </tr>
       *     <tr>
       *       <td>"all"</td>
       *       <td>Indicates that the component should apply the class for all focuses.</td>
       *     </tr>
       *     <tr>
       *       <td>"none"</td>
       *       <td>Indicates that the component should never apply the class, because the application has taken responsibility
       *           for applying the class when needed for accessibility.</td>
       *     </tr>
       *   </tbody>
       * </table>
       *
       * <h5>Toggling the classes</h5>
       *
       * <p>Components that toggle these focus classes outside of this API must maintain the invariant that
       * <code class="prettyprint">oj-focus-highlight</code> is applied to a given element in a (not necessarily strict) subset
       * of cases that <code class="prettyprint">oj-focus</code> is applied to that element.
       *
       * <p>Typically the specified element should be within the component subtree, in which case the classes will
       * automatically be removed from the element when the component is destroyed, when its <code class="prettyprint">disabled</code>
       * option is set to true, and when <code class="prettyprint">_NotifyDetached()</code> is called.
       *
       * <p>As a minor exception, for components that wrap themselves in a new root node at create time, if the specified
       * element is within the root node's subtree but not within the init node's subtree, then at destroy time only, the
       * classes will not be removed, since <code class="prettyprint">destroy()</code> is expected to remove such nodes.
       *
       * <p>If the element is NOT in the component subtree, then the caller is responsible for removing the classes at the
       * times listed above.
       *
       * <h5>Listeners</h5>
       *
       * <p>If <code class="prettyprint">setupHandlers</code> is not passed, or if <code class="prettyprint">setupHandlers</code>
       * is passed and uses <code class="prettyprint">_on</code> to register its listeners as seen in the example, then
       * the listeners are not invoked when the component is disabled, and the listeners are automatically cleaned up when the
       * component is destroyed.  Otherwise, the caller is responsible for ensuring that the disabled state is handled correctly,
       * and removing the listeners at destroy time.
       *
       * <h5>Related API's</h5>
       *
       * <p>Non-component internal callers should see DomUtils.makeFocusable().  Per its JSDoc (unpublished; see the source), it
       * has a couple of additional usage considerations.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       *
       * @param {(!Object|!jQuery)} options This param can either be the element (convenience syntax for callers needing to
       *   specify only the element(s) that would otherwise have been passed as <code class="prettyprint">options.element</code>)
       *   or an object supporting the following fields:
       * @param {jQuery} options.element The element(s) to receive the <code class="prettyprint">oj-focus</code> classes on focus.
       *   Required if <code class="prettyprint">setupHandlers</code> not passed; ignored otherwise.
       * @param {boolean} options.applyHighlight <code class="prettyprint">true</code> if the <code class="prettyprint">oj-focus-highlight</code>
       *   class should be applied when appropriate.  <code class="prettyprint">false</code> or omitted if that class should never be applied.
       * @param {?function(string)} options.afterToggle Optional callback function called each time the focus classes have been toggled,
       *   after the toggle.  The
       *   string "focusin" or "focusout" is passed, indicating whether the classes were added or removed.  Components
       *   with consistency requirements, such as "<code class="prettyprint">oj-default</code> must be applied iff no state classes such
       *   as <code class="prettyprint">oj-focus</code> are applied," can enforce those rules in this callback.
       * @param {?function()} options.getFocusHighlightPolicy Optional if <code class="prettyprint">applyHighlight</code> is
       *   <code class="prettyprint">true</code>; ignored otherwise.  Components with a component-specific focus policy
       *   mechanism should pass a function that always returns one of the three valid values listed above, keeping in mind
       *   that this method can be called on every focus.  See the example.
       * @param {?function()} options.recentPointer Relevant iff <code class="prettyprint">applyHighlight</code> is
       *   <code class="prettyprint">true</code> and the focus highlight policy is <code class="prettyprint">"nonPointer"</code>;
       *   ignored otherwise.  Recent pointer activity is considered to have occurred if (a) a mouse button or finger has
       *   recently been down or up, or (b) this optional callback function returns true.  Components wishing to additionally take into
       *   account (say) recent pointer <i>movements</i> can supply a function returning true if those movements have been detected,
       *   keeping in mind that this method can be called on every focus.  See the example.
       * @param {?function(function(!jQuery),function(!jQuery))} options.setupHandlers Can be omitted by components whose focus
       *   classes need to be added and removed on focusin and focusout, respectively.  Components needing to add/remove those
       *   classes in response to other events should specify this parameter, which is called once, immediately.  See the examples.
       *
       * @example <caption>Opt into the highlight behavior, and specify a function to be called every time the classes are toggled:</caption>
       * var self = this;
       * this._focusable({
       *     'element': this.element,
       *     'applyHighlight': true,
       *     'afterToggle' : function() {
       *         self._toggleDefaultClasses();
       *     }
       * });
       *
       * @example <caption>Arrange for mouse movement to be considered <u>in addition to</u> mouse/finger up/down.
       *   Also supply a component-specific focusHighlightPolicy:</caption>
       * var self = this;
       * this._focusable({
       *     'element': someElement,
       *     'applyHighlight': true,
       *     'recentPointer' : function() {
       *         // A timestamp-based approach avoids the risk of getting stuck in an inaccessible
       *         // state if (say) mouseenter is not followed by mouseleave for some reason.
       *         var millisSincePointerMove = Date.now() - _myPointerMoveTimestamp;
       *         var isRecent = millisSincePointerMove < myThreshold;
       *         return isRecent;
       *     },
       *     'getFocusHighlightPolicy' : function() {
       *         // Return the value of a component-specific SASS $variable, component option, or other
       *         // component-specific mechanism, either "all", "none", or "nonPointer".  SASS variables
       *         // should be pulled into JS once statically on load, not per-instance or per-focus.
       *     }
       * });
       *
       * @example <caption>Add/remove the focus classes in response to events other than focusin/focusout:</caption>
       * var self = this;
       * this._focusable({
       *     'applyHighlight': myBooleanValue,
       *     'setupHandlers': function( focusInHandler, focusOutHandler) {
       *         self._on( self.element, {
       *             // This example uses focus/blur listeners, which don't bubble, rather than the
       *             // default focusin/focusout (which bubble).  This is useful when one focusable
       *             // element is a descendant of another.
       *             focus: function( event ) {
       *                 focusInHandler($( event.currentTarget ));
       *             },
       *             blur: function( event ) {
       *                 focusOutHandler($( event.currentTarget ));
       *             }
       *         });
       *     }
       * });
       *
       * @example <caption>Alternate usage of <code class="prettyprint">setupHandlers</code>, which simply stashes the
       *   handlers so they can be called from the component's existing handlers:</caption>
       * var self = this;
       * this._focusable({
       *     'applyHighlight': myBooleanValue,
       *     'setupHandlers': function( focusInHandler, focusOutHandler) {
       *         self._focusInHandler = focusInHandler;
       *         self._focusOutHandler = focusOutHandler;
       *     }
       * });
       */
      _focusable: function (options) {
        if (!$.isPlainObject(options)) {
          // eslint-disable-next-line no-param-reassign
          options = { element: options };
        }

        // eslint-disable-next-line no-param-reassign
        options.component = this;
        DomUtils.makeFocusable(options);
      },

      /**
       * Remove all listener references that were attached to the element.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _UnregisterChildNode: function (element) {
        if (element) {
          $(element).off(this.eventNamespace);
          var bindings = this.bindings;
          if (bindings) {
            this.bindings = $(bindings.not(element));
          }
        }
      },

      /**
       * <p>Determines whether the component is LTR or RTL.
       *
       * <p>Component responsibilities:
       *
       * <ul>
       * <li>All components must determine directionality exclusively by calling this protected superclass method.
       *     (So that any future updates to the logic can be made in this one place.)</li>
       * <li>Components that need to know the directionality must call this method at create-time
       *     and from <code class="prettyprint">refresh()</code>, and cache the value.
       * <li>Components should not call this at other times, and should instead use the cached value.  (This avoids constant DOM
       *     queries, and avoids any future issues with component reparenting (i.e. popups) if support for directional islands is added.)</li>
       * </ul>
       *
       * <p>App responsibilities:
       *
       * <ul>
       * <li>The app specifies directionality by setting the HTML <code class="prettyprint">"dir"</code> attribute on the
       *     <code class="prettyprint">&lt;html></code> node.  When omitted, the default is <code class="prettyprint">"ltr"</code>.
       *     (Per-component directionality / directional islands are not currently supported due to inadequate CSS support.)</li>
       * <li>As with any DOM change, the app must <code class="prettyprint">refresh()</code> the component if the directionality changes dynamically.
       *   (This provides a hook for component housekeeping, and allows caching.)</li>
       * </ul>
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @return {string} the reading direction, either <code class="prettyprint">"ltr"</code> or <code class="prettyprint">"rtl"</code>
       * @default <code class="prettyprint">"ltr"</code>
       */
      _GetReadingDirection: function () {
        return DomUtils.getReadingDirection();
      },

      /**
       * <p>Notifies the component that its subtree has been connected to the document programmatically after the component has
       * been created.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _NotifyAttached: function () {
        this._propertyContext = null;
      },

      /**
       * <p>Notifies the component that its subtree has been removed from the document programmatically after the component has
       * been created.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _NotifyDetached: function () {
        this._propertyContext = null;
        this._removeStateClasses(this.widget());
      },

      /**
       * <p>Notifies the component that its subtree is initially visible after the component has
       * been created.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _NotifyInitShown: function () {},

      /**
       * <p>Notifies the component that its subtree has been made visible programmatically after the component has
       * been created.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _NotifyShown: function () {},

      /**
       * <p>Notifies the component that its subtree has been made hidden programmatically after the component has
       * been created.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _NotifyHidden: function () {},

      /**
       * <p>Determines whether this component is effectively disabled, i.e. it has its 'disabled' attribute set to true
       * or it has been disabled by its ancestor component.
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       * @return {boolean} true if the component has been effectively disabled, false otherwise
       */
      _IsEffectivelyDisabled: function () {
        return !!(this.options.disabled || this._ancestorDisabled);
      },

      /**
       * <p>Sets the ancestor-provided disabled state on this component.
       *
       * @memberof oj.baseComponent
       * @instance
       * @private
       * @param {boolean} disabled - true if this component is being disabled by its ancestor component, false otherwise
       */
      __setAncestorComponentDisabled: function (disabled) {
        this._ancestorDisabled = disabled;
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _getTranslationSectionLoader: function () {
        var sectionNames = [];

        var self = this;

        var index = 0;

        this._traverseWidgetHierarchy(function (proto) {
          // retrive translation section name for the widget and all of its ancestors

          // Since _GetTranslationsSectionName() is a protected method, we can only call it on the widget instance.
          // For superclases, we will assume that their section names can only be their full widget name

          var name = index === 0 ? self._GetTranslationsSectionName() : proto.widgetFullName;
          index += 1;

          var section = Translations.getComponentTranslations(name);

          if (section != null && !$.isEmptyObject(section)) {
            sectionNames.push(name);
          }
        });

        var count = sectionNames.length;

        if (count > 0) {
          return function () {
            // Optimize for the most common case where superclasses do not define translations
            if (count === 1) {
              return Translations.getComponentTranslations(sectionNames[0]);
            }

            var trs = {};

            for (var i = count - 1; i >= 0; i--) {
              $.widget.extend(trs, Translations.getComponentTranslations(sectionNames[i]));
            }

            return trs;
          };
        }
        return null;
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _getDynamicPropertyContext: function () {
        if (!this._propertyContext) {
          var c = {};
          this._propertyContext = c;
          var element = this.element[0];
          c.containers = _getSpecialContainerNames(element);
          c.element = element;
          c.isCustomElement = this._IsCustomElement();
          if (c.isCustomElement) c.customElement = this._getRootElement();
        }
        return this._propertyContext;
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _setupDefaultOptions: function (originalDefaults, constructorOptions) {
        var options = this.options;

        // Load component translations
        var translationLoader = this._getTranslationSectionLoader();

        var currVal = constructorOptions[_OJ_TRANSLATIONS_OPTION];

        if (translationLoader != null && (currVal === undefined || $.isPlainObject(currVal))) {
          _defineDynamicProperty(
            this,
            undefined,
            constructorOptions[_OJ_TRANSLATIONS_OPTION],
            options,
            _OJ_TRANSLATIONS_OPTION,
            translationLoader
          );
        }

        // Load options specified with oj.Components.setDefaultOptions()
        this._loadGlobalDefaultOptions(originalDefaults, constructorOptions);
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _loadGlobalDefaultOptions: function (originalDefaults, constructorOptions) {
        var options = this.options;

        var widgetHierNames = [];

        // walk up the widget hierarchy
        this._traverseWidgetHierarchy(function (proto) {
          widgetHierNames.push(proto.widgetName);
        });

        widgetHierNames.push('default');

        // get properties applicable to this component
        var defaults = Components.__getDefaultOptions(widgetHierNames);
        this._globalDefaults = defaults;

        if ($.isEmptyObject(defaults)) {
          return;
        }

        var self = this;

        var contextCallback = function () {
          return self._getDynamicPropertyContext();
        };

        var props = Object.keys(defaults);
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          var val = constructorOptions[prop];

          if (val === undefined || $.isPlainObject(val)) {
            var defaultValueList = defaults[prop];
            if (defaultValueList) {
              var callback = _getCompoundDynamicGetter(defaultValueList);
              if (callback) {
                _defineDynamicProperty(
                  this,
                  originalDefaults[prop],
                  val,
                  options,
                  prop,
                  callback,
                  contextCallback
                );
              } else {
                var list = [originalDefaults[prop]].concat(defaultValueList);
                list.push(val);
                options[prop] = _mergeOptionLayers(list);
              }
            }
          }
        }
      },

      /**
       * For Preact binding providers, sparse objects originating from VDOM trees should always be merged with default options.
       * This method processes an object containing (top-level) property name-value pairs and returns a new object where the
       * simple object values have been merged with defaults as appropriate
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _MergeOptionsWithDefaults: function (options) {
        let context;
        return Object.keys(options).reduce((newOptions, property) => {
          // Note that we are are not handling the case where property === 'translations' for now.
          // This could presumably be dealt with here by wiring directly to _getTranslationSectionLoader,
          // but punting for now on the assumption that it's not going to be common for people to try
          // setting instance-level translation overrides within VDOM
          const value = options[property];
          const defaultValue = this._originalDefaults[property];
          let globalDefaultValueList = this._globalDefaults[property]?.map((globalDefaultValue) => {
            if (globalDefaultValue != null && globalDefaultValue instanceof __ojDynamicGetter) {
              if (!context) {
                context = this._getDynamicPropertyContext();
              }
              return globalDefaultValue.getCallback()(context);
            }
            return globalDefaultValue;
          });
          // eslint-disable-next-line no-param-reassign
          newOptions[property] = _mergeOptionLayers(
            [defaultValue, ...(globalDefaultValueList || []), value],
            null,
            true
          );
          return newOptions;
        }, {});
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _traverseWidgetHierarchy: function (callback) {
        var proto = this.constructor.prototype;
        while (proto != null && proto.namespace === 'oj') {
          callback(proto);
          proto = Object.getPrototypeOf(proto);
        }
      },

      /**
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _getRootElement: function () {
        return this.OuterWrapper || this.element[0];
      },

      /**
       * Determines whether the component is being rendered as a custom element.
       * @return {boolean} True if the component is being rendered as a custom element
       *
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _IsCustomElement: function () {
        return ojcustomelementRegistry.isElementRegistered(this._getRootElement().tagName);
      },

      /**
       * Provides a promise for JET's Knockout throttling timeout
       * @return {Promise} a promise for JET's Knockout throttling timeout completing or a promise that will be resolved immediately for the case
       * when there is no outstanding throttling timeout
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _GetThrottlePromise: function () {
        if (this._IsCustomElement()) {
          var elem = this._getRootElement();
          return ojcustomelementUtils.CustomElementUtils.getElementBridge(elem).getThrottlePromise();
        }
        return Promise.resolve(null);
      },

      /**
       * Prepares a custom renderer context object for either the JQuery or custom element syntax,
       * removing and exposing keys as needed.
       * @param {Object} context The renderer context object.
       * @return {Object} The cleaned up renderer context.
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      _FixRendererContext: function (context) {
        if (this._IsCustomElement()) {
          // Do a shallow copy to avoid setter/getters from being lost
          var contextCopy = oj.CollectionUtils.copyInto({}, context);
          // remove component or widget constructor references and expose element reference instead
          delete contextCopy.component;
          contextCopy.componentElement = this._getRootElement();
          return contextCopy;
        }
        return context;
      },

      /**
       * This method retrieves root custom element that is used by TemplateEngine
       * loader to determine the type of template engine to load - legacy or preact with or without knockout.
       *
       * @returns {Element}
       * @protected
       * @instance
       * @memberof oj.baseComponent
       */
      _GetCustomElement: function () {
        return this._getRootElement();
      },

      /**
       * Returns a wrapper function for custom elements that converts an object
       * returned by a custom renderer into an old format supported by widgets
       * @param {Function} origRenderer Renderer function called to create custom content
       * @return {Function} A wrapper function that will used to convert result into toolkit format
       * @protected
       * @memberof oj.baseComponent
       */
      _WrapCustomElementRenderer: function (origRenderer) {
        if (this._IsCustomElement() && typeof origRenderer === 'function') {
          return function (context) {
            var obj = origRenderer(context);
            return obj && obj.insert ? obj.insert : null;
          };
        }
        return origRenderer;
      },

      /**
       * Stores a map of writeback options that we reference during option comparison.
       * Package private method called from the CustomElementBridge.
       * @param  {Object} options The writeback options map
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __saveWritebackOptions: function (options) {
        this._writebackOptions = options;
      },

      /**
       * Returns true if an option should be written back.
       * @param  {string} option The option to lookup
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      _getWritebackOption: function (option) {
        if (this._writebackOptions && this._writebackOptions[option]) {
          return true;
        }
        return false;
      },

      /**
       * Called by oj.Components.subtreeAttached and will only call _NotifyAttached
       * for non custom elements. Custom elements are notified when they are
       * attached from the DOM so oj.Components.subtreeAttached is unnecessary.
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __handleSubtreeAttached: function () {
        if (!this._IsCustomElement()) {
          this._NotifyAttached();
        }
      },

      /**
       * Called by oj.Components.subtreeAttached and will only call _NotifyDetached
       * for non custom elements. Custom elements are notified when they are
       * detached from the DOM so oj.Components.subtreeDetached is unnecessary.
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __handleSubtreeDetached: function () {
        if (!this._IsCustomElement()) {
          this._NotifyDetached();
        }
      },

      /**
       * Whether special handling is needed for connected and disconnected ops
       * @return {boolean} returns true if the component wants to suppress disconnect and connect operations that happened
       *                   in quick succession, since they can be very expensive.  Returns false otherwise, which is the default.
       * @memberof oj.baseComponent
       * @protected
       */
      _VerifyConnectedForSetup: function () {
        return false;
      },

      /**
       * Whether this component supports having its connected notifications (and disconnected suppressions) suspended if
       * the connection occurs inside a DOM tree marked with the data-oj-suspend attribute.  This can be useful in narrow cases
       * where we want to keep DOM connected so that we don't lose knockout subscriptions, but also don't want to perform any
       * expensive operations (e.g. data fetches) until the component is reparented to an active, visible container
       * @return {boolean} returns true if the component should treat connects to (and disconnected from) a data-oj-suspend container as NOPs
       * @memberof oj.baseComponent
       * @protected
       */
      _AllowConnectedSuspension: function () {
        return false;
      },

      /**
       * Called by the CustomElementBridge when the custom element is attached
       * to the DOM.
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __handleConnected: function () {
        if (this._AllowConnectedSuspension()) {
          const element = this._getRootElement();
          if (element?.closest('[data-oj-suspend]')) {
            this._suspendedConnect = true;
            return;
          }
        }
        this._NotifyAttached();
        if (!this.__delayConnectDisconnect(_STATE_CONNECTED)) {
          this._SetupResources();
        }
      },

      /**
       * Called by the CustomElementBridge when the custom element is detached
       * from the DOM.
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __handleDisconnected: function () {
        if (this._suspendedConnect) {
          this._suspendedConnect = false;
          return;
        }
        // note that when it is delayed, then NotifyDetached would be called before ReleaseResources
        // this is fine for all the components that will use delayed disconnect, will need to re-visit if that is not the case.
        if (!this.__delayConnectDisconnect(_STATE_DISCONNECTED)) {
          this._ReleaseResources();
        }
        this._NotifyDetached();
      },

      /**
       * Delay the call to SetupResources and ReleaseResources as part of connected and disconnected.
       * See _verifyConnectedForSetup method for details.
       * @return {boolean} true if SetupResources/ReleaseResources has been delayed, false otherwise.
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __delayConnectDisconnect: function (state) {
        if (!this._VerifyConnectedForSetup()) {
          return false;
        }

        if (this.connectedState === undefined) {
          window.queueMicrotask(
            function () {
              if (this.connectedState === state) {
                if (state === _STATE_CONNECTED) {
                  this._SetupResources();
                } else {
                  this._ReleaseResources();
                }
              }
              this.connectedState = undefined;
            }.bind(this)
          );
        }
        this.connectedState = state;

        return true;
      },

      /**
       * Method called by the CustomElementBridge to notify the component of changes to
       * any watched attributes registered in its metadata extension._WATCHED_ATTRS property.
       * @param {string} attr The name of the watched attribute
       * @param {string} oldValue The old attribute value
       * @param {string} newValue The new attribute value
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __handleWatchedAttribute: function (attr, oldValue, newValue) {
        this._WatchedAttributeChanged(attr, oldValue, newValue);
      },

      /**
       * Method for components to override in order to handle changes to watched attributes.
       * @param {string} attr The name of the watched attribute
       * @param {string} oldValue The old attribute value
       * @param {string} newValue The new attribute value
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      _WatchedAttributeChanged: function (attr, oldValue, newValue) {},

      /**
       * Method called by the CustomElementBridge to get the element to call focus on for this custom element
       * which can be the root custom element or an HTML element like an input or select.
       * @return {Element}
       * @memberof oj.baseComponent
       * @instance
       * @private
       */
      __getFocusElement: function () {
        return this.GetFocusElement();
      },

      /**
       * Returns the current focusable element for this component which can be the root custom element
       * or an HTML element like an input or select.
       * @return {Element}
       * @memberof oj.baseComponent
       * @instance
       * @protected
       */
      GetFocusElement: function () {
        return this.element[0];
      }

      /**
       * Under normal circumstances this class is applied automatically. It is documented here for the rare cases that an app
       * developer needs per-instance control.
       *
       * <p>The <code class="prettyprint">oj-focus-highlight</code> class applies focus styling that may not be desirable when
       * the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus
       * occurs by a non-pointer mechanism, for example keyboard or initial page load.
       *
       * <p>The application-level behavior for this component is controlled in the theme by the
       * <code class="prettyprint">$focusHighlightPolicy</code> SASS variable; however, note that this same variable controls
       * the focus highlight policy of many components and patterns. The values for the variable are:
       *
       * <ul>
       *   <li><code class="prettyprint">nonPointer</code>: <code class="prettyprint">oj-focus-highlight</code> is applied only
       *       when focus is not the result of pointer interaction. Most themes default to this value.</li>
       *   <li><code class="prettyprint">all</code>: <code class="prettyprint">oj-focus-highlight</code> is applied regardless
       *       of the focus mechanism.</li>
       *   <li><code class="prettyprint">none</code>: <code class="prettyprint">oj-focus-highlight</code> is never applied. This
       *       behavior is not accessible, and is intended for use when the application wishes to use its own event listener to
       *       precisely control when the class is applied (see below). The application must ensure the accessibility of the result.</li>
       * </ul>
       *
       * <p>To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use
       * event listeners to toggle this class as needed.
       *
       * @ojfragment ojFocusHighlightDoc - For use in the Styling table of components using the oj-focus-highlight class with the
       *    $focusHighlightPolicy var.  Components using that class with a component-specific mechanism instead of that $var will need
       *    different verbiage, which could be decomped to another baseComponent fragment if shareable by multiple components.
       * @memberof oj.baseComponent
       */
    });

    // Remove base component from the jQuery prototype, so it could not be created
    // directly by page authors

    delete $.fn[_BASE_COMPONENT];
  })(); // end of BaseComponent wrapper function

  // -----------------------------------------------------------------------------
  // End of baseComponent, start of other content
  // -----------------------------------------------------------------------------

  /**
   * <p>This method is our version of $.widget, i.e. the static initializer of a component such as ojButton.
   * It calls that method, plus does any other static init we need.
   *
   * TODO:
   * - Consider moving this method into its own file.
   * - For base param, make the type oj.baseComponent rather than Object, but need to declare that as a type first.  Review how that's done.
   *
   * @private
   * @param {string} name typically of the form "oj.ojMenu"
   * @param {Object} base NOT optional (unlike JQUI)
   * @param {Object} prototype
   * @param {boolean=} isHidden - if true, indicates that the component name should not
   * be available on jQuery prototype
   */
  oj.__registerWidget = function (name, base, prototype, isHidden) {
    $.widget(name, base, prototype);

    if (isHidden) {
      var globalName = name.split('.')[1];
      delete $.fn[globalName];
    }

    // create single-OJ pseudo-selector for component, e.g. ":oj-menu", in addition to the ":oj-ojMenu" that $.widget() creates.
    // for private components it will begin with an underscore, e.g.,  ":_oj-radio"
    if (name.substring(0, 5) === 'oj.oj' || name.substring(0, 6) === 'oj._oj') {
      var nameArray = name.split('.'); // ["oj", "ojMenu"], ["oj", "_ojRadio"]
      var namespace = nameArray[0]; // "oj"
      var simpleName = nameArray[1]; // "ojMenu", "_ojRadio"
      var fullName = namespace + '-' + simpleName; // "oj-ojMenu", "oj-_ojRadio"
      var isPrivate = simpleName.substring(0, 1) === '_';
      // if private, make the single-oj pseudo-selector start with an underscore, like this -> "_oj-radio"
      var modifiedFullName; // "oj-Menu", "_oj-Radio".  Lowercased below.
      if (isPrivate) {
        modifiedFullName = '_' + namespace + '-' + simpleName.substring(3);
      } else {
        modifiedFullName = namespace + '-' + simpleName.substring(2);
      }

      // Capitalization doesn't seem to matter with JQ pseudos, e.g. for the existing double-oj pseudo, both $(":oj-ojMenu") and $(":oj-ojmenu") work.
      // So, follow JQUI's pattern of using toLowerCase here, which will lowercase not only the "M' in "Menu", but also any camelcased chars after that.
      $.expr.pseudos[modifiedFullName.toLowerCase()] = function (elem) {
        return !!$.data(elem, fullName);
      };
    }
  };

  /**
   * @param {Object} self
   * @param {Object|undefined} originalDefaultValue
   * @param {?Object} constructorValue
   * @param {!Object} options
   * @param {string} prop
   * @param {Function} getter
   * @param {Function=} contextCallback
   * @private
   */
  function _defineDynamicProperty(
    self,
    originalDefaultValue,
    constructorValue,
    options,
    prop,
    getter,
    contextCallback
  ) {
    var override = constructorValue;
    var replaced = false;
    var overriddenSubkeys = {};

    // eslint-disable-next-line no-param-reassign
    delete options[prop];

    Object.defineProperty(options, prop, {
      get: function () {
        // Once the option is replaced, we no longer merge in defaults
        if (replaced) {
          return override;
        }

        if (self._settingNestedKey != null) {
          // The getter is getting called from the option() method that will be mutating the current
          // object. We need to return only the override portion in this case to avoid the defaults being
          // reapplied as an override

          return override;
        }

        var defaultVal = getter(contextCallback ? contextCallback() : prop);

        return _mergeOptionLayers([originalDefaultValue, defaultVal, override], overriddenSubkeys);
      },
      set: function (value) {
        override = value;

        if (self._settingNestedKey != null) {
          overriddenSubkeys[self._settingNestedKey] = true;
        } else {
          // The entire option has been replaced
          replaced = true;
        }
      },
      enumerable: true
    });
  }

  /**
   * @ignore
   */
  function _getCompoundDynamicGetter(values) {
    if (values.length === 1) {
      var val = values[0];
      return val instanceof __ojDynamicGetter ? val.getCallback() : null;
    }

    var hasGetters = false;
    for (var i = 0; i < values.length && !hasGetters; i++) {
      var value = values[i];
      if (value != null && value instanceof __ojDynamicGetter) {
        hasGetters = true;
      }
    }

    if (hasGetters) {
      return function (context) {
        var resolvedVals = [];
        values.forEach(function (_value) {
          if (_value != null && _value instanceof __ojDynamicGetter) {
            resolvedVals.push(_value.getCallback()(context));
          } else {
            resolvedVals.push(_value);
          }
        });

        return _mergeOptionLayers(resolvedVals);
      };
    }

    return null;
  }

  /**
   * @private
   */
  function _getSpecialContainerNames(element) {
    var elem = element;
    var containers = [];
    while (elem) {
      var ga = elem.getAttribute;
      var name = ga ? ga.call(elem, Components._OJ_CONTAINER_ATTR) : null;
      if (name != null) {
        containers.push(name);
      }
      elem = elem.parentNode;
    }

    return containers;
  }

  /**
   * @private
   */
  function _storeWidgetName(element, widgetName) {
    var data = element.data(_OJ_WIDGET_NAMES_DATA);
    if (!data) {
      data = [];
      element.data(_OJ_WIDGET_NAMES_DATA, data);
    }
    if (data.indexOf(widgetName) < 0) {
      data.push(widgetName);
    }
  }

  /**
   * @private
   */
  function _removeWidgetName(element, widgetName) {
    var data = element.data(_OJ_WIDGET_NAMES_DATA);
    if (data) {
      var index = data.indexOf(widgetName);
      if (index >= 0) {
        data.splice(index, 1);
        if (data.length === 0) {
          element.removeData(_OJ_WIDGET_NAMES_DATA);
        }
      }
    }
  }

  /**
   * @private
   * @param {Array} values - values to merge
   * @param {Object=} overriddenSubkeys subkeys where the merging should not occur, i.e.
   * @param {boolean=} avoidClones indicates whether to avoid creating new objects when merge an object onto a non-object
   * the value from corresponsing subkey on the last element of values array should win
   */
  function _mergeOptionLayers(values, overriddenSubkeys, avoidClones) {
    var result;
    for (var i = 0; i < values.length; i++) {
      var value = values[i];
      if (value !== undefined) {
        if ($.isPlainObject(value)) {
          const plainObjectResult = $.isPlainObject(result);
          // If merging an object onto a non-object and avoidClones is set, just replace result with value
          if (!plainObjectResult && avoidClones) {
            result = value;
          } else {
            var input = plainObjectResult ? [result, value] : [value];
            // The last object (overrides) is always fully merged in
            result = _mergeObjectsWithExclusions(
              {},
              input,
              i === values.length - 1 ? null : overriddenSubkeys,
              null,
              avoidClones
            );
          }
        } else {
          result = value;
        }
      }
    }
    return result;
  }

  /**
   * @private
   */
  function _mergeObjectsWithExclusions(target, input, ignoreSubkeys, basePath, avoidClones) {
    var inputLength = input.length;

    for (var inputIndex = 0; inputIndex < inputLength; inputIndex++) {
      var source = input[inputIndex];
      var keys = Object.keys(source);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var path;
        if (ignoreSubkeys == null) {
          path = null;
        } else if (basePath == null) {
          path = key;
        } else {
          path = basePath + '.' + key;
        }
        // Ignore all sources when the current path is registered in ignoreSubkeys
        if (ignoreSubkeys == null || !ignoreSubkeys[path]) {
          var value = source[key];
          if (value !== undefined) {
            if ($.isPlainObject(value)) {
              const plainObjectTarget = $.isPlainObject(target[key]);
              // If merging an object onto a non-object and avoidClones is set, just replace target with value
              if (!plainObjectTarget && avoidClones) {
                // eslint-disable-next-line no-param-reassign
                target[key] = value;
              } else {
                var params = plainObjectTarget ? [target[key], value] : [value];
                // eslint-disable-next-line no-param-reassign
                target[key] = _mergeObjectsWithExclusions(
                  {},
                  params,
                  ignoreSubkeys,
                  path,
                  avoidClones
                );
              }
            } else {
              // eslint-disable-next-line no-param-reassign
              target[key] = value;
            }
          }
        }
      }
    }
    return target;
  }

  /**
   * @private
   */
  function _returnTrue() {
    return true;
  }

  /**
   * Returns an object with context for the given child DOM node. This will always contain the subid for the node,
   * defined as the 'subId' property on the context object. Additional component specific information may also be included.
   *
   * For more details on returned objects, see <a href="#contextobjects-section">context objects</a>.
   *
   * @ojfragment nodeContextDoc
   * @memberof oj.baseComponent
   */

  /**
   * The child DOM node
   *
   * @ojfragment nodeContextParam
   * @memberof oj.baseComponent
   */

  /**
   * The context for the DOM node, or <code class="prettyprint">null</code> when none is found.
   *
   * @ojfragment nodeContextReturn
   * @memberof oj.baseComponent
   */

  /**
   * // Returns {'subId': 'oj-some-sub-id', 'componentSpecificProperty': someValue, ...}
   * var context = myComponent.getContextByNode(nodeInsideElement);
   *
   * @ojfragment nodeContextExample
   * @memberof oj.baseComponent
   */

  /**
   * <p>The contextMenu slot is set on the <code class="prettyprint">oj-menu</code> within this element.
   * This is used to designate the JET Menu that this component should launch as a context menu on right-click, Shift-F10, Press & Hold, or component-specific gesture.
   * If specified, the browser's native context menu will be replaced by the JET Menu specified in this slot.
   * <p>
   * The application can register a listener for the Menu's ojBeforeOpen event. The listener can cancel the launch via event.preventDefault(),
   * or it can customize the menu contents by editing the menu DOM directly, and then calling refresh() on the Menu.
   * <p>
   * To help determine whether it's appropriate to cancel the launch or customize the menu, the ojBeforeOpen listener can use component API's to determine which
   * table cell, chart item, etc., is the target of the context menu. See the JSDoc of the individual components for details.
   * <p>
   * Keep in mind that any such logic must work whether the context menu was launched via right-click, Shift-F10, Press & Hold, or component-specific touch gesture.
   *
   * @ojslot contextMenu
   * @memberof oj.baseComponent
   * @ojpreferredcontent ["MenuElement"]
   * @ojdeprecated {since: '13.0.0', description: 'This web component no longer supports launching a context menu.'}
   * @ojshortdesc The contextMenu slot is set on the oj-menu instance within this element.  It designates the JET Menu to launch as a context menu.
   * @ojmaxitems 1
   *
   * @example <caption>Initialize the component with a context menu:</caption>
   * &lt;oj-some-element>
   *     &lt;-- use the contextMenu slot to designate this as the context menu for this component -->
   *     &lt;oj-menu slot="contextMenu" style="display:none" aria-label="Some element's context menu">
   * ...
   *     &lt;/oj-menu>
   * &lt;/oj-some-element>
   */

  /**
   * Sets a property or a subproperty (of a complex property) and notifies the component
   * of the change, triggering a [property]Changed event.
   * The value should be of the same type as the type of the attribute mentioned in this API document.
   *
   * @function setProperty
   * @since 4.0.0
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   *
   * @expose
   * @memberof oj.baseComponent
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @instance
   *
   * @ojtsexample <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves the value of a property or a subproperty.
   * The return type will be the same as the type of the property as specified in this API document.
   * If the method is invoked with an incorrect property/subproperty name, it returns undefined.
   * @function getProperty
   * @since 4.0.0
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   *
   * @expose
   * @memberof oj.baseComponent
   * @ojshortdesc Retrieves the value of a property or a subproperty.
   * @instance
   *
   * @ojtsexample <caption>Get a single subproperty of a complex property:</caption>
   * let subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Performs a batch set of properties.
   * The type of value for each property being set must match the type of the property as specified in this
   * API document.
   * @function setProperties
   * @since 4.0.0
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   *
   * @expose
   * @memberof oj.baseComponent
   * @ojshortdesc Performs a batch set of properties.
   * @instance
   *
   * @ojtsexample <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */

  // override jQuery's cleanData method to bypass cleanup of custom elements and composites
  $.cleanData = (function (orig) {
    return function (elems) {
      const nonCustomElements = [];
      const customElementsToClean = [];
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (elem == null) {
          break;
        }

        // Skip cleaning any elements that are custom elements or are created by a custom element
        var bSkip = false;
        var constr = Components.__GetWidgetConstructor(elem);
        if (constr) {
          bSkip = constr('instance')._IsCustomElement();
          if (!bSkip) {
            var parent = Components.getComponentElementByNode(elem);
            bSkip = parent && ojcustomelementRegistry.isElementRegistered(parent.tagName);
          }
        }
        if (!bSkip) {
          nonCustomElements.push(elem);
        } else if (elem.$$cleanElement) {
          customElementsToClean.push(elem);
        }
      }
      if (nonCustomElements.length > 0) {
        orig(nonCustomElements);
      }
      customElementsToClean.forEach((item) => item.$$cleanElement());
    };
  })($.cleanData);

  // Override addClass + removeClass to use classList instead of add/removeAttribute in order
  // to avoid conflicting with fixes to work with Preact's class patching logic

  // Copied from jQuery
  function getClass(elem) {
    return (elem.getAttribute && elem.getAttribute('class')) || '';
  }

  $.fn.addClass = function (value) {
    if (typeof value === 'function') {
      return this.each(function (j) {
        $(this).addClass(value.call(this, j, getClass(this)));
      });
    }

    const iterableClasses = Array.isArray(value) ? value : ojcustomelementUtils.CustomElementUtils.getClassSet(value);
    this.each(function () {
      if (this.nodeType === 1) {
        this.classList.add(...iterableClasses);
      }
    });
    return this;
  };

  $.fn.removeClass = function (value) {
    if (typeof value === 'function') {
      return this.each(function (j) {
        $(this).removeClass(value.call(this, j, getClass(this)));
      });
    }

    if (!arguments.length) {
      return this.attr('class', '');
    }

    const iterableClasses = Array.isArray(value) ? value : ojcustomelementUtils.CustomElementUtils.getClassSet(value);
    this.each(function () {
      if (this.nodeType === 1) {
        this.classList.remove(...iterableClasses);
      }
    });
    return this;
  };

  /**
   * @export
   * @class
   * @since 1.0
   * @classdesc Common test support in JavaScript
   * @ojtsignore
   */
  const Test = {};
  oj._registerLegacyNamespaceProp('Test', Test);

  /**
   * A global application flag that can be set by a test to indicate that all page startup processing is done
   * and an external automated test can begin
   * @export
   * @type {boolean}
   */
  Test.ready = false;

  /**
   * @export
   * Return the node found given the locator
   * @param {Object|string} locator A locator which is either a JSON string (to be parsed using $.parseJSON), or an Object with the following properties:
   *                                             element: the component's selector, determined by the test author when laying out the page
   *                                             subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   *  @returns {any} the subcomponent located by the subId string passed in locator, if found.
   */
  Test.domNodeForLocator = function (locator) {
    var locObj = locator;
    if (oj.StringUtils.isString(locator)) {
      var locStr = /** @type {string} */ (locator);
      try {
        locObj = JSON.parse(locStr);
      } catch (e) {
        return null;
      }
    }
    if (locObj && locObj.element) {
      var element = $(locObj.element);
      if (element && element.length > 0) {
        delete locObj.element;
        var id = /** @type {Object} */ (locObj);
        return Components.getNodeBySubId(element[0], id);
      }
    }
    return null;
  };

  /**
   * @return {number} total number of open popups
   * @export
   * @since 1.1.0
   */
  Test.getOpenPopupCount = function () {
    return oj.ZOrderUtils.getOpenPopupCount();
  };

  /**
   * Returns a jQuery set of popup root elements that are open and actively
   * managed by the popup framework.
   *
   * @return {!jQuery}
   * @export
   * @since 1.1.0
   */
  Test.findOpenPopups = function () {
    return oj.ZOrderUtils.findOpenPopups();
  };

  /**
   * Utility used for testing. Compares two jQuery singleton wappered elements
   * determining which element has the greatest stacking context.
   *
   * @export
   * @param {jQuery} el1 first element to compare
   * @param {jQuery} el2 second element to compare
   * @return {number} 0 if elements have the same stacking context;
   *                  1 if the first element has a greater stacking context;
   *                 -1 when the second element has a greater stacking context;
   * @since 1.1.0
   */
  Test.compareStackingContexts = function (el1, el2) {
    return oj.ZOrderUtils.compareStackingContexts(el1, el2);
  };

  const subtreeAttached = Components.subtreeAttached;
  const subtreeDetached = Components.subtreeDetached;
  const subtreeHidden = Components.subtreeHidden;
  const subtreeShown = Components.subtreeShown;
  const createDynamicPropertyGetter = Components.createDynamicPropertyGetter;
  const setDefaultOptions = Components.setDefaultOptions;
  const getDefaultOptions = Components.getDefaultOptions;
  const __GetWidgetConstructor = Components.__GetWidgetConstructor;
  const setComponentOption = Components.setComponentOption;
  const getComponentOption = Components.getComponentOption;
  const getWidgetConstructor = Components.getWidgetConstructor;
  const isComponentInitialized = Components.isComponentInitialized;
  const markPendingSubtreeHidden = Components.markPendingSubtreeHidden;
  const unmarkPendingSubtreeHidden = Components.unmarkPendingSubtreeHidden;
  const __getDefaultOptions = Components.__getDefaultOptions;
  const getComponentElementByNode = Components.getComponentElementByNode;
  const getSubIdByNode = Components.getSubIdByNode;
  const getNodeBySubId = Components.getNodeBySubId;
  const callComponentMethod = Components.callComponentMethod;
  const _OJ_CONTAINER_ATTR = Components._OJ_CONTAINER_ATTR;

  exports._OJ_CONTAINER_ATTR = _OJ_CONTAINER_ATTR;
  exports.__GetWidgetConstructor = __GetWidgetConstructor;
  exports.__getDefaultOptions = __getDefaultOptions;
  exports.callComponentMethod = callComponentMethod;
  exports.createDynamicPropertyGetter = createDynamicPropertyGetter;
  exports.getComponentElementByNode = getComponentElementByNode;
  exports.getComponentOption = getComponentOption;
  exports.getDefaultOptions = getDefaultOptions;
  exports.getNodeBySubId = getNodeBySubId;
  exports.getSubIdByNode = getSubIdByNode;
  exports.getWidgetConstructor = getWidgetConstructor;
  exports.isComponentInitialized = isComponentInitialized;
  exports.markPendingSubtreeHidden = markPendingSubtreeHidden;
  exports.setComponentOption = setComponentOption;
  exports.setDefaultOptions = setDefaultOptions;
  exports.subtreeAttached = subtreeAttached;
  exports.subtreeDetached = subtreeDetached;
  exports.subtreeHidden = subtreeHidden;
  exports.subtreeShown = subtreeShown;
  exports.unmarkPendingSubtreeHidden = unmarkPendingSubtreeHidden;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojhtmlutils',['exports'], function (exports) { 'use strict';

  /**
   * @namespace
   * @hideconstructor
   * @ojtsmodule
   *
   * @since 6.1.0
   * @classdesc
   * <p>Utility class with functions for preprocessing HTML content.</p>
   * <p><b>Note,</b> the utility methods do not validate HTML input provided by an application
   * for integrity or security violations. It is the application's responsibility to sanitize
   * the input to prevent unsafe content from being added to the page.</p>
   */
  const HtmlUtils = {};

  /**
   * Utility that will parse an HTML string into an array of DOM Nodes.
   * @param {string} html The HTML string to parse.
   * @return {Array<Node>}
   * @memberof! HtmlUtils
   * @static
   */
  HtmlUtils.stringToNodeArray = function (html) {
    // escape html for the predefined tags
    var tags = [
      'table',
      'caption',
      'colgroup',
      'col',
      'thead',
      'tfoot',
      'th',
      'tbody',
      'tr',
      'td',
      'template',
      'p'
    ];
    var i;

    for (i = 0; i < tags.length; i++) {
      // eslint-disable-next-line no-param-reassign
      html = _escapeTag(tags[i], html);
    }
    // convert tags into DOM structure
    var container = document.createElement('div');
    container.innerHTML = html; // @HTMLUpdateOK html is the oj-module or composite View which does not come from the end user
    if (html.indexOf('<oj-bind-replace-') !== -1) {
      _unescapeTag(container);
    }

    // convert child nodes to nodes array accepted by oj-module element
    var nodesArray = [];
    while (container.firstChild) {
      nodesArray.push(container.firstChild);
      container.removeChild(container.firstChild);
    }
    return nodesArray;
  };

  /**
   * Utility that will clone the content of a template node and return
   * an array of DOM Nodes.
   * @param {Node} node The template node to retrieve the content for.
   * @return {Array<Node>}
   * @memberof! HtmlUtils
   * @static
   */
  HtmlUtils.getTemplateContent = function (node) {
    var nodes = [];

    if (node.nodeType === 1 && node.tagName.toLowerCase() === 'template') {
      var content = node.content;
      if (content) {
        nodes.push(document.importNode(content, true));
      } else {
        Array.prototype.forEach.call(node.childNodes, function (child) {
          nodes.push(child.cloneNode(true));
        });
      }
    } else {
      throw new Error('Invalid template node ' + node);
    }

    return nodes;
  };

  /**
   * @private
   */
  function _escapeTag(from, str) {
    var startTag = new RegExp('<' + from + '(?=\\s|>)', 'gi');
    var endTag = new RegExp('</' + from + '(?=\\s|>)', 'gi');
    return str
      .replace(startTag, '<oj-bind-replace-' + from)
      .replace(endTag, '</oj-bind-replace-' + from);
  }

  /**
   * @private
   */
  function _unescapeTag(parent) {
    // replace '<oj-bind-replace-tag' with the original <tag in the array of DOM nodes
    var children = parent.childNodes;
    var len = children.length;
    for (var i = 0; i < len; i++) {
      var child = children[i];
      _unescapeTag(child);
      var nodeName = child.nodeName.toLowerCase();
      var j;
      var attr;
      var replNode;

      const BIND_REPLACE = 'oj-bind-replace-';
      if (nodeName.substr(0, 16) === BIND_REPLACE) {
        var replName = nodeName.substr(16);
        replNode = document.createElement(replName); // @HTMLUpdateOK
        for (j = 0; j < child.attributes.length; j++) {
          attr = child.attributes[j];
          replNode.setAttribute(attr.name, attr.value); // @HTMLUpdateOK
        }
        var childHolder = replNode.content ? replNode.content : replNode;
        for (j = 0; child.childNodes.length > 0; ) {
          childHolder.appendChild(child.childNodes[0]);
        }
        parent.replaceChild(replNode, child);
      } else if (nodeName === 'script' || nodeName === 'style') {
        replNode = document.createElement(nodeName); // @HTMLUpdateOK
        for (j = 0; j < child.attributes.length; j++) {
          attr = child.attributes[j];
          replNode.setAttribute(attr.name, attr.value); // @HTMLUpdateOK
        }
        var origHTML = child.innerHTML; // @HTMLUpdateOK
        replNode.innerHTML = origHTML.replace(new RegExp(BIND_REPLACE, 'g'), ''); // @HTMLUpdateOK
        parent.replaceChild(replNode, child);
      } else if (child.nodeType === 8) {
        // comment node
        var origValue = child.nodeValue;
        child.nodeValue = origValue.replace(new RegExp(BIND_REPLACE, 'g'), '');
      }
    }
  }

  const stringToNodeArray = HtmlUtils.stringToNodeArray;
  const getTemplateContent = HtmlUtils.getTemplateContent;

  exports.getTemplateContent = getTemplateContent;
  exports.stringToNodeArray = stringToNodeArray;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojkoshared',['ojs/ojcore-base', 'knockout', 'ojs/ojconfig', 'ojs/ojlogger', 'ojs/ojhtmlutils'], function (oj, ko, Config, Logger, HtmlUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @private
   * @constructor
   * Global Change Queue Implementation
   * The queue is used to delay component updates until all model changes have been propagated
   * This is a private class that does not need to be xported
   */
  const GlobalChangeQueue = function () {
    this.Init();
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(GlobalChangeQueue, oj.Object, 'ComponentBinding.GlobalChangeQueue');

  GlobalChangeQueue.prototype.Init = function () {
    GlobalChangeQueue.superclass.Init.call(this);
    this._trackers = [];
    this._queue = [];
  };

  GlobalChangeQueue.prototype.registerComponentChanges = function (tracker) {
    if (this._trackers.indexOf(tracker) === -1) {
      this._trackers.push(tracker);
      if (!this._delayTimer) {
        this._delayTimer = setTimeout(oj.Object.createCallback(this, this._deliverChangesImpl), 1); // @HTMLUpdateOK delaying our own callback
        this._delayPromise = new Promise(
          function (resolve) {
            this._delayPromiseResolver = resolve;
          }.bind(this)
        );
      }
    }
  };

  GlobalChangeQueue.prototype.deliverChanges = function () {
    if (this._delayTimer) {
      clearTimeout(this._delayTimer);
    }
    this._deliverChangesImpl();
  };

  GlobalChangeQueue.prototype.getThrottlePromise = function () {
    return this._delayPromise || Promise.resolve();
  };

  GlobalChangeQueue.prototype._deliverChangesImpl = function () {
    this._delayTimer = null;
    this._resolveDelayPromise();
    var trackers = this._trackers;
    this._trackers = [];

    for (var i = 0; i < trackers.length; i++) {
      var tracker = trackers[i];
      this._queue.push({ tracker: tracker, changes: tracker.flushChanges() });
    }

    while (this._queue.length > 0) {
      var record = this._queue.shift();
      record.tracker.applyChanges(record.changes);
    }
  };

  GlobalChangeQueue.prototype._resolveDelayPromise = function () {
    if (this._delayPromise) {
      this._delayPromiseResolver();
      this._delayPromiseResolver = null;
      this._delayPromise = null;
    }
  };

  /**
   * @ignore
   * @constructor
   */
  function _KoCustomBindingProvider() {
    var _evaluatorCacheMap = new WeakMap();
    var _postprocessors = {};
    var _preprocessors = {};
    var _KoBindingCache = {};

    var _OJ_EXTENDED = '_ojExtended';
    var _OJ_CACHE_SCOPE = '_ojCacheScope';

    var _changeQueue = new GlobalChangeQueue();

    this.install = function () {
      var provider = ko.bindingProvider;
      var instanceName = 'instance';
      var wrapped = provider[instanceName];

      var getAccessors = 'getBindingAccessors';
      if (!wrapped[getAccessors]) {
        Logger.error(
          "JET's Knockout bindings are not compatible with the current binding " +
            'provider since it does not implement getBindingAccessors()'
        );
        return this;
      }

      var custom = {
        getWrapped: function () {
          return wrapped;
        }
      };
      provider[instanceName] = custom;

      var methodsToWrap = [];
      methodsToWrap.push(getAccessors, 'nodeHasBindings', 'getBindings');

      methodsToWrap.forEach(function (name) {
        custom[name] = _wrap(wrapped, name, function (n, original) {
          // _wrap() will be producing a function that always calls the 'wrapped'/original method first
          // to handle the binding postprocessor case.
          // Hovewer, for cases when the binding context has been created with  .extendBindingContext(),
          // we are replacing the binding evaluaror completely, and we do not need to call the original
          // getAccessors() method. _preWrapGetAccessors() will 'pre-wrap'/replace getAccessors() for that case,
          // so _wrap() will be wrapping the replaced method, and we will not be creating an evaluator in the original
          // getAccessors() method just to throw it away
          if (n !== getAccessors) {
            return original;
          }
          return _preWrapGetAccessors(original, wrapped);
        });
      });
      custom.preprocessNode = _wrapPreprocessNode(wrapped);

      _patchKoRenderTemplateSource();
      _patchKoTemplateSourceDomElement();
      _patchKoComponentsLoaders();
      _patchKoEvaluatorForCSP(_KoBindingCache);

      return this;
    };

    this.addPostprocessor = function (postprocessor) {
      var keys = Object.keys(postprocessor);
      keys.forEach(function (key) {
        _postprocessors[key] = _postprocessors[key] || [];
        _postprocessors[key].push(postprocessor[key]);
      });
    };

    this.registerPreprocessor = function (tagName, preprocessor) {
      _preprocessors[tagName] = preprocessor;
    };

    this.getBindingsString = function (node, wrapped, bindingContext) {
      return _getBindingsString(node, wrapped, bindingContext);
    };

    this.extendBindingContext = function (context, current, alias, templateAlias, cacheKey) {
      var extension = {
        $current: current,
        $root: undefined,
        $parent: undefined,
        $parents: undefined
      };

      if (alias) {
        extension[alias] = current;
      }
      if (templateAlias) {
        extension[templateAlias] = current;
      }
      if (context) {
        extension = context.extend(extension);
      } else {
        extension.$data = {}; // ensure that KO evaluator does not blow up when $context has no $data property
      }

      Object.defineProperty(extension, _OJ_CACHE_SCOPE, { value: cacheKey });
      Object.defineProperty(extension, _OJ_EXTENDED, { value: true });

      return extension;
    };

    this.createBindingExpressionEvaluator = function (expressionText, bindingContext) {
      if (bindingContext[_OJ_EXTENDED]) {
        return _createReplacementEvaluatorForExtend(expressionText);
      }
      var factory = Config.getExpressionEvaluator();
      if (factory) {
        var evaluate = factory.createEvaluator(expressionText).evaluate;
        return function ($context) {
          return evaluate([$context.$data || {}, $context]);
        };
      }

      var evaluator;
      try {
        /* jslint evil:true */
        // eslint-disable-next-line no-new-func
        evaluator = new Function( // @HTMLUpdateOK
          '$context',
          'with($context){with($data||{}){return ' + expressionText + ';}}'
        ); // binding expression evaluation
      } catch (e) {
        throw new Error(e.message + ' in expression "' + expressionText + '"');
      }
      return evaluator;
    };

    this.createEvaluator = function (expression, bindingContext) {
      return _createEvaluatorViaCache(
        this.createBindingExpressionEvaluator,
        expression,
        bindingContext
      );
    };

    this.getGlobalChangeQueue = function () {
      return _changeQueue;
    };

    function _wrap(wrapped, name, prewrap) {
      var isHasBindings = name === 'nodeHasBindings';

      return function (arg0) {
        if (isHasBindings) {
          var type = arg0.nodeType;
          if (type !== 1 && type !== 8) {
            return false;
          }
        }
        var delegate = prewrap(name, wrapped[name]);

        var ret = delegate ? delegate.apply(wrapped, arguments) : null;
        var postprocessHandlers = _postprocessors[name];

        if (postprocessHandlers != null) {
          var originalArgs = arguments;
          postprocessHandlers.forEach(function (handler) {
            var args = Array.prototype.slice.call(originalArgs);
            args.push(ret, wrapped);
            // Ignore dependencies here so that bindings don't get triggered due to contained evaluations
            ret = ko.ignoreDependencies(handler, null, args);
          });
        }
        return ret;
      };
    }

    function _wrapPreprocessNode(wrapped) {
      var originalPreprocessor = wrapped.preprocessNode;
      return function (node) {
        var preprocessor;
        var ret;
        var obj = null;
        if (node.nodeType === 1) {
          preprocessor = _preprocessors[node.nodeName.toLowerCase()];
        }
        if (!preprocessor) {
          preprocessor = originalPreprocessor;
          obj = wrapped;
        }
        if (preprocessor) {
          ret = ko.ignoreDependencies(preprocessor, obj, [node]);
        }
        if (Array.isArray(ret)) {
          ret = _preprocessNewNodes(node, ret);
        }
        return ret;
      };
    }

    function _preprocessNewNodes(originalNode, newNodes) {
      var provider = ko.bindingProvider.instance;
      var ret = newNodes.slice(0);
      var current = newNodes[0];
      var currentIndex = 0;
      var i = 0;

      while (currentIndex >= 0) {
        // get the next current element before preprocessing replaces current
        var next = ko.virtualElements.nextSibling(current);
        if (current !== originalNode) {
          var insertedNodes = provider.preprocessNode(current);
          if (Array.isArray(insertedNodes)) {
            // insert the nodes instead of the item at the index i
            ret.splice.apply(ret, [i, 1].concat(insertedNodes));
            // jump over the inserted nodes (-1 represents one node being replaced)
            i += insertedNodes.length - 1;
          }
        }
        current = next;
        i += 1;
        var nextIndex = currentIndex + 1;
        currentIndex = current ? newNodes.indexOf(current, nextIndex) : -1;
        // figure out how many virtual children we need to skip (they will be preprocessed after their container is entered)
        i += currentIndex - nextIndex; // this value is irrelevent if currentIndex is negative
      }

      return ret;
    }

    // Patches renderTemplateSource() to ensure that the template is parsed with the current document.
    // Otherwise, the custom elements are not being upgraded synchronously.
    // This method addresses an issue when JET components are defined inside of a <script> element.
    function _patchKoRenderTemplateSource() {
      var proto = ko.nativeTemplateEngine.prototype;
      var method = 'renderTemplateSource';
      var delegate = proto[method];

      proto[method] = function (templateSource, bindingContext, options, templateDocument) {
        return delegate.call(
          this,
          templateSource,
          bindingContext,
          options,
          templateDocument || document /* use current document if none is provided*/
        );
      };
    }

    // Patches ko.templateSources.domElement.nodes() method to ensure that custom elements are upgraded synchronously.
    // This method addresses an issue when JET components are defined inside of an external <template> element.
    function _patchKoTemplateSourceDomElement() {
      const proto = ko.templateSources.domElement.prototype;
      const method = 'nodes';
      const delegate = proto[method];

      proto[method] = function () {
        const nodes = delegate.apply(this, arguments);
        return nodes && nodes.nodeType === 11 ? document.importNode(nodes, true) : nodes;
      };
    }

    // This method adds custom KO component loader that overrides defaultLoader.loadTemplate().
    // This is done to ensure that the template is parsed with the current document in order
    // to upgrade custom elements synchronously
    // The custom loader takes precedence over the default loader.
    // This method addresses an issue when a knockout native component is used as a part of a JET component,
    // e.g. when items for oj-list-view contain a KO registered component.
    function _patchKoComponentsLoaders() {
      ko.components.loaders.unshift({
        loadTemplate: function (name, templateConfig, callback) {
          var nodes;
          if (typeof templateConfig === 'string') {
            nodes = ko.utils.parseHtmlFragment(templateConfig, document);
          } else if (templateConfig.element) {
            var element = templateConfig.element;
            if (element instanceof HTMLElement) {
              nodes = HtmlUtils.getTemplateContent(element);
            } else if (typeof element === 'string') {
              var template = document.getElementById(element);
              if (!template) {
                throw new Error(`Cannot find element with ID ${element}`);
              }
              nodes = HtmlUtils.getTemplateContent(template);
            } else {
              throw new Error(`Unknown element type: ${element}`);
            }
          }

          if (nodes) {
            ko.components.defaultLoader.loadTemplate(name, nodes, callback);
          } else {
            // Config type is not a string or an object. Let default loader handle it.
            callback(null);
          }
        }
      });
    }

    function _preWrapGetAccessors(original, wrappedProvider) {
      return function (node, bindingContext) {
        if (bindingContext[_OJ_EXTENDED]) {
          var bindingsString = _getBindingsString(node, wrappedProvider, bindingContext);
          // _createExtendAccessorsViaCache() returns a function that will produce a map of binding accessors.
          // Note that this function is immediately invoked with the bindingcontext and node as parameters.
          // That will pre-bind binding accessors to the values of $context and $element
          var accessors = bindingsString
            ? _createExtendAccessorsViaCache(bindingsString, bindingContext)(bindingContext, node)
            : null;

          // Check whether a node is a KO component. We will be using the default evaluator
          // to initialize component binding, while our own evaluator will be handling the
          // rest of the bindings specified with data-bind.
          // This means that in the inlikely case when a KO component is used in an inline
          // template or the oj-bind-foreach, the properties of component will be subject to a
          // possible collision between an aliased data object and a ViewModel property (avery unlikely scenario)
          if (node.nodeType === 1 && ko.components.isRegistered(node.tagName.toLowerCase())) {
            var originalAccessors = original.call(wrappedProvider, node, bindingContext);
            var componentEval = originalAccessors.component;
            if (componentEval) {
              // copy the component binding accessor from the original accessor map
              accessors = accessors || {};
              accessors.component = componentEval;
            }
          }
          return accessors;
        }
        return original.call(wrappedProvider, node, bindingContext);
      };
    }

    function _createExtendAccessorsViaCache(bindingsString, bindingContext) {
      var factory = function (expr) {
        // .preProcessBindings() will produce a string that defines a Function retrurning a map
        // with each key being the bidning name, and each value being an evalutor function for
        // binding value
        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(expr, {
          valueAccessors: true
        });
        return _createReplacementEvaluatorForExtend('{' + rewrittenBindings + '}');
      };

      return _createEvaluatorViaCache(factory, bindingsString, bindingContext);
    }

    function _createReplacementEvaluatorForExtend(expressionText) {
      // Note that the priority order of the binding context and the ViewModel are reversed
      // in this evaluator. This is needed for allowing properties supplied in bindsingProvider.extend()
      // to obscure properties in the ViewModel, which is the behavior one would expect when .extend()
      // is used
      var factory = Config.getExpressionEvaluator();
      if (factory) {
        var evaluate = factory.createEvaluator(expressionText).evaluate;
        return function ($context, $element) {
          return evaluate([$context, $context.$data || {}, { $element: $element }]);
        };
      }

      var evaluator;
      try {
        /* jslint evil:true */
        // eslint-disable-next-line no-new-func
        evaluator = new Function( // @HTMLUpdateOK
          '$context',
          '$element',
          'with($context.$data||{}){with($context){return ' + expressionText + '}}'
        ); // binding expression evaluation
      } catch (e) {
        throw new Error(e.message + ' in expression "' + expressionText + '"');
      }
      return evaluator;
    }

    function _createEvaluatorViaCache(factory, expr, bindingContext) {
      // The absence of binding context indicates that no caching should occur
      if (!bindingContext) {
        return factory(expr, bindingContext);
      }

      var cacheScope;
      var scopeMap = _evaluatorCacheMap;

      var key = bindingContext[_OJ_CACHE_SCOPE] || bindingContext;

      cacheScope = scopeMap.get(key);
      if (!cacheScope) {
        cacheScope = {};
        scopeMap.set(key, cacheScope);
      }
      var func = cacheScope[expr];
      if (!func) {
        func = factory(expr, bindingContext);
        cacheScope[expr] = func;
      }
      return func;
    }

    function _getBindingsString(node, wrapped, bindingContext) {
      var func = wrapped.getBindingsString;
      if (func) {
        return func.call(wrapped, node, bindingContext);
      }

      switch (node.nodeType) {
        case 1: // Element
          return node.getAttribute('data-bind');

        case 8: // Comment node
          var match = node.nodeValue.match(/^\s*ko(?:\s+([\s\S]+))?\s*$/);
          return match ? match[1] : null;

        default:
          return null;
      }
    }
  }

  function _patchKoEvaluatorForCSP(cache) {
    var instance = ko.bindingProvider.instance;
    var patched;
    var parseMethod = 'parseBindingsString';
    while (instance && !patched) {
      var original = instance[parseMethod];
      if (original) {
        patched = true;
        instance[parseMethod] = _getParseBindingsReplacement(original.bind(instance), cache);
      } else {
        instance = instance.getWrapped ? instance.getWrapped() : null;
      }
    }
    if (!patched) {
      Logger.error(
        'Unable to patch KO expression evaluation implementation. ' +
          'If you have a custom binding provider, make sure it implements the getWrapped() method that returns the default binding provider instance.'
      );
    }
  }

  function _getParseBindingsReplacement(original, cache) {
    return function (bindingsString, bindingContext, node, options) {
      var factory = Config.getExpressionEvaluator();
      if (!factory) {
        return original(bindingsString, bindingContext, node, options);
      }
      var evaluate = _createKoEvaluatorViaCache(bindingsString, options, factory, cache);
      return evaluate([bindingContext.$data || {}, bindingContext, { $element: node }]);
    };
  }

  function _createKoEvaluatorViaCache(expression, options, factory, cache) {
    var evaluate = cache[expression];
    if (!evaluate) {
      var rewrittenBindings = ko.expressionRewriting.preProcessBindings(expression, options);
      evaluate = factory.createEvaluator('{' + rewrittenBindings + '}').evaluate;
      // eslint-disable-next-line no-param-reassign
      cache[expression] = evaluate;
    }
    return evaluate;
  }

  const BindingProviderImpl = new _KoCustomBindingProvider().install();

  return BindingProviderImpl;

});


define('ojs/ojtemplateengine-utils',['exports', 'preact/jsx-runtime', 'preact', 'ojs/ojcore-base', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry', 'ojs/ojmetadatautils', 'ojs/ojlogger'], function (exports, jsxRuntime, preact, oj, ojcustomelementUtils, ojcustomelementRegistry, ojmetadatautils, Logger) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    const ROW = Symbol('row');
    class PreactTemplate {
        /**
         * Renders virtual nodes into parentStub element
         * @param componentElement
         * @param vnode
         * @param row
         * @param provided
         */
        static renderNodes(componentElement, vnode, row, provided) {
            const parentStub = row.parentStub;
            let retrieveNodes = () => Array.from(parentStub.childNodes);
            if (row.nodes) {
                // This is an update case.  We want to:
                // 1.  Store the nodes before and after the set of old DOM nodes
                // 2.  Let Preact render "into" the stub (Preact will actually just patch the nodes in place when called this way)
                // 3.  Use the before/after nodes (which should be unchanged) to retrieve the new set of rendered nodes
                // Note that we assume that the DOM nodes returned by an execute call are
                // inserted all together under a single parent node by the calling component.
                retrieveNodes = PreactTemplate._getRetrieveNodesFunction(row.nodes);
            }
            // JET-49840 - using rowTemplate within oj-table logs a console error.
            // The error is benign. Lets supress it, then return console.error to origin.
            const oldConsole = console.error;
            console.error = (msg, optionalParams) => {
                if (msg.indexOf('Improper nesting of table.') === -1) {
                    oldConsole.apply(console, arguments);
                }
            };
            try {
                const contextWrappers = provided
                    ? Array.from(provided).reduce((acc, [context, value]) => {
                        return jsxRuntime.jsx(context.Provider, { value: value, children: acc });
                    }, vnode)
                    : vnode;
                preact.render(contextWrappers, parentStub);
            }
            finally {
                // Set console.error back to origin.
                console.error = oldConsole;
            }
            let textNodesOnly = true;
            const nodes = retrieveNodes();
            nodes.forEach((node) => {
                // Add an attribute to recognize the content during clean() and a backpointer
                // to the associated row
                if (node.setAttribute) {
                    node.setAttribute('data-oj-vdom-template-root', '');
                    textNodesOnly = false;
                }
                else {
                    node['_oj_vdom_template_root'] = true;
                }
                node[ROW] = row;
                node[ojcustomelementUtils.CACHED_BINDING_PROVIDER] = 'preact';
            });
            row.vnode = vnode;
            row.nodes = nodes;
            // Set the attribute on the component to optimize the template roots search in
            // findTemplateRoots().
            if (textNodesOnly) {
                componentElement.setAttribute('data-oj-vdom-template-text-roots', '');
            }
        }
        static clean(node) {
            const row = node[ROW];
            // A single row might render multiple physical DOM nodes
            // ensure the row is only cleaned once
            if (row && !row.cleaned) {
                row.cleaned = true;
                // Components don't expect that calling clean on the template engine will result in
                // the cleaned nodes being disconnected, but that's what calling render(null) will do
                // In order to avoid violating this expectation, we'll reconnect the nodes in their
                // original location after the render(null) call.
                const reconnectNodes = PreactTemplate._getInsertNodesFunction(row.nodes);
                preact.render(null, row.parentStub);
                reconnectNodes(row.nodes);
                row.computedVNode?.dispose();
                const template = row.template;
                const index = template._cachedRows.indexOf(row);
                template._cachedRows.splice(index, 1);
                node[ROW] = null;
            }
        }
        /**
         * This method finds template roots under the given parent element.
         * The roots are found either by data-oj-vdom-template-root attribute or by _oj_vdom_template_root
         * property that were set directly on the node that does not accept attributes.
         * @param node
         * @param componentElement
         * @ignore
         */
        static findTemplateRoots(node, componentElement) {
            // Search for nodes created with VDom methods and let PreactTemplate clean them.
            // Note, if the roots are found then we don't have to search for the text siblings because
            // the entire row is cleaned for the given root. See the clean() method above.
            let vdomTemplateRoots = node && node.querySelectorAll
                ? Array.from(node.querySelectorAll('[data-oj-vdom-template-root=""]'))
                : [];
            // Add the node itself to the array if it has the data-oj-vdom-template-root attribute
            if (node && node.hasAttribute && node.hasAttribute('data-oj-vdom-template-root')) {
                vdomTemplateRoots.push(node);
            }
            // Handle the use-case where the given node has content from multiple templates or
            // mixed content from multiple rows from a single template.
            // Find if the components involved in given DOM branch executed templates with text only output.
            let findTextNodes = componentElement?.hasAttribute?.('data-oj-vdom-template-text-roots');
            if (!findTextNodes) {
                let containTextNodesOnly = node && node.querySelectorAll
                    ? node.querySelectorAll('[data-oj-vdom-template-text-roots=""]')
                    : [];
                findTextNodes = containTextNodesOnly.length > 0;
            }
            // Search for the potential text nodes that might make up the template - case when the template has text nodes only.
            if (findTextNodes) {
                const treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);
                let currentNode = treeWalker.currentNode;
                while (currentNode) {
                    if (currentNode['_oj_vdom_template_root']) {
                        vdomTemplateRoots.push(currentNode);
                    }
                    currentNode = treeWalker.nextNode();
                }
            }
            return vdomTemplateRoots;
        }
        // Given an array of connected nodes, returns a function that will insert
        // an array of nodes (could be the same array or a different array) at the
        // same location
        static _getInsertNodesFunction(oldNodes) {
            const lastNode = oldNodes[oldNodes.length - 1];
            const parentNode = lastNode.parentNode;
            const nextSibling = lastNode.nextSibling;
            return (nodes) => {
                nodes.forEach((node) => parentNode.insertBefore(node, nextSibling));
            };
        }
        // Given an array of connected nodes, determines the nodes immediately preceding
        // and following and returns a function that will return an array of the nodes
        // between these two nodes (i.e. after they've been updated by Preact)
        static _getRetrieveNodesFunction(oldNodes) {
            const firstNode = oldNodes[0];
            const lastNode = oldNodes[oldNodes.length - 1];
            const parentNode = firstNode.parentNode;
            const previousSibling = firstNode.previousSibling;
            const nextSibling = lastNode.nextSibling;
            // if oldNodes appear at the beginning of parentNode's children, previousSibling will be undefined
            // in that case, parentNode's firstChild will be the first of our newly rendered nodes, otherwise
            // the next sibling of the (non-null) previousSibling will be.
            const firstNewNode = () => previousSibling ? previousSibling.nextSibling : parentNode.firstChild;
            // note that in either case, it is possible for the render call to result in an empty set of nodes.
            // in that scenario, regardless of how the first "new" node is retrieved, it will actually be equal to
            // nextSibling, causing the loop below to immediately terminate
            return () => {
                const nodes = [];
                for (let node = firstNewNode(); node !== nextSibling; node = node.nextSibling) {
                    nodes.push(node);
                }
                return nodes;
            };
        }
        /**
         * @param {Element} template element
         * @param {Function} renderer - a function that will render the template
         * @param {string} elementTagName - tag name of the element where the resolved properties are read from
         * @param {Set<string>} propertySet - properties to be resolved
         * @param {any} data to be passed to the render function
         * @param {{string: any}} default property values
         * @param {Function} propertyValidator - function to validate resolved properties
         * @return an object that implements peek(), subscribe() and dispose() for retrieving the value,
         * being notified of value changes and removing the subscription
         * @ignore
         */
        static resolveVDomTemplateProps(template, renderer, elementTagName, propertySet, data, defaultValues, propertyValidator) {
            const metadata = ojcustomelementRegistry.getPropertiesForElementTag(elementTagName);
            const [cache, deleteEntry] = PreactTemplate.extendTemplate(template, PreactTemplate._COMPUTED_PROPS_CACHE_FACTORY, (recalc) => {
                for (const observable of cache) {
                    observable.recalculateValue(recalc);
                }
            });
            const calcValue = (render) => PreactTemplate._computeProps(render, elementTagName, metadata, propertySet, data, propertyValidator);
            const item = new ObservableProperty(calcValue, renderer, defaultValues, deleteEntry);
            cache.add(item);
            return item;
        }
        static _computeProps(renderer, elementTagName, metadata, propertySet, data, propertyValidator) {
            const result = renderer(data);
            const vnodes = Array.isArray(result) ? result : [result];
            const targetNode = vnodes.find((n) => n.type === elementTagName);
            if (!targetNode) {
                throw new Error(`Item template must contain an element named {elementTagName}`);
            }
            const props = {};
            const vprops = targetNode.props;
            Object.keys(vprops).forEach((origProp) => {
                const { prop, value } = ojcustomelementUtils.convertPrivatePropFromPreact(origProp, targetNode.props[origProp]);
                if (propertySet.has(prop)) {
                    // VDOM property names must not '.'' separators, so the property name array
                    // will always have a single element
                    // TODO: Uncomment the following line once dvt-base fixes the issue with the property
                    // validator implementation looking for a physical template child like <oj-chart-item>
                    // propertyValidator?.([prop], val);
                    props[prop] = ojcustomelementUtils.transformPreactValue(null, prop, ojmetadatautils.getPropertyMetadata(prop, metadata), value);
                }
            });
            return props;
        }
        /**
         * The method is handles templates used inside VComponents by the regular custom elements.
         * The '_cachedRows' property is added to the template to store all the processed nodes and
         * the setter/getter methods are added for 'render' property in order to update nodes
         * created with this template.
         * @param {Element} node the <template> element
         * @param {Function} initialCacheFactory - a function returning the initial cache value
         * @param {Function} a callback invoked when the 'render' property is set
         * @return item cache
         * @ignore
         */
        static extendTemplate(node, initialCacheFactory, onRenderChanged) {
            if (!node._cachedRows) {
                let fn = node.render;
                Object.defineProperties(node, {
                    _cachedRows: { writable: true, value: initialCacheFactory() },
                    render: {
                        enumerable: true,
                        get() {
                            return fn;
                        },
                        set(renderCallback) {
                            fn = renderCallback;
                            if (renderCallback) {
                                onRenderChanged(renderCallback);
                            }
                        }
                    }
                });
            }
            return node._cachedRows;
        }
    }
    PreactTemplate._COMPUTED_PROPS_CACHE_FACTORY = () => {
        const cache = new Set();
        return [cache, cache.delete.bind(cache)];
    };
    PreactTemplate._ROW_CACHE_FACTORY = () => [];
    class ObservableProperty {
        constructor(calculate, renderer, defaultProps, disposeCallback) {
            this._calculate = calculate;
            this._defaultProps = defaultProps;
            this._disposeCallback = disposeCallback;
            this._value = calculate(renderer);
            this._merged = this._getMergedValue(this._value);
        }
        peek() {
            return this._merged;
        }
        subscribe(sub) {
            if (this._sub) {
                throw new Error('Resolved property observable does not support multiple subscribers');
            }
            this._sub = sub;
        }
        dispose() {
            this._disposeCallback(this);
        }
        recalculateValue(renderer) {
            const val = this._calculate(renderer);
            const old = this._value;
            this._value = val;
            if (this._sub && !oj.Object.compareValues(val, old)) {
                this._merged = this._getMergedValue(val);
                this._sub(this._merged);
            }
        }
        _getMergedValue(val) {
            return Object.assign({}, this._defaultProps, val);
        }
    }

    const _SAVED_NODES_ID = 'savedNodesId';
    class TemplateEngineUtils {
        /**
         * Gets binding context for the template element.
         * @param bindingProvider Object that contains a subset of ko methods
         * @param componentElement Component element
         * @param templateElement The <template> element
         * @param properties Data to be applied to the template
         * @param alias An alias for referencing the data within a template
         * @param templateAlias  An additional alias to provide to the template children
         *    defined as data-oj-as attribute on the template
         * @returns {object} binding context for the template
         * @ignore
         */
        static getContext(bindingProvider, componentElement, templateElement, properties, alias, templateAlias, provided) {
            if (bindingProvider) {
                // Always use the binding context for the template  element
                // Note: the context for oj_bind_for_each template is stored on __ojBindingContext property.
                let bindingContext = templateElement.__ojBindingContext
                    ? templateElement.__ojBindingContext
                    : bindingProvider.__ContextFor(templateElement);
                // In the rare case it's not defined, check the componentElement and log a message
                if (!bindingContext) {
                    Logger.info('Binding context not found when processing template for element with id: ' +
                        componentElement.id +
                        '. Using binding context for element instead.');
                    bindingContext = bindingProvider.__ContextFor(componentElement);
                }
                const extendedBindingContext = bindingProvider.__ExtendBindingContext(bindingContext, properties, alias, templateAlias, componentElement);
                // Merge $provided contexts if the 'provided' argument is given.
                if (extendedBindingContext['$provided'] && provided) {
                    const merged = new Map([...extendedBindingContext['$provided'], ...provided]);
                    extendedBindingContext['$provided'] = merged;
                }
                else if (provided) {
                    extendedBindingContext['$provided'] = provided;
                }
                return extendedBindingContext;
            }
            // Build the context object out of 'properties' when ko and BindingProviderImpl modules are not present.
            const context = {
                $current: properties
            };
            if (templateAlias) {
                context[templateAlias] = properties;
            }
            return context;
        }
        /**
         *
         * @param defaultProps
         * @param elementTagName
         * @param propertySet
         * @ignore
         */
        static getResolvedDefaultProps(defaultProps, elementTagName, propertySet) {
            let props = defaultProps.get(elementTagName);
            if (!props) {
                const elem = document.createElement(elementTagName); // @HTMLUpdateOK element tag name will always be one of JET elements
                props = TemplateEngineUtils.getStaticPropertyMap(elem, propertySet, document.body);
                defaultProps.set(elementTagName, props);
            }
            return props;
        }
        /**
         *
         * @param firstElem
         * @param propertySet
         * @param parent
         * @ignore
         */
        static getStaticPropertyMap(firstElem, propertySet, parent) {
            const staticMap = {};
            if (firstElem) {
                const st = firstElem.style;
                st.display = 'none';
                st.position = 'absolute';
                firstElem.setAttribute('data-oj-binding-provider', 'none');
                parent.appendChild(firstElem);
                propertySet.forEach(function (key) {
                    if (firstElem[key] !== undefined) {
                        staticMap[key] = firstElem[key];
                    }
                });
                parent.removeChild(firstElem);
            }
            return staticMap;
        }
        /**
         *
         * @param bindingProvider
         * @param target
         * @param name
         * @param value
         * @param changeListener
         * @ignore
         */
        static createPropertyBackedByObservable(bindingProvider, target, name, value, changeListener) {
            const obs = bindingProvider.__Observable(value);
            Object.defineProperty(target, name, {
                get: () => obs(),
                set: (val) => {
                    obs(val);
                    if (changeListener) {
                        changeListener(val);
                    }
                },
                enumerable: true
            });
        }
        /**
         * Utility method that generates unique id, reads, removes from dom and stores child nodes in a shared map.
         * @param replacementMap
         * @param node
         * @returns {string} unique id used to create a comment node for ij-bind-if
         * @ignore
         */
        static _storeBindIfChildNodes(replacementMap, node) {
            const savedNodesId = _SAVED_NODES_ID + ojcustomelementUtils.ElementUtils.getUniqueId(null);
            const childNodes = [];
            while (node.childNodes.length > 0) {
                var child = node.childNodes[0];
                childNodes.push(document.importNode(child, true));
                node.removeChild(child);
            }
            replacementMap.set(savedNodesId, childNodes);
            return savedNodesId;
        }
        /**
         * Converts oj-bind-if node to a comment nodes and stores children in a shared map.
         * @param replacementMap
         * @param node
         * @param nodeName
         * @ignore
         */
        static _processOjBindIf(replacementMap, node, nodeName) {
            // Build ko comment node based on _ojBindIf_V2_ object value, that
            // contains test expression and nodes that will be added to the binding context.
            const expr = ojcustomelementUtils.KoBindingUtils.getExpressionForAttr(node, 'test', false);
            const savedNodesId = TemplateEngineUtils._storeBindIfChildNodes(replacementMap, node);
            const bindingStr = `ko _ojBindIf_V2_:{ test:${expr}, nodes:$current._ojNodesMap.${savedNodesId}, ojDoNotUseProcessed:true }`;
            TemplateEngineUtils._replaceBindElementWithComments(node, nodeName, bindingStr);
        }
        /**
         * Updates oj-if node by adding data that point to external nodes that used as child dom,
         * saves child dom in a shared map.
         * @param replacementMap
         * @param node
         * @ignore
         */
        static _processOjIf(replacementMap, node) {
            const savedNodesId = TemplateEngineUtils._storeBindIfChildNodes(replacementMap, node);
            node.setAttribute('oj-private-do-not-use', `$current._ojNodesMap.${savedNodesId}`);
        }
        /**
         * Converts oj-bind-text into comment node.
         * @param replacementMap
         * @param node
         * @param nodeName
         * @ignore
         */
        static _processOjBindText(replacementMap, node, nodeName) {
            const expr = ojcustomelementUtils.KoBindingUtils.getExpressionForAttr(node, 'value', true);
            const bindingStr = `ko text:${expr}`;
            TemplateEngineUtils._replaceBindElementWithComments(node, nodeName, bindingStr);
        }
        /**
         * Converts oj-bind-for-each into comment node.
         * @param replacementMap
         * @param node
         * @param nodeName
         * @ignore
         */
        static _processOjBindForEach(replacementMap, node, nodeName) {
            const bindingStr = ojcustomelementUtils.KoBindingUtils.createBindForEachHandlerStr(node);
            if (!bindingStr) {
                return;
            }
            TemplateEngineUtils._replaceBindElementWithComments(node, nodeName, bindingStr);
        }
        /**
         * Helper method that replaces given oj-bind-x element with comment nodes.
         * @param node
         * @param nodeName
         * @param bindingString
         * @ignore
         */
        static _replaceBindElementWithComments(node, nodeName, bindingString) {
            // Build a wrapper comment around ko comment node
            // with all of the attribute info that was on the original DOM node.
            const ojOpenComment = document.createComment(ojcustomelementUtils.KoBindingUtils.getNodeReplacementCommentStr(node));
            const ojCloseComment = document.createComment('/' + nodeName);
            const koOpenComment = document.createComment(bindingString);
            const koCloseComment = document.createComment('/ko');
            // Replace the original node with comment nodes, remove and store child nodes on the replacementMap object
            const parent = node.parentNode;
            parent.insertBefore(ojOpenComment, node); // @HTMLUpdateOK
            parent.insertBefore(koOpenComment, node); // @HTMLUpdateOK
            // Copy oj-bind-for-each children into the comment node
            if (nodeName === 'oj-bind-for-each') {
                while (node.childNodes.length > 0) {
                    const child = node.childNodes[0];
                    parent.insertBefore(child, node); // @HTMLUpdateOK
                }
            }
            parent.insertBefore(koCloseComment, node); // @HTMLUpdateOK
            parent.replaceChild(ojCloseComment, node);
        }
        /**
         * The method recursively walks the template nodes passing context object to each level of nodes.
         * The context object contains a shared map of 'unique key -> nodes[]' and number used to generate a unique key.
         * @param replacementMap node replacement map passed into recursive node walk
         * @param nodes nodes to process
         * @ignore
         */
        static _processBindElements(replacementMap, nodes) {
            nodes.forEach((node) => {
                TemplateEngineUtils._processBindElements(replacementMap, Array.from(node.childNodes));
                if (node.nodeType === 1) {
                    // Replace oj-bind-if node with comment nodes
                    const nodeName = node.tagName?.toLowerCase();
                    switch (nodeName) {
                        case 'oj-bind-if':
                            TemplateEngineUtils._processOjBindIf(replacementMap, node, nodeName);
                            break;
                        case 'oj-if':
                            TemplateEngineUtils._processOjIf(replacementMap, node);
                            break;
                        case 'oj-bind-text':
                            TemplateEngineUtils._processOjBindText(replacementMap, node, nodeName);
                            break;
                        case 'oj-bind-for-each':
                            TemplateEngineUtils._processOjBindForEach(replacementMap, node, nodeName);
                            break;
                    }
                }
            });
        }
        /**
         * Process a template element in order to optimize performance and resource usage
         * - save child nodes of oj-bind-if and oj-if elements on a template in order to share
         *   them between rows instead of keeping a copy for each row
         * - replace oj-bind-if with comment nodes on the template and avoid running
         *   this step for each row
         * @param templateElement The <template> element
         * @returns {object} object that contains template copy and node replacement map
         * @ignore
         */
        static processTemplate(templateElement) {
            if (templateElement.render) {
                return;
            }
            if (!templateElement['_replacedNodes']) {
                const replacementMap = new Map();
                const templateCopy = document.importNode(templateElement, true);
                Object.defineProperty(templateElement, '_replacedNodes', {
                    writable: true,
                    value: { templateCopy, replacementMap }
                });
                TemplateEngineUtils._processBindElements(replacementMap, Array.from(templateCopy.content.childNodes));
            }
            return templateElement['_replacedNodes'];
        }
    }

    exports.PreactTemplate = PreactTemplate;
    exports.TemplateEngineUtils = TemplateEngineUtils;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtemplateengine-ko',['knockout', 'ojs/ojkoshared', 'ojs/ojtemplateengine-utils', 'ojs/ojcore', 'ojs/ojhtmlutils', 'ojs/ojcustomelement-utils', 'ojs/ojcontext', 'ojs/ojlogger'], function (ko, BindingProviderImpl, ojtemplateengineUtils, oj, HtmlUtils, ojcustomelementUtils, Context, Logger) { 'use strict';

    BindingProviderImpl = BindingProviderImpl && Object.prototype.hasOwnProperty.call(BindingProviderImpl, 'default') ? BindingProviderImpl['default'] : BindingProviderImpl;
    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

    const _propertyContribsCache = new WeakMap();
    class TemplateEngineKoInternal {
        constructor() {
            this._bindingProvider = {
                __ContextFor: ko.contextFor,
                __ExtendBindingContext: BindingProviderImpl.extendBindingContext,
                __KoComputed: ko.computed,
                __Observable: ko.observable
            };
        }
        /**
         * Executes the template by deep-cloning the template nodes and then applying data bindings.
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {Element} reportBusy - optional element for bubblng busy states outside of the template
         * @param {Object} context the binding context for the template  element
         * @param {Map} provided - optional provided context to be applied to template
         * @return {Array.<Node>} HTML nodes representing the result of the execution
         * @ignore
         */
        executeTemplate(componentElement, templateElement, reportBusy, context, provided) {
            const processedTemplate = templateElement._replacedNodes.templateCopy;
            const tmpContainer = this._createAndPopulateContainer(processedTemplate, reportBusy);
            let stampedNodes = tmpContainer.childNodes;
            for (let i = 0; i < stampedNodes.length; i++) {
                const stampedNode = stampedNodes[i];
                // Set the binding provider on the stamped nodes in case the parent
                // component is a different binding provider
                stampedNode[ojcustomelementUtils.CACHED_BINDING_PROVIDER] = 'knockout';
            }
            ko.applyBindingsToDescendants(context, tmpContainer);
            return Array.prototype.slice.call(stampedNodes, 0);
        }
        resolveProperties(componentElement, templateElement, elementTagName, propertySet, data, alias, propertyValidator, alternateParent) {
            const templateAlias = templateElement.getAttribute('data-oj-as');
            const context = ojtemplateengineUtils.TemplateEngineUtils.getContext(this._bindingProvider, componentElement, templateElement, data, alias, templateAlias);
            const contribs = this._getPropertyContributorsViaCache(templateElement, context, elementTagName, propertySet, alternateParent || componentElement);
            return this._createComputed(contribs, context, propertyValidator);
        }
        /**
         *
         * @param node
         * @param context
         * @param elementTagName
         * @param propertySet
         * @param parent
         */
        _getPropertyContributorsViaCache(node, context, elementTagName, propertySet, parent) {
            let contribs = _propertyContribsCache.get(node);
            if (!contribs) {
                contribs = {};
                _propertyContribsCache.set(node, contribs);
                const tmpNode = this._createAndPopulateContainer(node);
                const firstElem = tmpNode.querySelector(elementTagName);
                contribs.evalMap = this._getPropertyEvaluatorMap(firstElem, propertySet, context);
                contribs.staticMap = this._getStaticPropertyMap(firstElem, propertySet, parent);
            }
            return contribs;
        }
        /**
         *
         * @param firstElem
         * @param propertySet
         * @param context
         */
        _getPropertyEvaluatorMap(firstElem, propertySet, context) {
            var evalMap = new Map();
            var attrs = firstElem ? firstElem.attributes : [];
            for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var prop = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attr.name);
                // Handle the 'dot' notation for bound subprops
                var propTokens = prop.split('.');
                if (propertySet.has(propTokens[0])) {
                    var info = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attr.value);
                    var expr = info.expr;
                    if (expr) {
                        evalMap.set(propTokens, BindingProviderImpl.createBindingExpressionEvaluator(expr, context));
                    }
                }
            }
            return evalMap;
        }
        _getStaticPropertyMap(firstElem, propertySet, parent) {
            const staticMap = {};
            if (firstElem) {
                var st = firstElem.style;
                st.display = 'none';
                st.position = 'absolute';
                firstElem.setAttribute('data-oj-binding-provider', 'none');
                parent.appendChild(firstElem);
                propertySet.forEach(function (key) {
                    if (firstElem[key] !== undefined) {
                        staticMap[key] = firstElem[key];
                    }
                });
                parent.removeChild(firstElem);
            }
            return staticMap;
        }
        /**
         *
         * @param contribs
         * @param context
         * @param propertyValidator
         */
        _createComputed(contribs, context, propertyValidator) {
            const computed = ko.pureComputed(() => {
                const boundValues = {};
                contribs.evalMap.forEach((evaluator, tokens) => {
                    var leafValue = ko.utils.unwrapObservable(evaluator(context));
                    if (propertyValidator) {
                        propertyValidator(tokens, leafValue);
                    }
                    boundValues[tokens[0]] = this._getMergedValue(boundValues, tokens, leafValue);
                });
                const extend = oj.CollectionUtils.copyInto;
                let valueMap = extend({}, contribs.staticMap, null, true);
                valueMap = extend(valueMap, boundValues, null, true);
                return valueMap;
            });
            return this._wrap(computed, ['peek', 'subscribe', 'dispose']);
        }
        _getMergedValue(valuesObj, tokens, value) {
            if (tokens.length < 2) {
                return value;
            }
            const complexVal = valuesObj[tokens[0]] || {};
            let current = complexVal;
            const lastIndex = tokens.length - 1;
            for (let i = 1; i < lastIndex; i++) {
                const token = tokens[i];
                const newVal = current[token] || {};
                current[token] = newVal;
                current = newVal;
            }
            current[tokens[lastIndex]] = value;
            return complexVal;
        }
        /**
         *
         * @param delegate
         * @param methods
         */
        _wrap(delegate, methods) {
            const ret = {};
            methods.forEach((method) => {
                ret[method] = delegate[method].bind(delegate);
            });
            return ret;
        }
        /**
         *
         * @param templateElement
         * @param reportBusy
         */
        _createAndPopulateContainer(templateElement, reportBusy) {
            var div = document.createElement('div');
            if (reportBusy) {
                div._ojReportBusy = reportBusy;
            }
            var nodes = HtmlUtils.getTemplateContent(templateElement);
            for (var i = 0; i < nodes.length; i++) {
                div.appendChild(nodes[i]);
            }
            return div;
        }
    }

    class TemplateEnginePreactInternal {
        constructor() {
            this._defaultProps = new Map();
        }
        /**
         * Executes the template by calling function callback stored as 'render' property on the template.
         * Template nodes will be cached in order to be updated when 'render' property value is updated,
         * in this case we don't need to refresh parent custom element completely.
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {Element} reportBusy - optional element for bubblng busy states outside of the template
         * @param {Object} context the binding context for the template  element
         * @param {Map} provided - optional provided context to be applied to template
         * @ignore
         */
        executeTemplate(componentElement, templateElement, reportBusy, context, provided) {
            // Override ko throttle() method to add busy state for pending changes.
            const busyContext = Context.getContext(templateElement).getBusyContext();
            const customThrottle = (callback, timeout) => {
                let timeoutInstance;
                return () => {
                    if (!timeoutInstance) {
                        // add busy state and assign busyStateResolve here
                        const busyStateResolve = busyContext.addBusyState({
                            description: 'pending changes for the template element'
                        });
                        timeoutInstance = setTimeout(() => {
                            timeoutInstance = undefined;
                            callback();
                            busyStateResolve();
                        }, timeout);
                    }
                };
            };
            const computedVNode = ko.pureComputed({
                read: () => {
                    // Run render() callback to produce VNode element - root node for template content.
                    // Then cache tempate the content.
                    // Also pass provided map to the renderer. IT is needed by VComponentTemplate engine
                    // since it uses context for entire slot
                    return templateElement.render(context.$current, provided);
                }
            })
                .extend({ rateLimit: { timeout: 0, method: customThrottle } });
            const vNode = computedVNode();
            ojtemplateengineUtils.PreactTemplate.extendTemplate(templateElement, ojtemplateengineUtils.PreactTemplate._ROW_CACHE_FACTORY, (renderer) => {
                // When the renderer changes, rerender all cached rows
                templateElement._cachedRows.forEach((rowItem) => {
                    // Also pass provided map to the renderer. IT is needed by VComponentTemplate engine
                    // since it uses context for entire slot
                    let newVNode = renderer(rowItem.currentContext, provided);
                    ojtemplateengineUtils.PreactTemplate.renderNodes(componentElement, newVNode, rowItem, provided);
                });
            });
            // Use a parent node stub to render since preact's render() needs a parent node.
            const parentStub = document.createElement('div');
            if (reportBusy) {
                parentStub._ojReportBusy = reportBusy;
            }
            const cachedRow = {
                currentContext: context.$current,
                template: templateElement,
                parentStub,
                computedVNode,
                vnode: undefined,
                nodes: undefined
            };
            ojtemplateengineUtils.PreactTemplate.renderNodes(componentElement, vNode, cachedRow, provided);
            templateElement._cachedRows.push(cachedRow);
            computedVNode.subscribe((newVNode) => {
                const currRow = templateElement._cachedRows.find((row) => row.computedVNode === computedVNode);
                // It is possible that the currRow is not found, because it could be already disposed
                // by the component. If that is the case, then skip rendering.
                if (currRow) {
                    if (!currRow.nodes[0].isConnected) {
                        // Preact will fail to update disconnected nodes. This should be fixed on a component
                        // that used templateEngine.execute() to produce the original set of nodes.
                        // The nodes should be either disposed or parked. Logging the warning in order to identify the condition.
                        Logger.warn(`PreactTemplateEngineKo subscription is called to replace disconnected row for the template slot \'${templateElement.slot}\' on ${componentElement.tagName}`);
                    }
                    ojtemplateengineUtils.PreactTemplate.renderNodes(componentElement, newVNode, currRow, provided);
                }
            });
            return cachedRow.nodes;
        }
        /**
         * Resolves properties on an element of the template without producing
         * any DOM. This method should be used when a template is used exclusively for collecting
         * properties while iterating over data
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {string} elementTagName tag name of the element where the property should be collected
         * @param {Set.<string>} propertySet properties to be resolved
         * @param {Object} data data to be applied to the template
         * @param {string} alias an alias for referencing the data within a template
         * @param {Function=} propertyValidator a function to type check the value for a property
         * @param {Element=} alternateParent an element where the template element will be
         * temporarily added as a child. If the parameter is ommitted, the componentElement will
         * be used
         * @return {Object} an object that implemenets three functions: peek(), subscribe() and dispose()
         * peek() returns the current value of the resolved properties, subscribe allows registering a subscription to the changes in resolved property values with
         * the subscription callback receiving the new value as a parameter, and dispose() removes the subscription.
         * @ignore
         */
        resolveProperties(componentElement, templateElement, elementTagName, propertySet, data, alias, propertyValidator, alternateParent) {
            const renderFunc = templateElement.render;
            const defaultProps = ojtemplateengineUtils.TemplateEngineUtils.getResolvedDefaultProps(this._defaultProps, elementTagName, propertySet);
            return ojtemplateengineUtils.PreactTemplate.resolveVDomTemplateProps(templateElement, renderFunc, elementTagName, propertySet, data, defaultProps, propertyValidator);
        }
    }

    /**
     * JET Template Engine implementation used by legacy components
     * with 'knockout' or 'none' binding providers.
     * @ignore
     */
    class JetTemplateEngine {
        constructor() {
            this._bindingProvider = {
                __ContextFor: ko.contextFor,
                __ExtendBindingContext: BindingProviderImpl.extendBindingContext,
                __KoComputed: ko.computed,
                __Observable: ko.observable
            };
            this._templateEngineKO = new TemplateEngineKoInternal();
            this._templateEngineVDOM = new TemplateEnginePreactInternal();
        }
        /**
         * The method checks whether the template is from Preact component (has 'render' method on it)
         * or it is a traditional template with child nodes. Then the appropriate executor is called on the template.
         * See executeTemplate() methods on internal implementations.
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {Object} properties data to be applied to the template
         * @param {string} alias an alias for referencing the data within a template
         * @param {Element} reportBusy - optional element for bubblng busy states outside of the template
         * @param {Map} provided - optional provided context to be applied to template
         * @return {Array.<Node>} HTML nodes representing the result of the execution
         * @ignore
         */
        execute(componentElement, templateElement, properties, alias, reportBusy, provided) {
            // Check to see if data-oj-as was defined on the template element as an additional
            // alias to provide to the template children
            const templateAlias = templateElement.getAttribute('data-oj-as');
            const processedNodes = ojtemplateengineUtils.TemplateEngineUtils.processTemplate(templateElement);
            if (processedNodes && processedNodes.replacementMap?.size > 0) {
                if (!properties) {
                    properties = {};
                }
                properties['_ojNodesMap'] = Object.fromEntries(processedNodes.replacementMap);
            }
            const context = ojtemplateengineUtils.TemplateEngineUtils.getContext(this._bindingProvider, componentElement, templateElement, properties, alias, templateAlias, provided);
            if (templateElement.render) {
                return this._templateEngineVDOM.executeTemplate(componentElement, templateElement, reportBusy, context, provided);
            }
            return this._templateEngineKO.executeTemplate(componentElement, templateElement, reportBusy, context, provided);
        }
        /**
         * Cleans specified node
         * @param node
         * @param componentElement component element used for execute call (used in preact template engine)
         * @ignore
         */
        clean(node, componentElement) {
            // Search for nodes created with VDom methods and let PreactTemplate clean them.
            let vdomTemplateRoots = ojtemplateengineUtils.PreactTemplate.findTemplateRoots(node, componentElement);
            vdomTemplateRoots.forEach((root) => {
                ojtemplateengineUtils.PreactTemplate.clean(root);
            });
            return ko.cleanNode(node);
        }
        /**
         * Resolves properties on an element of the template without producing
         * any DOM. This method should be used when a template is used exclusively for collecting
         * properties while iterating over data
         * @param {Element} componentElement component element
         * @param {Element} node the <template> element
         * @param {string} elementTagName tag name of the element where the property should be collected
         * @param {Set.<string>} propertySet properties to be resolved
         * @param {Object} data data to be applied to the template
         * @param {string} alias an alias for referencing the data within a template
         * @param {Function=} propertyValidator a function to type check the value for a property
         * @param {Element=} alternateParent an element where the template element will be
         * temporarily added as a child. If the parameter is ommitted, the componentElement will
         * be used
         * @return {Object} an object that implemenets three functions: peek(), subscribe() and dispose()
         * peek() returns the current value of the resolved properties, subscribe allows registering a subscription to the changes in resolved property values with
         * the subscription callback receiving the new value as a parameter, and dispose() removes the subscription.
         * @ignore
         */
        resolveProperties(componentElement, templateElement, elementTagName, propertySet, data, alias, propertyValidator, alternateParent) {
            if (templateElement.render) {
                return this._templateEngineVDOM.resolveProperties(componentElement, templateElement, elementTagName, propertySet, data, alias, propertyValidator, alternateParent);
            }
            return this._templateEngineKO.resolveProperties(componentElement, templateElement, elementTagName, propertySet, data, alias, propertyValidator, alternateParent);
        }
        /**
         * Defines a special 'tracked' property on the target object. Mutating the tracked property will automatically update
         * the DOM previously produced by the .execute() method
         * @param {Object} target an object where the property is defined
         * @param {string} name property name
         * @param {*=} optional initial value
         * @param {Function=} optional listener for value changes. Note that the listener
         * will be invoked both for upsteream and downstream changes
         * @ignore
         */
        defineTrackableProperty(target, name, value, changeListener) {
            ojtemplateengineUtils.TemplateEngineUtils.createPropertyBackedByObservable(this._bindingProvider, target, name, value, changeListener);
        }
    }

    var index = new JetTemplateEngine();

    return index;

});


define('ojs/ojtemplateengine-preact',['ojs/ojtemplateengine-utils'], function (ojtemplateengineUtils) { 'use strict';

    /**
     * JET Template Engine implementation for used by legacy components with 'preact'
     * binding provider and without 'knockout' dependencies.
     *
     * The template element must have 'render' property with function callback
     * that returns a body of the template.
     * The template will be processed using VDOM methods.
     */
    class PreactTemplateEngine {
        constructor() {
            this._defaultProps = new Map();
        }
        /**
         * Executes the template by calling function callback stored as 'render' property on the template.
         * The context is passed to the callback to process expressions.
         *
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {Object} properties data to be applied to the template
         * @param {string} alias an alias for referencing the data within a template
         * @param {Element} reportBusy - optional element for bubblng busy states outside of the template
         * @param {Map} provided - optional provided context to be applied to template
         * @return {Array.<Node>} HTML nodes representing the result of the execution
         * @ignore
         */
        execute(componentElement, templateElement, properties, alias, reportBusy, provided) {
            // Check to see if data-oj-as was defined on the template element as an additional
            // alias to provide to the template children
            const templateAlias = templateElement.getAttribute('data-oj-as');
            const context = ojtemplateengineUtils.TemplateEngineUtils.getContext(null, componentElement, templateElement, properties, alias, templateAlias, provided);
            if (templateElement.render) {
                return this._executeVDomTemplate(componentElement, templateElement, reportBusy, context, provided);
            }
            throw new Error(`The render property is expected on the template for component ${componentElement.id}`);
        }
        /**
         * Cleans specified node
         * @param node
         * @param componentElement component element used for execute call
         * @ignore
         */
        clean(node, componentElement) {
            // Search for nodes created with VDom methods and let PreactTemplate clean them.
            let vdomTemplateRoots = ojtemplateengineUtils.PreactTemplate.findTemplateRoots(node, componentElement);
            vdomTemplateRoots.forEach((root) => {
                ojtemplateengineUtils.PreactTemplate.clean(root);
            });
            return null;
        }
        /**
         * Resolves properties on an element of the template without producing
         * any DOM. This method should be used when a template is used exclusively for collecting
         * properties while iterating over data
         * @param {Element} componentElement component element
         * @param {Element} node the <template> element
         * @param {string} elementTagName tag name of the element where the property should be collected
         * @param {Set.<string>} propertySet properties to be resolved
         * @param {Object} data data to be applied to the template
         * @param {string} alias an alias for referencing the data within a template
         * @param {Function=} propertyValidator a function to type check the value for a property
         * @param {Element=} alternateParent an element where the template element will be
         * temporarily added as a child. If the parameter is ommitted, the componentElement will
         * be used
         * @return {Object} an object that implemenets three functions: peek(), subscribe() and dispose()
         * peek() returns the current value of the resolved properties, subscribe allows registering a subscription to the changes in resolved property values with
         * the subscription callback receiving the new value as a parameter, and dispose() removes the subscription.
         * @ignore
         */
        resolveProperties(componentElement, node, elementTagName, propertySet, data, alias, propertyValidator, alternateParent) {
            // The 'render' property on a template means that the template is a part of a VComponent.
            // The template will be processed with VDom methods
            const renderFunc = node.render;
            if (renderFunc) {
                const defaultProps = ojtemplateengineUtils.TemplateEngineUtils.getResolvedDefaultProps(this._defaultProps, elementTagName, propertySet);
                return ojtemplateengineUtils.PreactTemplate.resolveVDomTemplateProps(node, renderFunc, elementTagName, propertySet, data, defaultProps, propertyValidator);
            }
            throw new Error(`The render property is expected on the template for component ${componentElement.id}`);
        }
        /**
         * The method is not supported on this version of Template Engine
         * @param target
         * @param name
         * @param value
         * @param changeListener
         */
        defineTrackableProperty(target, name, value, changeListener) {
            throw new Error('This template engine does not support trackable property');
        }
        /**
         * Executes the template by calling function callback stored as 'render' property on the template.
         *
         * Template nodes will be cached in order to be updated when 'render' property value is updated,
         * in this case we don't need to refresh parent custom element completely.
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {Element} reportBusy - optional element for bubblng busy states outside of the template
         * @param {Object} context the binding context for the template  element
         * @param {Map} provided - optional provided context to be applied to template
         * @ignore
         */
        _executeVDomTemplate(componentElement, templateElement, reportBusy, context, provided) {
            const vNode = templateElement.render(context.$current);
            ojtemplateengineUtils.PreactTemplate.extendTemplate(templateElement, ojtemplateengineUtils.PreactTemplate._ROW_CACHE_FACTORY, (renderer) => {
                // When the renderer changes, rerender all cached rows
                templateElement._cachedRows.forEach((rowItem) => {
                    let newVNode = renderer(rowItem.currentContext);
                    ojtemplateengineUtils.PreactTemplate.renderNodes(componentElement, newVNode, rowItem, provided);
                });
            });
            // Use a parent node stub to render since preact's render() needs a parent node.
            const parentStub = document.createElement('div');
            if (reportBusy) {
                parentStub._ojReportBusy = reportBusy;
            }
            const cachedRow = {
                currentContext: context.$current,
                template: templateElement,
                parentStub,
                computedVNode: null,
                vnode: undefined,
                nodes: undefined
            };
            ojtemplateengineUtils.PreactTemplate.renderNodes(componentElement, vNode, cachedRow, provided);
            templateElement._cachedRows.push(cachedRow);
            return cachedRow.nodes;
        }
    }

    var index = new PreactTemplateEngine();

    return index;

});


define('ojs/ojcomposite-knockout',['ojs/ojcore-base', 'knockout', 'ojs/ojcustomelement', 'ojs/ojcustomelement-utils', 'ojs/ojkoshared', 'ojs/ojlogger', 'ojs/ojtemplateengine-ko'], function (oj, ko, ojcustomelement, ojcustomelementUtils, BindingProviderImpl, Logger, TemplateEngine) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  BindingProviderImpl = BindingProviderImpl && Object.prototype.hasOwnProperty.call(BindingProviderImpl, 'default') ? BindingProviderImpl['default'] : BindingProviderImpl;
  TemplateEngine = TemplateEngine && Object.prototype.hasOwnProperty.call(TemplateEngine, 'default') ? TemplateEngine['default'] : TemplateEngine;

  /**
   * @ignore
   */
  const CompositeTemplateRenderer = {};

  oj._registerLegacyNamespaceProp('CompositeTemplateRenderer', CompositeTemplateRenderer);

  /**
   * @ignore
   */
  CompositeTemplateRenderer.renderTemplate = function (params, element, view) {
    // Store composite children on a hidden node while slotting to avoid stale knockout bindings
    // when observables are updated while children are disconnected from DOM. The _storeNodes methods
    // also adds the storage node to the view so it's added to the DOM in setDomNodChildren
    var nodeStorage = CompositeTemplateRenderer._storeNodes(element, view);
    ko.virtualElements.setDomNodeChildren(element, view);

    // Attached is deprecated in 4.2.0 for connected which is called when the view is first attached to the DOM
    // and then each time the component is connected to the DOM after a disconnect
    CompositeTemplateRenderer.invokeViewModelMethod(element, params.viewModel, 'attached', [
      params.viewModelContext
    ]);
    CompositeTemplateRenderer.invokeViewModelMethod(element, params.viewModel, 'connected', [
      params.viewModelContext
    ]);

    var bindingContext = CompositeTemplateRenderer._getKoBindingContext();

    // Null out the parent references since we don't want the composite View to be able to access the outside context
    var childBindingContext = bindingContext.createChildContext(
      params.viewModel,
      undefined,
      function (ctx) {
        // for upstream dependency we will still rely components being registered on the oj namespace.
        ctx[oj.Composite.__COMPOSITE_PROP] = element;
        ctx.__oj_slots = params.slotMap;
        ctx.__oj_nodestorage = nodeStorage;
        ctx.$slotNodeCounts = params.slotNodeCounts;
        ctx.$slotCounts = params.slotNodeCounts;
        ctx.$props = params.props;
        ctx.$properties = params.props;
        ctx.$unique = params.unique;
        ctx.$uniqueId = params.uniqueId;
        ctx.$parent = null;
        ctx.$parentContext = null;
        ctx.$parents = null;
        ctx.$provided = null;
      }
    );

    ko.applyBindingsToDescendants(childBindingContext, element);

    CompositeTemplateRenderer.invokeViewModelMethod(element, params.viewModel, 'bindingsApplied', [
      params.viewModelContext
    ]);
  };

  /**
   * @ignore
   */
  CompositeTemplateRenderer.getEnclosingComposite = function (node) {
    var enclosing = null;
    // for upstream dependency we will still rely components being registered on the oj namespace.
    for (var ctx = ko.contextFor(node); ctx && !enclosing; ctx = ctx.$parentContext) {
      enclosing = ctx[oj.Composite.__COMPOSITE_PROP];
    }

    return enclosing;
  };

  /**
   * @ignore
   */
  CompositeTemplateRenderer.createTracker = function () {
    return ko.observable();
  };

  /**
   * @ignore
   */
  CompositeTemplateRenderer.invokeViewModelMethod = function (elem, model, name, args) {
    if (model == null) {
      return undefined;
    }
    var handler = model[name];
    if (typeof handler === 'function') {
      try {
        return ko.ignoreDependencies(handler, model, args);
      } catch (ex) {
        throw new Error(
          'Error while invoking ' +
            name +
            ' callback for ' +
            elem.tagName.toLowerCase() +
            " with id '" +
            elem.id +
            "'."
        );
      }
    }
    return undefined;
  };

  /**
   * @ignore
   */
  CompositeTemplateRenderer._storeNodes = function (element, view) {
    var nodeStorage;
    var childNodes = element.childNodes;
    if (childNodes) {
      nodeStorage = document.createElement('div');
      nodeStorage.setAttribute('data-bind', '_ojNodeStorage_');
      nodeStorage.style.display = 'none';
      view.push(nodeStorage);
      var assignableNodes = [];
      for (var i = 0; i < childNodes.length; i++) {
        var node = childNodes[i];
        if (ojcustomelementUtils.CustomElementUtils.isSlotable(node)) {
          assignableNodes.push(node);
        }
      }
      assignableNodes.forEach(function (_node) {
        nodeStorage.appendChild(_node); // @HTMLUpdateOK
      });

      ojcustomelementUtils.CustomElementUtils.subtreeHidden(nodeStorage);
    }
    return nodeStorage;
  };

  /**
   * @ignore
   */
  CompositeTemplateRenderer._getKoBindingContext = function () {
    // Cache the binding context that we use to generate the child
    // binding context for the View
    if (!CompositeTemplateRenderer._BINDING_CONTEXT) {
      var div = document.createElement('div');
      ko.applyBindings(null, div);
      CompositeTemplateRenderer._BINDING_CONTEXT = ko.contextFor(div);
      ko.cleanNode(div);
    }

    return CompositeTemplateRenderer._BINDING_CONTEXT;
  };

  /**
   * @private
   */
  CompositeTemplateRenderer._BINDING_CONTEXT = null;

  /**
   * @protected
   * @ignore
   */
  (function () {
    function _preprocessBindSlot(node, isTemplate) {
      var newNodes;
      var binding;
      var attrs = ['name', 'slot'];
      if (!isTemplate) {
        attrs.push('index');
        binding = 'ko _ojBindSlot_:{';
      } else {
        attrs.push('data');
        attrs.push('as');
        binding = 'ko _ojBindTemplateSlot_:{';
      }

      var valueExpressions = [];
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        var expr = _getExpression(node.getAttribute(attr));
        if (expr) {
          valueExpressions.push(attr + ':' + expr);
        }
      }
      binding += valueExpressions.join(',');
      binding += '}';

      var openComment = document.createComment(binding);

      var closeComment = document.createComment('/ko');

      newNodes = [openComment];

      var parent = node.parentNode;
      parent.insertBefore(openComment, node); // @HTMLUpdateOK

      // Copy the 'fallback content' children into the comment node
      while (node.childNodes.length > 0) {
        var child = node.childNodes[0];
        parent.insertBefore(child, node); // @HTMLUpdateOK
        newNodes.push(child);
      }

      newNodes.push(closeComment);

      parent.replaceChild(closeComment, node);
      return newNodes;
    }

    BindingProviderImpl.registerPreprocessor('oj-bind-slot', _preprocessBindSlot);

    BindingProviderImpl.registerPreprocessor('oj-slot', _preprocessBindSlot);

    BindingProviderImpl.registerPreprocessor('oj-bind-template-slot', function (node) {
      return _preprocessBindSlot(node, true);
    });

    function _getExpression(attrValue) {
      if (attrValue != null) {
        var exp = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrValue).expr;
        if (exp == null) {
          exp = "'" + attrValue + "'";
        }
        return exp;
      }

      return null;
    }
  })();

  ko.bindingHandlers._ojNodeStorage_ = {
    init: function () {
      return { controlsDescendantBindings: true };
    }
  };

  /**
   * Utilities shared between oj-bind-slot and oj-bind-template slot elements.
   * @private
   */
  const SlotUtils = {};

  oj._registerLegacyNamespaceProp('SlotUtils', SlotUtils);

  /**
   * Utility to move slot content to node storage to keep
   * bindings alive during cleanup.
   * @param {Element} element
   * @param {Object} bindingContext
   * @private
   */
  SlotUtils.cleanup = function (element, bindingContext) {
    var nodeStorage = bindingContext.__oj_nodestorage;
    // Move all non default template children to nodeStorage to keep bindings alive for
    // case where knockout if binding cleans up node when toggling state
    if (nodeStorage) {
      // Check to see if we've processed this node as an assigned node, skipping it if we haven't
      var node = ko.virtualElements.firstChild(element);
      while (node) {
        // Save a reference to the next node before we move it
        var next = ko.virtualElements.nextSibling(node);
        if (node.__oj_slots != null) {
          nodeStorage.appendChild(node); // @HTMLUpdateOK
          // Notifies JET components in node that they have been hidden
          if (node.nodeType === 1) {
            ojcustomelementUtils.CustomElementUtils.subtreeHidden(node);
          }
        }
        node = next;
      }
    }
  };

  /**
   * Cleanup method used by oj-bind-template-slot when the template is rendered by PreactTemplateEngine.
   * @param {*} engine
   * @param {*} componentElement
   * @param {*} nodes
   */
  SlotUtils.preactTemplateCleanup = function (engine, componentElement, nodes) {
    nodes.forEach((item) => {
      try {
        engine.clean(item, componentElement);
      } catch (err) {
        Logger.warn('Error during template cleanup ' + err);
      }
    });
  };

  ko.bindingHandlers._ojBindSlot_ = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
      // Add callback so we can move slot content to node storage during cleanup
      ko.utils.domNodeDisposal.addDisposeCallback(
        element,
        SlotUtils.cleanup.bind(null, element, bindingContext)
      );

      var slots = bindingContext.__oj_slots;

      var values = valueAccessor();
      var unwrap = ko.utils.unwrapObservable;
      var slotName = unwrap(values.name) || '';
      var slotAttr = unwrap(values.slot) || '';
      var index = unwrap(values.index);
      var assignedNodes = index != null ? [slots[slotName][index]] : slots[slotName];

      if (assignedNodes) {
        var i;
        for (i = 0; i < assignedNodes.length; i++) {
          // Save references to nodes we need to cleanup ._slot field
          var node = assignedNodes[i];
          // Get the slot value of this oj-bind-slot element so we can assign it to its
          // assigned nodes for downstream slotting
          node.__oj_slots = slotAttr;
        }
        ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);
        try {
          ko.virtualElements.setDomNodeChildren(element, assignedNodes);
        } finally {
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
        }

        // Notifies JET components in node that they have been shown
        for (i = 0; i < assignedNodes.length; i++) {
          var assignedNode = assignedNodes[i];
          if (assignedNode.nodeType === 1) {
            ojcustomelementUtils.CustomElementUtils.subtreeShown(assignedNode);
          }
        }
        return { controlsDescendantBindings: true };
      }

      // If no assigned nodes, then pass the slot value to default content
      var virtualChildren = ko.virtualElements.childNodes(element);
      virtualChildren.forEach(function (child) {
        if (isNodeSlotable(child)) {
          // eslint-disable-next-line no-param-reassign
          child.__oj_slots = slotAttr;
        }
      });
      // If no assigned nodes, let ko apply bindings to default slot content
      return undefined;
    }
  };

  function isNodeSlotable(node) {
    return node.nodeType === 1 || (node.nodeType === 3 && node.nodeValue.trim());
  }

  // Allow _ojBindSlot_ binding on virtual elements (comment nodes) which is done during knockout's preprocessNode method
  ko.virtualElements.allowedBindings._ojBindSlot_ = true;

  ko.bindingHandlers._ojBindTemplateSlot_ = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
      // Add callback so we can move slot content to node storage during cleanup
      ko.utils.domNodeDisposal.addDisposeCallback(
        element,
        SlotUtils.cleanup.bind(null, element, bindingContext)
      );

      var slots = bindingContext.__oj_slots;

      var values = valueAccessor();
      var unwrap = ko.utils.unwrapObservable;
      var slotName = unwrap(values.name) || '';
      var slotChildren = slots[slotName];
      // Take the last item matching the slot name
      var template = slotChildren && slotChildren[slotChildren.length - 1];
      // If no application provided template, check for default template
      var isDefaultTemplate = false;
      if (!template) {
        var virtualChildren = ko.virtualElements.childNodes(element);
        for (var i = 0; i < virtualChildren.length; i++) {
          if (virtualChildren[i].tagName === 'TEMPLATE') {
            isDefaultTemplate = true;
            template = virtualChildren[i];
            break;
          }
        }
      }

      if (template) {
        // for upstream dependency we will still rely components being registered on the oj namespace.
        var composite = bindingContext[oj.Composite.__COMPOSITE_PROP];
        if (template.tagName !== 'TEMPLATE') {
          Logger.error(
            "Slot content for slot '" +
              slotName +
              "' under " +
              composite.tagName.toLowerCase() +
              " with id '" +
              composite.id +
              "' should be wrapped inside a <template> node."
          );
        }
        // Get the slot value of this oj-bind-template element so we can assign it to its
        // assigned nodes for downstream slotting
        template.__oj_slots = unwrap(values.slot) || '';
        const engine = TemplateEngine;
        const componentElement = isDefaultTemplate ? element : composite;
        let nodes;

        // Re-execute the template if the oj-bind-template-slot bound attributes change
        ko.computed(function () {
          // Clean existing preact nodes on recompute
          if (template.render && nodes) {
            SlotUtils.preactTemplateCleanup(engine, componentElement, nodes);
          }
          // Use the template engine to execute the template
          var data = unwrap(values.data);
          var as = unwrap(values.as);

          // Extend the composite's bindingContext for the default template
          nodes = engine.execute(componentElement, template, data, isDefaultTemplate ? as : null);

          ko.virtualElements.setDomNodeChildren(element, nodes);
        });
        // Add cleanup methods for the vdom
        if (template.render) {
          // Need to execute engine.clean for PreactTemplateEngine to avoid memory leaks
          // when the composite component is disconnected.
          // Potentially this clean callback might be called on the nodes that are already cleaned,
          // but it does not looklike a big concern at moment. We might revork this code in the future
          // if it becomes an issue.
          const state = ojcustomelementUtils.CustomElementUtils.getElementState(composite);
          if (state.addTemplateCleanCallback) {
            state.addTemplateCleanCallback(() => {
              SlotUtils.preactTemplateCleanup(engine, componentElement, nodes);
            });
          }
          // Need to execute cleanup when the element is removed from DOM (conditional template rendering)
          ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
            SlotUtils.preactTemplateCleanup(engine, componentElement, nodes);
          });
        }
      } else {
        // Clear out any child nodes if no slot children or default template found
        ko.virtualElements.setDomNodeChildren(element, []);
      }
      return { controlsDescendantBindings: true };
    }
  };

  // Allow _ojBindTemplateSlot_ binding on virtual elements (comment nodes) which is done during knockout's preprocessNode method
  ko.virtualElements.allowedBindings._ojBindTemplateSlot_ = true;

});


define('ojs/ojcomposite',['exports', 'ojs/ojcore-base', 'ojs/ojhtmlutils', 'ojs/ojlogger', 'ojs/ojmetadatautils', 'ojs/ojcomposite-knockout', 'ojs/ojcustomelement', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry'], function (exports, oj, HtmlUtils, Logger, MetadataUtils, ojcompositeKnockout, ojcustomelement, ojcustomelementUtils, ojcustomelementRegistry) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  const CompositeInternal = {};

  /**
   * Finds the containing composite component for a given node. If the immediate enclosing
   * composite component is contained by another composite, the method will keep
   * walking up the composite hierarchy until the top-level composite
   * or the optional 'stopBelow' element is reached
   *
   * @param {Node} node the DOM node whose containing composite should be returned
   * @param {Element=} stopBelow the element where search should stop
   * @return {Element|null} the containing composite
   *
   * This method is currently intended for internal use only, and it is not exported
   * @ignore
   */
  CompositeInternal.getContainingComposite = function (node, stopBelow) {
    var composite = null;

    var _node = node;
    while (_node) {
      _node = oj.CompositeTemplateRenderer.getEnclosingComposite(_node);
      // : we should ignore oj-module component since it is not a relevant enclosing composite for this call
      if (_node && _node.nodeName.toLowerCase() !== 'oj-module') {
        // eslint-disable-next-line no-bitwise
        if (stopBelow && !((node.compareDocumentPosition(stopBelow) & 16) /* contained by*/)) {
          break;
        }
        composite = _node;
      }
    }

    return composite;
  };

  /**
   * @ignore
   */
  class CompositeState extends ojcustomelementUtils.LifecycleElementState {
      constructor() {
          super(...arguments);
          this._templateCleanCallbacks = [];
      }
      /**
       * @override
       */
      getTrackChildrenOption() {
          return 'immediate';
      }
      /**
       * Method is called during TemplateSlotBinding
       * when the template is rendered with Preact.
       * @param callback
       */
      addTemplateCleanCallback(callback) {
          this._templateCleanCallbacks.push(callback);
      }
      /**
       * The method is for cleaning templates rendered with Preact
       * when the composite is disconnected from DOM.
       */
      cleanTemplates() {
          this._templateCleanCallbacks.forEach((callback) => {
              callback();
          });
          this._templateCleanCallbacks = [];
      }
  }

  /**
   * JET component custom element bridge.
   *
   * Composite connnected callbacks occur asynchronously so we cannot
   * guarantee that child composite properties can be accessed before the
   * child busy state resolves.
   *
   * Composite code and applications should always wait on the element or page level
   * busy context before accessing properties or methods.
   *
   * @class
   * @ignore
   */
  const CompositeElementBridge = {};

  /**
   * Prototype for the JET component custom element bridge instance
   */
  CompositeElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);

  /** @ignore */
  CompositeElementBridge.DESC_KEY_CSS = 'css';
  /** @ignore */
  CompositeElementBridge.DESC_KEY_PARSE_FUN = 'parseFunction';
  /** @ignore */
  CompositeElementBridge.DESC_KEY_VIEW = 'view';
  /** @ignore */
  CompositeElementBridge.DESC_KEY_VIEW_MODEL = 'viewModel';
  /** @ignore */
  CompositeElementBridge.SUBID_MAP = 'data-oj-subid-map';

  CompositeElementBridge.DisconnectedState = 0;
  CompositeElementBridge.ConnectedState = 1;

  oj.CollectionUtils.copyInto(CompositeElementBridge.proto, {
    beforePropertyChangedEvent: function (element, property, detail) {
      var vmContext = { property: property };
      oj.CollectionUtils.copyInto(vmContext, detail);
      oj.CompositeTemplateRenderer.invokeViewModelMethod(
        element,
        this._VIEW_MODEL,
        'propertyChanged',
        [vmContext]
      );
    },

    AddComponentMethods: function (proto) {
      // Add subproperty getter/setter
      var setPropertyHelper = function (element, bridge, prop, value, propertyBag, isOuterSet) {
        if (!bridge.SaveEarlyPropertySet(element, prop, value)) {
          var setResult = bridge.SetProperty(element, prop, value, propertyBag, isOuterSet);
          if (setResult.propertySet) {
            if (setResult.isSubproperty) {
              // Retrieve the property tracker for the top level property and notify that a subproperty has
              // changed so any View bound subproperties will trigger a View update
              var propertyTracker = CompositeElementBridge._getPropertyTracker(
                bridge,
                setResult.property
              );
              propertyTracker.valueHasMutated();
            }
          }
        }
      };
      // eslint-disable-next-line no-param-reassign
      proto.setProperty = function (prop, value) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        setPropertyHelper(this, bridge, prop, value, this, true);
      };
      // eslint-disable-next-line no-param-reassign
      proto.getProperty = function (prop) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        return bridge.GetProperty(this, prop, this);
      };
      // eslint-disable-next-line no-param-reassign
      proto._propsProto.setProperty = function (prop, value) {
        // 'this' is the property object we pass to the ViewModel to track internal property changes
        setPropertyHelper(this._ELEMENT, this._BRIDGE, prop, value, this, false);
      };
      // eslint-disable-next-line no-param-reassign
      proto._propsProto.getProperty = function (prop) {
        // 'this' is the property object we pass to the ViewModel to track internal property changes
        return this._BRIDGE.GetProperty(this._ELEMENT, prop, this);
      };
      // Always add automation methods, but if the ViewModel defines overrides, wrap the overrides
      // and pass the default implementation in as the last parameter to the ViewModel's method.
      // eslint-disable-next-line no-param-reassign
      proto.getNodeBySubId = function (locator) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        var viewModel = bridge._getViewModel();
        if (viewModel.getNodeBySubId) {
          return viewModel.getNodeBySubId(locator, bridge._getNodeBySubId.bind(this));
        }
        return bridge._getNodeBySubId.bind(this)(locator);
      };
      // eslint-disable-next-line no-param-reassign
      proto.getSubIdByNode = function (node) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        var viewModel = bridge._getViewModel();
        if (viewModel.getSubIdByNode) {
          return viewModel.getSubIdByNode(node, bridge._getSubIdByNode.bind(this));
        }
        return bridge._getSubIdByNode.bind(this)(node);
      };
    },

    CreateComponent: function (element) {
      const state = ojcustomelementUtils.CustomElementUtils.getElementState(element);
      const slotMap = state.getSlotMap();
      // Setup the ViewModel context to pass to lifecycle listeners
      var slotNodeCounts = {};
      // Generate slot map before we update DOM with view nodes
      var slots = Object.keys(slotMap);
      for (var i = 0; i < slots.length; i++) {
        var slot = slots[i];
        slotNodeCounts[slot] = slotMap[slot].length;
      }
      var unique = ojcustomelementUtils.ElementUtils.getUniqueId();
      var vmContext = {
        element: element,
        props: Promise.resolve(this._PROPS),
        properties: this._PROPS,
        slotNodeCounts: Promise.resolve(slotNodeCounts),
        slotCounts: slotNodeCounts,
        unique: unique
      };
      vmContext.uniqueId = element.id ? element.id : unique;
      this._VM_CONTEXT = vmContext;

      var model = ojcustomelementRegistry.getElementDescriptor(element.tagName)[CompositeElementBridge.DESC_KEY_VIEW_MODEL];
      if (typeof model === 'function') {
        // eslint-disable-next-line new-cap
        model = new model(vmContext);
      } else {
        // The initialize callback is deprecated in 5.0.0. If the function returns a value, use it as the new model instance.
        model =
          oj.CompositeTemplateRenderer.invokeViewModelMethod(element, model, 'initialize', [
            vmContext
          ]) || model;
      }
      this._VIEW_MODEL = model;

      // This method can return a Promise which will delay additional lifecycle phases until it is resolved.
      var activatedPromise =
        oj.CompositeTemplateRenderer.invokeViewModelMethod(element, model, 'activated', [
          vmContext
        ]) || Promise.resolve(true);

      return activatedPromise.then(() => this._processCompositeTemplate(element));
    },

    DefineMethodCallback: function (proto, method, methodMeta) {
      // eslint-disable-next-line no-param-reassign
      proto[method] = function () {
        var methodName = methodMeta.internalName || method;
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        var viewModel = bridge._getViewModel();
        return viewModel[methodName].apply(viewModel, arguments);
      };
    },

    DefinePropertyCallback: function (proto, property, propertyMeta) {
      var set = function (value, bOuterSet) {
        // Properties can be set before the component is created. These early
        // sets are actually saved until after component creation and played back.
        if (!this._BRIDGE.SaveEarlyPropertySet(this._ELEMENT, property, value)) {
          if (bOuterSet) {
            // eslint-disable-next-line no-param-reassign
            value = ojcustomelementUtils.transformPreactValue(this._ELEMENT, property, propertyMeta, value);
          }
          // Property trackers are observables are referenced when the property is set or retrieved,
          // which allows us to automatically update the View when the property is mutated.
          var propertyTracker = CompositeElementBridge._getPropertyTracker(this._BRIDGE, property);
          var previousValue = propertyTracker.peek();
          if (!ojcustomelementUtils.ElementUtils.comparePropertyValues(propertyMeta.writeback, value, previousValue)) {
            // We should consider supporting custom comparators
            // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
            if (bOuterSet) {
              // eslint-disable-next-line no-param-reassign
              value = this._BRIDGE.ValidatePropertySet(this._ELEMENT, property, value);
            }

            if (propertyMeta._eventListener) {
              this._BRIDGE.SetEventListenerProperty(this._ELEMENT, property, value);
            }
            propertyTracker(value);

            if (!propertyMeta._derived) {
              var updatedFrom = bOuterSet ? 'external' : 'internal';
              oj.BaseCustomElementBridge.__FirePropertyChangeEvent(
                this._ELEMENT,
                property,
                value,
                previousValue,
                updatedFrom
              );
              this._BRIDGE.State.dirtyProps.add(property);
            }
          } else {
            Logger.info(
              ojcustomelementUtils.CustomElementUtils.getElementInfo(this._ELEMENT) +
                ": Ignoring property set for property '" +
                property +
                "' with same value."
            );
          }
        }
      };

      // Called on the ViewModel props object
      var innerSet = function (value) {
        set.bind(this)(value, false);
      };

      // Called on the custom element
      var outerSet = function (value) {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        set.bind(bridge._PROPS)(value, true);
      };

      var get = function (bOuterSet) {
        var propertyTracker = CompositeElementBridge._getPropertyTracker(this._BRIDGE, property);
        // If the attribute has not been set, return the default value
        // Calling .peek() lets us check the propertyTracker value without creating a dependency
        var value = bOuterSet ? propertyTracker.peek() : propertyTracker();
        if (value === undefined) {
          value = MetadataUtils.getDefaultValue(propertyMeta);
          propertyTracker(value);
        }
        return value;
      };

      // Called on the ViewModel props object
      var innerGet = function () {
        return get.bind(this, false)();
      };

      // Called on the custom element
      var outerGet = function () {
        var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(this);
        return get.bind(bridge._PROPS, true)();
      };

      // Don't add event listener properties for inner props
      if (!propertyMeta._derived) {
        oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(
          proto._propsProto,
          property,
          innerGet,
          innerSet
        );
      }
      oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto, property, outerGet, outerSet);
      ojcustomelementUtils.addPrivatePropGetterSetters(proto, property);
    },

    GetMetadata: function (descriptor) {
      // Composites have a public getMetadata API so we cannot directly modify the
      // original metadata object when we add additional info for on[PropertyName] properties
      return descriptor._metadata || {};
    },

    HandleDetached: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.HandleDetached.call(this, element);

      // Detached is deprecated in 4.2.0 for disconnected
      oj.CompositeTemplateRenderer.invokeViewModelMethod(element, this._VIEW_MODEL, 'detached', [
        element
      ]);
      oj.CompositeTemplateRenderer.invokeViewModelMethod(element, this._VIEW_MODEL, 'disconnected', [
        element
      ]);
      this._verifyConnectDisconnect(element, CompositeElementBridge.DisconnectedState);
    },

    HandleAttached: function (element) {
      this._verifyConnectDisconnect(element, CompositeElementBridge.ConnectedState);
    },

    HandleReattached: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.HandleReattached.call(this, element);

      // Check if the template was not rendered and render it if it is the case.
      // The connected callback will be called by CompositeTemplateRenderer.renderTemplate().
      if (this._delayedTemplateRender) {
        this._delayedTemplateRender = false;
        this._processCompositeTemplate(element);
      } else {
        oj.CompositeTemplateRenderer.invokeViewModelMethod(element, this._VIEW_MODEL, 'connected', [
          this._VM_CONTEXT
        ]);
      }

      this._verifyConnectDisconnect(element, CompositeElementBridge.ConnectedState);
    },

    InitializeElement: function (element) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

      ojcustomelementUtils.CustomElementUtils.markPendingSubtreeHidden(element);

      var descriptor;

      // Cache the View
      var cache = ojcustomelementRegistry.getElementRegistration(element.tagName).cache;
      if (!cache.view) {
        descriptor = ojcustomelementRegistry.getElementDescriptor(element.tagName);

        var view = descriptor[CompositeElementBridge.DESC_KEY_VIEW];
        // when multiple instances of the same CCA are on the same page, because of the async
        // nature, we could end up with multiple promises created on the same view. The first
        // resolved promise will set up cache.view, all others should just use the cached
        // view instead of parsing it again. So here we check existence of cache in the resolve
        // callback to avoid parsing the view multiple times.
        if (!cache.view) {
          if (typeof view === 'string') {
            cache.view = CompositeElementBridge._getDomNodes(view, element);
          } else {
            cache.view = view;
          }
        }
      }

      // Cache the CSS
      if (!cache.css) {
        if (!descriptor) {
          descriptor = ojcustomelementRegistry.getElementDescriptor(element.tagName);
        }
        // The CSS Promise will be null if loaded by the require-css plugin
        var css = descriptor[CompositeElementBridge.DESC_KEY_CSS];
        // CSS is optional so we need to check if it was provided
        if (css) {
          var style = document.createElement('style');
          style.type = 'text/css';
          if (style.styleSheet) {
            // for IE
            style.styleSheet.cssText = css;
          } else {
            style.appendChild(document.createTextNode(css)); // @HTMLUpdateOK
          }
          document.head.appendChild(style); // @HTMLUpdateOK
          // Set a flag that we've already processed and appended the style to the
          // document head so we only do this once for all composite instances
          cache.css = true;
        }
      }

      // Loop through all element attributes to get initial properties
      oj.BaseCustomElementBridge.__InitProperties(element, element);
    },

    InitializePrototype: function (proto) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializePrototype.call(this, proto);

      Object.defineProperty(proto, '_propsProto', { value: {} });
    },

    initializeBridge: function (element, descriptor) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.initializeBridge.call(this, element, descriptor);

      if (element._propsProto) {
        this._PROPS = Object.create(element._propsProto);
        this._PROPS._BRIDGE = this;
        this._PROPS._ELEMENT = element;
      }
    },

    ShouldRemoveDisabled: function () {
      // Composite components can opt in to have their disabled attribute removed.
      var ext = this.METADATA.extension;
      return ext ? ext._SHOULD_REMOVE_DISABLED === true : false;
    },

    _getNodeBySubId: function (locator) {
      // The locator subId can fall into one of 3 categories below:
      // 1) The target node belongs to a JET component or composite with a subId map
      // 2) The target node maps directly to a subId
      // 3) The composite does not have a match for the subId

      // The returned subId map the following key/value pairs:
      // {
      //    [subId]: {
      //      alias: [alias or null for non JET components],
      //      node: [node]
      //    }
      // }
      var map = CompositeElementBridge.__GetSubIdMap(this);
      var match = map[locator.subId];
      if (match) {
        if (match.alias) {
          // Case #1
          var clone = oj.CollectionUtils.copyInto({}, locator, undefined, true);
          clone.subId = match.alias;
          var component = match.node;
          // Check to see if we should call the method on the element or widget
          if (component.getNodeBySubId) {
            return component.getNodeBySubId(clone);
          }

          // For upstream or indirect dependency we will still rely components being registered on the oj namespace.
          return oj.Components.__GetWidgetConstructor(component)('getNodeBySubId', clone);
        }

        return match.node; // Case #2
      }

      return null; // Case #3
    },

    _getSubIdByNode: function (node) {
      // The node can fall into one of 3 categories below:
      // 1) The node is not a child of this composite.
      // 2) The node is a child of an inner composite and we need to convert its aliased subId
      // 3) The node is a child of this composite
      // 3a) The node is mapped directly to a subId
      // 3b) The node is owned by an element that has a getSubIdByNode method and we need to convert its aliased subId

      // Case #1
      if (!this.contains(node)) {
        return null;
      }

      // The returned node map has the following key/value pairs where nodeKey is
      // the value of the node's data-oj-subid[-map] attribute:
      // [nodeKey]: { map: [subIdMap], node: [node] }
      var nodeMap = CompositeElementBridge.__GetNodeMap(this);
      var nodeKey;
      var match;
      var locator;

      // Case #2
      var composite = CompositeInternal.getContainingComposite(node, this);
      if (composite != null) {
        nodeKey = composite.node.getAttribute(CompositeElementBridge.SUBID_MAP);
        match = nodeMap[nodeKey];
        if (match) {
          if (composite.getSubIdByNode) {
            locator = composite.getSubIdByNode(node);
            if (locator) {
              var alias = match.map[locator.subId];
              locator.subId = alias;
              return locator;
            }
          }
        }
        // Return null if we did not expose the node even though the inner composite does
        return null;
      }

      // Case #3
      // Walk up DOM tree until we find the containing node with the subId mapping
      var curNode = node;
      while (curNode !== this) {
        // We do not support an element having both attributes. If both are specified, -map takes precedence.
        nodeKey =
          curNode.getAttribute(CompositeElementBridge.SUBID_MAP) ||
          curNode.getAttribute('data-oj-subid');
        if (nodeKey) {
          break;
        }
        curNode = curNode.parentNode;
      }

      match = nodeMap[nodeKey];
      if (match) {
        var map = match.map;
        if (!map) {
          // Case #3a
          return { subId: nodeKey };
        }

        var component = match.node;
        // Check to see if we should call the method on the element or widget
        if (component.getSubIdByNode) {
          locator = component.getSubIdByNode(node);
        } else {
          // For upstream or indirect dependency we will still rely components being registered on the oj namespace.
          locator = oj.Components.__GetWidgetConstructor(component)('getSubIdByNode', node);
        }

        if (locator) {
          locator.subId = match.map[locator.subId];
          return locator;
        }
      }

      return null;
    },

    _getViewModel: function () {
      if (!this._VIEW_MODEL) {
        throw new ojcustomelementUtils.JetElementError(this._ELEMENT, 'Cannot access methods before element is upgraded.');
      }
      return this._VIEW_MODEL;
    },

    // Called from HandleAttached, HandleReattached, HandleDetached in order
    // to cleanup a composite on a true disconnect.
    _verifyConnectDisconnect: function (element, state) {
      if (this._verifyingState === undefined) {
        window.queueMicrotask(() => {
          if (this._verifyingState === state) {
            if (this._verifyingState === CompositeElementBridge.ConnectedState) {
              this._verifiedConnect(element);
            } else {
              this._verifiedDisconnect(element);
            }
            this._verifyingState = undefined;
          }
        });
      }
      this._verifyingState = state;
    },

    _verifiedConnect: function (element) {
      const state = ojcustomelementUtils.CustomElementUtils.getElementState(element);
      state.executeLifecycleCallbacks(true);
    },

    _verifiedDisconnect: function (element) {
      const state = ojcustomelementUtils.CustomElementUtils.getElementState(element);
      state.cleanTemplates();
      state.executeLifecycleCallbacks(false);
    },

    _processCompositeTemplate: function (element) {
      // Skip rendering the composite template since the it is not attached to the DOM.
      // The template will be rendered if and when the component will be reattached.
      // See HandleReattached().
      if (!element.isConnected) {
        this._delayedTemplateRender = true;
        return;
      }

      const state = ojcustomelementUtils.CustomElementUtils.getElementState(element);
      const slotMap = state.getSlotMap();
      const params = {
        props: this._PROPS,
        slotMap: slotMap,
        slotNodeCounts: this._VM_CONTEXT.slotCounts,
        unique: this._VM_CONTEXT.unique,
        uniqueId: this._VM_CONTEXT.uniqueId,
        viewModel: this._VIEW_MODEL,
        viewModelContext: this._VM_CONTEXT
      };

      // Store the name of the binding provider on the element when we are about
      // to insert the view. This will allow custom elements within the view to look
      // up the binding provider used by the composite (currently only KO).
      // eslint-disable-next-line no-param-reassign
      element[ojcustomelementUtils.CHILD_BINDING_PROVIDER] = 'knockout';

      ojcustomelementUtils.CustomElementUtils.unmarkPendingSubtreeHidden(element);

      const cache = ojcustomelementRegistry.getElementRegistration(element.tagName).cache;
      // Need to clone nodes first
      const view = CompositeElementBridge._getDomNodes(cache.view, element);
      oj.CompositeTemplateRenderer.renderTemplate(params, element, view);
    }
  });

  /** ***********************/
  /* PUBLIC STATIC METHODS */
  /** ***********************/

  /**
   * See Composite.register doc for details
   * @ignore
   *
   */
  CompositeElementBridge.register = function (tagName, descriptor) {
    var descrip = {};
    descrip[oj.BaseCustomElementBridge.DESC_KEY_META] = CompositeElementBridge._getResource(
      tagName,
      descriptor,
      oj.BaseCustomElementBridge.DESC_KEY_META
    );
    descrip[CompositeElementBridge.DESC_KEY_VIEW] = CompositeElementBridge._getResource(
      tagName,
      descriptor,
      CompositeElementBridge.DESC_KEY_VIEW
    );
    descrip[CompositeElementBridge.DESC_KEY_CSS] = CompositeElementBridge._getResource(
      tagName,
      descriptor,
      CompositeElementBridge.DESC_KEY_CSS
    );
    descrip[CompositeElementBridge.DESC_KEY_VIEW_MODEL] = CompositeElementBridge._getResource(
      tagName,
      descriptor,
      CompositeElementBridge.DESC_KEY_VIEW_MODEL
    );
    descrip[CompositeElementBridge.DESC_KEY_PARSE_FUN] =
      descriptor[CompositeElementBridge.DESC_KEY_PARSE_FUN];

    const registration = {
      descriptor: descrip,
      bridgeProto: CompositeElementBridge.proto,
      stateClass: CompositeState,
      composite: true,
      cache: {}
    };
    var metadata = descrip[oj.BaseCustomElementBridge.DESC_KEY_META];
    if (!metadata) {
      // Metadata is required starting in 3.0.0, but to be backwards compatible, just log a warning.
      Logger.warn("Composite registered'" + tagName.toLowerCase() + "' without Metadata.");
      metadata = {};
    }
    var view = descrip[CompositeElementBridge.DESC_KEY_VIEW];
    if (view == null) {
      throw new Error("Cannot register composite '" + tagName.toLowerCase() + "' without a View.");
    }

    // __ProcessEventListeners returns a copy of the metadata so we're not updating the original here.
    descrip._metadata = oj.BaseCustomElementBridge.__ProcessEventListeners(metadata, false);
    ojcustomelementRegistry.registerElement(tagName, registration, CompositeElementBridge.proto.getClass(descrip));
  };

  /** ***************************/
  /* NON PUBLIC STATIC METHODS */
  /** ***************************/

  /**
   * @ignore
   */
  CompositeElementBridge._getDomNodes = function (content, element) {
    var i;
    var clonedContent;
    if (typeof content === 'string') {
      return HtmlUtils.stringToNodeArray(content);
    } else if (CompositeElementBridge._isDocumentFragment(content)) {
      clonedContent = content.cloneNode(true);
      var nodes = [];
      for (i = 0; i < clonedContent.childNodes.length; i++) {
        nodes.push(clonedContent.childNodes[i]);
      }
      return nodes;
    } else if (Array.isArray(content)) {
      clonedContent = [];
      for (i = 0; i < content.length; i++) {
        clonedContent.push(content[i].cloneNode(true));
      }
      return clonedContent;
    }
    // TODO update this error message once we remove support for Array of DOM nodes and DocumentFragment
    throw new ojcustomelementUtils.JetElementError(
      element,
      'The composite View is not one of the following supported types: string, Array of DOM nodes, DocumentFragment'
    );
  };

  /**
   * Creates the subId and node maps needed for automation
   * @ignore
   */
  CompositeElementBridge._generateSubIdMap = function (bridge, element) {
    if (!bridge._SUBID_MAP) {
      // The format of the map will be { [composite subId] : {alias: [alias], node: [node] } }
      var subIdMap = {};
      var nodeMap = {};

      // data-oj-subid or data-oj-subid-map attributes can be defined on nested objects so we need
      // to walk the composite tree skipping over slots
      var children = element.children;
      for (var i = 0; i < children.length; i++) {
        CompositeElementBridge._walkSubtree(subIdMap, nodeMap, children[i]);
      }

      // eslint-disable-next-line no-param-reassign
      bridge._NODE_MAP = nodeMap;
      // eslint-disable-next-line no-param-reassign
      bridge._SUBID_MAP = subIdMap;
    }
  };

  /**
   * Walks a composite subtree, parsing and generating subId mappings.
   * @ignore
   */
  CompositeElementBridge._walkSubtree = function (subIdMap, nodeMap, node) {
    if (!node.hasAttribute('slot')) {
      CompositeElementBridge._addNodeToSubIdMap(subIdMap, nodeMap, node);
      // For upstream or indirect dependency we will still rely components being registered on the oj namespace.
      if (!ojcustomelementRegistry.isElementRegistered(node.tagName) && !oj.Components.__GetWidgetConstructor(node)) {
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
          CompositeElementBridge._walkSubtree(subIdMap, nodeMap, children[i]);
        }
      }
    }
  };

  /**
   * Checks to see if a node has defined subIds and adds them to the composite's
   * cached subId -> node and node -> subId maps for automation.
   * @ignore
   */
  CompositeElementBridge._addNodeToSubIdMap = function (subIdMap, nodeMap, node) {
    var nodeSubId = node.getAttribute('data-oj-subid');
    var nodeSubIdMapStr = node.getAttribute(CompositeElementBridge.SUBID_MAP);
    // We do not support an element having both attributes. If both are specified, -map takes precedence.
    if (nodeSubIdMapStr) {
      var parsedValue = JSON.parse(nodeSubIdMapStr);
      if (typeof parsedValue === 'object' && !(parsedValue instanceof Array)) {
        var nodeSubIdMap = parsedValue;
        var reverseMap = {};
        var keys = Object.keys(nodeSubIdMap);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          // eslint-disable-next-line no-param-reassign
          subIdMap[key] = { alias: nodeSubIdMap[key], node: node };
          reverseMap[nodeSubIdMap[key]] = key;
        }
        // eslint-disable-next-line no-param-reassign
        nodeMap[nodeSubIdMapStr] = { map: reverseMap, node: node };
      }
    } else if (nodeSubId) {
      // eslint-disable-next-line no-param-reassign
      subIdMap[nodeSubId] = { node: node };
      // eslint-disable-next-line no-param-reassign
      nodeMap[nodeSubId] = { node: node };
    }
  };

  /**
   * Returns the subId to node mapping for the composite's View.
   * @ignore
   */
  CompositeElementBridge.__GetSubIdMap = function (element) {
    var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    CompositeElementBridge._generateSubIdMap(bridge, element);
    return bridge._SUBID_MAP;
  };

  /**
   * Returns the node to subId mapping for the composite's View. The returned map has the
   * following key/value pairs where nodeKey is value of the node's data-oj-subid[-map] attribute:
   * {
   *   [nodeKey]: {
   *     map: [subIdMap],
   *     node: [node]
   *   }
   * }
   * @return {Map}
   * @ignore
   */
  CompositeElementBridge.__GetNodeMap = function (element) {
    var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(element);
    CompositeElementBridge._generateSubIdMap(bridge, element);
    return bridge._NODE_MAP;
  };

  /**
   * @ignore
   */
  CompositeElementBridge._getPropertyTracker = function (bridge, property) {
    if (!bridge._TRACKERS) {
      // eslint-disable-next-line no-param-reassign
      bridge._TRACKERS = {};
    }
    if (!bridge._TRACKERS[property]) {
      // eslint-disable-next-line no-param-reassign
      bridge._TRACKERS[property] = oj.CompositeTemplateRenderer.createTracker();
    }
    return bridge._TRACKERS[property];
  };

  /**
   * @ignore
   */
  CompositeElementBridge._getResource = function (tagName, descriptor, key) {
    var resource = descriptor[key];
    if (resource != null) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(resource, 'inline')) {
        return resource.inline;
      } else if (hasOwnProperty.call(resource, 'promise')) {
        throw new Error(
          'Error while registering ' +
            tagName +
            ". The resource type for descriptor key '" +
            key +
            "' is no longer supported." +
            ' The resource should be passed directly as the value instead.'
        );
      } else {
        return resource;
      }
    }
    return undefined;
  };

  /**
   * @ignore
   */
  CompositeElementBridge._isDocumentFragment = function (content) {
    if (window.DocumentFragment) {
      return content instanceof DocumentFragment;
    }

    return content && content.nodeType === 11;
  };

  /**
   * <p>
   *  JET allows developers to create custom components which can be composites of other components, HTML, JavaScript, or CSS.
   *  These reusable pieces of UI can be embedded as <a href="CustomElementOverview.html">custom HTML elements</a> and are
   *  registered using the Composite APIs described below. These custom components will be referred to
   *  as "composites" throughout the rest of this doc. Please see the <a href="CompositeOverview.html">JET Custom Components</a>
   *  concept doc for more information on how to create and use these custom components.
   * </p>
   *
   * @namespace
   * @ojtsmodule
   * @ojtsimport {module: "ojmetadata", type: "AMD", importName:"MetadataTypes"}
   * @since 2.0.0
   */
  const Composite = {};
  // this is the variable name that the AMD module will return in the require callback (used in a no-require environment)
  // eslint-disable-next-line no-unused-vars
  oj._registerLegacyNamespaceProp('Composite', Composite);

  /**
   * Returns a Promise resolving with the composite metadata with the given name or null if the composite has not been registered.
   * @param {string} name The component name, which should contain a dash '-' and not be a reserved tag name.
   * @return {Promise|null}
   * @ojdeprecated {since: '5.0.0', description: 'Use Composite.getComponentMetadata instead.'}
   * @ojsignature {target: "Type", value: "Promise<Composite.Metadata>|null", for: "returns", jsdocOverride: true}
   * @ignore
   * @memberof Composite
   */
  Composite.getMetadata = function (name) {
    var metadata = Composite.getComponentMetadata(name);
    return metadata ? Promise.resolve(metadata) : null;
  };

  /**
   * Returns the composite metadata with the given name or null if the composite has not been registered.
   * @param {string} name The component name, which should contain a dash '-' and not be a reserved tag name.
   * @return {Object|null}
   *
   * @export
   * @memberof Composite
   * @since 5.0.0
   *
   * @ojsignature {target: "Type", value: "MetadataTypes.ComponentMetadata|null", for: "returns", jsdocOverride: true}
   *
   */
  Composite.getComponentMetadata = function (name) {
    // We have one registry where custom elements, definitional elements, and composites are all stored with
    // the JET framework so we need to check to see if the element is a composite before returning its metadata
    if (ojcustomelementRegistry.isComposite(name)) {
      // Descriptor is guaranteed to be there for registered elements because we throw an error at registration
      // time if none is given
      var descriptor = ojcustomelementRegistry.getElementDescriptor(name);
      return descriptor[oj.BaseCustomElementBridge.DESC_KEY_META];
    }
    return null;
  };

  /**
   * Registers a composite component.
   * @param {string} name The component name, which should contain a dash '-' and not be a reserved tag name.
   * @param {Object} descriptor The registration descriptor. The descriptor will contain keys for Metadata, View, and ViewModel
   * that are detailed below. At a minimum a composite must register Metadata and View files, but all others are optional.
   * The composite resources should be mapped directly to each descriptor key.
   * See the <a href="CompositeOverview.html#registration">registration section</a> above for a sample usage.
   * @param {Object} descriptor.metadata A JSON formatted object describing the composite APIs. See the <a href="CompositeOverview.html#metadata">metadata documentation</a> for more info.
   * @param {string} descriptor.view A string representing the HTML that will be used for the composite.
   * @param {function(Composite.ViewModelContext):void} [descriptor.viewModel] This option is only applicable to composites hosting a Knockout template
   *                                      with a ViewModel and ultimately resolves to a constructor function.
   * @param {function(string, string, Object, function(string):any):any} [descriptor.parseFunction] The function that will be called to parse attribute values.
   *                                                              Note that this function is only called for non bound attributes. The parseFunction will take the following parameters:
   * <ul>
   *  <li>{string} value: The value to parse.</li>
   *  <li>{string} name: The name of the property.</li>
   *  <li>{Object} meta: The metadata object for the property which can include its type, default value,
   *      and any extensions that the composite has provided on top of the required metadata.</li>
   *  <li>{function(string):any} defaultParseFunction: The default parse function for the given attribute
   *      type which is used when a custom parse function isn't provided and takes as its parameter
   *      the value to parse.</li>
   * </ul>
   * @ojsignature [
   *               {target: "Type",
   *                value: "<P extends PropertiesType = PropertiesType>(name: string, descriptor: {
   *                metadata: MetadataTypes.ComponentMetadata;
   *                view: string;
   *                viewModel?: {new(context: ViewModelContext<P>): ViewModel<P>};
   *                parseFunction?: ((value: string, name: string, meta: MetadataTypes.ComponentMetadataProperties, defaultParseFunction?: (value: string) => any) => any);}): void"}]
   * @return {void}
   *
   * @export
   * @memberof Composite
   *
   */
  Composite.register = function (name, descriptor) {
    CompositeElementBridge.register(name, descriptor);
  };

  /**
   * Finds the containing composite component for a given node. If the immediate enclosing
   * composite component is contained by another composite, the method will keep
   * walking up the composite hierarchy until the top-level composite
   * or the optional 'stopBelow' element is reached
   *
   * @param {Node} node the DOM node whose containing composite should be returned
   * @param {Element=} stopBelow the element where search should stop
   * @return {Element|null} the containing composite
   *
   * This method is currently intended for internal use only, and it is not exported
   * @ignore
   */
  Composite.getContainingComposite = CompositeInternal.getContainingComposite;

  /**
   * @ignore
   */
  Composite.__COMPOSITE_PROP = '__oj_composite';

  /**
   * @ojoverviewdoc ComponentPackOverview - [9]JET Pack Metadata
   * @classdesc
   * {@ojinclude "name":"componentPackOverviewDoc"}
   */

  /**
   * <h2 id="usage">Overview
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h2>
   * <p>
   *  As development teams become more familiar with JET and gain experience with implementing and packaging reusable bits of application functionality as
   *  <a href="CompositeOverview.html">custom JET Web Components</a>, they encounter more complex use cases where multiple components have dependencies upon
   *  a set of shared development resources, including:  related Components, JavaScript base and utility classes, CSS files, icons, translation bundles, etc.
   * </p>
   * <p>
   *  The following JET component types can assist both JET Web Component producers and consumers with managing these complex use cases:
   *  <ul>
   *    <li><b>JET Component Packs, or JET Packs</b>, define versioned sets of JET Web Components that can be managed, packaged, and delivered as a whole.  JET Packs
   *      consist of metadata and additional artifacts that allow downstream consumers, such as Oracle Visual Builder or the JET Command Line interface,
   *      to automate the configuration and initialization of deployed applications that are built with these Components, including shared resources (e.g., CSS resources,
   *      utility JavaScript files, base JavaScript classes extended by multiple Web Components, etc.), and information about 3rd party packages.</li>
   *    <li><b>JET Reference Components</b> define a versioned external 3rd party library dependency  JET Packs, JET Resource Components, and individual JET Web Components can include
   *      a JET Reference Component as part of their <code>dependencies</code> metadata.  JET Reference Components consist of metadata for automating the installation of the corresponding
   *      3rd party library, as well as the necessary RequireJS configuration for calling into this 3rd party library from a deployed JET application.</li>
   *    <li><b>JET Resource Components</b> define and package resources shared by a set of JET Web Components  JET Packs, other JET Resource Components, and individual JET Web Components
   *      can include a JET Resource Component as part of their <code>dependencies</code> metadata.  Shared resources can include shared CSS, JavaScript base classes & utility code,
   *      icons, translation bundles, etc.</li>
   *  </ul>
   * </p>
   *
   * <h2 id="metadata">Metadata Structure
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#metadata"></a>
   * </h2>
   * <p>
   *   Metatata for JET Packs, JET Reference Components, and JET Resource Components is specified in a component.json file that is expected at the root
   *   of the Component's packaging.  Metadata properties like "name", "version", "jetVersion", "description", and "displayName" should be familiar from the
   *   <a href="MetadataOverview.html">metadata JSON</a> that is defined for JET Web Components.  The complete metadata structure for
   *   JET Packs, JET Reference Components, and JET Resource Components is as follows:
   * </p>
   *
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Required</th>
   *       <th>Type</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="rt">name</td>
   *       <td>yes</td>
   *       <td>{string}</td>
   *       <td>The component name.
   *           The component name must meet the following requirements (based upon the <a href="https://www.w3.org/TR/custom-elements/#custom-elements-core-concepts">W3C Custom Element spec</a>):
   *           <ul>
   *             <li>The name can include only letters, digits, '-', and '_'.</li>
   *             <li>The letters in the name should be all lowercase.</li>
   *             <li>The name must start with a lowercase letter.</li>
   *             <li>The name cannot be one of the following reserved names:</li>
   *             <ul>
   *               <li>annotation-xml</li>
   *               <li>color-profile</li>
   *               <li>font-face</li>
   *               <li>font-face-src</li>
   *               <li>font-face-uri</li>
   *               <li>font-face-format</li>
   *               <li>font-face-name</li>
   *               <li>missing-glyph</li>
   *             </ul>
   *           </ul>
   *           <h6>Note:</h6>
   *           The <b>full name</b> of a component consists of its <code>pack</code> metadata value and its <code>name</code> metadata value, appended
   *           together with a hyphen separating them:&nbsp;&nbsp;<code><i>[pack_value]</i>-<i>[name_value]</i></code>. For both JET Core
   *           Components and for JET Custom Components, <b>this full name corresponds to the Component's custom element tag name</b>. The names of
   *           standalone custom JET Web Components (i.e., custom components that are not members of a JET Pack, nor are JET Packs themselves) have
   *           the following additional requirements:
   *           <ul>
   *             <li>At least one hyphen is required.</li>
   *             <li>The first segment (up to the first hyphen) is a namespace prefix. <b>The namespace prefix 'oj' is reserved for components that are
   *               bundled with the JET release.</b></li>
   *             <li>The first hyphen must be followed by at least one character.</li>
   *           <ul>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="rt">version</td>
   *       <td>yes</td>
   *       <td>{string}</td>
   *       <td>The component version (following <a href="http://semver.org/">semantic version</a> rules). Note that changes to the metadata even for minor updates
   *         like updating the jetVersion should result in at least a patch component version change, e.g. 1.0.0 -> 1.0.1.</td>
   *     </tr>
   *     <tr>
   *       <td class="name">jetVersion</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>The <a href="http://semver.org/">semantic version</a> of the supported JET version(s).
   *         JET Component authors should not specify a semantic version range that includes unreleased JET major versions
   *         as major releases may contain non backwards compatible changes.  Authors should instead recertify components
   *         with each major release and update the metadata or release a new version that is compatible with the new
   *         release changes.
   *         <p><b>NOTE:</b>  Only valid for JET Packs and JET Resource Components.</p></td>
   *     </tr>
   *     <tr>
   *       <td class="name">bundles</td>
   *       <td>no</td>
   *       <td>{Object}</td>
   *       <td>Optional <a href="http://requirejs.org/docs/api.html#config-bundles">RequireJS-style bundles configuration</a> metadata that applies to
   *         JET Packs and JET Reference Components:
   *           <ul>
   *             <li>JET Packs may contain bundles that consist of multiple AMD modules (for example, each component could be packaged as a separate module).</li>
   *             <li>JET Reference Components may refer to 3rd party packages that include AMD-style bundles.</li>
   *           </ul>
   *         This configuration metadata allows RequireJS to map individual module names to the containing bundle.
   *         <p>The configuration object has the following properties:
   *            <table class="params">
   *              <thead>
   *                <tr>
   *                  <th>Key</th>
   *                  <th>Type</th>
   *                  <th>Description</th>
   *                </tr>
   *              </thead>
   *              <tbody>
   *                <tr>
   *                  <td class="name"><i>[bundle name]</i></td>
   *                  <td>{Array&lt;{string}>}</td>
   *                  <td>An array of module names contained within the specified bundle.</td>
   *                </tr>
   *              </tbody>
   *            </table>
   *            </br>
   *            Both the bundle names and the module names must correspond to paths that RequireJS is capable of loading.  This typically means prefixing these names
   *            with a prefix that is known to be path-mapped, such as:
   *              <ul>
   *                <li>the <code>pack</code> name for JET Packs</li>
   *                <li>some path that is specified by a JET Reference Component's <code>paths</code> metadata</li>
   *              </ul>
   *            Tools that consume JET Packs or JET Reference Components should merge the component.json <code>bundles</code> property into the applications RequireJS config
   *            at build time, thus allowing the application to run against the bundled artifacts.
   *         </p>
   *         <h6>Example:</h6>
   *         Assuming we have an oj-foo JET Pack that defines two bundles, the bundles property might be configured as follows:
   *  <pre class="prettyprint"><code>
   *  "bundles":
   *    {"oj-foo/some-bundle":
   *       ["oj-foo/component-one/loader", "oj-foo/component-two/loader"],
   *     "oj-foo/another-bundle":
   *       ["oj-foo/component-three/loader", "oj-foo/component-four/loader"],
   *    }
   *  </code></pre>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">dependencies</td>
   *       <td>no</td>
   *       <td>{Object}</td>
   *       <td>Dependency to semantic version mapping for JET Component dependencies.
   *         <h6>Example:</h6>
   *         <pre class="prettyprint"><code>dependencies:  {"oj-foo-composite1": "1.2.0", "oj-foo-composite2": "2.1.0"}</code></pre>
   *         <h6>Note:</h6>
   *           <ul>
   *             <li>Always use the <b>full name</b> of the component when declaring a dependency upon it.</li>
   *             <li>JET Packs use their <code>dependencies</code> metadata to specify the <b>exact</b> semantic versions of the JET Custom Components, JET Reference Components,
   *               and JET Resource Components that constitute the JET Pack  consequently, semantic version ranges are <b><i>not</i></b> permitted in JET Packs.</li>
   *             <li>JET Packs do not support nesting  in other words a JET Pack may not declare a dependency upon another JET Pack.</li>
   *             <li>JET Reference Components and JET Resource Components may use semantic version range syntax to specify the range of versions that are acceptable to fulfill
   *               their dependency requirements.</li>
   *           </ul>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">description</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>A high-level description for the component.</td>
   *     </tr>
   *     <tr>
   *       <td class="name">displayName</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>A user friendly, translatable name of the component.</td>
   *     </tr>
   *     <tr>
   *       <td class="name">extension</td>
   *       <td>no</td>
   *       <td>{Object}</td>
   *       <td>Placeholder for Extension metadata.  Each section is identified by a key that specifies the downstream tool that will process this metadata.
   *         <h6>For example:</h6>
   *         <table class="params">
   *           <thead>
   *             <tr>
   *               <th>Name</th>
   *               <th>Type</th>
   *               <th>Description</th>
   *             </tr>
   *           </thead>
   *           <tbody>
   *             <tr>
   *               <td class="name">vbdt</td>
   *               <td>{string}</td>
   *               <td>Indentifies an object with Visual Builder design time metadata</td>
   *             </tr>
   *           </tbody>
   *         </table>
   *         </br>
   *         Please consult the documentation for the downstream tool to determine what (if any) extension metadata is supported.
   *      </td>
   *     </tr>
   *     <tr>
   *       <td class="name">help</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>This optional metadata property is only valid for JET Packs. It specifies a URL to detailed API documentation for this JET Pack.<br/><br/>
   *           If unspecified, downstream consumers can look for a default <code>docs/index.html</code> file off of the root of
   *           the JET Pack package.
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">license</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>A reference to the license under which use of the component is granted. The value can be:
   *         <ul>
   *           <li>the name of the license text file packaged with the component</li>
   *           <li>a URL to a remote license file</li>
   *         </ul>
   *         If unspecified, downstream consumers can look for a default, case-insensitive license file at the root of the component package.
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">pack</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>Identifies the component as belonging to the specified JET Pack.
   *         <p>A JET Pack is a versioned set of JET Components with additional metadata that enables applications to easily install and configure path mappings to the artifacts in that JET Pack.
   *           <ul>
   *             <li>If specified, then there should exist a JET Pack whose name is the <code>pack</code> value, and which lists this component's <b>full name</b> in its
   *               <code>dependencies</code> metadata.</li>
   *             <li>If unspecified, then this is a standalone JET Component that is not a member of any JET Pack.</li>
   *             <li>JET Packs do not supported nesting and are therefore, by definition, standalone JET Components.</li>
   *           </ul>
   *         </p>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">package</td>
   *       <td>no</td>
   *       <td>{string}</td>
   *       <td>This metadata property is only valid for JET Reference Components, where it is a <b>REQUIRED</b> property.
   *         <p>Specifies the name of the AMD-compatible <a href="https://www.npmjs.com/">npm</a> package that is referenced by this component.  This is needed to allow the consuming application
   *           to identify the 3rd party library, for conflict resolution purposes as well as for security scanning and patching.
   *         </p>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">paths</td>
   *       <td>no</td>
   *       <td>{Object | Array&lt;{Object}>}</td>
   *       <td>Specifies path metadata that is used to generate RequireJS path mappings.
   *         <p>Each object is defined as follows:</p>
   *         <table class="params">
   *           <thead>
   *             <tr>
   *               <th>Key</th>
   *               <th>Type</th>
   *               <th>Description</th>
   *             </tr>
   *           </thead>
   *           <tbody>
   *             <tr>
   *               <td class="name">npm</td>
   *               <td>{Object}</td>
   *               <td>Specifies paths to use when configuring a path mapping to an npm package.  <b>This is only valid for JET Reference Components.</b>  At least one of the
   *                 following sub-properties must be specified:
   *                 <table class="params">
   *                   <thead>
   *                     <tr>
   *                       <th>Key</th>
   *                       <th>Type</th>
   *                       <th>Description</th>
   *                     </tr>
   *                   </thead>
   *                   <tbody>
   *                     <tr>
   *                       <td class="name">min</td>
   *                       <td>{string}</td>
   *                       <td>Path to the optimized form of the library, relative to the root of the npm package.</td>
   *                     </tr>
   *                     <tr>
   *                       <td class="name">debug</td>
   *                       <td>{string}</td>
   *                       <td>Path to the debug form of the library, relative to the root of the npm package.</td>
   *                     </tr>
   *                   </tbody>
   *                 </table>
   *               </td>
   *             </tr>
   *             <tr>
   *               <td class="name">cdn</td>
   *               <td>{Object}</td>
   *               <td>Specifies url-based paths to use when configuring a path mapping to a CDN-hosted artifact.  It is strongly recommended that urls be specified with <code>https:</code>,
   *                 as this is required for HTTP/2 and the consuming app may be configured to disallow non-secure urls.  At least one of the following sub-properties must be specified:
   *                 <table class="params">
   *                   <thead>
   *                     <tr>
   *                       <th>Key</th>
   *                       <th>Type</th>
   *                       <th>Description</th>
   *                     </tr>
   *                   </thead>
   *                   <tbody>
   *                     <tr>
   *                       <td class="name">min</td>
   *                       <td>{string}</td>
   *                       <td>The full url to the location of the optimized form of the artifact.</td>
   *                     </tr>
   *                     <tr>
   *                       <td class="name">debug</td>
   *                       <td>{string}</td>
   *                       <td>The full url to the location of the debug form of the artifact.</td>
   *                     </tr>
   *                   </tbody>
   *                 </table>
   *               </td>
   *             </tr>
   *             <tr>
   *               <td class="name">name</td>
   *               <td>{string}</td>
   *               <td>Optional value to use on the left hand side of the RequireJS path mapping when installing a JET Reference Component into an application. If not specified,
   *                 then the name defaults to the value of the <code>package</code> property, excluding any <a href="https://docs.npmjs.com/misc/scope">scope</a>.</td>
   *             </tr>
   *           </tbody>
   *         </table>
   *         <h6>Notes:</h6>
   *         <ul>
   *           <li>If the <code>paths</code> value is an array, then each array item is of the type described above.  When an array is specified, each element must resolve to a unique value
   *             for the <code>name</code> property.  (In practical terms, that means that only one element in the array can leverage the <code>package</code> property value for its default
   *             <code>name</code> value.)</li>
   *           <li>In addition to its use for JET Reference Components, <code>paths</code> is also valid for JET Packs and JET Resource Components <b>with the following restrictions</b>:
   *             <ol>
   *               <li>Only a single path mapping is allowed (in other words, the value cannot be an array);</li>
   *               <li>The <code>name</code> sub-property is ignored  the left hand side of the RequireJS path mapping always defaults to the JET Pack or JET Resource Component <code>name</code>
   *                 property value;</li>
   *               <li>The <code>npm</code> sub-property is ignored  JET Packs and JET Resource Components can leverage the <code>cdn</code> sub-property to configure loading those artifacts
   *                 at runtime from a CDN;</li>
   *               <li>The information in the <code>paths</code> property is ignored for JET Resource Components that are part of a JET Pack  only the JET Pack itself will be path mapped.</li>
   *             </ol>
   *           </li>
   *         </ul>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">publicModules</td>
   *       <td>no</td>
   *       <td>{Array&lt;{string}>}</td>
   *       <td>This metadata property is only valid for JET Resource Components.
   *         <p>JET Resource Components define and package resources shared by a set of JET Web Components, typically collected into a JET Pack.  By default,
   *            these shared resources are considered private, but sometimes it makes sense for a JET Resource Component to provide public utility modules
   *            that can be independently imported into a JET application.</p>
   *         <p>The <code>publicModules</code> metadata property specifies an array of paths to public modules that can be imported into a JET application.
   *            Oracle JET Tooling leverages this metadata to automatically build minified modules for these public utilities.</p>
   *         <p>The full path to the public module to be imported takes the form:  <code><i>[pack]</i>/<i>[name]</i>/<i>[publicModules entry]</i></code></p>
   *         <h6>Example:</h6>
   *         Assuming an <code>oj-foo-utils</code> Resource Component, which is a dependency for an <code>oj-foo</code> JET Pack:
   *  <pre class="prettyprint"><code>
   *  {
   *    "name": "utils",
   *    "pack": "oj-foo",
   *    "type": "resource",
   *    "displayName": "oj-foo Utilities",
   *    "publicModules": [
   *      "validators/fooValidatorFactory",
   *      "converters/fooConverterFactory"
   *    ],
   *    ...
   *  }
   *  </code></pre>
   *
   *         Importing <code>fooValidatorFactory</code> into a JET application written in JavaScript:
   *  <pre class="prettyprint"><code>
   *  define(['ojs/ojcore', ..., 'oj-foo/utils/validators/fooValidatorFactory'],
   *    function(oj, ...) {
   *      ...
   *  }
   *  </code></pre>
   *
   *         Importing <code>fooValidatorFactory</code> into a JET application written in TypeScript:
   *  <pre class="prettyprint"><code>
   *  import {fooValidatorFactory} from "oj-foo/utils/validators/fooValidatorFactory.js";
   *  </code></pre>
   *
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name">type</td>
   *       <td>no</td>
   *       <td>{"composite" | "core" | "pack" | "reference" | "resource"}
   *         <p><b>Default:</b>&nbsp;&nbsp;"composite"</p>
   *       </td>
   *       <td>Identifies the type of this JET Component.
   *         <p>Supported values are:</p>
   *         <table class="params">
   *           <thead>
   *             <tr>
   *               <th>Value</th>
   *               <th>Description</th>
   *             </tr>
   *           </thead>
   *           <tbody>
   *             <tr>
   *               <td class="name">composite</td>
   *               <td>Identifies the component as a <a href="ComponentTypeOverview.html#customcomponents">custom JET Web Component</a>, also known as a "Composite Component".
   *                 <b>This is the default, if <code>type</code> is unspecified.</b></td>
   *             </tr>
   *             <tr>
   *               <td class="name">core</td>
   *               <td>Identifies the component as a <a href="ComponentTypeOverview.html#corecomponents">JET Web Component</a> that is bundled with a particular version of JET.</td>
   *             </tr>
   *             <tr>
   *               <td class="name">pack</td>
   *               <td>Identifies the component as a <a href="ComponentTypeOverview.html#componentpacks">JET Component Pack</a>, or <b>JET Pack</b>.  A JET Pack is a versioned set
   *                 of JET Web Components with additional metadata that enables applications to easily install and configure path mappings to the artifacts in that JET Pack.
   *                 <p>The <code>dependencies</code> metadata property is used to specify the versioned components that make up the JET Pack.</p></td>
   *             </tr>
   *             <tr>
   *               <td class="name">reference</td>
   *               <td>Identifies the component as a <a href="ComponentTypeOverview.html#referencecomponents">JET Reference Component</a>, which describes a versioned external 3rd party library.
   *                 <p>A JET Reference Component can be referenced in the <code>dependencies</code> metadata of a JET Pack, a JET Resource Component, or an individual JET Web Component.</p>
   *               </td>
   *             </tr>
   *             <tr>
   *               <td class="name">resource</td>
   *               <td>Identifes the component as a <a href="ComponentTypeOverview.html#resourcecomponents">JET Resource Component</a>, which describes a versioned set of shared resources
   *                 (such as shared CSS, JavaScript base classes & utility code, icons, translation bundles, etc.)
   *                 <p>A JET Resource Component can be referenced in the <code>dependencies</code> metadata of a JET Pack, another JET Resource Component, or an individual JET Web Component.</p>
   *               </td>
   *             </tr>
   *           </tbody>
   *         </table>
   *         <p>Metadata for JET Web Components are described in more detail in the <a href="MetadataOverview.html">JET Metadata</a> topic.</p>
   *      </td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment componentPackOverviewDoc
   * @memberof ComponentPackOverview
   */

  /**
   * @ojoverviewdoc ComponentTypeOverview - [1]JET Component Types
   * @classdesc
   * {@ojinclude "name":"componentTypeOverviewDoc"}
   */
  /**
   * <h2 id="usage">Overview
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h2>
   * <p>
   *  JET Components are used to develop enterprise web applications.  In addition to offering Web Components, implemented as
   *  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">HTML custom elements</a>, JET supports
   *  other component types that help both producers and consumers package, install, and configure a set of related Web Components along
   *  with their dependencies and shared resources.  The full set of JET Component types are described below.
   * </p>
   *
   * <h2 id="corecomponents">JET Core Components
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#corecomponents"></a>
   * </h2>
   * <p>
   * <b>JET Core Components</b> are Web Components that are packaged and delivered with a particular release of JET.  These include standard
   * <a href="CustomElementOverview.html">custom element</a> widgets like buttons, input controls, data collection controls, data visualization controls,
   * declarative binding controls, etc.
   * </p>
   * <p>
   * See <a href="MetadataOverview.html">JET Metadata</a> for a discussion of the metadata structures that describe JET Web Components.
   * </p>
   *
   * <h2 id="customcomponents">JET Custom Components
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#customcomponents"></a>
   * </h2>
   * <p>
   * <b>JET Custom Components</b> are Web Components, typically developed, packaged, and distributed by other development teams, built on top of the JET Composite
   * Component Architecture.  These are also known as <a href="CompositeOverview.html">composite components</a>.
   * </p>
   * <p>
   * See <a href="MetadataOverview.html">JET Metadata</a> for a discussion of the metadata structures that describe JET Web Components.
   * </p>
   *
   * <h2 id="componentpacks">JET Component Packs
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#componentpacks"></a>
   * </h2>
   * <p>
   * <b>JET Component Packs, or JET Packs</b>, define versioned sets of JET Web Components that can be managed, packaged, and delivered as a whole.  JET Packs
   * consist of metadata and additional artifacts that allow downstream consumers to automate the configuration and initialization of deployed applications that are built
   * with these Components, including shared resources (e.g., CSS resources, utility JavaScript files, base JavaScript classes extended by multiple Web Components, etc.),
   * and information about 3rd party packages.
   * </p>
   * <p>
   * See <a href="ComponentPackOverview.html">JET Pack Metadata</a> for a discussion of the metadata structures that describe JET Packs and other components that manage
   * dependencies and shared resources.
   * </p>
   *
   * <h2 id="referencecomponents">JET Reference Components
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#referencecomponents"></a>
   * </h2>
   * <p>
   * <b>JET Reference Components</b> define a versioned external 3rd party library dependency  JET Packs, JET Resource Components, and individual JET Web Components can include
   * a JET Reference Component as part of their <code>dependencies</code> metadata.  JET Reference Components consist of metadata for automating the installation of the corresponding AMD-compatible
   * 3rd party library, as well as the necessary RequireJS configuration for calling into this 3rd party library from a deployed JET application.
   * </p>
   * <p>
   * See <a href="ComponentPackOverview.html">JET Pack Metadata</a> for a discussion of the JET Reference Component metadata structure.
   * </p>
   *
   * <h2 id="resourcecomponents">JET Resource Components
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#resourcecomponents"></a>
   * </h2>
   * <p>
   * <b>JET Resource Components</b> define and package resources shared by a set of JET components  JET Packs, other JET Resource Components, and individual JET Web Components can include
   * a JET Resource Component as part of their <code>dependencies</code> metadata.  Shared resources can include shared CSS, JavaScript base classes & utility code, icons, translation bundles, etc.
   * </p>
   * <p>
   * See <a href="ComponentPackOverview.html">JET Pack Metadata</a> for a discussion of the JET Resource Component metadata structure.
   * </p>
   *
   * @ojfragment componentTypeOverviewDoc
   * @memberof ComponentTypeOverview
   */

  /**
   * @ojoverviewdoc CompositeOverview - [3]JET Custom Components
   * @classdesc
   * {@ojinclude "name":"compositeOverviewDoc"}
   */

  /**
   * <h2 id="usage">Overview
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h2>
   * <p>
   *  JET allows developers to create custom Web Components which can be composites of other components, HTML, JavaScript, or CSS.
   *  These reusable pieces of UI can be embedded as <a href="CustomElementOverview.html">custom HTML elements</a> and are
   *  registered using the <a href="Composite.html">Composite API</a>. These custom Web Components will be referred to
   *  as "composites" throughout the rest of this doc.
   * </p>
   *
   * <h2 id="usage">Using a Composite
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#usage"></a>
   * </h2>
   * <p>
   *   Once registered within a page, a composite component can be used in the DOM as a custom HTML element like in the example below.
   *   A composite element will be recognized by the framework only after its module is loaded by the application. Once the element is
   *   recognized, the framework will register a busy state for the element and will begin the process of 'upgrading' the element.
   *   The element will not be ready for interaction (e.g. retrieving properties or calling methods) until the upgrade process is
   *   complete with the exception of property setters and the setProperty and setProperties methods.
   *   The application should listen to either the page-level or an element-scoped BusyContext before attempting to interact with
   *   any JET custom elements. See the <a href="oj.BusyContext.html">BusyContext</a> documentation on how BusyContexts can be scoped.
   * </p>
   * <pre class="prettyprint"><code>
   * &lt;my-chart type="bubble" data="{{dataModel}}">&lt;/my-chart>
   * </code></pre>
   * <p>
   *   The upgrade of JET composite elements relies on any data binding resolving, the management of which is done by a binding provider.
   *   The binding provider is responsible for setting and updating attribute expressions and any custom elements within its managed
   *   subtree will not finish upgrading until it applies bindings on that subtree. By default, there is a single binding provider for a page,
   *   but subtree specific binding providers can be added by using the <code>data-oj-binding-provider</code> attribute with values of
   *   "none" and "knockout". The default binding provider is knockout, but if a page or DOM subtree does not use any expression syntax or
   *   knockout, the application can set <code>data-oj-binding-provider="none"</code> on that element so its dependent JET composite custom
   *   elements do not need to wait for bindings to be applied to finish upgrading.
   * </p>
   * <p>
   *  Since a composite is registered as a custom HTML element, the same set of rules for attribute/property setting, data binding,
   *  method access, slotting, and event listening that apply to JET custom elements apply to composites. Please see the general
   *  <a href="CustomElementOverview.html">JET Component Overview</a> documentation to for more details.
   * </p>
   *
   * <h2 id="writing">Writing a Composite
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#writing"></a>
   * </h2>
   *
   * <h3 id="registration">Packaging and Registration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#registration"></a>
   * </h3>
   * <p>
   * Composite components should be packaged as a standalone module in a folder matching the tag name it will be registered with, e.g. 'my-chart'.
   * An application would use a composite by requiring it as a module, e.g. 'jet-composites/my-chart/loader'. The composite module could be
   * stored locally in the app which is the recommended approach, but could also be stored on a different server, or a CDN.  Note that there are
   * XHR restrictions when using the RequireJS text plugin which may need additional RequireJS config settings.  Please see the
   * <a href="https://github.com/requirejs/text#xhr-restrictions">text plugin documentation</a> for the full set of limitations and options.
   * By using RequireJS path mappings, the application can control where individual composites are loaded from.
   * See below for a sample RequireJS composite path configuration.
   *
   * Note that the 'jet-composites/my-chart' mapping is only required if the 'my-chart' composite module maps to a folder other than
   * 'someSubFolder/jet-composites/my-chart' using the configuration below.
   * <pre class="prettyprint"><code>
   * requirejs.config(
   * {
   *   baseUrl: 'js',
   *   paths:
   *   {
   *     'jet-composites': 'someSubFolder/jet-composites',
   *     'jet-composites/my-chart': 'https://someCDNurl',
   *     'jet-composites/my-table': 'https://someServerUrl'
   *   }
   * }
   * </code></pre>
   * </p>
   *
   * <p>
   * All composite modules should contain a loader.js file which will handle registering and specifying the dependencies for a composite component.
   * We recommend using RequireJS to define your composite module with relative file dependencies.
   * Registration is done via the <a href="Composite.html#.register">Composite.register</a> API.
   * By registering a composite component, an application links an HTML tag with provided
   * Metadata, View, ViewModel and CSS which will be used to render the composite. These optional
   * pieces can be provided via a descriptor object passed into the register API. See below for sample loader.js file configurations.
   * </p>
   *
   * Note that in this example we are using require-css, a RequireJS plugin for loading css which will load the styles within our page
   * so we do not need to pass any css into the register call. This is the recommended way to load CSS, especially for cases
   * where the composite styles contain references to any external resources.
   * <pre class="prettyprint"><code>
   * define(['ojs/ojcomposite', 'text!./my-chart.html', './my-chart', 'text!./my-chart.json', 'css!./my-chart'],
   *   function(Composite, view, viewModel, metadata) {
   *     Composite.register('my-chart',
   *     {
   *       metadata: JSON.parse(metadata),
   *       view: view,
   *       viewModel: viewModel
   *     });
   *   }
   * );
   * </code></pre>
   *
   * This example shows how to register a custom parse function which will be called to parse attribute values defined in the metadata.
   * <pre class="prettyprint"><code>
   * define(['ojs/ojcomposite', 'text!./my-chart.html', './my-chart', 'text!./my-chart.json'],
   *   function(Composite, view, viewModel, metadata) {
   *     var myChartParseFunction = function(value, name, meta, defaultParseFunction) {
   *       // Custom parsing logic goes here which can also return defaultParseFunction(value) for
   *       // values the composite wants to default to the default parsing logic for.
   *       // This function is only called for non bound attributes.
   *     }
   *
   *     Composite.register('my-chart',
   *     {
   *       metadata: JSON.parse(metadata),
   *       view: view,
   *       viewModel: viewModel,
   *       parseFunction: myChartParseFunction
   *     });
   *   }
   * );
   * </code></pre>
   *
   * <h3 id="metadata">Metadata
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#metadata"></a>
   * </h3>
   * <p>
   *  Composite Metadata should be provided in a component.json file and contains information about the
   *  composite used at run time to wire properties accessors and methods on the custom element. The JET
   *  Metadata schema also allows composite authors to include information that would benefit a design time
   *  environment and is described in more detail in the <a href="MetadataOverview.html">Metadata Overview</a>
   *  doc.
   * </p>
   * <h4>Example of Run Time Metadata</h4>
   * <p>
   *  The JET framework will ignore "extension" fields. Extension fields cannot be defined at
   *  the first level of the "properties", "methods", "events", or "slots" objects.
   * </p>
   * <pre class="prettyprint"><code>
   * {
   *  "name": "demo-card",
   *  "version": "1.0.2",
   *  "jetVersion": ">=3.0.0 <5.0.0",
   *  "properties": {
   *    "currentImage" : {
   *      "type": "string",
   *      "readOnly": true
   *    },
   *    "images": {
   *      "type": "Array<string>"
   *    },
   *    "isShown": {
   *      "type": "boolean",
   *      "value": true
   *    }
   *  },
   *  "methods": {
   *    "nextImage": {
   *      "internalName": "_nextImg"
   *      "extension": "This is where a composite can store additional data."
   *    },
   *    "prevImage": {}
   *   },
   *   "events": {
   *     "cardclick": {}
   *   }
   * }
   * </code></pre>
   *
   * <h3 id="view">View
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#viewmodel"></a>
   * </h3>
   * <p>
   * The composite View is the template HTML that will be stamped into the DOM when bindings are applied to the composite.
   * </p>
   *
   * <h4 id="viewprops">View Variables
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#viewmodel"></a>
   * </h4>
   * <p>
   * The View has access to several '$' variables along with any public variables defined in the composite's ViewModel.
   * Public ViewModel variables can be accessed by referencing the variable names directly without needing to access them from another
   * object. The View's '$' variables are similar to what is available on context object passed to the composite ViewModel constructor
   * and are listed below.
   * <ul>
   *   <li>$properties: A map of the composite component's current properties and values.</li>
   *   <li>$slotCounts: A map of slot name to assigned nodes count for the View.</li>
   *   <li>$unique: A unique string that can be used for unique id generation.</li>
   *   <li>$uniqueId: The ID of the composite component if specified. Otherwise, it is the same as unique.</li>
   * </ul>
   * </p>
   *
   * <h4 id="slotting">Slotting
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#slotting"></a>
   * </h4>
   * <p>
   * The View can also contain slots where application provided DOM can go.
   * Complex composite components which can contain additional composites and/or content for child facets defined in its
   * associated View can be constructed via slotting. There are two ways to define a composite's slots, using either an
   * <a href="oj.ojBindSlot.html">oj-bind-slot</a> element or an <a href="oj.ojBindTemplateSlot.html">oj-bind-template-slot</a>
   * element to indicate that that slot's content will be stamped using an application provided template. See the relevant
   * slot API docs for more information.
   * </p>
   *
   * <h4 id="bindorder-section">
   *   Binding Order
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#bindorder-section"></a>
   * </h4>
   * <p>The following steps will occur when processing the binding for a composite component:
   * <ol>
   *  <li>Apply bindings to children using the composite component's binding context.</li>
   *  <li>Create a slot map assigning component child nodes to View slot elements.
   *    <ol>
   *      <li>At this point the component child nodes are removed from the DOM and live in the slot map.</li>
   *    </ol>
   *  </li>
   *  <li>Insert the View and apply bindings to it with the ViewModel's binding context.
   *    <ol>
   *      <li>The composite's children will be 'slotted' into their assigned View slots.</li>
   *      <li>The oj-bind-slot's slot attribute, which is "" by default, will override its assigned node's slot attribute.</li>
   *    </ol>
   *  </li>
   * </ol>
   * </p>
   *
   * <h3 id="viewmodel">ViewModel
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#viewmodel"></a>
   * </h3>
   * <p>
   * If a constructor function is provided at registration, a new instance of the ViewModel will be created for each composite element.
   * The ViewModel is where the composite's internal logic lives and can expose public variables that the View can bind to. The ViewModel
   * constructor is called with a <a href=#ViewModelContext>context</a> object that allows the ViewModel logic to access
   * the composite element, the current set of properties, and other keys.
   * </p>
   *
   * <h4 id="viewmodelprops">Interacting with Properties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#viewmodelprops"></a>
   * </h4>
   * <p>
   * The ViewModel can access and update properties from the context.properties object. Any updates to context.properties will be interpreted
   * as an internal property change. This is where readOnly and writeback property updates can be done, e.g. context.properties.value = 'new value'.
   * Updates to properties on the composite element will be interpreted as coming from the application and updates to readOnly properties will
   * be blocked. These internal property updates will trigger [property]Changed events and can be differentiated from application triggered property
   * udpates using the updatedFrom field on the [property]Changed events. All ViewModel property updates will result in 'internal' set as
   * the updatedFrom field.
   * </p>
   * <p>
   * The context.properties object also has setProperty, getProperty, setProperties methods similar to the composite element. The
   * setProperty method should be used when updating subproperties so [property]Changed events are fired with the subproperty
   * field populated correctly.
   * </p>
   * <p>
   * The ViewModel can listen to property changes by registering a <a href="Composite.html#ViewModel">propertyChanged</a> callback. The callback
   * is called with a <a href="Composite.html#PropertyChangedContext">context</a> object that has the same set of properties as a [property]Changed
   * event. This listener will be called before the [property]Changed event is fired allowing the composite to react first.
   * </p>
   *
   * <h4 id="lifecycle">Lifecycle Callbacks
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#lifecycle"></a>
   * </h4>
   * <p>
   * A set of optional callback methods can be implemented on the ViewModel and will be called at each stage of the composite
   * lifecycle. These callbacks can be used to delay composite rendering, perform expensive actions like data fetches, and react
   * to property changes. To see the full set of lifecycle callbacks, see the <a href=Composite.html#ViewModel>Composite.ViewModel</a>
   * typedef for details.
   * </p>
   *
   * <h4 id="events">Firing Custom Events
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events"></a>
   * </h4>
   * <p>
   * If the composite needs to fire any events, it should done using the
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">CustomEvent</a> constructor, which JET provides a
   * polyfill for on IE. Events should be documented in the metadata for design time environments.
   * </p>
   *
   * <h3 id="styling">CSS
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#styling"></a>
   * </h3>
   * <p>
   * Composite component styling can be done via provided CSS. The JET framework will add the <code>oj-complete</code> class to the composite DOM
   * element after metadata properties have been resolved. To prevent a flash of unstyled content before the composite properties have been setup,
   * the composite CSS can include the following rule to hide the composite until the <code>oj-complete</code> class is set on the element.
   * <pre class="prettyprint"><code>
   * my-chart:not(.oj-complete) {
   *   visibility: hidden;
   * }
   * </code></pre>
   * </p>
   *
   * <p>
   * Composite CSS will not be scoped to the composite component and selectors will need to be appropriately selective. We recommend scoping CSS classes
   * and prefixing class names with the composite name as seen in the example below. <b>Note that we do not recommend overriding JET component CSS.
   * Composites should only update JET component styling via SASS variables.</b>
   * <pre class="prettyprint"><code>
   * my-chart .my-chart-text {
   *   color: white;
   * }
   * </code></pre>
   * </p>
   *
   * @ojfragment compositeOverviewDoc
   * @memberof CompositeOverview
   */

  /**
   * @ojoverviewdoc MetadataOverview - [8]JET Metadata
   * @classdesc
   * {@ojinclude "name":"metadataOverviewDoc"}
   */

  /**
   * <h2 id="usage">Overview
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h2>
   * <p>
   *  Metadata for a <a href="CustomElementOverview.html">JET Web Component</a> consists of a JSON formatted object which defines the
   *  properties, methods, slots, dynamic slots, and events fired by that component. <b>The names of the JET Web Component's properties, events,
   *  and methods should avoid collision with the existing <a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement">HTMLElement</a>
   *  properties, events, and methods. Additionally, the JET Web Component should not re-define any
   *  <a href="https://html.spec.whatwg.org/multipage/dom.html#global-attributes">global attributes or events</a>.
   *  Please refer to the <a href="https://html.spec.whatwg.org/multipage/">HTML Living Standard</a> for the latest guidance.</b>
   * </p>
   *
   * <p>
   *  The Metadata JSON object should have the following required properties: "name", "version", "jetVersion" and
   *  the following optional properties: "description", "dependencies", "icon", "displayName", "properties", "methods", "events", "slots", and "dynamicSlots".
   *  See the tables below for descriptions of these properties. The Metadata can be extended by appending any extra information in an "extension"
   *  field except at the first level of the "properties", "methods", "events", "slots" or "dynamicSlots" objects. Any metadata in an extension field will be ignored.
   * </p>
   *
   * <p>
   *  Keys defined in the "properties" top level object should map to the JET Web Component's properties following
   *  the same naming convention described in the <a href="CustomElementOverview.html#ce-proptoattr-section">Property-to-Attribute mapping</a> section.
   *  Non expression bound JET Web Component attributes will be correctly evaluated only if they are a primitive JavaScript type (boolean, number, string)
   *  or a JSON object. Note that JSON syntax requires that strings use double quotes. Attributes evaluating to any other types must be bound via expression syntax.
   *  Boolean attributes are considered true if set to the case-insensitive attribute name, the empty string or have no value assignment.
   *  JET Web Components will also evalute boolean attributes set explicitly to 'true' or 'false' to their respective boolean values. All other values are invalid.
   * </p>
   *
   * <p>
   *  Not all information provided in the Metadata is required at run time and those not indicated to be required at run time in the tables
   *  below can be omitted to reduce the Metadata download size. Any non run time information can be used for design time tools and property editors and could
   *  be kept in a separate JSON file which applications can use directly or merge with the run time metadata as needed, but would not be required by the loader.js
   *  file. For methods and events, only the method/event name is required at run time.
   * </p>
   *
   * <p>
   *  Note that the JET release includes a <code>'metadata/components'</code> directory with metadata for each JET Web Component that is bundled
   *  as part of that release.  JET Web Components that are bundled as part of a JET release are also referred to as <b>JET Core Components</b>. The
   *  JSON for each JET Core Component uses the exact same format as the metadata packaged with <b>JET Custom Components</b> (also known as
   *  <a href="CompositeOverview.html">composite components</a>), such that design time tools and property editors can leverage a common metadata format
   *  when integrating any JET Web Component into their environments.
   * </p>
   *
   * <h2 id="structure">Metadata Structure
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#structure"></a>
   * </h2>
   * <h3 id="top">Top Level Keys
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#top"></a>
   * </h3>
   * <%MetadataTypes.ComponentMetadata%>
   * <h3 id="ComponentMetadataProperties">Property Keys
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ComponentMetadataProperties"></a>
   * </h3>
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Value</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>[property name]</code></td>
   *       <td>Object containing the following properties:
   *          <%MetadataTypes.ComponentMetadataProperties%>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   * <h3 id="ComponentMetadataMethods">Method Keys
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ComponentMetadataMethods"></a>
   * </h3>
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Value</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>[method name]</code></td>
   *       <td>Object containing the following properties:
   *          <%MetadataTypes.ComponentMetadataMethods%>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   * <h3 id="ComponentMetadataEvents">Event Keys
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ComponentMetadataEvents"></a>
   * </h3>
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Value</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>[event name]</code></td>
   *       <td>Object containing the following properties:
   *          <%MetadataTypes.ComponentMetadataEvents%>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   * <h3 id="ComponentMetadataSlots">Slot Keys
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ComponentMetadataSlots"></a>
   * </h3>
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Value</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>[slot name]</code></td>
   *       <td>Object containing the following properties:
   *          <%MetadataTypes.ComponentMetadataSlots%>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   * <h6 class="notoc">Note:</h6>
   * <ul>
   *  <li>By convention, the slot name for a component's Default slot is the empty string:  <code>""</code>.</li>
   *  <li>Slots should follow a logical ordering representing their preferred presentation in a design-time environment:</li>
   *  <ul>
   *    <li>The Default slot should always be first.</li>
   *    <li>Slots that are rendered in specific locations should be ordered from top-start to bottom-end.</li>
   *    <li>Slots that are more typically used should be ordered ahead of slots that are used in more specialized use cases.</li>
   *  </ul>
   * </ul>
   * <h3 id="ComponentMetadataDynamicSlots">Dynamic Slot Keys
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ComponentMetadataDynamicSlots"></a>
   * </h3>
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Value</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>[dynamic slot definition key]</code></td>
   *       <td>Object containing the following dynamic template slot properties:
   *          <%MetadataTypes.ComponentMetadataSlots%>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   * <h6 class="notoc">Note:</h6>
   * An empty object is sufficient for specifying that the component supports dynamic slots.
   * Conversely, if the <code>dynamicSlots</code> metadata element is unspecified, then the component does not support dynamic slots.
   *
   * @ojfragment metadataOverviewDoc
   * @memberof MetadataOverview
   */

  /**
   *
   * @ojcomponent oj.ojBindSlot
   * @ojshortdesc An oj-bind-slot acts as a placeholder for child DOM to appear in a specified slot.
   * @ojbindingelement
   * @ojsignature {target: "Type", value: "class ojBindSlot extends HTMLElement"}
   * @ojmodule ojcomposite
   * @since 4.1.0
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["index", "name"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-binding-control'
   *
   * @classdesc
   * <h3 id="overview-section">
   *   Slot Binding
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview-section"></a>
   * </h3>
   * <p>
   * The oj-bind-slot element is used inside a composite View as a placeholder for child DOM and is
   * a declarative way to define a <a href="CustomElementOverview.html#ce-slots-section">slot</a>.
   * Default markup can be defined if no child DOM is assigned to that particular
   * slot by adding the markup as children of the slot. An oj-bind-slot element with a name attribute
   * whose value is not the empty string is referred to as a named slot. A slot without a name attribute or one
   * whose name value is the empty string is referred to as the default slot where any composite
   * children without a slot attribute will be moved to.
   * </p>
   *
   * <h3 id="slotprops-section">
   *   Slot Properties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#slotprops-section"></a>
   * </h3>
   * <ul>
   *  <li>A default slot is a slot element whose slot name is the empty string or missing.</li>
   *  <li>More than one node can be assigned to the same slot.</li>
   *  <li>A slot can also have a slot attribute and be assigned to another slot.</li>
   *  <li>A slot can have fallback content which are its child nodes that will be used in the DOM in its place if it has no assigned nodes.</li>
   *  <li>A slot can also also have an index attribute to allow the slot's assigned nodes
   *    to be individually slotted (e.g. in conjunction with an oj-bind-for-each element).</li>
   * </ul>
   *
   * <h3 id="nodeprops-section">
   *   Assignable Node Properties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#nodeprops-section"></a>
   * </h3>
   * <ul>
   *  <li>Nodes with slot attributes will be assigned to the corresponding named slots (if
   *    present) and all other assignable nodes (Text or Element) will be assigned to
   *    the default slot (if present).</li>
   *  <li>The slot attribute of a node is only applied once. If the View contains a
   *    composite and the node's assigned slot is a child of that composite, the slot
   *    attribute of the assigned slot is inherited for the slotting of that composite.</li>
   *  <li>Nodes with slot attributes that reference slots not present in the View will not appear in the DOM.</li>
   *  <li>If the View does not contain a default slot, nodes assigned to the default slot will not appear in the DOM.</li>
   *  <li>Nodes that are not assigned to a slot will not appear in the DOM.</li>
   * </ul>
   *
   * <h3 id="example1-section">
   *   Example #1: Basic Usage
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#example1-section"></a>
   * </h3>
   * Note that the IDs are provided for sample purposes only.
   * <h4>Initial DOM</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;component-a>
   *  &lt;div id="A" slot="foo">&lt;/div>
   *  &lt;div id="B" slot="bar">&lt;/div>
   *  &lt;div id="C">&lt;/div>
   *  &lt;div id="D" slot="foo">&lt;/div>
   *  &lt;div id="E" slot="cat">&lt;/div>
   * &lt;/component-a>
   * </code>
   * </pre>
   *
   * <h4>View</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;!-- component-a View -->
   * &lt;div id="outerFoo">
   *  &lt;oj-bind-slot name="foo">&lt;/oj-bind-slot>
   * &lt;/div>
   * &lt;div id="outerBar">
   *  &lt;oj-bind-slot name="bar">&lt;/oj-bind-slot>
   * &lt;/div>
   * &lt;div id="outerBaz">
   *  &lt;oj-bind-slot name="baz">
   *    &lt;!-- Default Content -->
   *    &lt;img id="F">&lt;/img>
   *    &lt;div id="G">&lt;/div>
   *  &lt;/oj-bind-slot>
   * &lt;/div>
   * &lt;div id="outerDefault">
   *  &lt;oj-bind-slot>
   *    &lt;!-- Default Content -->
   *    &lt;div id="H">&lt;/div>
   *  &lt;/oj-bind-slot>
   * &lt;/div>
   * </code>
   * </pre>
   *
   * <h4>Final DOM</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;component-a>
   *  &lt;div id="outerFoo">
   *      &lt;div id="A" slot="foo">&lt;/div>
   *      &lt;div id="D" slot="foo">&lt;/div>
   *  &lt;/div>
   *  &lt;div id="outerBar">
   *      &lt;div id="B" slot="bar">&lt;/div>
   *   &lt;/div>
   *  &lt;div id="outerBaz">
   *      &lt;img id="F">&lt;/img>
   *      &lt;div id="G">&lt;/div>
   *  &lt;/div>
   *  &lt;div id="outerDefault">
   *      &lt;div id="C">&lt;/div>
   *  &lt;/div>
   * &lt;/component-a>
   * </code>
   * </pre>
   *
   * <h3 id="example2-section">
   *   Example #2: Slot Attribute Evaluation
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#example2-section"></a>
   * </h3>
   * <p>When a node is assigned to a slot, its slot value is not used for subsequent
   *  slot assignments when child bindings are applied. Instead that slot's slot attribute,
   *  which by default is "", overrides the assigned node's slot attribute. No actual
   *  DOM changes will be made to the assigned node's slot attribute, but its evaluated
   *  slot value will be managed internally and used for applying subsequent child bindings.</p>
   *
   * <h4>Initial DOM</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;component-a>
   *  &lt;div id="A" slot="foo">&lt;/div>
   * &lt;/component-a>
   * </code>
   * </pre>
   *
   * <h4>View</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;!-- component-a View -->
   * &lt;component-b>
   *  &lt;oj-bind-slot name="foo">&lt;/oj-bind-slot>
   * &lt;/component-b>
   *
   * &lt;!-- component-b View -->
   * &lt;div id="outerFoo">
   *  &lt;oj-bind-slot name="foo">&lt;/oj-bind-slot>
   * &lt;/div>
   * &lt;div id="outerDefault">
   *  &lt;oj-bind-slot>&lt;/oj-bind-slot>
   * &lt;/div>
   * </code>
   * </pre>
   *
   * <p>When applying bindings for the component-a View, the oj-bind-slot binding will replace
   * slot foo with div A. Slot foo's slot attribute ("") overrides div A's ("foo")
   * so that the evaluated slot value ("") will be used when applying subsequent child bindings.<p>
   * <pre class="prettyprint">
   * <code>
   * &lt;!-- DOM -->
   * &lt;component-a>
   *  &lt;!-- Start component-a View -->
   *  &lt;component-b>
   *    &lt;!-- Evaluated slot value is "" -->
   *    &lt;div id="A" slot="foo">&lt;/div>
   *  &lt;/component-b>
   *  &lt;!-- End component-a View -->
   * &lt;/component-a>
   * </code>
   * </pre>
   *
   * <p>When applying bindings for the component-b View, the oj-bind-slot binding will replace
   *  component-b's default slot with div A since it's evaluated slot value is "".</p>
   * <pre class="prettyprint">
   * <code>
   * &lt;!-- DOM -->
   * &lt;component-a>
   *  &lt;!-- Start component-a View -->
   *  &lt;component-b>
   *    &lt;!-- Start component-b View -->
   *    &lt;div id="outerFoo">
   *    &lt;/div>
   *    &lt;div id="outerDefault">
   *      &lt;div id="A" slot="foo">&lt;/div>
   *    &lt;/div>
   *    &lt;!-- End component-b View -->
   *  &lt;/component-b>
   *  &lt;!-- End component-a View -->
   * &lt;/component-a>
   * </code>
   * </pre>
   *
   * <h3 id="deferred-section">
   *   Deferred Slots
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-section"></a>
   * </h3>
   * As a performance enhancement, the composite can participate in deferred slot
   * rendering by conditionally rendering a slot element inside a conditional oj-bind-if element
   * and document that certain slots will be lazily rendered. This gives the application the opportunity
   * to wrap their slot content in an <a href="oj.ojDefer.html">oj-defer</a> element and have the
   * bindings for that deferred content be delayed. oj.Components.subtreeHidden/Shown will automatically
   * be called on the slot contents when they are added or removed from a slot. <b>Note that due to a current
   * limitation, the slot element should be wrapped in an HTML element (e.g. &lt;div> or &lt;span>), when it is a child of an
   * oj-bind-if element or a knockout if binding on a comment node.</b> It is not required to wrap when
   * the slot element is a child of a knockout if binding on an HTML element.
   *
   * <h4>Initial DOM</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;card-component>
   *  &lt;oj-defer slot="front">
   *    &lt;div>
   *      ...
   *    &lt;/div>
   *  &lt;/oj-defer>
   *  &lt;oj-defer slot="back">
   *    &lt;div>
   *      ...
   *    &lt;/div>
   *  &lt;/oj-defer>
   * &lt;/card-component>
   * </code>
   * </pre>
   *
   * <h4>View</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-bind-if test="isFront">
   *   &lt;div>
   *     &lt;oj-bind-slot class="card-component-front">
   *       ...
   *     &lt;/oj-bind-slot>
   *   &lt;/div>
   * &lt;/oj-bind-if>
   * &lt;oj-bind-if test="!isFront">
   *   &lt;div>
   *     &lt;oj-bind-slot class="card-component-back">
   *       ...
   *     &lt;/oj-bind-slot>
   *   &lt;/div>
   * &lt;/oj-bind-if>
   * </code>
   * </pre>
   */

  /**
   * An index value allowing the slot children to be individually slotted. This is useful
   * when the composite needs to add additional DOM around slotted children.
   * @expose
   * @name index
   * @memberof oj.ojBindSlot
   * @instance
   * @type {number}
   * @example <caption>
   *          Use an oj-bind-for-each element inside the composite View to stamp out
   *          li wrapped oj-bind-slot elements that correspond to the number of slot children.
   *          The oj-bind-slot elements should have the value for the name attribute, but different indices.
   *          </caption>
   * &lt;!-- Composite View -->
   * &lt;ul>
   *   &lt;oj-bind-for-each data="[[new Array($slotCounts.foo)]]">
   *     &lt;template>
   *       &lt;li>
   *         &lt;oj-bind-slot name="foo" index="[[$current.index]]">&lt;/oj-bind-slot>
   *       &lt;/li>
   *     &lt;/template>
   *   &lt;/oj-bind-for-each>
   * &lt;/ul>
   */

  /**
   * The name of the slot.
   * @expose
   * @name name
   * @memberof oj.ojBindSlot
   * @instance
   * @type {string}
   * @example <caption>Define a slot within a composite View with the name "foo":</caption>
   * &lt;oj-bind-slot name="foo">
   *   &lt;div>My Contents&lt;/div>
   * &lt;/oj-bind-slot>
   */

  /**
   * <p>The <code class="prettyprint">oj-bind-slot</code> default slot is used to
   * specify fallback content which will be used in the DOM if the slot has no
   * assigned nodes.  As with assigned nodes, the fallback content will inherit
   * the slot attribute of the oj-bind-slot itself.
   *
   *
   * @ojchild Default
   * @memberof oj.ojBindSlot
   * @ojshortdesc The oj-bind-slot default slot is used to specify fallback content which will be used in the DOM if the slot has no assigned nodes.
   * @instance
   * @expose
   */

  /**
   *
   * @ojcomponent oj.ojBindTemplateSlot
   * @ojshortdesc An oj-bind-template-slot acts as a placeholder for stamped child DOM to appear in a specified slot.
   * @ojbindingelement
   * @ojsignature {target: "Type",
   *               value: "class ojBindTemplateSlot<D> extends HTMLElement",
   *               genericParameters: [{"name": "D", "description": "Type of data to be provided to the template"}]}
   * @ojmodule ojcomposite
   * @since 5.1.0
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["name"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-binding-control'
   *
   * @classdesc
   * <h3 id="overview-section">
   *   Template Slot Binding
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview-section"></a>
   * </h3>
   * <p>
   * The oj-bind-template-slot element is used inside a composite View as a placeholder for stamped child DOM and
   * is a declarative way to define a <a href="CustomElementOverview.html#ce-slots-template-section">template slot</a>.
   * Similar to oj-bind-slot-elements, the oj-bind-template-slot has fallback content
   * which should be provided in a template node and will be used when the template has no assigned nodes.
   * The 'name' attribute on an oj-bind-template-slot follows the same rules as an oj-bind-slot where a template slot
   * with a name attribute whose value is not the empty string is referred to as a named slot and a template slot
   * without a name attribute or one whose name value is the empty string is referred to as the default slot
   * where any composite children without a slot attribute will be moved to.
   * </p>
   *
   * <h3 id="slotprops-section">
   *   Template Slot Properties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#slotprops-section"></a>
   * </h3>
   * <ul>
   *  <li>A default template slot is a slot element whose slot name is the empty string or missing.</li>
   *  <li>More than one template node can be assigned to the same template slot, but only the last will be used for stamping.</li>
   *  <li>A template slot can also have a slot attribute and be assigned to another template slot or slot.</li>
   *  <li>A template slot can have a default template as its direct child node which will be used to stamp DOM content
   *      if it has no assigned nodes. The binding context for the default template is the composite's binding context with the
   *      additional data properties.</li>
   * </ul>
   *
   * <h3 id="nodeprops-section">
   *   Assignable Node Properties
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#nodeprops-section"></a>
   * </h3>
   * <ul>
   *  <li>Template nodes are the only allowed children of template slots.</li>
   *  <li>Nodes with slot attributes will be assigned to the corresponding named slots (if
   *    present) and all other assignable nodes (Text or Element) will be assigned to
   *    the default slot (if present).</li>
   *  <li>The slot attribute of a node is only applied once. If the View contains a
   *    composite and the node's assigned slot is a child of that composite, the slot
   *    attribute of the assigned slot is inherited for the slotting of that composite.</li>
   *  <li>Nodes with slot attributes that reference slots not present in the View will not appear in the DOM.</li>
   *  <li>If the View does not contain a default slot, nodes assigned to the default slot will not appear in the DOM.</li>
   *  <li>Nodes that are not assigned to a slot will not appear in the DOM.</li>
   * </ul>
   *
   *
   * <h3 id="bindingcontext-section">
   *   Binding Context
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#bindingcontext-section"></a>
   * </h3>
   * <p>
   *  Unlike oj-bind-slot nodes whose children's bindings are resolved in the application's binding
   *  context before being slotted, oj-bind-template-slot children are resolved when the composite View
   *  bindings are applied and are resolved in the application's binding context extended with additional
   *  properties provided by the composite. These additional properties are available on the $current
   *  variable in the application provided template node and should be documented in the composite's
   *  <a href="MetadataTypes.html#ComponentMetadataSlots">slot metadata</a>.
   * </p>
   *
   * <h3 id="example1-section">
   *   Example #1: Basic Usage
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#example1-section"></a>
   * </h3>
   * Note that the IDs are provided for sample purposes only.
   * <h4>Initial DOM</h4>
   * <pre class="prettyprint">
   * <code>
   * &lt;demo-list data="{{groceryList}}" header="Groceries">
   *  &lt;template slot="item" data-oj-as="groceryItem">
   *    &lt;oj-checkboxset>
   *      &lt;oj-option value="bought">&lt;oj-bind-text value='[[groceryItem.value]]'>&lt;/oj-bind-text>&lt;oj-option>
   *    &lt;/oj-checkboxset>
   *  &lt;/template>
   * &lt;/demo-list>
   * </code>
   * </pre>
   *
   * <h4>View</h4>
   * Note that if you want to build an HTML table using &lt;oj-bind-for-each&gt; element the html content must be parsed
   * by <a href="HtmlUtils.html#.stringToNodeArray">HtmlUtils.stringToNodeArray()</a> method. Keep in mind that the composite
   * views and the oj-module views that are loaded via ModuleElementUtils are already using that method. Thus to create
   * a table you can either place the content into a view or call HtmlUtils.stringToNodeArray() explicitly to process the content.
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;table>
   *   &lt;thead>
   *     &lt;tr>
   *       &lt;th>
   *         &lt;oj-bind-text value="[[$properties.header]]">&lt;/oj-bind-text>
   *       &lt;/th>
   *     &lt;/tr>
   *   &lt;/thead>
   *   &lt;tbody>
   *     &lt;oj-bind-for-each data="{{$properties.data}}">
   *       &lt;template>
   *         &lt;tr>
   *           &lt;td>
   *             &lt;!-- Template slot for list items with default template and alias -->
   *             &lt;oj-bind-template-slot name="item" data={{$current.data}}>
   *               &lt;!-- Default template -->
   *               &lt;template data-oj-as="listItem">
   *                 &lt;span>&lt;oj-bind-text value='[[listItem.value]]'>&lt;/oj-bind-text>&lt;/span>
   *               &lt;/template>
   *             &lt;/oj-bind-template-slot>
   *           &lt;/td>
   *         &lt;/tr>
   *       &lt;/template>
   *     &lt;/oj-bind-for-each>
   *   &lt;/tbody>
   * &lt;/table>
   * </code>
   * </pre>
   */

  /**
   * An optional alias for $current that can be referenced inside the default template DOM. Note
   * that application $current aliasing should be done with the
   * <a href="CustomElementOverview.html#ce-slots-template-section">data-oj-as</a> attribute on the
   * template element.
   * @expose
   * @name as
   * @memberof oj.ojBindTemplateSlot
   * @ojshortdesc An optional component-level alias for the context variable that can be referenced inside the default template DOM.
   * @instance
   * @type {string}
   * @ojtsignore
   * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
   * @example <caption>Define a slot within a composite View with the name "foo":</caption>
   * &lt;oj-bind-template-slot name="foo" data="[[extraProperties]]" as="listItem">
   *   &lt;!-- optional default template content -->
   *   &lt;template>
   *     ...
   *     <oj-bind-text value="[[listItem.value]]"></oj-bind-text>
   *     ...
   *   &lt;/template>
   * &lt;/oj-bind-template-slot>
   */

  /**
   * The object containing additional context variables to extend the stamped template nodes'
   * binding context. These variables will be exposed as variables on $current and aliases.
   * @expose
   * @name data
   * @memberof oj.ojBindTemplateSlot
   * @ojshortdesc The object containing additional context variables to extend the stamped template nodes's binding context.
   * @instance
   * @type {Object}
   * @example <caption>Define a slot within a composite View with the name "foo":</caption>
   * &lt;oj-bind-template-slot name="foo" data="[[$properties.data]]">
   *   &lt;!-- optional default template content -->
   *   &lt;template>
   *     ...
   *     <oj-bind-text value="[[$current.value]]"></oj-bind-text>
   *     ...
   *   &lt;/template>
   * &lt;/oj-bind-template-slot>
   * @ojsignature {target: "Type", value: "D"}
   */

  /**
   * The name of the slot.
   * @expose
   * @name name
   * @memberof oj.ojBindTemplateSlot
   * @instance
   * @type {string}
   * @example <caption>Define a slot within a composite View with the name "foo":</caption>
   * &lt;oj-bind-template-slot name="foo">
   *   &lt;!-- optional default template content -->
   *   &lt;template>
   *     ...
   *   &lt;/template>
   * &lt;/oj-bind-template-slot>
   */

  /**
   * <p>The <code class="prettyprint">oj-bind-template-slot</code> default slot
   * is used to specify a fallback template that will be used to stamp child
   * DOM if the slot has no assigned template nodes.  While assigned template
   * nodes are executed in an extension of the composite element's binding
   * context, the fallback template is executed in an extension of its own
   * binding context (commonly the binding context of the composite view).  As
   * with assigned templated nodes, the extension makes the value of the
   * data attribute available through $current and alias keys.  The fallback
   * content also inherits the slot attribute of the oj-bind-template-slot itself.
   *
   * @ojchild Default
   * @ojmaxitems 1
   * @memberof oj.ojBindTemplateSlot
   * @ojshortdesc The oj-bind-template-slot default slot is used to specify a fallback template that will be used to stamp child DOM if the slot has no assigned template nodes.
   * @instance
   * @expose
   */

  const register = Composite.register;
  const getMetadata = Composite.getMetadata;
  const getComponentMetadata = Composite.getComponentMetadata;
  const getContainingComposite = Composite.getContainingComposite;
  const __COMPOSITE_PROP = Composite.__COMPOSITE_PROP;

  exports.__COMPOSITE_PROP = __COMPOSITE_PROP;
  exports.getComponentMetadata = getComponentMetadata;
  exports.getContainingComposite = getContainingComposite;
  exports.getMetadata = getMetadata;
  exports.register = register;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbindingprovider',['exports', 'ojs/ojkoshared'], function (exports, BindingProviderImpl) { 'use strict';

  BindingProviderImpl = BindingProviderImpl && Object.prototype.hasOwnProperty.call(BindingProviderImpl, 'default') ? BindingProviderImpl['default'] : BindingProviderImpl;

  /**
   * Utility class with functions for interacting with the JET binding provider.
   * @namespace
   * @hideconstructor
   * @ojtsmodule
   *
   * @since 6.1.0
   */
  const BindingProvider = function () {};

  /**
   * Utility method to register a preprocessor for a specific tag name. The preprocessor
   * will be called with the DOM node matching the specified tag name and can modify, remove,
   * or replace node. Any new nodes must be inserted immediately before the DOM node, and if any
   * nodes were added or node was removed, the function must return an array of the new nodes
   * that are now in the document in place of node.
   * @param {string} tagName
   * @param {function(Node):Array<Node>} preprocessor
   * @return {void}
   * @ignore
   * @static
   */
  BindingProvider.registerPreprocessor = function (tagName, preprocessor) {
    BindingProviderImpl.registerPreprocessor(tagName, preprocessor);
  };

  /**
   * Creates an expression evaluator.
   * @param {string} expressionText The inner expression text not including any decorator characters
   *                                that identifies the string as an expression.
   * @param {Object} binding context where the expression will be evaluated
   * @return {function(object):any} An evaluator function that will take binding (data) context as a parameter
   * @static
   */
  BindingProvider.createBindingExpressionEvaluator = function (expressionText, bindingContext) {
    return BindingProviderImpl.createBindingExpressionEvaluator(expressionText, bindingContext);
  };

  const registerPreprocessor = BindingProvider.registerPreprocessor;
  const createBindingExpressionEvaluator = BindingProvider.createBindingExpressionEvaluator;

  exports.createBindingExpressionEvaluator = createBindingExpressionEvaluator;
  exports.registerPreprocessor = registerPreprocessor;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojknockouttemplateutils',['exports', 'jqueryui-amd/widget', 'jquery', 'knockout'], function (exports, widget, $, ko) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * This is added so that we could cleanup any ko references on the element when it is removed.
   * @export
   */
  $.widget('oj._ojDetectCleanData', {
    options: {
      /**
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       */
      cleanParent: false
    },
    _destroy: function () {
      var disposal = ko.utils.domNodeDisposal;
      var cleanExternalData = 'cleanExternalData';

      // need to temporarily short circuit the domNodeDisposal call otherwise
      // the _destroy override would be invoked again
      var oldCleanExternal = disposal[cleanExternalData];
      disposal[cleanExternalData] = function () {};

      try {
        // provide the option to clean from the parent node for components like ojdatagrid so that the comment
        // and text nodes aren't memory leaked with ko when remove/_destroy is not called on all node types
        if (this.options.cleanParent && this.element[0].parentNode != null) {
          ko.cleanNode(this.element[0].parentNode);
        } else {
          ko.cleanNode(this.element[0]);
        }
      } finally {
        disposal[cleanExternalData] = oldCleanExternal;
      }
    }
  });

  /**
   * Utility methods for knockout templates.
   *
   *
   * @since 4.0.0
   * @namespace
   * @ojtsmodule
   * @export
   * @name oj.KnockoutTemplateUtils
   */
  const KnockoutTemplateUtils = {};

  /**
   * JET custom elements do not support template binding attributes, so applications using knockout templates
   * should use this utility to convert their knockout templates to a renderer function for use in component
   * renderer APIs instead.
   *
   * @param {string} template The name of the knockout template to use.
   * @param {boolean=} bReplaceNode True if the entire target node should be replaced by the output of the template.
   *                                If false or omitted, the children of the target node will be replaced.
   * @return {function(Object)} A renderer function that takes a context object.
   * @export
   * @method getRenderer
   * @memberof oj.KnockoutTemplateUtils
   * @example <caption>Convert a knockout template to a custom tooltip renderer function:</caption>
   * &lt;oj-tag-cloud tooltip.renderer="[[oj.KnockoutTemplateUtils.getRenderer('tooltip_template')]]">&lt;/oj-tag-cloud>
   */
  KnockoutTemplateUtils.getRenderer = function (template, bReplaceNode) {
    var templateRenderer = function (context) {
      // For DVTs, the node to attach the template to is different than the context's parentElement key
      var parentElement = context._parentElement || context.parentElement;

      var bindingContext = ko.contextFor(context.componentElement);

      // Make sure we have a bindingContext before rendering.  It's possible that this is called
      // after a component has been disconnected and there is no bindingContext.
      if (bindingContext) {
        var childContext = bindingContext.createChildContext(context.data, null, function (binding) {
          // eslint-disable-next-line no-param-reassign
          binding.$context = context;
        });
        ko.renderTemplate(
          template,
          childContext,
          {
            afterRender: function (renderedElement) {
              $(renderedElement)._ojDetectCleanData();
            }
          },
          parentElement,
          bReplaceNode ? 'replaceNode' : 'replaceChildren'
        );
      }

      return null;
    };

    return function (context) {
      if (
        context.componentElement.classList &&
        context.componentElement.classList.contains('oj-dvtbase')
      ) {
        // Create a dummy div
        var dummyDiv = document.createElement('div');
        dummyDiv.style.display = 'none';
        dummyDiv._dvtcontext = context._dvtcontext;
        context.componentElement.appendChild(dummyDiv);
        Object.defineProperty(context, '_parentElement', { value: dummyDiv, enumerable: false });
        Object.defineProperty(context, '_templateCleanup', {
          value: function () {
            $(dummyDiv).remove();
          },
          enumerable: false
        });
        Object.defineProperty(context, '_templateName', {
          value: template,
          enumerable: false
        });

        templateRenderer(context);

        var elem = dummyDiv.children[0];
        if (elem) {
          dummyDiv.removeChild(elem);
          $(dummyDiv).remove();
          return { insert: elem };
        }
        return { preventDefault: true };
      }

      return templateRenderer(context);
    };
  };

  const getRenderer = KnockoutTemplateUtils.getRenderer;

  exports.getRenderer = getRenderer;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojresponsiveknockoututils',['exports', 'ojs/ojcore-base', 'ojs/ojcustomelement-registry', 'knockout', 'jquery', 'ojs/ojresponsiveutils', 'ojs/ojcustomelement-utils'], function (exports, oj, ojcustomelementRegistry, ko, $, ResponsiveUtils, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  const _createMediaQueryObservableInternal = function (queryString, componentElement) {
    if (queryString == null) {
      throw new Error(
        'ResponsiveKnockoutUtils.createMediaQueryObservable: aborting, queryString is null'
      );
    }

    var query = window.matchMedia(queryString);

    var observable = ko.observable(query.matches);

    const listener = function listener(_query) {
      observable(_query.matches);
    };

    let resumeCallback;
    let suspendCallback;
    if (componentElement) {
      resumeCallback = () => {
        query.addListener(listener);
      };
      suspendCallback = () => {
        query.removeListener(listener);
      };

      const state = ojcustomelementUtils.CustomElementUtils.getElementState(componentElement);
      state.addLifecycleCallbacks(resumeCallback, suspendCallback);
    }

    // add a listener for future changes
    query.addListener(listener);

    observable.dispose = function () {
      query.removeListener(listener);
      if (suspendCallback && resumeCallback) {
        const state = ojcustomelementUtils.CustomElementUtils.getElementState(componentElement);
        state.removeLifecycleCallbacks(resumeCallback, suspendCallback);
      }
    };

    // There is a major bug in webkit, tested on ios 7 going from
    // landscape to portrait.
    //    https://bugs.webkit.org/show_bug.cgi?id=123293
    //
    // Basically if you use a media query in css
    // then the js matchmedia call won't work!
    //
    // According to the bug this is known to be on webkit 538.4,
    // but I see it on 537.51 as well which is earlier, so
    // assume the problem exists generally on safari.
    // Chrome now uses blink instead of webkit, but chrome
    // still has webkit in their user agent string, however they
    // now only change the number after "Chrome".

    if (
      navigator.userAgent.indexOf('WebKit') !== -1 &&
      navigator.userAgent.indexOf('Chrome') === -1
    ) {
      $(window).resize(function () {
        // Somehow if I change some text in the dom on resize
        // the query listener is called
        var selector = 'oj-webkit-bug-123293';

        if ($('body').has('.' + selector).length === 0) {
          // setting display: none doesn't work, so using
          // oj-helper-hidden-accessible because this visually
          // hides the content without using display:none.
          // However we don't want screen readers to read
          // this so setting aria-hidden to true.
          // prettier-ignore
          $('body').append( // @HTMLUpdateOK
            '<div aria-hidden="true" class="oj-helper-hidden-accessible ' + selector + '">'
          );
        }

        $('.' + selector).text(new Date().getMilliseconds().toString());
      });
    }

    return observable;
  };

  const _createScreenRangeObservableInternal = function (componentElement) {
    // queryies
    var xxlQuery = ResponsiveUtils.getFrameworkQuery(ResponsiveUtils.FRAMEWORK_QUERY_KEY.XXL_UP);

    var xlQuery = ResponsiveUtils.getFrameworkQuery(ResponsiveUtils.FRAMEWORK_QUERY_KEY.XL_UP);

    var lgQuery = ResponsiveUtils.getFrameworkQuery(ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP);

    var mdQuery = ResponsiveUtils.getFrameworkQuery(ResponsiveUtils.FRAMEWORK_QUERY_KEY.MD_UP);

    var smQuery = ResponsiveUtils.getFrameworkQuery(ResponsiveUtils.FRAMEWORK_QUERY_KEY.SM_UP);

    // observables
    var xxlObservable =
      xxlQuery == null ? null : _createMediaQueryObservableInternal(xxlQuery, componentElement);

    var xlObservable =
      xlQuery == null ? null : _createMediaQueryObservableInternal(xlQuery, componentElement);

    var lgObservable =
      lgQuery == null ? null : _createMediaQueryObservableInternal(lgQuery, componentElement);

    var mdObservable =
      mdQuery == null ? null : _createMediaQueryObservableInternal(mdQuery, componentElement);

    var smObservable =
      smQuery == null ? null : _createMediaQueryObservableInternal(smQuery, componentElement);

    var screenRange = ko.pureComputed(function () {
      if (xxlObservable && xxlObservable()) {
        return ResponsiveUtils.SCREEN_RANGE.XXL;
      }

      if (xlObservable && xlObservable()) {
        return ResponsiveUtils.SCREEN_RANGE.XL;
      }

      if (lgObservable && lgObservable()) {
        return ResponsiveUtils.SCREEN_RANGE.LG;
      }

      if (mdObservable && mdObservable()) {
        return ResponsiveUtils.SCREEN_RANGE.MD;
      }

      if (smObservable && smObservable()) {
        return ResponsiveUtils.SCREEN_RANGE.SM;
      }

      throw new Error(' NO MATCH in ResponsiveKnockoutUtils.createScreenRangeObservable');
    });

    screenRange.subscribe(
      () => {
        if (smObservable) smObservable.dispose();
        if (mdObservable) mdObservable.dispose();
        if (lgObservable) lgObservable.dispose();
        if (xlObservable) xlObservable.dispose();
        if (xxlObservable) xxlObservable.dispose();
      },
      null,
      'asleep'
    );

    return screenRange;
  };

  /**
   * @namespace oj.ResponsiveKnockoutUtils
   * @classdesc Utilities for creating knockout observables to implement responsive pages.
   * For example you could use oj.ResponsiveKnockoutUtils.createMediaQueryObservable to
   * create an observable based on the screen width and then bind the tab bar's
   * orientation attribute to it. See the method doc below for specific examples.
   * @since 1.1.0
   * @export
   * @hideconstructor
   * @ojtsmodule
   * @ojtsimport knockout
   * @ojtsimport {module: "ojresponsiveutils", type:"AMD", importName: "ResponsiveUtils"}
   *
   */

  const ResponsiveKnockoutUtils = {};
  oj._registerLegacyNamespaceProp('ResponsiveKnockoutUtils', ResponsiveKnockoutUtils);
  /**
   * <p>Creates an observable that
   * returns true or false based on a media query string.
   * Can be used in conjunction with {@link ResponsiveUtils.getFrameworkQuery}
   * to create an observable based on a framework media query.</p>
   *
   * <p>In order to avoid leaking memory, any explicit subscribe() calls on this observable
   * should be paired with corresponding dispose() calls when the observable is no longer needed.
   * The observable returned by this method should not be used (directly or indirectly) in an expression
   * within the view of a custom composite element. See {@link oj.ResponsiveKnockoutUtils.createCompositeMediaQueryObservable} instead.</p>
   *
   * <p>Example:</p>
   * <pre class="prettyprint">
   * <code>
   *    var customQuery = oj.ResponsiveKnockoutUtils.createMediaQueryObservable(
   *                                         '(min-width: 400px)');
   *
   *    var lgQuery = oj.ResponsiveUtils.getFrameworkQuery(
   *                             oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP);
   *
   *    self.large = oj.ResponsiveKnockoutUtils.createMediaQueryObservable(lgQuery);
   * </code></pre>
   *
   * @param {string} queryString media query string, for example '(min-width: 400px)'
   * @return a knockout observable  that
   *              returns true or false based on a media query string.
   * @ojsignature {target: "Type", for: "returns", value: "ko.Observable<boolean>"}
   * @export
   * @static
   * @method createMediaQueryObservable
   * @memberof oj.ResponsiveKnockoutUtils
   */
  ResponsiveKnockoutUtils.createMediaQueryObservable = function (queryString) {
    return _createMediaQueryObservableInternal(queryString);
  };

  /**
   * <p>
   * This method creates an observable that returns true or false based on a media query string.
   * It is specifically designed to be used within composite elements.
   * The componentElement argument is used to clean up media query listeners when the composite element
   * is disconnected from DOM.
   * Can be used in conjunction with {@link ResponsiveUtils.getFrameworkQuery}
   * to create an observable based on a framework media query.
   * </p>
   *
   * <p>
   * This method can be safely used within composite elements to create an observable that can be used within view expressions
   * or explicitly subscribed to within the view model. Do not call dispose() on the observable.
   * The internal media query listeners will automatically be cleaned up when the element is disconnected from the DOM,
   * and garbage collection will take care of the rest.
   * </p>
   *
   * <p>Example:</p>
   * <pre class="prettyprint">
   * <code>
   *    var customQuery = oj.ResponsiveKnockoutUtils.createCompositeMediaQueryObservable(
   *                                         '(min-width: 400px)', modelContext.element);
   *
   *    var lgQuery = oj.ResponsiveUtils.getFrameworkQuery(
   *                             oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP);
   *
   *    self.large = oj.ResponsiveKnockoutUtils.createCompositeMediaQueryObservable(lgQuery, modelContext.element);
   * </code></pre>
   * @param {string} queryString media query string, for example '(min-width: 400px)'
   * @param { Element } componentElement composite element that calls the utility in its view or view model
   * @returns a knockout observable  that
   *              returns true or false based on a media query string.
   * @ojsignature {target: "Type", for: "returns", value: "ko.Observable<boolean>"}
   * @export
   * @static
   * @method createCompositeMediaQueryObservable
   * @memberof oj.ResponsiveKnockoutUtils
   */
  ResponsiveKnockoutUtils.createCompositeMediaQueryObservable = function (
    queryString,
    componentElement
  ) {
    const name = componentElement?.nodeName;
    if (!(componentElement && ojcustomelementRegistry.isComposite(name))) {
      throw new Error(
        `Incorrect usage of createCompositeMediaQueryObservable for ${name} - the method should be used on the composite components and componentElement should be given as a method argument.`
      );
    }
    return _createMediaQueryObservableInternal(queryString, componentElement);
  };

  /**
   * <p>
   * This method creates a computed observable, the
   * value of which is one of the {@link ResponsiveUtils.SCREEN_RANGE} constants.
   * For example when the width is in the
   * range defined by the sass variable $mediumScreenRange then
   * the observable returns <code>oj.ResponsiveUtils.SCREEN_RANGE.MD</code>,
   * but if it's in the range defined by $largeScreenRange then
   * it returns <code>oj.ResponsiveUtils.SCREEN_RANGE.LG</code>, etc.
   * </p>
   * <p>
   * In order to avoid leaking memory, any explicit subscribe() calls on this observable should be paired
   * with corresponding dispose() calls when the observable is no longer needed. The observable
   * returned by this method should not be used (directly or indirectly) in
   * an expression within the view of a custom composite element. See {@link oj.ResponsiveKnockoutUtils.createCompositeScreenRangeObservable} instead.
   * </p>
   *
   * <p>Example:</p>
   * <pre class="prettyprint">
   * <code>
   *        // create an observable which returns the current screen range
   *        self.screenRange = oj.ResponsiveKnockoutUtils.createScreenRangeObservable();
   *
   *        self.label2 = ko.computed(function() {
   *          var range = self.screenRange();
   *
   *          if ( oj.ResponsiveUtils.compare(
   *                       range, oj.ResponsiveUtils.SCREEN_RANGE.MD) <= 0)
   *          {
   *            // code for when screen is in small or medium range
   *          }
   *          else if (range == oj.ResponsiveUtils.SCREEN_RANGE.XL)
   *          {
   *            // code for when screen is in XL range
   *          }
   *        });
   * </code></pre>
   *
   * @return A knockout observable the value of which is one of the
   *  screen range constants, for example oj.ResponsiveUtils.SCREEN_RANGE.MD.
   * @ojsignature {target: "Type", for: "returns", value: "ko.Observable<ResponsiveUtils.ScreenRange>"}
   * @export
   * @static
   * @memberof oj.ResponsiveKnockoutUtils
   * @method createScreenRangeObservable
   */
  ResponsiveKnockoutUtils.createScreenRangeObservable = function () {
    return _createScreenRangeObservableInternal();
  };

  /**
   * <p>
   * The method creates a computed observable, the value of which is one of the {@link ResponsiveUtils.SCREEN_RANGE} constants.
   * For example when the width is in the range defined by the sass variable $mediumScreenRange then
   * the observable returns <code>oj.ResponsiveUtils.SCREEN_RANGE.MD</code>,
   * but if it's in the range defined by $largeScreenRange then
   * it returns <code>oj.ResponsiveUtils.SCREEN_RANGE.LG</code>, etc.
   * This method is designed to be used within composite element view expressions.
   * The componentElement argument is used to clean up media query listeners when the composite element
   * is disconnected from DOM.
   * </p>
   *
   * <p>
   * This method can be safely used within composite elements to create an observable that can be used within view expressions
   * or explicitly subscribed to within the view model. Do not call dispose() on the observable.
   * The internal media query listeners will automatically be cleaned up when the element is disconnected from the DOM,
   * and garbage collection will take care of the rest.
   * </p>
   *
   * <p>Example:</p>
   * <pre class="prettyprint">
   * <code>
   *        // create an observable which returns the current screen range
   *        self.screenRange = oj.ResponsiveKnockoutUtils.createCompositeScreenRangeObservable();
   *
   *        self.label2 = ko.computed(function() {
   *          var range = self.screenRange();
   *
   *          if ( oj.ResponsiveUtils.compare(
   *                       range, oj.ResponsiveUtils.SCREEN_RANGE.MD) <= 0)
   *          {
   *            // code for when screen is in small or medium range
   *          }
   *          else if (range == oj.ResponsiveUtils.SCREEN_RANGE.XL)
   *          {
   *            // code for when screen is in XL range
   *          }
   *        });
   * </code></pre>
   * @param { Element } componentElement composite element that calls the utility in its view or view model
   * @returns A knockout observable the value of which is one of the
   *  screen range constants, for example oj.ResponsiveUtils.SCREEN_RANGE.MD.
   * @ojsignature {target: "Type", for: "returns", value: "ko.Observable<ResponsiveUtils.ScreenRange>"}
   * @export
   * @static
   * @memberof oj.ResponsiveKnockoutUtils
   * @method createCompositeScreenRangeObservable
   */
  ResponsiveKnockoutUtils.createCompositeScreenRangeObservable = function (componentElement) {
    const name = componentElement?.nodeName;
    if (!(componentElement && ojcustomelementRegistry.isComposite(name))) {
      throw new Error(
        `Incorrect usage of createCompositeScreenRangeObservable for ${name} - the method should be used on the composite components and componentElement should be given as a method argument.`
      );
    }
    return _createScreenRangeObservableInternal(componentElement);
  };

  const { createScreenRangeObservable, createMediaQueryObservable, createCompositeScreenRangeObservable, createCompositeMediaQueryObservable } = ResponsiveKnockoutUtils;

  exports.createCompositeMediaQueryObservable = createCompositeMediaQueryObservable;
  exports.createCompositeScreenRangeObservable = createCompositeScreenRangeObservable;
  exports.createMediaQueryObservable = createMediaQueryObservable;
  exports.createScreenRangeObservable = createScreenRangeObservable;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojkeysetimpl',['ojs/ojcore-base'], function (oj) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * Contains all the core functionalities of KeySet.
   * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
   *
   * @ignore
   * @ojtsignore
   * @export
   * @class KeySetImpl
   * @constructor
   * @since 5.1.0
   */
  // eslint-disable-next-line no-unused-vars
  var KeySetImpl = function (initialValues) {
    this.NOT_A_KEY = {};

    /**
     * Returns whether the specified key is contained in this set.
     * @private
     * @param {any} key the key to check whether it is contained in this set.
     * @return {boolean} true if the specified key is contained in this set, false otherwise.
     */
    this.has = function (key) {
      return this.get(key) !== this.NOT_A_KEY;
    };

    /**
     * Finds the equavalent key of the specified key within this KeySet.
     * @private
     * @param {any} keyToFind the key to find
     * @return {any} the key in the key that is equivalent to keyToFind, or NO_KEY if nothing equivalent can be found.
     */
    this.get = function (keyToFind) {
      var iterator;
      var key;
      var found = this.NOT_A_KEY;
      var self = this;

      if (this._keys.has(keyToFind)) {
        return keyToFind;
      }

      // if it's a primitive, then we are done also
      if (!(keyToFind === Object(keyToFind))) {
        return this.NOT_A_KEY;
      }

      // using iterator if it's supported since we could break at any time
      if (typeof Symbol === 'function' && typeof Set.prototype[Symbol.iterator] === 'function') {
        iterator = this._keys[Symbol.iterator]();
        key = iterator.next();
        while (!key.done) {
          if (oj.KeyUtils.equals(key.value, keyToFind)) {
            return key.value;
          }
          key = iterator.next();
        }
      } else {
        // IE11 supports forEach
        this._keys.forEach(function (_key) {
          if (found === self.NOT_A_KEY && oj.KeyUtils.equals(_key, keyToFind)) {
            found = _key;
          }
        });
      }

      return found;
    };

    /**
     * Initialize the internal Set with a set of keys.
     * @private
     * @param {Set|Array|null|undefined} keys the initial keys to create the internal Set with.
     */
    this.InitializeWithKeys = function (keys) {
      this._keys = new Set(keys);
    };

    this.InitializeWithKeys(initialValues);
  };

  return KeySetImpl;

});


define('ojs/ojmonitoring',['exports'], function (exports) { 'use strict';

    const _MONITORS = {};
    const _WRITEBACK_MONITOR = Symbol();
    function getWritebackMonitor() {
        return _MONITORS[_WRITEBACK_MONITOR];
    }
    function setWritebackMonitor(monitor) {
        _MONITORS[_WRITEBACK_MONITOR] = monitor;
    }
    /**
     * This method should be used exclusively by JET while performing writeback
     */
    function performMonitoredWriteback(propName, writer, event, newValue) {
        if (writer) {
            const monitor = getWritebackMonitor();
            if (monitor) {
                monitor(propName, event, writer.bind(null, newValue));
            }
            else {
                writer(newValue);
            }
        }
    }

    exports.getWritebackMonitor = getWritebackMonitor;
    exports.performMonitoredWriteback = performMonitoredWriteback;
    exports.setWritebackMonitor = setWritebackMonitor;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbindpropagation',['exports', 'ojs/ojcustomelement-registry'], function (exports, ojcustomelementRegistry) { 'use strict';

    const STATIC_PROPAGATION = Symbol('StaticContextPropagation');
    const CONSUMED_CONTEXT = Symbol('ConsumedContext');
    function getPropagationMetadataViaCache(elemName, compMetadata) {
        let entry = _bindingPropagationMetadataCache.get(elemName);
        if (entry !== undefined) {
            return entry;
        }
        entry = null;
        const metadataProps = compMetadata.properties ?? {};
        const propKeys = Object.keys(metadataProps);
        propKeys.forEach((pName) => {
            const meta = metadataProps[pName];
            const provideMeta = meta?.binding?.provide;
            const consumeMeta = meta?.binding?.consume;
            if (provideMeta || consumeMeta) {
                if (meta.properties) {
                    throw new Error('Propagating complex properties is not supported!');
                }
                entry = entry ?? new Map();
                entry.set(pName, [provideMeta, consumeMeta]);
            }
        });
        // For internal use only, we also support unconditional providing of values through binding propagation
        // via root metadata extension._BINDING.provide
        const staticProvideMeta = compMetadata.extension?.['_BINDING']?.provide;
        if (staticProvideMeta) {
            entry = entry ?? new Map();
            // Normalize key/value pairs from the given map into the common format - {name, default}
            const provideMap = new Map();
            staticProvideMeta.forEach((value, key) => {
                provideMap.set(key, { name: key, default: value });
            });
            entry.set(STATIC_PROPAGATION, [provideMap, undefined]);
        }
        // Add an entry for consumed context for convenient access, if exists
        const consumedContexts = ojcustomelementRegistry.getElementRegistration(elemName)?.cache?.contexts;
        if (consumedContexts) {
            entry.set(CONSUMED_CONTEXT, [undefined, consumedContexts]);
        }
        _bindingPropagationMetadataCache.set(elemName, entry);
        return entry;
    }
    const _bindingPropagationMetadataCache = new Map();

    exports.CONSUMED_CONTEXT = CONSUMED_CONTEXT;
    exports.STATIC_PROPAGATION = STATIC_PROPAGATION;
    exports.getPropagationMetadataViaCache = getPropagationMetadataViaCache;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojknockout-base',['exports', 'knockout', 'ojs/ojkoshared', 'ojs/ojcore', 'ojs/ojcustomelement-registry', 'ojs/ojdomutils', 'ojs/ojlogger', 'ojs/ojcustomelement-utils', 'ojs/ojmonitoring', 'ojs/ojbindpropagation', 'ojs/ojkeysetimpl', 'ojs/ojcontext', 'ojs/ojtemplateengine-ko', 'ojs/ojcore-base', 'ojs/ojknockouttemplateutils', 'ojs/ojresponsiveknockoututils'], function (exports, ko, BindingProviderImpl, oj$1, ojcustomelementRegistry, DomUtils, Logger, ojcustomelementUtils, ojmonitoring, ojbindpropagation, KeySetImpl, Context, templateEngine, oj$2, KnockoutTemplateUtils, ResponsiveKnockoutUtils) { 'use strict';

  BindingProviderImpl = BindingProviderImpl && Object.prototype.hasOwnProperty.call(BindingProviderImpl, 'default') ? BindingProviderImpl['default'] : BindingProviderImpl;
  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;
  KeySetImpl = KeySetImpl && Object.prototype.hasOwnProperty.call(KeySetImpl, 'default') ? KeySetImpl['default'] : KeySetImpl;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  templateEngine = templateEngine && Object.prototype.hasOwnProperty.call(templateEngine, 'default') ? templateEngine['default'] : templateEngine;
  oj$2 = oj$2 && Object.prototype.hasOwnProperty.call(oj$2, 'default') ? oj$2['default'] : oj$2;

  /**
   * @ojoverviewdoc BindingOverview - [4]JET Binding Elements
   * @classdesc
   * {@ojinclude "name":"bindingOverviewDoc"}
   */

  /**
   * <h2 id="overview">Overview
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h2>
   *
   * <p>
   *  JET provides a set of binding elements that exist in the DOM only before bindings are applied.
   *  After the bindings are applied, the elements are removed from the document's DOM. However, the
   *  bindings they have defined will continue to function, i.e they will still be reacting to any
   *  changes in binding parameters, etc. These elements are intended to allow declaratively handling
   *  logic that would otherwise need to be done programatically, e.g. conditionals, loops, text binding,
   *  etc. Binding elements are removed from the DOM after bindings are applied in order to not interfere
   *  with page layout.
   * </p>
   * <p>
   *  Note that since binding elements will be removed from the DOM after bindings are applied, for
   *  slotting, applications need to wrap binding elements inside another HTML element (e.g. &lt;span&gt;)
   *  with the slot attribute. JET binding elements do not support the slot attribute.
   * </p>
   *
   * <h2 id="knockout">Knockout Equivalents
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#knockout"></a>
   * </h2>
   * <table class="params">
   *   <thead>
   *     <tr>
   *       <th>Knockout Binding</th>
   *       <th>JET Equivalent</th>
   *       <th>Notes</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="rt">attr</td>
   *       <td>:[attribute]="[[attrValue]]", e.g. :id="[[inputId]]"</td>
   *       <td>See the custom element
   *           <a href="CustomElementOverview.html#ce-databind-global-section">global attribute</a>
   *           data binding doc for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">css</td>
   *       <td>:class="[[classList]]"</td>
   *       <td>Supports the normal space delimited string of classes,
   *           an array of classes, or a map of class to boolean values
   *           for toggling classes in the DOM. See the custom element
   *           <a href="CustomElementOverview.html#ce-databind-class-section">class</a>
   *           data binding doc for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">event</td>
   *       <td>on-[event]</td>
   *       <td>No ":" prefix needed even on native HTML elements. The parameters
   *           passed to the on- listeners include two additional params.
   *           this.clickListener=function(event, data, bindingContext) {..}
   *           If the component has its own event equivalent, use those instead.
   *           Eg: oj-button should use on-oj-action not on-click. See the custom element
   *           <a href="CustomElementOverview.html#ce-events-section">event</a>
   *           data binding doc for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">foreach</td>
   *       <td>oj-bind-for-each</td>
   *       <td>See the <a href="oj.ojBindForEach.html">oj-bind-for-each</a> binding element doc
   *           for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">html</td>
   *       <td>oj-bind-dom</td>
   *       <td>See the <a href="oj.ojBindDom.html">oj-bind-dom</a> binding element doc
   *           for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">if</td>
   *       <td>oj-bind-if</td>
   *       <td>See the <a href="oj.ojBindIf.html">oj-bind-if</a> binding element doc
   *           for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">template</td>
   *       <td>oj-bind-template-slot if being used inside a composite or oj-module for other cases</td>
   *       <td>See the <a href="oj.ojBindTemplateSlot.html">oj-bind-template-slot</a> binding element and
   *           <a href="oj.ojModule.html">oj-module</a> element doc
   *           for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">text</td>
   *       <td>oj-bind-text</td>
   *       <td>See the <a href="oj.ojBindText.html">oj-bind-text</a> binding element doc
   *           for details.</td>
   *     </tr>
   *     <tr>
   *       <td class="rt">visible</td>
   *       <td>:style.display="[[ CONDITION ? '' : 'none' ]]"</td>
   *       <td> See the custom element
   *           <a href="CustomElementOverview.html#ce-databind-style-section">style</a>
   *           data binding doc for details.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   *
   * @ojfragment bindingOverviewDoc
   * @memberof BindingOverview
   */

  /**
   * @ignore
   */
  (function () {
    ko.bindingHandlers._ojBindIf_V2_ = {
      // Valid valueAccessors:
      //    boolean || {test: boolean, nodes: Node[], ojDoNotUseProcessed: true}
      //
      // When the value is a boolean value, then it is a regular oj-if or oj-bind-if usage with nodes provided as part of a DOM.
      // The case should be processed the same way is it is done by knockout in makeWithIfBinding() method -
      // the nodes copy is saved in savedNodes and used when test toogles its value.
      //
      // When the value is an object value, then we can expect an array of nodes provided via 'nodes' property.
      // When nodes are external there is no need to save them locally on savedNodes.
      init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        let didDisplayOnLastUpdate;
        let savedNodes;

        ko.computed(
          function () {
            const value = ko.utils.unwrapObservable(valueAccessor());
            const preprocessedValue = value?.ojDoNotUseProcessed;
            // When ojDoNotUseProcessed flag is present, it means that the value was preprocessed by JET,
            // 'test' and 'nodes' properties are expected to be available and the 'nodes' prop contains external nodes.
            const gotExternalNodes = preprocessedValue ? value.nodes : false;
            const shouldDisplay = preprocessedValue
              ? !!ko.utils.unwrapObservable(value.test)
              : !!value;
            const isInitial = !savedNodes && !gotExternalNodes;

            if (shouldDisplay === didDisplayOnLastUpdate) {
              return;
            }

            let nodes;
            if (gotExternalNodes) {
              nodes = value.nodes;
            } else {
              if (isInitial && ko.computedContext.getDependenciesCount()) {
                savedNodes = ko.utils.cloneNodes(
                  ko.virtualElements.childNodes(element),
                  true /* shouldCleanNodes */
                );
              }
              nodes = savedNodes;
            }

            if (shouldDisplay) {
              if (!isInitial) {
                ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(nodes));
              }

              ko.applyBindingsToDescendants(bindingContext, element);
            } else {
              ko.virtualElements.emptyNode(element);
            }

            didDisplayOnLastUpdate = shouldDisplay;
          },
          null,
          { disposeWhenNodeIsRemoved: element }
        );

        return { controlsDescendantBindings: true };
      }
    };
    ko.virtualElements.allowedBindings._ojBindIf_V2_ = true;
  })();

  BindingProviderImpl.addPostprocessor({
    nodeHasBindings: function (node, wrappedReturn) {
      if (!oj$1.BaseCustomElementBridge) {
        return wrappedReturn;
      }
      return wrappedReturn || (node.nodeType === 1 && ojcustomelementRegistry.isElementRegistered(node.nodeName));
    },

    getBindingAccessors: function (node, bindingContext, wrappedReturn) {
      if (node.nodeType === 1) {
        var name = node.nodeName;

        if (ojcustomelementRegistry.isElementRegistered(name)) {
          // eslint-disable-next-line no-param-reassign
          wrappedReturn = wrappedReturn || {};

          // eslint-disable-next-line no-param-reassign
          wrappedReturn._ojCustomElement = function () {
            const isComposite = ojcustomelementRegistry.isComposite(name);
            const isVComponent = ojcustomelementRegistry.isVComponent(name);
            return { skipThrottling: isComposite || isVComponent };
          };
        }
      }

      return wrappedReturn;
    }
  });

  /**
   * To create a custom binding,
   * use ComponentBinding.create(). Using prototypal inheritance to extend
   * ComponentBinding is not supported.
   * @export
   * @class ComponentBinding
   * @classdesc JQueryUI component binding for Knockout.js.
   * @param {string|Array.<string>} name - the name of the binding or an
   * array of strings in case the binding needs to be registered under several names
   * @param {?(Object|string)=} options - property object
   * @see ComponentBinding.create
   * @constructor
   * @since 1.0
   * @hideconstructor
   * @ojtsignore
   * @ojmodule ojknockout
   */
  const ComponentBinding = function (name, options) {
    if (this.Init) {
      this.Init(name, options);
    }
  };

  oj$1.Object.createSubclass(ComponentBinding, oj$1.Object, 'oj.ComponentBinding');
  oj$1._registerLegacyNamespaceProp('ComponentBinding', ComponentBinding);

  /**
   * Delivers all accumulated component changes across all instances of this binding.
   * Calling this method is optional - the changes will be delivered after a 1ms timeout
   * if this method is never invoked. However, you may call this method to speed up
   * component updates when the aplication code is done updating the view models.
   * @return {void}
   * @export
   */
  ComponentBinding.deliverChanges = function () {
    BindingProviderImpl.getGlobalChangeQueue().deliverChanges();
  };

  /**
   * @ignore
   */
  ComponentBinding.__cloneIfArray = function (value) {
    if (Array.isArray(value)) {
      // eslint-disable-next-line no-param-reassign
      value = value.slice();
    }
    return value;
  };

  /**
   * @private
   */
  ComponentBinding.__getKnockoutVersion = function () {
    return ko.version;
  };

  /**
   * Redefine ko.utils.domNodeDisposal.cleanExternalData, so that JET components can avoid removing the wrapper node during
   * KO cleanup
   * @private
   */
  (function () {
    var name = 'cleanExternalData';
    var disposal = ko.utils.domNodeDisposal;
    var wrapped = disposal[name];

    disposal[name] = function (node) {
      // This module does not have an explicit dependency on ojcomponentcore,
      // so check for the Components instance dynamically
      var func = DomUtils ? DomUtils.setInKoCleanExternal : null;
      if (func) {
        func(node);
      }
      try {
        wrapped(node);
      } finally {
        if (func) {
          func(null);
        }
      }
    };
  })();

  /**
   * @private
   * @constructor
   * Keeps track of changes for a single component
   */
  const ComponentChangeTracker = function (component, queue) {
    this.Init(component, queue);
  };

  // Subclass from oj.Object
  oj$1.Object.createSubclass(
    ComponentChangeTracker,
    oj$1.Object,
    'ComponentBinding.ComponentChangeTracker'
  );

  /**
   * @param {Function} updateCallback
   * @param {Object} queue
   */
  ComponentChangeTracker.prototype.Init = function (updateCallback, queue) {
    ComponentChangeTracker.superclass.Init.call(this);
    this._updateCallback = updateCallback;
    this._queue = queue;
    this._changes = {};
    this._suspendCountMap = {};
  };

  ComponentChangeTracker.prototype.addChange = function (property, value) {
    if (this._isSuspended(property) || this._disposed) {
      return;
    }
    this._changes[property] = value;
    this._queue.registerComponentChanges(this);
  };

  ComponentChangeTracker.prototype.dispose = function () {
    this._disposed = true;
  };

  ComponentChangeTracker.prototype.resume = function (option) {
    var count = this._suspendCountMap[option] || 0;
    count -= 1;
    if (count < 0) {
      Logger.error('ComponentChangeTracker suspendCount underflow');
      return;
    }

    if (count === 0) {
      delete this._suspendCountMap[option];
    } else {
      this._suspendCountMap[option] = count;
    }
  };

  ComponentChangeTracker.prototype.suspend = function (option) {
    var count = this._suspendCountMap[option] || 0;
    this._suspendCountMap[option] = count + 1;
  };

  ComponentChangeTracker.prototype.applyChanges = function (changes) {
    if (!this._disposed) {
      this._updateCallback(changes);
    }
  };

  ComponentChangeTracker.prototype.flushChanges = function () {
    var changes = this._changes;
    this._changes = {};
    return changes;
  };

  ComponentChangeTracker.prototype._isSuspended = function (option) {
    var count = this._suspendCountMap[option] || 0;
    return count >= 1;
  };

  const __ExpressionUtils = {};
  oj$1._registerLegacyNamespaceProp('__ExpressionUtils', __ExpressionUtils);
  (function () {
    var _ASSIGNMENT_TARGET_EXP = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;
    var _KO_WRITER_KEY = '_ko_property_writers';

    /**
     * @ignore
     * @private
     */

    __ExpressionUtils.getPropertyWriterExpression = function (expression) {
      var reserveddWords = ['true', 'false', 'null', 'undefined'];

      if (expression == null || reserveddWords.indexOf(expression) >= 0) {
        return null;
      }

      // Remove the white space on both ends to ensure that the _ASSIGNMENT_TARGET_EXP regexp
      // is matched properly
      // eslint-disable-next-line no-param-reassign
      expression = expression.trim();

      // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
      // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
      // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']];).
      var match = expression.match(_ASSIGNMENT_TARGET_EXP);

      if (match === null) {
        return null;
      }

      var target = match[1] ? 'Object(' + match[1] + ')' + match[2] : expression;

      return '{' + _KO_WRITER_KEY + ': function(v){' + target + '=v;}}';
    };

    __ExpressionUtils.getWriter = function (evaluator) {
      return evaluator[_KO_WRITER_KEY];
    };
  })();

  /**
   * @ignore
   * @constructor
   * @private
   */
  const ExpressionPropertyUpdater = function (element, bindingContext, skipThrottling) {
    var _throttler = _setupComponentChangeTracker();

    var _domListeners = {};
    var _expressionListeners = {};
    var _changeListeners = {};
    var _settingProperties = {};
    var _CHANGED_EVENT_SUFFIX = 'Changed';

    // This function should be called when the bindings are applied initially and whenever the expression attribute changes
    /**
     * Sets up property binding. This method is called both when the bindings are applied and in response to an attribute change.
     * @param {string|undefined} attrVal attribute value or undefined if there is none
     * @param {string} propName property name
     * @param {Object} metadata property metadata
     * @param {Function|undefined} providedValueSetter function that should be called with the result of the initial evalution of the expression
     * @param {string|undefined} providedPropName the key of the $provided map that points to an observable holding a provided value.
     * If the attrVal parameter is undefined, the observable will be used to set up property binding
     * @ignore
     */
    this.setupPropertyBinding = function (
      attrVal,
      propName,
      metadata,
      providedValueSetter,
      providedPropName
    ) {
      // If no metadata was passed in, just return bc this is not a component property.
      if (!metadata) {
        return;
      }

      // See if attribute is a component property/subproperty by checking for metadata
      var meta = _getPropertyMetadata(propName, metadata);
      if (!meta) {
        return;
      }

      var oldListener = _expressionListeners[propName];
      if (oldListener) {
        oldListener.dispose();
        _expressionListeners[propName] = null;
      }

      // Clean up property change listeners to handler the case when the type of the expression changes
      var changeListener = _changeListeners[propName];
      if (changeListener) {
        element.removeEventListener(propName + _CHANGED_EVENT_SUFFIX, changeListener);
        _changeListeners[propName] = null;
      }

      if (metadata._domListener) {
        var event = ojcustomelementUtils.AttributeUtils.eventListenerPropertyToEventType(propName);
        // If the attribute is removed, there won't be a new expression so the remove call
        // below can't be relied upon.  So clean up here as well to handle that case
        _setDomListener(bindingContext, event, null);
      }

      let evaluator;
      let expr;
      let downstreamOnly;

      if (attrVal === undefined) {
        // Implicit bindings are used only when the corresponding attribute is not set

        // Get an observable for the provided value if we have metadata for its name
        let observable;
        if (!providedPropName) {
          observable = null;
        } else if (bindingContext.$provided) {
          observable = bindingContext.$provided.get(providedPropName);
        }

        // If the observable is present, we set up the implicit binding
        if (observable) {
          evaluator = () => ko.unwrap(observable); // evaluator is using an implicit binding to a property provided by a container component
        }
      } else {
        const info = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrVal);
        expr = info.expr;
        if (expr) {
          evaluator = BindingProviderImpl.createEvaluator(expr, bindingContext);
          downstreamOnly = info.downstreamOnly;
        }
      }

      if (evaluator) {
        if (!metadata.readOnly) {
          var initialRead = true;
          ko.ignoreDependencies(function () {
            _expressionListeners[propName] = ko.computed(
              // The read() function for the computed will be called when the computed is created and whenever any of
              // the expression's dependency changes
              function () {
                var value = evaluator(bindingContext);
                var unwrappedValue = ko.utils.unwrapObservable(value);

                if (metadata._domListener) {
                  var _event = ojcustomelementUtils.AttributeUtils.eventListenerPropertyToEventType(propName);
                  _setDomListener(bindingContext, _event, unwrappedValue);
                } else {
                  // We cannot share the same storage with KO because we want to be able to compare values,
                  // so make a copy of the array before setting it.
                  if (Array.isArray(unwrappedValue)) {
                    unwrappedValue = unwrappedValue.slice();
                  }

                  if (metadata._eventListener) {
                    // Need to wrap the function so that it gets called with extra params
                    // No need to throw an error for the non-function case here because
                    // the bridge will throw it for us
                    if (unwrappedValue && unwrappedValue instanceof Function) {
                      unwrappedValue = _createSimpleEventListenerWrapper(
                        bindingContext,
                        unwrappedValue
                      );
                    }
                  }

                  if (!initialRead && _throttler) {
                    _throttler.addChange(propName, unwrappedValue);
                  } else {
                    _setElementProperty(propName, unwrappedValue);
                  }

                  if (initialRead && providedValueSetter) {
                    providedValueSetter(unwrappedValue);
                  }
                }
              }
            );
          });
          initialRead = false;
        }

        // Only listen for property changes for writeable properties
        if (expr !== undefined && metadata.writeback && !downstreamOnly) {
          _changeListeners[propName] = _listenToPropertyChanges(propName, expr, evaluator);
        }
      }
    };

    this.teardown = function () {
      var i;
      var names = Object.keys(_expressionListeners);
      for (i = 0; i < names.length; i++) {
        var listener = _expressionListeners[names[i]];
        // listener might be null if this attribute changed from an expression to a literal
        if (listener) {
          listener.dispose();
        }
      }
      _expressionListeners = {};

      // reset change listeners
      names = Object.keys(_changeListeners);
      for (i = 0; i < names.length; i++) {
        var prop = names[i].split('.')[0];
        element.removeEventListener(prop + _CHANGED_EVENT_SUFFIX, _changeListeners[prop]);
      }
      _changeListeners = {};

      // dom event listeners
      names = Object.keys(_domListeners);
      for (i = 0; i < names.length; i++) {
        var event = names[i];
        element.removeEventListener(event, _domListeners[event]);
      }
      _domListeners = {};

      if (_throttler) {
        _throttler.dispose();
      }
    };

    function _getCurrent(_bindingContext) {
      return _bindingContext.$current || _bindingContext.$data;
    }

    function _createSimpleEventListenerWrapper(_bindingContext, listener) {
      var current = _getCurrent(_bindingContext);
      return function (event) {
        listener(event, current, _bindingContext);
      };
    }

    function _createMutableEventListenerWrapper(_bindingContext) {
      var current = _getCurrent(_bindingContext);
      var eventListener;
      var domListener = function (event) {
        if (eventListener) {
          eventListener(event, current, _bindingContext);
        }
      };
      domListener.setListener = function (listener) {
        eventListener = listener;
      };
      return domListener;
    }

    function _setDomListener(_bindingContext, event, listener) {
      var domListener = _domListeners[event];
      if (!domListener) {
        // Create the wrapper
        domListener = _createMutableEventListenerWrapper(_bindingContext);
        _domListeners[event] = domListener;
        element.addEventListener(event, domListener);
      }
      if (listener == null || listener instanceof Function) {
        domListener.setListener(listener);
      } else {
        // this isn't actually a property, just transforming names...
        var property = ojcustomelementUtils.AttributeUtils.eventTypeToEventListenerProperty(event);
        var attribute = ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(property);
        var message = `Invalid type '${typeof listener}' found for attribute '${attribute}'.\
 Expected value of type 'function'."`;
        if (ojcustomelementRegistry.isElementRegistered(element.tagName)) {
          const elementState = ojcustomelementUtils.CustomElementUtils.getElementState(element);
          elementState.rejectBindingProvider(message);
        }
        throw new ojcustomelementUtils.JetElementError(element, message);
      }
    }

    /**
     * Helper function that checks whether subproperty path from event detail
     * matches the listener path.
     * We want to run the update when the path matches (the one path is a subset of another path), e.g.
     *  - listener propName=a.b.c and detail subproperty=a.b.c
     *  - listener propName=a.b.c and detail subproperty=a.b
     *  - listener propName=a.b and detail subproperty=a.b.c.
     * We want to skip the update when the path does not match, e.g.
     *  - listener propName=a.b.c and detail subprop=a.b.d
     * @param {*} eventDetail
     * @param {*} subscribedProp
     * @returns true if subproperty path matches subscribed property or if subproperty value does not exist.
     * @ignore
     */
    function _matchedPropertyPath(eventDetail, subscribedProp) {
      // subproperty is not given, nothing to check
      if (!eventDetail.subproperty) {
        return true;
      }
      const testSubprop = eventDetail.subproperty.path;
      const testPath = testSubprop.split('.');
      const subscribedPath = subscribedProp.split('.');

      const len = Math.min(subscribedPath.length, testPath.length);
      for (let i = 0; i < len; i++) {
        if (subscribedPath[i] !== testPath[i]) {
          return false;
        }
      }
      return true;
    }

    function _listenToPropertyChanges(propName, expr, evaluator) {
      var splitProps = propName.split('.');
      var topProp = splitProps[0];
      var listener = function (evt) {
        if (!_isSettingProperty(topProp) && _matchedPropertyPath(evt.detail, propName)) {
          let failure;
          let writer;
          ko.ignoreDependencies(function () {
            var value = evt.detail.value;
            // If the propName has '.' we need to walk the top level value and writeback
            // subproperty value
            for (var i = 1; i < splitProps.length; i++) {
              var subprop = splitProps[i];
              value = value[subprop];
            }

            var target = evaluator(bindingContext);

            if (ko.isObservable(target)) {
              if (ko.isWriteableObservable(target)) {
                writer = target;
              } else {
                failure = 'the observable is not writeable';
              }
            } else {
              var writerExpr = __ExpressionUtils.getPropertyWriterExpression(expr);
              if (writerExpr != null) {
                const writerEvaluator = BindingProviderImpl.createEvaluator(
                  writerExpr,
                  bindingContext
                );
                writer = __ExpressionUtils.getWriter(writerEvaluator(bindingContext));
              } else {
                failure = 'the expression is not a valid update target';
              }
            }
            if (!writer) {
              if (failure) {
                Logger.info(
                  "The expression '%s' for property '%s' was not updated because %s.",
                  expr,
                  propName,
                  failure
                );
              }
            } else {
              ojmonitoring.performMonitoredWriteback(
                propName,
                writer,
                evt,
                ComponentBinding.__cloneIfArray(value)
              );
            }
          });
        }
      };

      element.addEventListener(topProp + _CHANGED_EVENT_SUFFIX, listener);
      return listener;
    }

    function _setElementProperty(propName, value) {
      _startSettingProperty(propName);
      try {
        element.setProperty(propName, value);
      } catch (err) {
        ojcustomelementUtils.CustomElementUtils.getElementState(element).rejectBindingProvider(err);
        throw err;
      } finally {
        _endSettingProperty(propName);
      }
    }

    function _startSettingProperty(propName) {
      var count = _settingProperties[propName] || 0;
      count += 1;
      _settingProperties[propName] = count;
    }

    function _endSettingProperty(propName) {
      var count = _settingProperties[propName];
      if (!count) {
        Logger.error('Property count undefrlow');
        return;
      }
      count -= 1;
      if (count === 0) {
        _settingProperties[propName] = null;
      } else {
        _settingProperties[propName] = count;
      }
    }

    function _isSettingProperty(propName) {
      return _settingProperties[propName];
    }

    function _getPropertyMetadata(propName, metadata) {
      var propPath = propName.split('.');
      var meta = metadata;
      propPath.shift(); // current metadata is already for top level property
      for (var j = 0; j < propPath.length; j++) {
        meta = meta.properties;
        if (!meta) {
          break;
        }
        meta = meta[propPath[j]];
      }
      return meta;
    }

    function _setupComponentChangeTracker() {
      //  We are not throttling property updates for JET composites and native HTML elements because:
      //  1) Existing customers may expect that properties be updated immediately
      //  2) KO templates do not have any optimizations for simulteneous property updates
      //  3) Updates to embeddded JET components will still be throttled
      if (skipThrottling) {
        return null;
      }

      var updater = function (changes) {
        var keys = Object.keys(changes);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          // We rely on the flag set by the _startSettingProperty() to determine whether
          // the property is being changed in response to a subscription notification
          // from KO. Change events from all sets made NOT in response to a KO update
          // trigger an an attempt to write the value back into the associated expression.
          // If the writeback is not possible for any reason, we consider that the binding
          // has been 'obscured' by a local property set, and further update notifications
          // are are going to be ignored. This means that we are stuck with calling
          // _startSettingProperty() for all properties in the batch update.
          // The downside for this approach is that property changes made in response
          // to a property set from within the same batch will NOT be written back
          // into the KO expression. The likelihood of the writeback bugs because
          // of this is very low IMO: we have few properties with writeback enabled,
          // and the behavior for the component changing a property whose value is being set
          // in the same batch is already undefined. If some app runs into an issue, the
          // workaround will be to call oj.ComponentBinding.deliverChanges() after each observable
          // change.
          _startSettingProperty(key);
        }
        try {
          element.setProperties(changes);
        } finally {
          for (var n = 0; n < keys.length; n++) {
            var k = keys[n];
            _endSettingProperty(k);
          }
        }
      };

      return new ComponentChangeTracker(updater, BindingProviderImpl.getGlobalChangeQueue());
    }
  };

  /**
   * @ignore
   * @constructor
   * @private
   */
  const _KnockoutBindingProvider = function () {
    /**
     * @ignore
     */
    this._resolveWhenChildrenBindingsApplied = function (elem, trackOption) {
      var childrenPromises = this._getChildrenBindingsAppliedPromises(elem);
      if (trackOption === 'none' || childrenPromises.length === 0) {
        ojcustomelementUtils.CustomElementUtils.getElementState(elem).resolveBindingProvider(this);
      } else {
        var promises = [];
        while (childrenPromises.length > 0) {
          var callbackItem = childrenPromises.shift();
          if (
            trackOption === 'nearestCustomElement' ||
            (trackOption === 'immediate' && callbackItem.immediate === true)
          ) {
            promises.push(callbackItem.promiseCallback);
          }
        }
        Promise.all(promises).then(
          function () {
            this._resolveWhenChildrenBindingsApplied(elem, trackOption);
          }.bind(this)
        );
      }
    };

    this._getChildrenBindingsAppliedPromises = function (elem, create) {
      if (!elem._whenChildrenBindingsApplied && create) {
        Object.defineProperty(elem, '_whenChildrenBindingsApplied', {
          value: [],
          enumerable: false
        });
      }
      return elem._whenChildrenBindingsApplied || [];
    };

    /**
     * @ignore
     */
    this.__RegisterBindingAppliedPromiseForChildren = function (parent, immediate) {
      var promiseResolver = null;
      if (parent) {
        var childrenPromise = new Promise(function (resolve) {
          promiseResolver = resolve;
        });
        this._getChildrenBindingsAppliedPromises(parent, true);
        parent._whenChildrenBindingsApplied.push({
          immediate: immediate,
          promiseCallback: childrenPromise
        });
      }
      return promiseResolver;
    };

    /**
     * @ignore
     */
    this.__NotifyBindingsApplied = function (elem) {
      var trackOption = ojcustomelementUtils.CustomElementUtils.getElementState(elem).getTrackChildrenOption();
      this._resolveWhenChildrenBindingsApplied(elem, trackOption);
    };

    /**
     * @ignore
     */
    this.__NotifyBindingsDisposed = function (elem) {
      ojcustomelementUtils.CustomElementUtils.getElementState(elem).disposeBindingProvider(elem);
    };

    /**
     * Provides a promise for JET's Knockout throttling timeout
     * @return {Promise} a promise for JET's Knockout throttling timeout completing or a promise that will be resolved immediately for the case
     * when there is no outstanding throttling timeout
     * @ignore
     */
    this.__GetThrottlePromise = function () {
      return BindingProviderImpl.getGlobalChangeQueue().getThrottlePromise();
    };

    /**
     * A wrapper function used by VTemplateEngine that extends binding context with given extra properties.
     * @ignore
     */
    this.__ExtendBindingContext = function (context, current, alias, templateAlias, cacheKey) {
      return BindingProviderImpl.extendBindingContext(
        context,
        current,
        alias,
        templateAlias,
        cacheKey
      );
    };

    /**
     * A wrapper function used by VTemplateEngine that gets binding context object applied in a node.
     * @ignore
     */
    this.__ContextFor = function (node) {
      // Note: the context for oj_bind_for_each template is stored on __ojBindingContext property.
      return node.__ojBindingContext ? node.__ojBindingContext : ko.contextFor(node);
    };

    /**
     * A wrapper function used by VTemplateEngine that accepts an observable or plain value and returns a plain value.
     * @ignore
     */
    this.__UnwrapObservable = function (value) {
      return ko.utils.unwrapObservable(value);
    };

    /**
     * A wrapper function used by VTemplateEngine to check if a value is observable.
     * @ignore
     */
    this.__IsObservable = function (value) {
      return ko.isObservable(value);
    };

    /**
     * A wrapper function used by VTemplateEngine to create a computed observable.
     * @ignore
     */
    this.__KoComputed = function (evaluator, targetObject, options) {
      return ko.computed(evaluator, targetObject, options);
    };

    /**
     * A wrapper function used by VTemplateEngine to check if called during the first evaluation of the current computed observable.
     * @ignore
     */
    this.__KoIsInitial = function () {
      return ko.computedContext.isInitial();
    };

    /**
     * @ignore
     */
    this.__CleanNode = function (n) {
      ko.cleanNode(n);
    };
  };

  /**
   * @ignore
   */
  _KnockoutBindingProvider.getInstance = function () {
    return _KnockoutBindingProvider._instance;
  };

  /**
   * @ignore
   */
  _KnockoutBindingProvider._instance = new _KnockoutBindingProvider();
  oj._registerLegacyNamespaceProp('_KnockoutBindingProvider', _KnockoutBindingProvider);

  /* eslint-disable no-use-before-define */

  /**
   * @ignore
   */
  (function () {
    ko.bindingHandlers._ojCustomElement = {
      after: ['attr'], // Ensure attr binding is processed first so to handle :disabled case since we only process on init
      init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var _expressionHandler;
        var attributeListener;

        // TODO: this code is a workaround for JET-57399. It should be removed when the issue is fixed.
        if (
          bindingContext &&
          bindingContext.$provided &&
          !(bindingContext.$provided instanceof Map)
        ) {
          // eslint-disable-next-line no-param-reassign
          bindingContext.$provided = new Map(Object.entries(bindingContext.$provided));
        }

        const compMetadata = ojcustomelementRegistry.getMetadata(element.tagName);
        const metadataProps = compMetadata.properties || {};

        // Compute data about the provided and consumed properties.
        // Also get the function that would perform necessary clean up when the bindings on the provider element are being cleaned
        const {
          provide: provideMap,
          consume: consumeMap,
          cleanup: disposeProviderListeners
        } = _setupProvideAndConsumeMaps(element, compMetadata);

        // Called both when KO's cleanNode() is invoked and when the observable view model is mutated
        function cleanup() {
          if (_expressionHandler) {
            _expressionHandler.teardown();
            _expressionHandler = null;
          }

          if (attributeListener) {
            element.removeEventListener(_ATTRIBUTE_CHANGED, attributeListener);
            attributeListener = null;
          }

          _KnockoutBindingProvider.getInstance().__NotifyBindingsDisposed(element);
        }

        // Called only when KO's cleanNode() is invoked
        function finalCleanup() {
          cleanup();
          disposeProviderListeners();
        }

        function setup(skipThrottling, isInitial) {
          _expressionHandler = new ExpressionPropertyUpdater(element, bindingContext, skipThrottling);

          // Dummy metadata for passing to the ExpressionPropertyUpdater for DOM listener attributes i.e. on-*
          var domListenerMetadata = { _domListener: true };

          // Set a flag on the bridge to indicate that we are initializing expressions from the DOM
          // to avoid overriding any property sets that could have occured after
          const elementState = ojcustomelementUtils.CustomElementUtils.getElementState(element);
          elementState.beginApplyingBindings();

          // setupPropertyBinding will only update properties defined in metadata so it's safe to iterate through all element attributes
          // including ones defined on the base HTML prototype
          var attrs = element.attributes; // attrs is a NamedNodeMap
          for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            var propName = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attr.nodeName);
            let initialValueSetter;
            let topPropName;
            const isDomEvent =
              ojcustomelementUtils.AttributeUtils.isEventListenerProperty(propName) && !metadataProps[propName];

            if (!isDomEvent) {
              topPropName = propName.split('.')[0];
              const info = provideMap.get(topPropName);
              // Initial value for provided properties needs to be set only when setup() is called for the very first time.
              // After that, we will be using property change listeners to update the values
              initialValueSetter = isInitial && info ? info.set : undefined;
            }

            _expressionHandler.setupPropertyBinding(
              attr.value,
              propName,
              isDomEvent ? domListenerMetadata : metadataProps[topPropName],
              // Pass in a setter to store the initial value if this property will be
              // provided to descendants
              initialValueSetter
            );
          }

          // Now set up implicit consumption of bindings for properties whose attributes are not set and whose
          // metadata is set up to consume provided properties
          consumeMap.forEach((consumingPropValue, consumingProp) => {
            if (
              typeof consumingProp === 'string' &&
              !element.hasAttribute(ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(consumingProp))
            ) {
              const provideInfo = provideMap.get(consumingProp);
              // Initial value for provided properties needs to be set only when setup() is called for the very first time.
              // After that, we will be using property change listeners to update the values
              const initialValueSetter = isInitial && provideInfo ? provideInfo.set : undefined;
              _expressionHandler.setupPropertyBinding(
                undefined,
                consumingProp,
                metadataProps[consumingProp],
                initialValueSetter,
                consumingPropValue
              );
            } else if (consumingProp === ojbindpropagation.CONSUMED_CONTEXT) {
              // Pass context values via __oj_private_contexts property to make it available to the ComponentWithContexts class.
              // The ComponentWithContext will gets the property, parses the contexts and wraps the base component into Preact context providers.
              // Notice that we have a similar step in VTemplateEngine class, but the VTemplateEngine uses
              // __oj_provided_contexts property to pass provided values. The difference in steps is due to the fact
              // that VTemplateEngine nodes are processed by EnvironmentWrapper class before going to ComponentWithContexts class.
              // The EnvironmentWrapper class will set __oj_private_contexts property based on multiple factors that don't play role here.
              // See JET-68575 for details.
              const provided = bindingContext.$provided;
              const providedValues = new Map();
              consumingPropValue.forEach((context) => {
                if (provided && provided.has(context)) {
                  providedValues.set(context, ko.unwrap(provided.get(context)));
                }
              });
              element.setProperty('__oj_private_contexts', providedValues);
            }
          });

          attributeListener = function (evt) {
            var detail = evt.detail;
            var _attr = detail.attribute;
            var _propName = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(_attr);
            var _isDomEvent =
              ojcustomelementUtils.AttributeUtils.isEventListenerProperty(_propName) && !metadataProps[_propName];

            var metadata = _isDomEvent ? domListenerMetadata : metadataProps[_propName.split('.')[0]]; // send metadata for top level property
            _expressionHandler.setupPropertyBinding(
              detail.value,
              _propName,
              metadata,
              undefined /* no need to get initial value on attribute change */,
              consumeMap.get(_propName)
            );
          };

          element.addEventListener(_ATTRIBUTE_CHANGED, attributeListener);
        }

        // Use ko.computed to track changes to the binding context. The binding will be cleaned u and recreated when a change
        // is detected
        ko.computed(
          function () {
            // Access valueAccesor to ensure that the binding is re-initialized when an
            // observable ViewModel is mutated
            var skipThrottling = valueAccessor().skipThrottling;

            const isInitial = ko.computedContext.isInitial();
            if (!isInitial) {
              cleanup();
            }

            setup(skipThrottling, isInitial);
          },
          null,
          { disposeWhenNodeIsRemoved: element }
        );

        ko.utils.domNodeDisposal.addDisposeCallback(element, finalCleanup);

        const contextWithProvideInfo = _getChildContext(bindingContext, provideMap);
        ko.applyBindingsToDescendants(contextWithProvideInfo, element);

        _KnockoutBindingProvider.getInstance().__NotifyBindingsApplied(element);

        return { controlsDescendantBindings: true };
      }
    };

    const _ATTRIBUTE_CHANGED = 'attribute-changed';
    const _CHANGE_SUFFIX = 'Changed';

    function _setupProvideAndConsumeMaps(element, compMetadata) {
      // A map of a property name to a record with the following structure:
      // {set: {Function}, vars: Array<{name: {String}, obs: {Function}, transform: {Record<string, string>}}>} (the 'set' key representing
      // the setter for updating the value (the setter may be updating more than one observable if the value is being provided
      // under different names), the 'vars' key representing an array of records with a 'name' key
      // being the provided name, the 'obs' key being the associated observable, and the 'transform' key being an optional
      // transform map
      const provide = new Map();

      // A map of a property name to a name of a provided property that should be consumed via an implicit binding
      const consume = new Map();

      // Example 'provide binding' metadata:
      // binding: {provide: [{name: "containerLabelEdge", default: "inside"}, {name: "labelEdge", transform: {top: "provided", start: "provided"}}]}

      // Example 'consume binding' metadata:
      // binding: {consume: {name: "containerLabelEdge"}}

      const changeListeners = Object.create(null);

      const provideConsumeMeta = ojbindpropagation.getPropagationMetadataViaCache(element.localName, compMetadata); // will return null if the component has no provide/consume metadata
      if (provideConsumeMeta !== null) {
        const metadataProps = compMetadata.properties || {};
        // eslint-disable-next-line no-restricted-syntax
        for (const [pName, [provideMeta, consumeMeta]] of provideConsumeMeta) {
          if (provideMeta !== undefined) {
            // 1) populate the 'provide' map including
            //    a) using any root-level (static) values
            //    b) collecting initial values for properties whose attributes have literal values

            // The binding will be provided to descendants only if the corresponding attribute is set
            // or if the default value is provided via metadata
            const observables = [];
            const vars = [];
            if (pName === ojbindpropagation.STATIC_PROPAGATION) {
              // Populate the map with name => {name,default} values without creating observables
              // since the values are static.
              provideMeta.forEach((info) => {
                provide.set(info.name, info);
              });
            } else {
              // iterate over provided bindings (there may be more than one!) that a single attribute produces
              provideMeta.forEach((info) => {
                const name = info.name;
                if (name === undefined) {
                  throw new Error('name attribute for the binding/provide metadata is required!');
                }
                const defaultVal = info.default;
                const obs = _createObservableWithTransform(info.transform, defaultVal);
                observables.push(obs);
                vars.push({ name, obs });
              });
            }

            if (vars.length > 0) {
              // create a setter function that can update several observables at once
              const set = _getSingleSetter(observables);
              provide.set(pName, { set, vars });

              // Call the setter function whenever a  proeprty change event is fired
              const changeListener = _setupChangeListenerForProvidedProperty(set);
              const evtName = pName + _CHANGE_SUFFIX;
              element.addEventListener(evtName, changeListener);
              // Store listener in a map for future cleanup
              changeListeners[evtName] = changeListener;

              // If the attribute is present, and its value is not an expression, we won't be getting the initial value
              // when the expression is evaluated, so we have to coerce and store the initial value here
              const attrName = ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(pName);
              const hasAttribute = element.hasAttribute(attrName);
              if (hasAttribute) {
                const attrVal = element.getAttribute(attrName);
                if (!ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrVal).expr) {
                  set(
                    ojcustomelementUtils.AttributeUtils.attributeToPropertyValue(
                      element,
                      attrName,
                      attrVal,
                      metadataProps[pName]
                    )
                  );
                }
              }
            }
          }
          if (consumeMeta !== undefined) {
            // 2) populate the 'consume' map
            if (pName === ojbindpropagation.CONSUMED_CONTEXT) {
              consume.set(pName, consumeMeta);
            } else {
              const name = consumeMeta.name;
              if (name === undefined) {
                throw new Error("'name' property on the binding/consume metadata is required!");
              }
              consume.set(pName, name);
            }
          }
        }
      }

      function cleanup() {
        const changeListenerKeys = Object.keys(changeListeners);
        changeListenerKeys.forEach((key) => element.removeEventListener(key, changeListeners[key]));
      }

      return { provide, consume, cleanup };
    }

    function _setupChangeListenerForProvidedProperty(setter) {
      return (evt) => setter(evt.detail.value);
    }

    function _getChildContext(bindingContext, provideMap) {
      if (provideMap.size === 0) {
        return bindingContext;
      }
      const oldProvided = bindingContext.$provided;
      const newProvided = new Map(oldProvided);
      provideMap.forEach((propValue) => {
        if (propValue.vars) {
          // Set dynamically provided values
          const vars = propValue.vars;
          vars.forEach((info) => {
            const obs = info.obs;
            newProvided.set(info.name, obs);
          });
        } else {
          // Set statically provided values
          newProvided.set(propValue.name, propValue.default);
        }
      });
      return bindingContext.extend({ $provided: newProvided });
    }

    function _createObservableWithTransform(transform, initialVal) {
      const observable = ko.observable(initialVal);
      if (transform) {
        return ko.pureComputed({
          // eslint-disable-next-line no-prototype-builtins
          write: (value) => observable(transform.hasOwnProperty(value) ? transform[value] : value),
          read: () => observable()
        });
      }
      return observable;
    }

    function _getSingleSetter(observables) {
      return (val) => observables.forEach((observable) => observable(val));
    }
  })();

  /**
   * @ignore
   */
  (function () {
    var _BINDINGS = '_ojbindingsobj';

    BindingProviderImpl.registerPreprocessor('oj-bind-text', function (node) {
      return _replaceWithKo(node, 'text', 'value', true);
    });

    BindingProviderImpl.registerPreprocessor('oj-bind-if', function (node) {
      return _replaceWithKo(node, 'if', 'test', false);
    });

    BindingProviderImpl.registerPreprocessor('oj-bind-for-each', _replaceWithKoForEach);

    BindingProviderImpl.addPostprocessor({
      nodeHasBindings: function (node, wrappedReturn) {
        var bindings = _getBindings(node);
        return (
          wrappedReturn ||
          bindings._ATTR_BIND != null ||
          bindings._STYLE_BIND != null ||
          bindings._EVENT_BIND != null
        );
      },
      getBindingAccessors: function (node, bindingContext, wrappedReturn) {
        if (node.nodeType === 1) {
          // eslint-disable-next-line no-param-reassign
          wrappedReturn = wrappedReturn || {};
          var bindings = _getBindings(node);
          var i;
          var attr;

          // Style bindings
          var styleAttrs = bindings._STYLE_BIND;
          if (styleAttrs) {
            if (wrappedReturn.style) {
              throw new Error(
                'Cannot have both style data-bind and JET style binding on ' +
                  node.tagName +
                  ' with id ' +
                  node.id
              );
            }

            // If :style is set, any additional :style.* attributes would have thrown an error earlier
            if (styleAttrs === 'style') {
              // eslint-disable-next-line no-param-reassign
              wrappedReturn[styleAttrs] = _getValueEvaluator(
                node,
                styleAttrs,
                node.getAttribute(_getBoundAttrName(styleAttrs)),
                bindingContext,
                'object'
              );
            } else {
              var styleEvaluators = {};
              for (i = 0; i < styleAttrs.length; i++) {
                attr = styleAttrs[i];
                var styleProp = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attr.substring(6));
                styleEvaluators[styleProp] = _getValueEvaluator(
                  node,
                  attr,
                  node.getAttribute(_getBoundAttrName(attr)),
                  bindingContext,
                  'string'
                );
              }
              // eslint-disable-next-line no-param-reassign
              wrappedReturn.style = _getObjectEvaluator(styleEvaluators);
            }
          }

          // All other attribute bindings
          var boundAttrs = bindings._ATTR_BIND;
          if (boundAttrs) {
            if (wrappedReturn.attr) {
              throw new Error(
                'Cannot have both attr data-bind and JET attribute binding on ' +
                  node.tagName +
                  ' with id ' +
                  node.id
              );
            }

            var attrEvaluators = {};
            for (i = 0; i < boundAttrs.length; i++) {
              attr = boundAttrs[i];
              // For the class attribute we support a string, an array and object types.
              // For all the types we pass to knockout's css binding that also handles arrays and strings
              // since version 3.5.0.
              if (attr === 'class') {
                _setClassEvaluator(
                  wrappedReturn,
                  node,
                  node.getAttribute(_getBoundAttrName(attr)),
                  bindingContext
                );
              } else {
                attrEvaluators[attr] = _getValueEvaluator(
                  node,
                  attr,
                  node.getAttribute(_getBoundAttrName(attr)),
                  bindingContext,
                  'string'
                );
              }
            }

            // eslint-disable-next-line no-param-reassign
            wrappedReturn.attr = _getObjectEvaluator(attrEvaluators);
          }

          // Event bindings for native HTML elements
          var eventAttrs = bindings._EVENT_BIND;
          if (eventAttrs) {
            // Delegate to ExpressionPropertyUpdater, which is also responsible for
            // setting up the event bindings for custom elements.
            var expressionHandler = new ExpressionPropertyUpdater(node, bindingContext, true);

            for (i = 0; i < eventAttrs.length; i++) {
              var attrNode = eventAttrs[i];
              var propName = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attrNode.nodeName);
              expressionHandler.setupPropertyBinding(attrNode.value, propName, {
                _domListener: true
              });
            }

            ko.utils.domNodeDisposal.addDisposeCallback(node, function () {
              if (expressionHandler) {
                expressionHandler.teardown();
                expressionHandler = null;
              }
            });
          }
        }
        return wrappedReturn;
      }
    });

    function _replaceWithKo(node, bindableAttr, nodeAttr, stringify) {
      var expr = ojcustomelementUtils.KoBindingUtils.getExpressionForAttr(node, nodeAttr, stringify);
      if (!expr) {
        return undefined;
      }

      const handler = bindableAttr === 'if' ? '_ojBindIf_V2_' : bindableAttr;
      const binding = 'ko ' + handler + ':' + expr;
      return _getReplacementNodes(node, bindableAttr, binding);
    }

    function _replaceWithKoForEach(node) {
      const bindingStr = ojcustomelementUtils.KoBindingUtils.createBindForEachHandlerStr(node);
      if (!bindingStr) {
        return undefined;
      }
      return _getReplacementNodes(node, '_ojBindForEach_', bindingStr);
    }

    function _getReplacementNodes(node, bindableAttr, binding) {
      // Wrap the ko comment we will generate with an additional wrapper
      // with all of the attribute info that was on the original DOM node.
      // <!--oj-bind-for-each data='[[users]]' -->
      var nodeName = node.tagName.toLowerCase();
      var ojcommenttext = ojcustomelementUtils.KoBindingUtils.getNodeReplacementCommentStr(node);

      var parent = node.parentNode;
      var ojOpenComment = document.createComment(ojcommenttext);
      var ojCloseComment = document.createComment('/' + nodeName);
      parent.insertBefore(ojOpenComment, node); // @HTMLUpdateOK
      // eslint-disable-next-line no-param-reassign
      node[ojcustomelementUtils.OJ_BIND_CONVERTED_NODE] = ojOpenComment;

      var koOpenComment = document.createComment(binding);
      var koCloseComment = document.createComment('/ko');
      parent.insertBefore(koOpenComment, node); // @HTMLUpdateOK

      var newNodes = [ojOpenComment, koOpenComment];
      var child;
      // Copy oj-bind-x children into the comment node
      if (bindableAttr === 'if') {
        while (node.childNodes.length > 0) {
          child = node.childNodes[0];
          parent.insertBefore(child, node); // @HTMLUpdateOK
          newNodes.push(child);
        }
      } else if (bindableAttr === '_ojBindForEach_') {
        while (node.childNodes.length > 0) {
          child = node.childNodes[0];
          parent.insertBefore(child, node); // @HTMLUpdateOK
          newNodes.push(child);
        }
      }
      parent.insertBefore(koCloseComment, node); // @HTMLUpdateOK
      newNodes.push(koCloseComment);

      parent.replaceChild(ojCloseComment, node);
      newNodes.push(ojCloseComment);

      return newNodes;
    }

    function _setClassEvaluator(wrappedReturn, elem, value, bindingContext) {
      var evaluator;
      var exp = ojcustomelementUtils.AttributeUtils.getExpressionInfo(value).expr;
      if (exp == null) {
        var resolvedValue = ojcustomelementUtils.AttributeUtils.coerceValue(elem, 'class', value, 'any');
        evaluator = function () {
          return Array.isArray(resolvedValue) ? resolvedValue.join(' ') : resolvedValue;
        };
      } else {
        var classValueEvaluator = BindingProviderImpl.createEvaluator(exp, bindingContext).bind(
          null,
          bindingContext
        );
        // create computed to handle cases when an expression evaluates into an observable or
        // when expression evaluates into a function that mutates the value based on observable.
        evaluator = ko.pureComputed(function () {
          var classValue = ko.unwrap(classValueEvaluator());
          return Array.isArray(classValue) ? classValue.join(' ') : classValue;
        });
      }
      // eslint-disable-next-line no-param-reassign
      wrappedReturn.css = evaluator;
    }

    function _getValueEvaluator(elem, attr, value, bindingContext, type) {
      var exp = ojcustomelementUtils.AttributeUtils.getExpressionInfo(value).expr;
      if (exp == null) {
        return function () {
          return type === 'object' ? ojcustomelementUtils.AttributeUtils.coerceValue(elem, attr, value, type) : value;
        };
      }
      return BindingProviderImpl.createEvaluator(exp, bindingContext).bind(null, bindingContext);
    }

    function _getObjectEvaluator(attrEvaluators) {
      return function () {
        var evaluatedExprs = {};
        var attrs = Object.keys(attrEvaluators);
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          evaluatedExprs[attr] = attrEvaluators[attr]();
        }
        return evaluatedExprs;
      };
    }

    function _getBindings(node) {
      if (node.nodeType !== 1) {
        return {};
      }

      if (!node[_BINDINGS]) {
        // Iterate through all attributes on the element and find those that are using our
        // data bind attibute syntax
        var bindings = {};
        var boundAttrs = [];
        var boundStyle = [];
        var boundEvents = [];
        var attrs = node.attributes; // attrs is a NamedNodeMap
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var unboundAttrName = _getUnboundAttrName(attr.name);
          if (unboundAttrName) {
            // An element can have a style binding or several style.* bindings.
            // Throw an error if both are present.
            if (unboundAttrName === 'style') {
              bindings._STYLE_BIND = unboundAttrName;
            } else if (unboundAttrName.substring(0, 6) === 'style.') {
              boundStyle.push(unboundAttrName);
            } else {
              boundAttrs.push(unboundAttrName);
            }
          }

          // Handle event binding for native HTML elements.
          // The event binding for custom elements is handled by the bridge.
          if (!ojcustomelementRegistry.isElementRegistered(node.nodeName) && attr.name.substring(0, 3) === 'on-') {
            boundEvents.push(attr);
          }
        }

        if (boundStyle.length) {
          if (bindings._STYLE_BIND) {
            throw new Error(
              'Cannot have both style and style.* data bound attributes on ' +
                node.tagName +
                ' with id ' +
                node.id
            );
          } else {
            bindings._STYLE_BIND = boundStyle;
          }
        }

        if (boundAttrs.length) {
          bindings._ATTR_BIND = boundAttrs;
        }

        if (boundEvents.length) {
          bindings._EVENT_BIND = boundEvents;
        }

        // Cache attribute map as a non-enumerable property so we don't have to loop again
        // in getBindingAccessors
        Object.defineProperty(node, _BINDINGS, { value: bindings });
      }
      return node[_BINDINGS];
    }

    function _getUnboundAttrName(attr) {
      if (attr && attr.charAt(0) === ':') {
        return attr.slice(1);
      }
      return null;
    }

    function _getBoundAttrName(attr) {
      return ':' + attr;
    }
  })();

  

  (function () {
    'use strict';

    // index.js
    // --------
    // Fast For Each
    //
    // Employing sound techniques to make a faster Knockout foreach binding.
    // --------

    //      Utilities
    var MAX_LIST_SIZE = 9007199254740991;

    var supportsDocumentFragment = document && typeof document.createDocumentFragment === 'function';

    // Mimic a KO change item 'add'
    function valueToChangeAddItem(value, index, key) {
      return {
        status: 'added',
        value: value,
        index: index,
        key: key
      };
    }

    // Mimic a KO change item 'delete'
    function valueToChangeDeleteItem(index) {
      return {
        status: 'deleted',
        value: {},
        index: index
      };
    }

    // KO 3.4 doesn't seem to export this utility function so it's here just to be sure
    function createSymbolOrString(identifier) {
      // return typeof Symbol === 'function' ? Symbol(identifier) : identifier;
      return identifier;
    }

    // Array.prototype.map doesn't execute the mapping function on indices that don't have assigned values
    // so it would be a NOP for new Array(5).  Call this for loop based version instead
    function arrayMap(array, mapping) {
      var result;
      if (array) {
        var length = array.length;
        result = new Array(length);
        for (var i = 0; i < length; i++) {
          result[i] = mapping(array[i], i, array);
        }
      }
      return result;
    }

    function findNearestCustomParent(element, parentTrackingContext) {
      var parent = element.parentNode;
      while (parent && !ojcustomelementUtils.ElementUtils.isValidCustomElementName(parent.localName)) {
        parent = parent.parentNode;
      }
      if (!parent) {
        parent = parentTrackingContext ? parentTrackingContext._nearestCustomParent : null;
      }
      return parent;
    }

    function findImmediateState(element, nearestCustomParent, parentTrackingContext) {
      var isImmediate = false;
      var nestedElement = !!parentTrackingContext;
      if (element.parentNode === nearestCustomParent) {
        isImmediate = true;
      } else if (nestedElement && !element.parentNode.parentNode) {
        isImmediate = parentTrackingContext._immediate;
      }
      return isImmediate;
    }

    function getTemplateNodes(elem) {
      var defaultTemplate;
      var noDataTemplate;
      var nodes = ko.virtualElements.childNodes(elem);
      for (var i = 0; i < nodes.length; i++) {
        var testNode = nodes[i];
        if (testNode.nodeType === 1 && testNode.nodeName.toLowerCase() === 'template') {
          var slotAttr = ojcustomelementUtils.CustomElementUtils.getSlotAssignment(testNode);
          if (!defaultTemplate && (!slotAttr || slotAttr === '')) {
            defaultTemplate = testNode;
          } else if (!noDataTemplate && slotAttr === 'noData') {
            noDataTemplate = testNode;
          } else {
            // error condition
            var errMessage;
            switch (slotAttr) {
              case '':
                errMessage =
                  'Multiple default templates found: oj-bind-for-each requires a single default template element as its direct child';
                break;
              case 'noData':
                errMessage =
                  'Multiple noData templates found: oj-bind-for-each requires a single noData template element as its direct child';
                break;
              default:
                errMessage =
                  'Unknown template slot detected - ' +
                  slotAttr +
                  ': oj-bind-for-each supports a single default template and a single noData template';
            }
            throw new Error(errMessage);
          }
        }
      }
      if (!defaultTemplate) {
        throw new Error(
          'Default template not found: oj-bind-for-each requires a single default template element as its direct child'
        );
      }
      // eslint-disable-next-line no-param-reassign
      elem._templateNode = defaultTemplate;
      // eslint-disable-next-line no-param-reassign
      elem._noDataTemplateNode = noDataTemplate;
    }

    var insertAfterAndInvokeAttached = function (container, nodeOrNodeArray, insertAfterNode) {
      if (Array.isArray(nodeOrNodeArray)) {
        var frag = document.createDocumentFragment();

        for (let i = 0, len = nodeOrNodeArray.length; i !== len; ++i) {
          frag.appendChild(nodeOrNodeArray[i]);
        }

        ko.virtualElements.insertAfter(container, frag, insertAfterNode); // @HTMLUpdateOK

        if (oj$2.Components) {
          for (let i = 0, len = nodeOrNodeArray.length; i !== len; ++i) {
            oj$2.Components.subtreeAttached(nodeOrNodeArray[i]);
          }
        }
      } else {
        ko.virtualElements.insertAfter(container, nodeOrNodeArray, insertAfterNode); // @HTMLUpdateOK
        if (oj$2.Components) {
          oj$2.Components.subtreeAttached(nodeOrNodeArray);
        }
      }
    };

    // store a symbol for caching the pending delete info index in the data item objects
    var PENDING_DELETE_INDEX_KEY = createSymbolOrString('_ko_ffe_pending_delete_index');

    // Abandoned promise rejection for data provider
    var _ABANDONED_PROMISE_CHAIN = 'oj-bind-for-each: abandoned promise';

    /**
     * @constructor
     * @private
     * @since 4.1.0
     */
    function OjForEach(element, value, context) {
      this.element = value.element || element;
      // convert oj-bind-x components into template
      ko.applyBindingsToDescendants(context, this.element);
      getTemplateNodes(this.element);

      // Find the correct context for the template - it is either the context
      // applied on this oj-bind-for-each element or a context applied on a swapped template
      // when oj-bind-slot was processed. We need to use the correct context for the template.
      this.element._templateNode.__ojBindingContext = ko.contextFor(this.element._templateNode);
      this.data = value.data;
      this.as = value.as;
      this.changeQueue = [];
      this.firstLastNodesList = [];
      this.indexesToDelete = [];
      this.rendering_queued = false;
      this.pendingDeletes = [];

      // The headDataPromise and tailDataPromise are used to provide an order for Data Provider events:
      // - mutate events wait for the fetch event and any previous mutate events to finish
      // - the refresh event issued during ongoing fetch or mutation cancels ongoing chain
      // The headDataPromise is acting as an ID for the promise chain and tailDataPromise is
      // the latest promise in the chain of promises - used for chaining upcoming mutaition promises to it.
      // When the entire chain is resolved, the headDataPromise and tailDataPromise should be reset to null;
      this.headDataPromise = null;
      this.tailDataPromise = null;

      // Remove existing content.
      ko.virtualElements.emptyNode(this.element);
      this._initChildrenBindingsAppliedPromise();

      var primeData = ko.unwrap(this.data);
      if (primeData.fetchFirst) {
        // the data is a DataProvider object
        this.currentDataProvider = primeData;
        this.fetchData();
      } else {
        this.onArrayChange(arrayMap(primeData, valueToChangeAddItem));
      }
      this.addSubscriptions();
    }

    OjForEach.PENDING_DELETE_INDEX_KEY = PENDING_DELETE_INDEX_KEY;

    OjForEach.prototype.addSubscriptions = function () {
      var isObservable = ko.isObservable(this.data);
      if (this.currentDataProvider) {
        this.dataMutateHandler = this.handleDataMutateEvent.bind(this);
        this.dataRefreshHandler = this.handleDataRefreshEvent.bind(this);
        this.currentDataProvider.addEventListener('mutate', this.dataMutateHandler);
        this.currentDataProvider.addEventListener('refresh', this.dataRefreshHandler);
        if (isObservable) {
          this.changeSubs = this.data.subscribe(this.onDataChange, this, 'change');
        }
      } else if (isObservable) {
        if (!this.data.indexOf) {
          // observable but not an observable array
          // Make sure the observable is trackable.
          this.data = this.data.extend({ trackArrayChanges: true });
        }
        this.changeArraySubs = this.data.subscribe(this.onArrayDataChange, this, 'arrayChange');
        this.changeSubs = this.data.subscribe(this.onDataChange, this, 'change');
      }
    };

    OjForEach.prototype.removeSubscriptions = function () {
      if (this.changeSubs) {
        this.changeSubs.dispose();
      }
      if (this.changeArraySubs) {
        this.changeArraySubs.dispose();
      }
      if (this.currentDataProvider) {
        this.currentDataProvider.removeEventListener('mutate', this.dataMutateHandler);
        this.currentDataProvider.removeEventListener('refresh', this.dataRefreshHandler);
      }
    };

    OjForEach.prototype.onArrayDataChange = function (changeSet) {
      // temporary member, cleared on change event
      this.arrayChangeSet = changeSet;
    };

    OjForEach.prototype.onDataChange = function (changedData) {
      if (this.arrayChangeSet) {
        this.onArrayChange(this.arrayChangeSet);
        this.arrayChangeSet = null;
      } else {
        this.setData({
          data: this.data,
          dataProvider: changedData.fetchFirst ? changedData : null
        });
        this.recreateContent(changedData);
      }
    };

    OjForEach.prototype.recreateContent = function (changedData) {
      // clean up existing content
      this.changeQueue = [];
      this.firstLastNodesList = [];
      this.indexesToDelete = [];
      this.rendering_queued = false;
      this.pendingDeletes = [];
      this._noDataNodes = null;
      ko.virtualElements.emptyNode(this.element);
      if (changedData.fetchFirst) {
        // refetch data and recreate the child nodes
        this.fetchData();
      } else {
        this.onArrayChange(arrayMap(changedData, valueToChangeAddItem));
      }
    };

    OjForEach.prototype.registerBusyState = function () {
      var containerElement = this.element.parentNode;
      var busyContext = Context.getContext(containerElement).getBusyContext();
      return busyContext.addBusyState({
        description:
          'oj-bind-for-each binding on a node with the Id ' + containerElement.id + 'is loading data.'
      });
    };

    // initializes a promise for expanding an element and applying bindings to its children
    OjForEach.prototype._initChildrenBindingsAppliedPromise = function () {
      var currentContext = this.element._templateNode.__ojBindingContext.$current;
      var parentTrackingContext = currentContext
        ? {
            _nearestCustomParent: currentContext._nearestCustomParent,
            _immediate: currentContext._immediate
          }
        : null;
      var nearestCustomParent = findNearestCustomParent(this.element, parentTrackingContext);
      var isImmediate = findImmediateState(this.element, nearestCustomParent, parentTrackingContext);
      this.trackingContext = {
        _nearestCustomParent: nearestCustomParent,
        _immediate: isImmediate
      };
      this._childrenBindingsPromiseResolver = _KnockoutBindingProvider
        .getInstance()
        .__RegisterBindingAppliedPromiseForChildren(nearestCustomParent, isImmediate);
    };

    // resolves _whenChildrenBindingsApplied promise for the element
    OjForEach.prototype._resolveChildrenBindingsAppliedPromise = function () {
      if (this._childrenBindingsPromiseResolver) {
        this._childrenBindingsPromiseResolver();
        this._childrenBindingsPromiseResolver = null;
      }
    };

    // Helper function that resets head and tail promises, then the entire chain is resolved
    // and there are no pending promises
    OjForEach.prototype.resetChainIfCompleted = function (currentDataPromise) {
      if (currentDataPromise === this.tailDataPromise) {
        this.headDataPromise = null;
        this.tailDataPromise = null;
      }
    };

    // Helper function that processes promise rejection and rethrows an error
    // unless the error is a valid or already caught one
    OjForEach.prototype.promiseRejectHelper = function (reason, busyStateCallback, currentPromise) {
      busyStateCallback();
      this.resetChainIfCompleted(currentPromise);
      if (reason._CAUGHT_PROMISE_REJECTION || reason.message === _ABANDONED_PROMISE_CHAIN) {
        Logger.info(reason);
      } else {
        if (reason instanceof Error) {
          // should reuse existing error to stop extra throws down the chain, can't rethrow a new one
          // the chain gets an original error
          // eslint-disable-next-line no-param-reassign
          reason._CAUGHT_PROMISE_REJECTION = true;
          throw reason;
        }
        throw new Error(reason);
      }
    };

    // This function is used to retrieve data from data provider - on initial update and
    // to handle refresh operation
    OjForEach.prototype.fetchData = function () {
      var busyStateCallback = this.registerBusyState();
      var iterator = this.currentDataProvider.fetchFirst({ size: -1 })[Symbol.asyncIterator]();
      var dataPromiseResolve;
      var dataPromiseReject;
      var headPromise;

      // function passed to iterator.next() promise on success, until result.done is set to true
      var getProcessResultsFunc = function (changeSet, onArrayChangeCallback, callbackObj) {
        return function (result) {
          if (callbackObj.headDataPromise === headPromise) {
            // current promise
            var value = result.value;
            var entryIndex = changeSet.length;
            for (var i = 0; i < value.metadata.length && i < value.data.length; i++) {
              changeSet.push(valueToChangeAddItem(value.data[i], entryIndex, value.metadata[i].key));
              entryIndex += 1;
            }
            if (result.done) {
              // finish up
              onArrayChangeCallback.call(callbackObj, changeSet);
              busyStateCallback();
              dataPromiseResolve();
              callbackObj.resetChainIfCompleted(headPromise);
            } else {
              iterator
                .next()
                .then(
                  getProcessResultsFunc(changeSet, onArrayChangeCallback, callbackObj),
                  function (reason) {
                    busyStateCallback();
                    dataPromiseReject(reason);
                    callbackObj.resetChainIfCompleted(headPromise);
                  }
                );
            }
          } else {
            // abandoned promise
            busyStateCallback();
            dataPromiseReject(new Error(_ABANDONED_PROMISE_CHAIN));
          }
        };
      };

      // New head promise is created for the chain start.
      // The promise will be resolved on result.done() or rejected on errors.
      // All rejections are caught in the catch block and analyzed.
      // The abandoned promise rejections are ignored,
      // other rejections are thrown and marked with _CAUGHT_PROMISE_REJECTION
      // in order to prevent rethrowing in chained promises.
      headPromise = new Promise(
        function (resolve, reject) {
          dataPromiseResolve = resolve;
          dataPromiseReject = reject;
          iterator.next().then(
            getProcessResultsFunc([], this.onArrayChange, this),
            function (reason) {
              busyStateCallback();
              dataPromiseReject(reason);
              this.resetChainIfCompleted(headPromise);
            }.bind(this)
          );
        }.bind(this)
      );

      // the catch handles a case when the head promise does not have a chain and we need to catch valid rejection
      headPromise.catch(function (reason) {
        if (reason.message !== _ABANDONED_PROMISE_CHAIN) {
          if (reason instanceof Error) {
            // should reuse existing error to stop extra throws down the chain, can't rethrow a new one
            // the chain gets an original error
            // eslint-disable-next-line no-param-reassign
            reason._CAUGHT_PROMISE_REJECTION = true;
            throw reason;
          }
          throw new Error(reason);
        }
      });

      this.headDataPromise = headPromise;
      this.tailDataPromise = headPromise;
    };

    // This function populates an array of indexes either from event indexes or
    // from event keys
    OjForEach.prototype.getIndexesForEvent = function (eventIndexes, eventKeys) {
      var dataIndexes = [];
      var i;
      if (Array.isArray(eventIndexes)) {
        // use indexes if possible
        for (i = 0; i < eventIndexes.length; i++) {
          dataIndexes.push(eventIndexes[i]);
        }
      } else if (eventKeys) {
        // retrieve indexes from keys
        // eventKeys can be a Set or an Array, so we need to get the key count differently
        var eventKeysCount = Array.isArray(eventKeys) ? eventKeys.length : eventKeys.size;
        var eventKeySet = new KeySetImpl(eventKeys);
        var keyIndexMap = new Map();
        var count = 0;
        for (i = 0; i < this.firstLastNodesList.length && count < eventKeysCount; i++) {
          var nodeKey = this.firstLastNodesList[i].key;
          var eventKey = eventKeySet.get(nodeKey);
          if (eventKey !== eventKeySet.NOT_A_KEY) {
            keyIndexMap.set(eventKey, i);
            count += 1;
          }
        }

        eventKeys.forEach(function (keyValue) {
          dataIndexes.push(keyIndexMap.get(keyValue));
        });
      }
      return dataIndexes;
    };

    // Handler that processes "mutate" event from DataProvider
    OjForEach.prototype.handleDataMutateEvent = function (event) {
      // object that contains head and current promises, that we can't pass directly
      // to the function through the closure scope
      var busyStateCallback;
      var promiseContainer = {};
      var currentPromise;
      var self = this;

      if (this.tailDataPromise) {
        busyStateCallback = this.registerBusyState();
        currentPromise = this.tailDataPromise.then(function () {
          // success
          busyStateCallback();
          return self.getDataMutationHelper(event, promiseContainer);
        });
        currentPromise.catch(function (reason) {
          // error handler
          self.promiseRejectHelper(reason, busyStateCallback, currentPromise);
        });
      } else {
        currentPromise = this.getDataMutationHelper(event, promiseContainer);
        this.headDataPromise = currentPromise;
      }
      this.tailDataPromise = currentPromise;
      promiseContainer.head = this.headDataPromise;
      promiseContainer.current = currentPromise;
    };

    // Helper function that processes mutation event. If the event is asyncronous,
    // the function returns a promise, otherwise the function just updates existing data set,
    // returns either Promise for async mutation or undefined for sync mutation.
    OjForEach.prototype.getDataMutationHelper = function (event, promiseContainer) {
      var addDetail = event.detail.add;
      var removeDetail = event.detail.remove;
      var updateDetail = event.detail.update;
      var busyStateCallback;
      var dataPromise; // Define the promise when data are fetched - add or update event.

      // Used by doUpdates() and doAdditions(). The values could be assigned after fetch
      // if fetch is needed.
      var addData = addDetail && addDetail.data;
      var updateData = updateDetail && updateDetail.data;

      // Define helper methods for updates, removals and additions, that will be used for
      // both cases, when data are available and data are fetched
      var doUpdates = () => {
        if (updateData) {
          var dataIndex = 0;
          var changes = [];
          var dataIndexes = this.getIndexesForEvent(updateDetail.indexes, updateDetail.keys);
          updateDetail.keys.forEach(function (keyValue) {
            if (dataIndexes[dataIndex] !== undefined) {
              var dataItem = updateData[dataIndex];
              changes.push(valueToChangeDeleteItem(dataIndexes[dataIndex]));
              changes.push(valueToChangeAddItem(dataItem, dataIndexes[dataIndex], keyValue));
            }
            dataIndex += 1;
          });
          this.onArrayChange(changes);
        }
      };
      var doRemovals = () => {
        if (removeDetail) {
          // Get indexes to delete using either indexes or given keys
          var dataIndexes = this.getIndexesForEvent(removeDetail.indexes, removeDetail.keys);
          dataIndexes = dataIndexes.filter(function (value) {
            return value !== undefined;
          });
          this.onArrayChange(dataIndexes.map(valueToChangeDeleteItem));
        }
      };
      var doAdditions = () => {
        if (addData) {
          // The 'afterKeys' prop is deprecated, but continue to support it until we can remove it.
          // The getIndexesForEvent() method can take either array or set as its argument.
          var dataIndexes = this.getIndexesForEvent(
            addDetail.indexes,
            addDetail.addBeforeKeys ? addDetail.addBeforeKeys : addDetail.afterKeys
          );

          var getCurrentIndex = function (entryIndex) {
            var currentIndex =
              dataIndexes.length > entryIndex
                ? dataIndexes[entryIndex]
                : this.firstLastNodesList.length + entryIndex; // add entry to the end
            if (currentIndex === undefined) {
              return this.firstLastNodesList.length;
            }
            return currentIndex;
          };

          var changes = [];
          var dataIndex = 0; // Used to iterate trough eventData
          addDetail.keys.forEach(function (keyValue) {
            var dataItem = addData[dataIndex];
            changes.push(valueToChangeAddItem(dataItem, getCurrentIndex(dataIndex), keyValue));
            dataIndex += 1;
          }, this);
          this.onArrayChange(changes);
        }
      };

      // Some data were not sent, need to fetch data and work with promises.
      if ((updateDetail && !Array.isArray(updateData)) || (addDetail && !Array.isArray(addData))) {
        var updatePromise =
          updateDetail && !Array.isArray(updateData)
            ? this.currentDataProvider.fetchByKeys({ keys: updateDetail.keys })
            : Promise.resolve();
        var addPromise =
          addDetail && !Array.isArray(addData)
            ? this.currentDataProvider.fetchByKeys({ keys: addDetail.keys })
            : Promise.resolve();

        busyStateCallback = this.registerBusyState();
        dataPromise = Promise.all([updatePromise, addPromise]).then((keyResults) => {
          // successfully got all the data
          // if promise is current, retrieve records and update data set;
          // else throw valid rejection error
          if (promiseContainer.head === this.headDataPromise) {
            // Perform updates
            var updateKeyResults = keyResults[0];
            if (updateKeyResults && updateKeyResults.results.size > 0) {
              updateData = [...updateDetail.keys].map((key) => {
                return updateKeyResults.results.get(key).data;
              });
            }
            doUpdates();

            // Perform removals
            doRemovals();

            // Perform additions
            var addKeyResults = keyResults[1];
            if (addKeyResults && addKeyResults.results.size > 0) {
              addData = [...addDetail.keys].map((key) => {
                return addKeyResults.results.get(key).data;
              });
            }
            doAdditions();

            busyStateCallback();
            this.resetChainIfCompleted(promiseContainer.current);
          } else {
            // Promise is not current
            busyStateCallback();
            throw new Error(_ABANDONED_PROMISE_CHAIN);
          }
        });
        dataPromise.catch((reason) => {
          this.promiseRejectHelper(reason, busyStateCallback, promiseContainer.current);
        });
      } else {
        // We have all the data upfront - just do updates, removals and additions.
        doUpdates();
        doRemovals();
        doAdditions();
      }

      return dataPromise;
    };

    // Handler that processes "refresh" event from DataProvider
    OjForEach.prototype.handleDataRefreshEvent = function () {
      this.recreateContent(this.currentDataProvider);
    };

    // Renders noData template if necessary
    OjForEach.prototype._addNoData = function () {
      if (this.firstLastNodesList.length === 0 && this.element._noDataTemplateNode) {
        this._noDataNodes = templateEngine.execute(
          this.element,
          this.element._noDataTemplateNode,
          {},
          null
        );
        this.insertAllAfter(this._noDataNodes);
      }
    };

    // Removes nodes from noData Template, if they exist
    OjForEach.prototype._removeNoData = function () {
      if (this._noDataNodes) {
        this._noDataNodes.forEach((node) => {
          templateEngine.clean(node, this.element);
          node.parentNode.removeChild(node);
        });
        this._noDataNodes = null;
      }
    };

    // If the array changes we register the change.
    OjForEach.prototype.onArrayChange = function (changeSet) {
      this._removeNoData();
      var self = this;
      var changeMap = {
        added: [],
        deleted: []
      };
      var statusAdded = 'added';
      var statusDeleted = 'deleted';

      // knockout array change notification index handling:
      // - sends the original array indexes for deletes
      // - sends the new array indexes for adds
      // - sorts them all by index in ascending order
      // because of this, when checking for possible batch additions, any delete can be between to adds with neighboring indexes, so only additions should be checked
      for (var i = 0, len = changeSet.length; i < len; i++) {
        if (changeMap[statusAdded].length && changeSet[i].status === statusAdded) {
          var lastAdd = changeMap[statusAdded][changeMap[statusAdded].length - 1];
          var lastIndex = lastAdd.isBatch ? lastAdd.index + lastAdd.values.length - 1 : lastAdd.index;
          if (lastIndex + 1 === changeSet[i].index) {
            if (!lastAdd.isBatch) {
              // transform the last addition into a batch addition object
              lastAdd = {
                isBatch: true,
                status: statusAdded,
                index: lastAdd.index,
                values: [lastAdd.value],
                keys: [lastAdd.key]
              };
              changeMap[statusAdded].splice(changeMap[statusAdded].length - 1, 1, lastAdd);
            }
            lastAdd.values.push(changeSet[i].value);
            lastAdd.keys.push(changeSet[i].key);
          } else {
            changeMap[changeSet[i].status].push(changeSet[i]);
          }
        } else {
          changeMap[changeSet[i].status].push(changeSet[i]);
        }
      }

      if (changeMap[statusDeleted].length > 0) {
        this.changeQueue.push.apply(this.changeQueue, changeMap[statusDeleted]);
        this.changeQueue.push({ status: 'clearDeletedIndexes' });
      }
      this.changeQueue.push.apply(this.changeQueue, changeMap[statusAdded]);
      // Once a change is registered, the ticking count-down starts for the processQueue.
      if (this.changeQueue.length > 0 && !this.rendering_queued) {
        this.rendering_queued = true;
        self.processQueue();
      }
      this._addNoData();
      this._resolveChildrenBindingsAppliedPromise();
    };

    // Reflect all the changes in the queue in the DOM, then wipe the queue.
    OjForEach.prototype.processQueue = function () {
      var self = this;
      var lowestIndexChanged = MAX_LIST_SIZE;

      ko.utils.arrayForEach(this.changeQueue, function (changeItem) {
        if (typeof changeItem.index === 'number') {
          lowestIndexChanged = Math.min(lowestIndexChanged, changeItem.index);
        }
        // console.log(self['data'](), "CI", JSON.stringify(changeItem, null, 2), JSON.stringify($(self.element).text()))
        self[changeItem.status](changeItem);
        // console.log("  ==> ", JSON.stringify($(self.element).text()))
      });
      this.flushPendingDeletes();
      this.rendering_queued = false;

      // Update our indexes.
      this.updateIndexes(lowestIndexChanged);

      this.changeQueue = [];
    };

    // Process a changeItem with {status: 'added', ...}
    /**
     * @expose
     * @ignore
     */
    OjForEach.prototype.added = function (changeItem) {
      var index = changeItem.index;
      var valuesToAdd = changeItem.isBatch ? changeItem.values : [changeItem.value];
      var keysToAdd = changeItem.isBatch ? changeItem.keys : [changeItem.key];
      var referenceElement = this.getLastNodeBeforeIndex(index);
      // gather all childnodes for a possible batch insertion
      var allChildNodes = [];

      for (var i = 0, len = valuesToAdd.length; i < len; ++i) {
        var childNodes;
        var currentChildContext;

        // we check if we have a pending delete with reusable nodesets for this data, and if yes, we reuse one nodeset
        var pendingDelete = this.getPendingDeleteFor(valuesToAdd[i]);
        if (pendingDelete && pendingDelete.nodesets.length) {
          childNodes = pendingDelete.nodesets.pop();
          currentChildContext = pendingDelete.currentChildContext;
        } else {
          currentChildContext = {
            data: valuesToAdd[i],
            index: index + i,
            observableIndex: ko.observable()
          };
          Object.defineProperties(currentChildContext, {
            _nearestCustomParent: {
              value: this.trackingContext._nearestCustomParent,
              enumerable: false
            },
            _immediate: {
              value: this.trackingContext._immediate,
              enumerable: false
            }
          });
          childNodes = templateEngine.execute(
            this.element,
            this.element._templateNode,
            currentChildContext,
            this.as
          );
        }

        // Note discussion at https://github.com/angular/angular.js/issues/7851
        allChildNodes.push.apply(allChildNodes, Array.prototype.slice.call(childNodes));
        this.firstLastNodesList.splice(index + i, 0, {
          first: childNodes[0],
          last: childNodes[childNodes.length - 1],
          key: keysToAdd ? keysToAdd[i] : null,
          currentChildContext: currentChildContext
        });
      }

      this.insertAllAfter(allChildNodes, referenceElement);
    };

    OjForEach.prototype.getNodesForIndex = function (index) {
      var result = [];
      var ptr = this.firstLastNodesList[index].first;
      var last = this.firstLastNodesList[index].last;

      result.push(ptr);
      while (ptr && ptr !== last) {
        ptr = ptr.nextSibling;
        result.push(ptr);
      }
      return result;
    };

    OjForEach.prototype.getLastNodeBeforeIndex = function (index) {
      if (index < 1 || index - 1 >= this.firstLastNodesList.length) {
        return null;
      }
      return this.firstLastNodesList[index - 1].last;
    };

    OjForEach.prototype.insertAllAfter = function (nodeOrNodeArrayToInsert, insertAfterNode) {
      var i;
      var containerNode = this.element;

      if (nodeOrNodeArrayToInsert.length === 1) {
        insertAfterAndInvokeAttached(containerNode, nodeOrNodeArrayToInsert[0], insertAfterNode);
      } else if (supportsDocumentFragment) {
        insertAfterAndInvokeAttached(containerNode, nodeOrNodeArrayToInsert, insertAfterNode);
      } else {
        // Nodes are inserted in reverse order - pushed down immediately after
        // the last node for the previous item or as the first node of element.
        for (i = nodeOrNodeArrayToInsert.length - 1; i >= 0; --i) {
          var child = nodeOrNodeArrayToInsert[i];
          if (!child) {
            break;
          }
          insertAfterAndInvokeAttached(containerNode, child, insertAfterNode);
        }
      }
      return nodeOrNodeArrayToInsert;
    };

    // checks if the deleted data item should be handled with delay for a possible reuse at additions
    OjForEach.prototype.shouldDelayDeletion = function (data) {
      return data && (typeof data === 'object' || typeof data === 'function');
    };

    // gets the pending deletion info for this data item
    OjForEach.prototype.getPendingDeleteFor = function (data) {
      var index = data && data[PENDING_DELETE_INDEX_KEY];
      if (index === undefined) return null;
      return this.pendingDeletes[index];
    };

    // tries to find the existing pending delete info for this data item, and if it can't, it registeres one
    OjForEach.prototype.getOrCreatePendingDeleteFor = function (data) {
      var pd = this.getPendingDeleteFor(data);
      if (pd) {
        return pd;
      }
      pd = {
        data: data,
        nodesets: []
      };
      // eslint-disable-next-line no-param-reassign
      data[PENDING_DELETE_INDEX_KEY] = this.pendingDeletes.length;
      this.pendingDeletes.push(pd);
      return pd;
    };

    // Process a changeItem with {status: 'deleted', ...}
    /**
     * @expose
     * @ignore
     */
    OjForEach.prototype.deleted = function (changeItem) {
      // if we should delay the deletion of this data, we add the nodeset to the pending delete info object
      if (this.shouldDelayDeletion(changeItem.value)) {
        var pd = this.getOrCreatePendingDeleteFor(changeItem.value);
        pd.nodesets.push(this.getNodesForIndex(changeItem.index));
        pd.currentChildContext = this.firstLastNodesList[changeItem.index].currentChildContext;
      } else {
        // simple data, just remove the nodes
        this.removeNodes(this.getNodesForIndex(changeItem.index));
      }
      this.indexesToDelete.push(changeItem.index);
    };

    // removes a set of nodes from the DOM
    OjForEach.prototype.removeNodes = function (nodes) {
      if (!nodes.length) {
        return;
      }

      var removeFn = () => {
        var parent = nodes[0].parentNode;
        for (var i = nodes.length - 1; i >= 0; --i) {
          templateEngine.clean(nodes[i], this.element);
          parent.removeChild(nodes[i]);
        }
      };

      removeFn();
    };

    // flushes the pending delete info store
    // this should be called after queue processing has finished, so that data items and remaining (not reused) nodesets get cleaned up
    OjForEach.prototype.flushPendingDeletes = function () {
      for (var i = 0, len = this.pendingDeletes.length; i !== len; ++i) {
        var pd = this.pendingDeletes[i];
        while (pd.nodesets.length) {
          this.removeNodes(pd.nodesets.pop());
        }
        if (pd.data && pd.data[PENDING_DELETE_INDEX_KEY] !== undefined) {
          delete pd.data[PENDING_DELETE_INDEX_KEY];
        }
      }
      this.pendingDeletes = [];
    };

    // We batch our deletion of item indexes in our parallel array.
    // See brianmhunt/knockout-fast-foreach#6/#8
    /**
     * @expose
     * @ignore
     */
    OjForEach.prototype.clearDeletedIndexes = function () {
      // We iterate in reverse on the presumption (following the unit tests) that KO's diff engine
      // processes diffs (esp. deletes) monotonically ascending i.e. from index 0 -> N.
      for (var i = this.indexesToDelete.length - 1; i >= 0; --i) {
        this.firstLastNodesList.splice(this.indexesToDelete[i], 1);
      }
      this.indexesToDelete = [];
    };

    // Updates observableIndex property for the data
    OjForEach.prototype.updateIndexes = function (fromIndex) {
      for (var i = fromIndex, len = this.firstLastNodesList.length; i < len; ++i) {
        var ctx = this.firstLastNodesList[i].currentChildContext;
        if (ctx && ctx.observableIndex) {
          ctx.observableIndex(i);
        }
      }
    };

    // Getter used in ko.computed callback that monitors array replacements
    OjForEach.prototype.getData = function () {
      return { data: this.data, dataProvider: this.currentDataProvider };
    };

    // Setter used in ko.computed callback that monitors array replacements
    OjForEach.prototype.setData = function (obj) {
      this.removeSubscriptions();
      this.data = obj.data;
      this.currentDataProvider = obj.dataProvider;
      this.addSubscriptions();
    };

    ko.bindingHandlers._ojBindForEach_ = {
      // Valid valueAccessors:
      //    {data: array, as: string}
      init: function init(element, valueAccessor, bindings, vm, context) {
        var ffe;
        var value;

        ko.computed(
          function () {
            // : watch for array modifications, that are not covered by addSubscriptions() call:
            // - non-observable array replacement triggered by CCA
            // - array data defined with expression
            value = valueAccessor();
            if (ffe) {
              var updatedValues = value.data;
              var currentValues = ffe.getData().data;
              var currentPrimeData;
              var updatedPrimeData;
              // retrive the array data that might be defined as an observable
              ko.ignoreDependencies(function () {
                currentPrimeData = ko.unwrap(currentValues);
                updatedPrimeData = ko.unwrap(updatedValues);
              });
              ffe.setData({
                data: updatedValues,
                dataProvider: updatedPrimeData.fetchFirst ? updatedPrimeData : null
              });
              if (Array.isArray(currentPrimeData) && Array.isArray(updatedPrimeData)) {
                // compare arrays and update rendered DOM
                // initialize options for ko.utils.compareArrays
                // 'dontLimitMoves':true recommended for newer code, 'sparse':true is used for trackArray changes
                var compareArrayOptions = { sparse: true, dontLimitMoves: true };
                var changeSet = ko.utils.compareArrays(
                  currentPrimeData,
                  updatedPrimeData,
                  compareArrayOptions
                );
                ffe.onArrayChange(changeSet);
              } else {
                // recreate content in all other cases
                ffe.recreateContent(updatedPrimeData);
              }
            }
          },
          null,
          { disposeWhenNodeIsRemoved: element }
        );

        ffe = new OjForEach(element, value, context);

        ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
          ffe.removeSubscriptions();
        });
        return { controlsDescendantBindings: true };
      }
    };

    ko.virtualElements.allowedBindings._ojBindForEach_ = true;
  })();

  oj$1._registerLegacyNamespaceProp('ResponsiveKnockoutUtils', ResponsiveKnockoutUtils);
  oj$1._registerLegacyNamespaceProp('KnockoutTemplateUtils', KnockoutTemplateUtils);

  /**
   * @ignore
   */
  (function () {
    BindingProviderImpl.addPostprocessor({
      nodeHasBindings: function (node, nodeHasBindings) {
        return nodeHasBindings || (node.nodeType === 1 && node.nodeName.toLowerCase() === 'oj-if');
      },
      getBindingAccessors: function (node, bindingContext, _wrappedReturn) {
        let wrappedReturn = _wrappedReturn;
        if (node.nodeType === 1 && node.localName === 'oj-if') {
          const testEvaluator = _getEvaluator(node, 'test', bindingContext);
          const nodesEvaluator = _getEvaluator(node, 'oj-private-do-not-use', bindingContext);
          wrappedReturn = wrappedReturn || {};
          wrappedReturn._ojBindIf_V2_ = () => {
            const nodes = nodesEvaluator ? ko.unwrap(nodesEvaluator(bindingContext)) : null;
            return nodes
              ? { test: ko.unwrap(testEvaluator(bindingContext)), nodes, ojDoNotUseProcessed: true }
              : ko.unwrap(testEvaluator(bindingContext));
          };
          wrappedReturn.style = () => {
            return { display: 'contents' };
          };
        }
        return wrappedReturn;
      }
    });

    function _getEvaluator(node, attr, bindingContext) {
      if (attr === 'test' && !node.hasAttribute(attr)) {
        throw new Error("Missing the required 'test' attribute on <oj-if>");
      } else if (!node.hasAttribute(attr)) {
        return null;
      }
      const attrValue = node.getAttribute(attr);
      const exprInfo = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrValue);
      return BindingProviderImpl.createEvaluator(
        exprInfo.expr ? exprInfo.expr : attrValue,
        bindingContext
      );
    }
  })();

  /**
   * @ojmodule ojknockout
   * @ojcomponent oj.ojIf
   * @ojshortdesc An oj-if renders its contents only if a provided test returns true.
   * @ojsignature {target: "Type", value: "class ojIf extends HTMLElement"}
   * @ojhtmlelement
   * @since 17.0.0
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["test"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-if'
   *
   * @classdesc
   * <h3 id="overview-section">
   *   JET If Element
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview-section"></a>
   * </h3>
   * <p>Use &lt;oj-if&gt; to conditionally render its contents only if a provided test
   * returns true. Unlike &lt;[oj-bind-if]{@link oj.ojBindIf}&gt; this element will not be removed from
   * the DOM after bindings are applied. The element stays in the DOM and can therefore directly be used
   * as the slot content of a custom element. The element has display:contents style
   * applied on it to make it transparent for any css styles that a parent container wants to
   * pass to its descendants.
   * </p>
   *
   * @example <caption>Initialize the oj-if:</caption>
   * &lt;oj-if test='[[myTest]]'>
   *   &lt;div>Conditional content: &lt;oj-bind-text value="[[myValue]]">&lt;/oj-bind-text>&lt;/div>
   * &lt;/oj-if>
   */

  /**
   * The test condition for the if clause. The children of the element will
   * only be rendered if the test is true.
   * @expose
   * @name test
   * @memberof oj.ojIf
   * @instance
   * @type {boolean}
   * @example <caption>Initialize the oj-if:</caption>
   * &lt;oj-if test='[[myTest]]'>
   *   &lt;div>Conditional content: &lt;oj-bind-text value="[[myValue]]">&lt;/oj-bind-text>&lt;/div>
   * &lt;/oj-if>
   */

  /**
   * <p>The <code class="prettyprint">oj-if</code> default slot is used to
   * specify content that will be rendered when the test condition evaluates to
   * true.
   *
   * @ojchild Default
   * @memberof oj.ojIf
   * @instance
   * @expose
   */

  /**
   * @ojmodule ojknockout
   * @ojcomponent oj.ojBindForEach
   * @ojshortdesc An oj-bind-for-each binds items of an array to the specified markup section. The markup section is duplicated for each array item when element is rendered.
   * @ojbindingelement
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
   * @ojtsimport knockout
   * @ojsignature {target: "Type",
   *               value: "class ojBindForEach<K, D> extends HTMLElement",
   *               genericParameters: [{"name": "K", "description": "Type of key when passing data via a DataProvider"},
   *                                   {"name": "D", "description": "Type of row data being iterated"}]}
   * @since 4.1.0
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["data"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-for-each'
   *
   * @classdesc
   * <h3 id="oj-for-each-overview-section">
   *   ForEach Binding
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#oj-for-each-overview-section"></a>
   * </h3>
   * <p>Use &lt;oj-bind-for-each&gt; to bind items of an array to the specified markup section.
   * The markup section is duplicated for each array item when element is rendered.
   * &lt;oj-bind-for-each&gt; requires the application to specify a single &lt;template&gt; element
   * as its direct child.  The markup being stamped out should be placed inside of this &lt;template&gt; element.
   * </p>
   * <p>Note that the &lt;oj-bind-for-each&gt; element will be removed from the DOM after binding is applied.
   * For slotting, applications need to wrap the oj-bind-for-each element inside another HTML element (e.g. &lt;span&gt;) with the slot attribute.
   * The oj-bind-for-each element does not support the slot attribute.</p>
   * <p>Also note that if you want to build an HTML table using &lt;oj-bind-for-each&gt; element the html content must be parsed
   * by <a href="HtmlUtils.html#.stringToNodeArray">HtmlUtils.stringToNodeArray()</a> method. Keep in mind that the composite
   * views and the oj-module views that are loaded via ModuleElementUtils are already using that method. Thus to create
   * a table you can either place the content into a view or call HtmlUtils.stringToNodeArray() explicitly to process the content.</p>
   *
   * @example <caption>Initialize the oj-bind-for-each - access data using <code>$current</code>:</caption>
   *  &lt;oj-bind-for-each data='[{"type":"Apple"},{"type":"Orange"}]'>
   *    &lt;template>
   *      &lt;p>&lt;oj-bind-text value='[[$current.data.type]]'>&lt;/oj-bind-text>&lt;/p>
   *    &lt;/template>
   *  &lt;/oj-bind-for-each>
   *
   * @example <caption>Initialize the oj-bind-for-each - access data using alias:</caption>
   *  &lt;oj-bind-for-each data="[[fruits]]">
   *    &lt;template data-oj-as="fruit">
   *      &lt;p>&lt;oj-bind-text value="[[fruit.data.type]]">&lt;/oj-bind-text>&lt;/p>
   *    &lt;/template>
   *  &lt;/oj-bind-for-each>
   */

  /**
   * The array or an DataProvider that you wish to iterate over. Required property.
   * Note that the &lt;oj-bind-for-each&gt; will dynamically update the generated
   * DOM in response to changes if the value is an observableArray, or in response
   * to DataProvider events.
   * @expose
   * @name data
   * @memberof oj.ojBindForEach
   * @ojshortdesc The array or DataProvider that you wish to iterate over. See  the Help documentation for more information.
   * @instance
   * @type {array|Object}
   * @ojsignature {target: "Type", value:"Array<D>|DataProvider<K, D>", jsdocOverride:true}
   */

  /**
   * An alias for the array item. This can be especially useful
   * if multiple oj-bind-for-each elements are nested to provide access to the data
   * for each level of iteration.
   * @expose
   * @name as
   * @memberof oj.ojBindForEach
   * @ojshortdesc An alias for the array item. This is useful if multiple oj-bind-for-each elements are nested to provide access to the data for each iteration level.
   * @instance
   * @type {string}
   * @ojtsignore
   * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
   */
  // default slot
  /**
   * <p>The <code class="prettyprint">oj-bind-for-each</code> default slot is used to specify the template for binding items of an array.
   * The slot content must be a &lt;template> element.</p>
   * <p>When the template is executed for each item, it will have access to the same binding context that is applied to the &lt;oj-bind-for-each&gt; element.
   * In addition the binding context will contain the following properties:</p>
   * <ul>
   *   <li>$current - An object that contains information for the current item. (See the table below for a list of properties available on $current) </li>
   *   <li>alias - If <b>as</b> attribute was specified, the value will be used to provide an application-named alias for <code>$current</code>.
   *               This can be especially useful if multiple oj-bind-for-each elements are nested to provide access to the data for each level of iteration.
   *   </li>
   * </ul>
   *
   * @ojchild Default
   * @ojmaxitems 1
   * @ojshortdesc The oj-bind-for-each default slot is used to specify the template for binding items of an array if no named slots were defined by the application.
   * @memberof oj.ojBindForEach
   * @ojtemplateslotprops oj.ojBindForEach.DefaultItemContext
   * @instance
   * @expose
   */

  /**
   * <p>The <code class="prettyprint">noData</code> slot is used to specify the content to display when the data is empty.
   * The slot content must be a &lt;template> element.  If the slot is not specified no content will be rendered.
   * The template slot will be executed with an empty context object.
   *
   * @ojslot noData
   * @ojshortdesc The noData slot is used to specify the content to render when the data is empty.
   * @ojmaxitems 1
   * @memberof oj.ojBindForEach
   * @ojtemplateslotprops {}
   * @ojlegacymetadata templateSlotAlias "noDataTemplate"
   *
   * @ojtsexample <caption>Initialize the oj-bind-for-each with a noData slot specified:</caption>
   * &lt;oj-bind-for-each>
   *   &lt;template>
   *    &lt;oj-bind-text value="[[$current.data.name]]">&lt;/oj-bind-text>
   *   &lt;/template>
   *   &lt;template slot='noData'>
   *     &lt;span>&lt;oj-button>Add item&lt;/span>
   *   &lt;/template>
   * &lt;/oj-bind-for-each>
   */

  /**
   * @typedef {Object} oj.ojBindForEach.DefaultItemContext
   * @property {Object} data The current array item being rendered.
   * @property {number} index Zero-based index of the current array item being rendered. The index value is not updated in response to array additions and removals and is only recommended for static arrays.
   * @property {number} observableIndex An observable that refers to the zero-based index of the current array item being rendered. The <code>observableIndex</code> value is updated in response to array additions and removals and can be used for both static and dynamic arrays.
   * @ojsignature [{for: "data", target: "Type", value: "D"},
   *               {for: "genericTypeParameters", target: "Type", value: "<D>"},
   *               {for: "observableIndex", target: "Type", value: "ko.Observable<number>"}]
   */

  /**
   * @ojmodule ojknockout
   * @ojcomponent oj.ojBindIf
   * @ojshortdesc An oj-bind-if renders its contents only if a provided test returns true.
   * @ojsignature {target: "Type", value: "class ojBindIf extends HTMLElement"}
   * @ojbindingelement
   * @since 4.1.0
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["test"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-if'
   *
   * @classdesc
   * <h3 id="overview-section">
   *   If Binding
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview-section"></a>
   * </h3>
   * <p>Use &lt;oj-bind-if&gt; to conditionally render its contents only if a provided test
   * returns true. Note that the &lt;oj-bind-if&gt; element will be removed from the DOM
   * after binding is applied.For slotting, applications need to wrap the oj-bind-if element
   * inside another HTML element (e.g. &lt;span&gt;) with the slot attribute. The oj-bind-if element does not support
   * the slot attribute. </p>
   *
   * <p>Consider using &lt;oj-if&gt; element if you want conditionally render
   * content of a slot or if you want the element to stay in the DOM. See &lt;[oj-if]{@link oj.ojIf}&gt; for more details.</p>
   *
   * @example <caption>Initialize the oj-bind-if:</caption>
   * &lt;oj-bind-if test='[[myTest]]'>
   *   &lt;div>My Contents&lt;/div>
   * &lt;/oj-bind-if>
   */

  /**
   * The test condition for the if clause. The children of the element will
   * only be rendered if the test is true.
   * @expose
   * @name test
   * @memberof oj.ojBindIf
   * @instance
   * @type {boolean}
   * @example <caption>Initialize the oj-bind-if:</caption>
   * &lt;oj-bind-if test='[[myTest]]'>
   *   &lt;div>My Contents&lt;/div>
   * &lt;/oj-bind-if>
   */

  /**
   * <p>The <code class="prettyprint">oj-bind-if</code> default slot is used to
   * specify content that will be rendered when the test condition evaluates to
   * true.
   *
   * @ojchild Default
   * @memberof oj.ojBindIf
   * @instance
   * @expose
   */

  /**
   * @ojmodule ojknockout
   * @ojcomponent oj.ojBindText
   * @ojshortdesc An oj-bind-text binds a text node to an expression.
   * @ojsignature {target: "Type", value: "class ojBindText extends HTMLElement"}
   * @ojbindingelement
   * @since 4.1.0
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["value"]}
   * @ojvbdefaultcolumns 2
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-select-text'
   *
   * @classdesc
   * <h3 id="overview-section">
   *   Text Binding
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview-section"></a>
   * </h3>
   * <p>Use &lt;oj-bind-text&gt; to generate a text node with the resolved expression. Note that the
   * &lt;oj-bind-text&gt; element will be removed from the DOM after binding is
   * applied, and any child elements it has will be removed. For slotting, applications
   * need to wrap the oj-bind-text element inside another HTML element (e.g. &lt;span&gt;) with the slot attribute.
   * The oj-bind-text element does not support the slot attribute.</p>
   *
   * <p>Note: Since the element sets its value using a text node, it is safe to set any string value
   * without risking HTML or script injection.</p>
   *
   * @example <caption>Initialize the oj-bind-text:</caption>
   * &lt;span>
   *   &lt;oj-bind-text value='[[myText]]'>&lt;/oj-bind-text>
   * &lt;/span>
   */

  /**
   * The value of the text node.
   * @expose
   * @name value
   * @memberof oj.ojBindText
   * @instance
   * @type {string}
   * @ojtranslatable
   * @example <caption>Initialize the oj-bind-text:</caption>
   * &lt;span>
   *   &lt;oj-bind-text value='[[myText]]'>&lt;/oj-bind-text>
   * &lt;/span>
   */

  /**
   *@license
   *Copyright(c)2014,2025,Oracleand/oritsaffiliates.
   *TheUniversalPermissiveLicense(UPL),Version1.0
   *asshownathttps://oss.oracle.com/licenses/upl/
   *@ignore
   */

  exports.ComponentBinding = ComponentBinding;
  exports.ComponentChangeTracker = ComponentChangeTracker;
  exports.__ExpressionUtils = __ExpressionUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojknockout',['ojs/ojknockout-base'], function (ojknockoutBase) { 'use strict';

	/**
	 *@license
	 *Copyright(c)2014,2025,Oracleand/oritsaffiliates.
	 *TheUniversalPermissiveLicense(UPL),Version1.0
	 *asshownathttps://oss.oracle.com/licenses/upl/
	 *@ignore
	 */

});


define('ojs/ojkeyset',['exports', 'ojs/ojcore-base', 'ojs/ojkeysetimpl'], function (exports, oj, KeySetImpl$1) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    KeySetImpl$1 = KeySetImpl$1 && Object.prototype.hasOwnProperty.call(KeySetImpl$1, 'default') ? KeySetImpl$1['default'] : KeySetImpl$1;

    /**
     * A set of unique keys that will not change once it's created.  It contains mutation methods that will create a copy of this set.
     * @export
     * @interface ImmutableKeySet
     * @classdesc A set of unique keys that will not change once it's created.  It contains mutation methods that will create a copy of this set.
     * @since 14.0.0
     * @ojsignature {target: "Type", value: "interface ImmutableKeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]}
     */

    /**
     * @typedef {Object} ImmutableKeySet.ImmutableSet An immutable Set of unique values.
     * @ojsignature [{target: "Type",
     *               value: "{ size: number; has(value: V): boolean; values(): IterableIterator<V>; }"},
     *              {target:"Type", value:"<V>", for: "genericTypeParameters"}]
     */

    /**
     * An object that contains either set of keys or set of deleted keys depending on whether or not this set represents all keys.
     *
     * @since 14.0.0
     * @export
     * @expose
     * @memberof ImmutableKeySet
     * @instance
     * @name keys
     * @readonly
     * @type {any}
     * @ojsignature {target: "Type",
     *               value: "{ all: true, keys?: never, deletedKeys: ImmutableKeySet.ImmutableSet<K>} | {all: false, keys: ImmutableKeySet.ImmutableSet<K>, deletedKeys?: never }"}
     */

    /**
     * Returns a new ImmutableKeySet based on this set with the specified keys included.
     *
     * @since 14.0.0
     * @param {Set|Array} keys a set of keys to add to this set.
     * @return {ImmutableKeySet} a new ImmutableKeySet with the specified keys included, or the same instance if nothing was added.
     * @method
     * @name add
     * @memberof ImmutableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ImmutableKeySet<K>"}
     */

    /**
     * Returns a new ImmutableKeySet that represents all keys are included in this set.
     *
     * @since 14.0.0
     * @return {ImmutableKeySet} a new ImmutableKeySet that represents all keys are included in this set, or the same instance if this
     *                           set already include all keys.
     * @method
     * @name addAll
     * @memberof ImmutableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "(): ImmutableKeySet<K>"}
     */

    /**
     * Returns a new ImmutableKeySet based on this set with the specified keys excluded.
     *
     * @since 14.0.0
     * @param {Set|Array} keys a set of keys to remove from this set.
     * @return {KeySet} a new ImmutableKeySet with the specified keys excluded.
     * @method
     * @name delete
     * @memberof ImmutableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ImmutableKeySet<K>"}
     */

    /**
     * Returns whether this set should include all keys.
     *
     * @since 14.0.0
     * @return {boolean} true if this set should include all keys, false otherwise.
     * @method
     * @name isAddAll
     * @memberof ImmutableKeySet
     * @instance
     */

    /**
     * Returns whether the specified key is contained in this set.
     *
     * @since 14.0.0
     * @param {any} key the key to check whether it is contained in this set.
     * @return {boolean} true if the specified key is contained in this set, false otherwise.
     * @method
     * @name has
     * @memberof ImmutableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "K", for: "key"}
     */

    /**
     * Returns a new ImmutableKeySet containing no keys, or the same instance if this set is already empty.
     *
     * @since 14.0.0
     * @return {ImmutableKeySet} a new ImmutableKeySet with no keys.
     * @method
     * @name clear
     * @memberof ImmutableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "(): KeySet<K>"}
     */

    /**
     * The base class for KeySetImpl and AllKeySetImpl.  Represents an immutable set of keys.
     * @class KeySet
     * @export
     * @expose
     * @classdesc The base class for KeySetImpl and AllKeySetImpl.  Represents an immutable set of keys.
     * @constructor
     * @hideconstructor
     * @abstract
     * @since 4.1.0
     * @ojsignature {target: "Type", value: "abstract class KeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]}
     */

    /**
     * Returns a new KeySet based on this set with the specified keys included.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {KeySet} a new KeySet with the specified keys included.
     * @method
     * @name add
     * @memberof KeySet
     * @instance
     * @abstract
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySet<K>"}
     */

    /**
     * Returns a new KeySet that signals all keys are added to this set.
     *
     * @return {KeySet} a new KeySet that signals all keys are added to this set.
     * @method
     * @name addAll
     * @memberof KeySet
     * @instance
     * @abstract
     * @ojsignature {target: "Type", value: "(): KeySet<K>"}
     */

    /**
     * Returns a new KeySet based on this set with the specified keys excluded.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {KeySet} a new KeySet with the specified keys excluded.
     * @method
     * @name delete
     * @memberof KeySet
     * @instance
     * @abstract
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySet<K>"}
     */

    /**
     * Returns whether this set should include all keys.
     *
     * @return {boolean} true if this set should include all keys, false otherwise.
     * @method
     * @name isAddAll
     * @memberof KeySet
     * @instance
     * @abstract
     */

    /**
     * Returns whether the specified key is contained in this set.
     *
     * @param {any} key the key to check whether it is contained in this set.
     * @return {boolean} true if the specified key is contained in this set, false otherwise.
     * @method
     * @name has
     * @memberof KeySet
     * @instance
     * @abstract
     * @ojsignature {target: "Type", value: "K", for: "key"}
     */

    /**
     * Returns a new KeySet containing no keys.
     *
     * @return {KeySet} a new KeySet with no keys.
     * @method
     * @name clear
     * @memberof KeySet
     * @instance
     * @abstract
     * @ojsignature {target: "Type", value: "(): KeySet<K>"}
     */

    // end of jsdoc

    /**
     * Create a new immutable KeySet containing the keys of items.
     * Use this KeySet when specifying individual keys to select or expand.
     *
     * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
     *
     * @class KeySetImpl
     * @classdesc The KeySetImpl class contains a set of keys of items.
     * @extends {KeySet}
     * @implements {ImmutableKeySet}
     * @final
     * @since 7.0.0
     * @ojsignature [{target: "Type", value: "class KeySetImpl<K> extends KeySet<K> implements ImmutableKeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]},
     *               {target: "Type", value: "Set<K>|Array<K>", for:"keys"}]
     * @example <caption>Creates a new KeySetImpl with an initial set of keys:</caption>
     * require(['ojs/ojkeyset'],
     *   function(keySet) {
     *     var KeySetImpl = new keySet.KeySetImpl(['item1', 'item3']);
     *   }
     * );
     */

    /**
     * An object that contains set of keys that are included in this set.
     *
     * @since 14.0.0
     * @export
     * @expose
     * @memberof KeySetImpl
     * @instance
     * @name keys
     * @readonly
     * @type {any}
     * @ojsignature {target: "Type",
     *               value: "{ all: true, keys?: never, deletedKeys: ImmutableKeySet.ImmutableSet<K>} | {all: false, keys: ImmutableKeySet.ImmutableSet<K>, deletedKeys?: never }"}
     */

    /**
     * Returns a new KeySet based on this set with the specified keys included.
     * When a key is added to this KeySet it implies the key will become expanded (when this
     * is used for expansion) or selected (when this is used for selection).
     * If none of the keys specified are being added, then it will be a no-op and this KeySet is
     * returned.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {KeySetImpl} a new KeySet with the specified keys included.
     * @export
     * @expose
     * @instance
     * @method
     * @name add
     * @memberof KeySetImpl
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySetImpl<K>"}
     */

    /**
     * Returns a new KeySet that represents a set with all keys.  This will return a
     * AllKeySetImpl instance.
     *
     * @return {AllKeySetImpl} a new KeySet that represents a set with all keys.
     * @export
     * @expose
     * @instance
     * @method
     * @name addAll
     * @memberof KeySetImpl
     * @ojsignature {target: "Type", value: "(): AllKeySetImpl<K>"}
     */

    /**
     * Determines whether this is a set that represents all keys.  Since this KeySet
     * does not represent all keys, thie method will always return false.
     *
     * @return {boolean} true if this is a set that reprsents all keys, false otherwise.
     * @export
     * @expose
     * @instance
     * @method
     * @name isAddAll
     * @memberof KeySetImpl
     */

    /**
     * Returns a new KeySet based on this set with the specified keys excluded.
     * When a key is removed from this KeySet it implies the key will become collapsed (when this
     * is used for expansion) or de-selected (when this is used for selection).
     * If none of the keys specified are being deleted, then this KeySet is returned.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {KeySetImpl} a new KeySet with the specified keys excluded.
     * @export
     * @expose
     * @instance
     * @method
     * @name delete
     * @memberof KeySetImpl
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySetImpl<K>"}
     */

    /**
     * Returns a new KeySet containing no keys.  Specifically, invoking clear will collapse all keys (
     * when this is used for expansion) or clear selection (when this is used for selection).
     * If this KeySet already contains no keys then it is a no-op and the current KeySet is returned.
     *
     * @return {KeySetImpl} a new KeySet with no keys.
     * @export
     * @expose
     * @instance
     * @method
     * @name clear
     * @memberof KeySetImpl
     * @ojsignature {target: "Type", value: "(): KeySetImpl<K>"}
     */

    /**
     * Determines whether the specified key is in this set.
     * Specifically, this returns true if the key is expanded (when this is used for expansion)
     * or selected (when this is used for selection), and false otherwise.
     *
     * @param {any} key the key to check whether it is in this set.
     * @return {boolean} true if the specified key is in the set, false otherwise.
     * @export
     * @expose
     * @instance
     * @method
     * @name has
     * @memberof KeySetImpl
     * @ojsignature {target: "Type", value: "K", for:"key"}
     */

    /**
     * Returns the keys in this KeySet in the order they are added.
     * Specifically, this returns a set of keys that are expanded (when this is used for expansion)
     * or selected (when this is used for selection).
     *
     * @return {Set} the keys in this KeySet in the order they are added.
     * @export
     * @expose
     * @instance
     * @method
     * @name values
     * @memberof KeySetImpl
     * @ojsignature {target: "Type", value: "Set<K>", for:"returns"}
     */

    /**
     * Create a new immutable KeySet that represents a set with all keys.
     * Use this KeySet to select or expand all keys.
     *
     * @class AllKeySetImpl
     * @classdesc
     * The AllKeySetImpl class is a KeySet that represents a set with all keys.  This is used
     * for example, to select or expand all items in a component.
     * <p>
     * Note AllKeySetImpl does not actually hold nor have method to return all the keys.  Rather,
     * it provides an efficient way to let the component know that it should, for example, select
     * or expand all items without actually having all the keys present in the set.
     * <p>
     * If the application do require access to the set of all the keys, it should get them directly
     * from the associated <a href="DataProvider.html">DataProvider</a>, or other efficient ways
     * that are specific to the application.
     * @extends {KeySet}
     * @implements {ImmutableKeySet}
     * @final
     * @since 7.0.0
     * @ojsignature {target: "Type", value: "class AllKeySetImpl<K> extends KeySet<K> implements ImmutableKeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]}
     * @example <caption>Creates a new AllKeySetImpl to select all keys</caption>
     * require(['ojs/ojkeyset'],
     *   function(keySet) {
     *     var AllKeySetImpl = new keySet.AllKeySetImpl();
     *   }
     * );
     */

    /**
     * An object that contains set of deleted keys that are excluded from this set.
     *
     * @since 14.0.0
     * @export
     * @expose
     * @memberof AllKeySetImpl
     * @instance
     * @name keys
     * @readonly
     * @type {any}
     * @ojsignature {target: "Type",
     *               value: "{ all: true, keys?: never, deletedKeys: ImmutableKeySet.ImmutableSet<K>} | {all: false, keys: ImmutableKeySet.ImmutableSet<K>, deletedKeys?: never }"}
     */

    /**
     * Returns a new KeySet with the specified keys included in the set.
     * When a key is added to this KeySet it implies the key will become expanded (when this
     * is used for expansion) or selected (when this is used for selection).
     * If the keys specified have not been explicitly deleted from this KeySet before then
     * this will be a no-op as this KeySet by default includes all keys.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {AllKeySetImpl} a new KeySet with the specified keys included.
     * @export
     * @expose
     * @instance
     * @method
     * @name add
     * @memberof! AllKeySetImpl
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): AllKeySetImpl<K>"}
     */

    /**
     * Returns a new KeySet that represents a set with all keys.  If this KeySet already is
     * a set with all keys and no keys have been explicitly removed from this KeySet before,
     * then this will be a no-op and it would just return itself.
     * Invoking addAll will cause all keys to be expanded (when this is used for
     * expansion) or selected (when this is used for selection).
     *
     * @return {AllKeySetImpl} a new KeySet that represents a set with all keys.
     * @expose
     * @export
     * @instance
     * @method
     * @name addAll
     * @memberof! AllKeySetImpl
     * @ojsignature {target: "Type", value: "(): AllKeySetImpl<K>"}
     */

    /**
     * Determines whether this is a set that represents all keys.  Since this KeySet represents
     * all keys, this method will always return true.
     *
     * @return {boolean} true if this is a set that reprsents all keys, false otherwise.
     * @expose
     * @export
     * @instance
     * @method
     * @name isAddAll
     * @memberof! AllKeySetImpl
     */

    /**
     * Returns a new KeySet based on this set with the specified keys deleted.  In the case of
     * AllKeySetImpl this represents the keys to exclude from all keys.
     * When a key is removed from this KeySet it implies the key will become collapsed (when this
     * is used for expansion) or de-selected (when this is used for selection).
     * If the keys specified are already deleted then it will be a no-op and this KeySet is returned.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {AllKeySetImpl} a new KeySet with the specified keys excluded.
     * @expose
     * @export
     * @instance
     * @method
     * @name delete
     * @memberof! AllKeySetImpl
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): AllKeySetImpl<K>"}
     */

    /**
     * Returns a new KeySet containing no keys.  Specifically, invoking clear will collapse all keys (
     * when this is used for expansion) or clear selection (when this is used for selection).
     *
     * @return {KeySetImpl} a new KeySet with no keys.
     * @expose
     * @export
     * @instance
     * @method
     * @name clear
     * @memberof! AllKeySetImpl
     * @ojsignature {target: "Type", value: "(): KeySetImpl<K>"}
     */

    /**
     * Determines whether the specified key is in this set.
     * Specifically, this returns true if the key is expanded (when this is used for expansion)
     * or selected (when this is used for selection), and false otherwise.
     *
     * @param {any} key the key to check whether it is in this set.
     * @return {boolean} true if the specified key is in this set, false otherwise.
     * @expose
     * @export
     * @instance
     * @method
     * @name has
     * @memberof! AllKeySetImpl
     * @ojsignature {target: "Type", value: "K", for: "key"}
     */

    /**
     * Returns a set of keys of the items that are excluded from this set.
     * Specifically, this returns a set of keys that are collapsed (when this is used for expansion)
     * or de-selected (when this is used for selection).
     *
     * @return {Set} the keys of the deleted items.
     * @expose
     * @export
     * @instance
     * @method
     * @name deletedValues
     * @memberof! AllKeySetImpl
     * @ojsignature {target: "Type", value: "Set<K>", for: "returns"}
     */

    // end of jsdoc

    class KeySet {
    }
    oj._registerLegacyNamespaceProp('KeySet', KeySet);

    class KeySetImpl extends KeySet {
        constructor(keys) {
            super();
            this.keys = {
                all: false,
                keys: undefined
            };
            this.keys.keys = new Set(keys);
        }
        has(key) {
            return _has(this.keys.keys, key);
        }
        add(keys) {
            const set = new Set(this.keys.keys.values());
            keys.forEach((key) => {
                if (!_has(set, key)) {
                    set.add(key);
                }
            });
            if (set.size === this.keys.keys.size) {
                return this;
            }
            return new KeySetImpl(set);
        }
        delete(keys) {
            const set = new Set(this.keys.keys.values());
            keys.forEach((key) => {
                const ret = _find(set, key);
                if (ret.value) {
                    set.delete(ret.key);
                }
            });
            if (set.size === this.keys.keys.size) {
                return this;
            }
            return new KeySetImpl(set);
        }
        addAll() {
            return new AllKeySetImpl([]);
        }
        clear() {
            if (this.keys.keys.size === 0) {
                return this;
            }
            return new KeySetImpl([]);
        }
        isAddAll() {
            return false;
        }
        values() {
            return new Set(this.keys.keys.values());
        }
    }
    class AllKeySetImpl extends KeySet {
        constructor(keys) {
            super();
            this.keys = {
                all: true,
                deletedKeys: undefined
            };
            this.keys.deletedKeys = new Set(keys);
        }
        has(key) {
            return !_has(this.keys.deletedKeys, key);
        }
        add(keys) {
            const set = new Set(this.keys.deletedKeys.values());
            keys.forEach((key) => {
                const ret = _find(set, key);
                if (ret.value) {
                    set.delete(ret.key);
                }
            });
            if (set.size === this.keys.deletedKeys.size) {
                return this;
            }
            return new AllKeySetImpl(set);
        }
        delete(keys) {
            const set = new Set(this.keys.deletedKeys.values());
            keys.forEach((key) => {
                if (!_has(set, key)) {
                    set.add(key);
                }
            });
            if (set.size === this.keys.deletedKeys.size) {
                return this;
            }
            return new AllKeySetImpl(set);
        }
        addAll() {
            if (this.keys.deletedKeys.size === 0) {
                return this;
            }
            return new AllKeySetImpl([]);
        }
        clear() {
            return new KeySetImpl([]);
        }
        isAddAll() {
            return true;
        }
        deletedValues() {
            return new Set(this.keys.deletedKeys.values());
        }
    }
    const _has = (keys, keyToFind) => {
        return _find(keys, keyToFind).value;
    };
    const _find = (keys, keyToFind) => {
        if (keys.size === 0) {
            return { value: false };
        }
        if (typeof keyToFind === 'string' ||
            typeof keyToFind === 'number' ||
            typeof keyToFind === 'boolean') {
            return { value: keys.has(keyToFind), key: keyToFind };
        }
        const iterator = keys[Symbol.iterator]();
        let key = iterator.next();
        while (!key.done) {
            if (oj.KeyUtils.equals(key.value, keyToFind)) {
                return { value: true, key: key.value };
            }
            key = iterator.next();
        }
        return { value: false };
    };
    oj._registerLegacyNamespaceProp('KeySetImpl', KeySetImpl);
    oj._registerLegacyNamespaceProp('AllKeySetImpl', AllKeySetImpl);

    var KeySet$1 = function () {};
    // Subclass from oj.Object
    oj.Object.createSubclass(KeySet$1, oj.Object, 'KeySet');

    /**
     * Sets the internal Set object.
     *
     * @param {Set} set the internal Set object to replace with.
     * @protected
     */
    KeySet$1.prototype.SetInternal = function (set) {
      this._keys = set;
    };

    /**
     * Adds or deletes a set of keys from the internal Set object.
     * @param {boolean} isAdd true if add operation, false if delete operation
     * @param {Set|Array} keys keys to add or delete
     * @return {KeySet} returns current KeySet if add or delete is not performed, or a new KeySet with the
     *                     specified keys included (add) or excluded (delete).
     * @protected
     */
    KeySet$1.prototype.AddOrDeleteInternal = function (isAdd, keys) {
      var newSet;
      var keySet;

      newSet = isAdd ? this._add(keys) : this._remove(keys);
      if (newSet == null) {
        return this;
      }

      keySet = /** @type {KeySet} */ (Object.create(Object.getPrototypeOf(this)));
      keySet.SetInternal(newSet);
      return keySet;
    };

    /**
     * Adds the specified keys to the internal Set object.
     * @param {Set|Array} keys a set of keys to add
     * @return {Set} a new Set based on this internal Set with the specified keys appended to the end, or null if nothing was added.
     * @private
     */
    KeySet$1.prototype._add = function (keys) {
      var self = this;
      var newSet = null;

      keys.forEach(function (key) {
        // checks if it's already contained in the Set, can't use has() since it does a reference comparison
        if (key !== self.NOT_A_KEY && self.get(key) === self.NOT_A_KEY) {
          if (newSet == null) {
            newSet = self.Clone();
          }
          newSet.add(key);
        }
      });

      return newSet;
    };

    /**
     * Helper method to remove the specified keys from its set
     * @param {Set|Array} keys an interable set of keys to remove
     * @return {Set|null} a new Set based on this internal Set with the keys removed, or null if nothing is removed.
     * @private
     */
    KeySet$1.prototype._remove = function (keys) {
      var self = this;
      var newSet = null;
      var keyToDelete;

      // first check if there's anything to remove
      if (this._keys.size === 0) {
        return null;
      }

      keys.forEach(function (key) {
        // see if we can find a equivalent key in this Set since delete does a reference comparison to find the item to delete
        keyToDelete = self.get(key);
        if (keyToDelete !== self.NOT_A_KEY) {
          if (newSet == null) {
            newSet = self.Clone();
          }
          newSet.delete(keyToDelete);
        }
      });

      return newSet;
    };

    /**
     * Returns the size of this Set.
     * @return {number} the size of this Set.
     * @protected
     */
    KeySet$1.prototype.GetInternalSize = function () {
      return this._keys.size;
    };

    /**
     * Return a clone of the internal Set
     * @return {Set} the clone of the internal Set
     * @protected
     */
    KeySet$1.prototype.Clone = function () {
      return new Set(this._keys);
    };

    KeySetImpl$1.call(KeySet$1.prototype);

    /**
     * Create a new immutable KeySet containing the keys of the expanded items.
     * Use this KeySet when specifying individual keys to expand.
     *
     * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
     *
     * @class ExpandedKeySet
     * @classdesc The ExpandedKeySet class contains a set of keys of the expanded items.  See
     * also the <a href="ObservableExpandedKeySet.html">observable</a> version of this class.
     * @extends {KeySet}
     * @constructor
     * @final
     * @since 4.1.0
     * @ojdeprecated {since: '7.0.0', value:['KeySetImpl']}
     * @ojsignature [{target: "Type", value: "class ExpandedKeySet<K> extends KeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]},
     *               {target: "Type", value: "Set<K>|Array<K>", for:"keys"}]
     * @example <caption>Creates a new ExpandedKeySet with an initial set of keys to expand:</caption>
     * require(['ojs/ojkeyset'],
     *   function(keySet) {
     *     var expandedKeySet = new keySet.ExpandedKeySet(['group1', 'group3']);
     *   }
     * );
     */
    var ExpandedKeySet = function (keys) {
      this.InitializeWithKeys(keys);
    };
    oj._registerLegacyNamespaceProp('ExpandedKeySet', ExpandedKeySet);
    // Subclass from KeySet
    oj.Object.createSubclass(ExpandedKeySet, KeySet$1, 'ExpandedKeySet');

    /**
     * Returns a new KeySet based on this set with the specified keys included.
     * If none of the keys specified are added then this KeySet is returned.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {ExpandedKeySet} a new KeySet with the specified keys included.
     * @expose
     * @instance
     * @alias add
     * @memberof ExpandedKeySet
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandedKeySet<K>"}
     */
    ExpandedKeySet.prototype.add = function (keys) {
      return /** @type {!ExpandedKeySet} */ (this.AddOrDeleteInternal(true, keys));
    };

    /**
     * Returns a new KeySet that signals all keys are added to this set.
     *
     * @return {ExpandAllKeySet} a new KeySet that signals all keys are added to this set.
     * @expose
     * @instance
     * @alias addAll
     * @memberof ExpandedKeySet
     * @ojsignature {target: "Type", value: "(): ExpandAllKeySet<K>"}
     */
    ExpandedKeySet.prototype.addAll = function () {
      // eslint-disable-next-line no-use-before-define
      return new ExpandAllKeySet();
    };

    /**
     * Returns whether this set should include all keys.
     *
     * @return {boolean} true if this set includes all keys, false otherwise.
     * @expose
     * @instance
     * @alias isAddAll
     * @memberof ExpandedKeySet
     */
    ExpandedKeySet.prototype.isAddAll = function () {
      return false;
    };

    /**
     * Returns a new KeySet based on this set with the specified keys excluded.
     * If none of the keys specified are deleted then this KeySet is returned.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {ExpandedKeySet} a new KeySet with the specified keys excluded.
     * @expose
     * @instance
     * @alias delete
     * @memberof ExpandedKeySet
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandedKeySet<K>"}
     */
    ExpandedKeySet.prototype.delete = function (keys) {
      return /** @type {!ExpandedKeySet} */ (this.AddOrDeleteInternal(false, keys));
    };

    /**
     * Returns a new KeySet containing no keys.  If this KeySet already contains no keys then
     * the current KeySet is returned.
     *
     * @return {ExpandedKeySet} a new KeySet with no keys.
     * @expose
     * @instance
     * @alias clear
     * @memberof ExpandedKeySet
     * @ojsignature {target: "Type", value: "(): ExpandedKeySet<K>"}
     */
    ExpandedKeySet.prototype.clear = function () {
      return this.GetInternalSize() === 0 ? this : new ExpandedKeySet();
    };

    /**
     * Returns whether the specified key is contained in this set.
     *
     * @param {any} key the key to check whether it is contained in this set.
     * @return {boolean} true if the specified key is contained in this set, false otherwise.
     * @expose
     * @instance
     * @alias has
     * @memberof ExpandedKeySet
     * @ojsignature {target: "Type", value: "K", for:"key"}
     */
    ExpandedKeySet.prototype.has = function (key) {
      return this.get(key) !== this.NOT_A_KEY;
    };

    /**
     * Returns the keys in this KeySet in the order they are added.
     *
     * @return {Set} the keys in this KeySet in the order they are added.
     * @expose
     * @instance
     * @alias values
     * @memberof ExpandedKeySet
     * @ojsignature {target: "Type", value: "Set<K>", for:"returns"}
     */
    ExpandedKeySet.prototype.values = function () {
      return this.Clone();
    };

    /**
     * Create a new immutable KeySet containing the keys of the collapsed items.
     * Use this KeySet when expanding all keys.
     *
     *
     * @class ExpandAllKeySet
     * @classdesc The ExpandAllKeySet class represents a set with all keys expanded.
     * @extends {KeySet}
     * @constructor
     * @final
     * @since 4.1.0
     * @ojdeprecated {since: '7.0.0', value:['AllKeySetImpl']}
     * @ojsignature {target: "Type", value: "class ExpandAllKeySet<K> extends KeySet<K>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
     * @example <caption>Creates a new ExpandAllKeySet to expand all keys</caption>
     * require(['ojs/ojkeyset'],
     *   function(keySet) {
     *     var expandAllKeySet = new keySet.ExpandAllKeySet();
     *   }
     * );
     */
    var ExpandAllKeySet = function () {
      this.InitializeWithKeys(null);
    };
    oj._registerLegacyNamespaceProp('ExpandAllKeySet', ExpandAllKeySet);
    // Subclass from KeySet
    oj.Object.createSubclass(ExpandAllKeySet, KeySet$1, 'ExpandAllKeySet');

    /**
     * Returns a new KeySet with the specified keys excluded from a set of collapsed keys.
     * If the keys specified are already added then this KeySet is returned.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {ExpandAllKeySet} a new KeySet with the specified keys included.
     * @expose
     * @instance
     * @alias add
     * @memberof! ExpandAllKeySet
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandAllKeySet<K>"}
     */
    ExpandAllKeySet.prototype.add = function (keys) {
      // add keys on expand all = remove collapsed keys
      return /** @type {!ExpandAllKeySet} */ (this.AddOrDeleteInternal(false, keys));
    };

    /**
     * Returns a new KeySet that signals all keys are added to this set.  If this KeySet already
     * has all keys added, then this KeySet is returned.
     *
     * @return {ExpandAllKeySet} a new KeySet that signals all keys are added to this set.
     * @expose
     * @instance
     * @alias addAll
     * @memberof! ExpandAllKeySet
     * @ojsignature {target: "Type", value: "(): ExpandAllKeySet<K>"}
     */
    ExpandAllKeySet.prototype.addAll = function () {
      return this.GetInternalSize() === 0 ? this : new ExpandAllKeySet();
    };

    /**
     * Returns whether this set should include all keys.
     *
     * @return {boolean} true if this set includes all keys, false otherwise.
     * @expose
     * @instance
     * @alias isAddAll
     * @memberof! ExpandAllKeySet
     */
    ExpandAllKeySet.prototype.isAddAll = function () {
      return true;
    };

    /**
     * Returns a new KeySet based on this set with the specified keys included in a set of collapsed keys.
     * If the keys specified are already deleted then this KeySet is returned.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {ExpandAllKeySet} a new KeySet with the specified keys excluded.
     * @expose
     * @instance
     * @alias delete
     * @memberof! ExpandAllKeySet
     * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandAllKeySet<K>"}
     */
    ExpandAllKeySet.prototype.delete = function (keys) {
      // remove keys on expand all = add collapsed keys
      return /** @type {!ExpandAllKeySet} */ (this.AddOrDeleteInternal(true, keys));
    };

    /**
     * Returns a new KeySet containing no keys.
     *
     * @return {ExpandedKeySet} a new KeySet with no keys.
     * @expose
     * @instance
     * @alias clear
     * @memberof! ExpandAllKeySet
     * @ojsignature {target: "Type", value: "(): ExpandedKeySet<K>"}
     */
    ExpandAllKeySet.prototype.clear = function () {
      return new ExpandedKeySet();
    };

    /**
     * Returns whether the specified key is contained in this set.
     *
     * @param {any} key the key to check whether it is contained in this set.
     * @return {boolean} true if the specified key is contained in this set, false otherwise.
     * @expose
     * @instance
     * @alias has
     * @memberof! ExpandAllKeySet
     * @ojsignature {target: "Type", value: "K", for: "key"}
     */
    ExpandAllKeySet.prototype.has = function (key) {
      return this.get(key) === this.NOT_A_KEY;
    };

    /**
     * Returns a set of keys of the collapsed items.
     *
     * @return {Set} the keys of the collapsed items.
     * @expose
     * @instance
     * @alias deletedValues
     * @memberof! ExpandAllKeySet
     * @ojsignature {target: "Type", value: "Set<K>", for: "returns"}
     */
    ExpandAllKeySet.prototype.deletedValues = function () {
      return this.Clone();
    };

    /**
     * Contains a set of utility methods for working with KeySet.
     * @class
     * @ignore
     * @tsignore
     */
    var KeySetUtils = {};
    /**
     * Converts a KeySet into an array
     */
    KeySetUtils.toArray = function (keyset) {
      var arr;

      var set = keyset.isAddAll() ? keyset.deletedValues() : keyset.values();
      if (Array.from) {
        arr = Array.from(set);
      } else {
        // IE11 does not support Array.from
        arr = [];
        set.forEach(function (value) {
          arr.push(value);
        });
      }
      arr.inverted = keyset.isAddAll();
      return arr;
    };

    /**
     * Converts an array into a KeySet
     */
    KeySetUtils.toKeySet = function (arr) {
      var keyset = null;
      if (arr.inverted) {
        keyset = new AllKeySetImpl();
        keyset = keyset.delete(arr);
      } else {
        keyset = new KeySetImpl();
        keyset = keyset.add(arr);
      }
      return keyset;
    };

    exports.AllKeySetImpl = AllKeySetImpl;
    exports.ExpandAllKeySet = ExpandAllKeySet;
    exports.ExpandedKeySet = ExpandedKeySet;
    exports.KeySet = KeySet;
    exports.KeySetImpl = KeySetImpl;
    exports.KeySetUtils = KeySetUtils;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojknockout-keyset',['exports', 'knockout', 'ojs/ojkeyset'], function (exports, ko, ojkeyset) { 'use strict';

    class ObservableExpandedKeySet {
        constructor(initialValue) {
            this._proto = Object.create(ko.observable.fn);
            // by default if initialValue wasn't specified then we create a ExpandedKeySet
            const _initialValue = initialValue || new ojkeyset.ExpandedKeySet();
            const _result = ko.observable(_initialValue);
            const self = this;
            // mutation functions (needed to leave as function calls for arguments scope correctly)
            ko.utils.arrayForEach(['add', 'addAll', 'clear', 'delete'], function (methodName) {
                self._proto[methodName] = function () {
                    // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
                    // (for consistency with mutating regular observables)
                    const underlyingKeySet = this.peek();
                    const methodCallResult = underlyingKeySet[methodName].apply(underlyingKeySet, arguments);
                    // this should call valueWillMutate, update latestValue, valueHasMutate
                    this(methodCallResult);
                    // the mutation methods always return a new KeySet so we should return the ObservableExpandedKeySet itself
                    return this;
                };
            });
            Object.setPrototypeOf(_result, this._proto);
            return _result;
        }
    }

    /**
     * Create an observable version of a KeySet.
     *
     * @export
     * @param {(ExpandedKeySet|ExpandAllKeySet)=} initialValue The KeySet to observe.
     * @class ObservableExpandedKeySet
     * @classdesc Observable implementation of ExpandedKeySet that keeps track of mutation of KeySet.
     * Since KeySet is immutable, all mutation methods return a new KeySet,
     * and therefore applications must update the associated attribute with the new KeySet.  The ObservableExpandedKeySet
     * provides a convenient way for applications to mutate the KeySet directly without the need to update the associated
     * attribute.
     * @ojdeprecated {since: '7.0.0', value:['ObservableKeySet']}
     * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["ExpandedKeySet", "ExpandAllKeySet", "KeySetImpl", "AllKeySetImpl"]}
     * @ojsignature [{target: "Type", value: "class ObservableExpandedKeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]},
     *               {target: "Type", value: "ExpandedKeySet<K>|ExpandAllKeySet<K>", for:"initialValue"}]
     */

    /**
     * Updates the observable with a KeySet that includes the specified keys.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {ObservableExpandedKeySet} this observable KeySet.
     * @method
     * @name add
     * @memberof ObservableExpandedKeySet
     * @instance
     * @ojsignature [{target: "Type", value: "Set<K>|Array<K>", for:"keys"},
     *               {target: "Type", value: "ObservableExpandedKeySet<K>", for: "returns"}]
     */

    /**
     * Updates the observable with a KeySet that has all keys.
     *
     * @return {ObservableExpandedKeySet} this observable KeySet.
     * @method
     * @name addAll
     * @memberof ObservableExpandedKeySet
     * @instance
     * @ojsignature {target: "Type", value: "ObservableExpandedKeySet<K>", for: "returns"}
     */

    /**
     * Updates the observable with a KeySet that contains no keys.
     *
     * @return {ObservableExpandedKeySet} this observable KeySet.
     * @method
     * @name clear
     * @memberof ObservableExpandedKeySet
     * @instance
     * @ojsignature {target: "Type", value: "ObservableExpandedKeySet<K>", for: "returns"}
     */

    /**
     * Updates the observable with a KeySet that excludes the specified keys.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {ObservableExpandedKeySet} this observable KeySet.
     * @method
     * @name delete
     * @memberof ObservableExpandedKeySet
     * @instance
     * @ojsignature [{target: "Type", value: "Set<K>|Array<K>", for:"keys"},
     *               {target: "Type", value: "ObservableExpandedKeySet<K>", for: "returns"}]
     */

    class ObservableKeySet {
        constructor(initialValue) {
            this._proto = Object.create(ko.observable.fn);
            // by default if initialValue wasn't specified then we create a KeySetImpl
            const _initialValue = initialValue || new ojkeyset.KeySetImpl();
            const _result = ko.observable(_initialValue);
            const self = this;
            // mutation functions (needed to leave as function calls for arguments scope correctly)
            ko.utils.arrayForEach(['add', 'addAll', 'clear', 'delete'], function (methodName) {
                self._proto[methodName] = function () {
                    // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
                    // (for consistency with mutating regular observables)
                    const underlyingKeySet = this.peek();
                    const methodCallResult = underlyingKeySet[methodName].apply(underlyingKeySet, arguments);
                    // this should call valueWillMutate, update latestValue, valueHasMutate
                    this(methodCallResult);
                    // the mutation methods always return a new KeySet so we should return the ObservableKeySet itself
                    return this;
                };
            });
            Object.setPrototypeOf(_result, this._proto);
            return _result;
        }
    }

    /**
     * Creates an observable whose value is a KeySet.
     *
     * @export
     * @param {KeySet=} initialValue The KeySet to observe.
     * @class ObservableKeySet
     * @classdesc
     * Creates an <a href="https://knockoutjs.com/documentation/observables.html">observable</a> whose value is a <a href="KeySet.html">KeySet</a>.
     * <p>
     * Applications should use ObservableKeySet if they want to track or notify components to changes to a KeySet.
     * ObservableKeySet works just like an observable and it exposes a set of mutation methods that are similar to the
     * ones found in KeySet, which when invoked will update the underlying value in the observable with the updated KeySet.
     * This gives applications a convenient way to directly update KeySets which are designed to be immutable.
     * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["ExpandedKeySet", "ExpandAllKeySet", "KeySetImpl", "AllKeySetImpl"]}
     * @ojsignature [{target: "Type", value: "class ObservableKeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]},
     *               {target: "Type", value: "KeySetImpl<K>|AllKeySetImpl<K>", for:"initialValue"}]
     */
    /**
     * Equivalent to the <a href="KeySet.html#add">add</a> method on KeySet.  Calls add method on the underlying KeySet
     * and updates the observable with the returned KeySet.
     *
     * @param {Set|Array} keys a set of keys to add to this KeySet.
     * @return {ObservableKeySet} this observable KeySet.
     * @method
     * @name add
     * @memberof ObservableKeySet
     * @instance
     * @ojsignature [{target: "Type", value: "Set<K>|Array<K>", for:"keys"},
     *               {target: "Type", value: "ObservableKeySet<K>", for: "returns"}]
     */

    /**
     * Equivalent to the <a href="KeySet.html#addAll">addAll</a> method on KeySet.  Calls addAll method on the underlying KeySet
     * and updates the observable with the returned KeySet.
     *
     * @return {ObservableKeySet} this observable KeySet.
     * @method
     * @name addAll
     * @memberof ObservableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "ObservableKeySet<K>", for: "returns"}
     */

    /**
     * Equivalent to the <a href="KeySet.html#clear">clear</a> method on KeySet.  Calls clear method on the underlying KeySet
     * and updates the observable with the returned KeySet.
     *
     * @return {ObservableKeySet} this observable KeySet.
     * @method
     * @name clear
     * @memberof ObservableKeySet
     * @instance
     * @ojsignature {target: "Type", value: "ObservableKeySet<K>", for: "returns"}
     */

    /**
     * Equivalent to the <a href="KeySet.html#delete">delete</a> method on KeySet.  Calls delete method on the underlying KeySet
     * and updates the observable with the returned KeySet.
     *
     * @param {Set|Array} keys a set of keys to remove from this KeySet.
     * @return {ObservableKeySet} this observable KeySet.
     * @method
     * @name delete
     * @memberof ObservableKeySet
     * @instance
     * @ojsignature [{target: "Type", value: "Set<K>|Array<K>", for:"keys"},
     *               {target: "Type", value: "ObservableKeySet<K>", for: "returns"}]
     */

    exports.ObservableExpandedKeySet = ObservableExpandedKeySet;
    exports.ObservableKeySet = ObservableKeySet;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojknockout-validation',['ojs/ojcore', 'jquery', 'ojs/ojcontext', 'ojs/ojmessaging', 'ojs/ojknockout', 'knockout'], function (oj, $, Context, Message, ojknockout, ko) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  Message = Message && Object.prototype.hasOwnProperty.call(Message, 'default') ? Message['default'] : Message;

  /**
   * Tracks the validity of a group of components bound to this observable. It also provides
   * properties and methods that the page author can use to enforce form validation best practice.
   *
   * <p>
   * Validity of components that are disabled or readOnly will not be tracked by this object.</li>
   * </p>
   *
   * <p>
   * The <code class="prettyprint">invalidComponentTracker</code> binding attribute should be bound to
   * a ko observable, and 'ojs/ojknockout-validation' should be included in the dependency list.
   * At runtime the framework creates an instance of this type
   * <code class="prettyprint">oj.InvalidComponentTracker</code> and sets it on the bound observable.<br/>
   * This object can then be used by page authors to do the following -
   * <ul>
   * <li>determine if there are invalid components tracked by this object that are currently showing
   * errors.</li>
   * <li>determine if there are invalid components tracked by this object that are currently deferring
   * showing errors.</li>
   * <li>set focus on the first invalid component in the tracked group</li>
   * <li>show all messages on all tracked components including deferred error messages, and set focus
   * on the first invalid component.</li>
   * </ul>
   * </p>
   *
   * @example <caption> Bind an observable to the <code class="prettyprint">invalidComponentTracker</code> and access oj.InvalidComponentTracker instance.</caption>
   * &lt;input id="username" type="text" required
   *   data-bind="ojComponent: {component: 'ojInputText', value: userName,
   *    invalidComponentTracker: tracker}">
   * &lt;input id="password" type="text" required
   *   data-bind="ojComponent: {component: 'ojInputPassword', value: password,
   *    invalidComponentTracker: tracker}">
   *
   * &lt;script>
   * function MyViewModel() {
   *   var self = this;
   *   self.tracker = ko.observable();
   *
   *   log = function ()
   *   {
   *     var trackerObj = ko.utils.unwrapObservable(self.tracker);
   *     console.log(trackerObj instanceof oj.InvalidComponentTracker); // true, so safe to call InvalidComponentTracker methods and properties.
   *   }
   *
   *   self.focusOnFirstInvalid = function()
   *   {
   *      var trackerObj = ko.utils.unwrapObservable(self.tracker);
   *      if (trackerObj !== undefined)
   *      {
   *        // make sure the trackerObj is an oj.InvalidComponentTracker
   *        // before calling methods on it.
   *        if (trackerObj instanceof oj.InvalidComponentTracker)
   *        {
   *           // showMessages first
   *           // (this will show any hidden messages, if any)
   *           trackerObj.showMessages();
   *           // focusOnFirstInvalid will focus on the first component
   *           // that is invalid, if any.
   *           trackerObj.focusOnFirstInvalid();
   *         }
   *       }
   *     }
   * }
   * &lt;/script>
   * Note: Make sure you have included the 'ojs/ojknockout-validation' dependency in your require list,
   * otherwise you will see an error about InvalidComponentTracker being undefined.
   *
   * @class oj.InvalidComponentTracker
   * @constructor
   * @class
   * @export
   * @since 0.7.0
   * @ignore
   */
  const InvalidComponentTracker = function () {
    this.Init();
  };
  oj._registerLegacyNamespaceProp('InvalidComponentTracker', InvalidComponentTracker);

  // Subclass from oj.Object
  oj.Object.createSubclass(InvalidComponentTracker, oj.Object, 'oj.InvalidComponentTracker');

  // DOCLETS for public properties

  /**
   * Whether there is at least one component (tracked by this object) that is invalid and is currently
   * showing messages.
   *
   *
   * @example <caption>Disable button using <code class="prettyprint">invalidShown</code> property:</caption>
   * &lt;input id="username" type="text" required
   *   data-bind="ojComponent: {component: 'ojInputText', value: userName,
   *    invalidComponentTracker: tracker}">
   * &lt;input id="password" type="text" required
   *   data-bind="ojComponent: {component: 'ojInputPassword', value: password,
   *    invalidComponentTracker: tracker}">
   * &lt;button type="button" data-bind="ojComponent: {component: 'ojButton', label: 'Create',
   *   disabled: tracker()['invalidShown']}"></button>
   *
   * &lt;script>
   * var userName = ko.observable();
   * var password = ko.observable();
   * var tracker = ko.observable();
   * &lt;/script>
   *
   * @member
   * @name invalidShown
   * @access public
   * @instance
   * @default false
   * @type {boolean}
   * @expose
   * @memberof oj.InvalidComponentTracker
   */

  /**
   * prevent preceding jsdoc from applying to following line of code
   * @ignore
   */
  // Options we are interested in listening to changes for.
  InvalidComponentTracker._OPTION_MESSAGES_SHOWN = 'messagesShown';
  InvalidComponentTracker._OPTION_MESSAGES_HIDDEN = 'messagesHidden';
  InvalidComponentTracker._OPTION_DISABLED = 'disabled';
  InvalidComponentTracker._OPTION_READONLY = 'readOnly';

  /**
   * Whether there is at least one component that is invalid with deferred messages, i.e., messages
   * that are currently hidden. For example, when a component is
   * required, deferred validation is run when the component is created.
   * Any validation error raised is not shown to user right away, i.e., it is deferred.
   *
   * @example <caption>Enable button using <code class="prettyprint">invalidHidden</code> property:</caption>
   * &lt;input id="username" type="text" required
   *   data-bind="ojComponent: {component: 'ojInputText', value: userName,
   *    invalidComponentTracker: tracker}">
   * &lt;input id="password" type="text" required
   *   data-bind="ojComponent: {component: 'ojInputPassword', value: password,
   *    invalidComponentTracker: tracker}">
   * &lt;br/>
   * &lt;button type="button" data-bind="ojComponent: {component: 'ojButton', label: 'Create',
   *   disabled: !tracker()['invalidHidden']}"></button>
   *
   * &lt;script>
   * var userName = ko.observable();
   * var password = ko.observable();
   * var tracker = ko.observable();
   * &lt;/script>
   *
   * @member
   * @name invalidHidden
   * @access public
   * @instance
   * @default false
   * @type {boolean}
   * @expose
   * @memberof oj.InvalidComponentTracker
   */
  /**
   * Initializer
   * @protected
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker.prototype.Init = function () {
    InvalidComponentTracker.superclass.Init.call(this);

    // INTERNAL PROPERTIES
    // Array of Objects containing component and its element
    // that are being tracked by invalidComponentTracker
    // [{'component': component, 'element': element}]
    this._tracked = [];

    // tracks invalid components showing messages. indices correspond to this_tracked.
    // e.g., [true, false, false, false, true]
    this._invalid = [];

    // tracks invalid components hiding messages. indices correspond to this_tracked.
    // e.g., [false, true, false, false, false]
    this._invalidHidden = [];

    // PUBLIC PROPERTIES
    // Whether there is at least one component
    // (tracked by this object) that is invalid and is currently showing messages.
    this.invalidShown = false;
    // Whether there is at least one component that is invalid with deferred messages,
    // i.e., messages that are currently hidden.
    this.invalidHidden = false;
  };

  /**
   * Sets focus on first invalid component currently showing an error. This method does not set focus
   * on components that are invalid and have deferred messages. For example, when a component is
   * required, deferred validation is run. Any validation error raised is not shown to user right away,
   *  i.e., it is deferred.
   *  <p>
   *  To show hidden messages on all tracked components use showMessages() method. </p>
   *
   * @return {boolean} true if there is at least one invalid component to set focus on; false if
   * unable to locate a component to focus on or there are no invalid components.
   * @export
   * @see #showMessages
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker.prototype.focusOnFirstInvalid = function () {
    var firstInvalid = null;
    var self = this;
    var updateCounter = this._updateCounter;

    // we don't always have a element associated, so this is on the page level context
    var busyContext = Context.getPageContext().getBusyContext();
    var resolveBusyState = busyContext.addBusyState({
      description: 'Setting Focus to first invalid component.'
    });

    if (this.invalidShown) {
      firstInvalid = this._getFirstInvalidComponent();
    }

    // always call focus handler on a timer to give time for binding layer to
    // apply changes on the component.
    setTimeout(function () {
      // sometimes when this timer is called, firstInvalid may not have been determined
      // yet. Or the invalid states could have changed in between the timer being set and the
      // callback being called.
      // TODO: talk to Pavitra regarding this logic, it seems unnecessary.
      firstInvalid =
        updateCounter === self._updateCounter
          ? firstInvalid || self._getFirstInvalidComponent()
          : self._getFirstInvalidComponent();

      if (firstInvalid) {
        // Get the widget instance for the firstInvalid so we can call protected methods directly.
        firstInvalid('instance').GetFocusElement().focus();
      }

      resolveBusyState();
    }, 1);

    return !!firstInvalid;
  };

  /**
   * Shows hidden messages on all tracked components by calling showMessages() method on each tracked
   * editable component.
   *
   * @example <caption>Show all hidden messages on tracked components:</caption>
   *  function ViewModel ()
   *  {
   *    self = this;
   *    var tracker = ko.observable();
   *   // ...
   *
   *   showAllMessages : function ()
   *   {
   *      var trackerObj = ko.utils.unwrapObservable(self.tracker);
          return trackerObj.showMessages();
   *    }
   *  }
   *
   * @export
   * @memberof oj.InvalidComponentTracker
   * @instance
   * @see oj.editableValue#showMessages
   */
  InvalidComponentTracker.prototype.showMessages = function () {
    var tr;

    if (this.invalidHidden) {
      var len = this._invalidHidden.length;
      for (var index = 0; index < len; index++) {
        if (this._invalidHidden[index]) {
          tr = this._tracked[index].component.call(tr, 'showMessages');
        }
      }
    }
  };

  // P R I V A T E    M E T H O D S
  /**
   * Gets the first invalid component and returns the component to focus on.
   *
   * @returns the component instance that has focus or null
   * @private
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker.prototype._getFirstInvalidComponent = function () {
    var idx = 0;
    var invalidComponents = [];
    var len = this._invalid.length;

    // locate first invalid component and set focus on it
    // this._invalid is an array of booleans that tracks invalid components showing messages.
    // e.g., [false, true, true, false]. This maps to the this._tracked which holds the
    // components. So the components showing messages is the ones at indices 1 and 2.
    // this._tracked may not be in DOM order if a new tracked component was added not
    // at the end of the DOM order.
    for (idx = 0; idx < len; idx++) {
      var isInvalid = this._invalid[idx];
      if (isInvalid) {
        invalidComponents.push(this._tracked[idx]);
      }
    }

    if (invalidComponents.length === 0) {
      return null;
    }

    // sort the invalidComponents based on dom order
    invalidComponents.sort(function (a, b) {
      var elementA = a.element;
      var elementB = b.element;
      // If elementA precedes elementB in dom order, return -1
      // eslint-disable-next-line no-bitwise
      return elementA.compareDocumentPosition(elementB) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });

    // invalidComponents is sorted now by document order, so return the first one.
    return invalidComponents[0].component;
  };

  /**
   * Removes the component from its tracked list.
   *
   * @param {Object} component being removed
   * @returns {boolean} if internal state mutated; false otherwise
   * @private
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker.prototype._remove = function (component) {
    var trackedIndex = -1;
    var mutated = false;

    // locate the index in tracked, for the component that was updated
    $.each(this._tracked, function (index, item) {
      if (trackedIndex < 0 && item.component === component) {
        trackedIndex = index;
      }
    });

    if (trackedIndex >= 0) {
      this._tracked.splice(trackedIndex, 1);
      // stop tracking them in the internal arrays
      this._invalid.splice(trackedIndex, 1);
      this._invalidHidden.splice(trackedIndex, 1);
      this._updateInvalidProperties();
      mutated = true;
    }

    return mutated;
  };

  /**
   * Updates the internal properties to reflect the current validity state of the component, using
   * new messages.
   *
   * @param {Object} component the component that has the new messages
   * @param {Element} element the element that has the new messages (this is the component's element)
   * @param {string} option the option being updated. e.g., messagesShown, messagesHidden, disabled,
   *  readOnly
   * @param {Array.<string>| Array.<oj.Message>} value the value of the option. For example, if option is 'messagesShown'
   *   the value is the Array of the messagesShown, if empty value is [].
   * @returns {boolean} if internal state mutated; false otherwise
   * @private
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker.prototype._update = function (component, element, option, value) {
    var compValid = component.call(component, 'isValid');
    var mutated = true;
    var result;
    var trackedIndex = -1;

    // locate the index in tracked, for the component that was updated.
    $.each(this._tracked, function (index, item) {
      if (trackedIndex < 0 && item.component === component) {
        trackedIndex = index;
      }
    });

    switch (option) {
      case InvalidComponentTracker._OPTION_MESSAGES_SHOWN:
      case InvalidComponentTracker._OPTION_MESSAGES_HIDDEN:
        result = false;
        if (value) {
          // start tracking component if not already doing it.
          if (trackedIndex < 0) {
            trackedIndex = this._tracked.push({ component: component, element: element }) - 1;
            // adds the trackedIndex/result to this._invalid and this._invalidHidden boolean arrays,
            // keeping this._tracked in sync with this._invalid and this._invalidHidden.
            // adds the trackedIndex/result to this._invalid and this._invalidHidden boolean arrays,
            // keeping this._tracked in sync with this._invalid and this._invalidHidden.
            this._initializeInvalidTrackers(trackedIndex, result);
          }

          if (!compValid) {
            if (InvalidComponentTracker._hasInvalidMessages(value)) {
              result = true;
              if (option === InvalidComponentTracker._OPTION_MESSAGES_SHOWN) {
                // if component is disabled or readOnly but has messages showing, tracker stops
                // tracking component in its 'invalidShown' list. We do this because if property is
                // bound to a button, and if the only invalid component showing messages is disabled
                // the button would appear disabled visually, confusing the end-user.
                // E.g., disabled component can be initialized with messagesCustom making it invalid and
                // disabled.

                var isDisabled = component.call(
                  component,
                  'option',
                  InvalidComponentTracker._OPTION_DISABLED
                );
                var isReadOnly = component.call(
                  component,
                  'option',
                  InvalidComponentTracker._OPTION_READONLY
                );
                result = !(isDisabled || isReadOnly);
              }
            }
          }

          mutated = this._updateInvalidTracker(option, trackedIndex || 0, result);
          this._updateInvalidProperties();

          // update properties
          if (mutated) {
            // every time messages mutates, we track it.
            if (this._updateCounter === undefined) {
              this._updateCounter = 0;
            }
            this._updateCounter += 1;
          }
        }
        break;

      case InvalidComponentTracker._OPTION_DISABLED:
      case InvalidComponentTracker._OPTION_READONLY:
        // when component goes from enabled to disabled (or to readOnly) tracker updates invalidShown
        // to be false, since the component cannot be showing errors visually. Same goes for
        // invalidHidden.
        //
        // when component goes from disabled (or readOnly) to enabled validations are re-run and
        // component's messagesHidden and messagesShown are updated which result in invalidShown and
        // invalidHidden to be updated. This case is not handled here.

        mutated = false;
        if (value) {
          mutated = this._updateInvalidTracker(
            InvalidComponentTracker._OPTION_MESSAGES_SHOWN,
            trackedIndex || 0,
            false
          );
          mutated =
            this._updateInvalidTracker(
              InvalidComponentTracker._OPTION_MESSAGES_HIDDEN,
              trackedIndex || 0,
              false
            ) || mutated;
          this._updateInvalidProperties();
        }
        break;

      default:
        break;
    }
    return mutated;
  };

  /**
   * This is called when we are starting to track a component. Before this function is called,
   * we push the component and element into the this._tracked array and then we call this
   * with the trackedIndex
   *
   * @param {number} trackedIndex
   * @param {boolean} result true or false. Since this is initializing the this._invalid and
   * this._invalidHidden arrays, it really only makes sense if it is false but it
   *  isn't enforced.
   * @private
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker.prototype._initializeInvalidTrackers = function (trackedIndex, result) {
    if (this._invalid[trackedIndex] === undefined) {
      this._updateInvalidTracker(
        InvalidComponentTracker._OPTION_MESSAGES_SHOWN,
        trackedIndex,
        result
      );
    }
    if (this._invalidHidden[trackedIndex] === undefined) {
      this._updateInvalidTracker(
        InvalidComponentTracker._OPTION_MESSAGES_HIDDEN,
        trackedIndex,
        result
      );
    }
  };

  InvalidComponentTracker.prototype._updateInvalidProperties = function () {
    // updates public properties exposed by this object
    this.invalidShown = this._invalid.indexOf(true) >= 0;
    this.invalidHidden = this._invalidHidden.indexOf(true) >= 0;
  };

  /**
   * If option is "messagesShown", then update this._invalid boolean array,
   * else if option is "messagesHidden", update this._invalidHidden boolean array
   * using the trackedIndex and the value.
   * this._invalid is a boolean array, e.g., [false, false, false, true, false], indicating
   * which components have invalid messages showing.
   * this._invalidHidden is also a boolean array indicating which components have invalid messages
   * hidden. The components are tracked in this._tracked. The indices correspond. For example,
   * the component at this._tracked[3]['component'] is showing invalid messages
   * if this._invalid[3] is true.
   * @private
   * @memberof oj.InvalidComponentTracker
   * @instance
   * @param {string} option "messagesShown" or "messagesHidden".
   * @param {number} trackedIndex the index of the tracked component
   * @param {boolean} value true or false
   * @returns {boolean} whether or not this._invalid or this._invalidHidden was mutated
   */
  InvalidComponentTracker.prototype._updateInvalidTracker = function (option, trackedIndex, value) {
    var arr;
    var mutated = false;

    if (option === InvalidComponentTracker._OPTION_MESSAGES_SHOWN) {
      arr = this._invalid;
    } else if (option === InvalidComponentTracker._OPTION_MESSAGES_HIDDEN) {
      arr = this._invalidHidden;
    } else {
      arr = [];
    }

    // updates or pushes the value into the appropriate array
    if (trackedIndex >= 0 && arr[trackedIndex] !== undefined) {
      // mark component as invalid or invalidHidden to match the trackedIndex; update only if value
      // changes
      mutated = arr[trackedIndex] !== value;
      if (mutated) {
        arr[trackedIndex] = value;
      }
    } else {
      // new
      arr.push(value);
      mutated = true;
    }

    return mutated;
  };

  /**
   * helper to determine if we have invalid messages among the list of messages that are currently
   * showing i.e., that are showing.
   *
   * @param {!Array.<oj.Message>} messages list of all messages associated with component
   * @returns {boolean}
   * @private
   * @memberof oj.InvalidComponentTracker
   * @instance
   */
  InvalidComponentTracker._hasInvalidMessages = function (messages) {
    return !Message.isValid(messages);
  };

  /* jslint browser: true, devel: true*/

  // private to prevent creating a JSDoc page for this class.  The only thing we wish
  // to JSDoc is the invalidComponentTracker, which we're putting in EditableValue's output.
  /**
   * An extension to oj.ComponentBinding, properties exposed on this binding are available
   * to jet components that extend from oj.editableValue.
   *
   * @private
   * @constructor oj.ValueBinding
   * @see oj.ComponentBinding
   * @see oj.editableValue
   * @since 0.6.0
   */
  const ValueBinding = function () {};
  oj._registerLegacyNamespaceProp('ValueBinding', ValueBinding);

  /**
   * <p>When this attribute is bound to an observable, the framework pushes
   * an object of type {@link oj.InvalidComponentTracker} onto the observable.
   * The object itself tracks the validity of a group of editable components.
   *
   * <p>When this attribute is present, the binding registers a listener
   * for the <a href="#optionChange">optionChange</a>
   * event. This event is fired by JET editable components whenever its validity changes (i.e. when
   * <a href="#messagesShown">messagesShown</a> or <a href="#messagesHidden">messagesHidden</a>
   * options change). When the event is fired, the listener determines the current validity of the
   * component and updates the tracker.
   *
   * <p>
   * The observable bound to this attribute is often used with multiple component binding declarations
   * as shown in the example below.
   * </p>
   *
   * <p>
   * This attribute is only exposed via the <code class="prettyprint">ojComponent</code> binding, and
   * is not a component option.
   * </p>
   *
   * @example <caption>Track validity of multiple components using a single observable
   * bound to the <code class="prettyprint">invalidComponentTracker</code> attribute:</caption>
   * &lt;input id="username" type="text" name="username" required
   *   data-bind="ojComponent: {component: 'ojInputText', value: userName,
   *                            invalidComponentTracker: tracker}">
   *
   * &lt;input id="password" type="password" name="password" required
   *   data-bind="ojComponent: {component: 'ojInputPassword', value: password,
   *                            invalidComponentTracker: tracker}"/>
   *
   * // ViewModel that defines the tracker observable
   * &lt;script>
   * function MemberViewModel()
   * {
   *   var self = this;
   *
   *   self.tracker = ko.observable();
   *
   *   self.userName = ko.observable();
   *   self.password = ko.observable();
   *
   *   self.focusOnFirstInvalid = function()
   *   {
   *      var trackerObj = ko.utils.unwrapObservable(self.tracker);
   *      if (trackerObj !== undefined)
   *      {
   *        // make sure the trackerObj is an oj.InvalidComponentTracker
   *        // before calling methods on it.
   *        if (trackerObj instanceof InvalidComponentTracker)
   *        {
   *           // showMessages first
   *           // (this will show any hidden messages, if any)
   *           trackerObj.showMessages();
   *           // focusOnFirstInvalid will focus on the first component
   *           // that is invalid, if any.
   *           trackerObj.focusOnFirstInvalid();
   *         }
   *       }
   *     }
   * }
   * &lt;/script>
   *
   * @example <caption>Use tracker property <code class="prettyprint">invalid</code> to disable button:</caption>
   * // button is disabled if there are components currently showing errors
   * &lt;button type="button" data-bind="ojComponent: {component: 'ojButton', label: 'Submit',
   *                                                disabled: tracker()['invalidShown']}"></button>
   *
   * @ojbindingonly
   * @member
   * @name invalidComponentTracker
   * @memberof oj.editableValue
   * @instance
   * @type {oj.InvalidComponentTracker}
   * @default <code class="prettyprint">null</code>
   * @since 0.7.0
   * @ignore
   */
  /** prevent preceding jsdoc from applying to following line of code */

  ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER = 'invalidComponentTracker';

  // A listener is added for this event to listen to changes to the 'messagesHidden' or
  // 'messagesShown' options. The listener updates the InvalidComponentTracker.
  ValueBinding._EVENT_OPTIONCHANGE = 'ojoptionchange';

  // Options we are interested in listening to changes for.
  ValueBinding._OPTION_MESSAGES_SHOWN = 'messagesShown';
  ValueBinding._OPTION_MESSAGES_HIDDEN = 'messagesHidden';

  // options that are managed primarily to detect changes for tracker to be notified.
  ValueBinding._OPTION_DISABLED = 'disabled';
  ValueBinding._OPTION_READONLY = 'readOnly';

  // callback called when managed attribute is being updated
  ValueBinding._update = function (name, value, element, component, valueAccessor) {
    var options = valueAccessor.call();
    var updateProps = {};
    var ictObs = options[ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER];

    if (name === ValueBinding._OPTION_DISABLED || name === ValueBinding._OPTION_READONLY) {
      var icTracker = (ictObs && ictObs.peek()) || null; // don't add extra subscriptions
      // when either of these options are updated
      if (icTracker !== null && ko.isWriteableObservable(ictObs)) {
        if (icTracker._update.call(icTracker, component, element, name, value)) {
          // if _update mutates state
          ictObs.valueHasMutated();
        }
      }
      updateProps[name] = value;
      return updateProps;
    }

    return undefined;
  };

  // init callback for managed attributes. When managing options like disabled, readOnly
  // this method is required to return values.
  ValueBinding._init = function (name, value) {
    var initProps = {};

    initProps[name] = value;
    return initProps;
  };

  /**
   * Called after component binding creates the component.
   * @param {string} property
   * @param {Element} element the element to which binding applied the componnet
   * @param {Function=} component the widget bridge
   * @param {Object=} valueAccessor
   * @private
   */
  ValueBinding._afterCreate = function (property, element, component, valueAccessor) {
    var initProps = {};
    var optionsSet = valueAccessor.call();
    var isICTOptionSet;

    if (property === ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER) {
      isICTOptionSet = !!optionsSet[property];

      if (isICTOptionSet) {
        // register a writeback for invalidComponentTracker property by registering an event listener
        //  for the optionChange event.
        ValueBinding._registerInvalidComponentTrackerWriteback(
          property,
          optionsSet,
          element,
          component
        );
      }
    }

    return initProps;
  };

  /**
   * Called right before component is destroyed.
   *
   * @param {Element} element
   * @private
   */
  ValueBinding._beforeDestroy = function (property, element, component, valueAccessor) {
    var jelem = $(element);
    var options = valueAccessor.call();
    var icTracker;
    var ictObs = options[property];

    if (property === ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER) {
      jelem.off(ValueBinding._EVENT_OPTIONCHANGE, ValueBinding._updateInvalidComponentTracker);
      if (ictObs && ko.isWriteableObservable(ictObs)) {
        icTracker = ictObs.peek();
        // remove component from tracker
        if (icTracker._remove.call(icTracker, component)) {
          // if _remove mutates state, then components need to react to it.
          // example a button that binds to properties on invalidComponentTracker.
          ictObs.valueHasMutated();
        }
      }
    }
  };

  /**
   * Listener for the optionChange event, it updates the invalidComponentTracker associated to the
   * component that triggered the event.
   *
   * @param {jQuery.event=} event
   * @private
   */
  ValueBinding._updateInvalidComponentTracker = function (event) {
    var ictObs = event.data.tracker;
    var icTracker;
    var component = event.data.component;
    var element = event.data.element;
    var payload = arguments[1];
    var option = payload.option;
    var msgs = payload.value;

    if (
      option === ValueBinding._OPTION_MESSAGES_SHOWN ||
      option === ValueBinding._OPTION_MESSAGES_HIDDEN
    ) {
      if (ictObs && ko.isWriteableObservable(ictObs)) {
        icTracker = ictObs.peek();
        if (icTracker && icTracker._update.call(icTracker, component, element, option, msgs)) {
          // if _update mutates state
          ictObs.valueHasMutated();
        }
      }
    }
  };

  /**
   * Register a default callback for the 'optionChange' event. The callback writes the component and
   * its validity to the invalidComponentTracker observable.
   * @param {string} property
   * @param {Object} options original options set on element
   * @param {Element} element
   * @param {Function=} component
   * @private
   */
  ValueBinding._registerInvalidComponentTrackerWriteback = function (
    property,
    options,
    element,
    component
  ) {
    var ictObs = options[property];
    var icTracker;
    var jElem = $(element);

    // Create new intsance of InvalidComponentTracker if the observable is not set.
    if (ko.isObservable(ictObs)) {
      icTracker = ictObs.peek();
      // push new instance of oj.InvalidComponentTracker onto observable if none present.
      if (icTracker == null) {
        // null or undefined
        icTracker = new InvalidComponentTracker();
        ictObs(icTracker);
      }
    } else {
      // tracker object is not an observable.
      throw new Error(
        'Binding attribute ' +
          ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER +
          ' should be bound to a ko observable.'
      );
    }

    // update icTracker initial state using component's latest option values
    if (ko.isWriteableObservable(ictObs)) {
      // EditableValue's messagesShown option is an Array of messages currently shown on component.
      var messagesShown = component.call(component, 'option', ValueBinding._OPTION_MESSAGES_SHOWN);
      // EditableValue's messagesHidden option is an Array of messages currently hidden on component
      var messagesHidden = component.call(component, 'option', ValueBinding._OPTION_MESSAGES_HIDDEN);

      icTracker._update.call(
        icTracker,
        component,
        element,
        ValueBinding._OPTION_MESSAGES_SHOWN,
        messagesShown
      );
      icTracker._update.call(
        icTracker,
        component,
        element,
        ValueBinding._OPTION_MESSAGES_HIDDEN,
        messagesHidden
      );
      ictObs.valueHasMutated();
    }

    // register listener for optionChange event for future changes to messages* options
    var eventData = { tracker: ictObs, component: component, element: element };
    jElem.on(
      ValueBinding._EVENT_OPTIONCHANGE,
      eventData,
      ValueBinding._updateInvalidComponentTracker
    );
  };

  /**
   * editableValue Behavior Definition and Injection
   */
  if (oj.ComponentBinding.getDefaultInstance) {
    oj.ComponentBinding.getDefaultInstance().setupManagedAttributes({
      for: 'editableValue',
      attributes: [
        ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER,
        ValueBinding._OPTION_DISABLED,
        ValueBinding._OPTION_READONLY
      ],
      init: ValueBinding._init,
      update: ValueBinding._update,
      afterCreate: ValueBinding._afterCreate,
      beforeDestroy: ValueBinding._beforeDestroy
    });
  }

});



define('ojs/ojrouter',['ojs/ojcore', 'knockout', 'signals', 'ojs/ojlogger'], function(oj, ko, signals, Logger)
{
  "use strict";


/* jslint browser: true*/
/* global ko, signals, Logger:false */

/**
 * The ojRouter module.
 */
// Wrap in a IIFE to prevents the possiblity of collision in a non-AMD scenario.
(function () {
  'use strict';

  /**
   * Hold the value of the oj.Router.defaults.baseUrl property.
   * @private
   * @type {!string}
   */
  var _baseUrlProp = '/';

  /**
   * Hold the title before being modified by router
   * @private
   * @type {?string}
   */
  var _originalTitle;

  /**
   * Hold the url adapter to be used.
   * @private
   * @type {oj.Router.urlPathAdapter|oj.Router.urlParamAdapter}
   */
  var _urlAdapter;

  /**
   * The default name for the root instance.
   * @private
   * @const
   * @type {string}
   */
  var _DEFAULT_ROOT_NAME = 'root';

  /**
   * The name of the request param for bookmarkable data.
   * @private
   * @const
   * @type {string}
   */
  var _ROUTER_PARAM = 'oj_Router';
  /**
   * The separator used to build the title from router labels.
   * @private
   * @const
   * @type {string}
   */
  var _TITLE_SEP = ' | ';

  /**
   * Maximum size of URL
   * @private
   * @const
   * @type {number}
   */
  var _MAX_URL_LENGTH = 1024;

  /**
   * Name of the window event used to listen to the browser history changes
   * @private
   * @const
   * @type {string}
   */
  var _POPSTATE = 'popstate';

  /**
   * Name of the property of the object in the Promise returned by go() or sync()
   * @private
   * @const
   * @type {string}
   */
  var _HAS_CHANGED = 'hasChanged';

  /**
   * Object commonly used as return value for go() or sync()
   * @private
   * @const
   * @type {{hasChanged:boolean}}
   */
  var _NO_CHANGE_OBJECT = { hasChanged: false };

  /**
   * Flag set to true when oj.Router is initialized
   * @private
   * @type {boolean}
   */
  var _initialized = false;

  /**
   * Hold the leftover path when using ojModule and the child router
   * doesn't exist yet.
   * @private
   * @type {string|undefined}
   */
  var _deferredPath;

  /**
   * A queue to hold unprocessed transitions
   * @private
   * @type {Array.<Object>}
   */
  var _transitionQueue = [];

  /**
   * A promise that resolve when all transition in the queue is resolved.
   * @private
   */
  var _queuePromise;

  /**
   * A shortcut to access window.location
   * @private
   */
  var _location = window.location;

  /**
   * The name of the object containing state parameters.
   * @private
   */
  var _parametersValue = 'parameters';

  /**
   * The instance of the root router.
   * @private
   * @const
   * @type {!oj.Router}
   */
  var rootRouter;

  /**
   * Return key/value object of query parameters.
   * @private
   * @return {!Object.<string, string>}
   */
  function parseQueryParam(queryString) {
    var params = {};

    // Remove starting '?'
    var trimmedQueryString = queryString.split('?')[1];

    if (trimmedQueryString) {
      var keyValPairs = trimmedQueryString.split('&');
      keyValPairs.forEach(function (pair) {
        var parts = pair.split(/=(.+)?/);
        var key = parts[0];

        if (key.length) {
          var value = parts[1] && decodeURIComponent(parts[1]);
          params[key] = value;
        }
      });
    }

    return params;
  }

  /**
   * Takes a path of segment separated by / and returns an array of segments
   * @param  {string=} path a path of segment separated by /
   * @return {!Array} an array of segment
   */
  function _getSegments(path) {
    return path ? path.split('/') : [];
  }

  /**
   * Returns the first segment of a path separated by /
   * @param  {string=} id
   * @return {string}
   */
  function _getShortId(id) {
    var segment = _getSegments(id)[0];
    return _decodeSlash(segment);
  }

  /**
   * Build an URL by replacing portion of the existing URL. Portion that can be replaces are
   * pathname and search field. Use the extraState to build the new state param.
   * @private
   * @param  {!Object} pieces
   * @param  {!Object.<string, Object>} extraState
   * @return {!string}
   */
  function _buildUrl(pieces, extraState) {
    var parser = document.createElement('a');
    parser.href = _location.href;

    if (pieces.search !== undefined) {
      parser.search = pieces.search;
    }

    if (pieces.pathname !== undefined) {
      parser.pathname = pieces.pathname;
    }

    // Add or replace the existing state param
    parser.search = putStateParam(parser.search, extraState);

    return parser.href.replace(/\?$/, ''); // Remove trailing ? for IE
  }

  /**
   * Return the {@link oj.RouterState} object for a specific router given a state id.
   * @private
   * @param {oj.Router} router The router object.
   * @param {string} stateId The state id.
   * @return {oj.RouterState | undefined} The state object.
   */
  function getStateFromId(router, stateId) {
    var state;

    if (stateId && router._states) {
      oj.Assert.assertString(stateId);

      router._states.every(function (stateAt) {
        if (stateAt._id === stateId) {
          state = stateAt;
          return false;
        }
        return true;
      });
    }
    return state;
  }

  /**
   * Retrieve a router full name. A path of all rooter name from root.
   * @private
   * @param  {!oj.Router} router
   * @return {!string}
   */
  function getRouterFullName(router) {
    if (router._parentRouter) {
      return getRouterFullName(router._parentRouter) + '.' + router._name;
    }

    return router._name;
  }

  /**
   * Retrieves the absolute path to the current state. If one of the parent router current state is
   * not defined, the path is meaningless so returns undefined.
   * @private
   * @param {oj.Router|undefined} router
   * @return {string|undefined} path
   */
  function getCurrentPath(router) {
    var path;

    if (router) {
      path = getCurrentPath(router._parentRouter);

      if (path) {
        var sId = router._stateId();

        if (sId) {
          path += sId + '/';
        } else {
          path = undefined;
        }
      }
    } else {
      path = '/';
    }

    return path;
  }

  /**
   * Return the child router for a specific parent state value
   * @private
   * @param {oj.Router} router
   * @param {string|undefined} value
   * @return {oj.Router|undefined}
   */
  function _getChildRouter(router, value) {
    var subRouter;

    router._childRouters.every(function (sr) {
      // If child router doesn't have _parentState, then it was created before
      // the parent router navigated to a state, and so it's used as the default
      // child router.  There can only be one child router per parent state (even
      // if the parent state is "undefined"), so we should only ever encounter,
      // at most, one sub-router whose parent state is undefined.
      if (!sr._parentState) {
        subRouter = sr;
      } else if (sr._parentState === value) {
        // Otherwise, if a specific subrouter matches the queried value, then use
        // it instead of the default.
        subRouter = sr;

        // Once found, exit the loop right away.  There can be only one child
        // router per parent state, so the first one we find will be the only
        // one.
        return false;
      }
      return true;
    });

    return subRouter;
  }

  /**
   * Only keep changes where the value doesn't match the current router state
   * @private
   * @param {!Array.<_StateChange>} changes
   * @return {!Array.<_StateChange>}
   */
  function _filterNewState(changes) {
    var newChanges = changes.filter(function (change) {
      return change.value !== change.router._stateId();
    });

    if (Logger.option('level') === Logger.LEVEL_INFO) {
      Logger.info('Potential changes are: ');
      newChanges.forEach(function (change) {
        Logger.info(
          '   { router: %s, value: %s }',
          change.router && getRouterFullName(change.router),
          change.value
        );
      });
    }

    return newChanges;
  }

  /**
   * Update the bookmarkable data
   * @private
   * @this {!Object.<string, Object>}
   * @param {?Object} change
   */
  function _updateBookmarkableData(change) {
    var ex = this[change.router._name];
    if (ex !== undefined) {
      // eslint-disable-next-line no-param-reassign
      change.router._extra = ex;
    }
  }

  /**
   * Return true if the current transition is cancelled.
   * See queuing of transaction in _queueTransaction
   * @private
   * @return {boolean}
   */
  function isTransitionCancelled() {
    return _transitionQueue[0] && _transitionQueue[0].cancel;
  }

  /**
   * Encode and compress the a state object. This is used for bookmarkable data.
   * @private
   * @param {!Object.<string, Object>} extraState
   * @return {!string}
   * @throws An error if bookmarkable state is too big.
   */
  function encodeStateParam(extraState) {
    var jsonState = JSON.stringify(extraState);
    var encodedState = encodeURIComponent(jsonState);
    var compressedState = oj.LZString.compressToEncodedURIComponent(jsonState);
    var useCompressed = false;
    var param = _ROUTER_PARAM + '=';

    if (compressedState.length <= encodedState.length) {
      useCompressed = true;
    }

    if (useCompressed) {
      param += '1' + compressedState;
    } else {
      param += '0' + encodedState;
    }

    if (param.length > _MAX_URL_LENGTH) {
      throw new Error('Size of bookmarkable data is too big.');
    }

    return param;
  }

  /**
   * Decompress and decode the state param from the URL.  This is used for bookmarkable data.
   * @private
   * @param {!string} param
   * @return {!Object.<string, Object>}
   * @throws An error if parsing fails or format is invalid.
   */
  function decodeStateParam(param) {
    var extraState;
    // First character is the compression type. Right now only 0 and 1 are supported.
    // 0 for no compression, 1 for LZW
    var compressionType = param.charAt(0);

    var decodedParam = param.slice(1);

    if (compressionType === '0') {
      decodedParam = decodeURIComponent(decodedParam);
    } else if (compressionType === '1') {
      decodedParam = oj.LZString.decompressFromEncodedURIComponent(decodedParam);
    } else {
      throw new Error('Error retrieving bookmarkable data. Format is invalid');
    }

    extraState = /** @type {!Object.<string, Object>} */ (JSON.parse(decodedParam));

    if (Logger.option('level') === Logger.LEVEL_INFO) {
      Logger.info('Bookmarkable data: ');
      var names = Object.keys(extraState);
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        Logger.info('   { router: %s, value: %s }', name, extraState[name]);
      }
    }

    return extraState;
  }

  /**
   * Replace the state param in the URL.
   * @private
   * @param {!string} url the url to which the param will be added
   * @param {!Object.<string, Object>} extraState the object to be stored in the param
   * @return {!string} the URL with the new state param
   */
  function putStateParam(url, extraState) {
    var stateParam = '';
    var startSegment;
    var endSegment;
    var start = url.indexOf(_ROUTER_PARAM);

    if (start !== -1) {
      var end = url.indexOf('&', start);
      if (end === -1) {
        end = url.length;
      }

      startSegment = url.substring(0, start);
      endSegment = url.substr(end);
    } else {
      startSegment = url + (url.indexOf('?') === -1 ? '?' : '&');
      endSegment = '';
    }

    if (extraState && Object.getOwnPropertyNames(extraState).length > 0) {
      stateParam = encodeStateParam(extraState);
    } else {
      // Remove the '?' or '&'
      startSegment = startSegment.substring(0, startSegment.length - 1);
    }

    return startSegment + stateParam + endSegment;
  }

  /**
   * Traverse all the child routers in order to find a router that has the
   * state id given as an argument.
   * @private
   * @param  {!oj.Router} router
   * @param  {!string} sId
   * @param  {string=} parentStateId
   * @return {oj.Router|undefined}
   */
  function _findRouterForStateId(router, sId, parentStateId) {
    var result;

    router._childRouters.every(function (child) {
      if (
        (!child._parentState || child._parentState === parentStateId) &&
        child._getStateFromId(sId)
      ) {
        result = child;
        return false;
      }
      return true;
    });

    return result;
  }

  /**
   * Traverse the tree of routers and build an array of states made of the router and an
   * undefined value.
   * The first item of the array is the root and the last is the leaf.
   * @private
   * @param  {oj.Router} router
   */
  function _buildAllUndefinedState(router) {
    var states = [];

    if (router._currentState()) {
      // Push a state change with undefined value (2nd argument in constructor missing)
      states.push(new _StateChange(router));

      router._childRouters.forEach(function (child) {
        states = states.concat(_buildAllUndefinedState(child));
      });
    }

    return states;
  }

  /**
   * Build a page title using the label of the current child routers state
   * @private
   * @param  {oj.Router|undefined} router
   * @return {!{segment: string, title: string}}
   */
  function _buildTitle(router) {
    if (!router) {
      return { title: '', segment: '' };
    }

    // Recurse leaf first
    var titleInfo = _buildTitle(_getChildRouter(router, router._stateId()));

    // If we don't have a title yet, build one.
    if (titleInfo.title === '') {
      var state = router._currentState();
      if (state) {
        // If a title property is present, it has precedence.
        var title = state._title;
        if (title !== undefined) {
          if (typeof title === 'function') {
            title = title();
          }
          titleInfo.title = String(title);
        } else {
          // Otherwise, compose the title with the label
          title = state._label;
          if (title !== undefined) {
            title = String(title);
            // Append existing segment
            if (titleInfo.segment !== '') {
              title += _TITLE_SEP + titleInfo.segment;
            }
            titleInfo.segment = title;
          }
        }
      }
    }

    return titleInfo;
  }

  /**
   * Dispatch the transitionedToState signal
   * @private
   * @param {Object} param
   * @param {boolean} param.haschanged
   * @param {oj.Router=} param.router
   * @param {oj.RouterState=} param.oldState
   * @param {oj.RouterState=} param.newState
   */
  function dispatchTransitionedToState(param) {
    oj.Router._transitionedToState.dispatch(param);
  }

  /**
   * An object use to represent a change in a RouterState
   * @constructor
   * @param {!oj.Router} router
   * @param {string=} value
   * @private
   * @ojtsignore
   */
  function _StateChange(router, value) {
    this.router = router;
    this.value = value; // the value is also the stateId
  }

  /**
   * Returns the RouterState object for the state id in this change object
   * @return {oj.RouterState} the RouterState matching the value
   * @private
   */
  _StateChange.prototype.getState = function () {
    if (!this.state) {
      if (this.value) {
        this.state = this.router._getStateFromId(_getShortId(this.value));
      }
    }

    return this.state;
  };

  /**
   * Store a state parameter value by appending it to the value as a path
   * @param {string=} value
   * @private
   */
  _StateChange.prototype.addParameter = function (value) {
    if (value) {
      this.value += '/' + value;
    }
  };

  /**
   * Takes an array of changes from parsing and appends other changes needed to be done.
   * 1) All cascading default state
   * 2) All the state that need to become undefined
   * @private
   * @param {!Array.<_StateChange>} states
   * @return {!Array.<_StateChange>}
   */
  function _appendOtherChanges(states) {
    var lastItem = states[states.length - 1];
    var router;
    var value;

    // If there is a state, starts with it
    if (lastItem) {
      router = lastItem.router;
      value = _getShortId(lastItem.value);
    } else {
      // Otherwise, starts at the root router
      router = rootRouter;
      value = rootRouter._defaultStateId;
      if (value) {
        states.push(new _StateChange(router, value));
      }
    }

    // Append all the default states all the way to the leaf router
    router = _getChildRouter(router, value);
    while (router) {
      value = router._defaultStateId;
      if (value) {
        states.push(new _StateChange(router, value));
      }
      router = _getChildRouter(router, value);
    }

    // Build an array of all the state to become undefined due to the parent state changing. The
    // order of execution is leaf first.

    var undefStates = _buildAllUndefinedState(rootRouter); // First build an array of undefined state
    var undef = [];

    undefStates.forEach(function (select, i) {
      var change = states[i];

      // Only insert change for a different router since the undef change will already happen when
      // a router transition to a different state.
      if (!change || select.router !== change.router) {
        undef.unshift(select);
      }
    });

    // The order of execution is exit(undef) from leaf to root followed by enter from root to leaf
    return undef.concat(states);
  }

  /**
   * Build an array of objects by visiting the parent hierarchy.
   * Each element of the array represent the state of a router.
   * @private
   * @param {!oj.Router} router
   * @param {!string} path
   * @return {!Array.<_StateChange>}
   */
  function _buildStateFromPath(router, path) {
    var newStates = [];
    var routers = [];
    var rt = router;
    var parts = _getSegments(path);
    var parent;
    var parentStateId;
    var state;
    var stateChange;
    var pi = 0;

    // Since path is absolute, it always starts with '/', so remove the first
    // element (empty string)
    parts.splice(0, 1);

    // Build an array of routers, from the root to the current one.
    while (rt) {
      routers.unshift(rt);
      rt = rt._parentRouter;
    }

    // Traverse path and routers simultaneously.
    for (var sId = parts.shift(); sId; sId = parts.shift()) {
      if (state) {
        var pName = state._paramOrder[pi];

        // If state has parameters, save the state Id as the parameter value
        if (pName) {
          stateChange.addParameter(sId);
          pi += 1;
        } else {
          // Otherwise, reset parameter index
          pi = 0;
        }
      }

      if (!state || pi === 0) {
        rt = routers.shift();

        if (!rt) {
          rt = _findRouterForStateId(parent, sId, parentStateId);

          // Router doesn't exist, save deferredPath and stop
          if (!rt) {
            _deferredPath = path;
            return newStates;
          }
        }

        stateChange = new _StateChange(rt, sId);
        state = stateChange.getState();
        if (!state) {
          throw new Error(
            'Invalid path "' +
              path +
              '". State id "' +
              sId +
              '" does not exist on router "' +
              rt._name +
              '".'
          );
        }

        newStates.push(stateChange);
        parent = rt;
        parentStateId = sId;
      }
    }

    return newStates;
  }

  /**
   * Execute a callback and log if returns false.
   * @private
   * @param  {(function (): (?)|undefined)} callback
   * @param  {!string}   type
   * @param  {string}   stateId
   * @return {boolean}
   */
  function _executeCallback(callback, type, stateId) {
    var result = callback();
    if (!result) {
      Logger.info('%s is false for state: %s', type, stateId);
    }

    return result;
  }

  /**
   * Chain callback into a sequence if it's a function.
   * @private
   * @param  {(function (): (?)|undefined)} callback
   * @param  {IThenable.<?>|null}           sequence
   * @param  {!string}                      type
   * @param  {string}                       stateId
   * @return {IThenable.<?>|null}
   */
  function _chainCallback(callback, sequence, type, stateId) {
    // Check if we can enter this new state by executing the callback.
    // If the callback is a function, chain it.
    if (typeof callback === 'function') {
      // Check if this is the start of the chain
      if (!sequence) {
        // eslint-disable-next-line no-param-reassign
        sequence = new Promise(function (resolve) {
          resolve(_executeCallback(callback, type, stateId));
        });
      } else {
        // eslint-disable-next-line no-param-reassign
        sequence = sequence.then(function (result) {
          // Only test the next state if the previous promise return true
          if (result) {
            // eslint-disable-next-line no-param-reassign
            result = _executeCallback(callback, type, stateId);
          }

          return result;
        });
      }
    }

    return sequence;
  }

  /**
   * Traverse the child router and build a chain of promise for each canExit callback.
   * @private
   * @param  {oj.Router} router
   * @param  {IThenable.<?>|null}  sequence
   * @return {IThenable.<?>|null}  chain of promises executing the canExit on the current states
   */
  function _buildCanExitSequence(router, sequence) {
    var currentState = router._currentState();

    if (currentState) {
      // Traverse each child router and ask for canExit
      for (var i = 0; i < router._childRouters.length; i++) {
        // eslint-disable-next-line no-param-reassign
        sequence = _buildCanExitSequence(router._childRouters[i], sequence);
      }

      // A callback defined on bound viewModel has precedence.
      var canExitCallback;
      if (currentState.viewModel && currentState.viewModel.canExit) {
        canExitCallback = currentState.viewModel.canExit;
      } else {
        canExitCallback = currentState._canExit;
      }

      // eslint-disable-next-line no-param-reassign
      sequence = _chainCallback(canExitCallback, sequence, 'canExit', currentState._id);
    }

    return sequence;
  }

  /**
   * Invoke canExit callbacks in a deferred way.
   * @private
   * @param  {oj.Router} router
   * @return {IThenable.<?>|null} a promise returning true if all of the current state can exit.
   */
  function _canExit(router) {
    var sequence;

    if (isTransitionCancelled()) {
      return Promise.resolve(false);
    }

    Logger.info('Start _canExit.');

    if (router) {
      sequence = _buildCanExitSequence(router, null);
      if (sequence === null) {
        sequence = Promise.resolve(true);
      } else {
        sequence = sequence.then(function (result) {
          return result && !isTransitionCancelled();
        });
      }
    } else {
      sequence = Promise.resolve(true);
    }

    return sequence;
  }

  /**
   * Return a promise returning an object with an array of all the changes and the origin if all of
   * the new state in the allChanges array can enter.
   * @private
   * @param {!Array.<_StateChange>} allChanges
   * @param {string=} origin a string specifying the origin of the transition ('sync', 'popState')
   * @return {!Promise} a promise returning an object with an array of all the changes and the origin.
   */
  function _canEnter(allChanges, origin) {
    if (isTransitionCancelled()) {
      return Promise.resolve();
    }

    Logger.info('Start _canEnter.');

    var sequence = null;

    // Build a chain of canEnter promise for each state in the array of changes
    allChanges.forEach(function (change) {
      var newState = change.getState();

      // It is allowed to transition to an undefined state, but no state
      // callback need to be executed.
      if (newState) {
        sequence = _chainCallback(newState._canEnter, sequence, 'canEnter', newState._id);
      }
    });

    if (sequence === null) {
      sequence = Promise.resolve({ allChanges: allChanges, origin: origin });
    } else {
      sequence = sequence.then(function (result) {
        var returnObj;

        if (result && !isTransitionCancelled()) {
          returnObj = { allChanges: allChanges, origin: origin };
        }

        return returnObj;
      });
    }

    return sequence;
  }

  /**
   * Update the state of a router with the new value.
   * @private
   * @param {{value:string, router:!oj.Router}} change
   * @param {string | undefined} origin
   */
  function _update(change, origin) {
    var oldState = change.router._getStateFromId(_getShortId(change.router._stateId()));
    var newState = change.getState();

    return (
      Promise.resolve()
        .then(function () {
          if (Logger.option('level') === Logger.LEVEL_INFO) {
            Logger.info(
              'Updating state of %s to %s.',
              getRouterFullName(change.router),
              change.value
            );
          }
        })
        // Execute exit on the current state
        .then(oldState ? oldState._exit : undefined)
        .then(function () {
          var rt = change.router;
          var goingBackward = false;

          // Are we going back to the previous state?
          if (origin === 'popState') {
            var length = rt._navHistory.length;
            var i;
            // Are we going back to the previous state?
            for (i = length - 1; i >= 0; i--) {
              if (rt._navHistory[i] === change.value) {
                goingBackward = true;
                // Delete all elements up the one matching
                rt._navHistory.splice(i, length - i);
                break;
              }
            }

            // Back only if going back 1
            if (length - i === 1) {
              rt._navigationType = 'back';
            }
          }

          if (!goingBackward) {
            delete rt._navigationType;
            rt._navHistory.push(_getShortId(rt._stateId()));
          }

          // Update the parameters
          if (change.value && newState) {
            var segments = _getSegments(change.value);
            newState._paramOrder.forEach(function (name, ii) {
              var newValue = _decodeSlash(segments[ii + 1]);
              var oldValue = newState[_parametersValue][name];

              // Update the parameter value
              if (newValue !== oldValue) {
                newState[_parametersValue][name] = newValue;
              }
            });

            // TODO: Should we execute a callback for case where state doesn't change
            //      and using a configure with function? or disable for function configure?
          }

          // Change the value of the stateId
          rt._stateId(change.value);
        })
        // Execute enter on the new state
        .then(newState ? newState._enter : undefined)
    );
  }

  /**
   * Update the state of all routers in the change array.
   * @private
   * @param {Object} updateObj
   * @return {!Promise}
   */
  function _updateAll(updateObj) {
    if (!updateObj) {
      return Promise.resolve(_NO_CHANGE_OBJECT);
    }

    var sequence = Promise.resolve().then(function () {
      Logger.info('Entering _updateAll.');
      oj.Router._updating = true;
    });

    var oldState;
    var allChanges = updateObj.allChanges;
    allChanges.forEach(function (change) {
      oldState = change.router.currentState.peek();
      sequence = sequence.then(function () {
        if (!isTransitionCancelled()) {
          return _update(change, updateObj.origin);
        }
        return undefined;
      });
    });

    return sequence.then(
      function () {
        var hasChanged = false;
        var router;
        var newState;
        if (allChanges.length) {
          hasChanged = !isTransitionCancelled();
          /*
           * Pass the last state of a multi-state transition as the new state to
           * which we're transitioning.
           */
          var change = allChanges[allChanges.length - 1];
          router = change.router;
          newState = change.state;
        }
        oj.Router._updating = false;
        Logger.info('_updateAll returns %s.', String(hasChanged));
        return {
          hasChanged: hasChanged,
          router: router,
          oldState: oldState,
          newState: newState
        };
      },
      function (error) {
        oj.Router._updating = false;
        return Promise.reject(error);
      }
    );
  }

  /**
   * Update the state using the current URL.
   * @private
   * @param {string=} origin the transition origin
   * @return a Promise that resolves when the routers state are updated
   */
  function parseAndUpdate(origin) {
    var allChanges;

    try {
      allChanges = _urlAdapter.parse();

      // Only keep changes where the value doesn't match the router state
      allChanges = _filterNewState(allChanges);
    } catch (error) {
      return Promise.reject(error);
    }

    return _canEnter(allChanges, origin).then(_updateAll);
  }

  /**
   * Log the action and transaction as Logger.info.
   * @param       {string} action     The action performed
   * @param       {Object} transition The router transition.  The transition object
   * contains the following properties:
   * - {string} path The path to where the transition is occurring
   * - {string} origin The origin of the transition.  Will be one of, "sync", "go",
   *   "popState"
   * - {oj.Router} router The instance of the router performing the transition
   * - {string} historyUpdate A string indicating how the router should update the
   *   browser history.  Possible values are, "skip" or "replace"
   *   updated
   * @private
   */
  function _logTransition(action, transition) {
    if (Logger.option('level') === Logger.LEVEL_INFO) {
      var path = transition.path ? 'path=' + transition.path : '';
      var deferString = transition.deferredHandling ? 'deferredHandling=true' : '';
      var router = transition.router ? getRouterFullName(transition.router) : 'null';
      Logger.info(
        '>> %s: origin=%s router=%s %s %s',
        action,
        transition.origin,
        router,
        path,
        deferString
      );
    }
  }

  /**
   * Execute a transition. There are 3 types of transitions depending if they are
   * called from go, sync or handlePopState.
   * @private
   * @param  {Object} transition An object with properties describing the transition.
   * @return A Promise that resolves when the router is done with the state transition.
   */
  function _executeTransition(transition) {
    _logTransition('Executing', transition);

    if (!transition.deferredHandling) {
      // if the transition originate from a sync call, don't call canExit
      if (transition.origin === 'sync') {
        return parseAndUpdate();
      } else if (transition.origin === 'popState') {
        return _canExit(transition.router).then(function (canExit) {
          if (canExit) {
            return parseAndUpdate(transition.origin);
          }
          return Promise.resolve(_NO_CHANGE_OBJECT);
        });
      }
    }
    return transition.router._go(transition);
  }

  /**
   * Executes first transition on the queue then unqueue then recurse.
   * @private
   */
  function _resolveTransition() {
    var transition = _transitionQueue[0];
    var promise;

    _logTransition('Resolving', transition);

    if (transition.cancel) {
      _logTransition('Cancelled', transition);
      promise = Promise.resolve(_NO_CHANGE_OBJECT);
    } else {
      promise = _executeTransition(transition);
    }

    return promise.then(
      function (params) {
        var done = _transitionQueue.shift();
        _logTransition('Done with', done);
        if (params[_HAS_CHANGED] === true) {
          // Build the window title that will appear in the browser history
          var titleInfo = _buildTitle(rootRouter);
          var title;

          if (titleInfo.title !== '') {
            title = titleInfo.title;
          } else if (_originalTitle && _originalTitle.length > 0) {
            title = _originalTitle;
            if (titleInfo.segment !== '') {
              title += _TITLE_SEP + titleInfo.segment;
            }
          } else {
            title = titleInfo.segment;
          }

          if (title !== window.document.title) {
            window.document.title = title;
          }
        }
        dispatchTransitionedToState(params);
        return params;
      },
      function (error) {
        _transitionQueue = [];
        Logger.error('Error when executing transition: %o', error);
        dispatchTransitionedToState(_NO_CHANGE_OBJECT);
        return Promise.reject(error);
      }
    );
  }

  /**
   * Queue a transition. It will execute as soon as previous transitions in the
   * queue are done.
   * @private
   * @param  {Object} transition An object with properties describing the transition
   * @return A Promise that resolves when the router is done with the given state transition.
   */
  function _queueTransition(transition) {
    _logTransition('Queuing  ', transition);

    // var path = transition.path;
    // var bc = oj.Context.getPageContext().getBusyContext();
    // Disabling the state due to  - OJ.TESTS.ROUTER.SAMPLEOJMODULETEST FAILS
    // var removeBusyState = bc.addBusyState({description:'router transitioning to new state "'+path+'"'});

    // Push new transition at the end. Current transition is always at index 0
    var length = _transitionQueue.push(transition);

    // Simple case when the transition is the only one in the queue.
    if (length === 1) {
      _queuePromise = _resolveTransition();
    } else {
      // Cancel transition in queue and chain it
      var lastTransition = _transitionQueue[length - 2];
      // Don't cancel transitions from popstate event or for deferred path
      if (!lastTransition.deferredHandling) {
        _logTransition('Cancelling', lastTransition);
        lastTransition.cancel = true;
      }
      _queuePromise = _queuePromise.then(_resolveTransition);
    }

    return _queuePromise;
    // .then(function(result) {
    //     removeBusyState();
    //     return result;
    // }, function(error) {
    //     removeBusyState();
    //     return _queuePromise;
    // });
  }

  /**
   * @class
   * @requires ojs/ojcore
   * @since 1.1.0
   * @ojtsmodule
   * @classdesc
   * <h3>JET Router</h3>
   * <p>The router is designed to simplify writing navigation for Single Page Applications.
   * The approach taken is to think of navigation in terms of states and transitions instead
   * of URLs and hashes. A router is always in one in a number of possible states and when
   * a UI action is taken in the application, a transition between states is executed. The
   * router is responsible to properly format the URL to reflect the current state and to
   * restore the application to the matching state when the URL changes.
   * <p>Building navigation is done in three steps:
   * <h6>Define the states that can be taken by the router:</h6>
   * <pre class="prettyprint"><code>
   * var router = oj.Router.rootInstance;
   * // Add three states to the router with id 'home', 'book' and 'tables
   * router.configure({
   *    'home':   { label: 'Home',   value: 'homeContent', isDefault: true },
   *    'book':   { label: 'Book',   value: 'bookContent' },
   *    'tables': { label: 'Tables', value: 'tablesContent' }
   * });
   *
   * var viewModel = {
   *    router: router
   * };
   *
   * oj.Router.sync().then(
   *    function() {
   *       ko.applyBindings(viewModel);
   *    },
   *    function(error) {
   *       Logger.error('Error when starting router: ' + error.message);
   *    });
   * </code></pre>
   *
   * <h6>Trigger a state transition when user ask to navigate:</h6>
   * <pre class="prettyprint"><code>
   * &lt;div id="routing-container">
   *    &lt;div id='buttons-container'>
   *      &lt;oj-bind-for-each data="[[router.states]]">
   *        &lt;template>
   *          &lt;!-- Use the go function of the state as the handler for a click binding -->
   *          &lt;oj-button :id="[[$current.data.id]]" on-oj-action="[[go]]">
   *            &lt;oj-bind-text value="[[$current.data.label]]">&lt;/oj-bind-text>
   *          &lt;/oj-button>
   *        &lt;/template>
   *      &lt;/oj-bind-for-each>
   *    &lt;/div>
   * &lt;/div>
   * </code></pre>
   *
   * <h6>Listen to the state change and updates the dependent parts:</h6>
   * <pre class="prettyprint"><code>
   * &lt;!-- Display the content of the current state -->
   * &lt;h2 id="pageContent">
   *   &lt;oj-bind-text value="[[router.currentValue]]">&lt;/oj-bind-text>
   * &lt;/h2>
   * </code></pre>
   *
   * @desc
   * A Router cannot be instantiated. A static Router is created when the module is loaded and can be
   * accessed using the method {@link oj.Router.rootInstance|rootInstance}.
   * A child router can be created using the method {@link oj.Router#createChildRouter|createChildRouter}.
   * @see oj.Router.rootInstance
   * @see oj.Router#createChildRouter
   * @constructor
   * @hideconstructor
   * @export
   * @ojtsimport {module: "ojrouterstate", type: "AMD", imported:["RouterState"]}
   * @ojtsimport knockout
   * @ojtsimport signals
   * @ojdeprecated {since: '9.0.0', value:['CoreRouter']}
   */
  oj.Router = function (key, parentRouter, parentState) {
    var router = this;

    /**
     * A string identifier of the router. It is required the name is unique within all the
     * sibling routers.
     * @name oj.Router#name
     * @member
     * @readonly
     * @type {!string}
     * @see oj.Router#createChildRouter
     */
    this._name = key;

    /**
     * The state of the parent router when this router is current.
     * @private
     * @type {!string | undefined}
     */
    this._parentState =
      parentState || (parentRouter ? _getShortId(parentRouter._stateId()) : undefined);

    /**
     * The parent router. Root router doesn't have one.
     * @private
     * @type {oj.Router | undefined}
     */
    this._parentRouter = parentRouter;

    /**
     * Array of child router.
     * @private
     * @type {Array.<oj.Router>}
     */
    this._childRouters = [];

    /**
     * Used to store the bookmarkable data.
     * @private
     * @type {Object|undefined}
     */
    this._extra = undefined;

    /**
     * A Knockout observable for the id of the current state of the router.
     * @private
     */
    this._stateId = ko.observable();

    /**
     * A Knockout observable for the id of the current state.<br>
     * <code class="prettyprint">stateId()</code> returns the string id.<br>
     * <code class="prettyprint">stateId('book')</code> transitions the router to
     * the state with id 'book'.<br>
     * It is convenient to use the stateId observable when working with component
     * with 2-way binding like {@link oj.ojButtonsetOne#value|value} for
     * <code class="prettyprint">ojButtonset</code> or
     * {@link oj.ojNavigationList#selection|selection} for
     * <code class="prettyprint">ojNavigationList</code> because it does not
     * require a click on optionChange handler (See example below).
     * @name oj.Router#stateId
     * @type {function(string=): string}
     * @readonly
     *
     * @example <caption>A buttonSet using the router stateId for 2-way binding:</caption>
     * &lt;oj-buttonset-one value="{{router.stateId}}">
     *    &lt;oj-bind-for-each data="[[router.states]]">
     *      &lt;template>
     *        &lt;oj-option value="[[$current.data.id]]">
     *          &lt;span>&lt;oj-bind-text value="$current.data.label">&lt;/oj-bind-text>&lt;/span>
     *        &lt;/oj-option>
     *      &lt;/template>
     *    &lt;/oj-bind-for-each>
     * &lt;/oj-buttonset-one&gt;
     *
     */
    this._stateIdComp = ko.pureComputed({
      read: function () {
        // Return only the significant part of the id, the part without the state parameters.
        return _getShortId(this._stateId());
      },
      write: function (value) {
        this.go(value).then(null, function (error) {
          throw error;
        });
      },
      owner: router
    });

    /**
     * An array of all the possible states of the router. This array is null if the router is configured
     * using a callback.
     * @name oj.Router#states
     * @type {Array.<oj.RouterState>|null}
     * @readonly
     * @see oj.RouterState
     */
    this._states = null;

    /**
     * The state id of the default state for this router. The value is set when
     * {@link oj.Router#configure|configure} is called on the router and the state isDefault property is true.
     * If it is undefined, the router will start without a state selected.
     * This property is writable and can be used to set the default state id when
     * the router is configured using a callback.
     * @name oj.Router#defaultStateId
     * @type {string|undefined}
     */
    this._defaultStateId = undefined;

    /**
     * A Knockout observable on the current {@link oj.RouterState|RouterState} object.
     * @name oj.Router#currentState
     * @type {function():(oj.RouterState|undefined)}
     * @readonly
     *
     * @example <caption>Hide a panel when the state of the router is not yet defined:</caption>
     *    &lt;oj-bind-if test="[[router.currentState()]]"&gt;
     *       &lt;!-- content of the panel --&gt;
     *    &lt;/oj-bind-if&gt;
     */
    this._currentState = ko.pureComputed(function () {
      var shortId = _getShortId(router._stateId());
      return ko.ignoreDependencies(router._getStateFromId, router, [shortId]);
    });

    /**
     * A Knockout observable on the value property of the current state.<br>
     * The state value property is the part of the state object that will be used in the application.
     * It is a shortcut for <code class="prettyprint">router.currentState().value;</code>
     * @name oj.Router#currentValue
     * @type {function():(string|undefined)}
     * @readonly
     *
     * @example <caption>Display the content of the current state:</caption>
     * &lt;h2 id="pageContent">
     *   &lt;oj-bind-text value="[[router.currentValue]]">&lt;/oj-bind-text>
     * &lt;/h2>
     */
    this._currentValue = ko.pureComputed(function () {
      var shortId = _getShortId(router._stateId());
      var retValue;
      var currentState = ko.ignoreDependencies(router._getStateFromId, router, [shortId]);
      if (currentState) {
        retValue = currentState.value;
      }
      return retValue;
    });

    /**
     * The current navigation direction of the router, used for module animations.
     * The value will either be undefined if navigating forward, or "back" if
     * navigating backwards.
     * This is the same value available as part of {@link oj.Router#moduleConfig|moduleConfig}.
     * @name oj.Router#direction
     * @type {string|undefined}
     * @readonly
     * @since 5.0.0
     *
     */
    this._navigationType = undefined;

    /**
     * Keep track for history to managed the animation direction
     * @private
     * @type {Array}
     */
    this._navHistory = [];

    /**
     * An object used to pass Router information to ojModule in the moduleConfig
     * object.
     * @ignore
     * @constructor
     * @private
     */
    function _RouterParams() {
      Object.defineProperties(this, {
        parentRouter: {
          value: router,
          enumerable: true
        },
        direction: {
          get: function () {
            return router._navigationType;
          },
          enumerable: true
        }
      });
    }

    /**
     * An object to simplify integration between ojRouter and ojModule.
     * Use this object to configure an ojModule where the module name is the router
     * state. When the router changes state, ojModule will automatically load and
     * render the content of a new module based on the name specified in the
     * {@link oj.RouterState#value|value} or {@link oj.RouterState#id|id} property
     * of the current {@link oj.RouterState|RouterState}.<br>
     * The object moduleConfig provides the following functionality to the ojModule binding:
     * <ol>
     *   <li>it defines the name of the module by setting the <code class="prettyprint">name</code>
     * option to the value of the current router state.</li>
     *   <li>it makes the parent router accessible to the module using the
     * <code class="prettyprint">params['ojRouter']['parentRouter']</code> property.</li>
     *   <li>it defines a direction hint that can be use for the module animation.</li>
     *   <li>it makes the callback <code class="prettyprint">canExit</code> invokable on the
     * viewModel. If <code class="prettyprint">canExit</code> is not defined on the viewModel,
     * it will be invoked on the {@link oj.RouterState|RouterState}.</li>
     * </ol>
     * The moduleConfig object has the following properties:
     * <ul>
     *   <li><code class="prettyprint">name</code>: is set to the {@link oj.RouterState#value|value}
     * property of the current state of the router.  If a current state is not defined, the default
     * state is used and if the default state is not defined, the first state is used. On the
     * state object, if the <code class="prettyprint">value</code> is not defined or if it is
     * not a string, the {@link oj.RouterState#id|id} property is used.</li>
     *   <li><code class="prettyprint">params</code>: an object with a property named
     * <code class="prettyprint">ojRouter</code> which value is a object with two properties
     * <code class="prettyprint">parentRouter</code> which value is the parent router and
     * <code class="prettyprint">direction</code> which value is undefined or the string 'back'. In
     * JET version 1.1, the parent router was the entire params object making it impossible to pass
     * any other parameters. Application built using version 1.1 of JET now need to retrieve
     * the parent router from the <code class="prettyprint">ojRouter.parentRouter</code> property of
     * <code class="prettyprint">params</code>.</li>
     *   <li><code class="prettyprint">lifecycleListener</code>: an object implementing the
     * <code class="prettyprint">attached</code> callback to bind canExit to the router if it is
     * defined on the viewModel. If you override <code class="prettyprint">attached</code>, this
     * functionality will be lost unless you set the viewModel to the current state of the parent
     * router in your custom <code class="prettyprint">attached</code> implementation.</li>
     * </ul>
     *
     * The router calculate the direction of the navigation and make it available to the child module
     * using the parameter <code class="prettyprint">ojRouter.direction</code>.<br> This can be used
     * to specify a different module animation when going 'back'. The value of direction is either
     * undefined or 'back'. It is 'back' when the state transition is caused by a back button on the
     * browser and the new state is equal to the previous state.

     * To customize the behavior of the moduleduleConfig object, it is possible to create your own
     * moduleConfig and merge other properties or modifies the value of existing properties.
     *
     * @name oj.Router#moduleConfig
     * @type {Object}
     * @readonly
     * @property {ko.Observable<string>} name
     * @property {Object} params
     * @property {Object} params.ojRouter
     * @property {oj.Router} params.ojRouter.parentRouter
     * @property {string} params.ojRouter.direction
     * @property {Object} lifecycleListener
     * @property {function(any):void} lifecycleListener.attached
     *
     * @example <caption>Configure an ojModule binding with a router</caption>
     * &lt;!-- This is where your main page content will be loaded --&gt;
     * &lt;div id="mainContainer" data-bind="ojModule: router.moduleConfig"&gt;&lt;/div&gt;
     *
     * @example <caption>Creates a child router in the viewModel of a module</caption>
     * var viewModel = {
     *    initialize: function(params) {
     *       // Retrieve the parent router from the parameters
     *       var parentRouter = params.valueAccessor().params['ojRouter']['parentRouter'];
     *       // Create a child router for this viewModel
     *       this.router = parentRouter.createChildRouter('chapter')
     *          .configure({
     *             'preface':  { label: 'Preface',   value: storage['preface']  },
     *             'chapter1': { label: 'Chapter 1', value: storage['chapter1'] },
     *             'chapter2': { label: 'Chapter 2', value: storage['chapter2'] },
     *             'chapter3': { label: 'Chapter 3', value: storage['chapter3'] }
     *          });
     *       oj.Router.sync();
     *    },
     *
     *    // canExit callback will be called here
     *    canExit: function() {
     *       return (okToExit) ? true: false;
     *    }
     * };
     */
    this._moduleConfig = Object.create(null, {
      name: {
        value: ko.pureComputed(function () {
          var retValue;

          // ojModule name cannot afford to be null
          var stateId =
            _getShortId(this._stateId()) || this._defaultStateId || this._states[0].name;
          var currentState = this._getStateFromId(stateId);
          if (currentState) {
            retValue = currentState.value;
            if (!retValue || typeof retValue !== 'string') {
              retValue = currentState._id;
            }
          }
          return retValue;
        }, router),
        enumerable: true
      },
      params: {
        value: Object.create(null, {
          ojRouter: {
            value: new _RouterParams(),
            enumerable: true
          }
        }),
        enumerable: true
      },
      lifecycleListener: {
        value: {
          attached: function (params) {
            var state = router.currentState();
            if (state) {
              state.viewModel = params.viewModel;
            }
          },
          enumerable: true
        },
        enumerabl: true
      }
    });

    /**
     * @typedef {object} oj.Router.ModuleConfigType
     * @property {ko.Observable<string>} name The value of the current state.  See {@link oj.Router#currentValue}
     * @property {Object} params
     * @property {Object} params.ojRouter
     * @property {oj.Router} params.ojRouter.parentRouter A reference to the current router
     * @property {string} params.ojRouter.direction The animation direction of the module, if defined.
     * @property {Object} params.ojRouter.parameters An object containing the observable parameters of the current router state.
     * @property {Object} lifecycleListener
     * @property {function(any):void} lifecycleListener.attached The 'attached' listener for the module
     * @ojsignature [{ target: "Type", value: "{[key:string]:any}", for: "params.ojRouter.parameters" }]
     */

    /**
     * Similar to {@link oj.Router#moduleConfig}, this object is meant to be used to configure
     * a module binding which reacts to changes in the router state or its parameters.
     * This configuration also creates observables around all of the
     * {@link oj.RouterState#parameters} found in the router state.
     <p>
     This observable is dyanmically created only when it's first requested.  To
     use observableModuleConfig and its observable parameters, first reference
     the property in your own code, which
     will setup the observable and add observable state parameters.  To use
     the observable parameters, retrieve the instance from the parameters passed
     to your view model.
     </p>
     @example <caption>Use observable parameters</caption>
     var root = oj.Router.rootInstance;
     root.configure(...);
     var mc = root.observableModuleConfig;
     ...
     function ViewModel(viewParams) {
        var router = viewParams['ojRouter']['parentRouter'];
        var currentState = router.currentState();
        // Retrieve object containing observable parameters
        var params = viewParams['ojRouter']['parameters'];
        var employeeId = params['employeeId'];
        // Get an observable parameter's value
        var idValue = employeeId();

        // Optionally subscribe to a parameter's value change
        employeeId.subscribe(function(newId) {
        });
     }
     * @name oj.Router#observableModuleConfig
     * @type {Object}
     * @since 4.2.0
     * @readonly
     *
     * @ojsignature {target: "Type", value: "ko.Observable<oj.Router.ModuleConfigType>", jsdocOverride: true}
     */
    this._getObservableModuleConfig = function () {
      if (!this._observableModuleConfig) {
        var stateObservable = router.currentState;
        var initialState = stateObservable.peek();
        var omc = ko.observable(_getConfigObject(initialState, router));
        // Subscribe to the changes and update omc appropriately
        stateObservable.subscribe(function (state) {
          var omcObject = omc.peek();
          var oldName = omcObject.name;
          var newName = _getNameFromState(state);
          if (oldName !== newName) {
            omc(_getConfigObject(state, router)); // all new config value when the name changes
          } else {
            // update parameters only
            _updateConfigObject(state, omcObject);
          }
        });
        this._observableModuleConfig = omc;
      }
      return this._observableModuleConfig;
    };

    function _getConfigObject(currentState, _router) {
      var obj = {
        name: _getNameFromState(currentState),
        params: {
          ojRouter: {
            parentRouter: _router,
            get direction() {
              return _router._navigationType;
            }
          }
        }
      };
      obj.params.ojRouter[_parametersValue] = {};
      if (currentState) {
        _updateConfigObject(currentState, obj);

        obj.lifecycleListener = {
          attached: _router.moduleConfig.lifecycleListener.attached
        };
      }

      return obj;
    }

    function _updateConfigObject(currentState, config) {
      var params = config.params.ojRouter[_parametersValue];
      var stateParams = currentState[_parametersValue];
      var paramKeys = Object.keys(stateParams);
      paramKeys.forEach(function (paramKey) {
        var value = stateParams[paramKey];
        var setter = params[paramKey];
        if (!setter) {
          setter = ko.observable();
          params[paramKey] = setter;
        }
        setter(value);
      });
    }

    function _getNameFromState(currentState) {
      var name;
      if (currentState) {
        name = currentState.value;
        if (!name || typeof name !== 'string') {
          name = currentState._id;
        }
      }
      return name;
    }

    Object.defineProperties(this, {
      parent: {
        /**
         * The parent router if it exits.
         * Only the 'root' router does not have a parent router.
         * @name oj.Router#parent
         * @member
         * @type {oj.Router|undefined}
         * @readonly
         */
        value: this._parentRouter,
        enumerable: true
      }
    });
  };

  Object.defineProperties(oj.Router.prototype, {
    name: {
      get: function () {
        return this._name;
      },
      enumerable: true
    },
    states: {
      get: function () {
        return this._states;
      },
      enumerable: true
    },
    stateId: {
      get: function () {
        return this._stateIdComp;
      },
      enumerable: true
    },
    currentState: {
      get: function () {
        return this._currentState;
      },
      enumerable: true
    },
    currentValue: {
      get: function () {
        return this._currentValue;
      },
      enumerable: true
    },
    direction: {
      get: function () {
        return this._navigationType;
      },
      enumerable: true
    },
    defaultStateId: {
      get: function () {
        return this._defaultStateId;
      },
      set: function (newValue) {
        this._defaultStateId = newValue;
      },
      enumerable: true
    },
    moduleConfig: {
      get: function () {
        return this._moduleConfig;
      },
      enumerable: true
    },
    observableModuleConfig: {
      get: function () {
        return this._getObservableModuleConfig();
      },
      enumerable: true
    }
  });

  /**
   * Create the instance of the root router.
   */
  rootRouter = new oj.Router(_DEFAULT_ROOT_NAME, undefined, undefined);

  /**
   * Function use to handle the popstate event.
   */
  function handlePopState() {
    var sId = _getShortId(rootRouter._stateId());
    var subRouter = null;

    Logger.info('Handling popState event with URL: %s', _location.href);

    // First retrieve the sub-router associated with the current state, if there is one.
    if (sId) {
      for (var i = 0; i < rootRouter._childRouters.length; i++) {
        var sr = rootRouter._childRouters[i];
        if (sId === sr.parent.stateId()) {
          subRouter = sr;
          break;
        }
      }
    }

    _queueTransition({ router: subRouter, origin: 'popState' });
  }

  /**
   * Return a child router by name.  The name is the value given to
   * {@link oj.Router#createChildRouter|createChildRouter}.
   * @param  {!string} name The name of of the child router to find
   * @return {oj.Router|undefined} The child router
   * @since 1.2.0
   * @export
   */
  oj.Router.prototype.getChildRouter = function (name) {
    var childRouter;

    if (name && typeof name === 'string') {
      var trimmedName = name.trim();
      if (trimmedName.length > 0) {
        this._childRouters.every(function (sr) {
          if (sr._name === trimmedName) {
            childRouter = sr;
            return false;
          }
          return true;
        });
      }
    }

    return childRouter;
  };

  /**
   * Get the child router associated with the parent's current state.  See
   * {@link oj.Router#createChildRouter|createChildRouter} for details on how child routers are associated
   * with parent states.
   * @return {oj.Router|undefined} The child router for the current state, if defined.
   * @since 5.0.0
   * @export
   *
   */
  oj.Router.prototype.getCurrentChildRouter = function () {
    var sId = _getShortId(this._stateId() || this._defaultStateId);
    return _getChildRouter(this, sId);
  };

  /**
   * Create a child router with the given name. A router can either have one child
   * router that handles all possible states, or one child router per state.
   * See the examples below.
   * @param {!string} name The unique name representing the router.  The name is
   * used by the function {@link oj.Router#getChildRouter|getChildRouter} to retrieve
   * the child router.
   * @param {string=} parentStateId The state Id of the parent router for determining
   * when this child router is used.
   * If not defined, the child router is created for the current state of the router.
   * @return {oj.Router} the child router
   * @throws An error if a child router exist with the same name or if the current
   * state already has a child router.
   * @export
   * @example <caption>
   * <b>Create a default child router for the parent</b>
   * In this example, the parent router is assumed to have no current state (it
   * has not yet navigated to any particular state). Since we are not specifying a
   * value for parentStateId, the newly created router will be the default child
   * router.
   * </caption>
   * // Parent router has no current state
   * router = oj.Router.rootInstance;
   * // This child router is the default child router for all parent router states
   * childRouter = router.createChildRouter('chapter');
   * @example <caption>
   * <b>Create a child router for the root's current state</b>
   * In this example, the parent has navigated to a state before the child router
   * is created.  Even though no value is given for parentStateId, the child router
   * is only used when the parent is in the particular state.
   * </caption>
   * // Parent router navigates to a given state
   * router = oj.Router.rootInstance;
   * router.go('book').then(function(result) {
   *   if (result.hasChanged) {
   *     // Child router is only used when parent router's state is 'book'
   *     // because parent now has a current state
   *     var childRouter = router.createChildRouter('chapter');
   *   }
   * });
   * @example <caption>
   * <b>Create a child router for parent state id 'book'</b>
   * In this example, the parent router hasn't yet navigated to a particular state
   * but the child specifies 'book' as its parentStateId, therefore, the child will
   * only be used when the parent is in that particular state.
   * </caption>
   * // Parent router has no current state
   * router = oj.Router.rootInstance;
   * // Child router is only used when parent router's state is 'book'
   * childRouter = router.createChildRouter('chapter', 'book');
   */
  oj.Router.prototype.createChildRouter = function (name, parentStateId) {
    var childRouter;

    oj.Assert.assertString(name);

    var _parentStateId = parentStateId || _getShortId(this._stateId());

    var encodedName = encodeURIComponent(name.trim());
    // Make sure it doesn't already exist.
    for (var i = 0; i < this._childRouters.length; i++) {
      var sr = this._childRouters[i];
      if (sr._name === encodedName) {
        throw new Error('Invalid router name "' + encodedName + '", it already exists.');
      } else if (sr._parentState === _parentStateId) {
        throw new Error(
          'Cannot create more than one child router for parent state id "' + sr._parentState + '".'
        );
      }
    }

    childRouter = new oj.Router(encodedName, this, _parentStateId);

    this._childRouters.push(childRouter);

    return childRouter;
  };

  /**
   * @private
   * @param {string} stateId The state id.
   * @return {oj.RouterState | undefined} The state object.
   */
  oj.Router.prototype._getStateFromId = function (stateId) {
    var state;
    if (this._stateFromIdCallback) {
      state = this._stateFromIdCallback(stateId);
      // If return is a config object, instantiate RouterState with it
      if (state && !(state instanceof oj.RouterState)) {
        state = new oj.RouterState(stateId, state, this);
      }
    } else {
      state = getStateFromId(this, stateId);
    }
    return state;
  };

  /**
   * Configure the states of the router. The router can be configured in two ways:
   * <ul>
   *  <li>By describing all of the possible states that can be taken by this router.</li>
   *  <li>By providing a callback returning a {@link oj.RouterState|RouterState}
   *      object given a string state id.</li>
   * </ul>
   * This operation resets any previous configuration, and is chainable.<br>
   * Configuring {@link oj.RouterState#parameters router state parameters} should
   * be done here.  See the example below.
   *
   * @param {!(Object.<string, {oj.RouterState.ConfigOptions}> |
   *         function(string): (oj.RouterState | undefined)) } option
   * Either a callback or a dictionary of states.
   * <h6>A callback:</h6>
   * <h4 id="stateFromIdCallback" class="name">
   *    stateFromIdCallback
   *    <span class="signature">(stateId)</span>
   *    <span class="type-signature">
   *        {<a href="oj.RouterState.html">oj.RouterState</a>|undefined}
   *    </span>
   * </h4>
   * A function returning a {@link oj.RouterState|RouterState} given a string state id.<br>
   * When using a callback, the {@link oj.Router#states|states} property will always be null since
   * states are defined on the fly.<br>See second example below.
   * <h6>A dictionary of states:</h6>
   * It is a dictionary in which the keys are state {@link oj.RouterState#id|id}s and values are objects
   * defining the state.  Note that the forward slash character '/' is not allowed
   * in the state Id.  See {@link oj.RouterState.ConfigOptions|ConfigOptions}.<br>See first example below.
   * <h6>Key</h6>
   * <table class="params">
   *   <thead><tr>
   *     <th>Type</th>
   *     <th class="last">Description</th>
   *   </tr></thead>
   *   <tbody>
   *     <tr>
   *       <td class="type">
   *         <span class="param-type">string</span>
   *       </td>
   *       <td class="description last">the state id.
   *       See the RouterState <a href="oj.RouterState.html#id">id</a> property.</td>
   *    </tr>
   *    <tr>
   *      <td class="type">
   *        <span class="param-type">oj.RouterState.ConfigOptions</span>
   *      </td>
   *      <td class="value">
   *        <span class="param-type">See {@link oj.RouterState.ConfigOptions|ConfigOptions}
   *        for the options available for configuring router states</span>
   *      </td>
   *   </tbody>
   * </table>
   * @return {Router}
   * @export
   * @see oj.RouterState
   * @ojsignature { target:'Type',
   *              value: '{[key:string]: oj.RouterState.ConfigOptions}|((id:string)=> oj.RouterState|oj.RouterState.ConfigOptions|undefined|null)',
   *              for: 'option'}
   * @example <caption>Add three states with id 'home', 'book' and 'tables':</caption>
   * router.configure({
   *    'home':   { label: 'Home',   value: 'homeContent', isDefault: true },
   *    'book':   { label: 'Book',   value: 'bookContent' },
   *    'tables': { label: 'Tables', value: 'tablesContent' }
   * });
   * @example <caption>Configure dynamic states via callback function:</caption>
   * router.configure(function(stateId) {
   *    var state;
   *
   *    if (stateId) {
   *       state = { value: data[stateId] };
   *    }
   *    return state;
   * });
   * @example <caption>Configuring {@link oj.RouterState#parameters state parameters}:</caption>
   * router.configure({
   *    'home':   { label: 'Home',   value: 'homeContent', isDefault: true },
   *    'book/{chapter}/{paragraph}':   { label: 'Book',   value: 'bookContent' },
   * });
   */
  oj.Router.prototype.configure = function (option) {
    this._stateId(undefined);
    delete this._defaultStateId;
    // StateId are changing so erase history.
    this._navigationType = undefined;
    this._navHistory = [];

    if (typeof option === 'function') {
      this._states = null;
      // Override prototype
      this._stateFromIdCallback = option;
    } else {
      this._states = [];
      this._stateFromIdCallback = undefined;

      Object.keys(option).forEach(function (key) {
        var rsOptions = option[key];
        this._states.push(new oj.RouterState(key, rsOptions, this));
        // Set the defaultStateId of the router from the isDefault property
        if (typeof rsOptions.isDefault === 'boolean' && rsOptions.isDefault) {
          this._defaultStateId = _getShortId(key);
        }
      }, this);
    }

    return this;
  };

  /**
   * Return the {@link oj.RouterState} object which state id matches one of the possible states of the router.
   * @param {string} stateId - the id of the requested {@link oj.RouterState} object.
   * @return {oj.RouterState|undefined} the state object matching the id.
   * @export
   * @example <caption>Retrieve the RouterState for id 'home':</caption>
   * var homeState = router.getState('home');
   * var homeStateValue = homeState.value;
   */
  oj.Router.prototype.getState = function (stateId) {
    return this._getStateFromId(stateId);
  };

  /**
   * Initialize the default for oj.Router if needed. Dispose on the root router
   * will de-initialize.
   * @private
   */
  function _initialize() {
    if (!_initialized) {
      if (!_urlAdapter) {
        // eslint-disable-next-line new-cap
        _urlAdapter = new oj.Router.urlPathAdapter();
      }

      _urlAdapter.init(_baseUrlProp);

      _originalTitle = window.document.title;

      /**
       * Listen to URL changes caused by back/forward button
       * using the popstate event. Call handlePopState to dispatch the change of URL.
       */
      window.addEventListener(_POPSTATE, handlePopState, false);

      Logger.info('Initializing rootInstance.');
      Logger.info('Base URL is %s', _baseUrlProp);
      Logger.info('Current URL is %s', _location.href);

      _initialized = true;
    }
  }

  /**
   * Convert forward slash characters used for paths to a character which doesn't
   * require URL encoding (to save space in the URL) and is unambiguous from the
   * path separator.
   * @param       {string} value The string whose slash characters are to be encoded.
   * @return      {string}      An encoded form of the string
   * @private
   */
  function _encodeSlash(value) {
    var enc = value;
    if (enc && enc.replace) {
      enc = enc.replace(/~/g, '~0');
      enc = enc.replace(/\//g, '~1');
    }
    return enc;
  }

  /**
   * Given an encoded string from _encodeSlash, decode the characters to restore
   * the value to its original form.
   * @param       {string} value The string whose encoded slash values will be decoded.
   * @return      {string}      The decoded form of the string
   * @private
   */
  function _decodeSlash(value) {
    var dec = value;
    if (dec && dec.replace) {
      dec = dec.replace(/~1/g, '/');
      dec = dec.replace(/~0/g, '~');
    }
    return dec;
  }

  /**
   * Go is used to transition to a new state using a path made of state ids separated by a slash.  The
   * path can be absolute or relative.<br>
   * <br>
   * Example of valid path:
   * <ul>
   *   <li><code class="prettyprint">router.go('home')</code>: transition router
   *    to state id 'home'</li>
   *   <li><code class="prettyprint">router.go('/book/chapt2')</code>: transition
   *    the root instance to state id 'book' and the child router to state id
   *    'chapt2'</li>
   *   <li><code class="prettyprint">router.go('chapt2/edit')</code>: transition
   *   router to state id 'chapt2' and child router to state id 'edit'</li>
   *   <li><code class="prettyprint">router.go(['chapt2','edit'])</code>: equivalent
   *   to the previous transition, but using an array of path strings in place of
   *   forward slashes.
   * </ul>
   * <br>
   * If the stateIdPath argument is <code class="prettyprint">undefined</code> or an empty string, go
   * transition to the default state of the router.<br>
   * A {@link oj.Router.transitionedToState|transitionedToState} signal is
   * dispatched when the state transition has completed.
   * @param {(string|Array.<string>)=} stateIdPath A path of ids representing the state to
   * which to transition, separated by forward slashes (/).  This can also be an Array
   * of strings, each segment representing individual states.  An array is typically used
   * if the forward slash should be part of the state Id and needs to be distinguished
   * from the path separators.
   * @param {Object=} options - an object with additional information on how to execute the transition.
   * @param {string} options.historyUpdate Specify how the transition should act on the browser
   * history. If this property is not specified, a new URL is added to the history.<br>
   * <b><i>Supported Values:</i></b><br>
   * <code class="prettyprint">'skip'</code>: does not update the history with the new URL<br>
   * <code class="prettyprint">'replace'</code>: modifies the current history with the new URL
   * @return {!Promise.<{hasChanged: boolean}>} A Promise that resolves when the
   * router is done with the state transition.<br>
   * When the promise is fullfilled, the parameter value is an object with the property
   * <code class="prettyprint">hasChanged</code>.<br>
   * The value of <code class="prettyprint">hasChanged</code> is:
   * <ul>
   *   <li>true: If the router state changed.</li>
   * </ul>
   * When the Promise is rejected, the parameter value is:
   * <ul>
   *   <li>An Error object stipulating the reason for the rejection during the
   *   resolution. Possible errors are:
   *   <ul>
   *     <li>If stateIdPath is defined but is not of type string.</li>
   *     <li>If stateIdPath is undefined but the router has no default state.</li>
   *     <li>If a state id part of the path cannot be found in a router.</li>
   *   </ul>
   *   </li>
   * </ul>
   * @export
   * @example <caption>Transition a router to the state id 'home':</caption>
   * router.go('home');
   * @example <caption>Transition a router to its default state and handle errors:</caption>
   * router.go().then(
   *    function(result) {
   *       if (result.hasChanged) {
   *          Logger.info('Router transitioned to default state.');
   *       }
   *       else {
   *          Logger.info('No transition, Router was already in default state.');
   *       }
   *    },
   *    function(error) {
   *       Logger.error('Transition to default state failed: ' + error.message);
   *    }
   * );
   * @example <caption>Transition a router to state id 'stepB' without updating the URL:</caption>
   * wizardRouter.go('stepB', { historyUpdate: 'skip' });
   */
  oj.Router.prototype.go = function (stateIdPath, options) {
    _initialize();

    var optionsWithDefault = options || {};

    if (Array.isArray(stateIdPath)) {
      // eslint-disable-next-line no-param-reassign
      stateIdPath = stateIdPath.map(_encodeSlash).join('/');
    }

    return _queueTransition({
      router: this,
      path: stateIdPath,
      origin: 'go',
      historyUpdate: optionsWithDefault.historyUpdate
    });
  };

  /**
   * Internal go used by _executeTransition
   * @private
   * @param  {Object} transition An object with properties describing the transition
   * @return {any} A Promise that resolves when the routing is done
   */
  oj.Router.prototype._go = function (transition) {
    var newStates;
    var useDefault = true;
    var stateIdPath = transition.path;
    var replace = false;
    var skip = false;

    switch (transition.historyUpdate) {
      case 'skip':
        skip = true;
        break;
      case 'replace':
        replace = true;
        break;
      default:
        break;
    }

    if (stateIdPath) {
      if (typeof stateIdPath === 'string') {
        useDefault = false;
      } else {
        return Promise.reject(new Error('Invalid object type for state id.'));
      }
    }

    if (useDefault) {
      stateIdPath = this._defaultStateId;
      if (!stateIdPath) {
        // No default defined, so nowhere to go.
        Logger.info(function () {
          return 'Undefined state id with no default id on router ' + getRouterFullName(this);
        });
        return Promise.resolve(_NO_CHANGE_OBJECT);
      }
    }

    var path;
    // Absolute or relative?
    if (stateIdPath.charAt(0) === '/') {
      path = stateIdPath;
    } else {
      path = getCurrentPath(this._parentRouter);
      if (!path) {
        return Promise.reject(
          new Error(
            'Invalid path "' + stateIdPath + '". The parent router does not have a current state.'
          )
        );
      }
      path += stateIdPath;
    }

    Logger.info('Destination path: %s', path);

    try {
      newStates = _buildStateFromPath(this, path);
      newStates = _appendOtherChanges(newStates);
    } catch (err) {
      return Promise.reject(err);
    }

    // It is important that we do not call canEnter on state that we not going to enter so
    // only keep changes where the value doesn't match the current router state.
    // reducedState is an array of object with 2 properties, value and router.
    var reducedState = _filterNewState(newStates);

    // Only transition if replace is true or if the new state is different.
    // When replace is true, it is possible the states are the same (by example when going to the
    // default state of a child router) but the transition still need to be executed.
    if (replace || reducedState.length > 0) {
      Logger.info('Deferred mode or new state is different.');
      return _canExit(this).then(function (canExit) {
        if (canExit) {
          // Only calls canEnter callback on state that are changing
          return _canEnter(reducedState)
            .then(_updateAll)
            .then(function (params) {
              if (params[_HAS_CHANGED]) {
                if (skip) {
                  Logger.info('Skip history update.');
                } else {
                  var url = _urlAdapter.buildUrlFromStates(newStates);
                  Logger.info('%s URL to %s', replace ? 'Replacing' : 'Pushing', url);
                  window.history[replace ? 'replaceState' : 'pushState'](null, '', url);
                }
              }
              return params;
            });
        }
        return Promise.resolve(_NO_CHANGE_OBJECT);
      });
    }

    return Promise.resolve(_NO_CHANGE_OBJECT);
  };

  /**
   * Store additional data for this router that will be added in a compressed form to the URL
   * so it can be bookmarked. When calling this method, the URL is immediately modified.
   * @param {!Object} data the data to store with this state.
   * @throws An error if the bookmarkable state is too big.
   * @return {undefined}
   * @export
   * @ojsignature [{ target: "Type", for: "data", value: "{[key:string]:any}" }]
   * @example <caption>Store a color in the URL:</caption>
   * try {
   *    var color = '#99CCFF';
   *    router.store(color);
   *    $('#chapter').css('background', color);
   * }
   * catch (error) {
   *    Logger.error('Error while storing data: ' + error.message);
   * }
   */
  oj.Router.prototype.store = function (data) {
    this._extra = data;

    var extraState = {};
    var router = this;

    // Walk the parent routers
    while (router) {
      if (router._extra !== undefined) {
        extraState[router._name] = router._extra;
      }
      router = router._parentRouter;
    }

    // and the children routers
    router = this;
    var nextLevel;
    while (router) {
      for (var i = 0; i < router._childRouters.length; i++) {
        var sr = router._childRouters[i];
        var shortId = _getShortId(router._stateId());
        if (shortId && shortId === sr._parentState) {
          if (sr._extra !== undefined) {
            extraState[sr._name] = sr._extra;
          }
          nextLevel = sr;
          break;
        }
      }
      router = nextLevel;
      nextLevel = undefined;
    }

    window.history.replaceState(null, '', _buildUrl({}, extraState));
  };

  /**
   * Retrieve the additional data stored in the URL.
   * @return {any} the content stored in the URL
   * @ojsignature [{ target: "Type", for: "returns", value: "{[key:string]:any}" }]
   * @export
   * @example <caption>Retrieve the value of the background color stored in the URL:</caption>
   *  oj.Router.sync().then(
   *     function() {
   *        var color = viewModel.router.retrieve();
   *        if (color) {
   *           $('#chapter').css('background', color);
   *        }
   *     },
   *     function(error) {
   *        Logger.error('Error during sync: ' + error.message);
   *     }
   *  );
   */
  oj.Router.prototype.retrieve = function () {
    return this._extra;
  };

  /**
   * Dispose the router.<br>
   * Erase all states of this router and its children.
   * Remove itself from parent router child list.<br>
   * When this method is invoked on the {@link oj.Router.rootInstance|rootInstance}, it
   * also remove internal event listeners and re-initialize the
   * {@link oj.Router.defaults|defaults}.
   * @return {undefined}
   * @export
   */
  oj.Router.prototype.dispose = function () {
    // Depth first
    while (this._childRouters.length > 0) {
      this._childRouters[0].dispose();
    }

    // If this is the root, clean up statics
    if (!this._parentRouter) {
      _baseUrlProp = '/'; // Restore the default value
      _urlAdapter = null;
      this._name = _DEFAULT_ROOT_NAME;
      // Restore title
      window.document.title = _originalTitle;

      window.removeEventListener(_POPSTATE, handlePopState);
      oj.Router._transitionedToState.removeAll();
      _initialized = false;
    } else {
      // Remove itself from parent children array.
      var parentChildren = this._parentRouter._childRouters;
      for (var i = 0; i < parentChildren.length; i++) {
        if (parentChildren[i]._name === this._name) {
          parentChildren.splice(i, 1);
          break;
        }
      }

      delete this._parentState;
    }

    delete this._navigationType;
    this._navHistory = [];
    this._states = null;
    delete this._defaultStateId;
    delete this._extra;
  };

  /**
   * Alias for property oj.Router.transitionedToState
   * @private
   */
  oj.Router._transitionedToState = new signals.Signal();

  /**
   * Flag set to true when the router is in the process of updating the states
   * involved in the current transition
   * @private
   * @type {boolean}
   */
  oj.Router._updating = false;

  Object.defineProperties(oj.Router, {
    rootInstance: {
      /**
       * The static instance of {@link oj.Router} representing the unique root router.
       * This instance is created at the time the module is loaded.<br>
       * All other routers will be children of this object.<br>
       * The name of this router is 'root'. To change this name use the
       * {@link oj.Router.defaults|rootInstanceName} property.
       * @name oj.Router.rootInstance
       * @type oj.Router
       * @readonly
       * @example <caption>Retrieve the root router and configure it:</caption>
       * var router = oj.Router.rootInstance;
       * router.configure({
       *    'home':   { label: 'Home',   value: 'homeContent', isDefault: true },
       *    'book':   { label: 'Book',   value: 'bookContent' },
       *    'tables': { label: 'Tables', value: 'tablesContent' }
       * });
       */
      value: rootRouter,
      enumerable: true
    },
    transitionedToState: {
      /**
       * A {@link http://millermedeiros.github.io/js-signals/|signal} dispatched when the state transition
       * has completed either by successfully changing the state or cancelling.<br>
       * The parameter of the event handler is a boolean true when the state has changed.<br>
       * This is usefull when some post processing is needed or to test the result after a state change.
       * @name oj.Router.transitionedToState
       * @type {signals.Signal}
       * @readonly
       * @example <caption>Creates promise that resolve when the state transition is complete.</caption>
       * var promise = new Promise(function(resolve, reject) {
       *       oj.Router.transitionedToState.add(function(result) {
       *          if (result.hasChanged) {
       *             Logger.info('The state has changed');
       *          }
       *          resolve();
       *       });
       */
      value: oj.Router._transitionedToState,
      enumerable: true
    }
  });

  /**
   * A set of Router defaults properties.<br>
   * <h6>Warning: </h6>Defaults can not be changed after the first call to {@link oj.Router.sync|sync()}
   * has been made. To re-initialize the router, you need to call {@link oj.Router#dispose|dispose()} on
   * the {@link oj.Router.rootInstance|rootInstance} first then change the defaults.
   * @property {oj.Router.urlPathAdapter|oj.Router.urlParamAdapter} [urlAdapter] an instance of the url adapter to use. If not specified, the router
   * will be using the path url adapter. Possible values are an instance of
   * {@link oj.Router.urlPathAdapter} or {@link oj.Router.urlParamAdapter}.
   * @property {string} [baseUrl] the base URL to be used for relative URL addresses. The value can be
   * absolute or relative.  If not specified, the default value is '/'.<br>
   * <b>Warning</b>: When using the {@link oj.Router.urlPathAdapter|path URL adapter} it is necessary
   * to set the base URL if your application is not using <code class="prettyprint">index.html</code>
   * or is not starting at the root folder. Using the base URL is the only way the router can retrieve
   * the part of the URL representing the state.<br>
   * @property {string} [rootInstanceName] the name used for the root router. If not defined,
   * the name is 'root'. This is used by the {@link oj.Router.urlParamAdapter|urlParamAdapter} to build
   * the URL in the form of <code class="prettyprint">/index.html?root=book</code>.
   * @export
   * @example <caption>Change the default URL adapter to the urlParamAdapter</caption>
   * oj.Router.defaults['urlAdapter'] = new oj.Router.urlParamAdapter();
   * @example <caption>Set the base URL for an application located at the root and a starting page
   * named <code class="prettyprint">index.html</code>. This is the default.</caption>
   * oj.Router.defaults['baseUrl'] = '/';
   * @example <caption>Set the base URL for an application with a page named
   * <code class="prettyprint">main.html</code> and located in the
   * <code class="prettyprint">/myApp</code> folder.</caption>
   * oj.Router.defaults['baseUrl'] = '/myApp/main.html';
   * @example <caption>Change the default root router name to 'id'</caption>
   * oj.Router.defaults['rootInstanceName'] = 'id';
   */
  oj.Router.defaults = {};

  Object.defineProperties(oj.Router.defaults, {
    urlAdapter: {
      get: function () {
        if (!_urlAdapter) {
          // eslint-disable-next-line new-cap
          _urlAdapter = new oj.Router.urlPathAdapter();
        }
        return _urlAdapter;
      },
      set: function (urlAdapter) {
        if (_initialized) {
          throw new Error(
            'Incorrect operation. Cannot change URL adapter after calling sync() or go().'
          );
        }
        _urlAdapter = urlAdapter;
      },
      enumerable: true,
      readonly: false
    },
    baseUrl: {
      get: function () {
        return _baseUrlProp;
      },
      set: function (baseUrl) {
        if (_initialized) {
          throw new Error(
            'Incorrect operation. Cannot change base URL after calling sync() or go().'
          );
        }
        if (!baseUrl) {
          _baseUrlProp = '/';
        } else {
          // Remove anything after ? or #
          _baseUrlProp = baseUrl.match(/[^?#]+/)[0];
        }
      },
      enumerable: true,
      readonly: false
    },
    rootInstanceName: {
      get: function () {
        return rootRouter._name;
      },
      set: function (rootName) {
        if (_initialized) {
          throw new Error(
            'Incorrect operation. Cannot change the name of the root instance after calling sync() or go().'
          );
        }

        oj.Assert.assertString(rootName);
        rootRouter._name = encodeURIComponent(rootName.trim());
      },
      enumerable: true,
      readonly: false
    }
  });

  /**
   * Synchronise the router with the current URL. The process parse the URL and
   * <ol>
   *   <li>transition the router to a new state matching the URL.</li>
   *   <li>initialize the bookmarkable storage.</li>
   *   <li>dispatch a {@link oj.Router.transitionedToState|transitionedToState} signal.</li>
   * </ol>
   * It has to be called after a router is configured, to synchronise the URL with the
   * router state.<br>
   * If a default state is defined, the router will transition to it, otherwise no transition will
   * occur and the router will be in an undefined state.<br>
   * Because the process of transitioning between two states invokes callbacks (canExit, canEnter)
   * that are promises, this function also returns a promise.
   * @return {!Promise.<{hasChanged: boolean}>} A Promise that resolves when the router is done with
   * the state transition.<br>
   * When the Promise is fullfilled, the parameter value is an object with the property
   * <code class="prettyprint">hasChanged</code>.<br>
   * The value of <code class="prettyprint">hasChanged</code> is:
   * <ul>
   *   <li>true: If the router state changed.</li>
   * </ul>
   * When the Promise is rejected, the parameter value is:
   * <ul>
   *   <li>An Error object stipulating the reason for the rejection when an error
   * occurred during the resolution.</li>
   * </ul>
   * @export
   * @example <caption>Start the root instance</caption>
   * var router = oj.Router.rootInstance;
   * // Add three states to the router with id 'home', 'book' and 'tables
   * router.configure({
   *    'home':   { label: 'Home',   value: 'homeContent', isDefault: true },
   *    'book':   { label: 'Book',   value: 'bookContent' },
   *    'tables': { label: 'Tables', value: 'tablesContent' }
   * });
   *
   * var viewModel = {
   *    router: router
   * };
   *
   * oj.Router.sync().then(
   *    function() {
   *       ko.applyBindings(viewModel);
   *    },
   *    function(error) {
   *       Logger.error('Error when starting the router: ' + error.message);
   *    }
   * );
   * @example <caption>Synchronise a newly created child Router and retrieve the bookmarkable state</caption>
   *  oj.Router.sync().then(
   *     function() {
   *        var color = viewModel.router.retrieve();
   *        if (color) {
   *           $('#chapter').css('background', color);
   *        }
   *     },
   *     function(error) {
   *        Logger.error('Error during sync: ' + error.message);
   *     }
   *  );
   *
   */
  oj.Router.sync = function () {
    var transition = { router: rootRouter, origin: 'sync' };

    _initialize();

    Logger.info('Entering sync with URL: %s', _location.href);

    if (_deferredPath) {
      transition.path = _deferredPath;
      transition.deferredHandling = true;
      transition.historyUpdate = 'replace';
      _deferredPath = undefined;
      return _queueTransition(transition);
    }

    if (oj.Router._updating) {
      Logger.info('Sync called while updating, waiting for updates to end.');
      // Returms a promise that resolve as soon as the current transition is complete.
      return new Promise(function (resolve) {
        oj.Router._transitionedToState.addOnce(function (result) {
          Logger.info('Sync updates done.');
          resolve(result);
        });
      });
    }

    return _queueTransition(transition);
  };

  /*------------------------------------------------------------------------------
    URL Apdaters section
    ------------------------------------------------------------------------------*/

  /**
   *
   * @class
   * @since 1.1.0
   * @classdesc Url adapter used by the {@link oj.Router} to manage URL in the form of
   * <code class="prettyprint">/book/chapter2</code>.<br>The UrlPathAdapter is the default
   * adapter used by the {@link oj.Router|router} as it makes more human-readable URLs,
   * is user-friendly, and less likely to exceed the maximum charaacter limit in the
   * browser URL.
   * <br>Since this adapter generates path URLs, it's advisable that your application
   * be able to restore the page should the user bookmark or reload the page.  For
   * instance, given the URL <code class="prettyprint">/book/chapter2</code>, your
   * application server ought to serve up content for "chapter2" if the user should
   * bookmark or reload the page.  If that's not possible, then consider using the
   * {@link oj.Router.urlParamAdapter|urlParamAdapter}.
   * <br>There are two available URL adapters,
   * this one and the {@link oj.Router.urlParamAdapter|urlParamAdapter}.<br>To change
   * the URL adapter, use the {@link oj.Router.defaults|urlAdapter} property.
   * @see oj.Router.urlParamAdapter
   * @see oj.Router.defaults
   * @constructor
   * @export
   * @memberof oj.Router
   * @ojdeprecated {since: '9.0.0', value:['CoreRouter']}
   */
  oj.Router.urlPathAdapter = function () {
    /**
     * Variable to store the base path. This is used to retrieve the portion of the path
     * representing the routers state.
     * @ignore
     * @type {!string}
     */
    var _basePath = '';

    /**
     * Initialize the adapter given the baseUrlProp.
     * For the urlPathAdapter, retrieve the potential file name to handle application with
     * index.html in their URL.
     * @ignore
     * @param {!string} baseUrlProp the value of oj.Router.defaults.baseUrl
     */
    this.init = function (baseUrlProp) {
      // Use the browser parser to get the pathname. It works with absolute or relative URL.
      var parser = document.createElement('a');
      parser.href = baseUrlProp;

      var path = parser.pathname;
      path = path.replace(/^([^/])/, '/$1'); // Should always start with slash (for IE)

      // Normalize the base path. Always ends with a '/'
      if (path.slice(-1) !== '/') {
        path += '/';
      }

      _basePath = path;
    };

    /**
     * Construct an array of states where each item is an object made of a router and
     * the new state for it.
     * @ignore
     * @return {!Array.<_StateChange>}
     * @throws Error when parsing of router param fails.
     */
    this.parse = function () {
      var router = rootRouter;
      // To retrieve the portion of the path representing the routers state,
      // remove the base portion of the path.
      var path = _location.pathname.replace(_basePath, '');
      var segments = _getSegments(decodeURIComponent(path)).map(_decodeSlash);
      var changes = [];

      Logger.info('Parsing: %s', path);

      while (router) {
        var value = segments.shift();
        if (!value) {
          break;
        }

        var stateChange = new _StateChange(router, value);

        var state = stateChange.getState();

        // If this state has parameters, the following segments are parameter values
        if (state) {
          // eslint-disable-next-line no-loop-func
          state._paramOrder.forEach(function () {
            // Retrieve the next segment and use it for the parameter value
            stateChange.addParameter(segments.shift());
          });
        }

        changes.push(stateChange);
        router = _getChildRouter(router, value);
      }

      changes = _appendOtherChanges(changes);

      // Retrieve the extra state from request param oj_Router
      var stateStr = _location.search.split(_ROUTER_PARAM + '=')[1];
      if (stateStr) {
        stateStr = stateStr.split('&')[0];
        if (stateStr) {
          changes.forEach(_updateBookmarkableData, decodeStateParam(stateStr));
        }
      }

      return changes;
    };

    /**
     * Given an ordered array of states, build the URL representing all
     * the states.
     * Never starts with a '/': "book"  "book/chapter2"
     * @ignore
     * @param {!Array.<_StateChange>} newStates
     * @return {!string} the URL representing the states
     */
    this.buildUrlFromStates = function (newStates) {
      var canDefault = false;
      var pathname = '';
      var extraState = {}; // Compound object of all extra states

      // Build the new URL by walking the array of states backward in order to eliminate
      // the default state from the URL. As soon as a value is not the default, stops the removal.
      for (var ns = newStates.pop(); ns; ns = newStates.pop()) {
        if (ns.value) {
          if (canDefault || ns.value !== ns.router._defaultStateId) {
            pathname = pathname ? ns.value + '/' + pathname : ns.value;
            canDefault = true;
          }
        }

        // Build an object made of the extra data of each router
        if (ns.router._extra !== undefined) {
          extraState[ns.router._name] = ns.router._extra;
        }
      }

      return _buildUrl({ pathname: _basePath + pathname }, extraState);
    };
  };

  /**
   * @class
   * @since 1.1.0
   * @classdesc Url adapter used by the {@link oj.Router} to manage URL in the form of
   * <code class="prettyprint">/index.html?root=book&book=chapter2</code>.  This adapter
   * can be used if the {@link oj.Router.urlPathAdapter|urlPathAdapter} doesn't meet
   * the application's needs.
   * <br>This adapter is well-suited for single-page applications whose entry point
   * is always a single document, i.e., "index.html" which restores its router state
   * from additional parameters.  The router state is encoded as URL parameters and
   * then restored after the page is loaded.  This is ideal for applications which
   * cannot handle multiple entry points, as recommended by {@link oj.Router.urlPathAdapter|urlPathAdapter}.
   * <br>There are two available
   * URL adapters, this one and the {@link oj.Router.urlPathAdapter|urlPathAdapter}.<br>To change
   * the URL adapter, use the {@link oj.Router.defaults|urlAdapter} property.
   * @see oj.Router.urlPathAdapter
   * @see oj.Router.defaults
   * @constructor
   * @export
   * @example <caption>Change the default URL adapter to urlParamAdapter instead of urlPathAdapter:</caption>
   * oj.Router.defaults['urlAdapter'] = new oj.Router.urlParamAdapter();
   * @ojdeprecated {since: '9.0.0', value:['CoreRouter']}
   */
  oj.Router.urlParamAdapter = function () {
    /**
     * Initialize the adapter.
     * @ignore
     */
    this.init = function () {
      // No-op
    };

    /**
     * Construct an array of states where each item is an object made of a router and
     * the new state for it.
     * @ignore
     * @return {!Array.<_StateChange>}
     * @throws Error when parsing of router param fails.
     */
    this.parse = function () {
      var search = _location.search;
      var params = parseQueryParam(search);
      var router = rootRouter;
      var changes = [];

      Logger.info('Parsing: %s', search);

      while (router) {
        var value = params[router._name] || router._defaultStateId;

        // Retrieve all value separated by '/'
        var segments = _getSegments(value);
        value = segments.shift();

        var stateChange = new _StateChange(router, value);

        if (value) {
          var state = stateChange.getState();

          // If this state has parameters, retrieve their values from the segments
          if (state) {
            // eslint-disable-next-line no-loop-func
            state._paramOrder.forEach(function () {
              stateChange.addParameter(segments.shift());
            });
          }

          changes.push(stateChange);
        }
        router = _getChildRouter(router, value);
      }

      changes = _appendOtherChanges(changes);

      // Retrieve the extra state from oj_Router param
      var stateStr = params[_ROUTER_PARAM];
      if (stateStr) {
        changes.forEach(_updateBookmarkableData, decodeStateParam(stateStr));
      }

      return changes;
    };

    /**
     * Given an ordered array of states, build the URL representing all
     * the states.
     * Never starts with a '/': "index.html", "book/chapter2"
     * @ignore
     * @param {!Array.<_StateChange>} newStates
     * @return {!string} the URL representing the states
     * @throws An error if bookmarkable state is too big.
     */
    this.buildUrlFromStates = function (newStates) {
      var canDefault = false;
      var search = '';
      var extraState = {}; // Compound object of all extra states

      // Build the new URL by walking the array of states backward in order to eliminate
      // the default state from the URL. As soon as a value is not the default, stops the removal.
      for (var ns = newStates.pop(); ns; ns = newStates.pop()) {
        if (ns.value) {
          if (canDefault || ns.value !== ns.router._defaultStateId) {
            // _name is already encoded
            var paramName = '&' + ns.router._name + '=';
            var paramValue = ns.value;

            // Because we are traversing the array backward, insert instead of append
            search = paramName + encodeURIComponent(paramValue) + search;
            canDefault = true;
          }
        }

        // Build an object made of the extra data of each router
        if (ns.router._extra !== undefined) {
          extraState[ns.router._name] = ns.router._extra;
        }
      }

      // Replace first parameter separator from '&' to '?'
      if (search) {
        search = '?' + search.substr(1);
      }

      return _buildUrl({ search: search }, extraState);
    };
  };
  return rootRouter;
})();
// eslint-disable-next-line no-unused-vars
var Router = oj.Router;


/* eslint-disable no-bitwise */
/* eslint-disable no-constant-condition */
/* The purpose of this file is compression which by its nature is bit banging */

/**
 * Utility to compress JSON to store on the URL.
 */
(function () {
  var _fcc = String.fromCharCode;
  var _keyStrUriSafe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$';
  var _baseReverseDic;

  oj.LZString = {
    /**
     * Compress into a string that is URI encoded
     * @ignore
     * @param {?string} input
     * @return {string}
     */
    compressToEncodedURIComponent: function (input) {
      if (input === null) {
        return '';
      }
      return _compress(input, 6, function (a) {
        return _keyStrUriSafe.charAt(a);
      });
    },

    /**
     * Decompress from an output of compressToEncodedURIComponent
     * @ignore
     * @param {?string} input
     * @return {?string}
     */
    decompressFromEncodedURIComponent: function (input) {
      if (input === null) {
        return '';
      }
      if (input === '') {
        return null;
      }
      return _decompress(input.length, 32, function (index) {
        return _getBaseValue(_keyStrUriSafe, input.charAt(index));
      });
    }
  };

  /**
   * @param  {string} alphabet
   * @param  {string} character
   * @return {string}
   */
  function _getBaseValue(alphabet, character) {
    var i;

    if (!_baseReverseDic) {
      _baseReverseDic = {};
    }
    if (!_baseReverseDic[alphabet]) {
      _baseReverseDic[alphabet] = {};
      for (i = 0; i < alphabet.length; i++) {
        _baseReverseDic[alphabet][alphabet[i]] = i;
      }
    }
    return _baseReverseDic[alphabet][character];
  }

  /**
   * @param  {?string} uncompressed
   * @param  {number} bitsPerChar
   * @param  {function(number):string} getCharFromInt
   * @return {string}
   */
  function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed === null) {
      return '';
    }
    var i;
    var value;
    var contextDictionary = {};
    var contextDictionaryToCreate = {};
    var contextW = '';
    var contextEnlargeIn = 2; // Compensate for the first entry which should not count
    var contextDictSize = 3;
    var contextNumBits = 2;
    var contextDataString = '';
    var contextDataVal = 0;
    var contextDataPosition = 0;
    var len = uncompressed.length;

    for (var ii = 0; ii < len; ii++) {
      var contextC = uncompressed[ii];
      if (!Object.prototype.hasOwnProperty.call(contextDictionary, contextC)) {
        contextDictionary[contextC] = contextDictSize;
        contextDictSize += 1;
        contextDictionaryToCreate[contextC] = true;
      }

      var contextWc = contextW + contextC;
      if (Object.prototype.hasOwnProperty.call(contextDictionary, contextWc)) {
        contextW = contextWc;
      } else {
        if (Object.prototype.hasOwnProperty.call(contextDictionaryToCreate, contextW)) {
          if (contextW.charCodeAt(0) < 256) {
            for (i = contextNumBits; i--; ) {
              contextDataVal <<= 1;
              if (contextDataPosition === bitsPerChar - 1) {
                contextDataPosition = 0;
                contextDataString += getCharFromInt(contextDataVal);
                contextDataVal = 0;
              } else {
                contextDataPosition += 1;
              }
            }
            value = contextW.charCodeAt(0);
            for (i = 8; i--; ) {
              contextDataVal = (contextDataVal << 1) | (value & 1);
              if (contextDataPosition === bitsPerChar - 1) {
                contextDataPosition = 0;
                contextDataString += getCharFromInt(contextDataVal);
                contextDataVal = 0;
              } else {
                contextDataPosition += 1;
              }
              value >>= 1;
            }
          } else {
            value = 1;
            for (i = contextNumBits; i--; ) {
              contextDataVal = (contextDataVal << 1) | value;
              if (contextDataPosition === bitsPerChar - 1) {
                contextDataPosition = 0;
                contextDataString += getCharFromInt(contextDataVal);
                contextDataVal = 0;
              } else {
                contextDataPosition += 1;
              }
              value = 0;
            }
            value = contextW.charCodeAt(0);
            for (i = 16; i--; ) {
              contextDataVal = (contextDataVal << 1) | (value & 1);
              if (contextDataPosition === bitsPerChar - 1) {
                contextDataPosition = 0;
                contextDataString += getCharFromInt(contextDataVal);
                contextDataVal = 0;
              } else {
                contextDataPosition += 1;
              }
              value >>= 1;
            }
          }
          contextEnlargeIn -= 1;
          if (contextEnlargeIn === 0) {
            contextEnlargeIn = Math.pow(2, contextNumBits);
            contextNumBits += 1;
          }
          delete contextDictionaryToCreate[contextW];
        } else {
          value = contextDictionary[contextW];
          for (i = contextNumBits; i--; ) {
            contextDataVal = (contextDataVal << 1) | (value & 1);
            if (contextDataPosition === bitsPerChar - 1) {
              contextDataPosition = 0;
              contextDataString += getCharFromInt(contextDataVal);
              contextDataVal = 0;
            } else {
              contextDataPosition += 1;
            }
            value >>= 1;
          }
        }
        contextEnlargeIn -= 1;
        if (contextEnlargeIn === 0) {
          contextEnlargeIn = Math.pow(2, contextNumBits);
          contextNumBits += 1;
        }
        // Add wc to the dictionary.
        contextDictionary[contextWc] = contextDictSize;
        contextDictSize += 1;
        contextW = String(contextC);
      }
    }

    // Output the code for w.
    if (contextW !== '') {
      if (Object.prototype.hasOwnProperty.call(contextDictionaryToCreate, contextW)) {
        if (contextW.charCodeAt(0) < 256) {
          for (i = contextNumBits; i--; ) {
            contextDataVal <<= 1;
            if (contextDataPosition === bitsPerChar - 1) {
              contextDataPosition = 0;
              contextDataString += getCharFromInt(contextDataVal);
              contextDataVal = 0;
            } else {
              contextDataPosition += 1;
            }
          }
          value = contextW.charCodeAt(0);
          for (i = 8; i--; ) {
            contextDataVal = (contextDataVal << 1) | (value & 1);
            if (contextDataPosition === bitsPerChar - 1) {
              contextDataPosition = 0;
              contextDataString += getCharFromInt(contextDataVal);
              contextDataVal = 0;
            } else {
              contextDataPosition += 1;
            }
            value >>= 1;
          }
        } else {
          value = 1;
          for (i = contextNumBits; i--; ) {
            contextDataVal = (contextDataVal << 1) | value;
            if (contextDataPosition === bitsPerChar - 1) {
              contextDataPosition = 0;
              contextDataString += getCharFromInt(contextDataVal);
              contextDataVal = 0;
            } else {
              contextDataPosition += 1;
            }
            value = 0;
          }
          value = contextW.charCodeAt(0);
          for (i = 16; i--; ) {
            contextDataVal = (contextDataVal << 1) | (value & 1);
            if (contextDataPosition === bitsPerChar - 1) {
              contextDataPosition = 0;
              contextDataString += getCharFromInt(contextDataVal);
              contextDataVal = 0;
            } else {
              contextDataPosition += 1;
            }
            value >>= 1;
          }
        }
        contextEnlargeIn -= 1;
        if (contextEnlargeIn === 0) {
          contextEnlargeIn = Math.pow(2, contextNumBits);
          contextNumBits += 1;
        }
        delete contextDictionaryToCreate[contextW];
      } else {
        value = contextDictionary[contextW];
        for (i = contextNumBits; i--; ) {
          contextDataVal = (contextDataVal << 1) | (value & 1);
          if (contextDataPosition === bitsPerChar - 1) {
            contextDataPosition = 0;
            contextDataString += getCharFromInt(contextDataVal);
            contextDataVal = 0;
          } else {
            contextDataPosition += 1;
          }
          value >>= 1;
        }
      }
      contextEnlargeIn -= 1;
      if (contextEnlargeIn === 0) {
        contextNumBits += 1;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i = contextNumBits; i--; ) {
      contextDataVal = (contextDataVal << 1) | (value & 1);
      if (contextDataPosition === bitsPerChar - 1) {
        contextDataPosition = 0;
        contextDataString += getCharFromInt(contextDataVal);
        contextDataVal = 0;
      } else {
        contextDataPosition += 1;
      }
      value >>= 1;
    }

    // Flush the last char
    while (true) {
      contextDataVal <<= 1;
      if (contextDataPosition === bitsPerChar - 1) {
        contextDataString += getCharFromInt(contextDataVal);
        break;
      } else contextDataPosition += 1;
    }
    return contextDataString;
  }

  /**
   * @param  {number} length
   * @param  {number} resetValue
   * @param  {function(number):string} getNextValue
   * @return {?string}
   */
  function _decompress(length, resetValue, getNextValue) {
    var dictionary = [];
    var enlargeIn = 4;
    var dictSize = 4;
    var numBits = 3;
    var entry = '';
    var result = '';
    var resb;
    var c;
    var data = {
      val: getNextValue(0),
      position: resetValue,
      index: 1
    };

    for (var i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    var bits = 0;
    var maxpower = Math.pow(2, 2);
    var power = 1;
    while (power !== maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position === 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index);
        data.index += 1;
      }
      bits |= (resb > 0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (bits) {
      case 0:
        bits = 0;
        maxpower = Math.pow(2, 8);
        power = 1;
        while (power !== maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position === 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index);
            data.index += 1;
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = _fcc(bits);
        break;
      case 1:
        bits = 0;
        maxpower = Math.pow(2, 16);
        power = 1;
        while (power !== maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position === 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index);
            data.index += 1;
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = _fcc(bits);
        break;
      case 2:
        return '';
      default:
        break;
    }

    dictionary[3] = c;
    var w = c;
    result = c;
    while (true) {
      if (data.index > length) {
        return '';
      }

      bits = 0;
      maxpower = Math.pow(2, numBits);
      power = 1;
      while (power !== maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position === 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index);
          data.index += 1;
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
      }

      c = bits;
      switch (c) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power !== maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position === 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index);
              data.index += 1;
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize] = _fcc(bits);
          dictSize += 1;
          c = dictSize - 1;
          enlargeIn -= 1;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power !== maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position === 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index);
              data.index += 1;
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize] = _fcc(bits);
          dictSize += 1;
          c = dictSize - 1;
          enlargeIn -= 1;
          break;
        case 2:
          return result;
        default:
          break;
      }

      if (enlargeIn === 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits += 1;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else if (c === dictSize) {
        entry = w + (w.length ? w[0] : '');
      } else {
        return null;
      }
      result += entry;

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize] = w + entry[0];
      dictSize += 1;
      enlargeIn -= 1;

      w = entry;

      if (enlargeIn === 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits += 1;
      }
    }
  }
})();


/* jslint browser: true*/

/**
 * The RouterState module.
 */
(function () {
  var stateParamExp = /^{(\w+)}$/;

  oj.RouterState = function (id, options, router) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    oj.Assert.assertString(id);
    // eslint-disable-next-line no-param-reassign
    id = id.trim();

    // The id is in the form /aaa/{p1}/{p2}
    var path = id.split('/');
    // We cannot have duplicate because the format of the object parameter
    // doesn't allow it.
    this._id = path.shift();

    this._parameters = {};

    this._paramOrder = [];

    path.forEach(function (pathItem, i) {
      /*
       * Match pattern "{token}"
       */
      var match = pathItem.match(stateParamExp);
      if (match) {
        var token = match[1];
        this._parameters[token] = null;
        this._paramOrder[i] = token;
      }
    }, this);

    this._canEnter = options.canEnter;
    if (this._canEnter) {
      oj.Assert.assertFunctionOrNull(this._canEnter);
    }

    this._enter = options.enter;
    if (this._enter) {
      oj.Assert.assertFunctionOrNull(this._enter);
    }

    this._canExit = options.canExit;
    if (this._canExit) {
      oj.Assert.assertFunctionOrNull(this._canExit);
    }

    this._exit = options.exit;
    if (this._exit) {
      oj.Assert.assertFunctionOrNull(this._exit);
    }
    this._value = options.value;

    this._label = options.label;

    this._title = options.title;

    this._router = router;

    this.viewModel = undefined;

    this.go = () => {
      if (!this._router) {
        oj.Router._transitionedToState.dispatch({ hasChanged: false });
        return Promise.reject(new Error('Router is not defined for this RouterState object.'));
      }
      return this._router.go(this._id);
    };

    this.isCurrent = () => {
      if (!this._router) {
        throw new Error('Router is not defined for this RouterState object.');
      }
      return this._router._stateId() === this._id;
    };

    Object.defineProperties(this, {
      id: {
        value: this._id,
        enumerable: true
      },
      value: {
        get: function () {
          return this._value;
        },
        set: function (newValue) {
          this._value = newValue;
        },
        enumerable: true
      },
      label: {
        get: function () {
          return this._label;
        },
        set: function (newValue) {
          this._label = newValue;
        },
        enumerable: true
      },
      title: {
        get: function () {
          return this._title;
        },
        set: function (newValue) {
          this._title = newValue;
        },
        enumerable: true
      },
      canEnter: {
        get: function () {
          return this._canEnter;
        },
        set: function (newValue) {
          this._canEnter = newValue;
        },
        enumerable: true
      },
      enter: {
        get: function () {
          return this._enter;
        },
        set: function (newValue) {
          this._enter = newValue;
        },
        enumerable: true
      },
      canExit: {
        get: function () {
          return this._canExit;
        },
        set: function (newValue) {
          this._canExit = newValue;
        },
        enumerable: true
      },
      exit: {
        get: function () {
          return this._exit;
        },
        set: function (newValue) {
          this._exit = newValue;
        },
        enumerable: true
      },
      parameters: {
        get: function () {
          return this._parameters;
        },
        enumerable: true
      }
    });
  };
})();

  ;return Router; 
});

define('ojs/ojmodule',['ojs/ojcore-base', 'knockout', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojcustomelement-utils'], function (oj, ko, Logger, Context, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   * ojModule Conventions
   * @namespace
   * @ojtsmodule
   * @ojtsignore
   * @since 1.1
   * @ojdeprecated {since: '9.0.0', description: 'Replace ModuleBinding and ojModule with oj-module element.'}
   */
  const ModuleBinding = {};
  // Define a mapping variable that maps the return value of the module to the name used in the callback function of a require call.
  // eslint-disable-next-line no-unused-vars
  oj._registerLegacyNamespaceProp('ModuleBinding', ModuleBinding);

  /**
   * Default configuration values
   * ojModule binding's conventions may be overridden for the entire application after the ojs/ojmodule
   * module is loaded. For example:
   * <p><code class="prettyprint">
   * ModuleBinding.defaults.modelPath = 'models/';
   * </code></p>
   * Note that the default names of the {@link ModuleBinding.ConventionMethods optional lifecycle methods}
   * on the ViewModel are different from their counterparts on the {@link ojModule.LifecycleListener LifecycleListener}
   * interface
   * @property {string} viewPath default View path. Defaults to 'text!views/'
   * @property {string} viewSuffix default View suffix. Defaults to '.html'
   * @property {string} modelPath default Model suffix. Defaults to 'viewModels/'
   * @property {string} initializeMethod name of the initialialization method
   * (see {@link ModuleBinding.ConventionMethods#initialize definition})
   * @property {string} disposeMethod name of the dispose method
   * (see {@link ModuleBinding.ConventionMethods#dispose definition})
   * @property {string} activatedHandler name of the 'activated' event handler
   * (see {@link ModuleBinding.ConventionMethods#handleActivated definition})
   * @property {string} attachedHandler name of the 'attached' event handler
   * (see {@link ModuleBinding.ConventionMethods#handleAttached definition})
   * @property {string} detachedHandler name of the 'detached' event handler
   * (see {@link ModuleBinding.ConventionMethods#handleDetached definition})
   * @property {string} bindingsAppliedHandler name of the 'bindingsApplied' event handler
   * (see {@link ModuleBinding.ConventionMethods#handleBindingsApplied definition})
   * @property {string} deactivatedHandler name of the 'deactivated' event handler
   * (see {@link ModuleBinding.ConventionMethods#handleDeactivated definition})
   * @property {string} transitionCompletedHandler name of the 'transitionCompleted' event handler
   * (see {@link ModuleBinding.ConventionMethods#handleTransitionCompleted definition})
   * @export
   * @memberof ModuleBinding
   */
  ModuleBinding.defaults = {
    viewPath: 'text!views/',
    viewSuffix: '.html',
    modelPath: 'viewModels/',
    initializeMethod: 'initialize',
    disposeMethod: 'dispose',
    activatedHandler: 'handleActivated',
    attachedHandler: 'handleAttached',
    detachedHandler: 'handleDetached',
    bindingsAppliedHandler: 'handleBindingsApplied',
    deactivatedHandler: 'handleDeactivated',
    transitionCompletedHandler: 'handleTransitionCompleted'
  };

  /**
   * @ignore
   */
  ModuleBinding._EMPTY_MODULE = 'oj:blank';

  (function () {
    ko.bindingHandlers.ojModule = {
      init: function (element, valueAccessor, allBindingsAccessor, koViewModel, bindingContext) {
        var currentViewModel;
        var currentAnimationPromise;
        var cache = {};
        var currentCacheKey;
        var pendingViewId = -1;
        var cacheHolder;
        var endCommentNode;
        var busyStateResolver;
        var currentEmpty;
        var currentCleanupMode;
        var isCustomElement = element.parentNode && element.parentNode.nodeName === 'OJ-MODULE'; // custom element check

        var legacyViewModelMethodFunc = isCustomElement ? function () {} : _invokeViewModelMethod;
        var legacyLifecycleListenerFunc = isCustomElement ? function () {} : _invokeLifecycleListener;
        var viewModelMethodFunc = isCustomElement ? _invokeViewModelMethodOnElement : function () {};
        var dispatchLifecycleEventFunc = isCustomElement ? _dispatchLifecycleEvent : function () {};

        function resolveBusyState() {
          if (busyStateResolver) {
            busyStateResolver();
            busyStateResolver = null;
          }
        }

        var invokeModelDispose = function (model) {
          legacyViewModelMethodFunc(model, 'disposeMethod', [element, valueAccessor]);
        };

        var disposeAssociatedComponentViewModel = function () {
          invokeModelDispose(currentViewModel);
        };

        var nodeDispose = function () {
          disposeAssociatedComponentViewModel();

          // call dispose() on cached models
          var keys = Object.keys(cache);
          for (var i = 0; i < keys.length; i++) {
            var model = cache[keys[i]].model;
            invokeModelDispose(model);
          }
          resolveBusyState();

          // Knockout will call ko.cleanNode on all child nodes including the cacheHolder
        };

        ko.utils.domNodeDisposal.addDisposeCallback(element, nodeDispose);

        var _IGNORE_PROMISE = new Error(
          'Promise cancelled because ojModule is fetching new View and ViewModel'
        );

        // This function is used to interrupt Promise chains when the new view/viewModel combination is being loaded
        var checkPendingId = function (id) {
          if (id !== pendingViewId) {
            throw _IGNORE_PROMISE;
          }
        };

        var initCacheHolder = function () {
          if (!cacheHolder) {
            cacheHolder = document.createElement('div');
            cacheHolder.className = 'oj-helper-module-cache';
            // it is Ok to insert the cache holder as the first element because
            // all current children of the element will be moved to the cache holder
            ko.virtualElements.prepend(element, cacheHolder); // @HTMLUpdateOK cacheHolder is constructed above
          }
        };

        var contextElement = element;

        if (element.nodeType === 8) {
          // comment
          contextElement = element.parentNode;
          ko.virtualElements.setDomNodeChildren(element, []); // remove all child nodes of the virtual element
          endCommentNode = element.nextSibling;
        }

        ko.computed(
          function () {
            pendingViewId += 1;

            if (!busyStateResolver) {
              var busyContext = Context.getContext(contextElement).getBusyContext();
              busyStateResolver = busyContext.addBusyState({
                description:
                  'ojModule binding on a node with the Id ' +
                  element.id +
                  'is loading the module. Binding evaluator: ' +
                  valueAccessor.toString()
              });
            }

            var isInitial = pendingViewId === 0;

            var unwrap = ko.utils.unwrapObservable;
            var value = unwrap(valueAccessor());

            var moduleName;
            var viewName;
            var params;
            var modelFactory;
            var viewFunction;
            var cacheKey;
            var lifecycleListener;
            var animation;
            var requireFunc;
            var modelPath;
            var viewPath;
            var accessorView;
            var accessorViewModel;
            var cleanupMode;

            if (typeof value === 'string') {
              moduleName = value;
            } else {
              moduleName = unwrap(value.name);
              viewName = unwrap(value.viewName);
              params = unwrap(value.params);
              modelFactory = unwrap(value.viewModelFactory);
              viewFunction = unwrap(value.createViewFunction);
              cacheKey = unwrap(value.cacheKey);
              lifecycleListener = unwrap(value.lifecycleListener);
              animation = unwrap(value.animation);
              accessorView = unwrap(value.view);
              accessorViewModel = unwrap(value.viewModel);
              requireFunc = unwrap(value.require);
              cleanupMode = unwrap(value.cleanupMode);
            }

            if (requireFunc != null && !(requireFunc instanceof Function)) {
              viewPath = requireFunc.viewPath;
              modelPath = requireFunc.modelPath;
              requireFunc = requireFunc.instance;
            }

            viewName = viewName == null ? moduleName : viewName;

            var empty = ModuleBinding._EMPTY_MODULE === viewName;

            var attachPromise = legacyLifecycleListenerFunc(lifecycleListener, 'activated', [
              element,
              valueAccessor
            ]);
            dispatchLifecycleEventFunc(contextElement, 'ojTransitionStart', [accessorViewModel]);

            var viewPromise;
            var modelPromise;
            var cached;

            if (empty) {
              viewPromise = Promise.resolve([]);
              modelPromise = Promise.resolve(null);
            } else {
              cached = cacheKey == null ? null : cache[cacheKey];

              if (cached != null) {
                delete cache[cacheKey];
                viewPromise = Promise.resolve(cached.view);
                modelPromise = Promise.resolve(cached.model);
              }
            }

            if (viewPromise == null && accessorView != null) {
              viewPromise = Promise.resolve(accessorView);
            }

            if (modelPromise == null) {
              if (accessorViewModel != null) {
                modelPromise = Promise.resolve(accessorViewModel);
              } else if (modelFactory != null) {
                modelPromise = ko.ignoreDependencies(modelFactory.createViewModel, modelFactory, [
                  params,
                  valueAccessor
                ]);
              }

              if (modelPromise == null && moduleName != null) {
                if (modelPath == null) {
                  modelPath = ModuleBinding.defaults.modelPath;
                }
                modelPromise = _getOjModuleRequirePromise(
                  requireFunc,
                  'viewModel',
                  modelPath + moduleName
                );
              }

              if (modelPromise != null) {
                // Wrap model promise to perform initialization
                modelPromise = modelPromise.then(
                  function (id, viewModel) {
                    checkPendingId(id);

                    if (typeof viewModel === 'function') {
                      // eslint-disable-next-line no-param-reassign,new-cap
                      viewModel = new viewModel(params);
                    } else {
                      // If the function returns a value, use it as the new model instance
                      // eslint-disable-next-line no-param-reassign
                      viewModel =
                        legacyViewModelMethodFunc(viewModel, 'initializeMethod', [
                          element,
                          valueAccessor
                        ]) || viewModel;
                    }

                    return viewModel;
                  }.bind(null, pendingViewId)
                );

                // Handle the case where the Model is responsible for creating a View
                if (viewPromise == null && viewFunction != null) {
                  viewPromise = modelPromise.then(
                    function (id, model) {
                      checkPendingId(id);

                      if (model == null) {
                        resolveBusyState();
                        throw new Error(
                          'createViewFunction option cannot be used when the ViewModel is null'
                        );
                      }

                      var viewMethod = model[viewFunction];

                      if (viewMethod == null) {
                        resolveBusyState();
                        throw new Error(
                          'function specified by the createViewFunction option was not found on the ViewModel'
                        );
                      }

                      return viewMethod.call(model);
                    }.bind(null, pendingViewId)
                  );
                }
              }
              if (viewPromise == null) {
                if (viewName != null) {
                  if (viewPath == null) {
                    viewPath = ModuleBinding.defaults.viewPath;
                  }
                  viewPromise = _getOjModuleRequirePromise(
                    requireFunc,
                    'view',
                    viewPath + viewName + ModuleBinding.defaults.viewSuffix
                  );
                } else {
                  resolveBusyState();
                  throw new Error('View name or view instance must be specified');
                }
              }
            }

            if (viewPromise == null) {
              resolveBusyState();
              throw new Error('ojModule is missing a View');
            }

            var modelAttachPromise;

            if (modelPromise != null) {
              modelAttachPromise = modelPromise.then(
                function (id, viewModel) {
                  checkPendingId(id);
                  return legacyViewModelMethodFunc(viewModel, 'activatedHandler', [
                    element,
                    valueAccessor
                  ]);
                }.bind(null, pendingViewId)
              );
            }

            // We will ahve to wait for any module animation that has already started. Allowing a new View to be loaded while
            // animation is in progress would potentially leave the DOM in
            var masterPromise = Promise.all([
              viewPromise,
              modelPromise,
              attachPromise,
              modelAttachPromise,
              currentAnimationPromise
            ]);

            masterPromise.then(
              function (id, values) {
                if (id !== pendingViewId) {
                  return;
                }

                var view = values[0];

                if (view == null) {
                  resolveBusyState();
                  throw new Error("The module's View was resolved to null");
                }

                var nodes = _getDomNodes(view, resolveBusyState);
                var model = values[1];
                _checkForReusedView(element, nodes, model, isCustomElement, resolveBusyState);

                var saveInCache = false;
                var cachedNodeArray;

                var oldDomNodes = _getContainedNodes(element, cacheHolder, endCommentNode);
                var oldKoNodes = _getKoNodes(element, cacheHolder);

                if (currentCacheKey != null && !currentEmpty) {
                  saveInCache = true;
                  cachedNodeArray = oldDomNodes;
                  initCacheHolder();
                } else if (isCustomElement) {
                  // need view nodes for the event payload
                  cachedNodeArray = oldDomNodes;
                }

                var oldNodesRemoved = false;

                var removeOldDomNodes = function (oldViewParent) {
                  if (oldNodesRemoved) {
                    return;
                  }

                  oldNodesRemoved = true;

                  if (saveInCache) {
                    // legacy cache case - move the node into cacheHolder, then detach
                    // Keep the cached nodes connected as a workaround for the Knockout removing observable subscriptions when
                    // they fire on disconnected nodes
                    _moveDomNodes(oldDomNodes, cacheHolder);
                    _detachOldView(element, oldViewParent || element, cacheHolder);
                  } else if (isCustomElement && currentCleanupMode === 'none') {
                    // external cache case
                    // detach from DOM by simply removing to preserve applied binding on the nodes
                    for (var i = 0; i < cachedNodeArray.length; i++) {
                      var cachedNode = cachedNodeArray[i];
                      cachedNode.parentNode.removeChild(cachedNode);
                    }
                  } else {
                    // cache is not involved - clean up and detach
                    oldKoNodes.forEach(function (n) {
                      ko.cleanNode(n);
                    });
                    _detachOldView(element, oldViewParent || element, cacheHolder);
                  }

                  if (!isInitial) {
                    // ensure that this is not the very first view displayed by the binding
                    legacyLifecycleListenerFunc(lifecycleListener, 'detached', [
                      element,
                      valueAccessor,
                      currentViewModel,
                      cachedNodeArray
                    ]);
                    legacyViewModelMethodFunc(currentViewModel, 'detachedHandler', [
                      element,
                      valueAccessor,
                      cachedNodeArray
                    ]);
                    viewModelMethodFunc(currentViewModel, 'disconnected', cachedNodeArray);
                    dispatchLifecycleEventFunc(contextElement, 'ojViewDisconnected', [
                      currentViewModel,
                      cachedNodeArray
                    ]);

                    legacyLifecycleListenerFunc(lifecycleListener, 'deactivated', [
                      element,
                      valueAccessor,
                      currentViewModel
                    ]);
                    legacyViewModelMethodFunc(currentViewModel, 'deactivatedHandler', [
                      element,
                      valueAccessor
                    ]);
                  }

                  if (saveInCache) {
                    // For upstream or indirect dependency we will still rely components being registered on the oj namespace.
                    _invokeOnSubtree(cachedNodeArray, ojcustomelementUtils.CustomElementUtils.subtreeHidden);
                    cache[currentCacheKey] = { model: currentViewModel, view: cachedNodeArray };
                  } else if (isCustomElement && currentCleanupMode === 'none') {
                    _invokeOnSubtree(
                      cachedNodeArray,
                      oj.Components ? oj.Components.subtreeDetached : null
                    );
                  } else {
                    disposeAssociatedComponentViewModel();
                  }
                  currentViewModel = model;
                  currentCacheKey = cacheKey;
                  currentEmpty = empty;
                  currentCleanupMode = cleanupMode;
                };

                function insertAndActivateNewNodes(_targetElement) {
                  var targetElement = _targetElement || element;

                  // For custom elements check whether the binding is already applied to nodes
                  // before attaching nodes to DOM. This helps in a scenario when knockout
                  // uses parent nodes to find applied binding and returns parent binding as a result.
                  // E.g. knockout might return incorrect binding for comment nodes that are attached to DOM.
                  var bindingApplied = isCustomElement && _isBindingApplied(nodes, model);

                  _insertNodes(targetElement, nodes);

                  var fromCache = cached != null;

                  // For upstream or indirect dependency we will still rely components being registered on the oj namespace.
                  if (fromCache) {
                    _invokeOnSubtree(nodes, oj.Components ? oj.Components.subtreeShown : null);
                  } else if (bindingApplied) {
                    _invokeOnSubtree(nodes, oj.Components ? oj.Components.subtreeAttached : null);
                  }

                  legacyLifecycleListenerFunc(lifecycleListener, 'attached', [
                    targetElement,
                    valueAccessor,
                    model,
                    fromCache
                  ]);
                  legacyViewModelMethodFunc(model, 'attachedHandler', [
                    targetElement,
                    valueAccessor,
                    fromCache
                  ]);
                  viewModelMethodFunc(model, 'connected', nodes);
                  dispatchLifecycleEventFunc(contextElement, 'ojViewConnected', [model]);

                  if (!fromCache && !bindingApplied) {
                    var childBindingContext = bindingContext.createChildContext(
                      model,
                      undefined,
                      function (ctx) {
                        ctx.$module = model;
                        ctx.$params = params;
                      }
                    );

                    if (isCustomElement) {
                      // nulling out the composite binding context props from the contained module
                      childBindingContext.$parent = undefined;
                      childBindingContext.$parents = undefined;
                      childBindingContext.$parentContext = undefined;
                      childBindingContext.$props = undefined;
                      childBindingContext.$properties = undefined;
                      childBindingContext.$slotNodeCounts = undefined;
                      childBindingContext.$slotCounts = undefined;
                      childBindingContext.$unique = undefined;
                      childBindingContext.$uniqueId = undefined;
                      childBindingContext.$provided = undefined;
                    }

                    _applyBindingsToNodes(targetElement, nodes[0], childBindingContext, cacheHolder);

                    legacyLifecycleListenerFunc(lifecycleListener, 'bindingsApplied', [
                      targetElement,
                      valueAccessor,
                      model
                    ]);
                    legacyViewModelMethodFunc(model, 'bindingsAppliedHandler', [
                      targetElement,
                      valueAccessor
                    ]);
                  }
                }

                var transitionComplete = function () {
                  legacyLifecycleListenerFunc(lifecycleListener, 'transitionCompleted', [
                    element,
                    valueAccessor,
                    model
                  ]);
                  legacyViewModelMethodFunc(model, 'transitionCompletedHandler', [
                    element,
                    valueAccessor
                  ]);
                  viewModelMethodFunc(model, 'transitionCompleted', nodes);
                  dispatchLifecycleEventFunc(contextElement, 'ojTransitionEnd', [model]);
                  resolveBusyState();
                };

                if (animation != null) {
                  var actx = _createAnimationContext(
                    element,
                    valueAccessor,
                    isInitial,
                    currentViewModel,
                    model,
                    isCustomElement
                  );
                  var promise = _animate(
                    actx,
                    animation,
                    element,
                    oldDomNodes,
                    insertAndActivateNewNodes,
                    removeOldDomNodes,
                    transitionComplete
                  );
                  // wrap currentAnimationPromise is a promise that never gets rejected, so that the ojModule can still
                  // navigate to a new View
                  currentAnimationPromise = _createNoFailPromise(promise);
                } else {
                  currentAnimationPromise = undefined;
                }

                if (!currentAnimationPromise) {
                  removeOldDomNodes(null);
                  insertAndActivateNewNodes(null);
                  transitionComplete();
                }
              }.bind(null, pendingViewId),

              /* reject callback */
              function (id, reason) {
                if (reason === _IGNORE_PROMISE) {
                  return;
                }

                if (reason != null) {
                  resolveBusyState();

                  Logger.error(reason);
                  // Additionally log the stack trace for the original error
                  /* if (reason instanceof Error)
                {
                  Logger.error(reason.stack);
                }*/
                }
              }.bind(null, pendingViewId)
            );
          },
          null,
          { disposeWhenNodeIsRemoved: element }
        );

        return { controlsDescendantBindings: true };
      }
    };

    // Allow ojModule binding on virtual elements (comment nodes)
    ko.virtualElements.allowedBindings.ojModule = true;

    /**
     * @ignore
     */
    function _animate(
      _actx,
      animation,
      element,
      oldDomNodes,
      insertAndActivateFunc,
      removeOldDomNodes,
      transitionComplete
    ) {
      var actx = _actx;
      var canAnimateFunc = animation.canAnimate;
      var animating = canAnimateFunc == null || canAnimateFunc.call(animation, actx);

      if (!animating) {
        return undefined;
      }

      var newViewParent;
      var oldViewParent;

      var settings = animation.prepareAnimation.call(animation, actx);
      if (settings) {
        newViewParent = settings.newViewParent;
        oldViewParent = settings.oldViewParent;
      }

      var targetElement = newViewParent || element;

      if (oldViewParent && oldViewParent !== element) {
        _moveDomNodes(oldDomNodes, oldViewParent);
      } else if (targetElement === element) {
        removeOldDomNodes(null);
      }
      // remove all nodes from the target element if it is not the main element managed by ojModule (that one is cleaned
      // separately, and it also contains cached views
      if (targetElement !== element) {
        ko.virtualElements.setDomNodeChildren(targetElement, []);
      }

      insertAndActivateFunc(targetElement);

      var newDomNodes = Array.prototype.slice.call(targetElement.childNodes);

      var viewInserted = false;

      var insertNewView = function () {
        if (viewInserted) {
          return;
        }
        viewInserted = true;
        if (element !== targetElement) {
          _insertNodes(element, newDomNodes);

          var isCustomElement = element.parentNode && element.parentNode.nodeName === 'OJ-MODULE'; // custom element check
          // For upstream or indirect dependency we will still rely components being registered on the oj namespace.
          if (oj.Components && !isCustomElement) {
            // The subtree just got moved to a new parent, so notify components
            // of the 'detach' imeddiately followed by the 'attach'
            _invokeOnSubtree(newDomNodes, oj.Components.subtreeDetached);
            _invokeOnSubtree(newDomNodes, oj.Components.subtreeAttached);
          }
        }
      };

      var removeOldView = removeOldDomNodes.bind(null, oldViewParent); // pass oldViewParent as the first parameter

      actx.newViewParent = newViewParent;
      actx.oldViewParent = oldViewParent;
      actx.oldViewNodes = oldDomNodes;
      actx.removeOldView = removeOldView;
      actx.insertNewView = insertNewView;

      var postAnimation = function () {
        removeOldView();
        insertNewView();
        transitionComplete();
      };

      var animationPromise = animation.animate.call(animation, actx).then(
        postAnimation, // success
        function () {
          // failure
          postAnimation();
          Logger.error('ojModule animation promise was rejected');
        }
      );

      return animationPromise;
    }

    /**
     * @ignore
     */
    function _detachOldView(element, _oldViewParent, cacheHolder) {
      var oldViewParent = _oldViewParent || element;
      var empty = [];
      // If the node being emptied is the ojModule host node, ensure that the cacheHolder stays
      if (cacheHolder && element === oldViewParent) {
        // Remove cacheHolder to avoid bindoings being deactivated
        cacheHolder.parentNode.removeChild(cacheHolder);
        empty.push(cacheHolder);
      }
      ko.virtualElements.setDomNodeChildren(oldViewParent, empty);
    }

    /**
     * @ignore
     */
    function _moveDomNodes(nodes, target) {
      nodes.forEach(function (n) {
        target.appendChild(n); // @HTMLUpdateOK child nodes are module view
      });
    }

    /**
     * @ignore
     */
    function _isBindingApplied(nodes, model) {
      var bindingContext;
      for (var i = 0; i < nodes.length; i++) {
        bindingContext = ko.contextFor(nodes[i]);
        if (bindingContext) {
          break;
        }
      }
      return bindingContext && bindingContext.$module && bindingContext.$module === model;
    }

    /**
     * @ignore
     */
    function _isDocumentFragment(content) {
      if (window.DocumentFragment) {
        return content instanceof DocumentFragment;
      }

      return content && content.nodeType === 11;
    }

    /**
     * @ignore
     */
    function _dispatchLifecycleEvent(element, eventName, params) {
      var detail = {};
      if (params[0]) {
        detail.viewModel = params[0];
      }
      if (params[1]) {
        detail.view = params[1];
      }
      var customEvent = new CustomEvent(eventName, { detail: detail });
      element.dispatchEvent(customEvent);
    }

    /**
     * @ignore
     */
    function _invokeLifecycleListener(listener, method, params) {
      if (listener && listener[method]) {
        var data = { element: params[0], valueAccessor: params[1] };
        if (params.length > 2) {
          data.viewModel = params[2];
          if (params.length > 3) {
            data[typeof params[3] === 'boolean' ? 'fromCache' : 'cachedNodes'] = params[3];
          }
        }
        // : suspend dependency detection while listeners are invoked
        var ret = ko.ignoreDependencies(listener[method], listener, [data]);
        return ret;
      }
      return undefined;
    }

    /**
     * @ignore
     * @param {?Object} model
     * @param {string} key
     * @param {Array=} params
     * @return {Object|undefined}
     */
    function _invokeViewModelMethod(model, key, params) {
      if (model == null) {
        return undefined;
      }
      var name = ModuleBinding.defaults[key];
      if (name != null && model) {
        var handler = model[name];
        if (typeof handler === 'function') {
          var data;
          if (params) {
            data = { element: params[0], valueAccessor: params[1] };
            if (params.length > 2) {
              data[typeof params[2] === 'boolean' ? 'fromCache' : 'cachedNodes'] = params[2];
            }
          }
          // : suspend dependency detection while listeners are invoked
          var ret = ko.ignoreDependencies(handler, model, [data]);
          return ret;
        }
      }
      return undefined;
    }

    /**
     * @ignore
     * @param {?Object} model
     * @param {string} name
     * @param {Array} params
     */
    function _invokeViewModelMethodOnElement(model, name, params) {
      if (model && name) {
        var handler = model[name];
        if (typeof handler === 'function') {
          // suspend dependency detection while listeners are invoked
          ko.ignoreDependencies(handler, model, [params]);
        }
      }
    }

    /**
     * @ignore
     */
    function _getContainedNodes(container, cacheHolder, endCommentNode) {
      var childList = [];
      var firstChild = ko.virtualElements.firstChild(container);

      for (var node = firstChild; node != null && node !== endCommentNode; node = node.nextSibling) {
        if (node !== cacheHolder) {
          childList.push(node);
        }
      }

      return childList;
    }

    /**
     * @ignore
     */
    function _getKoNodes(container, cacheHolder) {
      const koNodes = [];
      const childNodes = ko.virtualElements.childNodes(container);

      for (let i = 0; i < childNodes.length; i++) {
        const node = childNodes[i];
        if (node !== cacheHolder) {
          const type = node.nodeType;
          if (type === 1 || type === 8) {
            koNodes.push(node);
          }
        }
      }
      return koNodes;
    }

    /**
     * @ignore
     */
    function _koNodesForEach(first, cacheHolder, callback) {
      var node = first;
      while (node != null) {
        var next = ko.virtualElements.nextSibling(node);
        var type = node.nodeType;
        if (node !== cacheHolder && (type === 1 || type === 8)) {
          callback(node);
        }
        node = next;
      }
    }

    /**
     * @ignore
     */
    function _applyBindingsToNodes(parentNode, first, bindingContext, cacheHolder) {
      // Workaround for KO not calling preprocessNode() on the node where .applyBindings() is called
      var provider = ko.bindingProvider.instance;
      var preprocessNode = provider.preprocessNode;

      if (preprocessNode) {
        _koNodesForEach(first, cacheHolder, function (node) {
          preprocessNode.call(provider, node);
        });

        // Get the new first node since a new node could have been inserted at the very top
        // eslint-disable-next-line no-param-reassign
        first = ko.virtualElements.firstChild(parentNode);
      }

      _koNodesForEach(first, cacheHolder, function (node) {
        ko.applyBindings(bindingContext, node);
      });
    }

    /**
     * @ignore
     */
    function _insertNodes(container, nodes) {
      var nodeCount = nodes.length;
      for (var i = nodeCount - 1; i >= 0; i--) {
        ko.virtualElements.prepend(container, nodes[i]); // @HTMLUpdateOK nodes are the module view
      }
    }

    /**
     * @ignore
     */
    function _createAnimationContext(
      node,
      valueAccessor,
      isInitial,
      oldViewModel,
      newViewModel,
      isCustomElement
    ) {
      return {
        node: isCustomElement ? node.parentNode : node,
        valueAccessor: isCustomElement ? null : valueAccessor,
        isInitial: isInitial,
        oldViewModel: oldViewModel,
        newViewModel: newViewModel
      };
    }

    /**
     * @ignore
     */
    function _invokeOnSubtree(nodeArray, method) {
      if (method) {
        for (var i = 0; i < nodeArray.length; i++) {
          var node = nodeArray[i];
          if (node.nodeType === 1 /* element*/) {
            method(node);
          }
        }
      }
    }

    /**
     * @ignore
     */
    function _getDomNodes(_content, resolveBusyState) {
      var content = _content;
      if (typeof content === 'string') {
        content = ko.utils.parseHtmlFragment(content, document);
      } else if (_isDocumentFragment(content)) {
        content = ko.utils.arrayPushAll([], content.childNodes);
      } else if (Array.isArray(content)) {
        content = ko.utils.arrayPushAll([], content);
      } else {
        resolveBusyState();
        throw new Error('The View (' + content + ') has an unsupported type');
      }
      return content;
    }

    /**
     * This method gets replaced by JET's Webpack plugin to implement dynamic module loading under Webpack.
     * @ignore
     */
    function _getOjModuleRequirePromise(_requireFunc, type, module) {
      // Note that the 'type' parameter is not used by the implementation below.
      // It is, however, used by the Webpack-specific implementation of this function.
      var requireFunc = _requireFunc || require;
      var p = new Promise(function (resolve, reject) {
        requireFunc([module], resolve, reject);
      });

      p = p.catch(function (e) {
        Logger.error('ojModule failed to load ' + module);
        throw e;
      });

      return p;
    }

    /**
     * @ignore
     */
    function _createNoFailPromise(promise) {
      if (!promise) {
        return promise;
      }
      var noFail = new Promise(
        // eslint-disable-next-line no-unused-vars
        function (resolve, reject) {
          promise.then(resolve, resolve);
        }
      );
      return noFail;
    }

    /**
     * @ignore
     */
    function _checkForReusedView(element, nodes, model, isCustomElement, resolveBusyState) {
      //   - <oj-module> does not give any indication to the page author if the previously cleaned view is being reused
      // Throw an error if the view is being reused, else set a non-enumerable property for the next time check
      if (isCustomElement && nodes.length > 0 && !_isBindingApplied(nodes, model)) {
        if (nodes[0]._oj_module_used_view) {
          resolveBusyState();
          throw new Error(
            "The oj-module with id '" +
              element.id +
              "' cannot apply binding on a previously cleaned view."
          );
        } else {
          Object.defineProperty(nodes[0], '_oj_module_used_view', { value: true });
        }
      }
    }
  })();

  return ModuleBinding;

});


define('ojs/ojmodule-element',['knockout', 'ojs/ojcontext', 'ojs/ojmodule', 'ojs/ojcomposite', 'ojs/ojcustomelement-utils'], function (ko, Context, ojmodule, Composite, ojcustomelementUtils) { 'use strict';

  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   * @ojcomponent oj.ojModule
   * @since 4.2.0
   * @ojdisplayname ojModule Element
   * @ojshortdesc A module is a navigational element that manages content replacement within a particular region of the page.
   * @ojsignature {target: "Type", value: "class ojModule extends JetElement<ojModuleSettableProperties>"}
   *
   * @ojoracleicon 'oj-ux-ico-code'
   *
   * @classdesc
   * <h3 id="ojModuleOverview-section">
   *   JET Module
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ojModuleOverview-section"></a>
   * </h3>
   *
   * <p>
   * The oj-module custom element is used for binding a view and a corresponding view model to an element
   * to provide content replacement within a particular region of the page. In case of a single page application
   * the element <code>config</code> attribute defines navigation within a region.
   * </p>
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-module config='[[moduleConfig]]' animation='[[moduleAnimation]]'>
   * &lt;/oj-module>
   * </code>
   * </pre>
   * <p><b>ModuleElementUtils</b> - You can use ModuleElementUtils helper methods in conjunction with oj-module
   * to generate a configuration object for the element. See the demos and documentation for
   * the <a href="ModuleElementUtils.html">ModuleElementUtils</a> class for details on the available methods.</p>
   *
   * <h2 id="lifecycle">View Models
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#viewmodel"></a>
   * </h2>
   * <h3 id="lifecycle">Lifecycle
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#lifecycle"></a>
   * </h3>
   * <p>
   * If a ViewModel is provided as a part of configuration for the oj-module element, it should implement the
   * <a href="oj.ModuleViewModel.html">ModuleViewModel</a> interface to provide lifecycle callbacks.
   * See the lifecycle methods that could be implemented on the view model
   * that will be called at each stage of the component's lifecycle.
   * </p>
   *
   * <h3 id="lifecycle">Best Practices
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#bestpractice"></a>
   * </h3>
   * <p>
   * We recommend using non-singleton ViewModels for modules that may contain
   * child modules. If the parent module's ViewModel has to be a singleton,
   * application developers have to ensure that a new view is being returned
   * every time the child module is re-rendered (this can be achieved by binding
   * the child module's config object to a function call).
   * </p>
   * <p>
   * When the parent module is cleaning its view, it will not stop at the
   * boundary of the child module, i.e. the entire DOM hierarchy will be cleaned.
   * This creates problems when the cleaned child module's view is cached.
   * To avoid this issue, only cache child modules if their parent modules are also being cached,
   * or ensure that the child module's cache is emptied when the parent module's view is about
   * to be cleaned (see the <a href="oj.ModuleViewModel.html#disconnected">disconnected</a> callback
   * and the <a href="oj.ojModule.html#event:viewDisconnected">ojViewDisconnected</a> event).
   * </p>
   */

  /**
   * Configuration object that defines a view and a corresponding view model responsible the markup section
   * under oj-module. An application can also specify a clean up mode for the view as a part of the configuration object.
   * See details for each attribute.  The configuration object can be specified either directly or via a Promise.
   *
   * @member
   * @name config
   * @memberof! oj.ojModule
   * @instance
   * @type {Object|Promise}
   * @ojshortdesc The module configuration object. See the Help documentation for more information.
   *
   * @example <caption>Initialize the ojModule element with the <code class="prettyprint">config</code> attribute:</caption>
   * &lt;oj-module config='[[moduleConfig]]'>&lt;/oj-module>
   *
   * @example <caption>Get or set the <code class="prettyprint">accept</code> property after initialization:</caption>
   * // getter
   * var config = myModule.config;
   *
   * // setter
   * myModule.config = {'view':view,'viewModel':viewModel}; // where view is an Array of DOM nodes and viewModel is a model object for the view
   */

  /**
   * Defines the view for the ojModule.
   * <p>Note that oj-module will not be cloning the node array before using it as the module's View
   * and applying bindings to it. If the application needs to have an access to the original node array,
   * it should be setting the 'view' property to a cloned copy.</p>
   * @expose
   * @name config.view
   * @ojshortdesc Defines module view.
   * @memberof! oj.ojModule
   * @instance
   * @type {Array.<Node>}
   * @default null
   */

  /**
   * Defines model for the view.
   * <p>The following optional lifecycle methods can be defined on the ViewModel object and will be called
   * at the corresponding lifecycle stage. See <a href="oj.ojModule.html#lifecycle">View Model Lifecycle section</a></p>
   * @expose
   * @name config.viewModel
   * @ojshortdesc The ViewModel instance.
   * @memberof! oj.ojModule
   * @instance
   * @type {(Object|null)=}
   * @ojsignature {target: "Type", value: "oj.ModuleViewModel|null", jsdocOverride:true}
   * @default null
   */

  /**
   * Defines the clean up mode for the view. The setting allows an application to use an external cache for the view and view model.
   * By default the oj-module element will clean up and release the view nodes when the view is removed from the DOM.
   * If an application wants to keep the view and view model in memory for faster access,
   * it should set the cleanupMode to "none" and retain references to the view and viewModel to be used when the module is reloaded.
   * Note, when the cached view is no longer needed, the application should call the Knockout <code>ko.cleanNode()</code> method
   * on all the top-level nodes in the view.
   * Also, if the cached view might receive observable changes, it must be kept connected in the DOM (perhaps with the CSS <code>display:none</code> style).
   * @expose
   * @name config.cleanupMode
   * @ojshortdesc The cleanup mode for the view.
   * @memberof! oj.ojModule
   * @instance
   * @type {string}
   * @default "onDisconnect"
   * @ojsignature { target: "Type",
   *                value: "?"}
   * @ojvalue {string} "onDisconnect" The View nodes will be destroyed on disconnect.
   * @ojvalue {string} "none" Use the setting to preserve the view, e.g. if the view and view model will be stored in external cache.
   */

  /**
   * Instance of the {@link oj.ModuleElementAnimation} duck-typing interface that will manage animation effects during View transitions.
   * Note that during the animation transition, the original View and the View that is being transitioned to may both be simultaneously
   * attached to the DOM.  Consequently, it is the application's responsbility to ensure that element IDs are unique across Views.
   * @member
   * @name animation
   * @memberof! oj.ojModule
   * @instance
   * @type {Object}
   * @default null
   * @ojshortdesc Specifies an animation object used for view transitions. See the Help documentation for more information.
   * @ojsignature {target: "Type", value: "ModuleElementAnimation", jsdocOverride:true}
   */

  /**
   * Triggered before transition to the new View is started - before View is inserted into the DOM.
   * @member
   * @name transitionStart
   * @memberof oj.ojModule
   * @instance
   * @event
   * @ojshortdesc Triggered before transition to the new View is started
   * @property {Object} viewModel ViewModel for the new View.
   * @ojsignature {target: "Type", value: "oj.ModuleViewModel", for: "viewModel", jsdocOverride:true}
   */

  /**
   * Triggered after the View is inserted into the DOM.
   * @member
   * @name viewConnected
   * @memberof oj.ojModule
   * @instance
   * @event
   * @ojshortdesc Triggered after the View is inserted into the DOM
   * @property {Object} viewModel ViewModel for the View being attached to the DOM.
   * @ojsignature {target: "Type", value: "oj.ModuleViewModel", for: "viewModel", jsdocOverride:true}
   */

  /**
   * Triggered after transition to the new View is complete. That includes any possible animation between the old and the new View.
   * @member
   * @name transitionEnd
   * @memberof oj.ojModule
   * @instance
   * @event
   * @ojshortdesc Triggered after transition to the new View is complete
   * @property {Object} viewModel ViewModel for the new View.
   * @ojsignature {target: "Type", value: "oj.ModuleViewModel", for: "viewModel", jsdocOverride:true}
   */

  /**
   * Triggered after the View is removed from the DOM
   * @member
   * @name viewDisconnected
   * @memberof oj.ojModule
   * @instance
   * @event
   * @ojshortdesc Triggered after the View is removed from the DOM
   * @property {Object} viewModel An array of DOM nodes that represent the disconnected View. The application can use the nodes to store them in cache.
   * @property {Array.<Node>} view ViewModel for the new View.
   * @ojsignature {target: "Type", value: "oj.ModuleViewModel", for: "viewModel", jsdocOverride:true}
   */

  function moduleViewModel(context) {
    var element = context.element;
    var props = context.properties;
    var self = this;
    this.animation = context.properties.animation;
    this.config = ko.observable({ view: [] });
    this.configPromise = null;

    this.propertyChanged = function (detail) {
      if (detail.property === 'animation') {
        self.animation = detail.value;
      } else if (detail.property === 'config') {
        updateConfig();
      }
    };

    function updateConfig() {
      if (!self.busyCallback) {
        self.busyCallback = Context.getContext(element)
          .getBusyContext()
          .addBusyState({ description: 'oj-module is waiting on config Promise resolution' });
      }
      var configPromise = Promise.resolve(props.config);
      self.configPromise = configPromise;
      configPromise.then(
        function (config) {
          if (configPromise === self.configPromise) {
            // Make sure the promise that just resolved is the latest one we're waiting for
            self.config(config);
            self.busyCallback();
            self.busyCallback = null;
          }
        },
        function (reason) {
          if (configPromise === self.configPromise) {
            // Make sure the promise that just resolved is the latest one we're waiting for
            self.busyCallback();
            self.busyCallback = null;
            throw reason;
          }
        }
      );
    }

    updateConfig();

    function isViewAttached(config) {
      var view = config ? config.view : null;
      var testNode = view && view.length > 0 ? view[0][ojcustomelementUtils.OJ_BIND_CONVERTED_NODE] || view[0] : null;
      return testNode && element.contains(testNode);
    }

    function invokeViewModelMethod(model, name) {
      var handler = model && model[name];
      if (typeof handler === 'function') {
        ko.ignoreDependencies(handler, model);
      }
    }

    function dispatchLifecycleEvent(eventName, viewModel, view) {
      var detail = {};
      if (viewModel) {
        detail.viewModel = viewModel;
      }
      if (view) {
        detail.view = view;
      }
      var customEvent = new CustomEvent(eventName, { detail: detail });
      element.dispatchEvent(customEvent);
    }

    this.connected = function () {
      var currentConfig = this.config();
      if (isViewAttached(currentConfig)) {
        invokeViewModelMethod(currentConfig.viewModel, 'connected');
        dispatchLifecycleEvent('ojViewConnected', currentConfig.viewModel);
      }
    }.bind(this);

    this.disconnected = function () {
      var currentConfig = this.config();
      invokeViewModelMethod(currentConfig.viewModel, 'disconnected');
      dispatchLifecycleEvent('ojViewDisconnected', currentConfig.viewModel, currentConfig.view);
    }.bind(this);
  }

  var moduleValue =
    '{"view":config().view, "viewModel":config().viewModel,' +
    '"cleanupMode":config().cleanupMode,"animation":animation}';

  var moduleView = '<!-- ko ojModule: ' + moduleValue + ' --><!-- /ko -->';

var __oj_module_metadata = 
{
  "properties": {
    "animation": {
      "type": "object"
    },
    "config": {
      "type": "object|Promise",
      "properties": {
        "cleanupMode": {
          "type": "string",
          "enumValues": [
            "none",
            "onDisconnect"
          ],
          "value": "onDisconnect"
        },
        "view": {
          "type": "Array<Node>"
        },
        "viewModel": {
          "type": "object"
        }
      }
    }
  },
  "events": {
    "ojTransitionEnd": {},
    "ojTransitionStart": {},
    "ojViewConnected": {},
    "ojViewDisconnected": {}
  },
  "extension": {}
};
  /* global __oj_module_metadata */
  // eslint-disable-next-line no-undef
  Composite.register('oj-module', {
    view: moduleView,
    metadata: __oj_module_metadata,
    viewModel: moduleViewModel
  });

  /**
   * A duck-typing interface that defines a contract for managing animations during the oj-module element View transitions.
   * Use 'animation' attribute on the [Module]{@link oj.ojModule#animation} to set ModuleElementAnimation instance.
   * @interface ModuleElementAnimation
   * @memberof oj
   * @since 4.2.0
   * @export
   *
   */

  /**
   * Optional method that determines whether the animated transition should proceed. If the method is not implemented, all
   * transitions will be allowed to proceed
   * @method
   * @name canAnimate
   *
   * @param {Object} context a context object with the keys detailed below
   * @param {Node} context.node a DOM node for the oj-module element
   * @param {boolean} context.isInitial true if the initial View is about to be displayed, false otherwise
   * @param {Object} context.oldViewModel the instance of the ViewModel for the old View
   * @param {Object} context.newViewModel the instance of the ViewModel for the new View
   *
   * @return {boolean} true if animation should proceed, false otherwise
   * @memberof oj.ModuleElementAnimation
   * @ojsignature [{target: "Type", value: "oj.ModuleViewModel", for:"context.oldViewModel", jsdocOverride:true},
   *               {target: "Type", value: "oj.ModuleViewModel", for:"context.newViewModel", jsdocOverride:true}]
   * @instance
   */

  /**
   * Prepares animation by designating where the new View should be inserted and optionally specifying where the old View
   * should be moved
   * @method
   * @name prepareAnimation
   *
   * @param {Object} context a context object with the keys detailed below
   * @param {Node} context.node a DOM node for the oj-module element
   * @param {boolean} context.isInitial true if the initial View is about to be displayed, false otherwise
   * @param {Object} context.oldViewModel the instance of the ViewModel for the old View
   * @param {Object} context.newViewModel the instance of the ViewModel for the new View
   *
   * @return {?Object} an object that may contain values for the following keys:
   * <ul>
   * <li>'newViewParent' - a DOM node where the new View should be inserted. If this parameter is not specified, the new View
   * will be inserted into the node associated with the oj-module element</li>
   * <li>'oldViewParent' - a DOM node where the old View should be moved. If this parameter is not specified, the old View
   * will not be moved</li>
   * </ul>
   * @memberof oj.ModuleElementAnimation
   * @ojsignature [{target: "Type", value: "oj.ModuleViewModel", for:"context.oldViewModel", jsdocOverride:true},
   *               {target: "Type", value: "oj.ModuleViewModel", for:"context.newViewModel", jsdocOverride:true},
   *               {target: "Type", value: "null|{ newViewParent?: Node, oldViewParent?: Node }", for: "returns"}]
   * @instance
   */

  /**
   * Prepares animation by designating where the new View should be inserted and optionally specifying where the old View
   * should be moved
   * @method
   * @name animate
   *
   * @param {Object} context a context object with the keys detailed below
   * @param {Node} context.node a DOM node for the oj-module element
   * @param {boolean} context.isInitial true if the initial View is about to be displayed, false otherwise
   * @param {Object} context.oldViewModel the instance of the ViewModel for the old View
   * @param {Object} context.newViewModel the instance of the ViewModel for the new View
   * @param {Node} context.newViewParent the 'newViewParent' parameter returned by the prepareAnimation() method
   * @param {Node} context.oldViewParent the 'oldViewParent' parameter returned by the prepareAnimation() method
   * @param {Function} context.removeOldView calling this function will remove the DOM nodes representing the old View. If this
   * function is not invoked by the ModuleElementAnimation implementation, and the old View is still connected when the Promise is
   * resolved, the old View will be removed by the component.
   * @param {Function} context.insertNewView calling this function will insert new View's DOM nodes into the location
   * managed by the component. If this function is not invoked by the ModuleElementAnimation implementation, and the new View is not at
   * its intended location when the Promise is resolved, the View will be moved by the component.
   * @param {Array} context.oldDomNodes an array of DOM nodes representing the old View
   * @return {Promise} - a Promise that should be resolved when the animation, moving/removing of DOM nodes and the
   * cleanup are complete. Note that the component will not be able to navigate to a new View until the Promise is resolved.
   * @ojsignature [{target: "Type", value: "oj.ModuleViewModel", for:"context.oldViewModel", jsdocOverride:true},
   *               {target: "Type", value: "oj.ModuleViewModel", for:"context.newViewModel", jsdocOverride:true},
   *               {target: "Type", value: "()=> undefined", for:"context.removeOldView"},
   *               {target: "Type", value: "()=> undefined", for:"context.insertNewView"}]
   * @memberof oj.ModuleElementAnimation
   * @instance
   */

  /**
   * A duck-typing interface that defines a contract for a view model consumed by the oj-module element.
   *
   * @since 7.0.0
   * @export
   * @interface ModuleViewModel
   * @memberof oj
   */

  /**
   * This optional method may be implemented on the ViewModel and will be invoked
   * after the View is inserted into the DOM.
   * This method might be called multiple times - after the View is created and
   * inserted into the DOM, after the View is reconnected after being disconnected
   * and after a parent element, oj-module, with attached View is reconnected to the DOM.
   * An array of DOM nodes that represent the connected View will be passed to the callback.
   * @method
   * @since 7.0.0
   * @name connected
   * @ojshortdesc A callback method that is invoked after the View is inserted into the DOM.
   * @memberof oj.ModuleViewModel
   * @instance
   * @ojsignature {target: "Type", value: "?(view:Array<Node>): void"}
   */

  /**
   * This optional method may be implemented on the ViewModel and invoked
   * after transition to the new View is complete, including any possible
   * animation between the old and the new View.
   * An array of DOM nodes that represent the new View will be passed to the callback.
   * @method
   * @since 7.0.0
   * @name transitionCompleted
   * @ojshortdesc A callback method that is invoked after transition to the new View is complete.
   * @memberof oj.ModuleViewModel
   * @instance
   * @ojsignature {target: "Type", value: "?(view:Array<Node>): void"}
   */

  /**
   * This optional method may be implemented on the ViewModel and will be invoked
   * when the View is disconnected from the DOM.
   * This method might be called multiple times - after the View is disconnected
   * from the DOM and after a parent element, oj-module, with attached View is
   * disconnected from the DOM.
   * An array of DOM nodes that represent the disconnected View will be passed to the callback.
   * @method
   * @since 7.0.0
   * @name disconnected
   * @ojshortdesc A callback method that is invoked after View is disconnected from the DOM.
   * @memberof oj.ModuleViewModel
   * @instance
   * @ojsignature {target: "Type", value: "?(view:Array<Node>): void"}
   */

  /**
   * This optional method may be implemented on the ViewModel and will be invoked
   * by <a href="oj.ModuleRouterAdapter.html">ModuleRouterAdapter</a> on <code>beforeStateChange</code> event
   * assuming that oj-module is used in conjuction with ModuleRouterAdapter.
   * <p>This method must return a Promise. When defined the method is invoked
   * before router state change. If the Promise is resolved, then the BaseRouter will continue
   * with the state change, otherwise (Promise rejected) the state change is vetoed and the current router state
   * does not change.<p>
   * <p>Note, that the method might be called at any time after the view model is created, e.g. before the corresponding view has been connected or bindings have been applied.</p>
   * @method
   * @since 8.0.0
   * @name canExit
   * @ojshortdesc A callback method that is invoked before BaseRouter state change.
   * @memberof oj.ModuleViewModel
   * @instance
   * @ojsignature {target: "Type", value: "?(): Promise<void>"}
   */

  /**
   * This optional method may be implemented on the ViewModel and will be invoked
   * by <a href="oj.ModuleRouterAdapter.html">ModuleRouterAdapter</a> on <code>stateChange</code> event
   * assuming that oj-module is used in conjuction with ModuleRouterAdapter.
   * <p>If the method is present the ModuleRouterAdapter will assume that the view model knows how to handle parameter
   * change. It will not reload the module and re-apply binding. If the method is not present the ModuleRouterAdapter
   * will reload the module and apply the binding upon any parameter change.</p>
   * <p>Note, that the method might be called at any time after the view model is created, e.g. before the corresponding view has been connected or bindings have been applied.</p>
   * @method
   * @since 8.0.0
   * @name parametersChanged
   * @ojshortdesc A callback method that might be invoked on BaseRouter state change.
   * @memberof oj.ModuleViewModel
   * @instance
   * @ojsignature {target: "Type", value: "?(params:any): void"}
   */

});


define('ojs/ojmodule-element-utils',['exports', 'ojs/ojcore-base', 'ojs/ojhtmlutils'], function (exports, oj, HtmlUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @namespace
   * @name ModuleElementUtils
   *
   * @ojtsmodule
   * @ojtsimport {module: "ojmodule-element", type: "AMD", imported: ["ModuleViewModel"]}
   * @classdesc
   * <h3>Utility methods for oj-module element</h3>
   * <p>ModuleElementUtils is a helper object that provides convenience methods for creating views, view models or entire oj-module configuration objects using RequireJS.
   * </p>
   * <h3>Conventions</h3>
   * <h4>View</h4>
   * <ul>
   *  <li>Views should have .html extension.</li>
   *  <li>In addition to loading the view, both the createView() and createConfig() methods will convert the loaded view into an array of nodes, as expected by oj-module.</li>
   * </ul>
   * <h4>View Model</h4>
   * <ul>
   *  <li>ViewModel modules should have .js extension.</li>
   *  <li>The view model is loaded as an AMD module and the value is expected to be either a constructor function or an object - a view model instance.</li>
   *  <li>See descriptions of the createViewModel() and createConfig() methods for details on how the loaded module is handled.</li>
   * </ul>
   *
   * <h3> Create configuration object using createView() and createViewModel()</h3>
   * <pre class="prettyprint"><code>
   * //define oj-module config as a Promise that resolves into a configuration object
   * self.moduleConfig = Promise.all([
   *   moduleElementUtils.createView({'viewPath':'views/dashboard/page.html'}),
   *   moduleElementUtils.createViewModel({'viewModelPath':'viewModels/dashboard/page'})
   *  ])
   *  .then(
   *    function(values){
   *      return {'view':values[0],'viewModel':values[1]};
   *    },
   *    function(reason){}
   *  );
   * </code></pre>
   *
   * <h3> Create configuration object using createConfig()</h3>
   * <pre class="prettyprint"><code>
   * //define oj-module config as a Promise that resolves into a configuration object
   * self.moduleConfig = moduleElementUtils.createConfig({ name: 'dashboard/page', params: {value:'A'} });
   * </code></pre>
   *
   * @hideconstructor
   * @since 5.0.0
   */
  const ModuleElementUtils = {};

  oj._registerLegacyNamespaceProp('ModuleElementUtils', ModuleElementUtils);

  /**
   * Utility function for creating a view to be used in configuration object for oj-module.
   * @since 5.0.0
   *
   * @param {Object} options Options object used to create a view
   * @param {string} options.viewPath The path to the view, relative to the RequireJS baseURL.
   *                                  The text plugin will be used for loading the view.
   * @param {Function=} options.require An optional instance of the require() function to be used for loading the view.
   *                    By default the path is relative to the baseUrl specified for the application require calls.
   *
   * @example <caption>Get promise for the view</caption>
   * var viewPromise = moduleElementUtils.createView({'viewPath':'views/dashboard/page.html'});
   *
   * @return {Promise} A promise that resolves into an array of DOM nodes
   * @ojsignature [
   *   {target: "Type", for: "options.require", value: "((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void)"},
   *   {target: "Type", value: "(options: {viewPath: string, require?: ((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void)}):Promise<Node[]>"}]
   * @memberof! ModuleElementUtils
   * @static
   */
  ModuleElementUtils.createView = function (options) {
    if (!(options && options.viewPath)) {
      return Promise.resolve([]);
    }

    return (
      new Promise(function (resolve, reject) {
        var requireFunc = options.require ? options.require : require;
        requireFunc(['text!' + options.viewPath], resolve, reject);
      })
        // NOTE: Do not put any calls referencing imported modules in this method. They
        // will cause issues during Webpack. The post-processing of the view HTML text
        // using HtmlUtils is moved to _processViewText because of this.
        .then(ModuleElementUtils._processViewText)
    );
  };

  /**
   * Read HTML content as text to construct HTMLElements.
   * This method is needed so that calls to HtmlUtils can be properly Webpack'd
   * when referenced from createView.
   * @param {string} viewText The view HTML as a string
   * @return Array<HTMLElement> An array of HTMLElement(s) from the parsed text
   * @private
   */
  ModuleElementUtils._processViewText = function (viewText) {
    return HtmlUtils.stringToNodeArray(viewText);
  };
  /**
   * Utility function for creating a view model to be used in configuration object for oj-module.
   * @since 5.0.0
   *
   * @param {Object} options Options object used to create a view model
   * @param {string} options.viewModelPath The path to the model, relative to the RequireJS baseURL.
   * @param {Function=} options.require An optional instance of the require() function to be used for loading the view model.
   *                  By default the path is relative to the baseUrl specified for the application require calls.
   * @param {any=} options.params Parameters object that will be passed either to the model constructor or
   *                  to the <code>initialize</code> method on the loaded model.
   * @param {('always'|'never'|'ifParams')=} options.initialize valid values are "always", "never", "ifParams" (default)
   *                  <ul>
   *                   <li>always - the model will be instantiated from the constructor whether parameters are given or not.</li>
   *                   <li>never - an instance or a constructor will be given to the application and the application is responsible for constructing the model instance.</li>
   *                   <li>ifParams - the model will be instantiated from the constructor or <code>initialize</code> method will be called on the instance,
   *                       when parameters object is specified.</li>
   *                  </ul>
   * @example <caption>Get promise for the model</caption>
   * var modelPromise = moduleElementUtils.createViewModel({'viewModelPath':'viewModels/dashboard/page'});
   *
   * @return {Promise} A promise that contains either model instance or a model constructor.
   *                  When the promise is resolved into a constructor, the application is responsible
   *                  for constructing the model instance before passing it to the configuration object on the oj-module.
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "P", for: "options.params"},
   *               {target: "Type", for: "options.require", value: "((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void)"},
   *               {target: "Type", value: "(options: {viewModelPath: string, params?: P, require?: ((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void),initialize?: 'always' | 'never' | 'ifParams'}):Promise<oj.ModuleViewModel|Function>"}]
   * @memberof! ModuleElementUtils
   * @static
   */
  ModuleElementUtils.createViewModel = function (options) {
    if (!(options && options.viewModelPath)) {
      return Promise.resolve(null);
    }

    return new Promise(function (resolve, reject) {
      var requireFunc = options.require ? options.require : require;
      requireFunc([options.viewModelPath], resolve, reject);
    }).then(function (viewModelValue) {
      var viewModel = viewModelValue;
      if (
        viewModel &&
        (options.initialize === 'always' ||
          (options.params != null && options.initialize !== 'never'))
      ) {
        if (typeof viewModel === 'function') {
          // eslint-disable-next-line new-cap
          viewModel = new viewModel(options.params);
        } else if (typeof viewModel.initialize === 'function') {
          viewModel.initialize(options.params);
        }
      }
      return viewModel;
    });
  };

  /**
   * Utility function for creating a configuration object for oj-module.
   * This method uses the name or paths to load a view and a view model and constructs a configuration
   * object for the oj-module element.
   * Note, the view model is loaded as an AMD module. If the returned value is a function,
   * it will be treated as a view model constructor; otherwise the returned value will be treated
   * as a view model instance. When view model parameters are specified, they will be passed to the
   * constructor or to the <code>initialize</code> method on the view model instance.
   * The <code>initialize</code> method on the view model is optional.
   *
   * @since 7.0.0
   *
   * @param {Object} options Options object used to create a view model
   * @param {string=} options.name View model name. If <code>viewPath</code> option is omitted,
   *                  the name is also going to be used for loading the view.
   *                  The view and view model will be loaded using default paths - 'views/' and 'viewModels/'.
   *                  The path is relative to the RequireJS baseURL.
   *                  The text plugin will be used for loading the view.
   *                  Use <code>viewPath</code> and <code>viewModelPath</code>
   *                  when you want to load view and view model from different locations.
   * @param {string=} options.viewPath The path to the view, relative to the RequireJS baseURL.
   *                  The text plugin will be used for loading the view.
   * @param {string=} options.viewModelPath The path to the model, relative to the RequireJS baseURL.
   * @param {Function=} options.require An optional instance of the require() function to be used
   *                  for loading the view and view model. By default the path is relative to the baseUrl
   *                  specified for the application require calls.
   * @param {any=} options.params Parameters object that will be passed either to the model constructor or
   *                  to the <code>initialize</code> method on the loaded model.
   *
   * @example <caption>Get promise for the oj-module configuration object.</caption>
   * var configPromise = moduleElementUtils.createConfig({ name: 'dashboard/page', params: {value:'A'} });
   *
   * @return {Promise} A promise that resolves into a configuration object for oj-module.
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "P", for: "options.params"},
   *               {target: "Type", for: "options.require", value: "((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void)"},
   *               {target: "Type", value: "(options: {name?: string, viewPath?: string, viewModelPath?: string, params?: P, require?: ((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void)}):Promise<{view:Node[], viewModel:oj.ModuleViewModel|null}>"}]
   * @memberof! ModuleElementUtils
   * @static
   */
  ModuleElementUtils.createConfig = function (options) {
    if (!(options && (options.name || options.viewPath))) {
      return Promise.resolve(null);
    }
    var viewPath = options.viewPath || 'views/' + options.name + '.html';
    var modelPath = options.viewModelPath || (options.name ? 'viewModels/' + options.name : null);
    return Promise.all([
      ModuleElementUtils.createView({ viewPath: viewPath, require: options.require }),
      ModuleElementUtils.createViewModel({
        viewModelPath: modelPath,
        require: options.require,
        params: options.params,
        initialize: 'always'
      })
    ]).then(function (values) {
      return { view: values[0], viewModel: values[1] };
    });
  };

  const createView = ModuleElementUtils.createView;
  const createViewModel = ModuleElementUtils.createViewModel;
  const createConfig = ModuleElementUtils.createConfig;

  exports.createConfig = createConfig;
  exports.createView = createView;
  exports.createViewModel = createViewModel;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojanimation',['exports', 'ojs/ojcore-base', 'jquery', 'ojs/ojdomutils', 'ojs/ojthemeutils', 'ojs/ojlogger'], function (exports, oj, $, DomUtils, ThemeUtils, Logger) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  const _TRANSLATE = 'translate(';
  const _TRANSLATE2 = ') translateZ(0)';

  /**
   * @ojshortdesc Utility methods for animating elements.
   *
   * @classdesc <h3 id="custom-animation-section">
   *   Customizing and Disabling Animation
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#custom-animation-section"></a>
   * </h3>
   *
   * Default animations can be customized or disabled at several levels with varying degrees of control:
   * <ol>
   *   <li>For all JET components.</li>
   *   <li>For all instances of a JET component.</li>
   * </ol>
   *
   * <h4>1. For all JET components</h4>
   *
   * <p>There are several theme variables that control the speed of animations in JET.  Applications can change their values
   * to speed up or slow down animations for all components, or to disable animations altogether by setting them to 0:</p>
   * <pre class="prettyprint"><code>$animationDurationShort: .25s !default;
   * $animationDurationMedium: .4s !default;
   * $animationDurationLong: .5s !default;
   * </code></pre>
   * <p>Note that setting them to 0 does not make the actions that invoke animations synchronous.  For example, opening a dialog is an asynchronous
   * action.  By setting the animation duration to 0 simply makes the dialog appear to open immediately.  Events related to the dialog opening
   * are still fired asynchronously, though with a much shorter delay.</p>
   *
   * <h4>2. For All Instances of a JET Component.</h4>
   *
   * <p>Default animations for JET components are defined by component-specific theme variables.  Changing the values of the theme variables for a particular component
   * will affect the default animations for all instances of that component.
   *
   * <h3 id="busy-state-section">
   *   Adding Busy State
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#busy-state-section"></a>
   * </h3>
   *
   * <p>Animations are asynchronous by nature.  Sometimes applications may need to wait for an animation to end before
   *    proceeding with other operations.  All the effect methods in AnimationUtils return promises that are
   *    resolved when the animations end.</p>
   * <p>In cases where applications use the {@link oj.BusyContext} class to track the busy state of components or pages, it is
   *    up to the callers of the effect methods to add busy state to the appropriate context, which may or may not
   *    be the context that contains the element being animated.</p>
   *
   * <h4>Examples</h4>
   * <br>
   * <i>Add a busy state while an animation is in progress:</i>
   * <pre class="prettyprint"><code>
   * // Context node is usually the animated element but can also be a node for any
   * // context that wants to wait for the animation to end.
   * var contextNode = element;
   * var busyContext = oj.Context.getContext(contextNode).getBusyContext();
   * var resolveFunc = busyContext.addBusyState({"description": "Animation in progress"});
   * AnimationUtils.slideOut(element).then(resolveFunc);
   * </code></pre>
   *
   * @namespace
   * @ojtsmodule
   * @since 2.1
   * @export
   * @ojimportmembers Animation
   */
  const AnimationUtils = {};
  oj._registerLegacyNamespaceProp('AnimationUtils', AnimationUtils);
  // this is the variable name that the AMD module will return in the require callback (used in a no-require environment)
  // eslint-disable-next-line no-unused-vars
  // Return a platform-dependent property or event name from a base name
  AnimationUtils._getName = function (element, baseName) {
    if (!AnimationUtils._nameMap) {
      AnimationUtils._nameMap = {};
      var nameMap = AnimationUtils._nameMap;
      var style = element.style;

      // Property names
      nameMap.backfaceVisibility =
        style.webkitBackfaceVisibility !== undefined
          ? 'webkitBackfaceVisibility'
          : 'backfaceVisibility';
      nameMap.transform = style.webkitTransform !== undefined ? 'webkitTransform' : 'transform';
      nameMap.transformOrigin =
        style.webkitTransformOrigin !== undefined ? 'webkitTransformOrigin' : 'transformOrigin';
      nameMap.transition = style.webkitTransition !== undefined ? 'webkitTransition' : 'transition';

      // Event names
      nameMap.transitionend =
        style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
    }

    var mappedName = AnimationUtils._nameMap[baseName];

    return mappedName || baseName;
  };

  AnimationUtils._getElementStyle = function (element, baseName) {
    return element.style[AnimationUtils._getName(element, baseName)];
  };

  AnimationUtils._setElementStyle = function (element, baseName, value) {
    // eslint-disable-next-line no-param-reassign
    element.style[AnimationUtils._getName(element, baseName)] = value;
  };

  /**
   * Main utility function for starting a css transition on an element.<br>
   * Currently this function assumes the following:<br>
   * 1. If multiple properties are animated, they all use the same delay and duration.<br>
   * All css property names should be specified in camel case.
   * @param {Element} element  the HTML element to animate
   * @param {Object} fromState  the css class and properties for setting up the starting state
   * @param {Object} toState  the css class and properties for setting up the ending state
   * @param {Object} options  the common options for the css transition or animation.  This
   *                          include 'delay', 'duration', 'timingFunction', and 'persist'.
   * @param {Array} transProps  an array of css properties being transitioned.
   * @param {Array=} persistProps  an array of css properties to persist if the persist option is set.
   *                               If this is omitted, it will be set to transProps.
   * @return {Promise|IThenable} a promise that will be resolved when the animation ends
   * @private
   */
  AnimationUtils._animate = function (
    element,
    fromState,
    toState,
    options,
    transProps,
    persistProps
  ) {
    var propArray = [].concat(transProps);

    // eslint-disable-next-line no-unused-vars
    var doAnimate = function (resolve, reject) {
      var endListener = function (event) {
        // event.propertyName is the hyphenated name.  Entries in propArray is the
        // camel-case name without prefix.  So we drop any prefix and convert
        // event.propertyName to camel-case before finding it in propArray.
        var basePropName =
          event.propertyName.indexOf('-webkit-') === 0
            ? event.propertyName.substr(8)
            : event.propertyName;
        basePropName = AnimationUtils._getCamelCasePropName(basePropName);
        var idx = propArray.indexOf(basePropName);
        if (idx > -1) {
          if (propArray.length > 1) {
            propArray.splice(idx, 1);
          } else {
            resolvePromise();
          }
        }
      };
      var requestId = 0;
      var promiseResolved = false;

      function resolvePromise() {
        if (!promiseResolved) {
          if (requestId) {
            window.cancelAnimationFrame(requestId);
            requestId = 0;
          }

          element.removeEventListener(AnimationUtils._getName(element, 'transitionend'), endListener);

          if (resolve) {
            resolve(true);
          }
          promiseResolved = true;
        }
      }

      // For css transition, specify the transition value when applying the toState
      // since we don't want to trigger the transition prematurely.
      if (toState == null) {
        // eslint-disable-next-line no-param-reassign
        toState = {};
      }
      if (toState.css == null) {
        // eslint-disable-next-line no-param-reassign
        toState.css = {};
      }
      // eslint-disable-next-line no-param-reassign
      toState.css.transition = AnimationUtils._createTransitionValue(element, transProps, options);

      // Save the orignal style so that we can restore it later if needed
      var effectCount = AnimationUtils._saveStyle(
        element,
        fromState,
        toState,
        options,
        persistProps || transProps
      );

      AnimationUtils._applyState(element, fromState, effectCount > 1);

      element.addEventListener(AnimationUtils._getName(element, 'transitionend'), endListener);

      var duration = options.duration;
      var delay = options.delay;
      var skipPromise = options._skipPromise;

      function transitionFunc() {
        requestId = 0;
        AnimationUtils._applyState(element, toState, effectCount > 1);
      }

      if (fromState == null) {
        // If there is no fromState, assume that we are transitioning from the
        // current state to a new state, so just apply toState immediately.
        transitionFunc();
      } else {
        if (!options._noReflow) {
          // If the final state is the same as current state,
          // requestAnimationFrame may not trigger a transition.  Need to force
          // a reflow after applying the initial state by getting one of several
          // properties that cause reflow.
          //
          // Assign it to an export object so that Closure compiler will not remove
          // this as dead code
          AnimationUtils._x = element.offsetWidth;
        }

        // Add the toState after a delay.  This is necessary to trigger css
        // transition.
        requestId = window.requestAnimationFrame(transitionFunc);
      }

      var totalMs = AnimationUtils._getTotalTiming(duration, delay);
      if (!skipPromise) {
        // There are situations in which the transitionend event is never
        // fired (e.g. removing the transiton property or setting the display
        // property to none.)
        // Add a timeout to avoid having unresolved promise.
        setTimeout(resolvePromise, totalMs + 100);
      }
    };

    // Special option to skip promise to reduce overhead.  A side effect is that
    // no clean up will be done on the element, which is fine if the element is
    // temporary
    if (options._skipPromise) {
      doAnimate(null, null);
      return null;
    }

    var promise = new Promise(doAnimate);
    return promise.then(function () {
      // Remove any temporary effect class when the promise is fulfilled.
      // Do not remove them in the endListener, since the promise fulfillment
      // callback is not in the same animation frame and occurs later than
      // the endListener.  Because any caller cleanup is done on promise
      // fulfillment, the element may flash if we remove the class too early.

      if (fromState && fromState.addClass) {
        $(element).removeClass(fromState.addClass);
      }

      if (toState && toState.addClass) {
        $(element).removeClass(toState.addClass);
      }

      AnimationUtils._restoreStyle(element);
    });
  };

  // Save the element style from a property set
  AnimationUtils._saveCssValues = function (element, css, savedStyle, persistProps) {
    var cssProps = Object.keys(css);
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    for (var i = 0; i < cssProps.length; i++) {
      var cssProp = cssProps[i];
      if (
        !hasOwnProperty.call(savedStyle, cssProp) &&
        (!persistProps || persistProps.indexOf(cssProp) === -1)
      ) {
        // eslint-disable-next-line no-param-reassign
        savedStyle[cssProp] = AnimationUtils._getElementStyle(element, cssProp);
      }
    }
  };

  // Save the original element style before animating it
  AnimationUtils._saveStyle = function (element, fromState, toState, options, persistProps) {
    var savedStyle = element._ojSavedStyle || {};
    var fromStateCss = fromState && fromState.css ? fromState.css : {};
    var toStateCss = toState && toState.css ? toState.css : {};

    var _persistProps = persistProps;
    if (!(options && options.persist === 'all')) {
      _persistProps = null;
    }

    AnimationUtils._saveCssValues(element, fromStateCss, savedStyle, _persistProps);
    AnimationUtils._saveCssValues(element, toStateCss, savedStyle, _persistProps);

    // eslint-disable-next-line no-param-reassign
    element._ojSavedStyle = savedStyle;

    // Remember how many times this is called to allow composite animation
    var effectCount = element._ojEffectCount || 0;
    effectCount += 1;
    // eslint-disable-next-line no-param-reassign
    element._ojEffectCount = effectCount;

    return effectCount;
  };

  // Restore the original element style
  AnimationUtils._restoreStyle = function (_element) {
    var element = _element;
    var effectCount = element._ojEffectCount;

    // In case of composite animation, restore style when the last effect has ended
    if (effectCount > 1) {
      element._ojEffectCount = effectCount - 1;
    } else {
      var savedStyle = element._ojSavedStyle;
      if (savedStyle) {
        var props = Object.keys(savedStyle);
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          AnimationUtils._setElementStyle(element, prop, savedStyle[prop]);
        }

        delete element._ojSavedStyle;
        delete element._ojEffectCount;
      }
    }
  };

  // Get the corresponding camel-cased property name
  AnimationUtils._getCamelCasePropName = function (propName) {
    if (propName.indexOf('-') >= 0) {
      var newName = '';

      var strArray = propName.split('-');
      for (var i = 0; i < strArray.length; i++) {
        var subStr = strArray[i];

        if (subStr) {
          if (newName) {
            newName += subStr.charAt(0).toUpperCase() + subStr.slice(1);
          } else {
            // Keep the first segment in lower case
            newName = subStr;
          }
        }
      }

      return newName;
    }

    return propName;
  };

  // Get the corresponding hyphenated property name
  AnimationUtils._getHyphenatedPropName = function (propName) {
    var newName = propName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    if (newName.indexOf('webkit') === 0) {
      newName = '-' + newName;
    }
    return newName;
  };

  // Concatenate value for style property that allows multiple values
  AnimationUtils._concatMultiValue = function (element, state, propName, defaultPrefix, separator) {
    if (state.css[propName]) {
      var currPropValue = AnimationUtils._getElementStyle(element, propName);
      if (currPropValue && currPropValue.indexOf(defaultPrefix) !== 0) {
        // eslint-disable-next-line no-param-reassign
        state.css[propName] = currPropValue + separator + state.css[propName];
      }
    }
  };

  AnimationUtils._splitTransform = function (transform) {
    var array = [];

    if (transform && transform !== 'none') {
      var _transform = transform;
      var index = _transform.indexOf(')');
      while (index > 0) {
        var funcExpr = _transform.substr(0, index + 1);
        array.push(funcExpr.trim());
        _transform = _transform.slice(index + 1);
        index = _transform.indexOf(')');
      }
    }

    return array;
  };

  AnimationUtils._getTransformFuncName = function (funcExpr) {
    var index = funcExpr.indexOf('(');
    if (index >= 1) {
      return funcExpr.substr(0, index);
    }

    return funcExpr;
  };

  // Apply the transform style
  AnimationUtils._applyTransform = function (element, newTransform) {
    var oldTransform = AnimationUtils._getElementStyle(element, 'transform');
    var oldTransformArray = AnimationUtils._splitTransform(oldTransform);
    var newTransformArray = AnimationUtils._splitTransform(newTransform);
    var extraTransformArray = [];

    for (var i = 0; i < newTransformArray.length; i++) {
      var funcName = AnimationUtils._getTransformFuncName(newTransformArray[i]);
      var match = false;

      if (funcName) {
        for (var j = 0; j < oldTransformArray.length; j++) {
          // Search for funcName + '(' since some transform functions can be the
          // prefix of other functions such as translate and translateZ.
          if (oldTransformArray[j].indexOf(funcName + '(') === 0) {
            // Replace any matching old transform function with the new one
            oldTransformArray[j] = newTransformArray[i];
            match = true;
          }
        }
      }

      // Keep track of any new transform function that wasn't specified
      if (!match) {
        extraTransformArray.push(newTransformArray[i]);
      }
    }

    // Concatenate the updated transform list with newly added list
    oldTransformArray = oldTransformArray.concat(extraTransformArray);

    // Return the transform list as a string
    return oldTransformArray.join(' ');
  };

  AnimationUtils._applyState = function (element, state, isComposite) {
    if (state) {
      if (state.css) {
        var transitionPropName = 'transition';
        var transformPropName = 'transform';

        // For composite animation, we need to concatenate certain property values
        // instead of replacing them
        if (isComposite) {
          AnimationUtils._concatMultiValue(element, state, transitionPropName, 'all', ', ');
        }

        if (state.css[transformPropName]) {
          // eslint-disable-next-line no-param-reassign
          state.css[transformPropName] = AnimationUtils._applyTransform(
            element,
            state.css[transformPropName]
          );
        }

        var newStyle = state.css;
        var props = Object.keys(newStyle);
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          AnimationUtils._setElementStyle(element, prop, newStyle[prop]);
        }
      }

      if (state.addClass) {
        $(element).addClass(state.addClass);
      }

      if (state.removeClass) {
        $(element).removeClass(state.removeClass);
      }
    }
  };

  // Get a timing value in millisecond from a string such as duration and delay
  AnimationUtils._getTimingValue = function (timingStr) {
    var timingValue = parseFloat(timingStr);
    if (isNaN(timingValue)) {
      return 0;
    }

    return timingStr.indexOf('ms') > -1 ? timingValue : timingValue * 1000;
  };

  AnimationUtils._getTotalTiming = function (duration, delay) {
    var durationMs = AnimationUtils._getTimingValue(duration);
    if (durationMs > 0) {
      var delayMs = delay ? AnimationUtils._getTimingValue(delay) : 0;
      return durationMs + delayMs;
    }

    return 0;
  };

  AnimationUtils._calcCssTime = function (propertyStr, delayStr, durationStr) {
    var propertyArray = propertyStr.split(',');
    var delayArray = delayStr.split(',');
    var durationArray = durationStr.split(',');
    var propertyLen = propertyArray.length;
    var delayLen = delayArray.length;
    var durationLen = durationArray.length;
    var maxTime = 0;

    for (var i = 0; i < propertyLen; i++) {
      var duration = durationArray[i % durationLen];
      var delay = delayArray[i % delayLen];
      var totalMs = AnimationUtils._getTotalTiming(duration, delay);

      maxTime = Math.max(maxTime, totalMs);
    }

    return maxTime;
  };

  AnimationUtils._calcEffectTime = function (element) {
    var style = window.getComputedStyle(element);
    var propertyStr;
    var delayStr;
    var durationStr;

    propertyStr = style.animationName || style.webkitAnimationName;
    delayStr = style.animationDelay || style.webkitAnimationDelay;
    durationStr = style.animationDuration || style.webkitAnimationDuration;
    var animationTime = AnimationUtils._calcCssTime(propertyStr, delayStr, durationStr);

    propertyStr = style.transitionProperty || style.webkitTransitionProperty;
    delayStr = style.transitionDelay || style.webkitTransitionDelay;
    durationStr = style.transitionDuration || style.webkitTransitionDuration;
    var transitionTime = AnimationUtils._calcCssTime(propertyStr, delayStr, durationStr);

    return Math.max(animationTime, transitionTime);
  };

  // Fill in empty timing options from a set of source options
  AnimationUtils._fillEmptyOptions = function (targetOptions, sourceOptions) {
    // eslint-disable-next-line no-param-reassign
    targetOptions.delay = targetOptions.delay || sourceOptions.delay;
    // eslint-disable-next-line no-param-reassign
    targetOptions.duration = targetOptions.duration || sourceOptions.duration;
    // eslint-disable-next-line no-param-reassign
    targetOptions.timingFunction = targetOptions.timingFunction || sourceOptions.timingFunction;
    // eslint-disable-next-line no-param-reassign
    targetOptions.persist = targetOptions.persist || sourceOptions.persist;
  };

  // Trigger oj custom event
  AnimationUtils._triggerEvent = function (element, eventName, ui, component) {
    var defaultPrevented;

    if (component && component._trigger) {
      // _trigger() returns false if preventDefault has been called
      defaultPrevented = !component._trigger(eventName, null, ui);
    } else {
      var ojEventType = 'oj' + eventName.substr(0, 1).toUpperCase() + eventName.substr(1);
      var customEvent = new CustomEvent(ojEventType, { detail: ui, bubbles: true, cancelable: true });
      var eventTarget = component || element;
      if (eventTarget.dispatchEvent) {
        eventTarget.dispatchEvent(customEvent);
      }
      defaultPrevented = customEvent.defaultPrevented;
    }

    return defaultPrevented;
  };

  /**
   * Internal method for starting an animation.
   * @param {Element} element  the HTML element to animate
   * @param {string} action  a component-defined string that identifies the action starting
   *                         the animation, such as "open", "close", "add", "remove", etc.
   * @param {string|Object|Array} effects  The name of one of the effect methods
   *                        in AnimationUtils, or an object that specifies the
   *                        effect method and its options, such as:
   *                        {'effect': 'fadeOut', 'endOpacity': 0.5}, or an array of the above.
   * @param {Object=} component  the component that owns the HTML element
   *                             to animate.  If this is specified and it has a
   *                             _trigger method (jQuery UI widget), animation events will
   *                             be triggered on the component via jQuery UI _trigger(),
   *                             so that listeners specified as event options will work.
   *                             If this is specified but it doesn't have a _trigger
   *                             method (HTML element), animation events will be triggered
   *                             on the component via dispatchEvent.
   *                             If this is not specified, animation events will be triggered
   *                             on the animated HTML element via dispatchEvent.
   * @return {Promise} a promise that will be resolved when the animation ends
   * @export
   * @ignore
   */
  AnimationUtils.startAnimation = function (element, action, effects, component) {
    // Temporary fix for callers that are passing in jQuery object
    // eslint-disable-next-line no-param-reassign
    element = $(element)[0];

    return new Promise(
      // eslint-disable-next-line no-unused-vars
      function (resolve, reject) {
        var jelem = $(element);
        var fromMarker = 'oj-animate-' + action;
        var toMarker = fromMarker + '-active';
        var eventProcessed = false;
        var markerProcessed = false;
        var resolvePromise = function () {
          if (eventProcessed && markerProcessed) {
            jelem.removeClass(fromMarker);
            jelem.removeClass(toMarker);
            AnimationUtils._restoreStyle(element);
            resolve(true);

            var ui = { action: action, element: element };
            AnimationUtils._triggerEvent(element, 'animateEnd', ui, component);
          }
        };
        var eventCallback = function () {
          eventProcessed = true;
          resolvePromise();
        };
        var markerCallback = function () {
          markerProcessed = true;
          resolvePromise();
        };

        // This will add a ref count so that the style is not restored until
        // all effects and user-defined css transitions have ended.  Otherwise
        // there may be screen flash if 'persist' !== 'all'.
        AnimationUtils._saveStyle(element, null, null, null, null);

        // Trigger ojanimatestart event so that app can prevent default animation
        // and define custom effect in JS
        var ui = { action: action, element: element, endCallback: eventCallback };
        var defaultPrevented = AnimationUtils._triggerEvent(element, 'animateStart', ui, component);

        // Continue animation handling if app didn't preventDefault
        if (!defaultPrevented) {
          var effectArray = [].concat(effects);
          var promiseArray = [];
          var lastOptions = {};

          for (var i = 0; i < effectArray.length; i++) {
            var animationEffect = effectArray[i];
            var effectName = '';
            var effectOptions;

            // Start any explicit animation effect
            if (animationEffect != null && animationEffect !== 'none') {
              if (typeof animationEffect === 'string') {
                effectName = animationEffect;
                effectOptions = {};
              } else if (typeof animationEffect === 'object') {
                effectName = animationEffect.effect;
                effectOptions = $.extend({}, animationEffect);
              }

              // Fill in empty timing options with what was specified last
              AnimationUtils._fillEmptyOptions(effectOptions, lastOptions);

              // Remember the last set of options
              lastOptions = $.extend({}, effectOptions);
            }

            if (effectName && AnimationUtils[effectName]) {
              promiseArray.push(AnimationUtils[effectName](element, effectOptions));
            }
          }

          if (promiseArray.length) {
            Promise.all(promiseArray).then(eventCallback);
          } else {
            eventCallback();
          }
        }

        // Add marker class so that app can define custom effect in CSS
        jelem.addClass(fromMarker);
        var requestId = window.requestAnimationFrame(function () {
          requestId = 0;

          jelem.addClass(toMarker);

          var totalMs = AnimationUtils._calcEffectTime(element);
          if (totalMs > 0) {
            // Set a timeout to resolve the promise.  We can't rely on
            // transitionend event since there can be multiple transition
            // properties, or the transition is never triggered, or the transition
            // is cancelled.
            setTimeout(markerCallback, totalMs + 100);
          } else {
            markerCallback();
          }
        });

        // In case we are in the background and requestAnimationFrame is not
        // called, have a timeout that cancel the request and resolve promise
        setTimeout(function () {
          if (requestId) {
            window.cancelAnimationFrame(requestId);
            requestId = 0;
            markerCallback();
          }
        }, 1000);
      }
    );
  };

  AnimationUtils._mergeOptions = function (effect, options) {
    if (AnimationUtils._defaultOptions == null) {
      AnimationUtils._defaultOptions = ThemeUtils.parseJSONFromFontFamily(
        'oj-animation-effect-default-options'
      );
    }

    // At the minimum, we should have a duration.  Merge any theming defaults
    // and then any user options to it.
    return $.extend(
      { duration: '400ms' },
      AnimationUtils._defaultOptions ? AnimationUtils._defaultOptions[effect] : null,
      options
    );
  };

  AnimationUtils._createTransitionValue = function (element, transProps, options) {
    var transValue = '';

    if (transProps) {
      for (var i = 0; i < transProps.length; i++) {
        var propName = AnimationUtils._getName(element, transProps[i]);
        var hyphenatedName = AnimationUtils._getHyphenatedPropName(propName);

        transValue += (i > 0 ? ', ' : '') + hyphenatedName + ' ' + options.duration;

        if (options.timingFunction) {
          transValue += ' ' + options.timingFunction;
        }

        if (options.delay) {
          transValue += ' ' + options.delay;
        }
      }
    }

    return transValue;
  };

  AnimationUtils._fade = function (element, _options, effect, startOpacity, endOpacity) {
    var options = AnimationUtils._mergeOptions(effect, _options);

    var fromState = { css: { opacity: startOpacity } };
    var toState = { css: { opacity: endOpacity } };

    if (options) {
      if (options.startOpacity) {
        fromState.css.opacity = options.startOpacity;
      }

      if (options.endOpacity) {
        toState.css.opacity = options.endOpacity;
      }
    }

    return AnimationUtils._animate(element, fromState, toState, options, ['opacity']);
  };

  /**
   * Animaton effect method for fading in a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {number=} options.startOpacity starting opacity. Default is 0.
   * @param {number=} options.endOpacity  ending opacity. Default is 1.
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.fadeIn = function (element, options) {
    return AnimationUtils._fade(element, options, 'fadeIn', 0, 1);
  };

  /**
   * Animaton effect method for fading out a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {number=} options.startOpacity starting opacity. Default is 1.
   * @param {number=} options.endOpacity  ending opacity. Default is 0.
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.fadeOut = function (element, options) {
    return AnimationUtils._fade(element, options, 'fadeOut', 1, 0);
  };

  /**
   * Animaton effect method for expanding a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.direction direction to expand. Valid values are "height", "width", or "both". Default is "height".
   * @param {string=} options.startMaxHeight starting max-height value to expand from.  Default is "0".
   * @param {string=} options.endMaxHeight ending max-height value to expand to.  Default is natural element height.
   * @param {string=} options.startMaxWidth starting max-width value to expand from.  Default is "0".
   * @param {string=} options.endMaxWidth starting max-width value to expand to.  Default is natural element width.
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.expand = function (element, options) {
    return AnimationUtils._expandCollapse(element, options, true);
  };

  /**
   * Animaton effect method for collapsing a HTML element.
   * <p>When using this method to hide an element, the element should not have any border
   * or padding, because border and padding are visible even if the element's height
   * is set to 0. The use of "box-sizing: border-box" style doesn't change this behavior.
   * If the element needs border and padding, create a wrapper element around it and
   * call this method on the wrapper element instead.</p>
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.direction direction to collapse. Valid values are "height", "width", or "both". Default is "height".
   * @param {string=} options.startMaxHeight starting max-height value to collapse from.  Default is natural element height.
   * @param {string=} options.endMaxHeight ending max-height value to collapse to.  Default is "0".
   * @param {string=} options.startMaxWidth starting max-width value to collapse from.  Default is natural element width.
   * @param {string=} options.endMaxWidth starting max-width value to collapse to.  Default is "0".
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.collapse = function (element, options) {
    return AnimationUtils._expandCollapse(element, options, false);
  };

  // Wrap table row content and return an array of wrapper elements to animate
  AnimationUtils._wrapRowContent = function (row, rowHeight) {
    var wrappers = [];
    var cell;
    var cells = row.children;
    var cellsPadding = [];
    var cellsTextAlign = [];
    var i;

    // Collect all the needed style before modifying the DOM.  Otherwise it
    // causes additional reflow and takes more time.

    // eslint-disable-next-line no-param-reassign
    row._ojSavedHeight = row.style.height;

    for (i = 0; i < cells.length; i++) {
      cell = cells[i];
      var cellStyle = window.getComputedStyle(cell);
      cellsPadding.push(cellStyle.padding);
      cellsTextAlign.push(cellStyle.textAlign);

      // Remember the inline padding style (not computed style)
      cell._ojSavedPadding = cell.style.padding;
    }

    // Start modifying the DOM

    for (i = 0; i < cells.length; i++) {
      cell = cells[i];

      // Create the outer wrapper
      var outerWrapper = document.createElement('div');
      outerWrapper.style.overflow = 'hidden;';

      // Create the inner wrapper
      var innerWrapper = document.createElement('div');
      innerWrapper.style.display = 'table-cell';
      innerWrapper.style.verticalAlign = 'middle';
      innerWrapper.style.boxSizing = 'border-box';
      innerWrapper.style.height = rowHeight;
      innerWrapper.style.padding = cellsPadding[i];
      innerWrapper.style.textAlign = cellsTextAlign[i];

      // Append inner wrapper to outer wrapper
      outerWrapper.appendChild(innerWrapper); // @HTMLUpdateOK innerWrapper is constructed by component code and is not using string passed in through any APIs.

      // Transfer children of cell to inner wrapper
      while (cell.firstChild) {
        innerWrapper.appendChild(cell.firstChild); // @HTMLUpdateOK cell.firstChild is constructed by component code and is not using string passed in through any APIs.
      }

      // Finally append the outer wrapper back to the cell
      cell.appendChild(outerWrapper); // @HTMLUpdateOK outerWrapper is constructed by component code and is not using string passed in through any APIs.

      // Set the cell padding to 0 so that it can be completely collapsed
      cell.style.padding = '0';

      wrappers.push(outerWrapper);
    }

    // Set the row height to 0 so that it can be completely collapsed
    // eslint-disable-next-line no-param-reassign
    row.style.height = '0';

    return wrappers;
  };

  // Unwrap table row content
  AnimationUtils._unwrapRowContent = function (row) {
    var cells = row.children;

    for (var i = 0; i < cells.length; i++) {
      var cell = cells[i];

      var outerWrapper = cell.children[0];
      if (outerWrapper) {
        var innerWrapper = outerWrapper.children[0];
        if (innerWrapper) {
          while (innerWrapper.firstChild) {
            cell.appendChild(innerWrapper.firstChild); // @HTMLUpdateOK innerWrapper.firstChild is constructed by component code and is not using string passed in through any APIs.
          }
        }

        // Remove the outer wrapper will also remove the inner wrapper
        cell.removeChild(outerWrapper);
      }

      // Restore any inline padding style to the cell
      cell.style.padding = cell._ojSavedPadding;
      delete cell._ojSavedPadding;
    }

    // Restore any inline height style to the row
    // eslint-disable-next-line no-param-reassign
    row.style.height = row._ojSavedHeight;
    // eslint-disable-next-line no-param-reassign
    delete row._ojSavedHeight;
  };

  // Expand or collapse a table row
  AnimationUtils._expandCollapseRow = function (element, options, isExpand) {
    var promise = Promise.resolve();
    var rowHeight = element.offsetHeight + 'px';
    var wrappers = AnimationUtils._wrapRowContent(element, rowHeight);
    var wrapperOptions = $.extend({}, options);

    // Set the known max height into the options so that each cell doesn't
    // have to recalculate it
    if (isExpand) {
      if (!wrapperOptions.endMaxHeight) {
        wrapperOptions.endMaxHeight = rowHeight;
      }
    } else if (!wrapperOptions.startMaxHeight) {
      wrapperOptions.startMaxHeight = rowHeight;
    }

    // Set persist option so that we don't need to restore the style after
    // animation.  The wrapper will be removed anyway.
    wrapperOptions.persist = 'all';

    // Set internal _noReflow option so that we don't force reflow on Firefox.
    // New elements will naturally cause reflow.
    wrapperOptions._noReflow = true;

    if (wrappers.length) {
      // Animate all the cells
      for (var i = 0; i < wrappers.length; i++) {
        // We only need one promise/row.  Skip promise for all cells except first.
        if (i === 0) {
          wrapperOptions._skipPromise = false;
          promise = AnimationUtils._expandCollapse(wrappers[i], wrapperOptions, isExpand);
        } else {
          wrapperOptions._skipPromise = true;
          AnimationUtils._expandCollapse(wrappers[i], wrapperOptions, isExpand);
        }
      }
    }

    return promise.then(function () {
      if (options == null || options.persist !== 'all') {
        AnimationUtils._unwrapRowContent(element);
      }
    });
  };

  // Determine the min/max width/height used for animation
  AnimationUtils._getSizeLimit = function (element, style, optionValue, isLower, isWidth) {
    var limitValue = optionValue;

    if (!limitValue) {
      if (isLower) {
        limitValue = '0';
      } else {
        var cssValue = isWidth ? style.maxWidth : style.maxHeight;
        if (cssValue !== 'none') {
          limitValue = cssValue;
        } else {
          limitValue = (isWidth ? element.offsetWidth : element.offsetHeight) + 'px';
        }
      }
    }

    return limitValue;
  };

  AnimationUtils._expandCollapse = function (element, _options, isExpand) {
    // Handle the case where the element is a <tr> element.  We need to wrap the
    // content of every child <td> and animate the wrappers because the min height
    // of <tr> and <td> are limited by their contents.
    if (element && element.tagName === 'TR') {
      return AnimationUtils._expandCollapseRow(element, _options, isExpand);
    }

    var options = AnimationUtils._mergeOptions(isExpand ? 'expand' : 'collapse', _options);

    var fromState = { css: {} };
    var toState = { css: {} };

    var direction = options.direction || 'height';

    var fromCSS = fromState.css;
    var toStateCSS = toState.css;

    var style = window.getComputedStyle(element);
    var transProps = [];
    if (direction === 'both' || direction === 'height') {
      var startMaxHeight = AnimationUtils._getSizeLimit(
        element,
        style,
        options.startMaxHeight,
        isExpand,
        false
      );
      var endMaxHeight = AnimationUtils._getSizeLimit(
        element,
        style,
        options.endMaxHeight,
        !isExpand,
        false
      );

      fromCSS.maxHeight = startMaxHeight;
      toStateCSS.maxHeight = endMaxHeight;
      transProps.push('maxHeight');
    }

    if (direction === 'both' || direction === 'width') {
      var startMaxWidth = AnimationUtils._getSizeLimit(
        element,
        style,
        options.startMaxWidth,
        isExpand,
        true
      );
      var endMaxWidth = AnimationUtils._getSizeLimit(
        element,
        style,
        options.endMaxWidth,
        !isExpand,
        true
      );

      fromCSS.maxWidth = startMaxWidth;
      toStateCSS.maxWidth = endMaxWidth;
      transProps.push('maxWidth');
    }

    // expand and collapse needs overflow hidden to hide the content
    fromCSS.overflow = options.overflow ? options.overflow : 'hidden';

    var persistProps = [].concat(transProps);
    persistProps.push('overflow');

    return AnimationUtils._animate(element, fromState, toState, options, transProps, persistProps);
  };

  /**
   * Animaton effect method for zooming in a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.axis the axis along which to scale the element. Valid values are "x", "y", or "both". Default is "both".
   * @param {string=} options.transformOrigin set the CSS transform-origin property, which controls the anchor point for the zoom. Default is "center".
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.zoomIn = function (element, options) {
    return AnimationUtils._zoom(element, options, true);
  };

  /**
   * Animaton effect method for zooming out a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.axis the axis along which to scale the element. Valid values are "x", "y", or "both". Default is "both".
   * @param {string=} options.transformOrigin set the CSS transform-origin property, which controls the anchor point for the zoom. Default is "center".
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.zoomOut = function (element, options) {
    return AnimationUtils._zoom(element, options, false);
  };

  AnimationUtils._zoom = function (element, _options, isIn) {
    var options = AnimationUtils._mergeOptions(isIn ? 'zoomIn' : 'zoomOut', _options);

    var fromState = { css: {} };
    var toState = { css: {} };

    var axis = options.axis || 'both';

    var scale;
    if (axis === 'both') {
      scale = 'scale';
    } else if (axis === 'x') {
      scale = 'scaleX';
    } else {
      scale = 'scaleY';
    }
    var fromCSS = fromState.css;
    var toStateCSS = toState.css;
    var transformPropName = 'transform';
    var transformOriginPropName = 'transformOrigin';

    fromCSS[transformPropName] = scale + '(' + (isIn ? 0 : 1) + _TRANSLATE2;
    toStateCSS[transformPropName] = scale + '(' + (isIn ? 1 : 0) + _TRANSLATE2;

    fromCSS[transformOriginPropName] = options.transformOrigin || 'center';

    return AnimationUtils._animate(element, fromState, toState, options, [transformPropName]);
  };

  /**
   * Animaton effect method for sliding in a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.direction Direction of the slide. Valid values are "left", "top", "right", "bottom", "start", and "end". Default is "start".
   *                                    This option is ignored if either offsetX or offsetY is specified.
   * @param {string=} options.offsetX The offset on the x-axis to translate from. This value must be a number followed by a unit such as "px", "em", etc.
   *                                  If moving in a horizontal direction, default to element width. Otherwise, default to "0px".
   * @param {string=} options.offsetY The offset on the y-axis to translate from. This value must be a number followed by a unit such as "px", "em", etc.
   *                                  If moving in a vertical direction, default to element height. Otherwise, default to "0px".
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.slideIn = function (element, options) {
    return AnimationUtils._slide(element, options, true);
  };

  /**
   * Animaton effect method for sliding out a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.direction Direction of the slide. Valid values are "left", "top", "right", "bottom", "start", and "end". Default is "start".
   *                                    This option is ignored if either offsetX or offsetY is specified.
   * @param {string=} options.offsetX The offset on the x-axis to translate to. This value must be a number followed by a unit such as "px", "em", etc.
   *                                  If moving in a horizontal direction, default to element width. Otherwise, default to "0px".
   * @param {string=} options.offsetY The offset on the y-axis to translate to. This value must be a number followed by a unit such as "px", "em", etc.
   *                                  If moving in a vertical direction, default to element height. Otherwise, default to "0px".
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.slideOut = function (element, options) {
    return AnimationUtils._slide(element, options, false);
  };

  AnimationUtils._slide = function (element, _options, isIn) {
    var options = AnimationUtils._mergeOptions(isIn ? 'slideIn' : 'slideOut', _options);

    var fromState = { css: {} };
    var toState = { css: {} };

    var direction = options.direction || 'start';

    var offsetX = '0';
    var offsetY = '0';
    var fromCSS = fromState.css;
    var toStateCSS = toState.css;

    if (options.offsetX || options.offsetY) {
      if (options.offsetX) {
        offsetX = options.offsetX;
      }

      if (options.offsetY) {
        offsetY = options.offsetY;
      }
    } else {
      var isRTL = DomUtils.getReadingDirection() === 'rtl';

      switch (direction) {
        case 'left':
          offsetX = (isIn ? element.offsetWidth : -element.offsetWidth) + 'px';
          break;
        case 'right':
          offsetX = (isIn ? -element.offsetWidth : element.offsetWidth) + 'px';
          break;
        case 'top':
          offsetY = (isIn ? element.offsetHeight : -element.offsetHeight) + 'px';
          break;
        case 'bottom':
          offsetY = (isIn ? -element.offsetHeight : element.offsetHeight) + 'px';
          break;
        case 'end':
          offsetX = (isIn ? -element.offsetWidth : element.offsetWidth) * (isRTL ? -1 : 1) + 'px';
          break;
        default: // 'start'
          offsetX = (isIn ? element.offsetWidth : -element.offsetWidth) * (isRTL ? -1 : 1) + 'px';
          break;
      }
    }

    var transformPropName = 'transform';
    if (isIn) {
      fromCSS[transformPropName] = _TRANSLATE + offsetX + ',' + offsetY + _TRANSLATE2;
      toStateCSS[transformPropName] = 'translate(0,0) translateZ(0)';
    } else {
      fromCSS[transformPropName] = 'translate(0,0) translateZ(0)';
      toStateCSS[transformPropName] = _TRANSLATE + offsetX + ',' + offsetY + _TRANSLATE2;
    }

    return AnimationUtils._animate(element, fromState, toState, options, [transformPropName]);
  };

  /**
   * Animaton effect method for rippling a HTML element.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.offsetX Horizontal offset of the ripple center, with a unit of either "px" or "%".
   *                                  If the unit is "px", it specifies the offset in pixels.
   *                                  If the unit is "%", it specifies the offset as a percentage of the element's width.
   * @param {string=} options.offsetY Vertical offset of the ripple center, with a unit of either "px" or "%".
   *                                  If the unit is "px", it specifies the offset in pixels.
   *                                  If the unit is "%", it specifies the offset as a percentage of the element's height.
   * @param {string=} options.color Color of the ripple. Default is specified in the "oj-animation-effect-ripple" CSS class.
   * @param {string=} options.diameter Diameter of the ripple, with a unit of either "px" or "%".
   *                                   If the unit is "px", it specifies the diameter in pixels.
   *                                   If the unit is "%", it specifies the diameter as a percentage of either the element's width or height, whichever is less.
   *                                   Default is specified in the "oj-animation-effect-ripple" CSS class.
   * @param {number=} options.startOpacity start opacity of the ripple. Default is specified in the "oj-animation-effect-ripple" CSS class.
   * @param {number=} options.endOpacity end opacity of the ripple. Default is 0.
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.ripple = function (element, options) {
    var _options = AnimationUtils._mergeOptions('ripple', options);

    var fromState = { css: {} };
    var toState = { css: {} };

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    // The rippler need its own container since setting overflow on the target
    // element may not work if the element has no explicit height, which can be
    // the case on buton, listitem, etc.
    var container = $('<div>').css({ position: 'absolute', overflow: 'hidden' });
    var rippler = $("<div class='oj-animation-effect-ripple oj-animation-rippler'>");

    // prepend the rippler instead of append so that it doesn't obscure other children
    var style = window.getComputedStyle(element);
    var position =
      style.position === 'static'
        ? { left: element.offsetLeft, top: element.offsetTop }
        : { left: 0, top: 0 };
    element.insertBefore(container[0], element.firstChild); // @HTMLUpdateOK container is constructed by component code and is not using string passed in through any APIs.
    container.css({
      left: position.left + 'px',
      top: position.top + 'px',
      width: width + 'px',
      height: height + 'px'
    });

    container.prepend(rippler); // @HTMLUpdateOK rippler is constructed by component code and is not using string passed in through any APIs.

    var fromCSS = fromState.css;
    var toStateCSS = toState.css;
    var transformPropName = 'transform';

    AnimationUtils._setRippleOptions(fromCSS, rippler, container, _options);

    fromCSS[transformPropName] = 'scale(0) translateZ(0)';
    fromCSS.opacity = _options.startOpacity || rippler.css('opacity');

    toStateCSS[transformPropName] = 'scale(1) translateZ(0)';
    toStateCSS.opacity = _options.endOpacity || 0;

    // Always persist the ripple state so that it remains invisible until removed.
    // Otherwise it may re-appear briefly on mobile Safari.
    _options.persist = 'all';

    return AnimationUtils._animate(rippler[0], fromState, toState, _options, [
      transformPropName,
      'opacity'
    ]).then(function () {
      container.remove();
    });
  };

  AnimationUtils._setRippleOptions = function (_css, rippler, parent, options) {
    var css = _css;
    var diameter = rippler.width();
    var parentWidth = parent.width();
    var parentHeight = parent.height();

    if (options.diameter) {
      var diameterStr = options.diameter;
      var value = parseInt(diameterStr, 10);
      if (!isNaN(value)) {
        if (diameterStr.charAt(diameterStr.length - 1) === '%') {
          diameter = Math.floor(Math.min(parentWidth, parentHeight) * (value / 100));
        } else {
          diameter = value;
        }

        css.width = diameter + 'px';
        css.height = diameter + 'px';
      }
    }

    var position = parent.css('position') === 'static' ? parent.position() : { left: 0, top: 0 };
    var offset;

    offset = AnimationUtils._calcRippleOffset(options.offsetX, diameter, parentWidth, position.left);
    if (offset != null) {
      css.left = offset + 'px';
    }

    offset = AnimationUtils._calcRippleOffset(options.offsetY, diameter, parentHeight, position.top);
    if (offset != null) {
      css.top = offset + 'px';
    }

    if (options.color) {
      css.backgroundColor = options.color;
    }
  };

  AnimationUtils._calcRippleOffset = function (_offsetOption, diameter, parentSize, parentOffset) {
    var offset;

    var offsetOption = _offsetOption || '50%';

    var offsetInt = parseInt(offsetOption, 10);
    if (!isNaN(offsetInt)) {
      if (offsetOption.charAt(offsetOption.length - 1) === '%') {
        offset = parentSize * (offsetInt / 100) - diameter / 2;
      } else {
        offset = offsetInt - diameter / 2;
      }

      // offset should be relative to the rippler's offsetParent, which is not
      // the parent element if the parent element has static position.
      offset = Math.floor(offset + parentOffset);
    }

    return offset;
  };

  AnimationUtils._removeRipple = function (element, _options) {
    var options = _options || {};

    var possibleEffects = { fadeOut: 1, collapse: 1, zoomOut: 1, slideOut: 1 };
    var removeEffect = options.removeEffect || 'fadeOut';
    var rippler = $('.oj-animation-rippler', element);

    if (rippler.length === 0) {
      Logger.warn('No rippler so returning');
      return undefined;
    }

    if (!(removeEffect in possibleEffects)) {
      return rippler.remove();
    }

    return AnimationUtils[removeEffect](rippler, options).then(function () {
      rippler.remove();
    });
  };

  AnimationUtils._calcBackfaceAngle = function (angle) {
    var backfaceAngle;
    var expr = /^([+-]?\d*\.?\d*)(.*)$/;
    var matchArray = angle.match(expr);
    var amount = parseFloat(matchArray[1]);
    var unit = matchArray[2];

    switch (unit) {
      case 'deg':
        backfaceAngle = amount - 180 + unit;
        break;
      case 'grad':
        backfaceAngle = amount - 200 + unit;
        break;
      case 'rad':
        backfaceAngle = amount - 3.1416 + unit;
        break;
      case 'turn':
        backfaceAngle = amount - 0.5 + unit;
        break;
      default:
        Logger.error('Unknown angle unit in flip animation: ' + unit);
        break;
    }

    return backfaceAngle;
  };

  AnimationUtils._flip = function (element, options, effect, startAngle, endAngle) {
    // Handle the case where the element has children to represent front and back
    // faces.  We need to flip the children instead of the parent since IE doesn't
    // support preserve-3d style, which works on other browsers.
    if (options && options.flipTarget === 'children') {
      var promises = [];
      var children = $(element).children();
      var childOptions;

      var frontOptions = $.extend({}, options);
      delete frontOptions.flipTarget;

      var backOptions = $.extend({}, frontOptions);
      backOptions.startAngle = AnimationUtils._calcBackfaceAngle(options.startAngle || startAngle);
      backOptions.endAngle = AnimationUtils._calcBackfaceAngle(options.endAngle || endAngle);

      for (var i = 0; i < children.length; i++) {
        childOptions = $(children[i]).hasClass('oj-animation-backface') ? backOptions : frontOptions;
        promises.push(AnimationUtils._flip(children[i], childOptions, effect, startAngle, endAngle));
      }

      return Promise.all(promises);
    }

    // eslint-disable-next-line no-param-reassign
    options = AnimationUtils._mergeOptions(effect, options);

    var fromCss = {};
    var toCss = {};
    var fromState = { css: fromCss };
    var toState = { css: toCss };
    var rotateFunc = 'rotateY(';
    var perspective = '2000px';
    var backfaceVisibility = 'hidden';
    var transformOrigin = 'center';
    var transform;

    if (options) {
      if (options.axis === 'x') {
        rotateFunc = 'rotateX(';
      }

      if (options.startAngle) {
        // eslint-disable-next-line no-param-reassign
        startAngle = options.startAngle;
      }

      if (options.endAngle) {
        // eslint-disable-next-line no-param-reassign
        endAngle = options.endAngle;
      }

      if (options.perspective) {
        perspective = options.perspective;
      }

      if (options.backfaceVisibility) {
        backfaceVisibility = options.backfaceVisibility;
      }

      if (options.transformOrigin) {
        transformOrigin = options.transformOrigin;
      }
    }

    // perspective() must precede rotate() in the transform value in order for it to work
    transform = 'perspective(' + perspective + ') ' + rotateFunc;

    // Safari still requires webkit prefix for backfaceVisibility property
    var backfaceVisPropName = 'backfaceVisibility';
    var transformPropName = 'transform';
    var transformOriginPropName = 'transformOrigin';

    fromCss[transformPropName] = transform + startAngle + ')';
    fromCss[backfaceVisPropName] = backfaceVisibility;
    fromCss[transformOriginPropName] = transformOrigin;

    toCss[transformPropName] = transform + endAngle + ')';

    // backfaceVisibility and transformOrigin affects the final look of the element,
    // so they should be persisted if the persist option is set.
    return AnimationUtils._animate(
      element,
      fromState,
      toState,
      options,
      [transformPropName],
      [transformPropName, backfaceVisPropName, transformOriginPropName]
    );
  };

  /**
   * Animaton effect method for rotating a HTML element into view.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.axis  The axis of the rotation. Valid values are "x" and "y". Default is "y".
   * @param {string=} options.startAngle  The starting angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "-180deg", which shows the back face of the element.
   * @param {string=} options.endAngle  The ending angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "0deg", which shows the front face of the element.
   * @param {string=} options.backfaceVisibility  The visibility of the back face when facing the user. Valid values are "visible" and "hidden". If set to "visible", the back face shows a
   *                                              mirrored image of the front face. If set to "hidden", the back face is invisible.  Default is "hidden".
   * @param {string=} options.perspective  The 3D perspective for the element. Default is "2000px". A smaller value makes the 3D effect more pronounced during rotation.
   * @param {string=} options.transformOrigin  The axis location for the rotation. Refer to CSS transform-origin for valid values. Default is "center".
   * @param {string=} options.flipTarget  The target for flipping.  Valid values are "element" and "children".  Default is "element".
   *                                      <p>Set to "element" to flip the element itself.</p>
   *                                      <p>Set to "children" to flip the children of the element.  This is used when the element is a card-like structure that
   *                                         has children to represent the front and back faces of a card.  The child that represents the back face must have
   *                                         the "oj-animation-backface" marker class.  Use this option instead of the "transform-style: preserve-3d" CSS style because
   *                                         some browsers do not support "transform-style".  See the cookbook for a Card Flip example of using this option.</p>
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.flipIn = function (element, options) {
    return AnimationUtils._flip(element, options, 'flipIn', '-180deg', '0deg');
  };

  /**
   * Animaton effect method for rotating a HTML element out of view.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object=} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
   *                                    Set to "all" to persist the inline style.  Default is "none".
   * @param {string=} options.axis  The axis of the rotation. Valid values are "x" and "y". Default is "y".
   * @param {string=} options.startAngle  The starting angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "0deg", which shows the front face of the element.
   * @param {string=} options.endAngle  The ending angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "180deg", which shows the back face of the element.
   * @param {string=} options.backfaceVisibility  The visibility of the back face when facing the user. Valid values are "visible" and "hidden". If set to "visible", the back face shows a
   *                                              mirrored image of the front face. If set to "hidden", the back face is invisible.  Default is "hidden".
   * @param {string=} options.perspective  The 3D perspective for the element. Default is "2000px". A smaller value makes the 3D effect more pronounced during rotation.
   * @param {string=} options.transformOrigin  The axis location for the rotation. Refer to CSS transform-origin for valid values. Default is "center".
   * @param {string=} options.flipTarget  The target for flipping.  Valid values are "element" and "children".  Default is "element".
   *                                      <p>Set to "element" to flip the element itself.</p>
   *                                      <p>Set to "children" to flip the children of the element.  This is used when the element is a card-like structure that
   *                                         has children to represent the front and back faces of a card.  The child that represents the back face must have
   *                                         the "oj-animation-backface" marker class.  Use this option instead of the "transform-style: preserve-3d" CSS style because
   *                                         some browsers do not support "transform-style".  See the cookbook for a Card Flip example of using this option.</p>
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.flipOut = function (element, options) {
    return AnimationUtils._flip(element, options, 'flipOut', '0deg', '180deg');
  };

  /**
   * Animaton effect method for adding transition to a HTML element.  Caller should
   * set the new style immediately before calling this method.  This is for internal
   * use only.
   *
   * @param {Element} element  the HTML element to animate
   * @param {Object} options Options applicable to the specific animation effect.
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @param {Array} options.transitionProperties  An array of properties to transition.
   * @return {Promise|IThenable} a promise that will be resolved when the animation ends
   *
   * @export
   * @ignore
   */
  AnimationUtils.addTransition = function (element, options) {
    var _options = AnimationUtils._mergeOptions('addTransition', options);

    return AnimationUtils._animate(element, null, null, _options, _options.transitionProperties);
  };

  AnimationUtils._createHeroParent = function () {
    var viewport = document.createElement('div');
    var body = document.body;

    body.appendChild(viewport); // @HTMLUpdateOK viewPort constructed above
    viewport.style.position = 'absolute';
    viewport.style.height = body.offsetHeight + 'px';
    viewport.style.width = body.offsetWidth + 'px';
    viewport.style.left = body.offsetLeft + 'px';
    viewport.style.top = body.offsetTop + 'px';
    viewport.style.zIndex = 2000;
    viewport.className = 'oj-animation-host-viewport';

    var host = document.createElement('div');
    host.className = 'oj-animation-host';

    viewport.appendChild(host); // @HTMLUpdateOK host is constructed above

    return host;
  };

  AnimationUtils._removeHeroParent = function (heroParent) {
    if (heroParent) {
      var viewport = heroParent.parentNode;
      if (viewport && viewport.parentNode) {
        viewport.parentNode.removeChild(viewport);
      }
    }
  };

  AnimationUtils._defaultHeroCreateClonedElement = function (context) {
    return context.fromElement.cloneNode(true);
  };

  AnimationUtils._defaultHeroHideFromAndToElements = function (context) {
    var fromElement = context.fromElement;
    var toElement = context.toElement;
    fromElement.style.visibility = 'hidden';
    toElement.style.visibility = 'hidden';
  };

  AnimationUtils._defaultHeroAnimateClonedElement = function (context) {
    return new Promise(function (resolve) {
      var heroStyle = context.clonedElement.style;

      heroStyle.transformOrigin = 'left top';
      heroStyle.transform = 'translate(0, 0) scale(1, 1)';

      requestAnimationFrame(function () {
        heroStyle.transitionDelay = context.delay;
        heroStyle.transitionDuration = context.duration;
        heroStyle.transitionTimingFunction = context.timingFunction;
        heroStyle.transitionProperty = 'transform';

        // Put translate before scale because otherwise the scale factor will affect the translate value
        var transform = _TRANSLATE + context.translateX + 'px,' + context.translateY + 'px)';
        transform += ' scale(' + context.scaleX.toFixed(2) + ',' + context.scaleY.toFixed(2) + ')';
        heroStyle.transform = transform;

        var waitTime =
          AnimationUtils._getTimingValue(context.delay) +
          AnimationUtils._getTimingValue(context.duration);

        setTimeout(function () {
          resolve();
        }, waitTime);
      });
    });
  };

  AnimationUtils._defaultHeroShowToElement = function (context) {
    var toElement = context.toElement;
    toElement.style.visibility = 'visible';
  };

  AnimationUtils._doAnimateHero = function (
    fromElement,
    toElementSelector,
    resolvedOptions,
    toElementElapsedTime,
    resolve,
    reject
  ) {
    var toElement = document.querySelector(toElementSelector);

    // Wait for toElement to appear to DOM if it is not there yet
    if (toElement == null) {
      var interval = 100;
      if (toElementElapsedTime + interval > resolvedOptions.toElementWaitTime) {
        reject('toElement not found in DOM after toElementWaitTime has expired');
      } else {
        setTimeout(function () {
          AnimationUtils._doAnimateHero(
            fromElement,
            toElementSelector,
            resolvedOptions,
            toElementElapsedTime + interval,
            resolve,
            reject
          );
        }, interval);
      }
      return;
    }

    var fromRect = fromElement.getBoundingClientRect();
    var toRect = toElement.getBoundingClientRect();
    var translateX = toRect.left - fromRect.left;
    var translateY = toRect.top - fromRect.top;
    var scaleX = toRect.width / fromRect.width;
    var scaleY = toRect.height / fromRect.height;
    var heroContext = {
      fromElement: fromElement,
      toElement: toElement,
      clonedElement: null,
      translateX: translateX,
      translateY: translateY,
      scaleX: scaleX,
      scaleY: scaleY,
      toElementElapsedTime: toElementElapsedTime,
      delay: resolvedOptions.delay,
      duration: resolvedOptions.duration,
      timingFunction: resolvedOptions.timingFunction
    };

    var clonedElement = resolvedOptions.createClonedElement(heroContext);

    heroContext.clonedElement = clonedElement;

    var heroParent = AnimationUtils._createHeroParent();
    var parentRect = heroParent.getBoundingClientRect();
    heroParent.appendChild(clonedElement);
    clonedElement.style.position = 'absolute';
    clonedElement.style.left = fromRect.left - parentRect.left + 'px';
    clonedElement.style.top = fromRect.top - parentRect.top + 'px';

    resolvedOptions.hideFromAndToElements(heroContext);

    // Make sure clonedElement is visible in case createClonedElement return fromElement or toElement
    clonedElement.style.visibility = 'visible';

    function _postAnimation() {
      resolvedOptions.showToElement(heroContext);
      AnimationUtils._removeHeroParent(heroParent);
    }

    resolvedOptions
      .animateClonedElement(heroContext)
      .then(function () {
        _postAnimation();
        resolve();
      })
      .catch(function (reason) {
        _postAnimation();
        reject(reason);
      });
  };

  /**
   * Animation effect method for animating a hero element from one location to another.
   * A hero element is an element that appears to be shared between a source location and a destination location,
   * even though there are separate source element and destination element.
   * <p>
   * The following steps are taken by this method:
   * </p>
   * <ol>
   *   <li>Create a temporary div that has a z-index higher than that of the source and destination elements.
   *   <li>Clone the source element.
   *   <li>Position the cloned element on the temporary div at the same position as the source element.
   *   <li>Hide the source and destination elements.
   *   <li>Animate the cloned element by translating and scaling its position and size towards the destination element.
   *   <li>Show the destination element.
   *   <li>Remove the temporary div together with the cloned element that is on it.
   * </ol>
   * This method provides callback parameters that can be used to override some of the steps.
   *
   * @param {Element} element The source element for the hero animation.
   * @param {Object} options Options applicable to the specific animation effect.
   * @param {string} options.toElementSelector  A CSS selector which specifies the destination element that occupies the location to animate to.
   * @param {number=} options.toElementWaitTime  The time in millisecond to wait for the destination element to become present in the DOM tree.
   * The default is 5000, which is equal to 5 seconds. No animation occurs and the promise returned by this function will be rejected if the
   * destination element is not present when toElementWaitTime expires.
   * @param {(function(AnimationUtils.HeroContext):Element)=} options.createClonedElement An optional application-provided function that returns the element used in animation.
   * <p>By default animateHero will clone the source element specified by the "fromElement" parameter. Application can override this by returning a different element.</p>
   * @param {(function(AnimationUtils.HeroContext):void)=} options.hideFromAndToElements An optional application-provided function that controls the visibility of the source and destination elements during animation.
   * <p>By default animateHero will hide both the source element and destination element while animating the cloned element.</p>
   * @param {(function(AnimationUtils.HeroContext):Promise)=} options.animateClonedElement An optional application-provided function that animates the cloned element.
   * <p>By default animateHero will move and scale the cloned element to the position and size of the destination element.</p>
   * @param {(function(AnimationUtils.HeroContext):void)=} options.showToElement An optional application-provided function that controls the visibility of the destination element after animation.
   * <p>By default animateHero will show the destination element after animation ends.</p>
   * @param {string=} options.delay  The delay from the time the animation is applied to time the
   * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
   * (by specifying ms as the unit). Default is "0s".
   * @param {string=} options.duration The duration that an animation should take to complete. This may be
   * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
   * Default is "400ms".
   * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
   * animation-timing-function. Default is "ease".
   * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
   *
   * @export
   * @memberof AnimationUtils
   */
  AnimationUtils.animateHero = function (element, options) {
    var fromElement = element;
    var resolvedOptions = {
      toElementWaitTime: 5000,
      createClonedElement: AnimationUtils._defaultHeroCreateClonedElement,
      hideFromAndToElements: AnimationUtils._defaultHeroHideFromAndToElements,
      animateClonedElement: AnimationUtils._defaultHeroAnimateClonedElement,
      showToElement: AnimationUtils._defaultHeroShowToElement,
      delay: '0s',
      duration: '400ms',
      timingFunction: 'ease'
    };
    var toElementElapsedTime = 0;

    Object.assign(resolvedOptions, options);

    return new Promise(function (resolve, reject) {
      if (!fromElement) {
        reject('No element specified');
      } else if (!options.toElementSelector) {
        reject('No options.toElementSelector specified');
      } else {
        AnimationUtils._doAnimateHero(
          fromElement,
          options.toElementSelector,
          resolvedOptions,
          toElementElapsedTime,
          resolve,
          reject
        );
      }
    });
  };

  const startAnimation = AnimationUtils.startAnimation;
  const fadeIn = AnimationUtils.fadeIn;
  const fadeOut = AnimationUtils.fadeOut;
  const expand = AnimationUtils.expand;
  const collapse = AnimationUtils.collapse;
  const zoomIn = AnimationUtils.zoomIn;
  const zoomOut = AnimationUtils.zoomOut;
  const slideIn = AnimationUtils.slideIn;
  const slideOut = AnimationUtils.slideOut;
  const ripple = AnimationUtils.ripple;
  const flipIn = AnimationUtils.flipIn;
  const flipOut = AnimationUtils.flipOut;
  const addTransition = AnimationUtils.addTransition;
  const animateHero = AnimationUtils.animateHero;

  exports.addTransition = addTransition;
  exports.animateHero = animateHero;
  exports.collapse = collapse;
  exports.expand = expand;
  exports.fadeIn = fadeIn;
  exports.fadeOut = fadeOut;
  exports.flipIn = flipIn;
  exports.flipOut = flipOut;
  exports.ripple = ripple;
  exports.slideIn = slideIn;
  exports.slideOut = slideOut;
  exports.startAnimation = startAnimation;
  exports.zoomIn = zoomIn;
  exports.zoomOut = zoomOut;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojmoduleanimations',['exports', 'knockout', 'jquery', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojthemeutils', 'ojs/ojanimation'], function (exports, ko, $, oj, DomUtils, ThemeUtils, AnimationUtils) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * A collection of ModuleAnimation implementations that can be specified on the "animation"
   * option of ojModule binding.<br><br>
   * These implementations assume that either the ojModule binding is on a real HTML element
   * or, for ojModule binding on virtual element, each view is contained by a single HTML
   * root element.
   *
   * <h3 id="module-layout-section">
   *   Laying Out ojModule Views
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#module-layout-section"></a>
   * </h3>
   *
   * Guidelines on laying out ojModule views to achieve smoother animation:
   * <ul>
   * <li>The ojModule binding should be placed on a container div that has a dimension
   * independent of its children.  During view switch, new view is inserted and old view
   * is removed.  The container div acts as a placeholder to ensure other elements around
   * the views such as header and navigation controls do not move.
   *
   * <li>All views that will be loaded by the ojModule binding should have the same size.
   * For example by setting their height to 100%.  This will make sure the views fill up
   * the space in the container div.  Some animation effects such as sliding to cover or
   * reveal look best when the old view and the new view have the same size.
   *
   * <li>All views should have a background color.  This will make sure the old view
   * does not show through the new view, unless it is the intent of the application
   * to have a glass pane effect during the animation.
   *
   * <li>Avoid applying css style to any view element that is dependent on the
   * DOM hierarchy outside the view.  This is because during view change the view can be
   * temporarily attached to a different parent.  Having css style that assumes certain
   * hierarchy outside the view can make the desired style not to be applied during animation.
   * </ul>
   *
   * @namespace
   * @ojtsimport {module: "ojanimation", type: "AMD", importName: "AnimationUtils"}
   * @ojtsimport {module: "ojmodule-element", type: "AMD", imported: ["ModuleElementAnimation"]}
   * @since 1.2
   * @ojtsmodule
   * @export
   */
  const ModuleAnimations = {};

  oj._registerLegacyNamespaceProp('ModuleAnimations', ModuleAnimations);

  ModuleAnimations._addContainedElements = function (node, roots) {
    var child = ko.virtualElements.firstChild(node);
    while (child) {
      if (child.nodeType === 1) {
        roots.push(child);
      } else if (child.nodeType === 8) {
        this._addContainedElements(child, roots);
      }

      child = ko.virtualElements.nextSibling(child);
    }
  };

  ModuleAnimations._cacheVirtualViewRoot = function (context, root) {
    // eslint-disable-next-line no-param-reassign
    context._ojOldRoot = root;
  };

  ModuleAnimations._getVirtualViewRoot = function (context) {
    return context._ojOldRoot;
  };

  ModuleAnimations._defaultCanAnimate = function (context) {
    // No animation for the initial module display
    if (context.isInitial) {
      return false;
    }

    // We can animate if the module binding is on a real element
    if (context.node.nodeType === 1) {
      return true;
    }

    // If the module binding is on a comment node, we can animate if the view
    // is single-rooted
    if (context.node.nodeType === 8) {
      var children = [];
      ModuleAnimations._addContainedElements(context.node, children);
      if (children && children.length === 1) {
        ModuleAnimations._cacheVirtualViewRoot(context, children[0]);
        return true;
      }
    }

    return false;
  };

  ModuleAnimations._getOldView = function (context) {
    var oldView;

    if (context.node.nodeType === 1) {
      oldView = context.node;
    } else if (context.node.nodeType === 8) {
      oldView = ModuleAnimations._getVirtualViewRoot(context);
    }

    return oldView;
  };

  ModuleAnimations._createViewParent = function (oldView) {
    var viewport = $(document.createElement('div'));
    var cssStyle = {
      position: 'absolute',
      height: oldView.offsetHeight + 'px',
      width: oldView.offsetWidth + 'px',
      left: oldView.offsetLeft + 'px',
      top: oldView.offsetTop + 'px'
    };

    viewport.appendTo(oldView.offsetParent); // @HTMLUpdateOK viewPort constructed above
    viewport.css(cssStyle);
    viewport.addClass('oj-animation-host-viewport');

    var host = document.createElement('div');
    host.className = 'oj-animation-host';

    viewport.append(host); // @HTMLUpdateOK host is constructed above

    return host;
  };

  /**
   * Create and return a ModuleAnimation implementation that combines base effects from {@link AnimationUtils}
   *
   * @param {null|string|Object|function} oldViewEffect - an animation effect for the outgoing view.<br><br>
   *                              If this is null, no animation will be applied.<br>
   *                              If this is a function, it should return a Promise that resolves when the animation ends.<br>
   *                              If this is a string, it should be one of the effect method names in AnimationUtils.<br>
   *                              If this is an object, it should describe the effect:
   * @param {string} oldViewEffect.effect - the name of an effect method in AnimationUtils
   * @param {*=} oldViewEffect.effectOption - any option applicable to the specific animation effect<br><br>
   *                                                 Replace <i>effectOption</i> with the actual option name.  More than one option can be specified.
   *                                                 Refer to the method description in {@link AnimationUtils} for available options.
   * @param {null|string|Object|function} newViewEffect - an animation effect for the incoming view.<br><br>
   *                                             This is in the same format as oldViewEffect.
   * @param {boolean} newViewOnTop - specify true to initially create the new view on top of the old view.
   *                  This is needed for certain effects such as sliding the new view in to cover the old view.
   *                  Default is false.
   * @return {Object} an implementation of the ModuleAnimation interface
   * @export
   *@ojsignature [
   *  { target: "Type", for: "oldViewEffect", value: "{effect: AnimationUtils.AnimationMethods, [key:string]: any}|AnimationUtils.AnimationMethods|((param0: Element) => Promise<void>)|null"},
   *  { target: "Type", for: "newViewEffect", value: "{effect: AnimationUtils.AnimationMethods, [key:string]: any}|AnimationUtils.AnimationMethods|((param0: Element) => Promise<void>)|null"},
   *  { target: "Type", for: "returns", value: "ModuleElementAnimation"}
   * ]
   *
   * @example <caption>Create a custom ModuleAnimation that fades out old view by 50% and slides in the new view:</caption>
   * var customAnimation = ModuleAnimations.createAnimation({"effect":"fadeOut", "endOpacity":0.5}, {"effect":"slideIn", "direction":"end"}, true);
   */
  ModuleAnimations.createAnimation = function (oldViewEffect, newViewEffect, newViewOnTop) {
    return {
      canAnimate: ModuleAnimations._defaultCanAnimate,
      prepareAnimation: function (context) {
        var viewParents = {};
        var oldView = ModuleAnimations._getOldView(context);

        if (newViewEffect && !newViewOnTop) {
          viewParents.newViewParent = ModuleAnimations._createViewParent(oldView);
        }

        if (oldViewEffect) {
          viewParents.oldViewParent = ModuleAnimations._createViewParent(oldView);
        }

        if (newViewEffect && newViewOnTop) {
          viewParents.newViewParent = ModuleAnimations._createViewParent(oldView);
        }

        return viewParents;
      },
      animate: function (context) {
        var oldViewHost = context.oldViewParent;
        var newViewHost = context.newViewParent;

        var promises = [];

        if (oldViewHost && oldViewEffect) {
          if (typeof oldViewEffect === 'function') {
            promises.push(oldViewEffect(oldViewHost));
          } else {
            // eslint-disable-next-line no-undef
            promises.push(AnimationUtils.startAnimation(oldViewHost, 'close', oldViewEffect));
          }
        }

        if (newViewHost && newViewEffect) {
          if (typeof newViewEffect === 'function') {
            promises.push(newViewEffect(newViewHost));
          } else {
            // eslint-disable-next-line no-undef
            promises.push(AnimationUtils.startAnimation(newViewHost, 'open', newViewEffect));
          }
        }

        var animatePromise = Promise.all(promises);

        return animatePromise
          .then(function () {
            ModuleAnimations._postAnimationProcess(context);
          })
          .catch(function () {
            ModuleAnimations._postAnimationProcess(context);
          });
      }
    };
  };

  ModuleAnimations._removeViewParent = function (context, hostProp) {
    var host = context[hostProp];

    if (host) {
      var viewport = host.parentNode;
      if (viewport && viewport.parentNode) {
        viewport.parentNode.removeChild(viewport);
      }
    }
  };

  ModuleAnimations._postAnimationProcess = function (context) {
    context.removeOldView();
    context.insertNewView();

    ModuleAnimations._removeViewParent(context, 'newViewParent');
    ModuleAnimations._removeViewParent(context, 'oldViewParent');
  };

  ModuleAnimations._getModuleEffect = function (animateName) {
    if (ModuleAnimations._moduleEffects == null) {
      ModuleAnimations._moduleEffects = ThemeUtils.parseJSONFromFontFamily(
        'oj-animation-module-effects'
      );
    }

    if (ModuleAnimations._moduleEffects) {
      return ModuleAnimations._moduleEffects[animateName];
    }

    return null;
  };

  ModuleAnimations._getImplementation = function (animateName) {
    var descriptor = ModuleAnimations._getModuleEffect(animateName);
    if (descriptor) {
      return ModuleAnimations.createAnimation(
        descriptor.oldViewEffect,
        descriptor.newViewEffect,
        descriptor.newViewOnTop
      );
    }

    return null;
  };

  ModuleAnimations._getNavigateMethod = function (context, navigationType) {
    if (ModuleAnimations._navigateMethods == null) {
      ModuleAnimations._navigateMethods = ThemeUtils.parseJSONFromFontFamily(
        'oj-animation-navigate-methods'
      );
    }

    if (ModuleAnimations._navigateMethods) {
      return ModuleAnimations._navigateMethods[navigationType];
    }

    return null;
  };

  ModuleAnimations._navigateCanAnimate = function (context, navigationType) {
    var animateName = ModuleAnimations._getNavigateMethod(context, navigationType);
    if (ModuleAnimations[animateName]) {
      return (
        ModuleAnimations[animateName].canAnimate == null ||
        ModuleAnimations[animateName].canAnimate(context)
      );
    }

    return false;
  };

  ModuleAnimations._navigatePrepareAnimation = function (context, navigationType) {
    var animateName = ModuleAnimations._getNavigateMethod(context, navigationType);
    if (ModuleAnimations[animateName] && ModuleAnimations[animateName].prepareAnimation) {
      return ModuleAnimations[animateName].prepareAnimation(context);
    }

    return null;
  };

  ModuleAnimations._navigateAnimate = function (context, navigationType) {
    var animateName = ModuleAnimations._getNavigateMethod(context, navigationType);
    if (ModuleAnimations[animateName] && ModuleAnimations[animateName].animate) {
      return ModuleAnimations[animateName].animate(context);
    }

    return Promise.resolve();
  };

  ModuleAnimations._getNavigateImplementation = function (navigationType) {
    return {
      canAnimate: function (context) {
        return ModuleAnimations._navigateCanAnimate(context, navigationType);
      },
      prepareAnimation: function (context) {
        return ModuleAnimations._navigatePrepareAnimation(context, navigationType);
      },
      animate: function (context) {
        return ModuleAnimations._navigateAnimate(context, navigationType);
      }
    };
  };

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the new view left to cover the old view.
   * @export
   * @memberof ModuleAnimations
   * @ignore
   */
  ModuleAnimations.coverLeft = ModuleAnimations._getImplementation('coverLeft');

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the new view left to cover the old view.
   * @export
   * @memberof ModuleAnimations
   * @ignore
   */
  ModuleAnimations.coverRight = ModuleAnimations._getImplementation('coverRight');

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the old view left to reveal the new view.
   * @export
   * @memberof ModuleAnimations
   * @ignore
   */
  ModuleAnimations.revealLeft = ModuleAnimations._getImplementation('revealLeft');

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the old view right to reveal the new view.
   * @export
   * @memberof ModuleAnimations
   * @ignore
   */
  ModuleAnimations.revealRight = ModuleAnimations._getImplementation('revealRight');

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the new view in to cover the old view.<br><br>
   * This will take the text direction of the page into account.  On "ltr" page,
   * the new view will slide to the left.  On "rtl" page, it will slide to the
   * right.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.coverStart =
    DomUtils.getReadingDirection() === 'rtl'
      ? ModuleAnimations.coverRight
      : ModuleAnimations.coverLeft;

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the old view out to reveal the new view.<br><br>
   * This will take the text direction of the page into account.  On "ltr" page,
   * the old view will slide to the right.  On "rtl" page, it will slide to the
   * left.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.revealEnd =
    DomUtils.getReadingDirection() === 'rtl'
      ? ModuleAnimations.revealLeft
      : ModuleAnimations.revealRight;

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the new view up to cover the old view.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.coverUp = ModuleAnimations._getImplementation('coverUp');

  /**
   * ModuleAnimation implementation for changing views by
   * sliding the old view down to reveal the new view.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.revealDown = ModuleAnimations._getImplementation('revealDown');

  /**
   * ModuleAnimation implementation for changing views by
   * zooming in on the new view.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.zoomIn = ModuleAnimations._getImplementation('zoomIn');

  /**
   * ModuleAnimation implementation for changing views by
   * zooming out on the old view.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.zoomOut = ModuleAnimations._getImplementation('zoomOut');

  /**
   * ModuleAnimation implementation for changing views by
   * fading in the new view and fading out the old view.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.fade = ModuleAnimations._getImplementation('fade');

  /**
   * ModuleAnimation implementation for changing views by
   * having the new view push out the old view towards the start of the reading order.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.pushStart = ModuleAnimations._getImplementation('pushStart');

  /**
   * ModuleAnimation implementation for changing views by
   * having the new view push out the old view towards the end of the reading order.
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   */
  ModuleAnimations.pushEnd = ModuleAnimations._getImplementation('pushEnd');

  /**
   * ModuleAnimation implementation for navigating to child views by
   * using animations that are dependent on the platform theme.
   * <p>The default animations for each platform theme are as follows:</p>
   * <ul>
   *   <li>Web theme: coverStart</li>
   *   <li>iOS theme: coverStart</li>
   *   <li>Android theme: coverUp</li>
   *   <li>Windows theme: zoomIn</li>
   * </ul>
   * <p>The default animation can be changed with the following theme variable:<br>
   * <code class="prettyprint">$animationNavChildDefault</code>: specify
   * the animation for navigating to child views.<br>
   * <p>Valid values are the names of specific animation implementations such as
   * "coverStart".</p>
   * @export
   * @memberof ModuleAnimations
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @example <caption>Set the default in the theme (SCSS) :</caption>
   * $animationNavChildDefault:  coverStart  !default;
   */
  ModuleAnimations.navChild = ModuleAnimations._getNavigateImplementation('navChild');

  /**
   * ModuleAnimation implementation for navigating to parent views by
   * using animations that are dependent on the platform theme.
   * <p>The default animations for each platform theme are as follows:</p>
   * <ul>
   *   <li>Web theme: revealEnd</li>
   *   <li>iOS theme: revealEnd</li>
   *   <li>Android theme: revealDown</li>
   *   <li>Windows theme: zoomOut</li>
   * </ul>
   * <p>The default animation can be changed with the following theme variable:<br>
   * <code class="prettyprint">$animationNavParentDefault</code>: specify
   * the animation for navigating to parent views.</p>
   * <p>Valid values are the names of specific animation implementations such as
   * "revealEnd".</p>
   * @export
   * @memberof ModuleAnimations
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @example <caption>Set the default in the theme (SCSS) :</caption>
   * $animationNavParentDefault:  revealEnd  !default;
   */
  ModuleAnimations.navParent = ModuleAnimations._getNavigateImplementation('navParent');

  /**
   * ModuleAnimation implementation for drilling in to views by
   * using animations that are dependent on the platform theme.
   * <p>The default animations for each platform theme are as follows:</p>
   * <ul>
   *   <li>Web theme: coverStart</li>
   *   <li>iOS theme: coverStart</li>
   *   <li>Android theme: coverUp</li>
   *   <li>Windows theme: zoomIn</li>
   * </ul>
   * @export
   * @ignore
   * @memberof ModuleAnimations
   * @deprecated This is deprecated.  Please use <a href="#navChild">navChild</a> instead.
   */
  ModuleAnimations.drillIn = ModuleAnimations.navChild;

  /**
   * ModuleAnimation implementation for drilling out of views by
   * using animations that are dependent on the platform theme.
   * <p>The default animations for each platform theme are as follows:</p>
   * <ul>
   *   <li>Web theme: revealEnd</li>
   *   <li>iOS theme: revealEnd</li>
   *   <li>Android theme: revealDown</li>
   *   <li>Windows theme: zoomOut</li>
   * </ul>
   * @export
   * @ignore
   * @memberof ModuleAnimations
   * @deprecated This is deprecated.  Please use <a href="#navParent">navParent</a> instead.
   */
  ModuleAnimations.drillOut = ModuleAnimations.navParent;

  /**
   * ModuleAnimation implementation for navigating to sibling views earlier in the reading order by
   * using animations that are dependent on the platform theme.
   * <p>The default animations for each platform theme are as follows:</p>
   * <ul>
   *   <li>Web theme: none</li>
   *   <li>iOS theme: none</li>
   *   <li>Android theme: pushEnd</li>
   *   <li>Windows theme: pushEnd</li>
   * </ul>
   * <p>The default animation can be changed with the following theme variable:<br>
   * <code class="prettyprint">$animationNavSiblingEarlierDefault</code>: specify
   * the animation for navigating to sibling views earlier in the reading order.</p>
   * <p>Valid values are the names of specific animation implementations such as
   * "pushEnd".</p>
   * @export
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @memberof ModuleAnimations
   * @example <caption>Set the default in the theme (SCSS) :</caption>
   * $animationNavSiblingEarlierDefault:  pushEnd  !default;
   */
  ModuleAnimations.navSiblingEarlier =
    ModuleAnimations._getNavigateImplementation('navSiblingEarlier');

  /**
   * ModuleAnimation implementation for navigating to sibling views later in the reading order by
   * using animations that are dependent on the platform theme.
   * <p>The default animations for each platform theme are as follows:</p>
   * <ul>
   *   <li>Web theme: none</li>
   *   <li>iOS theme: none</li>
   *   <li>Android theme: pushStart</li>
   *   <li>Windows theme: pushStart</li>
   * </ul>
   * <p>The default animation can be changed with the following theme variable:<br>
   * <code class="prettyprint">$animationNavSiblingLaterDefault</code>: specify
   * the animation for navigating to sibling views later in the reading order.</p>
   * <p>Valid values are the names of specific animation implementations such as
   * "pushStart".</p>
   * @export
   * @memberof ModuleAnimations
   * @ojsignature {target: "Type", value: "ModuleElementAnimation"}
   * @example <caption>Set the default in the theme (SCSS) :</caption>
   * $animationNavSiblingLaterDefault:  pushStart  !default;
   */
  ModuleAnimations.navSiblingLater = ModuleAnimations._getNavigateImplementation('navSiblingLater');

  /**
   * Returns an implementation of ModuleAnimation interface that switches between different animation implementations
   *
   * @param {Function} callback - a callback function whose return value should be a string containing one of the animation types
   * supported by ModuleAnimations. The function will be passed a context object with the keys detailed below:
   * <ul>
   * <li>node - a DOM node where the ojModule binding is attached. This may be a virtual/comment node</li>
   * <li>valueAccessor - value accessor for the binding</li>
   * <li>isInitial  - true if the initial View is about to be displayed, false otherwise</li>
   * <li>oldViewModel - the instance of the ViewModel for the old View</li>
   * <li>newViewModel  - the instance of the ViewModel for the new View</li>
   * </ul>
   *
   * @return {Object} switching implementation of the ModuleAnimation interface
   * @ojsignature [
   *    {target:"Type", for: "callback", value: "(param0: ModuleAnimations.SwitcherCallBackParam) => ModuleAnimations.Animations"},
   *    {target:"Type", for: "returns", value: "ModuleElementAnimation"}
   *  ]
   * @export
   */
  ModuleAnimations.switcher = function (callback) {
    /**
     * @constructor
     * @private
     */
    var AnimateProxy = function () {
      var _delegate;

      function _getDelegateInvoker(name) {
        var invoker = function (context) {
          return _delegate[name].call(_delegate, context);
        };
        return invoker;
      }

      var _self = this;
      var _canAnimate = 'canAnimate';

      this[_canAnimate] = function (context) {
        // Get the 'delegate' animation
        var type = callback(context);
        _delegate = type == null ? null : ModuleAnimations[type];
        if (!_delegate) {
          return false;
        }

        // Define the rest of the methods on the fly if we have a delegate
        var methods = ['prepareAnimation', 'animate'];
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          _self[method] = _getDelegateInvoker(method);
        }

        return _getDelegateInvoker(_canAnimate)(context);
      };
    };

    return new AnimateProxy();
  };

  /**
   * @typedef {Object} ModuleAnimations.SwitcherCallBackParam
   * @property {Element} node
   * @property {function() : any} valueAccessor
   * @property {boolean} isInitial
   * @property {any} oldViewModel
   * @property {any} newViewModel
   */
  /**
   * All the available animation types supported in ModuleAnimations
   * @typedef {Object} ModuleAnimations.Animations
   * @ojvalue {string} "coverStart"
   * @ojvalue {string} "coverUp"
   * @ojvalue {string} "fade"
   * @ojvalue {string} "navChild"
   * @ojvalue {string} "navParent"
   * @ojvalue {string} "navSiblingEarlier"
   * @ojvalue {string} "navSiblingLater"
   * @ojvalue {string} "pushEnd"
   * @ojvalue {string} "pushStart"
   * @ojvalue {string} "revealDown"
   * @ojvalue {string} "revealEnd"
   * @ojvalue {string} "zoomIn"
   * @ojvalue {string} "zoomOut"
   */

  const createAnimation = ModuleAnimations.createAnimation;
  const coverLeft = ModuleAnimations.coverLeft;
  const coverRight = ModuleAnimations.coverRight;
  const revealLeft = ModuleAnimations.revealLeft;
  const revealRight = ModuleAnimations.revealRight;
  const coverStart = ModuleAnimations.coverStart;
  const revealEnd = ModuleAnimations.revealEnd;
  const coverUp = ModuleAnimations.coverUp;
  const revealDown = ModuleAnimations.revealDown;
  const zoomIn = ModuleAnimations.zoomIn;
  const zoomOut = ModuleAnimations.zoomOut;
  const fade = ModuleAnimations.fade;
  const pushStart = ModuleAnimations.pushStart;
  const pushEnd = ModuleAnimations.pushEnd;
  const navChild = ModuleAnimations.navChild;
  const navParent = ModuleAnimations.navParent;
  const drillIn = ModuleAnimations.drillIn;
  const drillOut = ModuleAnimations.drillOut;
  const navSiblingEarlier = ModuleAnimations.navSiblingEarlier;
  const navSiblingLater = ModuleAnimations.navSiblingLater;
  const switcher = ModuleAnimations.switcher;

  exports.coverLeft = coverLeft;
  exports.coverRight = coverRight;
  exports.coverStart = coverStart;
  exports.coverUp = coverUp;
  exports.createAnimation = createAnimation;
  exports.drillIn = drillIn;
  exports.drillOut = drillOut;
  exports.fade = fade;
  exports.navChild = navChild;
  exports.navParent = navParent;
  exports.navSiblingEarlier = navSiblingEarlier;
  exports.navSiblingLater = navSiblingLater;
  exports.pushEnd = pushEnd;
  exports.pushStart = pushStart;
  exports.revealDown = revealDown;
  exports.revealEnd = revealEnd;
  exports.revealLeft = revealLeft;
  exports.revealRight = revealRight;
  exports.switcher = switcher;
  exports.zoomIn = zoomIn;
  exports.zoomOut = zoomOut;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdefer',['ojs/ojkoshared', 'knockout', 'ojs/ojcore-base'], function (BindingProviderImpl, ko, oj) { 'use strict';

  BindingProviderImpl = BindingProviderImpl && Object.prototype.hasOwnProperty.call(BindingProviderImpl, 'default') ? BindingProviderImpl['default'] : BindingProviderImpl;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  (function () {
    BindingProviderImpl.addPostprocessor({
      nodeHasBindings: function (node, _wrappedReturn) {
        var wrappedReturn = _wrappedReturn;
        return (
          wrappedReturn ||
          (node.nodeType === 1 &&
            /* istanbul ignore next: nodeHasBindings only called for non-elements */
            node.nodeName.toLowerCase() === 'oj-defer')
        );
      },
      getBindingAccessors: function (node, bindingContext, _wrappedReturn) {
        var wrappedReturn = _wrappedReturn;
        if (node.nodeType === 1 && node.nodeName.toLowerCase() === 'oj-defer') {
          wrappedReturn = wrappedReturn || {};
          wrappedReturn._ojDefer_ =
            /* istanbul ignore next: binding handler doesn't call valueAccessor */
            function () {};
        }
        return wrappedReturn;
      }
    });
  })();

  ko.bindingHandlers._ojDefer_ = {
    init: function (_element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
      var element = _element;

      // _shown is set if subtreeShown was called before bound. Therefore, if _shown was set
      // we can directly call ko.applyBindingsToDescendants() without waiting for subtreeShown
      // because it was already called.

      if (!element._shown) {
        // this _activateSubtree function will be called from the element's
        // _activate API.
        if (!element._activateSubtree) {
          // Stash away the children into a node array and pass them through closure
          // to _activateSubtree() function.
          var nodesArray = [];
          while (element.firstChild) {
            nodesArray.push(element.firstChild);
            element.removeChild(element.firstChild);
          }
          element._activateSubtree = (parentNode) => {
            nodesArray.forEach((node) => parentNode.appendChild(node));
            ko.applyBindingsToDescendants(bindingContext, parentNode);
          };
        }
      } else {
        ko.applyBindingsToDescendants(bindingContext, element);
      }
      return { controlsDescendantBindings: true };
    }
  };

  /**
   *
   * @since 4.0.0
   * @ojcomponent oj.ojDefer
   * @ojshortdesc Defer is used to delay applying bindings to its children until it is activated. Child elements are disconnected from the DOM tree until the parent component activates its subtree.
   * @ojsignature {target: "Type", value:"class ojDefer extends HTMLElement"}
   * @ojhtmlelement
   * @ojoracleicon 'oj-ux-ico-defer'
   * @classdesc
   * The oj-defer custom element delays applying bindings to its children until it is activated.
   * It works by disconnecting child elements from the DOM tree until the parent component activates its subtree. In addition, the tag will
   * defer binding execution and disconnect children within hidden subtrees of the components which support it.
   * There are several components which support oj-defer:<br>
   * <ul>
   * <li>Collapsible</li>
   * <li>Dialog</li>
   * <li>Film Strip</li>
   * <li>Off Canvas</li>
   * <li>Drawer Popup</li>
   * <li>Drawer Layout</li>
   * <li>Popup</li>
   * <li>MasonryLayout</li>
   * <li>Menu</li>
   * <li>Composite Component Slots</li>
   * </ul>
   * <p>&lt;oj-defer> only defers applying bindings to its contents, it does not defer the loading of JavaScript modules needed to fully instantiate the DOM.
   * For example, while &lt;oj-defer> can defer applying bindings to an &lt;oj-button> element, the containing page must still aggresively load
   * the "ojs/ojbutton" module for the component to be created.
   * Using an &lt;oj-module> within an &lt;oj-defer> offers a way to additionally defer the loading of JavaScript modules;
   * any modules needed to instantiate the view of the &lt;oj-module> will not be loaded until bindings
   * are applied to the &lt;oj-module> by the containing &lt;oj-defer>.
   * </p>
   * <p>Note: For composite component slots, the oj-defer element could have a slot attribute specified directly on it,
   * i.e. &lt;oj-defer slot="something">, or &lt;oj-defer> could appear within a child subtree of the element with a slot attribute. Also,
   * the current implementation may allow bindings to be applied
   * to the content within &lt;oj-defer> prematurely if the tag is used in one of the
   * 'hiding' components that is nested within another 'hiding' component. That
   * limitation will be removed in the future.</p>
   */

  class DeferElement extends HTMLElement {
    constructor() {
      super();
      // Define internal properties for the _shown and _activateSubtree class properties.
      this._activateSubtreeInternal = null;
      this._shownInternal = false;
    }

    // Add getter for _shown. We don't need setter since we don't want external code to modify it.
    // The property is used as a flag in activating elements when binding.
    get _shown() {
      return this._shownInternal;
    }
    // Add getter and setter for _activateSubtree, since we expect the external code to set the value.
    // _activateSubtree is a non-public property that will be defined as a function by either ko.bindingHandlers
    // or VTemplateEngine. The function will attach saved child nodes to oj-defer element and apply bindings
    // if necessary. The property will be deleted by the caller after a single use.
    get _activateSubtree() {
      return this._activateSubtreeInternal;
    }
    set _activateSubtree(value) {
      this._activateSubtreeInternal = value;
    }
    // Define the class method that would be used by JET and only be called
    // by subtreeAttach
    _activate() {
      if (!this._activateSubtree) {
        // if the _activateSubtree function is not there then that means we have
        // not been bound yet. Therefore, this internal property sets _shown to true
        // as a flag to activate when bound.
        this._shownInternal = true;
      } else {
        // if we have stashed away children, put them back, apply binding and then
        // set the internal property to null.
        this._activateSubtree(this);
        this._activateSubtreeInternal = null;
      }
    }
  }
  customElements.define('oj-defer', DeferElement);
  oj._registerLegacyNamespaceProp('DeferElement', DeferElement);

});


define('ojs/ojdatasource-common',['exports', 'ojs/ojcore-base', 'ojs/ojcore'], function (exports, oj$1, oj$2) { 'use strict';

  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;
  oj$2 = oj$2 && Object.prototype.hasOwnProperty.call(oj$2, 'default') ? oj$2['default'] : oj$2;

  /**
   * @preserve Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  /* jslint browser: true*/

  /**
   * @export
   * @class DataSource
   * @extends EventSource
   * @classdesc Object representing data used by table and grid components
   * @param {Object} data data supported by the components
   * @constructor
   * @final
   * @since 1.0
   * @abstract
   * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
   * @ojtsignore
   */
  const DataSource = function (data) {
    this.data = data;
    this.Init();
  };
  oj$1._registerLegacyNamespaceProp('DataSource', DataSource);
  /**
   * Subclass from oj.Object
   * @private
   */
  oj$1.Object.createSubclass(DataSource, oj$1.EventSource, 'oj.DataSource');

  /**
   * Initializes the instance.
   * @export
   * @memberof DataSource
   * @return {undefined}
   * @ojtsignore
   */
  DataSource.prototype.Init = function () {
    DataSource.superclass.Init.call(this);
  };

  /**
   * Determines whether this DataSource supports the specified feature.
   * @method
   * @name getCapability
   * @memberof DataSource
   * @instance
   * @param {string} feature the feature in which its capabilities is inquired.
   * @return {string|null} the capability of the specified feature.  Returns null if the feature is not recognized.
   */

  /**
   * @class DataGridDataSource
   * @classdesc The base class for DataGridDataSource.<br>
   * DataGridDataSource implementations must implement all of the functions documented here.
   * @export
   * @extends DataSource
   * @constructor
   * @final
   * @since 1.0
   * @ojtsignore
   */
  const DataGridDataSource = function (data) {
    // DataSource would calls Init
    DataGridDataSource.superclass.constructor.call(this, data);
  };
  oj$2._registerLegacyNamespaceProp('DataGridDataSource', DataGridDataSource);
  /**
   * Subclass DataGridDataSource to DataSource
   * @private
   */
  oj$2.Object.createSubclass(DataGridDataSource, oj$2.DataSource, 'oj.DataGridDataSource');

  /**
   * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
   * that the total count is unknown.
   * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
   * @return {number} the total number of rows/columns.
   * @method
   * @name getCount
   * @memberof DataGridDataSource
   * @instance
   */

  /**
   * Returns whether the total count returned in getCount function is an actual or an estimate.
   * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are
   *        "row" and "column".
   * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the
   *         count returned in getCount function is an estimate.  The default value is "exact".
   * @method
   * @name getCountPrecision
   * @memberof DataGridDataSource
   * @instance
   */

  /**
   * Fetch a range of headers from the data source.
   * @export
   * @method
   * @name fetchHeaders
   * @memberof DataGridDataSource
   * @instance
   * @param {Object} headerRange information about the header range, it must contain the following properties:
   *        axis, start, count.
   * @property {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
   * @property {number} headerRange.start the start index of the range in which the header data are fetched.
   * @property {number} headerRange.count the size of the range in which the header data are fetched.
   * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.
   * @property {function({startHeaderSet: Object}, {headerRange: Object}, {endHeaderSet: Object}):undefined} callbacks.success the callback to invoke when fetch headers completed successfully.
   *        The function takes three parameters: HeaderSet object representing start headers, headerRange object passed into the original fetchHeaders call,
   *        and a HeaderSet object representing the end headers along the axis.
   * @property {function({status: Object}):undefined} callbacks.error the callback to invoke when fetch cells failed.
   * @param {Object=} callbackObjects the object in which the callback function is invoked on.
   * @property {Object=} callbackObjects.success
   * @property {Object=} callbackObjects.error
   * @return {undefined}
   */

  /**
   * Fetch a range of cells from the data source.
   * @method
   * @name fetchCells
   * @memberof DataGridDataSource
   * @instance
   * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array
   *        of range info for each axis, where each range contains three properties: axis, start, count.
   * @property {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid
   *        values are "row" and "column".
   * @property {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
   * @property {number} cellRanges.count the size of the range for this axis in which the cells are fetched.
   * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.
   * @property {function({cellSet: Object}, {cellRanges: Array.<Object>}):undefined} callbacks.success the callback to invoke when fetch cells completed successfully.
   * @property {function({status: Object}):undefined} callbacks.error the callback to invoke when fetch cells failed.
   * @param {Object=} callbackObjects the object in which the callback function is invoked on.
   * @property {Object=} callbackObjects.success
   * @property {Object=} callbackObjects.error
   * @return {undefined}
   */

  /**
   * Returns the keys based on the indexes.
   * @method
   * @name keys
   * @memberof DataGridDataSource
   * @instance
   * @param {Object} indexes the index for each axis
   * @property {number|null} indexes.row the index for the row axis
   * @property {number|null} indexes.column the index for the column axis
   * @return {Promise.<Object>} a Promise object which when resolved returns an object containing the keys for each axis
   */

  /**
   * Returns the row and column index based on the keys.
   * @method
   * @name indexes
   * @memberof DataGridDataSource
   * @instance
   * @param {Object} keys the key for each axis
   * @property {any} keys.row the key for the row axis
   * @property {any} keys.column the key for the column axis
   * @return {Promise.<Object>} a Promise object which when resolved returns an object containing the index for each axis
   */

  /**
   * Performs a sort on the data source.
   * @method
   * @name sort
   * @memberof DataGridDataSource
   * @instance
   * @param {Object|null} criteria the sort criteria.
   * @property {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
   * @property {any} criteria.key The key that identifies which header to sort
   * @property {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   * @param {Object=} callbacks the callbacks to be invoke upon completion of the sort operation.
   * @property {function():undefined=} callbacks.success the callback to invoke when the sort completed successfully.
   * @property {function({status: Object}):undefined=} callbacks.error the callback to invoke when sort failed.
   * @param {Object=} callbackObjects the object in which the callback function is invoked on.
   * @property {Object=} callbackObjects.success
   * @property {Object=} callbackObjects.error
   * @return {undefined}
   */

  /**
   * Moves a row from one location to another.
   * @method
   * @name move
   * @memberof DataGridDataSource
   * @instance
   * @param {any} rowToMove the key of the row to move
   * @param {any} referenceRow the key of the reference row which combined with position are used to determine
   *        the destination of where the row should moved to.
   * @param {string} position The position of the moved row relative to the reference row.
   *        Valid values are: "before", "after"
   * @param {Object=} callbacks the callbacks to be invoke upon completion of the move operation.
   * @property {function():undefined=} callbacks.success the callback to invoke when the sort completed successfully.
   * @property {function({status: Object}):undefined=} callbacks.error the callback to invoke when sort failed.
   * @param {Object=} callbackObjects the object in which the callback function is invoked on.
   * @property {Object=} callbackObjects.success
   * @property {Object=} callbackObjects.error
   * @return {undefined}
   */

  /**
   * Checks whether a move operation is valid.
   * @param {any} rowToMove the key of the row to move
   * @param {any} referenceRow the key of the reference row which combined with position are used to determine
   *        the destination of where the row should moved to.
   * @param {string} position the position of the moved row relative to the reference row.
   * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
   * @method
   * @name moveOK
   * @memberof DataGridDataSource
   * @instance
   */

  /**
   * Determines whether this DataGridDataSource supports certain feature.
   * @method
   * @name getCapability
   * @memberof DataGridDataSource
   * @instance
   * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
   * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".
   *         For "move", the valid return values are: "row", "none".
   *         Returns null if the feature is not recognized.
   */

  /**
   * @class DiagramDataSource
   * @classdesc Base class for Diagram DataSource.  Implementations must implement all of the functions documented here.
   * @param {Object} data data required by the DiagramDataSource implementation
   * @export
   * @extends DataSource
   * @constructor
   * @final
   * @since 3.0
   * @ojtsignore
   * @ojdeprecated {since: '14.0.0', description: 'DiagramDataSource has been deprecated with the oj-diagram data property,
   * use DataProvider on nodeData and linkData oj-diagram attributes instead.'}
   */
  const DiagramDataSource = function (data) {
    DiagramDataSource.superclass.constructor.call(this, data);
  };
  oj$1._registerLegacyNamespaceProp('DiagramDataSource', DiagramDataSource);

  /**
   * Subclass DiagramDataSource to DataSource
   * @private
   */
  oj$1.Object.createSubclass(DiagramDataSource, oj$1.DataSource, 'oj.DiagramDataSource');

  /**
   * Object that defines diagram node. The object might also have additional custom properties that can be
   * mapped to node styles (see {@link oj.ojDiagram#nodeProperties})
   * or used during Diagram layout (see {@link oj.DvtDiagramLayoutContextNode#getData}).
   * @typedef {Object} NodeObject
   * @memberof DiagramDataSource
   * @property {string} id Node id
   * @property {Array.<string>=} categories An optional array of additional category strings corresponding to the node.
   * @property {string=} label The label for the node. If the string contains new line characters, a multi-line label will be rendered.
   * @property {Array.<Object>=} nodes An array of objects with properties for the child nodes.
   *                     Set value to null to indicate leaf node, if child nodes could be fetched on container disclosure.
   *                     Set value to 'undefined' to indicate potential child nodes, if the child nodes should be fetched on container disclosure.
   * @property {string=} selectable Specifies whether or not the node will be selectable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
   * @property {string=} draggable  Specifies whether or not the node will be draggable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
   * @property {string=} shortDesc  The description of the node. This is used for accessibility and also for customizing the tooltip text.
   */

  /**
   * Object that defines diagram link. The object might also have additional custom properties that can be
   * mapped to link styles (see {@link oj.ojDiagram#linkProperties})
   * or used during Diagram layout (see {@link oj.DvtDiagramLayoutContextLink#getData}).
   * @typedef {Object} LinkObject
   * @memberof DiagramDataSource
   * @property {string} id Link id
   * @property {string} startNode Start node id.
   * @property {string} endNode End node id.
   * @property {Array.<string>=} categories An optional array of additional category strings corresponding to the link.
   * @property {string=} label The label for the link. If the string contains new line characters, a multi-line label will be rendered.
   * @property {string=} selectable Specifies whether or not the node will be selectable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
   * @property {string=} shortDesc  The description of the node. This is used for accessibility and also for customizing the tooltip text.
   */

  /**
   * Returns child data for the given parent.
   * The data include all immediate child nodes along with links whose endpoints
   * both descend from the current parent node.
   * If all the links are available upfront, they can be returned as part of the
   * top-level data (since all nodes descend from the diagram root).
   * If lazy-fetching links is desirable, the most
   * optimal way to return links is as part of the data of the
   * nearest common ancestor of the link's endpoints.
   *
   * @param {Object|null} parentData An object that contains data for the parent node. See {@link DiagramDataSource.NodeObject} section.
   *                     If parentData is null, the method retrieves data for top level nodes.
   * @return {Promise} Promise resolves to a component object with the following structure:<p>
   * <table>
   * <tbody>
   * <tr><td><b>nodes</b></td><td>An array of objects for the child nodes for the given parent.
   *              See {@link DiagramDataSource.NodeObject} section.</td></tr>
   * <tr><td><b>links</b></td><td>An array of objects for the links for the given parent.
   *              See {@link DiagramDataSource.LinkObject} section.</td></tr>
   * </tbody>
   * </table>
   * @method
   * @name getData
   * @memberof DiagramDataSource
   * @instance
   */

  /**
   * Retrieves number of child nodes
   * @param {Object} nodeData A data object for the node in question.
   *                          See {@link DiagramDataSource.NodeObject} section.
   * @return {number} Number of child nodes if child count is available.
   *                  The method returns 0 for leaf nodes.
   *                  The method returns -1 if the child count is unknown
   *                  (e.g. if the children have not been fetched).
   * @method
   * @name getChildCount
   * @memberof DiagramDataSource
   * @instance
   */

  /**
   * Indicates whether the specified object contains links
   * that should be discovered in order to display promoted links.
   *
   * @param {Object} nodeData A data object for the container node in question.
   *                          See {@link DiagramDataSource.NodeObject} section
   * @return {string} the valid values are "connected", "disjoint", "unknown"
   * @method
   * @name getDescendantsConnectivity
   * @memberof DiagramDataSource
   * @instance
   */

  /**
   * @export
   * Event types
   * @enum {string}
   * @memberof DiagramDataSource
   */
  DiagramDataSource.EventType = {
    /**
     * Triggered when nodes or links are added to DiagramDataSource.<p>
     * The event payload contains.<p>
     *
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
     *  <ul>
     *    <li>nodes: An array of node objects. See {@link DiagramDataSource.NodeObject} section.</li>
     *    <li>links: An array of link objects. See {@link DiagramDataSource.LinkObject} section.</li>
     *  </ul>
     * </td></tr>
     * <tr><td><b>parentId</b></td><td>string</td><td>parent id for nodes and links</td></tr>
     * <tr><td><b>index</b></td><td>number</td><td>An index where the nodes should be added</td></tr>
     * </tbody>
     * </table>
     */
    ADD: 'add',
    /**
     * Triggered when nodes or links are removed from DiagramDataSource.
     * The event payload contains:<p>
     *
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
     *  <ul>
     *    <li>nodes: An array of node objects. See {@link DiagramDataSource.NodeObject} section.</li>
     *    <li>links: An array of link objects. See {@link DiagramDataSource.LinkObject} section.</li>
     *  </ul>
     * </td></tr>
     * <tr><td><b>parentId</b></td><td>string</td><td>parent id for nodes and links</td></tr>
     * </tbody>
     * </table>
     */
    REMOVE: 'remove',
    /**
     * Triggered when nodes or links are removed from DiagramDataSource.
     * The event payload contains:<p>
     *
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
     *  <ul>
     *    <li>nodes: An array of node objects. See {@link DiagramDataSource.NodeObject} section.</li>
     *    <li>links: An array of link objects. See {@link DiagramDataSource.LinkObject} section.</li>
     *  </ul>
     * </td></tr>
     * </tbody>
     * </table>
     */
    CHANGE: 'change'
  };

  /**
   * @preserve Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  /* jslint browser: true,devel:true*/

  /**
   * @export
   * @class TableDataSource
   * @abstract
   * @classdesc Abstract class representing tabular data that can be used by different components such as [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
   * [PagingControl]{@link oj.ojPagingControl}, [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
   * This class is not used directly and is used as the base to implement other subclasses.  Implementations of TableDataSource must implement all of the methods documented here.<br><br>
   * JET provides the following implementations:<br><br>
   * <table class="generic-table">
   *   <thead>
   *     <th>Subclass</th>
   *     <th>When to Use</th>
   *     <th>Use with</th>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>{@link ArrayTableDataSource}</td>
   *       <td>When the data is available from an array.</td>
   *       <td>ListView<br>NavigationList<br>TabBar<br>Table<br></td>
   *     </tr>
   *     <tr>
   *       <td>{@link CollectionTableDataSource}</td>
   *       <td>When the data is available from an {@link Collection} object, such as an external data source.</td>
   *       <td>ListView<br>NavigationList<br>TabBar<br>Table<br></td>
   *     </tr>
   *     <tr>
   *       <td>{@link oj.FlattenedTreeTableDataSource}</td>
   *       <td>When the data has a tree-like structure that is displayed in a Table with RowExpander.</td>
   *       <td>Table (with RowExpander)<br></td>
   *     </tr>
   *     <tr>
   *       <td>{@link PagingTableDataSource}</td>
   *       <td>When paging functionality is needed on top of other TableDataSource implementations.</td>
   *       <td>ListView<br>PagingControl<br>Table<br></td>
   *     </tr>
   *   </tbody>
   * </table>
   * <br>Refer to the documentation and demos of individual components for more information on how to use them with the TableDataSource subclasses.</br><br>
   * In case specialized behavior is needed, new subclass can be created by using [oj.Object.createSubclass]{@link oj.Object.createSubclass}.  New subclass can be based on
   * TableDataSource, in which case all methods must be implemented, or it can be based on an existing subclass, in which case only methods that require different behavior need
   * to be overridden.
   *
   * @extends DataSource
   * @param {Object} data data supported by the components
   * @param {Object=} options Options for the TableDataSource
   * @constructor
   * @final
   * @since 1.0
   * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
   * @ojtsignore
   */
  const TableDataSource = function (data, options) {
    if (this.constructor === TableDataSource) {
      // This should only be called by the constructors of the subclasses. If you need
      // to initialize a new TableDataSource then call the constructors of the subclasses such
      // as oj.ArrayTableDataSource or oj.CollectionTableDataSource.
      var errSummary = TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY;
      var errDetail = TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL;
      throw new Error(errSummary + '\n' + errDetail);
    }
    // Initialize
    this.data = data;
    this.options = options;
    this.isFetching = false;
    this._startIndex = 0;
    this.Init();
  };
  oj$2._registerLegacyNamespaceProp('TableDataSource', TableDataSource);

  /**
   * Subclass from oj.DataSource
   * @private
   */
  oj$2.Object.createSubclass(TableDataSource, oj$2.DataSource, 'oj.TableDataSource');

  /**
   * Initializes the instance.
   * @memberof TableDataSource
   * @instance
   * @override
   * @protected
   */
  TableDataSource.prototype.Init = function () {
    TableDataSource.superclass.Init.call(this);
  };

  /**
   * @export
   * @expose
   * @memberof TableDataSource
   * @desc The sort criteria. Whenever sort() is called with the criteria parameter, that value is copied to this
   * property. If sort() is called with empty sort criteria then the criteria set in this property is used.
   *
   * @type {Object}
   * @property {any} criteria.key The key that identifies which field to sort
   * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   */
  TableDataSource.prototype.sortCriteria = null;

  /**
   * Return the row data found at the given index.
   *
   * @param {number} index Index for which to return the row data.
   * @param {Object=} options Options to control the at.
   * @return {Promise.<null|TableDataSource.RowData>} Promise resolves to a compound object which has the structure below. If the index is out of range, Promise resolves to null.<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>The raw row data</td></tr>
   * <tr><td><b>index</b></td><td>The index for the row</td></tr>
   * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
   * </tbody>
   * </table>
   * @method
   * @name at
   * @memberof TableDataSource
   * @instance
   */

  /**
   * Fetch the row data.
   * @param {Object=} options Options to control fetch
   * @property {number} [options.startIndex] The index at which to start fetching records.
   * @property {boolean} [options.silent] If set, do not fire a sync event.
   * @return {Promise.<null|TableDataSource.RowDatas>} Promise object resolves to a compound object which contains an array of row data objects, an array of ids, and the startIndex triggering done when complete.<p>
   *         The structure of the resolved compound object is:<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>startIndex</b></td><td>The startIndex for the returned set of rows</td></tr>
   * </tbody>
   * </table>
   * @method
   * @name fetch
   * @memberof TableDataSource
   * @instance
   */

  /**
   * Return the first row data whose id value is the given id
   * @param {string} id ID for which to return the row data, if found.
   * @param {Object=} options Options to control the get.
   * @return {Promise.<null|TableDataSource.RowData>} Promise which resolves to a compound object which has the structure below where the id matches the given id. If none are found, resolves to null.<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>The raw row data</td></tr>
   * <tr><td><b>index</b></td><td>The index for the row</td></tr>
   * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
   * </tbody>
   * </table>
   * @method
   * @name get
   * @memberof TableDataSource
   * @instance
   */

  /**
   * Determines whether this TableDataSource supports certain feature.
   * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
   * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".
   *         Returns null if the feature is not recognized.
   * @memberof TableDataSource
   * @instance
   * @method
   * @name getCapability
   */

  /**
   * Performs a sort on the data source. Null criteria clears the existing sort.
   * @param {Object} [criteria] the sort criteria.
   * @property {any} criteria.key The key that identifies which field to sort
   * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   * @return {Promise.<null>} promise object triggering done when complete.
   * @method
   * @name sort
   * @memberof TableDataSource
   * @instance
   */

  /**
   * Return the total size of data available, including server side if not local.
   * @returns {number} total size of data
   * @method
   * @name totalSize
   * @memberof TableDataSource
   * @instance
   */

  /**
   * Returns the confidence for the totalSize value.
   * @return {string} "actual" if the totalSize is the time of the fetch is an exact number
   *                  "estimate" if the totalSize is an estimate
   *                  "atLeast" if the totalSize is at least a certain number
   *                  "unknown" if the totalSize is unknown
   * @ojsignature {target: "Type", for: "returns", value: "'actual'|'estimate'|'atLeast'|'unknown'"}
   * @export
   * @expose
   * @memberof TableDataSource
   * @instance
   */
  TableDataSource.prototype.totalSizeConfidence = function () {
    return 'actual';
  };

  /**
   * Row Data returned by methods like, at/get.
   * @typedef {Object} TableDataSource.RowData
   * @property {Object} data The raw row data.
   * @property {number} index The index for the row.
   * @property {any} key The key value for the row.
   */

  /**
   * Row Datas returned by fetch method.
   * @typedef {Object} TableDataSource.RowDatas
   * @property {Array.<Object>} data An array of raw row data.
   * @property {Array.<any>} keys An array of key values for the rows.
   * @property {number} startIndex The startIndex for the returned set of rows.
   */

  /**
   * Events which are published by TableDataSource. Any custom TableDataSource
   * implementation must publish the corresponding events.
   * @export
   * Event types
   * @enum {string}
   * @memberof TableDataSource
   */
  TableDataSource.EventType = {
    /** Triggered when a Row has been added to a TableDataSource<p>
     * The event payload contains:<p>
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
     * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
     * <tr><td><b>indexes</b></td><td>An array of index values for the rows in post-insert sorted order</td></tr>
     * </tbody>
     * </table>
     */
    ADD: 'add',
    /** Triggered when a Row has been removed from a TableDataSource<p>
     * The event payload contains:<p>
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
     * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
     * <tr><td><b>indexes</b></td><td>An array of index values for the rows in pre-remove sorted order</td></tr>
     * </tbody>
     * </table>
     */
    REMOVE: 'remove',
    /** Triggered when a TableDataSource has been reset */
    RESET: 'reset',
    /** Triggered when a TableDataSource has been refreshed */
    REFRESH: 'refresh',
    /** Triggered when a TableDataSource has been sorted<p>
     * The event payload contains:<p>
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>header</b></td><td>the key of the header which was sorted on</td></tr>
     * <tr><td><b>direction</b></td><td>the direction of the sort ascending/descending</td></tr>
     * </tbody>
     * </table>
     */
    SORT: 'sort',
    /** Triggered when a Row's attributes have been changed<p>
     * The event payload contains:<p>
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
     * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
     * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
     * </tbody>
     * </table>
     */
    CHANGE: 'change',
    /** Triggered when a TableDataSource has sent a fetch request. It is expected that
     * a component using TableDataSource will go into a busy state upon receiving
     * this event.
     * The event payload contains:<p>
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>startIndex</b></td><td>The start index at which the fetch was invoked</td></tr>
     * </tbody>
     * </table>
     */
    REQUEST: 'request',
    /** Triggered when a TableDataSource has been updated by a fetch. It is expected that
     * a component using TableDataSource will exit busy state upon completion of rendering
     * after receiving this event.<p>
     * The event payload contains:<p>
     * <table cellspacing="0" style="border-collapse: collapse;">
     * <tbody>
     * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
     * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
     * <tr><td><b>startIndex</b></td><td>The start index at which the fetch occurred</td></tr>
     * </tbody>
     * </table>
     */
    SYNC: 'sync',
    /** Triggered when an error occurred on the TableDataSource */
    ERROR: 'error'
  };

  /**
   * @private
   */
  TableDataSource._LOGGER_MSG = {
    _ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY: 'oj.TableDataSource constructor called.',
    _ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL:
      'Please do not instantiate oj.TableDataSource. Please use one of the subclasses instead such as oj.ArrayTableDataSource or oj.CollectionTableDataSource.',
    _ERR_DATA_INVALID_TYPE_SUMMARY: 'Invalid data type.',
    _ERR_DATA_INVALID_TYPE_DETAIL: 'Please specify the appropriate data type.'
  };

  /**
   * @class TreeDataSource
   * @classdesc Abstract class representing hierarchical (tree) data that can be used by different components such as [Indexer]{@link oj.ojIndexer}, [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
   * and [TreeView]{@link oj.ojTreeView}.<br><br>
   * This class is not used directly and is used as the base to implement other subclasses.  Implementations of TreeDataSource must implement all of the methods documented here.<br><br>
   * JET provides the following implementations:<br><br>
   * <table class="generic-table">
   *   <thead>
   *     <th>Subclass</th>
   *     <th>When to Use</th>
   *     <th>Use with</th>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>{@link CollectionTreeDataSource}</td>
   *       <td>When the data is available from an {@link Collection} object, such as an external data source.</td>
   *       <td>ListView<br>NavigationList<br>TreeView<br></td>
   *     </tr>
   *     <tr>
   *       <td>{@link IndexerModelTreeDataSource}</td>
   *       <td>When the data has a tree-like structure that is displayed in a ListView with Indexer.</td>
   *       <td>ListView (with Indexer)<br></td>
   *     </tr>
   *     <tr>
   *       <td>{@link JsonTreeDataSource}</td>
   *       <td>When the data is available from an array of JSON objects that represent tree nodes.</td>
   *       <td>ListView<br>NavigationList<br>TreeView<br></td>
   *     </tr>
   *   </tbody>
   * </table>
   * <br>Refer to the documentation and demos of individual components for more information on how to use them with the TreeDataSource subclasses.</br><br>
   * In case specialized behavior is needed, new subclass can be created by using [oj.Object.createSubclass]{@link oj.Object.createSubclass}.  New subclass can be based on
   * TreeDataSource, in which case all methods must be implemented, or it can be based on an existing subclass, in which case only methods that require different behavior need
   * to be overridden.
   *
   * @param {Object} data data supported by the component
   * @export
   * @extends DataSource
   * @abstract
   * @constructor
   * @final
   * @since 1.0
   * @ojdeprecated {since: '6.0.0', description: 'Use TreeDataProvider instead.'}
   * @ojtsignore
   */

  const TreeDataSource = function (data) {
    TreeDataSource.superclass.constructor.call(this, data);
  };
  oj$2._registerLegacyNamespaceProp('TreeDataSource', TreeDataSource);
  /**
   * Subclass TreeDataSource to DataSource
   * @private
   */
  oj$2.Object.createSubclass(TreeDataSource, oj$2.DataSource, 'oj.TreeDataSource');

  /**
   * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
   * that the child count is unknown.
   * @param {any} parent the parent key.  Specify null if inquiring child count of the root.
   * @return {number} the number of children for the specified parent.
   * @method
   * @name getChildCount
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Fetch the children
   * @param {any} parent the parent key.  Specify null if fetching children from the root.
   * @param {Object} range information about the range, it must contain the following properties: start, count
   * @property {number} range.start the start index of the range in which the children are fetched
   * @property {number} range.count the size of the range in which the children are fetched
   * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
   *        types are "success" and "error"
   * @property {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
   * @property {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
   * @param {Object=} options optional parameters for this operation
   * @property {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain
   *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
   *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching
   * @return {void}
   * @method
   * @name fetchChildren
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Fetch all children and their children recursively from a specified parent.
   * @param {any} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
   * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
   *        types are "success" and "error"
   * @property {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
   * @property {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
   * @param {Object=} options optional parameters for this operation
   * @property {number=} options.start the index related to parent in which to begin fetching descendants from.  If this is not specified, then value zero will be used
   * @property {number=} options.maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
   *        there is no maximum fetch count
   * @return {void}
   * @method
   * @name fetchDescendants
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Performs a sort operation on the tree data.
   * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
   * @property {any} criteria.key the key identifying the attribute (column) to sort on
   * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   * @param {Object} callbacks callbacks for the sort operation
   * @property {function():void} callbacks.success the callback to invoke when the sort completed successfully
   * @property {function({status: *})=} callbacks.error the callback to invoke when sort failed.
   * @return {void}
   * @method
   * @name sort
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Returns the current sort criteria of the tree data.
   * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
   *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
   *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   * @ojsignature {target: "Type",
   *               value: "{key: any, direction: 'ascending'|'descending'|'none'}",
   *               for: "returns"}
   * @method
   * @name getSortCriteria
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Moves a row from one location to another (different position within the same parent or a completely different parent)
   * @param {any} rowToMove the key of the row to move
   * @param {any} referenceRow the key of the reference row which combined with position are used to determine
   *        the destination of where the row should moved to.
   * @param {number|string} position The position of the moved row relative to the reference row.
   *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position
   *        the element at a specific point among the reference row's current children.
   * @param {Object} callbacks the callbacks for the move function
   * @property {function():void} callbacks.success the callback to invoke when the move completed successfully
   * @property {function({status: *})=} callbacks.error the callback to invoke when move failed.
   * @return {void}
   * @method
   * @name move
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Checks whether a move operation is valid.
   * @param {any} rowToMove the key of the row to move
   * @param {any} referenceRow the key of the reference row which combined with position are used to determine
   *        the destination of where the row should moved to.
   * @param {number|string} position The position of the moved row relative to the reference row.
   *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position
   *        the element at a specific point among the reference row's current children.
   * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
   * @ojsignature {target: "Type",
   *               value: "'valid'|'invalid'",
   *               for: "returns"}
   * @method
   * @name moveOK
   * @memberof TreeDataSource
   * @instance
   */

  /**
   * Determines whether this TreeDataSource supports the specified feature.
   * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort",
   *        "move", "fetchDescendants", "batchFetch"
   * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
   *         For "sort", the valid return values are: "default", "none".
   *         For "fetchDescendants", the valid return values are: "enable", "disable", "suboptimal".
   *         For "move", the valid return values are: "default", "none".
   *         For "batchFetch", the valid return values are: "enable", "disable".
   * @method
   * @name getCapability
   * @memberof TreeDataSource
   * @instance
   */

  // Define a mapping variable that maps the return value of the module to the name used in the callback function of a require call.
  var DataSourceCommon = {};
  DataSourceCommon.DataGridDataSource = oj.DataGridDataSource;

  exports.DataGridDataSource = DataGridDataSource;
  exports.DataSource = DataSource;
  exports.DataSourceCommon = DataSourceCommon;
  exports.DiagramDataSource = DiagramDataSource;
  exports.TableDataSource = TableDataSource;
  exports.TreeDataSource = TreeDataSource;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojarraytabledatasource',['ojs/ojcore-base', 'jquery', 'ojs/ojlogger', 'ojs/ojtranslation', 'ojs/ojdatasource-common'], function (oj, $, Logger, Translations, ojdatasourceCommon) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * @export
   * @class ArrayTableDataSource
   * @since 1.0
   * @ojtsignore
   * @extends TableDataSource
   * @classdesc Object representing data available from an array.  This data source can be used by [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
   *            [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
   *            See the Table - Base Table demo for an example.<br><br>
   *            Refer to {@link TableDataSource} for other data sources that represent tabular data.
   * @param {Array|Object|function():Array} data data supported by the components
   *                                      <p>This can be either an Array, or a Knockout observableArray.</p>
   *                                      <p>Each array element should be an object representing one row of data, with the property names and values corresponding to column names and values.
   *                                         Array of primitive values such as ["Apple", "Orange"] is not currently supported.</p>
   * @param {Object|null} [options] Options for the TableDataSource
   * @param {string} [options.idAttribute] The column that contains the row key.
   *                 If this is not specified, all the values in a row are used as the key.
   * @param {"enabled"|"disabled"} [options.startFetch] Control whether to start initial fetch when the TableDataSource is bound to a component.  Valid values are:<br><br>
   *                                    <b>"enabled"</b> (default) - Start initial fetch automatically when the TableDataSource is bound to a component.<br>
   *                                    <b>"disabled"</b> - Do not start initial fetch automatically.  Application will call the <a href="#fetch">fetch()</a> method to
   *                                                        start the first fetch.
   * @ojdeprecated {since: '5.0.0', description: 'Use ArrayDataProvider instead.'}
   * @ojsignature {target: "Type",
   *               value: "KnockoutObservableArray<object>|Array<object>",
   *               for: "data"}
   * @constructor
   * @final
   * @ojtsignore
   * @example
   * // First initialize an array
   * var deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
   *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
   *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
   *
   * // Then create an ArrayTableDataSource object with the array
   * var dataSource = new ArrayTableDataSource(deptArray, {idAttribute: 'DepartmentId'});
   */
  const ArrayTableDataSource = function (data, options) {
    // Initialize
    this.data = data || {}; // This was put in to keep closure happy...
    if (!(data instanceof Array) && !this._isObservableArray(data)) {
      // we only support Array or ko.observableArray.
      var errSummary = ojdatasourceCommon.TableDataSource._LOGGER_MSG._ERR_DATA_INVALID_TYPE_SUMMARY;
      var errDetail = ojdatasourceCommon.TableDataSource._LOGGER_MSG._ERR_DATA_INVALID_TYPE_DETAIL;
      throw new Error(errSummary + '\n' + errDetail);
    }

    if (options == null || options.idAttribute == null) {
      Logger.info(ArrayTableDataSource._LOGGER_MSG._INFO_ARRAY_TABLE_DATASOURCE_IDATTR);
    }

    ArrayTableDataSource.superclass.constructor.call(this, data, options);

    this._eventHandlers = [];
    this._rows = {};

    if (data != null) {
      this._idAttribute = null;
      if (options != null && options.idAttribute != null) {
        this._idAttribute = options.idAttribute;
      }
    }

    if (
      (options != null && (options.startFetch === 'enabled' || options.startFetch == null)) ||
      options == null
    ) {
      this._startFetchEnabled = true;
    }
  };

  oj._registerLegacyNamespaceProp('ArrayTableDataSource', ArrayTableDataSource);
  // Subclass from oj.DataSource
  oj.Object.createSubclass(ArrayTableDataSource, ojdatasourceCommon.TableDataSource, 'ArrayTableDataSource');

  /**
   * @export
   * @desc If set to a function(row1, row2), then this function is called comparing raw row data (see the
   * JavaScript array.sort() for details)
   * @memberof ArrayTableDataSource
   * @type {null|string|Function}
   * @ojsignature {target: "Type",
   *               value: "null|string|((param0: object, param1?: object)=> number|string|object)"}
   */
  ArrayTableDataSource.prototype.comparator = null;

  /**
   * @export
   *
   * @type {Object}
   * @property {any} criteria.key The key that identifies which field to sort
   * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   *
   * @desc The sort criteria. Whenever sort() is called with the criteria parameter, that value is copied to this
   * property. If sort() is called with empty sort criteria then the criteria set in this property is used.
   * @memberof ArrayTableDataSource
   */
  ArrayTableDataSource.prototype.sortCriteria = null;

  /**
   * Initializes the instance.
   * @memberof ArrayTableDataSource
   * @instance
   * @override
   * @protected
   */
  ArrayTableDataSource.prototype.Init = function () {
    ArrayTableDataSource.superclass.Init.call(this);
  };

  /**
   * Add a row (or array of rows) to the end
   *
   * @param {Object|Array.<Object>} m Row object data (or array of rows) to add. These should be sets of attribute/values.
   * @param {Object=} options
   * @param {boolean} [options.silent] if set, do not fire an add event<p>
   * @param {number|Array.<number>} [options.at] splice the new row at the value given (at:index). If an array of rows then this should be an array of indexes <p>
   * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of keys, and an array of indexes which were added triggering done when complete.<p>
   *         The structure of the resolved compound object is:<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
   * </tbody>
   * </table>
   * @ojsignature {target:"Type",
   *               value: "Promise<null|ArrayTableDataSource.RowDatas>",
   *               for: "returns",
   *               jsdocOverride: true}
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.add = function (m, options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    this._checkDataLoaded();
    var index = options.at;

    return this._addToRowSet(m, index, options);
  };

  /**
   * Return the row data found at the given index.
   *
   * @param {number} index Index for which to return the row data.
   * @param {Object=} options Options to control the at.
   * @return {Promise} Promise resolves to a compound object which has the structure below. If the index is out of range, Promise resolves to null.<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>The raw row data</td></tr>
   * <tr><td><b>index</b></td><td>The index for the row</td></tr>
   * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
   * </tbody>
   * </table>
   * @ojsignature {target:"Type",
   *               value: "Promise<null|TableDataSource.RowData>",
   *               for: "returns",
   *               jsdocOverride: true}
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  // eslint-disable-next-line no-unused-vars
  ArrayTableDataSource.prototype.at = function (index, options) {
    this._checkDataLoaded();
    var row;

    if (index < 0 || index >= this._rows.data.length) {
      row = null;
    } else {
      row = { data: this._rows.data[index], index: index, key: this._getId(this._rows.data[index]) };
    }

    return new Promise(function (resolve) {
      resolve(row);
    });
  };

  /**
   * Change a row (or array of rows), if found.
   * @param {Object|Array.<Object>} m Row object data (or array of rows) to change. These should be sets of attribute/values.
   * @param {Object=} options
   * @param {boolean} [options.silent] if set, do not fire an add event<p>
   * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of keys, and an array of indexes which were changed triggering done when complete.<p>
   *          The structure of the resolved compound object is:<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
   * </tbody>
   * </table>
   * @ojsignature {target:"Type",
   *               value: "Promise<null|ArrayTableDataSource.RowDatas>",
   *               for: "returns",
   *               jsdocOverride: true}
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.change = function (m, options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    this._checkDataLoaded();
    var silent = options.silent;
    var rowArray = { data: [], keys: [], indexes: [] };

    if (!(m instanceof Array)) {
      // eslint-disable-next-line no-param-reassign
      m = [m];
    }

    for (var i = 0; i < m.length; i++) {
      var row = m[i];

      if (row != null) {
        var key = this._getId(row);
        var changedRow = this._getInternal(key, false);
        rowArray.data.push(this._wrapWritableValue(row));
        rowArray.keys.push(key);
        rowArray.indexes.push(changedRow.index);
        this._rows.data[changedRow.index] = row;
      }
    }

    if (!silent && rowArray.data.length > 0) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.CHANGE, rowArray);
    }

    return Promise.resolve(rowArray);
  };

  /**
   * Fetch the row data.
   * @param {Object=} options Options to control fetch
   * @param {number} [options.startIndex] The index at which to start fetching records.
   * @param {boolean} [options.silent] If set, do not fire a sync event.
   * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of ids, and the startIndex triggering done when complete.<p>
   *      The structure of the resolved compound object is:<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>startIndex</b></td><td>The startIndex for the returned set of rows</td></tr>
   * </tbody>
   * </table>
   * @ojsignature {target:"Type",
   *               value: "Promise<null|TableDataSource.RowDatas>",
   *               for: "returns",
   *               jsdocOverride: true}
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.fetch = function (options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    var fetchType = options.fetchType;

    if (fetchType === 'init' && !this._startFetchEnabled) {
      return Promise.resolve();
    }

    return this._fetchInternal(options);
  };

  /**
   * Return the first row data whose id value is the given id
   * @param {string} id ID for which to return the row data, if found.
   * @param {Object=} options Options to control the get.
   * @return {Promise} Promise which resolves to a compound object which has the structure below where the id matches the given id. If none are found, resolves to null.<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>The raw row data</td></tr>
   * <tr><td><b>index</b></td><td>The index for the row</td></tr>
   * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
   * </tbody>
   * </table>
   * @ojsignature {target:"Type",
   *               value: "Promise<null|TableDataSource.RowData>",
   *               for: "returns",
   *               jsdocOverride: true}
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  // eslint-disable-next-line no-unused-vars
  ArrayTableDataSource.prototype.get = function (id, options) {
    this._checkDataLoaded();
    return Promise.resolve(this._getInternal(id, true));
  };

  /**
   * Determines whether this TableDataSource supports certain feature.
   * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
   * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".
   *         Returns null if the feature is not recognized.
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  // eslint-disable-next-line no-unused-vars
  ArrayTableDataSource.prototype.getCapability = function (feature) {
    return 'full';
  };

  /**
   * Remove a row (or array of rows), if found.
   * @param {Object|Array.<Object>}  m Row object data (or array of rows) to remove. These should be sets of attribute/values.
   * @param {Object=} options
   * @param {boolean} [options.silent] if set, do not fire a remove event
   * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of keys, and an array of indexes which were removed triggering done when complete.<p>
   *      The structure of the resolved compound object is:<p>
   * <table>
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
   * </tbody>
   * </table>
   * @ojsignature {target:"Type",
   *               value: "Promise<null|ArrayTableDataSource.RowDatas>",
   *               for: "returns",
   *               jsdocOverride: true}
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.remove = function (m, options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    this._checkDataLoaded();
    return this._removeInternal(m, options);
  };

  /**
   * Remove and replace the entire list of rows with a new set of rows, if provided. Otherwise, empty the datasource. The next fetch
   * call will re-populate the datasource with the original array data. To empty out the data, call reset with an empty array.
   * @param {Array.<Object>=} data Array of row objects with which to replace the data.
   * @param {Object=} options user options, passed to event
   * @return {Promise.<void>} promise object triggering done when complete.
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.reset = function (data, options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    // eslint-disable-next-line no-param-reassign
    options.previousRows = this._rows;
    var silent = options.silent;

    if (data != null) {
      this.data = data;
    }
    this._rows = {};
    this._totalSize = 0;

    // clear any change subscription even if no new data is provided
    // a new subscription will be created on the next data fetch
    if (this._arrayChangeSubscription) {
      this._arrayChangeSubscription.dispose();
      this._arrayChangeSubscription = null;
    }

    if (!silent) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.RESET, null);
    }
    return Promise.resolve();
  };

  /**
   * Performs a sort on the data source.
   * @param {Object|null} [criteria] the sort criteria.
   * @param {any} criteria.key The key that identifies which field to sort
   * @param {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
   * @return {Promise.<null>} promise object triggering done when complete.
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.sort = function (criteria) {
    if (criteria == null) {
      // eslint-disable-next-line no-param-reassign
      criteria = this.sortCriteria;
    } else {
      this.sortCriteria = criteria;
    }
    // eslint-disable-next-line no-param-reassign
    criteria = criteria || {};

    this._checkDataLoaded();
    var self = this;
    return new Promise(function (resolve) {
      var comparator = self._getComparator();

      self._rows.data.sort(function (a, b) {
        return ArrayTableDataSource._sortFunc(a, b, comparator, self);
      });
      self._sorted = true;
      var result = { header: criteria.key, direction: criteria.direction };
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(self, ojdatasourceCommon.TableDataSource.EventType.SORT, result);
      resolve(result);
    });
  };

  /**
   * Return the total size of data available, including server side if not local.
   * @returns {number} total size of data
   * @export
   * @expose
   * @memberof ArrayTableDataSource
   * @instance
   */
  ArrayTableDataSource.prototype.totalSize = function () {
    this._checkDataLoaded();
    return this._totalSize;
  };

  ArrayTableDataSource.prototype._addToRowSet = function (m, index, options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    var silent = options.silent;
    var rowArray = { data: [], keys: [], indexes: [] };

    if (!(m instanceof Array)) {
      // eslint-disable-next-line no-param-reassign
      m = [m];
    }
    if (index != null && !(index instanceof Array)) {
      // eslint-disable-next-line no-param-reassign
      index = [index];
    }

    for (var i = 0; i < m.length; i++) {
      var row = m[i];

      if (row != null) {
        var key = this._getId(row);

        rowArray.data.push(this._wrapWritableValue(row));
        rowArray.keys.push(key);

        if (this._sorted === true && this._rows.data.length > 0) {
          var self = this;
          for (var j = 0; j < this._rows.data.length; j++) {
            if (
              ArrayTableDataSource._sortFunc(row, this._rows.data[j], self._getComparator(), self) < 0
            ) {
              this._rows.data.splice(j, 0, row);
              rowArray.indexes.push(j);
              break;
            } else if (j === this._rows.data.length - 1) {
              this._rows.data.push(row);
              rowArray.indexes.push(j + 1);
              break;
            }
          }
        } else if (index == null) {
          this._rows.data.push(row);
          rowArray.indexes.push(this._rows.data.length - 1);
        } else {
          this._rows.data.splice(index[i], 0, row);
          rowArray.indexes.push(index[i]);
        }
        this._totalSize += 1;
        this._realignRowIndices();
      }
    }

    if (!silent && rowArray.data.length > 0) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.ADD, rowArray);
    }

    return Promise.resolve(rowArray);
  };

  ArrayTableDataSource.prototype._checkDataLoaded = function () {
    if (!this._isDataLoaded()) {
      var dataArray = [];
      if (this.data instanceof Array) {
        dataArray = this.data;
      } else if (this._isObservableArray(this.data)) {
        dataArray = /** @type {Function} */ (this.data).peek();
        this._subscribeObservableArray(this.data);
      }
      this._rows = this._getRowArray(dataArray);
      this._totalSize = dataArray.length;
    }
  };

  ArrayTableDataSource.prototype._isDataLoaded = function () {
    if (this._rows == null || this._rows.data == null) {
      return false;
    }

    return true;
  };

  ArrayTableDataSource.prototype._fetchInternal = function (options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    this._startFetch(options);
    this._checkDataLoaded();
    var pageSize;
    var rowArray;
    var keyArray;
    var endIndex;
    try {
      pageSize = options.pageSize > 0 ? options.pageSize : -1;
      if (!this._startIndex) {
        this._startIndex = 0;
      }

      this._startIndex = options.startIndex == null ? this._startIndex : options.startIndex;
      endIndex = ArrayTableDataSource._getEndIndex(this._rows, this._startIndex, pageSize);
      rowArray = [];
      keyArray = [];

      for (var i = this._startIndex; i <= endIndex; i++) {
        var key = this._getId(this._rows.data[i]);
        var wrappedRow = this._wrapWritableValue(this._rows.data[i]);
        rowArray[i - this._startIndex] = wrappedRow;
        keyArray[i - this._startIndex] = key;
      }
    } catch (err) {
      this._endFetch(options, null, err);
      return Promise.reject(err);
    }

    if (endIndex < this._startIndex) {
      // this means we have no more rows at the startIndex. So adjust our
      // startIndex down to indicate the last row
      this._startIndex = endIndex + 1;
    }
    // eslint-disable-next-line no-param-reassign
    options.pageSize = pageSize;
    // eslint-disable-next-line no-param-reassign
    options.startIndex = this._startIndex;
    // eslint-disable-next-line no-param-reassign
    options.refresh = true;
    var result = { data: rowArray, keys: keyArray, startIndex: this._startIndex };
    this._endFetch(options, result, null);

    return Promise.resolve(result);
  };

  ArrayTableDataSource.prototype._getInternal = function (id, wrap) {
    var result = null;
    for (var i = 0; i < this._rows.data.length; i++) {
      var row = this._rows.data[i];
      var wrappedRow;

      if (row !== undefined) {
        var key = this._getId(row);
        if ($.isArray(key) && $.isArray(id)) {
          if (key.length === id.length) {
            var equal = true;
            for (var j = 0; j < id.length; j++) {
              if (key[j] !== id[j]) {
                equal = false;
                break;
              }
            }
            if (equal) {
              if (wrap) {
                wrappedRow = this._wrapWritableValue(row);
                result = { data: wrappedRow, key: key, index: this._rows.indexes[i] };
              } else {
                result = { data: row, key: key, index: this._rows.indexes[i] };
              }
              break;
            }
          }
        } else if (key === id) {
          if (wrap) {
            wrappedRow = this._wrapWritableValue(row);
            result = { data: wrappedRow, key: key, index: this._rows.indexes[i] };
          } else {
            result = { data: row, key: key, index: this._rows.indexes[i] };
          }
          break;
        }
      }
    }
    return result;
  };

  ArrayTableDataSource.prototype._getComparator = function () {
    var comparator = this.comparator;

    if (comparator == null) {
      var key = this.sortCriteria.key;
      var direction = this.sortCriteria.direction;

      if (direction === 'ascending') {
        comparator = function (row) {
          if ($.isFunction(row[key])) {
            return row[key]();
          }
          return row[key];
        };
      } else if (direction === 'descending') {
        comparator = function (rowA, rowB) {
          var a;
          var b;
          if ($.isFunction(rowA[key])) {
            a = rowA[key]();
            b = rowB[key]();
          } else {
            a = rowA[key];
            b = rowB[key];
          }

          if (a === b) {
            return 0;
          }
          return a > b ? -1 : 1;
        };
      }
    }
    return comparator;
  };

  // Realign all the indices of the rows (after sort for example)
  ArrayTableDataSource.prototype._realignRowIndices = function () {
    for (var i = 0; i < this._rows.data.length; i++) {
      this._rows.indexes[i] = i;
    }
  };

  ArrayTableDataSource.prototype._removeInternal = function (m, options) {
    var i;
    var self = this;
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    var silent = options.silent;
    var rowArray = { data: [], keys: [], indexes: [] };

    if (!(m instanceof Array)) {
      // eslint-disable-next-line no-param-reassign
      m = [m];
    }

    var sortedRowArray = [];
    for (i = 0; i < m.length; i++) {
      var row = m[i];

      if (row != null) {
        var key = this._getId(row);
        var deletedRow = this._getInternal(key, false);

        if (deletedRow != null) {
          sortedRowArray.push({
            data: deletedRow.data,
            key: deletedRow.key,
            index: deletedRow.index
          });
        }
      }
    }
    sortedRowArray.sort(function (a, b) {
      return a.index - b.index;
    });

    for (i = 0; i < sortedRowArray.length; i++) {
      rowArray.data.push(sortedRowArray[i].data);
      rowArray.keys.push(sortedRowArray[i].key);
      rowArray.indexes.push(sortedRowArray[i].index);
    }

    for (i = rowArray.indexes.length - 1; i >= 0; i--) {
      this._rows.data.splice(rowArray.indexes[i], 1);
      this._rows.indexes.splice(rowArray.indexes[i], 1);
      this._totalSize -= 1;
    }
    this._realignRowIndices();

    if (!silent && rowArray.data.length > 0) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(self, ojdatasourceCommon.TableDataSource.EventType.REMOVE, rowArray);
    }

    return Promise.resolve(rowArray);
  };

  ArrayTableDataSource.prototype._setRow = function (index, row) {
    this._rows[index] = row;
    // eslint-disable-next-line no-param-reassign
    row.index = index;
  };

  /**
   * Indicate starting fetch
   * @param {Object} options
   * @private
   * @memberof ArrayTableDataSource
   */
  ArrayTableDataSource.prototype._startFetch = function (options) {
    if (!options.silent) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.REQUEST, {
        startIndex: options.startIndex
      });
    }
  };

  /**
   * Indicate ending fetch
   * @param {Object} options
   * @param {Object} result Result object
   * @param {Object} error Error
   * @private
   * @memberof ArrayTableDataSource
   */
  ArrayTableDataSource.prototype._endFetch = function (options, result, error) {
    if (error != null) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.ERROR, error);
    } else if (!options.silent) {
      ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.SYNC, result);
    }
  };

  ArrayTableDataSource.prototype._handleRowChange = function (event) {
    // eslint-disable-next-line no-param-reassign
    event.startIndex = this._startIndex;
    ojdatasourceCommon.TableDataSource.superclass.handleEvent.call(this, ojdatasourceCommon.TableDataSource.EventType.CHANGE, event);
  };

  ArrayTableDataSource._compareKeys = function (keyA, keyB, direction) {
    if (direction === 'descending') {
      if (keyA < keyB) {
        return 1;
      }
      if (keyB < keyA) {
        return -1;
      }
    } else {
      if (keyA > keyB) {
        return 1;
      }
      if (keyB > keyA) {
        return -1;
      }
    }
    return 0;
  };

  ArrayTableDataSource._getEndIndex = function (rows, startIndex, pageSize) {
    var endIndex = rows.data.length - 1;

    if (pageSize > 0) {
      endIndex = startIndex + pageSize - 1;
      endIndex = endIndex > rows.data.length - 1 ? rows.data.length - 1 : endIndex;
    }

    return endIndex;
  };

  ArrayTableDataSource._getKey = function (val, attr) {
    if (typeof val[attr] === 'function') {
      return val[attr]();
    }
    return val[attr];
  };

  ArrayTableDataSource.prototype._getRowArray = function (values) {
    var endIndex = values.length - 1;

    var rowArray = { data: [], indexes: [] };
    this._attributes = null;

    for (var i = 0; i <= endIndex; i++) {
      var clonedRowValues = {};
      var rowValues = values[i];

      if (rowValues) {
        var props = Object.keys(rowValues);
        for (var j = 0; j < props.length; j++) {
          var prop = props[j];
          clonedRowValues[prop] = rowValues[prop];
          if (i === 0) {
            if (this._attributes == null) {
              this._attributes = [];
            }
            this._attributes.push(prop);
          }
        }
      } else {
        clonedRowValues = null;
      }
      rowArray.data[i] = clonedRowValues;
      rowArray.indexes[i] = i;
    }

    return rowArray;
  };

  ArrayTableDataSource.prototype._getId = function (row) {
    var id;
    var idAttribute = this._getIdAttr(row);
    var errDetail;

    if (row == null) {
      return null;
    }

    if ($.isArray(idAttribute)) {
      var i;
      id = [];
      for (i = 0; i < idAttribute.length; i++) {
        if (idAttribute[i] in row) {
          id[i] = ArrayTableDataSource._getKey(row, idAttribute[i]);
        } else {
          errDetail = Translations.applyParameters(
            ArrayTableDataSource._LOGGER_MSG._ERR_ARRAY_TABLE_DATASOURCE_IDATTR_NOT_IN_ROW,
            [idAttribute[i]]
          );
          throw new Error(errDetail);
        }
      }
    } else if (idAttribute in row) {
      id = ArrayTableDataSource._getKey(row, idAttribute);
    } else {
      errDetail = Translations.applyParameters(
        ArrayTableDataSource._LOGGER_MSG._ERR_ARRAY_TABLE_DATASOURCE_IDATTR_NOT_IN_ROW,
        [idAttribute]
      );
      throw new Error(errDetail);
    }

    return id;
  };

  ArrayTableDataSource.prototype._getIdAttr = function (row) {
    if (this._idAttribute != null) {
      return this._idAttribute;
    }

    if (this._attributes == null) {
      this._attributes = [];
      var props = Object.keys(row);
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        this._attributes.push(prop);
      }
    }

    if (Object.prototype.hasOwnProperty.call(this._attributes, 'id')) {
      return 'id';
    }

    return this._attributes;
  };

  ArrayTableDataSource._sortFunc = function (a, b, comparator, self) {
    var keyA;
    var keyB;
    var i;
    var retVal;
    var direction = self.sortCriteria.direction;

    if ($.isFunction(comparator)) {
      // How many args?
      if (comparator.length === 1) {
        // "sortBy" comparator option
        keyA = comparator.call(self, a);
        keyB = comparator.call(self, b);
        var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(',') : [keyA];
        var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(',') : [keyB];
        for (i = 0; i < attrs1.length; i++) {
          retVal = ArrayTableDataSource._compareKeys(attrs1[i], attrs2[i], direction);
          if (retVal !== 0) {
            return retVal;
          }
        }
        return 0;
      }
      // "sort" comparator option
      return comparator.call(self, a, b);
    }
    // String option
    if (oj.StringUtils.isString(comparator)) {
      var attrs = comparator.split(',');

      for (i = 0; i < attrs.length; i++) {
        keyA = ArrayTableDataSource._getKey(a, attrs[i]);
        keyB = ArrayTableDataSource._getKey(b, attrs[i]);
        retVal = ArrayTableDataSource._compareKeys(keyA, keyB, direction);
        if (retVal !== 0) {
          return retVal;
        }
      }
    }
    return 0;
  };

  ArrayTableDataSource.prototype._subscribeObservableArray = function (data) {
    if (!(data instanceof Array)) {
      var self = this;
      // subscribe to observableArray arrayChange event to get individual updates
      this._arrayChangeSubscription = /** @type {{subscribe: Function}} */ (data).subscribe(
        function (changes) {
          var updatedIndexes = [];
          var removeDuplicate = [];
          var i;
          var j;
          var index;
          var status;
          for (i = 0; i < changes.length; i++) {
            index = changes[i].index;
            status = changes[i].status;
            for (j = 0; j < changes.length; j++) {
              if (
                j !== i &&
                index === changes[j].index &&
                status !== changes[j].status &&
                updatedIndexes.indexOf(i) < 0 &&
                removeDuplicate.indexOf(i) < 0
              ) {
                if (status === 'deleted') {
                  removeDuplicate.push(i);
                  updatedIndexes.push(j);
                } else {
                  removeDuplicate.push(j);
                  updatedIndexes.push(i);
                }
              }
            }
          }
          var rowArray = [];
          for (i = 0; i < changes.length; i++) {
            if (updatedIndexes.indexOf(i) >= 0) {
              var key = self._getId(self._rows.data[changes[i].index]);
              var updatedKey = self._getId(changes[i].value);
              if (updatedKey != null && !oj.Object.compareValues(updatedKey, key)) {
                self._rows.data[changes[i].index] = changes[i].value;
              }
              rowArray.push(changes[i].value);
            }
          }
          self.change(rowArray, null);
          rowArray = [];
          var indexArray = [];
          for (i = 0; i < changes.length; i++) {
            if (
              updatedIndexes.indexOf(i) < 0 &&
              removeDuplicate.indexOf(i) < 0 &&
              changes[i].status === 'deleted'
            ) {
              rowArray.push(changes[i].value);
            }
          }
          self.remove(rowArray, null);

          rowArray = [];
          indexArray = [];
          for (i = 0; i < changes.length; i++) {
            if (
              updatedIndexes.indexOf(i) < 0 &&
              removeDuplicate.indexOf(i) < 0 &&
              changes[i].status === 'added'
            ) {
              rowArray.push(changes[i].value);
              indexArray.push(changes[i].index);
            }
          }
          self.add(rowArray, { at: indexArray });
        },
        null,
        'arrayChange'
      );
    }
  };

  ArrayTableDataSource.prototype._wrapWritableValue = function (m) {
    var returnObj = {};

    if (m) {
      var props = Object.keys(m);

      for (var i = 0; i < props.length; i++) {
        ArrayTableDataSource._defineProperty(returnObj, m, props[i]);
      }
    } else {
      return null;
    }

    return returnObj;
  };

  // To check for observableArray, we can't do instanceof check because it's
  // a function. So we just check if it contains a subscribe function.
  ArrayTableDataSource.prototype._isObservableArray = function (obj) {
    return typeof obj === 'function' && typeof obj.subscribe === 'function';
  };

  ArrayTableDataSource._defineProperty = function (row, m, prop) {
    Object.defineProperty(row, prop, {
      get: function () {
        return m[prop];
      },
      set: function (newValue) {
        // eslint-disable-next-line no-param-reassign
        m[prop] = newValue;
      },
      enumerable: true
    });
  };

  ArrayTableDataSource._LOGGER_MSG = {
    _INFO_ARRAY_TABLE_DATASOURCE_IDATTR:
      "idAttribute option has not been specified. Will default to using 'id' if the field exists. If not, will use all the fields.",
    _ERR_ARRAY_TABLE_DATASOURCE_IDATTR_NOT_IN_ROW:
      'Specified idAttribute {0} not in row data. Please ensure all specified idAttribute fields are in the row data or do not specify idAttribute and all fields will be used as id.'
  };

  /**
   * Shape of Data Info returned by methods like, add/change/remove.
   * @typedef {Object} ArrayTableDataSource.RowDatas
   * @property {Array.<Object>} data An array of raw row data.
   * @property {Array.<any>} keys An array of key values for the rows.
   * @property {Array.<number>} indexes An array of index values for the rows.
   */

});


define('ojs/ojeventtarget',['exports', 'ojs/ojcore-base'], function (exports, oj) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 11.0.0
     * @export
     * @class GenericEvent
     * @classdesc
     */

    /**
     *
     * @since 11.0.0
     * @export
     * @namespace EventTargetMixin
     * @classdesc Mixin class to provide generic implementation of addEventListener and removeEventListener
     * methods for the {@link DataGridProvider} interface.
     * <p>
     * This class cannot be instantiated.  You can only call the static applyMixin
     * method to add the implementation to another class.
     * </p>
     * @hideconstructor
     */

    /**
     * Apply this mixin to another class
     *
     * @since 11.0.0
     * @param {Function} derivedCtor the constructor of an existing class
     * @export
     * @expose
     * @memberof EventTargetMixin
     * @method
     * @name applyMixin
     * @return {void}
     * @ojtsexample <caption>Apply the mixin in Typescript:</caption>
     * class CustomDataGridProvider&lt;D> implements DataGridProvider&lt;D> {
     *   // Add a stand-in property to satisfy the compiler
     *   addEventListener: () => void;
     *   removeEventListener: () => void;
     *
     *   constructor() {
     *     // Constructor implementation
     *   }
     * }
     *
     * EventTargetMixin.applyMixin(CustomDataGridProvider);
     *
     * @ojtsexample <caption>Apply the mixin in Javascript:</caption>
     * function CustomDataGridProvider() {
     *   // Constructor implementation
     * }
     *
     * EventTargetMixin.applyMixin(CustomDataGridProvider);
     */

    // end of jsdoc

    class GenericEvent {
        constructor(type, options) {
            this.type = type;
            this.options = options;
            if (options != null) {
                this['detail'] = options['detail'];
            }
        }
    }
    oj._registerLegacyNamespaceProp('GenericEvent', GenericEvent);

    class EventTargetMixin {
        addEventListener(eventType, listener) {
            if (!this._eventListeners) {
                this._eventListeners = [];
            }
            this._eventListeners.push({
                type: eventType.toLowerCase(),
                listener: listener
            });
        }
        removeEventListener(eventType, listener) {
            if (this._eventListeners) {
                let i;
                for (i = this._eventListeners.length - 1; i >= 0; i--) {
                    if (this._eventListeners[i]['type'] == eventType &&
                        this._eventListeners[i]['listener'] == listener) {
                        this._eventListeners.splice(i, 1);
                    }
                }
            }
        }
        dispatchEvent(evt) {
            if (this._eventListeners) {
                var i, returnValue;
                //clone the eventListeners to isolate mutations that may occur during dispatching events
                var eventListeners = this._eventListeners.slice(0);
                for (i = 0; i < eventListeners.length; i++) {
                    var eventListener = eventListeners[i];
                    if (evt && evt.type && eventListener['type'] == evt.type.toLowerCase()) {
                        returnValue = eventListener['listener'].apply(this, [evt]);
                        if (returnValue === false) {
                            // event cancelled
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        static applyMixin(derivedCtor) {
            let baseCtors = [EventTargetMixin];
            baseCtors.forEach((baseCtor) => {
                Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
                    if (name !== 'constructor') {
                        derivedCtor.prototype[name] = baseCtor.prototype[name];
                    }
                });
            });
        }
    }
    oj._registerLegacyNamespaceProp('EventTargetMixin', EventTargetMixin);

    exports.EventTargetMixin = EventTargetMixin;
    exports.GenericEvent = GenericEvent;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdataprovider',['exports', 'ojs/ojcore-base', 'ojs/ojlogger', 'ojs/ojeventtarget'], function (exports, oj$1, Logger, ojeventtarget) { 'use strict';

    oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 4.2.0
     * @export
     * @interface DataProvider
     * @extends EventTarget
     * @ojsignature {target: "Type",
     *               value: "interface DataProvider<K, D> extends EventTarget",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
     * @classdesc
     * The DataProvider interface defines the contract by which JET components retrieve data.  By exposing this contract as an interface, we allow for a range of possible data retrieval strategies, while shielding components from dependencies on any one particular implementation choice.  For example, some DataProvider implementations may get data from a local array. Others may retrieve data from a remote endpoint.  In either case, the consuming component simply interacts with the DataProvider interface and is unaware of the of the specific data retrieval approach.
     * <p>
     * The DataProvider contract has the following characteristics:
     * <ul>
     *   <li>Asynchronous: Even in cases where data is available synchronously (eg. the data is already in a local array), the DataProvider contract provides access to the data via asynchronous APIs.  As such, consumers are able to interact with the data in a consistent manner, regardless of how the data is retrieved.</li>
     *   <li>Stateless: The DataProviders data retrieval APIs are inherently stateless.  Attempts to retrieve data are atomic and are not impacted by previous interactions with the DataProvider.  This avoids potential brittleness when multiple consumers are interacting with the same DataProvider instance.</li>
     *   <li>Key-based: In order to ensure reliable interactions with the data set, the DataProvider contract assumes that each data item can be accessed via a unique key.  While the index can be used as a key if no viable key is available, stable keys should be used whenever possible.</li>
     *   <li>Read only (with mutation notifications):  The base DataProvider contract does not include mutation APIs.  That is, the DataProvider contract defines APIs for reading data, not for writing data.  However, DataProvider implementations may expose their own type-specific mutation APIs, and the DataProvider contract defines an event-based mechanism for notifying consumers of data changes.</li>
     *   <li>Filterable:  When requesting data from a DataProvider, consumers are able to specify filter criteria that are used to restrict the data set to those items that match the specified criteria.</li>
     *   <li>Sortable:  When requesting data from a DataProvider, consumers are able to specify sort criteria that impact the ordering of the provided data.</li>
     * </ul>
     * <p>
     * The DataProvider contract exposes three ways for consumers to retrieve data:
     * <ul>
     *   <li>Iteration: the {@link DataProvider#fetchFirst} method returns an AsyncIterable that can be used to iterate over the entire data set.  Consumers typically use this when rendering a data set.</li>
     *   <li>By keys: the {@link DataProvider#fetchByKeys} method allows specific items to be retrieved by key.  Consumers typically use this when interacting with a subset of data (eg. for retrieving the values of the selected rows in a table component).</li>
     *   <li>By offset: the {@link DataProvider#fetchByOffset} method allows a specific block of data to be retrieved by specifying an offset and size. Consumers typically use this for paging purposes.</li>
     * </ul>
     * A related interface is {@link TreeDataProvider}, which extends DataProvider. TreeDataProviders represent hierarchical data, whereas (non-tree) DataProviders represent data sets that are single-level.
     * <p>
     * JET provides several out-of-the-box DataProvider implementations that support the most common use cases.
     * <br>
     * <h4 id="description:DataProviderImplementations" class="name">
     *   Implementations
     * </h4>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Class</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>
     *         {@link ArrayDataProvider}
     *       </td>
     *       <td>
     *         Basic DataProvider implementation that takes the data from a Javascript array or ko.observableArray.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link ArrayTreeDataProvider}
     *       </td>
     *       <td>
     *         Basic TreeDataProvider implementation that takes the data from a Javascript array or ko.observableArray that contains "children" property for subtree data.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link CollectionDataProvider}
     *       </td>
     *       <td>
     *         DataProvider implementation that takes the data from a {@link Collection} object. {@link Collection} is an older class that represents data usually comes from external source such as a REST.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link DeferredDataProvider}
     *       </td>
     *       <td>
     *         DataProvider implementation that takes the data from a promise that resolves to another DataProvider object.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link FlattenedTreeDataProviderView}
     *       </td>
     *       <td>
     *         DataProvider implementation that wraps a TreeDataProvider object and "flattens" the hierarchical data into a single level.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link IndexerModelTreeDataProvider}
     *       </td>
     *       <td>
     *         TreeDataProvider implementation that takes the data from a Javascript array that contains "children" property for subtree data. This class also implements the {@link oj.IndexerModel} interface.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link ListDataProviderView}
     *       </td>
     *       <td>
     *         DataProvider implementation that wraps another DataProvider, adding data manipulation functionality such as filtering, sorting and field mapping.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link PagingDataProviderView}
     *       </td>
     *       <td>
     *         DataProvider implementation that wraps another DataProvider object. This class also implements the {@link PagingModel} interface so that it can be used by components that support paging.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link RESTDataProvider}
     *       </td>
     *       <td>
     *         DataProvider implementation that fetches data from a JSON-based REST API.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link RESTTreeDataProvider}
     *       </td>
     *       <td>
     *         TreeDataProvider implementation that fetches hierarchical data from a JSON-based REST API.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>
     *         {@link TreeDataProviderView}
     *       </td>
     *       <td>
     *         TreeDataProvider implementation that wraps another TreeDataProvider object and exposes additional APIs. This class provides field mapping functionality for the wrapped TreeDataProvider.
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     * <h4 id="description:DataProviderClassHierarchy" class="name">
     *   Class Hierarchy
     * </h4>
     * <ul>
     *   <li><b>Interface {@link DataProvider}</b></li>
     *   <ul>
     *     <li>{@link ArrayDataProvider}</li>
     *     <li>{@link CollectionDataProvider}</li>
     *     <li>{@link DeferredDataProvider}</li>
     *     <li>{@link FlattenedTreeDataProviderView}</li>
     *     <li>{@link ListDataProviderView}</li>
     *     <li>{@link PagingDataProviderView}</li>
     *     <li>{@link RESTDataProvider}</li>
     *     <li><b>Interface {@link TreeDataProvider}</b></li>
     *       <ul>
     *         <li>{@link ArrayTreeDataProvider}</li>
     *         <li>{@link IndexerModelTreeDataProvider}</li>
     *         <li>{@link RESTTreeDataProvider}</li>
     *         <li>{@link TreeDataProviderView}</li>
     *       </ul>
     *     </li>
     *   </ul>
     * </ul>
     * </p><p>
     *
     * <h3 id="events-section">
     *   Events
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
     * </h3>
     * Implementations can fire the following events by creating an instance of the event class and passing the event payload in the constructor.
     * <h4 id="event:DataProviderMutationEvent" class="name">
     *   {@link DataProviderMutationEvent}
     * </h4>
     * This event is fired when items have been added or removed from the data.
     * <p>
     * Event payloads should implement the {@link DataProviderMutationEventDetail} interface.
     * </p><p>
     * Consumers can add an event listener for the "mutate" event type on the DataProvider object.
     * </p>
     * <i>Example of implementation firing a DataProviderMutationEvent for removed items:</i>
     * <pre class="prettyprint"><code>let removeDetail = {data: removedDataArray,
     *                     indexes: removedIndexArray,
     *                     keys: removedKeySet,
     *                     metadata: removedMetadataArray};
     * this.dispatchEvent(new DataProviderMutationEvent({remove: removeDetail}));
     * </code></pre>
     *
     * <i>Example of consumer listening for the "mutate" event type:</i>
     * <pre class="prettyprint"><code>let listener = function(event) {
     *   if (event.detail.remove) {
     *     let removeDetail = event.detail.remove;
     *     // Handle removed items
     *   }
     * };
     * dataProvider.addEventListener("mutate", listener);
     * </code></pre>
     * <h4 id="event:DataProviderRefreshEvent" class="name">
     *   {@link DataProviderRefreshEvent}
     * </h4>
     * This event is fired when the data has been refreshed and components need to re-fetch the data.
     * <p>
     * This event contains no additional event payload.
     * </p><p>
     * Consumers can add an event listener for the "refresh" event type on the DataProvider object.
     * </p>
     * <i>Example of consumer listening for the "refresh" event type:</i>
     * <pre class="prettyprint"><code>let listener = function(event) {
     * };
     * dataProvider.addEventListener("refresh", listener);
     * </code></pre>
     * <h3 id="custom-implementations-section">
     *   Custom Implementations
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#custom-implementations-section"></a>
     * </h3>
     * Applications can also create their own implementations of the DataProvider interface and use them with JET components.  For example, an application can create a DataProvider implementation
     * that fetches data from a REST endpoint.
     * </p><p>
     * Implementation classes must implement all of the interface methods.  It should also fire the DataProvider events when appropriate, so that JET components or other consumers can respond to data change accordingly.
     * </p>
     * <p>
     * A generic implementation of {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys} is available from {@link FetchByKeysMixin}
     * which can be used in custom implementations of DataProvider.
     * It is for convenience and may not provide the most efficient implementation for your data provider.
     * Classes that implement the DataProvider interface are encouraged to provide a more efficient implementation.
     * </p>
     * <p>
     * In order for JET components to work correctly, DataProvider implementations should ensure that:
     * <ul>
     *   <li>
     *     The iterator accounts for data mutations when returning the next block of data, and that no row is duplicated or skipped.
     *     For example, an offset-based implementation may need to adjust the offset from which the next block of data starts if rows
     *     have been added or removed in the returned data.
     *   </li>
     *   <li>
     *     JET components may call "next" on the iterator even after the iterator has returned done:true.  If new data is available after
     *     the last returned row, the iterator is expected to return the new data and set "done" to false.
     *     This differs from the AsyncIterator spec for performance reasons.
     *   </li>
     * </ul>
     * </p>
     * <p>Assuming that a DataProvider has returned rows indexed 0 to 9. Normally it should start the next block at index 10. Now consider
     *    the following distinct mutation cases:</p>
     * <ul>
     *   <li>If a row is added at index 5, the DataProvider should fire a "mutate" event with the added row, and starts the
     *       next block at index 11.</li>
     *   <li>On the other hand, if a row is removed at index 5, the DataProvider should fire a "mutate" event with the removed row, and starts the
     *       next block at index 9.</li>
     * </ul>
     * <i>Example of adjusting the offset upon mutations for a DataProvider implementation that keeps track of its own offset.
     * This is just an illustration of what some implementations might do. The necessary adjustment is highly dependent of the
     * individual implementation.
     * </i>
     * <pre class="prettyprint"><code>
     * // offset is the current offset to start the next fetch
     * // removeIndexes is an array of indexes for removed items relative to the original dataset
     * // addIndexes is an array of indexes for added items relative to the dataset after the mutations
     * function getNewOffset(offset, removeIndexes, addIndexes) {
     *   let removeCount = 0;
     *
     *   if (removeIndexes) {
     *     removeIndexes.forEach(function (index) {
     *       // only count the changes below the last offset
     *       if (index < offset) {
     *         ++removeCount;
     *       }
     *     });
     *   }
     *
     *   offset -= removeCount;
     *   if (addIndexes) {
     *     addIndexes.forEach(function (index) {
     *       // only count the changes below the last offset
     *       if (index < offset) {
     *         ++offset;
     *       }
     *     });
     *   }
     *
     *   return offset;
     * }
     * </code></pre>
     */
    oj.DataProvider = function () {};

    /**
     * Get an AsyncIterable object for iterating the data. Iterating data on this AsyncIterable object can be
     * aborted if an AbortSignal is specified when getting this AsyncIterable object.
     * <p>
     * AsyncIterable contains a Symbol.asyncIterator method that returns an AsyncIterator.
     * AsyncIterator contains a next method for fetching the next block of data.
     * </p><p>
     * The "next" method returns a promise that resolves to an object, which contains a "value" property for the data and a "done" property
     * that is set to true when there is no more data to be fetched.  The "done" property should be set to true only if there is no "value"
     * in the result.  Note that "done" only reflects whether the iterator is done at the time "next" is called.  Future calls to "next"
     * may or may not return more rows for a mutable data source.
     * </p><p>
     * In order for JET components to work correctly, DataProvider implementations should ensure that:
     * </p>
     * <ul>
     *   <li>
     *     The iterator accounts for data mutations when returning the next block of data, and that no row is duplicated or skipped.
     *     For example, an offset-based implementation may need to adjust the offset from which the next block of data starts if rows
     *     have been added or removed in the returned data.
     *   </li>
     *   <li>
     *     JET components may call "next" on the iterator even after the iterator has returned done:true.  If new data is available after
     *     the last returned row, the iterator is expected to return the new data and set "done" to false.
     *     This differs from the AsyncIterator spec for performance reasons.
     *   </li>
     * </ul>
     * <p>
     * Please see the <a href="DataProvider.html#custom-implementations-section">DataProvider documentation</a> for
     * more information on custom implementations.
     * </p>
     *
     * @since 4.2.0
     * @param {FetchListParameters=} params fetch parameters. If an unsupported matchBy value is included in FetchListParameters, an error will be thrown.
     * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
     * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name fetchFirst
     * @ojsignature {target: "Type",
     *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
     * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
     * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
     * let result = await asyncIterator.next();
     * let value = result.value;
     * let data = value.data;
     * let keys = value.metadata.map(function(val) {
     *   return val.key;
     * });
     * // true or false for done
     * let done = result.done;
     * @ojtsexample <caption>How to abort fetchFirst</caption>
     * // abort on an AbortController instance will abort all requests that are associated
     * // with the signal from that abortController.
     * const abortController = new AbortController();
     * // component passes AbortSignal as part of FetchListParameters to fetchFirst
     * // on dataProvider to get an iterator that carries AbortSignal in it.
     * const asyncIterator = dataprovider
     *        .fetchFirst({
     *           size: this.size,
     *           signal: abortController.signal,
     *            ...
     *         })[Symbol.asyncIterator]();
     * try {
     *  const result = await asyncIterator.next();
     * } catch (err) {
     *  // if the data fetch has been aborted, retrieving data from the fetched result
     *  // will be rejected with DOMException named AbortError
     *  if (err.severity === 'info') {
     *    // if the data fetch has been aborted from a jet component as a performance concern, an <u><a href="AbortReason.html">AbortReason</a></u> will be provided.
     *    console.log(err.message);
     *  }
     * }
     * // later when abort is desired, component can invoke abort() on the cached
     * // abort controller to abort any outstanding data retrieval it requested
     * // on asyncIterator.
     * if (abort_is_desired) {
     *   abortController.abort();
     * }
     */

    /**
     * Determines whether this DataProvider defines a certain feature.
     *
     *
     * @since 4.2.0
     * @param {string} capabilityName capability name. Defined capability names are:
     *                  "dedup", "eventFiltering", "fetchByKeys", "fetchByOffset", "fetchCapability", "fetchFirst", "filter", "sort" and "key".
     * @return {Object} capability information or null if undefined
     * <ul>
     *   <li>If capabilityName is "dedup", returns a {@link DedupCapability} object.</li>
     *   <li>If capabilityName is "eventFiltering", returns a {@link EventFilteringCapability} object.</li>
     *   <li>If capabilityName is "fetchByKeys", returns a {@link FetchByKeysCapability} object.</li>
     *   <li>If capabilityName is "fetchByOffset", returns a {@link FetchByOffsetCapability} object.</li>
     *   <li>If capabilityName is "fetchCapability", returns a {@link FetchCapability} object.
     *       <b>(Deprecated since 10.0.0. Use specific fetch capabilityName (fetchByKeys/fetchByOffset/fetchFirst) instead.)</b></li>
     *   <li>If capabilityName is "fetchFirst", returns a {@link FetchFirstCapability} object.</li>
     *   <li>If capabilityName is "filter", returns a {@link FilterCapability} object.</li>
     *   <li>If capabilityName is "sort", returns a {@link SortCapability} object.</li>
     *   <li>If capabilityName is "key", returns a {@link KeyCapability} object.</li>
     * </ul>
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name getCapability
     * @ojsignature {target: "Type",
     *               value: "(capabilityName: string): any"}
     * @ojtsexample <caption>Check what kind of fetchByKeys is defined.</caption>
     * let capabilityInfo = dataprovider.getCapability('fetchByKeys');
     * if (capabilityInfo.implementation == 'iteration') {
     *   // the DataProvider supports iteration for fetchByKeys
     *   ...
     */

    /**
     * Return the total number of rows in this dataprovider
     *
     *
     * @return {Promise.<number>} Returns a Promise which resolves to the total number of rows. -1 is unknown row count.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name getTotalSize
     * @ojtsexample <caption>Get the total rows</caption>
     * let value = await dataprovider.getTotalSize();
     * if (value === -1) {
     *   // we don't know the total row count
     * } else {
     *   // the total count
     *   console.log(value);
     * }
     */

    /**
     * Fetch rows by keys. The resulting key map will only contain keys which were actually found. Fetch can be
     * aborted if an AbortSignal is specified when calling fetchByKeys.
     *
     *
     * @since 4.2.0
     * @param {FetchByKeysParameters} parameters fetch by key parameters
     * @return {Promise.<FetchByKeysResults>} Returns Promise which resolves to {@link FetchByKeysResults}.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name fetchByKeys
     * @ojsignature {target: "Type",
     *               value: "(parameters : FetchByKeysParameters<K>) : Promise<FetchByKeysResults<K, D>>"}
     * @ojtsexample <caption>Fetch for keys 1001 and 556</caption>
     * let keySet = new Set();
     * keySet.add(1001);
     * keySet.add(556);
     *
     * let value = await dataprovider.fetchByKeys({keys: keySet});
     * // get the data for key 1001
     * console.log(value.results.get(1001).data);
     * @ojtsexample <caption>How to abort fetchByKeys</caption>
     * // abort on an AbortController instance will abort all requests that are associated
     * // with the signal from that abortController.
     * const abortController = new AbortController();
     * let keySet = new Set();
     * keySet.add(1001);
     * keySet.add(556);
     * // component passes AbortSignal as part of FetchByKeysParameters to fetchByKeys
     * // on dataProvider
     * try {
     *  let value = await dataprovider.fetchByKeys({keys: keySet, signal: abortController.signal});
     * } catch (err) {
     *  // if the data fetch has been aborted, retrieving data from the fetched result
     *  // will be rejected with DOMException named AbortError
     *  if (err.severity === 'info') {
     *    // if the data fetch has been aborted from a jet component as a performance concern, an <u><a href="AbortReason.html">AbortReason</a></u> will be provided.
     *    console.log(err.message);
     *  }
     * }
     * // later when abort is desired, component can invoke abort() on the cached
     * // abort controller to abort any outstanding data retrieval it requested
     * // on asyncIterator.
     * if (abort_is_desired) {
     *   abortController.abort();
     * }
     */

    /**
     * Check if there are rows containing the specified keys. The resulting key map will only contain keys which were actually found.
     *
     *
     * @since 4.2.0
     * @param {FetchByKeysParameters} parameters contains by key parameters
     * @return {Promise.<ContainsKeysResults>} Returns Promise which resolves to {@link ContainsKeysResults}.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name containsKeys
     * @ojsignature {target: "Type",
     *               value: "(parameters : FetchByKeysParameters<K>) : Promise<ContainsKeysResults<K>>"}
     * @ojtsexample <caption>Check if keys 1001 and 556 are contained</caption>
     * let keySet = new Set();
     * keySet.add(1001);
     * keySet.add(556);
     *
     * let value = await dataprovider.containsKeys({keys: keySet});
     * let results = value['results'];
     * if (results.has(1001)) {
     *   console.log('Has key 1001');
     * } else if (results.has(556)) {
     *   console.log('Has key 556');
     * }
     */

    /**
     * Fetch rows by offset. Fetch can be aborted if an AbortSignal is specified when calling fetchByOffset.
     * <p>
     * A generic implementation of this method is available from {@link FetchByOffsetMixin}.
     * It is for convenience and may not provide the most efficient implementation for your data provider.
     * Classes that implement the DataProvider interface are encouraged to provide a more efficient implementation.
     * </p>
     *
     *
     * @since 4.2.0
     * @param {FetchByOffsetParameters} parameters fetch by offset parameters. If an unsupported matchBy value is included in FetchByOffsetParameters, an error will be thrown.
     * @return {Promise.<FetchByOffsetResults>} Returns Promise which resolves to {@link FetchByOffsetResults}.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name fetchByOffset
     * @ojsignature {target: "Type",
     *               value: "(parameters: FetchByOffsetParameters<D>): Promise<FetchByOffsetResults<K, D>>"}
     * @ojtsexample <caption>Fetch by offset 5 rows starting at index 2</caption>
     * let result = await dataprovider.fetchByOffset({size: 5, offset: 2});
     * let results = result['results'];
     * let data = results.map(function(value) {
     *   return value['data'];
     * });
     * let keys = results.map(function(value) {
     *   return value['metadata']['key'];
     * });
     * @ojtsexample <caption>How to abort fetchByOffset</caption>
     * // abort on an AbortController instance will abort all requests that are associated
     * // with the signal from that abortController.
     * const abortController = new AbortController();
     * // component passes AbortSignal as part of FetchByOffsetParameters to fetchByOffset
     * // on dataProvider
     * try {
     *  let value = await dataprovider.fetchByOffset({
     *                  size: 5,
     *                  offset: 2,
     *                  signal: abortController.signal
     *              });
     * } catch (err) {
     *  // if the data fetch has been aborted, retrieving data from the fetched result
     *  // will be rejected with DOMException named AbortError
     *  if (err.severity === 'info') {
     *    // if the data fetch has been aborted from a jet component as a performance concern, an <u><a href="AbortReason.html">AbortReason</a></u> will be provided.
     *    console.log(err.message);
     *  }
     * }
     * // later when abort is desired, component can invoke abort() on the cached
     * // abort controller to abort any outstanding data retrieval it requested
     * // on asyncIterator.
     * if (abort_is_desired) {
     *   abortController.abort();
     * }
     */

    /**
     * Returns a string that indicates if this data provider is empty.  Valid values are:
     * <ul>
     * <li>"yes": this data provider is empty.</li>
     * <li>"no": this data provider is not empty.</li>
     * <li>"unknown": it is not known if this data provider is empty until a fetch is made.</li>
     * </ul>
     *
     *
     * @since 4.2.0
     * @return {"yes" | "no" | "unknown"} string that indicates if this data provider is empty
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name isEmpty
     * @ojsignature {target: "Type",
     *               value: "(): 'yes' | 'no' | 'unknown'"}
     * @ojtsexample <caption>Check if empty</caption>
     * let isEmpty = dataprovider.isEmpty();
     * console.log('DataProvider is empty: ' + isEmpty);
     */

    /**
     * Return an empty Set which is optimized to store keys
     * <p>
     * Optionally provided by certain DataProvider implementations for storing
     * keys from the DataProvider in a performant fashion. Sometimes components will
     * need to temporarily store a Set of keys provided by the DataProvider, for
     * example, in the case of maintaining a Set of selected keys. Only the DataProvider
     * is aware of the internal structure of keys such as whether they are primitives, Strings,
     * or objects and how to do identity comparisons. Therefore, the DataProvider can optionally
     * provide a Set implementation which can performantly store keys surfaced by the
     * DataProvider.
     * </p>
     *
     *
     * @since 6.2.0
     * @param {Set.<any>=} initialSet Optionally specify an initial set of keys for the Set. If not specified, then return an empty Set.
     * @return {Set.<any>} Returns a Set optimized for handling keys from the DataProvider.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     * @ojsignature {target: "Type",
     *               value: "?(initialSet?: Set<K>): Set<K>"}
     * @ojtsexample <caption>create empty key Set</caption>
     * // create optional initial parameter
     * let initSet = new Set();
     * initSet.add('a');
     * let keySet = dataprovider.createOptimizedKeySet(initSet);
     */

    /**
     * Return an empty Map which is optimized to store key value pairs
     * <p>
     * Optionally provided by certain DataProvider implementations for storing
     * key/value pairs from the DataProvider in a performant fashion. Sometimes components will
     * need to temporarily store a Map of keys provided by the DataProvider, for
     * example, in the case of maintaining a Map of selected keys. Only the DataProvider
     * is aware of the internal structure of keys such as whether they are primitives, Strings,
     * or objects and how to do identity comparisons. Therefore, the DataProvider can optionally
     * provide a Map implementation which can performantly store key/value pairs surfaced by the
     * DataProvider.
     * </p>
     *
     *
     * @since 6.2.0
     * @param {Map.<any>=} initialMap Optionally specify an initial map of key/values for the Map. If not specified, then return an empty Map.
     * @return {Map.<any>} Returns a Map optimized for handling keys from the DataProvider.
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     * @ojsignature {target: "Type",
     *               value: "?(initialMap?: Map<K, D>): Map<K, D>"}
     * @ojtsexample <caption>create empty key Map</caption>
     * // create optional parameter
     * let initMap = new Map();
     * initMap.set('a', 'apple');
     * let keyMap = dataprovider.createOptimizedKeyMap(initMap);
     */

    /**
     * Add a callback function to listen for a specific event type.
     *
     *
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name addEventListener
     * @param {string} eventType The event type to listen for.
     * @param {EventListener} listener The callback function that receives the event notification.
     * @ojsignature {target: "Type",
     *               value: "(eventType: string, listener: EventListener): void"}
     */

    /**
     * Remove a listener previously registered with addEventListener.
     *
     *
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name removeEventListener
     * @param {string} eventType The event type that the listener was registered for.
     * @param {EventListener} listener The callback function that was registered.
     * @ojsignature {target: "Type",
     *               value: "(eventType: string, listener: EventListener): void"}
     */

    /**
     * Dispatch an event and invoke any registered listeners.
     *
     *
     * @export
     * @expose
     * @memberof DataProvider
     * @instance
     * @method
     * @name dispatchEvent
     * @param {Event} event The event object to dispatch.
     * @return {boolean} Return false if a registered listener has cancelled the event. Return true otherwise.
     * @ojsignature {target: "Type",
     *               value: "(evt: Event): boolean"}
     */

    // end of jsdoc

    (function (AttributeFilterOperator) {
        let AttributeOperator;
        (function (AttributeOperator) {
            AttributeOperator["$co"] = "$co";
            AttributeOperator["$eq"] = "$eq";
            AttributeOperator["$ew"] = "$ew";
            AttributeOperator["$pr"] = "$pr";
            AttributeOperator["$gt"] = "$gt";
            AttributeOperator["$ge"] = "$ge";
            AttributeOperator["$lt"] = "$lt";
            AttributeOperator["$le"] = "$le";
            AttributeOperator["$ne"] = "$ne";
            AttributeOperator["$regex"] = "$regex";
            AttributeOperator["$sw"] = "$sw";
        })(AttributeOperator = AttributeFilterOperator.AttributeOperator || (AttributeFilterOperator.AttributeOperator = {}));
    })(exports.AttributeFilterOperator || (exports.AttributeFilterOperator = {}));
    oj$1._registerLegacyNamespaceProp('AttributeFilterOperator', exports.AttributeFilterOperator);

    (function (CompoundFilterOperator) {
        let CompoundOperator;
        (function (CompoundOperator) {
            CompoundOperator["$and"] = "$and";
            CompoundOperator["$or"] = "$or";
        })(CompoundOperator = CompoundFilterOperator.CompoundOperator || (CompoundFilterOperator.CompoundOperator = {}));
    })(exports.CompoundFilterOperator || (exports.CompoundFilterOperator = {}));
    oj$1._registerLegacyNamespaceProp('CompoundFilterOperator', exports.CompoundFilterOperator);

    (function (DataProviderUtils) {
        DataProviderUtils.WARN_DUPLICATE_KEYS_DETAIL = 'Duplicate keys detected. Though this can occur due to race conditions, it is likely an indication that the underlying data set contains non-unique keys.';
        /**
         * Returns the resulting array of keys from the handling of an add event.
         * @param {Array} initialKeys
         * @param {Object} addEventDetail
         * @param {boolean} isLoadAll
         */
        function getAddEventKeysResult(initialKeys, addEventDetail, isLoadAll) {
            var i;
            var beforeKey;
            var eventKey;
            var eventIndex;
            var beforeIndex;
            // returns an object that stores the required insertion information for a given key
            function _createAddItem(itemKey, itemIndex) {
                return { key: itemKey, index: itemIndex };
            }
            var returnKeys = initialKeys.slice();
            var eventKeys = [];
            addEventDetail.keys.forEach(function (key) {
                eventKeys.push(key);
            });
            var eventBeforeKeys = [];
            // afterKeys is deprecated, but continue to support it until we can remove it.
            // forEach can be called on both array and set.
            var beforeKeyIter = addEventDetail.addBeforeKeys
                ? addEventDetail.addBeforeKeys
                : addEventDetail.afterKeys;
            if (beforeKeyIter != null) {
                beforeKeyIter.forEach(function (key) {
                    eventBeforeKeys.push(key);
                });
            }
            var foundDuplicate = false;
            var eventIndexes = addEventDetail.indexes;
            // if beforeKeys are specified, they take precedence over index values.
            if (eventBeforeKeys.length === eventKeys.length) {
                // loop through the beforeKeys, and perform insertions as we find them.
                // some beforeKeys may be in our list of keys to add, so we need to continuously loop through our adds until no insertions are made.
                // at that point, any left over rows are out of our rendered viewport, and we can safely ignore them in not isLoadAll.
                var leftOverLength = 0;
                var requiresAdditionalLooping = true;
                while (requiresAdditionalLooping) {
                    while (eventKeys.length !== leftOverLength) {
                        leftOverLength = eventKeys.length;
                        // loop through in reverse order as most DP impls have an increasing global index order in their events.
                        for (i = eventKeys.length - 1; i >= 0; i--) {
                            eventKey = eventKeys[i];
                            // ensure the key does not already exist in the data set.
                            if (!containsKey(returnKeys, eventKey)) {
                                beforeKey = eventBeforeKeys[i];
                                if (beforeKey != null) {
                                    beforeIndex = _indexOfKey(returnKeys, beforeKey);
                                    if (beforeIndex !== -1) {
                                        returnKeys.splice(beforeIndex, 0, eventKey);
                                        eventBeforeKeys.splice(i, 1);
                                        eventKeys.splice(i, 1);
                                    }
                                }
                                else if (isLoadAll) {
                                    // null beforeKey is at the end of the data set, only add if isLoadAll
                                    returnKeys.push(eventKey);
                                    eventBeforeKeys.splice(i, 1);
                                    eventKeys.splice(i, 1);
                                }
                            }
                            else {
                                // if duplicate key detected, just remove that key from the set to be added
                                eventBeforeKeys.splice(i, 1);
                                eventKeys.splice(i, 1);
                                foundDuplicate = true;
                            }
                        }
                    }
                    // if before keys were not continuous, just do our best to add the remaining ones at the end when isLoadAll
                    if (isLoadAll && eventKeys.length !== 0) {
                        Logger.error('Invalid "beforeKey" value detected in "add" event.');
                        returnKeys.push(eventKeys[0]);
                        eventBeforeKeys.splice(0, 1);
                        eventKeys.splice(0, 1);
                        requiresAdditionalLooping = eventKeys.length !== 0;
                    }
                    else {
                        requiresAdditionalLooping = false;
                    }
                }
            }
            else if (eventIndexes != null && eventIndexes.length === eventKeys.length) {
                // if beforeKeys are not specified, we need to rely on the index values.
                // in order to be safely added, we need to ensure they are ordered in ascending order
                var indexItems = [];
                for (i = 0; i < eventKeys.length; i++) {
                    eventKey = eventKeys[i];
                    // ensure the key does not already exist in the data set
                    if (!containsKey(returnKeys, eventKey)) {
                        eventIndex = eventIndexes[i];
                        if (eventIndex != null) {
                            var added = false;
                            for (var j = 0; j < indexItems.length; j++) {
                                // this is the absolute event index once all updates are made - store it (sorted low to high) and add after
                                if (indexItems[j].index > eventIndex) {
                                    indexItems.splice(j, 0, _createAddItem(eventKey, eventIndex));
                                    added = true;
                                    break;
                                }
                            }
                            if (!added) {
                                indexItems.push(_createAddItem(eventKey, eventIndex));
                            }
                        }
                        else if (isLoadAll) {
                            // null index is at the end of the data set, only add if isLoadAll
                            returnKeys.push(eventKey);
                        }
                    }
                    else {
                        foundDuplicate = true;
                    }
                }
                // add the sorted items by index to ensure final index values are correct
                for (i = 0; i < indexItems.length; i++) {
                    var indexItem = indexItems[i];
                    if (indexItem.index < returnKeys.length) {
                        returnKeys.splice(indexItem.index, 0, indexItem.key);
                    }
                    else if (isLoadAll) {
                        if (indexItem.index !== returnKeys.length) {
                            // log error if index values are not correct
                            Logger.error('Invalid "index" value detected in "add" event.');
                        }
                        // add remaining rows to the end when isLoadAll
                        returnKeys.push(indexItem.key);
                    }
                }
            }
            else if (isLoadAll) {
                // if neither beforeKeys nor indexes are specified, just add all keys to the end in the current order
                eventKeys.forEach(function (key) {
                    returnKeys.push(key);
                });
            }
            if (foundDuplicate) {
                Logger.warn(DataProviderUtils.WARN_DUPLICATE_KEYS_DETAIL);
            }
            // return updated keys since any remaining beforeKey rows and index rows are not connected to the viewport
            return returnKeys;
        }
        DataProviderUtils.getAddEventKeysResult = getAddEventKeysResult;
        function doesAttributeExistInFilterCriterion(attributeName, filterCriterion) {
            // handle text filter
            if (filterCriterion.text) {
                return true;
            }
            // handle Nested Filter
            if (filterCriterion.attribute && filterCriterion.op && filterCriterion.op === '$exists') {
                if (this.doesAttributeExistInFilterCriterion(attributeName, filterCriterion.criterion)) {
                    return true;
                }
            }
            // handle AttributeExpression filter
            else if (filterCriterion.attribute) {
                if (filterCriterion.attribute === '*') {
                    return true;
                }
                else if (filterCriterion.attribute === attributeName) {
                    return true;
                }
            }
            // handle Attribute filter
            // eslint-disable-next-line no-prototype-builtins
            else if (filterCriterion.value && filterCriterion.value.hasOwnProperty(attributeName)) {
                return true;
            }
            // handle Compound Filter
            else if (filterCriterion.criteria && filterCriterion.criteria.length > 0) {
                for (let i = 0; i < filterCriterion.criteria.length; i++) {
                    if (this.doesAttributeExistInFilterCriterion(attributeName, filterCriterion.criteria[i])) {
                        return true;
                    }
                }
            }
            return false;
        }
        DataProviderUtils.doesAttributeExistInFilterCriterion = doesAttributeExistInFilterCriterion;
        /**
         * @private
         */
        function containsKey(array, key) {
            for (var i = 0; i < array.length; i++) {
                if (oj$1.KeyUtils.equals(array[i], key)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * @private
         */
        function _indexOfKey(array, key) {
            for (var i = 0; i < array.length; i++) {
                if (oj$1.KeyUtils.equals(array[i], key)) {
                    return i;
                }
            }
            return -1;
        }
    })(exports.DataProviderUtils || (exports.DataProviderUtils = {}));

    /**
     * @ignore
     * @namespace SortUtils
     */
    (function (SortUtils) {
        /**
         * Helper function that returns a comparator which does natural sort
         * @method
         * @name getNaturalSortCriteriaComparator
         * @memberof! SortUtils
         * @static
         * @param {Array<SortCriterion>} sortCriteria The sortCriterion for the comparator
         * @returns {function} comparator
         */
        function getNaturalSortCriteriaComparator(sortCriteria) {
            return (x, y) => {
                for (const sort of sortCriteria) {
                    const compareResult = getNaturalSortCriterionComparator(sort)(x, y);
                    if (compareResult !== 0) {
                        return compareResult;
                    }
                }
                return 0;
            };
        }
        SortUtils.getNaturalSortCriteriaComparator = getNaturalSortCriteriaComparator;
        /**
         * Helper function that returns a comparator which does natural sort
         * @method
         * @name getNaturalSortCriteriaComparator
         * @memberof! SortUtils
         * @static
         * @param {Array<SortCriterion>} sortCriteria The sortCriterion for the comparator
         * @returns {function} comparator
         */
        function getNaturalSortCriterionComparator(sortCriterion) {
            const _getVal = (val, attr) => {
                if (val === null || typeof val === 'undefined') {
                    return val;
                }
                if (typeof attr === 'string') {
                    const dotIndex = attr.indexOf('.');
                    if (dotIndex > 0) {
                        const startAttr = attr.substring(0, dotIndex);
                        const endAttr = attr.substring(dotIndex + 1);
                        const subObj = val[startAttr];
                        if (subObj) {
                            return _getVal(subObj, endAttr);
                        }
                    }
                }
                if (typeof val[attr] === 'function') {
                    return val[attr]();
                }
                return val[attr];
            };
            return (x, y) => {
                let direction, attribute, xval, yval;
                direction = sortCriterion['direction'];
                attribute = sortCriterion['attribute'];
                xval = _getVal(x, attribute);
                yval = _getVal(y, attribute);
                let compareResult = 0;
                const comparator = getNaturalSortComparator();
                if (direction === 'ascending') {
                    compareResult = comparator(xval, yval);
                }
                else {
                    compareResult = comparator(yval, xval);
                }
                if (compareResult !== 0) {
                    return compareResult;
                }
                return 0;
            };
        }
        SortUtils.getNaturalSortCriterionComparator = getNaturalSortCriterionComparator;
        /**
         * Helper function that returns a comparator which does natural sort
         * @method
         * @name getNaturalSortCriteriaComparator
         * @memberof! SortUtils
         * @static
         * @param {Array<SortCriterion>} sortCriteria The sortCriterion for the comparator
         * @returns {function} comparator
         */
        function getNaturalSortComparator() {
            return (xval, yval) => {
                if (xval === null || typeof xval === 'undefined') {
                    return 1;
                }
                if (yval === null || typeof yval === 'undefined') {
                    return -1;
                }
                let compareResult = 0;
                const strX = typeof xval === 'string' ? xval : String(xval).toString();
                const strY = typeof yval === 'string' ? yval : String(yval).toString();
                compareResult = strX.localeCompare(strY, undefined, {
                    numeric: true,
                    sensitivity: 'base'
                });
                if (compareResult !== 0) {
                    return compareResult;
                }
                return 0;
            };
        }
        SortUtils.getNaturalSortComparator = getNaturalSortComparator;
    })(exports.SortUtils || (exports.SortUtils = {}));

    
    class DataCache {
        constructor() {
            this._handleMutationAdd = function (eventDetail, callback) {
                let indexes = [];
                const eventsMap = new Map();
                const keysInCache = [];
                let keyIndex = 0;
                eventDetail[DataCache._KEYS].forEach((key) => {
                    eventsMap.set(key, {
                        data: eventDetail[DataCache._DATA]?.[keyIndex],
                        metadata: eventDetail[DataCache._METADATA]?.[keyIndex]
                    });
                    keyIndex++;
                });
                const filterCriterion = this._fetchParams?.filterCriterion;
                // if sortCriteria is provided, we need to insert the new data in the correct order
                if (this._fetchParams?.sortCriteria?.length > 0) {
                    const sortComparator = exports.SortUtils.getNaturalSortCriteriaComparator(this._fetchParams.sortCriteria);
                    // create array of eventdetail data and sort it based on sortCriterion
                    const eventDetailDataArray = [];
                    eventDetail[DataCache._DATA]?.forEach((data, index) => {
                        eventDetailDataArray.push({
                            data: data,
                            metadata: eventDetail[DataCache._METADATA][index]
                        });
                    });
                    eventDetailDataArray.sort((a, b) => {
                        return sortComparator(a.data, b.data);
                    });
                    // merge two sorted arrays i.e. eventDetailDataArray and this._items
                    let cacheIndex = 0;
                    let dataArrayIndex = 0;
                    while (dataArrayIndex < eventDetailDataArray.length &&
                        cacheIndex < this._items.length &&
                        this._items[cacheIndex] != undefined) {
                        // if filterCriterion is provided, then insert data only if it matches the filterCriterion
                        if (filterCriterion && !filterCriterion.filter(eventDetailDataArray[dataArrayIndex].data)) {
                            dataArrayIndex++;
                            continue;
                        }
                        let currentCompare = sortComparator(eventDetailDataArray[dataArrayIndex].data, this._items[cacheIndex]?.data);
                        if (currentCompare < 0) {
                            this._items.splice(cacheIndex, 0, new this.Item(eventDetailDataArray[dataArrayIndex].metadata, eventDetailDataArray[dataArrayIndex].data));
                            indexes.push(cacheIndex);
                            dataArrayIndex++;
                            cacheIndex++;
                        }
                        else {
                            cacheIndex++;
                        }
                    }
                    // eventDetailDataArray still has data which is not handled
                    if (dataArrayIndex < eventDetailDataArray.length) {
                        // if this._items contains undefined then it is sparse array and truncate cache at that index
                        if (cacheIndex < this._items.length && this._items[cacheIndex] === undefined) {
                            this._items.length = cacheIndex;
                            this._done = false;
                        }
                        else if (this.isDone()) {
                            while (dataArrayIndex < eventDetailDataArray.length) {
                                // if filterCriterion is provided, then insert data only if it matches the filterCriterion
                                if (filterCriterion &&
                                    !filterCriterion.filter(eventDetailDataArray[dataArrayIndex].data)) {
                                    dataArrayIndex++;
                                    continue;
                                }
                                this._items.push(new this.Item(eventDetailDataArray[dataArrayIndex].metadata, eventDetailDataArray[dataArrayIndex].data));
                                indexes.push(this._items.length - 1);
                                dataArrayIndex++;
                            }
                        }
                    }
                }
                else {
                    // create new eventDetail object which contains only filtered data
                    let eventDetailCopy = {
                        addBeforeKeys: eventDetail[DataCache._BEFOREKEYS] ? [] : eventDetail[DataCache._BEFOREKEYS],
                        data: eventDetail[DataCache._DATA] ? [] : eventDetail[DataCache._DATA],
                        indexes: eventDetail[DataCache._INDEXES] ? [] : eventDetail[DataCache._INDEXES],
                        keys: new Set(),
                        metadata: eventDetail[DataCache._METADATA] ? [] : eventDetail[DataCache._METADATA],
                        parentKeys: eventDetail.parentKeys ? [] : eventDetail.parentKeys,
                        transient: eventDetail.transient
                    };
                    let index = 0;
                    eventDetail[DataCache._KEYS].forEach((key) => {
                        if (!filterCriterion ||
                            (filterCriterion && filterCriterion.filter(eventDetail[DataCache._DATA][index]))) {
                            eventDetailCopy.addBeforeKeys?.push(eventDetail[DataCache._BEFOREKEYS][index]);
                            eventDetailCopy.data?.push(eventDetail[DataCache._DATA][index]);
                            eventDetailCopy.indexes?.push(eventDetail[DataCache._INDEXES][index]);
                            eventDetailCopy.metadata?.push(eventDetail[DataCache._METADATA][index]);
                            eventDetailCopy.parentKeys?.push(eventDetail.parentKeys[index]);
                            eventDetailCopy.keys.add(key);
                        }
                        index++;
                    });
                    for (let i = 0; i < this._items.length; i++) {
                        keysInCache.push(this._items[i]?.metadata?.key);
                    }
                    const finalKeys = exports.DataProviderUtils.getAddEventKeysResult(keysInCache, eventDetailCopy, this.isDone() && this.getSparseIndex() === -1);
                    let initialSparseIndex = -1;
                    finalKeys.forEach((key, index) => {
                        if (key === undefined && initialSparseIndex === -1) {
                            initialSparseIndex = index;
                        }
                        if (!oj$1.Object.compareValues(key, this._items[index]?.metadata?.key) &&
                            eventsMap.has(key)) {
                            let eventData = eventsMap.get(key);
                            this._items.splice(index, 0, new this.Item(eventData.metadata, eventData.data));
                            indexes.push(index);
                            eventsMap.delete(key);
                        }
                    });
                    if (eventsMap.size > 0 && initialSparseIndex > -1) {
                        this._items.length = initialSparseIndex;
                        this._done = false;
                    }
                    if (callback) {
                        callback('add', indexes);
                    }
                }
            };
            this._handleMutationRemove = function (eventDetail, callback) {
                let indexes = [];
                const eventDetailKeys = eventDetail[DataCache._KEYS];
                const keysNotInCache = [];
                if (eventDetailKeys == null || eventDetailKeys.size === 0) {
                    return;
                }
                let index = 0;
                eventDetailKeys.forEach((key) => {
                    let keyFound = false;
                    for (let i = this._items.length - 1; i >= 0; i--) {
                        if (this._items[i] && oj$1.Object.compareValues(this._items[i]?.metadata?.key, key)) {
                            this._items.splice(i, 1);
                            indexes.push(i);
                            keyFound = true;
                            break;
                        }
                    }
                    if (!keyFound) {
                        keysNotInCache.push(key);
                    }
                    index++;
                });
                let sparseIndex = this.getSparseIndex();
                if (keysNotInCache.length > 0 && sparseIndex > -1) {
                    // discarding all contents after an empty item
                    this._items.length = sparseIndex;
                    this._done = false;
                }
                if (callback) {
                    callback('remove', indexes);
                }
            };
            this._handleMutationUpdate = function (eventDetail) {
                const eventDetailData = eventDetail[DataCache._DATA];
                if (eventDetailData && eventDetailData.length > 0) {
                    const eventDetailKeys = eventDetail[DataCache._KEYS];
                    const eventDetailMetadata = this._deriveMetadataFromKey(eventDetail[DataCache._METADATA], eventDetailKeys);
                    let i, index = 0;
                    eventDetailKeys.forEach((key) => {
                        for (i = this._items.length - 1; i >= 0; i--) {
                            if (oj$1.Object.compareValues(this._items[i]?.metadata?.key, key)) {
                                this._items.splice(i, 1, new this.Item(eventDetailMetadata[index], eventDetailData[index]));
                                break;
                            }
                        }
                        index++;
                    });
                }
            };
            this.Item = class {
                constructor(metadata, data) {
                    this.metadata = metadata;
                    this.data = data;
                    this[DataCache._METADATA] = metadata;
                    this[DataCache._DATA] = data;
                }
            };
            this.FetchByKeysResults = class {
                constructor(fetchParameters, results) {
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this[DataCache._FETCHPARAMETERS] = fetchParameters;
                    this[DataCache._RESULTS] = results;
                }
            };
            this.FetchByOffsetResults = class {
                constructor(fetchParameters, results, done, totalFilteredRowCount) {
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this.done = done;
                    this.totalFilteredRowCount = totalFilteredRowCount;
                    this[DataCache._FETCHPARAMETERS] = fetchParameters;
                    this[DataCache._RESULTS] = results;
                    this[DataCache._DONE] = done;
                    if (fetchParameters?.includeFilteredRowCount === 'enabled') {
                        this.totalFilteredRowCount = totalFilteredRowCount;
                    }
                }
            };
            this._items = [];
        }
        addListResult(result) {
            const items = [];
            result.value.data.forEach((data, index) => {
                items.push(new this.Item(result.value.metadata[index], data));
            });
            this._items = this._items.concat(items);
            this._done = result.done;
        }
        getDataList(params, offset) {
            this._fetchParams = params;
            let fetchSize = 25;
            if (params.size != null) {
                if (params.size === -1) {
                    fetchSize = this.getSize();
                }
                else {
                    fetchSize = params.size;
                }
            }
            const items = this._items.slice(offset, offset + fetchSize);
            const data = [];
            const metadata = [];
            items.forEach((item) => {
                data.push(item.data);
                metadata.push(item.metadata);
            });
            return { fetchParameters: params, data, metadata };
        }
        getDataByKeys(params) {
            const results = new Map();
            if (params && params.keys) {
                params.keys.forEach((key) => {
                    for (const item of this._items) {
                        if (item?.metadata?.key === key) {
                            results.set(key, item);
                            break;
                        }
                    }
                });
            }
            return new this.FetchByKeysResults(params, results);
        }
        getDataByOffset(params) {
            this._fetchParams = params;
            let results = [];
            let done;
            if (params.size === -1) {
                done = this.isDone();
                results = this._items.slice(params.offset);
            }
            else {
                const size = params.size || DataCache._DEFAULT_SIZE;
                // all data is cached and fetchByOffset is trying to get data larger than data's total size
                // then done is true
                done = params.offset + size >= this.getSize() && this.isDone();
                results = this._items.slice(params.offset, params.offset + size);
            }
            return new this.FetchByOffsetResults(params, results, done, this.getSize());
        }
        addFetchByOffsetResult(result) {
            const offset = result.fetchParameters.offset || 0;
            result.results.forEach((data, index) => {
                this._items[offset + index] = data;
            });
            this._done = this._done || result.done;
        }
        processMutations(detail, callback = null) {
            if (detail.remove != null) {
                this._handleMutationRemove(detail.remove, callback);
            }
            if (detail.add != null) {
                this._handleMutationAdd(detail.add, callback);
            }
            if (detail.update != null) {
                this._handleMutationUpdate(detail.update);
            }
        }
        reset() {
            this._items = [];
            this._done = false;
        }
        getSize() {
            return this._items.length;
        }
        isDone() {
            return this._done;
        }
        getSparseIndex(start = 0, end = this._items.length) {
            for (let i = start; i < end; i++) {
                if (this._items[i] === undefined) {
                    return i;
                }
            }
            return -1;
        }
        _deriveMetadataFromKey(metadata, keys) {
            // when metadata is not provided, derive it from key
            if (!metadata || metadata.length != keys.size) {
                metadata = [];
                keys.forEach((key) => {
                    metadata.push({ key });
                });
            }
            return metadata;
        }
    }
    DataCache._DATA = 'data';
    DataCache._METADATA = 'metadata';
    DataCache._ITEMS = 'items';
    DataCache._BEFOREKEYS = 'addBeforeKeys';
    DataCache._KEYS = 'keys';
    DataCache._INDEXES = 'indexes';
    DataCache._FROM = 'from';
    DataCache._OFFSET = 'offset';
    DataCache._REFRESH = 'refresh';
    DataCache._MUTATE = 'mutate';
    DataCache._SIZE = 'size';
    DataCache._FETCHPARAMETERS = 'fetchParameters';
    DataCache._SORTCRITERIA = 'sortCriteria';
    DataCache._DIRECTION = 'direction';
    DataCache._ATTRIBUTE = 'attribute';
    DataCache._VALUE = 'value';
    DataCache._DONE = 'done';
    DataCache._RESULTS = 'results';
    DataCache._CONTAINSPARAMETERS = 'containsParameters';
    DataCache._DEFAULT_SIZE = 25;
    DataCache._CONTAINSKEYS = 'containsKeys';
    DataCache._FETCHBYKEYS = 'fetchByKeys';
    DataCache._FETCHBYOFFSET = 'fetchByOffset';
    DataCache._FETCHFIRST = 'fetchFirst';
    DataCache._FETCHATTRIBUTES = 'attributes';
    oj$1._registerLegacyNamespaceProp('DataCache', DataCache);

    /**
     * The class for DataProviderMutationEvent
     */
    class DataProviderMutationEvent extends ojeventtarget.GenericEvent {
        constructor(detail) {
            const eventOptions = {};
            eventOptions[DataProviderMutationEvent._DETAIL] = detail;
            super('mutate', eventOptions);
        }
    }
    DataProviderMutationEvent._DETAIL = 'detail';
    oj$1._registerLegacyNamespaceProp('DataProviderMutationEvent', DataProviderMutationEvent);

    /**
     * The class for DataProviderRefreshEvent
     */
    class DataProviderRefreshEvent extends ojeventtarget.GenericEvent {
        constructor(detail) {
            const eventOptions = {};
            eventOptions['detail'] = detail;
            super('refresh', eventOptions);
        }
    }
    oj$1._registerLegacyNamespaceProp('DataProviderRefreshEvent', DataProviderRefreshEvent);

    class FetchByKeysMixin {
        /**
         * Fetch rows by keys
         */
        fetchByKeys(params) {
            let fetched = 0;
            const limit = this['getIterationLimit'] ? this['getIterationLimit']() : -1;
            const options = {};
            options['size'] = 25;
            const resultMap = new Map();
            const dataProviderAsyncIterator = this['fetchFirst'](options)[Symbol.asyncIterator]();
            function _fetchNextSet(params, dataProviderAsyncIterator, resultMap) {
                return dataProviderAsyncIterator.next().then(function (result) {
                    const value = result['value'];
                    const data = value['data'];
                    const metadata = value['metadata'];
                    const keys = metadata.map(function (metadata) {
                        return metadata['key'];
                    });
                    let foundAllKeys = true;
                    params['keys'].forEach(function (findKey) {
                        if (!resultMap.has(findKey)) {
                            keys.map(function (key, index) {
                                if (key === findKey) {
                                    resultMap.set(key, { metadata: metadata[index], data: data[index] });
                                }
                            });
                        }
                        if (!resultMap.has(findKey)) {
                            foundAllKeys = false;
                        }
                    });
                    // Keep track of how many rows we have fetched
                    fetched += data.length;
                    // Keep iterating if we haven't found all keys and there are more data
                    if (!foundAllKeys && !result['done']) {
                        if (limit != -1 && fetched >= limit) {
                            // If we have reached the limit, just return the results
                            return resultMap;
                        }
                        else {
                            return _fetchNextSet(params, dataProviderAsyncIterator, resultMap);
                        }
                    }
                    else {
                        return resultMap;
                    }
                });
            }
            return _fetchNextSet(params, dataProviderAsyncIterator, resultMap).then(function (resultMap) {
                const mappedResultMap = new Map();
                resultMap.forEach(function (value, key) {
                    const mappedItem = [value];
                    mappedResultMap.set(key, mappedItem[0]);
                });
                return { fetchParameters: params, results: mappedResultMap };
            });
        }
        /**
         * Check if rows are contained by keys
         */
        containsKeys(params) {
            return this.fetchByKeys(params).then(function (fetchByKeysResult) {
                const results = new Set();
                params['keys'].forEach(function (key) {
                    if (fetchByKeysResult['results'].get(key) != null) {
                        results.add(key);
                    }
                });
                return Promise.resolve({ containsParameters: params, results });
            });
        }
        getCapability(capabilityName) {
            if (capabilityName === 'fetchByKeys') {
                return { implementation: 'iteration' };
            }
            let cap = null;
            if (this['_ojSkipLastCapability'] !== true) {
                this['_ojSkipLastCapability'] = true;
                // Find the index for the very last _ojLastGetCapability
                let index = 1;
                while (this['_ojLastGetCapability' + index]) {
                    ++index;
                }
                // Iterate through the _ojLastGetCapability(n) in reverse order
                for (--index; index > 0; index--) {
                    cap = this['_ojLastGetCapability' + index](capabilityName);
                    if (cap) {
                        break;
                    }
                }
                delete this['_ojSkipLastCapability'];
            }
            return cap;
        }
        static applyMixin(derivedCtor) {
            // Save the current getCapability
            const _lastGetCapability = derivedCtor.prototype['getCapability'];
            const baseCtors = [FetchByKeysMixin];
            baseCtors.forEach((baseCtor) => {
                Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
                    if (name !== 'constructor') {
                        derivedCtor.prototype[name] = baseCtor.prototype[name];
                    }
                });
            });
            if (_lastGetCapability) {
                let index = 1;
                while (derivedCtor.prototype['_ojLastGetCapability' + index]) {
                    ++index;
                }
                derivedCtor.prototype['_ojLastGetCapability' + index] = _lastGetCapability;
            }
        }
    }
    oj$1._registerLegacyNamespaceProp('FetchByKeysMixin', FetchByKeysMixin);

    class FetchByOffsetMixin {
        /**
         * Fetch rows by offset
         */
        fetchByOffset(params) {
            const size = params && params['size'] > 0 ? params['size'] : 25;
            const sortCriteria = params ? params['sortCriteria'] : null;
            const offset = params && params['offset'] > 0 ? params['offset'] : 0;
            let fetched = 0;
            const limit = this['getIterationLimit'] ? this['getIterationLimit']() : -1;
            let done = false;
            const options = {};
            options['size'] = size;
            options['sortCriteria'] = sortCriteria;
            const resultArray = new Array();
            const dataProviderAsyncIterator = this['fetchFirst'](options)[Symbol.asyncIterator]();
            function _fetchNextSet(params, dataProviderAsyncIterator, resultArray) {
                return dataProviderAsyncIterator.next().then(function (result) {
                    done = result['done'];
                    const value = result['value'];
                    const data = value['data'];
                    const metadata = value['metadata'];
                    const dataLen = data.length;
                    if (offset < fetched + dataLen) {
                        const start = offset <= fetched ? 0 : offset - fetched;
                        for (let index = start; index < dataLen; index++) {
                            if (resultArray.length === size) {
                                break;
                            }
                            resultArray.push({ metadata: metadata[index], data: data[index] });
                        }
                    }
                    fetched += dataLen;
                    if (resultArray.length < size && !done) {
                        if (limit !== -1 && fetched >= limit) {
                            // If we have reached the limit, just return the results
                            return resultArray;
                        }
                        else {
                            return _fetchNextSet(params, dataProviderAsyncIterator, resultArray);
                        }
                    }
                    else {
                        return resultArray;
                    }
                });
            }
            return _fetchNextSet(params, dataProviderAsyncIterator, resultArray).then(function (resultArray) {
                return { fetchParameters: params, results: resultArray, done: done };
            });
        }
        getCapability(capabilityName) {
            if (capabilityName === 'fetchByOffset') {
                return { implementation: 'iteration' };
            }
            let cap = null;
            if (this['_ojSkipLastCapability'] !== true) {
                this['_ojSkipLastCapability'] = true;
                // Find the index for the very last _ojLastGetCapability
                let index = 1;
                while (this['_ojLastGetCapability' + index]) {
                    ++index;
                }
                // Iterate through the _ojLastGetCapability(n) in reverse order
                for (--index; index > 0; index--) {
                    cap = this['_ojLastGetCapability' + index](capabilityName);
                    if (cap) {
                        break;
                    }
                }
                delete this['_ojSkipLastCapability'];
            }
            return cap;
        }
        static applyMixin(derivedCtor) {
            // Save the current getCapability
            const _lastGetCapability = derivedCtor.prototype['getCapability'];
            const baseCtors = [FetchByOffsetMixin];
            baseCtors.forEach((baseCtor) => {
                Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
                    if (name !== 'constructor') {
                        derivedCtor.prototype[name] = baseCtor.prototype[name];
                    }
                });
            });
            if (_lastGetCapability) {
                let index = 1;
                while (derivedCtor.prototype['_ojLastGetCapability' + index]) {
                    ++index;
                }
                derivedCtor.prototype['_ojLastGetCapability' + index] = _lastGetCapability;
            }
        }
    }
    oj$1._registerLegacyNamespaceProp('FetchByOffsetMixin', FetchByOffsetMixin);

    (function (FilterUtils) {
        /**
         * Helper function that checks if itemData satisfies the search criteria
         * defined by selector or not. Undefined selector means everything is
         * selected.
         * @method
         * @name satisfy
         * @memberof! FilterUtils
         * @static
         * @param {string} selector Rule that defines whether an object is selected
         *                          or not.
         * @param {object} itemData The value to check with.
         * @returns {boolean} true if itemData satisfies search criteria defined
         *                         by selector, and false otherwise.
         */
        function satisfy(selector, itemData) {
            if (!selector) {
                // undefined selector means select everything.
                return true;
            }
            else {
                const expTree = _buildExpressionTree(selector, selector.collationOptions);
                return _evaluateExpressionTree(expTree, itemData);
            }
        }
        FilterUtils.satisfy = satisfy;
        /**
         * Helper function that validates whether the filterCriterion matches the DataProvider's capability.
         * Currently, we only validate the usage of NestedFilter and TextFilter with matchBy value set.
         * Will throw an error if filterCriterion includes unsupported filter and matchBy value.
         * @method
         * @name validateFilterCapabilities
         * @memberof! FilterUtils
         * @static
         * @param {FilterCapability} supportedCapability filter capability of data provider
         * @param {DataFilter.Filter} filterCriterion The filterCriterion that needs to be checked.
         */
        function validateFilterCapabilities(supportedCapability, filterCriterion) {
            let matchBy;
            const supportedMatchBy = supportedCapability?.textFilterMatching?.matchBy;
            if (filterCriterion) {
                // text filter
                if (filterCriterion.text) {
                    matchBy = filterCriterion.matchBy;
                    if (matchBy && (!supportedMatchBy || supportedMatchBy.indexOf(matchBy) < 0)) {
                        throw new Error('This data provider does not support TextFilter with matchBy value ' + matchBy);
                    }
                }
                // Multiple text filter or ExtendedCompoundFilter
                if (filterCriterion.criteria?.length > 0) {
                    for (let index = 0; index < filterCriterion.criteria.length; index++) {
                        const item = filterCriterion.criteria[index];
                        validateFilterCapabilities(supportedCapability, item);
                    }
                }
                // nested filter
                if (filterCriterion.criterion) {
                    validateFilterCapabilities(supportedCapability, filterCriterion.criterion);
                }
            }
        }
        FilterUtils.validateFilterCapabilities = validateFilterCapabilities;
        /**
         * Helper function used by {@link _satisfy} to build an expression tree
         * based on expression object for easier evaluation later.
         * @method
         * @name _buildExpressionTree
         * @memberof! FilterUtils
         * @static
         * @param {object} expression The expression that used to filter an object.
         * @returns {object} The tree representation of the passed-in expression.
         */
        function _buildExpressionTree(expression, collationOptions = undefined) {
            let subTree;
            const itemTreeArray = [];
            for (const key in expression) {
                if (key === 'collationOptions' || key === 'criterion') {
                    continue;
                }
                if (expression.hasOwnProperty(key)) {
                    const value = expression[key];
                    if (key.indexOf('$') === 0) {
                        if (_isMultiSelector(key)) {
                            if (value instanceof Array) {
                                subTree = {
                                    operator: key,
                                    array: []
                                };
                                for (const val of value) {
                                    const itemTree = _buildExpressionTree(val, expression.collationOptions);
                                    subTree.array.push(itemTree);
                                }
                            }
                            else {
                                throw new Error('not a valid expression: ' + expression);
                            }
                        }
                        else if (_isSingleSelector(key)) {
                            throw new Error('not a valid expression: ' + expression);
                        }
                        else if (_isNestedSelector(key)) {
                            const nestedSubTree = _buildExpressionTree(expression['criterion'], expression['criterion']['collationOptions']);
                            itemTreeArray.push({
                                left: value,
                                right: nestedSubTree,
                                operator: key,
                                collationOptions
                            });
                        }
                    }
                    else if (_isLiteral(value)) {
                        itemTreeArray.push({
                            left: key,
                            right: value,
                            operator: '$eq',
                            collationOptions
                        });
                    }
                    else {
                        const partialTree = {
                            left: key,
                            collationOptions
                        };
                        _completePartialTree(partialTree, value);
                        itemTreeArray.push(partialTree);
                    }
                }
            }
            if (itemTreeArray.length > 1) {
                subTree = {
                    operator: '$and',
                    array: itemTreeArray
                };
            }
            else if (itemTreeArray.length === 1) {
                subTree = itemTreeArray[0];
            }
            return subTree;
        }
        /**
         * Helper function used by {@link _buildExpressionTree} to complete the
         * right side of an expression tree.
         * @method
         * @name _completePartialTree
         * @memberof! FilterUtils
         * @static
         * @param {object} partialTree The tree representation of an expression.
         * @param {object} expression The object to evaluate the expression tree
         *                          against.
         */
        function _completePartialTree(partialTree, expression) {
            let found = false;
            for (const key in expression) {
                if (expression.hasOwnProperty(key)) {
                    const value = expression[key];
                    if (found || !_isSingleSelector(key)) {
                        throw new Error('parsing error ' + expression);
                    }
                    partialTree.operator = key;
                    partialTree.right = value;
                    found = true;
                }
            }
        }
        /**
         * Helper function used by {@link find} to apply an expression tree to
         * an object to check if this object satisfies the expression tree or not.
         * @method
         * @name _evaluateExpressionTree
         * @memberof! FilterUtils
         * @tatic
         * @param {object} expTree The tree representation of an expression.
         * @param {object} itemData The object to evaluate the expression tree
         *                          against.
         * @returns {boolean} true if itemData satisfies expression tree, false
         *                    otherwise.
         */
        function _evaluateExpressionTree(expTree, itemData) {
            const operator = expTree.operator;
            const { collationOptions } = expTree;
            if (_isMultiSelector(operator)) {
                if (expTree.left || !(expTree.array instanceof Array)) {
                    throw new Error('invalid expression tree!' + expTree);
                }
                else {
                    let result;
                    const subTreeArray = expTree.array;
                    for (const subTree of subTreeArray) {
                        const subResult = _evaluateExpressionTree(subTree, itemData);
                        if (operator === '$or' && subResult === true) {
                            return true;
                        }
                        else if (operator === '$and' && subResult === false) {
                            return false;
                        }
                        result = subResult;
                    }
                    return result;
                }
            }
            else if (_isSingleSelector(operator)) {
                const value = expTree.right;
                let itemValue;
                if (expTree.left != '*') {
                    itemValue = getValue(expTree.left, itemData);
                    return _evaluateSingleSelectorExpression(operator, value, itemValue, collationOptions);
                }
                else {
                    const itemProperties = Object.keys(itemData);
                    for (const itemProp of itemProperties) {
                        itemValue = getValue(itemProp, itemData);
                        if (_evaluateSingleSelectorExpression(operator, value, itemValue, collationOptions)) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            else if (_isNestedSelector(operator)) {
                let nestedItemDataArray = getValue(expTree.left, itemData);
                if (nestedItemDataArray === undefined ||
                    !(nestedItemDataArray instanceof Array) ||
                    nestedItemDataArray.length === 0) {
                    return false;
                }
                for (const nestedItemData of nestedItemDataArray) {
                    let nestedResult = _evaluateExpressionTree(expTree.right, nestedItemData);
                    if (nestedResult) {
                        return true;
                    }
                }
                return false;
            }
            else {
                throw new Error('not a valid expression!' + expTree);
            }
        }
        /**
         * Helper function to evaluate a single selector expression.
         * @method
         * @name _evaluateSingleSelectorExpression
         * @memberof! FilterUtils
         * @static
         * @param {string} operator The operator of an expression.
         * @param {object} value The value.
         * @param {object} itemValue The object to evaluate the expression tree
         *                          against.
         * @returns {boolean} true if itemData satisfies expression, false
         *                    otherwise.
         */
        function _evaluateSingleSelectorExpression(operator, value, itemValue, collationOptions) {
            // Use Intl.Collator if there is a collationOptions and the values being compared are both strings.
            if (collationOptions &&
                ['base', 'accent', 'case', 'variant'].indexOf(collationOptions.sensitivity) < 0) {
                throw new Error('not a valid sensitivity! ' + collationOptions.sensitivity);
            }
            let collator;
            if (collationOptions &&
                (typeof value === 'string' || value instanceof String) &&
                (typeof itemValue === 'string' || itemValue instanceof String) &&
                ['base', 'accent', 'case', 'variant'].indexOf(collationOptions.sensitivity) >= 0) {
                collator = new Intl.Collator(undefined, collationOptions);
            }
            if (operator === '$lt') {
                const fixedTokens = _fixNullForString(itemValue, value);
                itemValue = fixedTokens[0];
                value = fixedTokens[1];
                return collator ? collator.compare(itemValue, value) < 0 : itemValue < value;
            }
            else if (operator === '$gt') {
                const fixedTokens = _fixNullForString(itemValue, value);
                itemValue = fixedTokens[0];
                value = fixedTokens[1];
                return collator ? collator.compare(itemValue, value) > 0 : itemValue > value;
            }
            else if (operator === '$lte') {
                const fixedTokens = _fixNullForString(itemValue, value);
                itemValue = fixedTokens[0];
                value = fixedTokens[1];
                return collator ? collator.compare(itemValue, value) <= 0 : itemValue <= value;
            }
            else if (operator === '$gte') {
                const fixedTokens = _fixNullForString(itemValue, value);
                itemValue = fixedTokens[0];
                value = fixedTokens[1];
                return collator ? collator.compare(itemValue, value) >= 0 : itemValue >= value;
            }
            else if (operator === '$eq') {
                return collator ? collator.compare(itemValue, value) === 0 : itemValue === value;
            }
            else if (operator === '$ne') {
                return collator ? collator.compare(itemValue, value) !== 0 : itemValue !== value;
            }
            else if (operator === '$regex') {
                if (itemValue != null) {
                    if (!(typeof itemValue === 'string') && !(itemValue instanceof String)) {
                        if (!(itemValue instanceof Object)) {
                            // primitive so coerce to a string
                            itemValue = new String(itemValue);
                        }
                        else {
                            // call toString() on objects. Check if it returns just the default
                            // return value for toString(). If so, then we can't do anything so
                            // return false
                            itemValue = itemValue.toString();
                            if (itemValue == '[object Object]') {
                                return false;
                            }
                        }
                    }
                    // Convert the values if necessary.  This is only needed when $regex
                    // is generated internally from $co, $ew, and $ew.
                    // If the $regex is from text filter, there is no collationOptions.
                    // If the $regex is from attribute filter, caller shouldn't need collationOptions.
                    const sensitivity = collationOptions?.sensitivity;
                    let option = undefined;
                    if (sensitivity === 'base' || sensitivity === 'case') {
                        // replace accent combining diacritical marks
                        itemValue = itemValue.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                        value = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    }
                    if (sensitivity === 'base' || sensitivity === 'accent') {
                        // regex option
                        // it is not safe to convert regex with toLowerCase()
                        option = 'i';
                    }
                    const matchResult = itemValue.match(new RegExp(value, option));
                    return matchResult !== null;
                }
                return false;
            }
            else if (operator === '$exists') {
                if (value) {
                    return itemValue !== null && itemValue !== undefined;
                }
                else {
                    return itemValue === null || itemValue === undefined;
                }
            }
            else {
                throw new Error('not a valid operator! ' + operator);
            }
            return false;
        }
        /**
         * Helper function that checks if the token is a multiple selector operator
         * or not.
         * @method
         * @name _isMultiSelector
         * @memberof! FilterUtils
         * @static
         * @param {string} token The token to check against.
         * @returns {boolean} true if the token is the supported multiple selector
         *                    operator, false otherwise.
         */
        function _isMultiSelector(token) {
            return token === '$and' || token === '$or';
        }
        /**
         * Helper function that checks if the token is a single selector operator
         * or not.
         * @method
         * @name _isSingleSelector
         * @memberof! FilterUtils
         * @static
         * @param {string} token The token to check against.
         * @returns {boolean} true if the token is the supported single selector
         *                    operator, false otherwise.
         */
        function _isSingleSelector(token) {
            return (token === '$lt' ||
                token === '$gt' ||
                token === '$lte' ||
                token === '$gte' ||
                token === '$eq' ||
                token === '$ne' ||
                token === '$regex' ||
                token === '$exists');
        }
        /**
         * Helper function that checks if this is nested selector or not.
         * @method
         * @name _isNestedSelector
         * @memberof! FilterUtils
         * @static
         * @param {string} token The token to check against.
         * @returns {boolean} true if the token is the supported nested selector
         *                    operator, false otherwise.
         */
        function _isNestedSelector(token) {
            return token === '$nestedAttr';
        }
        /**
         * Helper function that checks if the token is a literal or not.
         * @method
         * @name _isLiteral
         * @memberof! FilterUtils
         * @static
         * @param {string} token The token to check against.
         * @returns {boolean} true if the token is a literal, false otherwise.
         */
        function _isLiteral(token) {
            return typeof token !== 'object';
        }
        /**
         * Helper function that checks if the token is a string
         * @method
         * @name _isSring
         * @memberof! FilterUtils
         * @static
         * @param {string} token The token to check against.
         * @returns {boolean} true if the token is a string, false otherwise.
         */
        function _isString(token) {
            return token != null && (token instanceof String || typeof token === 'string');
        }
        /**
         * Helper function that sets null literals to empty string for string comparison
         * @method
         * @name _fixNullForString
         * @memberof! FilterUtils
         * @static
         * @param {string} leftToken left hand token
         * @param {string} rightToken right hand token
         * @returns {Array} Array of left and right hand tokens
         */
        function _fixNullForString(leftToken, rightToken) {
            if (_isString(leftToken) && rightToken == null) {
                rightToken = '';
            }
            else if (_isString(rightToken) && leftToken == null) {
                leftToken = '';
            }
            return [leftToken, rightToken];
        }
        /**
         * Helper function that retrieves the value of a property from an object.
         * The object can have nested properties, and the property name could be
         * a path to the leaf property.
         * @method
         * @name getValue
         * @memberof! FilterUtils
         * @static
         * @param {string} path The chain of the property names from the root to
         *                      the leaf when the object has nested properties.
         * @param {object} itemValue The object to retrieve the property value
         *                           from.
         * @returns {object} the object that contains all the properties defined
         *                   in fieldsExpression array, the corresponding property
         *                   value is obtained from itemData.
         */
        function getValue(path, itemValue) {
            const paths = path.split('.');
            let returnValue = itemValue;
            for (const path of paths) {
                returnValue = returnValue[path];
            }
            return returnValue;
        }
    })(exports.FilterUtils || (exports.FilterUtils = {}));

    /**
     * The class for FilterFactory<D>
     */
    class FilterImpl {
        constructor(options) {
            options = options || {};
            this._textFilterAttributes = options['filterOptions']
                ? options['filterOptions']['textFilterAttributes']
                : null;
            const filterDef = options.filterDef;
            if (filterDef) {
                if (filterDef['op']) {
                    this['op'] = filterDef['op'];
                    if (filterDef['value'] !== undefined) {
                        this['value'] = filterDef['value'];
                        if (filterDef['attribute']) {
                            this['attribute'] = filterDef['attribute'];
                        }
                    }
                    else if (filterDef['criteria']) {
                        this['criteria'] = filterDef['criteria'];
                    }
                    else if (filterDef['criterion']) {
                        this['criterion'] = filterDef['criterion'];
                        if (filterDef['attribute']) {
                            this['attribute'] = filterDef['attribute'];
                        }
                    }
                    if (filterDef['collationOptions']) {
                        this['collationOptions'] = filterDef['collationOptions'];
                    }
                }
                else if (filterDef['text']) {
                    this['text'] = filterDef['text'];
                    this['matchBy'] = filterDef['matchBy'];
                }
            }
        }
        filter(item, index, array) {
            return exports.FilterUtils.satisfy(FilterImpl._transformFilter(this), item);
        }
        static _transformFilter(filter) {
            let transformedExpr;
            if (filter) {
                let op = filter.op;
                let filterValue;
                const collationOptions = filter.collationOptions;
                if (op === '$exists' && filter['attribute'] && filter['criterion']) {
                    // NestedFilter
                    transformedExpr = {};
                    transformedExpr['$nestedAttr'] = filter['attribute'];
                    transformedExpr['criterion'] = FilterImpl._transformFilter(FilterFactory.getFilter({ filterDef: filter['criterion'] }));
                    return transformedExpr;
                }
                if (filter['text']) {
                    op = '$regex';
                }
                else {
                    // offline has slightly different names for some operators
                    if (op === '$le') {
                        op = '$lte';
                    }
                    else if (op === '$ge') {
                        op = '$gte';
                    }
                    else if (op === '$pr') {
                        op = '$exists';
                    }
                }
                if (op !== '$and' && op !== '$or') {
                    if (filter['text']) {
                        if (filter['matchBy'] === 'phrase') {
                            // 1. Escape special characters
                            // 2. Remove single and double quotes
                            // 3. Add word boundary and wild cards for phrase matching
                            filterValue = new RegExp(`${'\\b' +
                            filter['text']
                                .replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&')
                                .replace(/('|")/g, '')
                                .replace(/(\s|\t)/g, '(.*)((\\s|\\t|\\r|\\n)*)')}`, 'i');
                        }
                        else if (filter['matchBy'] === 'startsWith') {
                            filterValue = new RegExp(`^${filter['text'].replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&')}`, 'i');
                        }
                        else {
                            // 'contains' | 'fuzzy' | 'unknown'
                            // Escape special characters without change filter['text'] which is the original filter string by default
                            filterValue = new RegExp(filter['text'].replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'), 'i');
                        }
                    }
                    else {
                        filterValue = filter.value;
                    }
                    transformedExpr = {};
                    const attributeExpr = filter.attribute;
                    if (attributeExpr) {
                        // handle AttributeExprFilterDef
                        const operatorExpr = {};
                        // need express sw and ew as regex
                        if (op === '$sw' || op === '$ew' || op === '$co') {
                            filterValue = FilterImpl._fixStringExpr(op, filterValue);
                            op = '$regex';
                        }
                        operatorExpr[op] = filterValue;
                        transformedExpr[attributeExpr] = operatorExpr;
                    }
                    else if (filter['text']) {
                        // handle TextFilterDef
                        const operatorExpr = {};
                        operatorExpr[op] = filterValue;
                        if (filter._textFilterAttributes && filter._textFilterAttributes.length > 0) {
                            const textFilterArray = [];
                            filter._textFilterAttributes.forEach(function (field) {
                                const textFilter = {};
                                textFilter[field] = operatorExpr;
                                textFilterArray.push(textFilter);
                            });
                            transformedExpr['$or'] = textFilterArray;
                        }
                        else {
                            transformedExpr['*'] = operatorExpr;
                        }
                    }
                    else {
                        // handle AttributeFilterDef
                        // the field/value combos are specified in the value itself
                        const criteriaArray = [];
                        if (filterValue == undefined) {
                            throw new Error('attribute cannot be empty');
                        }
                        FilterImpl._transformObjectExpr(filterValue, op, null, criteriaArray);
                        transformedExpr['$and'] = criteriaArray;
                    }
                }
                else {
                    // handle ExtendedCompoundFilterDef
                    const criteriaArray = [];
                    filter.criteria.forEach(function (compCriteria) {
                        if (compCriteria && compCriteria['text'] && filter._textFilterAttributes) {
                            compCriteria['_textFilterAttributes'] = filter._textFilterAttributes;
                        }
                        criteriaArray.push(FilterImpl._transformFilter(compCriteria));
                    });
                    transformedExpr = {};
                    transformedExpr[op] = criteriaArray;
                }
                transformedExpr.collationOptions = collationOptions;
            }
            return transformedExpr;
        }
        static _transformObjectExpr(objectExpr, op, path, criteriaArray) {
            const objectProps = Object.keys(objectExpr);
            if (objectProps.length > 0) {
                Object.keys(objectExpr).forEach(function (fieldAttribute) {
                    let fieldValue = objectExpr[fieldAttribute];
                    const fieldAttributePath = path ? path + '.' + fieldAttribute : fieldAttribute;
                    if (!(fieldValue instanceof Object)) {
                        const operatorExpr = {};
                        // need express co, sw and ew as regex
                        if (op === '$sw' || op === '$ew' || op === '$co') {
                            fieldValue = FilterImpl._fixStringExpr(op, fieldValue);
                            op = '$regex';
                        }
                        operatorExpr[op] = fieldValue;
                        const fieldExpr = {};
                        fieldExpr[fieldAttributePath] = operatorExpr;
                        criteriaArray.push(fieldExpr);
                    }
                    else {
                        FilterImpl._transformObjectExpr(fieldValue, op, fieldAttributePath, criteriaArray);
                    }
                });
            }
            else {
                const operatorExpr = {};
                operatorExpr[op] = objectExpr;
                const fieldExpr = {};
                fieldExpr[path] = operatorExpr;
                criteriaArray.push(fieldExpr);
            }
        }
        static _fixStringExpr(op, value) {
            if (typeof value === 'string' || value instanceof String) {
                if (op === '$sw') {
                    value = '^' + value;
                }
                else if (op === '$ew') {
                    value = value + '$';
                }
            }
            return value;
        }
    }
    class FilterFactory {
        static getFilter(options) {
            return new FilterImpl(options);
        }
    }
    oj$1._registerLegacyNamespaceProp('FilterFactory', FilterFactory);

    const createAbortRejectionValue = (signal) => {
        return signal.reason instanceof DOMException
            ? signal.reason
            : new DOMException(signal.reason, 'AbortError');
    };
    const wrapWithAbortHandling = (signal, wrapped, catchAndRejectErrors) => {
        if (signal?.aborted) {
            return Promise.reject(createAbortRejectionValue(signal));
        }
        return new Promise((resolve, reject) => {
            signal?.addEventListener('abort', () => {
                return reject(createAbortRejectionValue(signal));
            });
            if (catchAndRejectErrors) {
                wrapped(resolve, reject).catch(reject);
            }
            else {
                wrapped(resolve, reject);
            }
        });
    };

    class DataProviderFeatureChecker {
        static isDataProvider(dataprovider) {
            if (dataprovider && dataprovider['fetchFirst']) {
                return true;
            }
            return false;
        }
        static isTreeDataProvider(dataprovider) {
            if (dataprovider && dataprovider['getChildDataProvider']) {
                return true;
            }
            return false;
        }
    }
    oj$1._registerLegacyNamespaceProp('DataProviderFeatureChecker', DataProviderFeatureChecker);

    exports.DataCache = DataCache;
    exports.DataProviderFeatureChecker = DataProviderFeatureChecker;
    exports.DataProviderMutationEvent = DataProviderMutationEvent;
    exports.DataProviderRefreshEvent = DataProviderRefreshEvent;
    exports.FetchByKeysMixin = FetchByKeysMixin;
    exports.FetchByOffsetMixin = FetchByOffsetMixin;
    exports.FilterFactory = FilterFactory;
    exports.wrapWithAbortHandling = wrapWithAbortHandling;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojset',['ojs/ojkeysetimpl'], function (KeySetImpl) { 'use strict';

    KeySetImpl = KeySetImpl && Object.prototype.hasOwnProperty.call(KeySetImpl, 'default') ? KeySetImpl['default'] : KeySetImpl;

    /**
     * Implementation of the ES6 Set API:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
     * that can deal with how equalities are handled when Object is used as key
     * @ignore
     * @ojtsignore
     * @export
     * @class ojSet
     * @constructor
     * @since 6.2.0
     */
    class ojSet {
        constructor(initialKeys) {
            this.initialKeys = initialKeys;
            const self = this;
            this._set = new Set();
            this._keyset = new KeySetImpl();
            if (initialKeys) {
                initialKeys.forEach(function (key) {
                    self.add(key);
                });
            }
            Object.defineProperty(this, 'size', {
                get() {
                    return this._set.size;
                }
            });
            this[Symbol.iterator] = function () {
                return this._set[Symbol.iterator]();
            };
        }
        clear() {
            this._set.clear();
            this._keyset._keys.clear();
        }
        delete(key) {
            const theKey = this._keyset.get(key);
            if (theKey === this._keyset.NOT_A_KEY) {
                return false;
            }
            this._keyset._keys.delete(theKey);
            return this._set.delete(theKey);
        }
        forEach(callbackfn, thisArg) {
            this._set.forEach(callbackfn, thisArg);
        }
        keys() {
            return this._set.keys();
        }
        values() {
            return this._set.values();
        }
        entries() {
            return this._set.entries();
        }
        has(key) {
            return this._keyset.has(key);
        }
        add(key) {
            const theKey = this._keyset.get(key);
            if (theKey === this._keyset.NOT_A_KEY) {
                this._keyset._keys.add(key);
                this._set.add(key);
            }
            return this;
        }
        get [(Symbol.iterator, Symbol.toStringTag)]() {
            return Set[Symbol.toStringTag]();
        }
    }

    return ojSet;

});


define('ojs/ojmap',['ojs/ojkeysetimpl'], function (KeySetImpl) { 'use strict';

  KeySetImpl = KeySetImpl && Object.prototype.hasOwnProperty.call(KeySetImpl, 'default') ? KeySetImpl['default'] : KeySetImpl;

  /**
   * Implementation of the ES6 Map API:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
   * that can deal with how equalities are handled when Object is used as key
   * @ignore
   * @ojtsignore
   * @export
   * @class ojMap
   * @constructor
   * @since 5.2.0
   */
  var ojMap = function (initialMap) {
    if (initialMap) {
      this._map = initialMap;
      this._keyset = new KeySetImpl(Array.from(this._map.keys()));
    } else {
      this._map = new Map();
      this._keyset = new KeySetImpl();
    }
  };
  var _proto = ojMap.prototype;

  Object.defineProperty(_proto, 'size', {
    get: function () {
      return this._map.size;
    }
  });

  _proto.clear = function () {
    this._map.clear();
    this._keyset._keys.clear();
  };

  _proto.delete = function (key) {
    var theKey = this._keyset.get(key);
    if (theKey === this._keyset.NOT_A_KEY) {
      return false;
    }
    this._keyset._keys.delete(theKey);
    return this._map.delete(theKey);
  };

  _proto.forEach = function (callback) {
    this._map.forEach(callback);
  };

  _proto.entries = function () {
    return this._map.entries();
  };

  _proto.keys = function () {
    return this._map.keys();
  };

  _proto.values = function () {
    return this._map.values();
  };

  _proto.get = function (key) {
    var theKey = this._keyset.get(key);
    return this._map.get(theKey);
  };

  _proto.has = function (key) {
    return this._keyset.has(key);
  };

  _proto.set = function (key, value) {
    var theKey = this._keyset.get(key);
    if (theKey === this._keyset.NOT_A_KEY) {
      this._keyset._keys.add(key);
      this._map.set(key, value);
    } else {
      // update value
      this._map.set(theKey, value);
    }
    return this;
  };

  return ojMap;

});


define('ojs/ojarraydataproviderimpl',['exports', 'ojs/ojdataprovider', 'ojs/ojset', 'ojs/ojcore-base', 'ojs/ojmap', 'ojs/ojlogger'], function (exports, ojdataprovider, ojSet, oj, ojMap, Logger) { 'use strict';

    ojSet = ojSet && Object.prototype.hasOwnProperty.call(ojSet, 'default') ? ojSet['default'] : ojSet;
    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    ojMap = ojMap && Object.prototype.hasOwnProperty.call(ojMap, 'default') ? ojMap['default'] : ojMap;

    const _ATDEFAULT = '@default';
    const getFetchCapability = () => {
        const exclusionFeature = new Set();
        exclusionFeature.add('exclusion');
        return {
            caching: 'all',
            attributeFilter: {
                expansion: {},
                ordering: {},
                defaultShape: {
                    features: exclusionFeature
                }
            }
        };
    };
    const markNoProxy = (obj) => {
        Object.defineProperty(obj, Symbol.for('oj-vb-no-object-proxy'), { value: true });
        return obj;
    };
    const getCapability = (capabilityName) => {
        if (capabilityName === 'sort') {
            return { attributes: 'multiple' };
        }
        else if (capabilityName === 'fetchByKeys') {
            return Object.assign({ implementation: 'lookup' }, getFetchCapability());
        }
        else if (capabilityName === 'fetchByOffset') {
            return Object.assign({ implementation: 'randomAccess', totalFilteredRowCount: 'exact' }, getFetchCapability());
        }
        else if (capabilityName === 'fetchFirst') {
            return Object.assign({ iterationSpeed: 'immediate', totalFilteredRowCount: 'exact' }, getFetchCapability());
        }
        else if (capabilityName === 'fetchCapability') {
            return getFetchCapability();
        }
        else if (capabilityName === 'filter') {
            return {
                operators: [
                    '$co',
                    '$eq',
                    '$ew',
                    '$pr',
                    '$gt',
                    '$ge',
                    '$lt',
                    '$le',
                    '$ne',
                    '$regex',
                    '$sw',
                    '$exists'
                ],
                attributeExpression: ['*'],
                textFilter: {},
                textFilterMatching: { matchBy: ['startsWith', 'contains', 'phrase'] },
                nestedFilter: {},
                collationOptions: {
                    sensitivity: ['base', 'accent', 'case', 'variant']
                }
            };
        }
        return null;
    };
    /**
     * Get value for attribute
     */
    const getVal = (val, attr) => {
        if (typeof attr === 'string') {
            const dotIndex = attr.indexOf('.');
            if (dotIndex > 0) {
                const startAttr = attr.substring(0, dotIndex);
                const endAttr = attr.substring(dotIndex + 1);
                const subObj = val[startAttr];
                if (subObj) {
                    return getVal(subObj, endAttr);
                }
            }
        }
        if (typeof val[attr] === 'function') {
            return val[attr]();
        }
        return val[attr];
    };
    /**
     * Get all values in a row
     */
    const getAllVals = (val) => {
        if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
            return val;
        }
        return Object.keys(val).map((key) => {
            return getVal(val, key);
        });
    };
    const filterRowAttributes = (fetchAttribute, data, updatedData) => {
        if (Array.isArray(fetchAttribute)) {
            // first see if we want all attributes
            let fetchAllAttributes = false;
            fetchAttribute.forEach((key) => {
                if (key === _ATDEFAULT || key.name === _ATDEFAULT) {
                    fetchAllAttributes = true;
                }
            });
            let i;
            Object.keys(data).forEach((dataAttr) => {
                if (fetchAllAttributes) {
                    let excludeAttribute = false;
                    let fetchAttr = dataAttr;
                    let attribute;
                    for (i = 0; i < fetchAttribute.length; i++) {
                        if (fetchAttribute[i] instanceof Object) {
                            attribute = fetchAttribute[i]['name'];
                        }
                        else {
                            attribute = fetchAttribute[i];
                        }
                        if (attribute.startsWith('!')) {
                            attribute = attribute.substr(1, attribute.length - 1);
                            if (attribute === dataAttr) {
                                // if it's excluded then set the exclusion flag and break
                                excludeAttribute = true;
                                break;
                            }
                        }
                        else if (attribute === dataAttr) {
                            // if there is a fetch attribute with the same name then use that
                            fetchAttr = fetchAttribute[i];
                            break;
                        }
                    }
                    if (!excludeAttribute) {
                        filterRowAttributes(fetchAttr, data, updatedData);
                    }
                }
                else {
                    fetchAttribute.forEach((fetchAttr) => {
                        let attribute;
                        if (fetchAttr instanceof Object) {
                            attribute = fetchAttr['name'];
                        }
                        else {
                            attribute = fetchAttr;
                        }
                        if (!attribute.startsWith('!') && attribute === dataAttr) {
                            filterRowAttributes(fetchAttr, data, updatedData);
                        }
                    });
                }
            });
        }
        else if (fetchAttribute instanceof Object) {
            const name = fetchAttribute['name'];
            const attributes = fetchAttribute['attributes'];
            if (name && !name.startsWith('!')) {
                if (data[name] instanceof Object && !Array.isArray(data[name]) && attributes) {
                    const updatedDataSubObj = {};
                    filterRowAttributes(attributes, data[name], updatedDataSubObj);
                    updatedData[name] = updatedDataSubObj;
                }
                else if (Array.isArray(data[name]) && attributes) {
                    updatedData[name] = [];
                    let updatedDataArrayItem;
                    data[name].forEach((arrVal, index) => {
                        updatedDataArrayItem = {};
                        filterRowAttributes(attributes, arrVal, updatedDataArrayItem);
                        updatedData[name][index] = updatedDataArrayItem;
                    });
                }
                else {
                    _proxyAttribute(updatedData, data, name);
                }
            }
        }
        else {
            _proxyAttribute(updatedData, data, fetchAttribute);
        }
    };
    const _proxyAttribute = (updatedData, data, attribute) => {
        if (!updatedData || !data) {
            return;
        }
        Object.defineProperty(updatedData, attribute, {
            get() {
                return data[attribute];
            },
            set(val) {
                data[attribute] = val;
            },
            enumerable: true
        });
    };
    /**
     * Return an empty Set which is optimized to store keys
     */
    const createOptimizedKeySet = (initialSet) => {
        return new ojSet(initialSet);
    };
    /**
     * Returns an empty Map which will efficiently store Keys returned by the DataProvider
     */
    const createOptimizedKeyMap = (initialMap) => {
        if (initialMap) {
            const map = new ojMap();
            initialMap.forEach((value, key) => {
                map.set(key, value);
            });
            return map;
        }
        return new ojMap();
    };
    const createItem = (key, data) => {
        return markNoProxy({
            metadata: markNoProxy({ key }),
            data,
        });
    };
    const keyArrayToMetadataArray = (keys) => {
        return keys.map((key) => {
            return markNoProxy({ key });
        });
    };
    /**
     * Return the index of a key, or -1 if the key is not found.
     */
    const indexOfKey = (searchKey, keys) => {
        let keyIndex = -1;
        let i;
        for (i = 0; i < keys.length; i++) {
            if (oj.Object.compareValues(keys[i], searchKey)) {
                keyIndex = i;
                break;
            }
        }
        return keyIndex;
    };

    class ArrayDataProviderImpl {
        constructor(options, implOptions) {
            var _a;
            this.options = options;
            this.implOptions = implOptions;
            this._sequenceNum = 0;
            this._mutationSequenceNum = 0;
            this._mapClientIdToIteratorInfo = new Map();
            this.AsyncIterable = (_a = class {
                    constructor(_asyncIterator) {
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = () => {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this.AsyncIterator = class {
                constructor(_parent, _nextFunc, _params, _offset) {
                    this._parent = _parent;
                    this._nextFunc = _nextFunc;
                    this._params = _params;
                    this._offset = _offset;
                    this._clientId = (_params && _params.clientId) || Symbol();
                    _parent._mapClientIdToIteratorInfo.set(this._clientId, {
                        offset: _offset,
                        rowKey: null,
                        filterCriterion: _params?.filterCriterion,
                        sortCriteria: _params?.sortCriteria,
                        fetchedRowKeys: []
                    });
                    this._cacheObj = { mutationSequenceNum: _parent._mutationSequenceNum };
                }
                ['next']() {
                    const callback = (resolve, reject) => {
                        const cachedIteratorInfo = this._parent._mapClientIdToIteratorInfo.get(this._clientId);
                        const cachedOffset = cachedIteratorInfo ? cachedIteratorInfo.offset : null;
                        const resultObj = this._nextFunc(this._params, cachedOffset, false, this._cacheObj);
                        // Add a getter for totalFilteredRowCount
                        Object.defineProperty(resultObj.result.value, 'totalFilteredRowCount', {
                            get: () => {
                                if (this._params?.includeFilteredRowCount === 'enabled') {
                                    if (this._totalFilteredRowCount === undefined ||
                                        this._parent._resetTotalFilteredRowCount) {
                                        this._totalFilteredRowCount = this._parent._getTotalFilteredRowCount(this._params);
                                        this._parent._resetTotalFilteredRowCount = false;
                                    }
                                    return this._totalFilteredRowCount;
                                }
                            },
                            enumerable: true
                        });
                        const rowKeyArray = resultObj.result.value.metadata?.map((itemMetadata) => itemMetadata.key);
                        const fetchedRowKeys = rowKeyArray
                            ? cachedIteratorInfo?.fetchedRowKeys
                                ? cachedIteratorInfo.fetchedRowKeys.concat(rowKeyArray)
                                : rowKeyArray
                            : [];
                        const lastRowKey = fetchedRowKeys.length > 0 ? fetchedRowKeys[fetchedRowKeys.length - 1] : null;
                        this._parent._mapClientIdToIteratorInfo.set(this._clientId, {
                            offset: resultObj.offset,
                            rowKey: lastRowKey,
                            filterCriterion: this._params?.filterCriterion,
                            sortCriteria: this._params?.sortCriteria,
                            fetchedRowKeys
                        });
                        return resolve(resultObj.result);
                    };
                    return this._parent.implOptions.supportAbortController
                        ? ojdataprovider.wrapWithAbortHandling(this._params?.signal, callback, false)
                        : // Using the syntax below as opposed to the more straightfoward
                            // "new Promise((resolve, reject) => callback(resolve, reject))"
                            // to allow Errors to be thrown rather than being turned into Promise rejections.
                            // This avoids what would be a (subtle) change in behavior in MADP
                            callback(Promise.resolve.bind(Promise), Promise.reject.bind(Promise));
                }
            };
        }
        containsKeys(containsParameters) {
            return this.fetchByKeys(containsParameters).then((fetchByKeysResult) => {
                const results = new ojSet();
                containsParameters.keys.forEach((key) => {
                    if (fetchByKeysResult.results.get(key) != null) {
                        results.add(key);
                    }
                });
                return Promise.resolve(markNoProxy({
                    containsParameters,
                    results
                }));
            });
        }
        fetchByKeys(fetchParameters) {
            const callback = (resolve, reject) => {
                this.implOptions.generateKeysIfNeeded(() => this.generateKeys());
                const results = new ojMap();
                const keys = this.implOptions.getKeys();
                const fetchAttributes = fetchParameters != null ? fetchParameters.attributes : null;
                let findKeyIndex, i = 0;
                if (fetchParameters) {
                    const rowData = this.implOptions.getData();
                    fetchParameters.keys.forEach((searchKey) => {
                        findKeyIndex = null;
                        for (i = 0; i < keys.length; i++) {
                            if (oj.Object.compareValues(keys[i], searchKey)) {
                                findKeyIndex = i;
                                break;
                            }
                        }
                        if (findKeyIndex != null && findKeyIndex >= 0) {
                            let row = rowData[findKeyIndex];
                            if (fetchAttributes && fetchAttributes.length > 0) {
                                const updatedData = {};
                                filterRowAttributes(fetchAttributes, row, updatedData);
                                row = updatedData;
                            }
                            results.set(searchKey, createItem(searchKey, row));
                        }
                    });
                    return resolve(markNoProxy({
                        fetchParameters,
                        results
                    }));
                }
                else {
                    return reject('Keys are a required parameter');
                }
            };
            return this.implOptions.supportAbortController
                ? ojdataprovider.wrapWithAbortHandling(fetchParameters?.signal, callback, false)
                : // Using the syntax below as opposed to the more straightfoward
                    // "new Promise((resolve, reject) => callback(resolve, reject))"
                    // to allow Errors to be thrown rather than being turned into Promise rejections.
                    // This avoids what would be a (subtle) change in behavior in MADP
                    callback(Promise.resolve.bind(Promise), Promise.reject.bind(Promise));
        }
        fetchByOffset(params) {
            const callback = (resolve, reject) => {
                const size = params != null ? params.size : -1;
                const sortCriteria = params != null ? params.sortCriteria : null;
                const offset = params != null ? (params.offset > 0 ? params.offset : 0) : 0;
                const fetchAttributes = params != null ? params.attributes : null;
                const filterCriterion = params != null ? params.filterCriterion : null;
                this.implOptions.generateKeysIfNeeded(() => this.generateKeys());
                let resultsArray = [];
                let done = true;
                if (params) {
                    const fetchParams = {
                        size,
                        sortCriteria,
                        filterCriterion,
                        attributes: fetchAttributes
                    };
                    const iteratorResults = this._fetchFrom(fetchParams, offset, true).result;
                    const newParams = iteratorResults.value.fetchParameters;
                    if (newParams.sortCriteria !== sortCriteria) {
                        params = { ...params, sortCriteria: newParams.sortCriteria };
                    }
                    const value = iteratorResults.value;
                    done = iteratorResults.done;
                    const data = value.data;
                    const keys = value.metadata.map((value) => value.key);
                    resultsArray = data.map((value, index) => {
                        return createItem(keys[index], value);
                    });
                    return resolve(Object.assign(markNoProxy({
                        fetchParameters: params,
                        results: resultsArray,
                        done
                    }), params?.includeFilteredRowCount === 'enabled'
                        ? { totalFilteredRowCount: this._getTotalFilteredRowCount(params) }
                        : null));
                }
                else {
                    return reject('Offset is a required parameter');
                }
            };
            return this.implOptions.supportAbortController
                ? ojdataprovider.wrapWithAbortHandling(params?.signal, callback, false)
                : // Using the syntax below as opposed to the more straightfoward
                    // "new Promise((resolve, reject) => callback(resolve, reject))"
                    // to allow Errors to be thrown rather than being turned into Promise rejections.
                    // This avoids what would be a (subtle) change in behavior in MADP
                    callback(Promise.resolve.bind(Promise), Promise.reject.bind(Promise));
        }
        /**
         * Fetch the first block of data
         */
        fetchFirst(params) {
            const offset = 0;
            return new this.AsyncIterable(new this.AsyncIterator(this, this._fetchFrom.bind(this), params, offset));
        }
        getTotalSize() {
            return Promise.resolve(this.implOptions.getData().length);
        }
        isEmpty() {
            return this.implOptions.getData().length > 0 ? 'no' : 'yes';
        }
        _getTotalFilteredRowCount(params) {
            const rowData = this.implOptions.getData();
            const filterDef = params ? params.filterCriterion : null;
            let totalFilteredRowCount = -1;
            if (filterDef) {
                totalFilteredRowCount = 0;
                // Always call getFilter to get a Filter instance, so any ArrayDataProvider options such as textFilterAttributes will work.
                // This effectively ignore any "filter" property passed in filterCriterion.
                let filterCriterion = ojdataprovider.FilterFactory.getFilter({
                    filterDef: filterDef,
                    filterOptions: this.options
                });
                for (let i = 0; i < rowData.length; i++) {
                    if (filterCriterion.filter(rowData[i])) {
                        ++totalFilteredRowCount;
                    }
                }
            }
            else {
                totalFilteredRowCount = rowData.length;
            }
            return totalFilteredRowCount;
        }
        /**
         * Get id value for row
         */
        getId(row) {
            let id;
            const keyAttributes = this.options?.keyAttributes;
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            if (keyAttributes != null) {
                if (Array.isArray(keyAttributes)) {
                    let i;
                    id = [];
                    for (i = 0; i < keyAttributes.length; i++) {
                        id[i] = getVal(row, keyAttributes[i]);
                    }
                }
                else if (keyAttributes === '@value') {
                    id = getAllVals(row);
                }
                else {
                    id = getVal(row, keyAttributes);
                }
                if (enforceKeyStringify === 'on') {
                    return JSON.stringify(id);
                }
                return id;
            }
            else {
                return null;
            }
        }
        generateKeys() {
            const keyAttributes = this.options?.keyAttributes;
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            const keys = [];
            const rowData = this.implOptions.getData();
            for (let i = 0; i < rowData.length; i++) {
                let id = this.getId(rowData[i]);
                if (id == null || keyAttributes === '@index') {
                    id =
                        enforceKeyStringify === 'on' ? JSON.stringify(this._sequenceNum++) : this._sequenceNum++;
                }
                keys.push(id);
            }
            return keys;
        }
        /**
         * Fetch from offset
         */
        _fetchFrom(params, offset, useHasMore, cacheObj) {
            const fetchAttributes = params != null ? params.attributes : null;
            this.implOptions.generateKeysIfNeeded(() => this.generateKeys());
            const sortCriteria = params != null ? params.sortCriteria : null;
            const indexMap = this._getCachedIndexMap(sortCriteria, cacheObj);
            const rowData = this.implOptions.getData();
            const keys = this.implOptions.getKeys();
            const mappedData = indexMap.map((index) => {
                const row = rowData[index];
                return row;
            });
            const mappedKeys = indexMap.map((index) => {
                return keys[index];
            });
            const fetchSize = params != null ? (params.size > 0 ? params.size : params.size < 0 ? keys.length : 25) : 25;
            let hasMore = offset + fetchSize < mappedData.length;
            const mergedSortCriteria = this.implOptions.mergeSortCriteria(sortCriteria);
            if (mergedSortCriteria != null) {
                params = { ...params, sortCriteria: mergedSortCriteria };
            }
            let resultData = [];
            let resultKeys = [];
            let updatedOffset = 0;
            let filteredResultData;
            if (params != null && params.filterCriterion) {
                let filterCriterion = null;
                // Always call getFilter to get a Filter instance, so any constructor options such as textFilterAttributes will work.
                // This effectively ignore any "filter" property passed in filterCriterion.
                filterCriterion = ojdataprovider.FilterFactory.getFilter({
                    filterDef: params.filterCriterion,
                    filterOptions: this.options
                });
                let i = 0;
                while (resultData.length < fetchSize && i < mappedData.length) {
                    if (filterCriterion.filter(mappedData[i])) {
                        // updatedOffset is the post-filtered offset
                        if (updatedOffset >= offset) {
                            resultData.push(mappedData[i]);
                            resultKeys.push(mappedKeys[i]);
                        }
                        updatedOffset++;
                    }
                    i++;
                }
                hasMore = i < mappedData.length;
            }
            else {
                resultData = mappedData.slice(offset, offset + fetchSize);
                resultKeys = mappedKeys.slice(offset, offset + fetchSize);
            }
            updatedOffset = offset + resultData.length;
            filteredResultData = resultData.map((row) => {
                if (fetchAttributes && fetchAttributes.length > 0) {
                    const updatedData = {};
                    filterRowAttributes(fetchAttributes, row, updatedData);
                    row = updatedData;
                }
                return row;
            });
            const resultMetadata = keyArrayToMetadataArray(resultKeys);
            const result = markNoProxy({
                fetchParameters: params,
                data: filteredResultData,
                metadata: resultMetadata
            });
            const done = !(useHasMore ? hasMore : result.data.length > 0);
            return {
                result: markNoProxy({
                    value: result,
                    done
                }),
                offset: updatedOffset
            };
        }
        /**
         * Get cached index map
         */
        _getCachedIndexMap(sortCriteria, cacheObj) {
            if (cacheObj &&
                cacheObj['indexMap'] &&
                cacheObj['mutationSequenceNum'] === this._mutationSequenceNum) {
                return cacheObj['indexMap'];
            }
            const dataIndexes = this.implOptions.getData().map((value, index) => {
                return index;
            });
            const indexMap = this._sortData(dataIndexes, sortCriteria);
            if (cacheObj) {
                cacheObj['indexMap'] = indexMap;
                cacheObj['mutationSequenceNum'] = this._mutationSequenceNum;
            }
            return indexMap;
        }
        /**
         * Sort data
         */
        _sortData(indexMap, sortCriteria) {
            const rowData = this.implOptions.getData();
            const indexedData = indexMap.map((index) => {
                return { index: index, value: rowData[index] };
            });
            if (sortCriteria != null) {
                indexedData.sort(this.implOptions.getSortComparator(sortCriteria));
            }
            return indexedData.map((item) => {
                return item.index;
            });
        }
        queueMutationEvent(changes) {
            this._mutationEvent = this._createMutationEvent(changes);
        }
        flushQueue() {
            this.implOptions.dispatchEvent(this._mutationEvent ?? new ojdataprovider.DataProviderRefreshEvent());
            this._mutationEvent = null;
        }
        _createMutationEvent(changes) {
            let i, j, id, index, status, dataArray = [], keyArray = [], indexArray = [];
            const afterKeyArray = [];
            let addCount = 0;
            let deleteCount = 0;
            this._mutationSequenceNum++;
            // first check if we only have adds or only have deletes
            let onlyAdds = true;
            let onlyDeletes = true;
            this._resetTotalFilteredRowCount = true;
            changes.forEach((change) => {
                if (change['status'] === 'deleted') {
                    onlyAdds = false;
                    ++deleteCount;
                }
                else if (change['status'] === 'added') {
                    onlyDeletes = false;
                    ++addCount;
                }
            });
            const updatedIndexes = [];
            const removeDuplicate = [];
            let operationUpdateEventDetail = null;
            let operationAddEventDetail = null;
            let operationRemoveEventDetail = null;
            const generatedKeys = this.implOptions.generateKeysIfNeeded(() => this.generateKeys());
            if (!onlyAdds && !onlyDeletes) {
                // squash deletes and adds into updates
                for (i = 0; i < changes.length; i++) {
                    index = changes[i].index;
                    status = changes[i].status;
                    const iKey = this.getId(changes[i].value);
                    for (j = 0; j < changes.length; j++) {
                        if (j !== i &&
                            index === changes[j].index &&
                            status !== changes[j]['status'] &&
                            updatedIndexes.indexOf(i) < 0 &&
                            removeDuplicate.indexOf(i) < 0) {
                            // Squash delete and add only if they have the same index and either no key or same key
                            if (iKey == null || oj.Object.compareValues(iKey, this.getId(changes[j].value))) {
                                if (status === 'deleted') {
                                    removeDuplicate.push(i);
                                    updatedIndexes.push(j);
                                }
                                else {
                                    removeDuplicate.push(j);
                                    updatedIndexes.push(i);
                                }
                            }
                        }
                    }
                }
                for (i = 0; i < changes.length; i++) {
                    if (updatedIndexes.indexOf(i) >= 0) {
                        const key = this.implOptions.getKeys()[changes[i].index];
                        // By this time, updatedIndexes contains indexes of "added" entries in "changes" array that
                        // have matching "deleted" entries with same keys, which should be the same as the old keys.
                        keyArray.push(key);
                        dataArray.push(changes[i].value);
                        indexArray.push(changes[i].index);
                    }
                }
                if (keyArray.length > 0) {
                    operationUpdateEventDetail = markNoProxy({
                        keys: new ojSet(keyArray),
                        metadata: keyArrayToMetadataArray(keyArray),
                        data: dataArray,
                        indexes: indexArray
                    });
                }
            }
            dataArray = [];
            keyArray = [];
            indexArray = [];
            if (!onlyAdds) {
                for (i = 0; i < changes.length; i++) {
                    if (changes[i]['status'] === 'deleted' &&
                        updatedIndexes.indexOf(i) < 0 &&
                        removeDuplicate.indexOf(i) < 0) {
                        id = this.implOptions.getKeyForDelete(changes[i], generatedKeys);
                        keyArray.push(id);
                        dataArray.push(changes[i].value);
                        indexArray.push(changes[i].index);
                    }
                }
                if (keyArray.length > 0) {
                    keyArray.forEach((key) => {
                        const keyIndex = indexOfKey(key, this.implOptions.getKeys());
                        if (keyIndex >= 0) {
                            this.implOptions.spliceKeys(keyIndex, 1);
                        }
                    });
                }
                if (keyArray.length > 0) {
                    operationRemoveEventDetail = markNoProxy({
                        keys: new ojSet(keyArray),
                        metadata: keyArrayToMetadataArray(keyArray),
                        data: dataArray,
                        indexes: indexArray
                    });
                }
            }
            dataArray = [];
            keyArray = [];
            indexArray = [];
            if (!onlyDeletes) {
                const isInitiallyEmpty = this.implOptions.getKeys() != null
                    ? this.implOptions.getKeys().length > 0
                        ? false
                        : true
                    : true;
                for (i = 0; i < changes.length; i++) {
                    if (changes[i]['status'] === 'added' &&
                        updatedIndexes.indexOf(i) < 0 &&
                        removeDuplicate.indexOf(i) < 0) {
                        id = this.getId(changes[i].value);
                        if (id == null && (generatedKeys || this.implOptions.keysSpecified)) {
                            id = this.implOptions.getKeys()[changes[i].index];
                        }
                        if (id == null) {
                            id = this._sequenceNum++;
                            this.implOptions.spliceKeys(changes[i].index, 0, id);
                        }
                        else if (isInitiallyEmpty || indexOfKey(id, this.implOptions.getKeys()) === -1) {
                            this.implOptions.spliceKeys(changes[i].index, 0, id);
                        }
                        else if (!generatedKeys && !this.implOptions.keysSpecified) {
                            // If we get here, we have a duplicate key because the id is found in the _keys array,
                            // and it was neither just generated nor specified in the keys options.
                            // In this case we log a warning but should add the key to the _keys array to keep
                            // it in sync with the data array.  It is up to the app to ensure key uniqueness.
                            Logger.warn('added row has duplicate key ' + id);
                            this.implOptions.spliceKeys(changes[i].index, 0, id);
                        }
                        keyArray.push(id);
                        dataArray.push(changes[i].value);
                        indexArray.push(changes[i].index);
                    }
                }
                for (i = 0; i < changes.length; i++) {
                    if (changes[i]['status'] === 'added' &&
                        updatedIndexes.indexOf(i) < 0 &&
                        removeDuplicate.indexOf(i) < 0) {
                        // afterKeys can only be calculated after all keys
                        // have been added to the internal keys cache
                        let afterKey = this.implOptions.getKeys()[changes[i].index + 1];
                        afterKey = afterKey == null ? null : afterKey;
                        afterKeyArray.push(afterKey);
                    }
                }
                if (keyArray.length > 0) {
                    operationAddEventDetail = markNoProxy({
                        keys: new ojSet(keyArray),
                        afterKeys: new ojSet(afterKeyArray),
                        addBeforeKeys: afterKeyArray,
                        metadata: keyArrayToMetadataArray(keyArray),
                        data: dataArray,
                        indexes: indexArray
                    });
                }
            }
            // Adjust the last offset for iterators before firing event
            this._adjustIteratorOffset(operationRemoveEventDetail, operationAddEventDetail);
            return new ojdataprovider.DataProviderMutationEvent(markNoProxy({
                add: operationAddEventDetail,
                remove: operationRemoveEventDetail,
                update: operationUpdateEventDetail
            }));
        }
        resetTotalFilteredRowCount() {
            this._resetTotalFilteredRowCount = true;
        }
        /**
         * Adjust the last offset for iterators.
         */
        _adjustIteratorOffset(removeArray, addArray) {
            const removeIndexes = removeArray?.indexes;
            const addIndexes = addArray?.indexes.slice(0);
            this._mapClientIdToIteratorInfo.forEach((iteratorInfo, clientId) => {
                if (iteratorInfo.offset > 0) {
                    const filterCriterion = iteratorInfo.filterCriterion;
                    const sortCriteria = iteratorInfo.sortCriteria;
                    const sortComparator = sortCriteria
                        ? this.implOptions.getSortComparator(sortCriteria)
                        : null;
                    if (removeIndexes) {
                        removeIndexes.forEach((rowIndex, index) => {
                            const rowKey = Array.from(removeArray.keys)[index];
                            const fetchedRowIndex = indexOfKey(rowKey, iteratorInfo.fetchedRowKeys);
                            if (fetchedRowIndex > -1) {
                                --iteratorInfo.offset;
                                iteratorInfo.fetchedRowKeys.splice(fetchedRowIndex, 1);
                            }
                        });
                        iteratorInfo.rowKey = iteratorInfo.fetchedRowKeys[iteratorInfo.fetchedRowKeys.length - 1];
                    }
                    if (addIndexes) {
                        const addData = addArray.data.slice(0);
                        const addKeys = Array.from(addArray.keys);
                        // ignore all filtered items
                        if (filterCriterion?.filter != null) {
                            for (let i = addIndexes.length - 1; i >= 0; i--) {
                                let data = addData[i];
                                if (data != null && filterCriterion.filter(data)) {
                                    addIndexes.splice(i, 1);
                                    addData.splice(i, 1);
                                    addKeys.splice(i, 1);
                                }
                            }
                        }
                        if (sortComparator != null) {
                            // if sorted add all keys to array, sort array, and remove keys after last key
                            const newArray = [...iteratorInfo.fetchedRowKeys, ...addKeys];
                            const allData = this.implOptions.getData();
                            // We can use a plain map here instead of ojMap because the
                            // addKeys === _getKeys when this is called today
                            const indexOfKeyMap = new Map();
                            this.implOptions.getKeys().forEach((key, index) => {
                                indexOfKeyMap.set(key, index);
                            });
                            newArray.sort((key1, key2) => {
                                const key1Data = allData[indexOfKeyMap.get(key1)];
                                const key2Data = allData[indexOfKeyMap.get(key2)];
                                return sortComparator({ value: key1Data }, { value: key2Data });
                            });
                            iteratorInfo.fetchedRowKeys = newArray.slice(0, indexOfKey(iteratorInfo.rowKey, newArray) + 1);
                            iteratorInfo.offset = iteratorInfo.fetchedRowKeys.length;
                        }
                        else {
                            // if unsorted add data to position in add event if it's in range
                            addIndexes.forEach((rowIndex, index) => {
                                const rowKey = addKeys[index];
                                const lastFetchedRowIndex = indexOfKey(iteratorInfo.rowKey, this.implOptions.getKeys());
                                if (rowIndex < lastFetchedRowIndex) {
                                    ++iteratorInfo.offset;
                                    const fetchedRowIndex = indexOfKey(rowKey, iteratorInfo.fetchedRowKeys);
                                    if (fetchedRowIndex < 0) {
                                        iteratorInfo.fetchedRowKeys.splice(rowIndex, 0, rowKey);
                                    }
                                }
                            });
                        }
                    }
                    this._mapClientIdToIteratorInfo.set(clientId, iteratorInfo);
                }
            });
        }
    }

    exports.ArrayDataProviderImpl = ArrayDataProviderImpl;
    exports.createOptimizedKeyMap = createOptimizedKeyMap;
    exports.createOptimizedKeySet = createOptimizedKeySet;
    exports.getCapability = getCapability;
    exports.getVal = getVal;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojarraydataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojeventtarget', 'ojs/ojarraydataproviderimpl'], function (oj, ojdataprovider, ojeventtarget, ojarraydataproviderimpl) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 4.1.0
     * @export
     * @final
     * @class ArrayDataProvider
     * @implements DataProvider
     * @classdesc Note usage of {@link MutableArrayDataProvider} is preferred over ArrayDataProvider as it removes the dependency on knockout. This class implements {@link DataProvider}.
     *            Object representing data available from an array or observableArray. If a plain array is used then it is considered to be immutable.
     *            If an observableArray is used then for mutations, please use the observableArray functions or always call valueHasMutated() if
     *            mutating the underlying array. The decision on whether to use an array or observableArray should therefore be guided
     *            by whether the data will be mutable. This dataprovider can be used by [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
     *            [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
     *            See the ArrayDataProvider and Table - Base Table demos for examples.<br><br>
     *            The default sorting algorithm used when a sortCriteria is passed into fetchFirst is natural sort.
     *
     * <h3 id="events-section">
     *   Events
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
     * </h3>
     * Consumers can add event listeners to listen for the following event types and respond to data change.
     * <h4 id="event:mutate" class="name">
     *   mutate
     * </h4>
     * This event is fired when items have been added or removed from the data.
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>, which implements the {@link DataProviderMutationEventDetail} interface.
     * </p>
     *
     * <h4 id="event:refresh" class="name">
     *   refresh
     * </h4>
     * This event is fired when the data has been refreshed and components need to re-fetch the data.
     * <p>
     * This event contains no additional event payload.
     * </p>
     *
     * <i>Example of consumer listening for the "mutate" event type:</i>
     * <pre class="prettyprint"><code>let listener = function(event) {
     *   if (event.detail.remove) {
     *     const removeDetail = event.detail.remove;
     *     // Handle removed items
     *   }
     * };
     * dataProvider.addEventListener("mutate", listener);
     * </code></pre>
     *
     * @param {(Array|function():Array)} data data supported by the components
     *                                      <p>This can be either an Array, or a Knockout observableArray.</p>
     * @param {ArrayDataProvider.DeprecatedOptions=} options Options for the ArrayDataProvider
     * @ojsignature [{target: "Type",
     *               value: "class ArrayDataProvider<K, D> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "ArrayDataProvider.Options<K, D> | ArrayDataProvider.DeprecatedOptions<D>",
     *               for: "options"}
     * ]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     * "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     * "FetchListResult","FetchListParameters"]}
     * @ojtsmodule
     * @ojtsexample
     * // First initialize an array
     * let deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
     *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
     *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
     * // Then create an ArrayDataProvider object with the array
     * let dataprovider = new ArrayDataProvider(deptArray, {keyAttributes: 'DepartmentId'});
     * @example
     * // First initialize an array
     * const deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
     *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
     *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
     * // Then create an ArrayDataProvider object with the array
     * const dataprovider = new ArrayDataProvider(deptArray, {keyAttributes: 'DepartmentId'});
     * @ojtsexample
     * // Data and Key array
     * let deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
     *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
     *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
     * let keysArray = [10, 20, 30];
     * let dataprovider = new ArrayDataProvider(deptArray, {keyAttributes: 'DepartmentId', keys: keysArray});
     * @example
     * // Data and Key array
     * const deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
     *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
     *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
     * const keysArray = [10, 20, 30];
     * const dataprovider = new ArrayDataProvider(deptArray, {keyAttributes: 'DepartmentId', keys: keysArray});
     */

    /**
     * @typedef {Object} ArrayDataProvider.Options
     * @property {ArrayDataProvider.SortComparators=} sortComparators - Optional sortComparator for custom sort.
     * <p>
     * Sort follows JavaScript's localeCompare <code>{numeric: true}</code>.
     * Please check {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#numeric_sorting|String.prototype.localeCompare()} for details.
     * </p>
     * <p>
     * For numbers, we convert them into strings then compare them with localeCompare, which may not sort floating point numbers based on their numeric values.
     * If you want to sort floating point numbers based on their numeric values, sortComparator can be used to do a custom sort.
     * </p>
     * <p>
     * For undefined and null values, they are considered as the largest values during sorting. For an empty string, it is considered as the smallest value during sorting.
     * </p>
     * @property {SortCriterion=} implicitSort - Optional array of {@link SortCriterion} used to specify sort information when the data loaded into the dataprovider is already sorted.
     * This is used for cases where we would like display some indication that the data is already sorted.
     * For example, ojTable will display the column sort indicator for the corresponding column in either ascending or descending order upon initial render.
     * This option is not used for cases where we want the ArrayDataProvider to apply a sort on initial fetch.
     * For those cases, please wrap in a ListDataProviderView and set the sortCriteria property on it.
     * @property {any=} keys - Optional keys for the data. If not supplied, then the keys are generated according options.keyAttributes. If that is also not supplied then index is used as key.
     *                                                 <p>If this option is specified, the caller is responsible for maintaining both the keys and data arrays to keep them in sync.
     *                                                 When the data need to be changed, the corresponding changes must be made to the keys array first before the data change.</p>
     * @property {string=} keyAttributes - Optionally the field name which stores the key in the data. Can be a string denoting a single key attribute or an array
     *                                                  of strings for multiple key attributes. Please note that the ids in ArrayDataProvider must always be unique. Please do not introduce duplicate ids, even during temporary mutation operations. @index causes ArrayDataProvider to use index as key and @value will cause ArrayDataProvider to
     *                                                  use all attributes as key. @index is the default.
     *                                                  <p>With "@index", the key generation is based on the item index only initially.  The key for an item, once assigned,
     *                                                  will not change even if the item index changes (e.g. by inserting/removing items from the array).  Assigned keys will
     *                                                  never be reassigned.  If the array is replaced with new items, the new items will be assigned keys that are different
     *                                                  from their indices.  In general, caller should specify keyAttributes whenever possible and should never assume that the
     *                                                  generated keys are the same as the item indices.</p>
     *                                                  <p>This option is ignored if the "keys" option is specified.</p>
     * @property {string=} textFilterAttributes - Optionally specify which attributes the filter should be applied on when a TextFilter filterCriteria is specified. If this option is not specified then the filter will be applied to all attributes.
     * @property {string=} enforceKeyStringify - Optionally specify whether keys need to be converted to strings. Supported values:<br>
     *                                  <ul>
     *                                    <li>'off': the key values are returned as it is.
     *                                    <li>'on': the key values are converted into string.
     *                                  </ul>
     *                                Default is 'off'.
     *                                Key stringify will directly call JSON.stringify on all keys passed out of the DataProvider. Use JSON.parse if you need to convert the key back to a complex type.
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "ArrayDataProvider.SortComparators<D>", for: "sortComparators"},
     *  {target: "Type", value: "Array<SortCriterion<D>>", for: "implicitSort"},
     *  {target: "Type", value: "K[] | (() => K[])", for: "keys"},
     *  {target: "Type", value: "string | string[]", for: "keyAttributes"},
     *  {target: "Type", value: "string[]", for: "textFilterAttributes"},
     *  {target: "Type", value: "'off' | 'on'", for: "enforceKeyStringify"}
     * ]
     * @ojtsexample <caption>Examples for sortComparator</caption>
     * // Custom comparator for date
     * let comparator = function (a, b) {
     *    if (a === b) {
     *      return 0;
     *    }
     *
     *    const dateA = new Date(a).getTime();
     *    const dateB = new Date(b).getTime();
     *    return dateA > dateB ? 1 : -1;
     * };
     * // Then create an ArrayDataProvider object and set Date field to use the this comparator
     * this.dataprovider = new ArrayDataProvider(JSON.parse(deptArray), {
     *    keyAttributes: "DepartmentId",
     *    sortComparators: { comparators: new Map().set("Date", comparator) },
     * });
     * @ojtsexample
     * // Custom comparator for number
     * let comparator = function (a, b) {
     *    return a - b;
     *  };
     * // Then create an ArrayDataProvider object and set Salary field to use the this comparator
     * this.dataprovider = new ArrayDataProvider(JSON.parse(deptArray), {
     *    keyAttributes: "DepartmentId",
     *    sortComparators: { comparators: new Map().set("Salary", comparator) },
     * });
     */

    /**
     * @typedef {Object} ArrayDataProvider.DeprecatedOptions
     * @property {ArrayDataProvider.SortComparators=} sortComparators - Optional sortComparator to use for sort.
     * @property {SortCriterion=} implicitSort - Optional array of {@link SortCriterion} used to specify sort information when the data loaded into the dataprovider is already sorted.
     * This is used for cases where we would like display some indication that the data is already sorted.
     * For example, ojTable will display the column sort indicator for the corresponding column in either ascending or descending order upon initial render.
     * This option is not used for cases where we want the ArrayDataProvider to apply a sort on initial fetch.
     * For those cases, please wrap in a ListDataProviderView and set the sortCriteria property on it.
     * @property {any=} keys - Optional keys for the data. If not supplied, then the keys are generated according options.keyAttributes. If that is also not supplied then index is used as key.
     *                                                 <p>If this option is specified, the caller is responsible for maintaining both the keys and data arrays to keep them in sync.
     *                                                 When the data need to be changed, the corresponding changes must be made to the keys array first before the data change.</p>
     * @property {string=} idAttribute - <span class="important">Deprecated: this option is deprecated and will be removed in the future.
     *                                                  Please use the keyAttributes option instead.</span><br><br>
     *                                                  Optionally the field name which stores the id in the data. Can be a string denoting a single key attribute or an array
     *                                                  of strings for multiple key attributes. Dot notation can be used to specify nested attribute (e.g. 'attr.id'). Please note that the ids in ArrayDataProvider must always be unique. Please do not introduce duplicate ids, even during temporary mutation operations.
     *                                                  @index causes ArrayDataProvider to use index as key and @value will cause ArrayDataProvider to
     *                                                  use all attributes as key. @index is the default.
     * @property {string=} keyAttributes - Optionally the field name which stores the key in the data. Can be a string denoting a single key attribute or an array
     *                                                  of strings for multiple key attributes. Please note that the ids in ArrayDataProvider must always be unique. Please do not introduce duplicate ids, even during temporary mutation operations. @index causes ArrayDataProvider to use index as key and @value will cause ArrayDataProvider to
     *                                                  use all attributes as key. @index is the default.
     *                                                  <p>With "@index", the key generation is based on the item index only initially.  The key for an item, once assigned,
     *                                                  will not change even if the item index changes (e.g. by inserting/removing items from the array).  Assigned keys will
     *                                                  never be reassigned.  If the array is replaced with new items, the new items will be assigned keys that are different
     *                                                  from their indices.  In general, caller should specify keyAttributes whenever possible and should never assume that the
     *                                                  generated keys are the same as the item indices.</p>
     *                                                  <p>This option is ignored if the "keys" option is specified.</p>
     * @property {string=} textFilterAttributes - Optionally specify which attributes the filter should be applied on when a TextFilter filterCriteria is specified. If this option is not specified then the filter will be applied to all attributes.
     * @ojsignature [
     *  {target: "Type", value: "<D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "ArrayDataProvider.SortComparators<D>", for: "sortComparators"},
     *  {target: "Type", value: "Array<SortCriterion<D>>", for: "implicitSort"},
     *  {target: "Type", value: "any", for: "keys"},
     *  {target: "Type", value: "string|string[]", for: "idAttribute"},
     *  {target: "Type", value: "string|string[]", for: "keyAttributes"},
     *  {target: "Type", value: "string[]", for: "textFilterAttributes"},
     * ]
     * @ojdeprecated {since: '10.1.0', description: 'Use ArrayDataProvider.Options instead.'}
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof ArrayDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    /**
     * A static method that determines whether this DataProvider defines a certain feature.
     *
     * @since 14.0.0
     * @param {string} capabilityName capability name. Defined capability names are:
     *                  "dedup", "eventFiltering", "fetchByKeys", "fetchByOffset", "fetchCapability", "fetchFirst", "filter", and "sort".
     * @return {Object} capability information or null if undefined
     * @export
     * @expose
     * @instance
     * @memberof ArrayDataProvider
     * @name getCapability
     * @static
     * @method
     * @ojsignature {target: "Type",
     *               value: "(capabilityName: string): any"}
     *
     */

    class ArrayDataProvider {
        constructor(data, options) {
            this.data = data;
            this.options = options;
            this._subscribeObservableArray(data);
            let keysSpecified = false;
            if (options != null && options.keys != null) {
                const enforceKeyStringify = options.enforceKeyStringify;
                keysSpecified = true;
                this._keys =
                    enforceKeyStringify === 'on'
                        ? options.keys.map((key) => JSON.stringify(key))
                        : options.keys;
            }
            this._impl = new ojarraydataproviderimpl.ArrayDataProviderImpl(
            // VB ADP + ADP2 don't specify keyAttributes or idAttribute until activate() gets called
            // so we have to do our normalization of these options lazily.
            {
                ...options,
                get keyAttributes() {
                    return options?.keyAttributes ?? options?.idAttribute;
                }
            }, {
                getData: () => this._getRowData(),
                getKeys: () => this._getKeys(),
                generateKeysIfNeeded: (generateKeys) => this._generateKeysIfNeeded(generateKeys),
                mergeSortCriteria: (sortCriteria) => this._mergeSortCriteria(sortCriteria),
                getSortComparator: (sortCriteria) => this._getSortComparator(sortCriteria),
                dispatchEvent: (event) => this.dispatchEvent(event),
                supportAbortController: true,
                getKeyForDelete: (change, generatedKeys) => this._getKeyForDelete(change, generatedKeys),
                spliceKeys: (...args) => this._keys.splice(...args),
                keysSpecified
            });
        }
        containsKeys(containsParameters) {
            return this._impl.containsKeys(containsParameters);
        }
        fetchByKeys(fetchParameters) {
            return this._impl.fetchByKeys(fetchParameters);
        }
        fetchByOffset(params) {
            return this._impl.fetchByOffset(params);
        }
        /**
         * Fetch the first block of data
         */
        fetchFirst(params) {
            return this._impl.fetchFirst(params);
        }
        /**
         * Determines whether this DataProvider supports certain feature.
         */
        getCapability(capabilityName) {
            return ojarraydataproviderimpl.getCapability(capabilityName);
        }
        static getCapability(capabilityName) {
            return ojarraydataproviderimpl.getCapability(capabilityName);
        }
        getTotalSize() {
            return this._impl.getTotalSize();
        }
        isEmpty() {
            return this._impl.isEmpty();
        }
        /**
         * Return an empty Set which is optimized to store keys
         */
        createOptimizedKeySet(initialSet) {
            return ojarraydataproviderimpl.createOptimizedKeySet(initialSet);
        }
        /**
         * Returns an empty Map which will efficiently store Keys returned by the DataProvider
         */
        createOptimizedKeyMap(initialMap) {
            return ojarraydataproviderimpl.createOptimizedKeyMap(initialMap);
        }
        /**
         * Get the rows data, unwrapping observableArray if needed.
         */
        _getRowData() {
            return unwrapArrayIfNeeded(this.data);
        }
        /**
         * Get the keys, unwrapping observableArray if needed.
         */
        _getKeys() {
            return unwrapArrayIfNeeded(this._keys);
        }
        /**
         * If observableArray, then subscribe to it
         */
        _subscribeObservableArray(data) {
            if (!(data instanceof Array)) {
                if (!this._isObservableArray(data)) {
                    // we only support Array or ko.observableArray
                    throw new Error('Invalid data type. ArrayDataProvider only supports Array or observableArray.');
                }
                // subscribe to observableArray arrayChange event to get individual updates
                data['subscribe']((changes) => this._impl.queueMutationEvent(changes), null, 'arrayChange');
                data['subscribe']((changes) => this._impl.flushQueue(), null, 'change');
            }
        }
        _getKeyForDelete(change, generatedKeys) {
            // ArrayDataProvider might receive array changes containing deletes before any
            // fetch has been issued.  In this case, it never generated a key for the original
            // array and must derive it from the data in the change
            let id = this._impl.getId(change.value);
            if (id == null) {
                if (generatedKeys) {
                    id = change.index;
                }
                else {
                    id = this._getKeys()[change.index];
                }
            }
            return id;
        }
        /**
         * Check if observableArray
         */
        _isObservableArray(obj) {
            return typeof obj === 'function' && obj.subscribe && !(obj['destroyAll'] === undefined);
        }
        /**
         * Generate keys array if it wasn't passed in options.keys
         */
        _generateKeysIfNeeded(generateKeys) {
            if (this._keys == null) {
                this._keys = generateKeys();
                return true;
            }
            return false;
        }
        /**
         * Apply sort comparators
         */
        _getSortComparator(sortCriteria) {
            return (x, y) => {
                const sortComparators = this.options != null ? this.options.sortComparators : null;
                let i, direction, attribute, comparator, xval, yval;
                for (i = 0; i < sortCriteria.length; i++) {
                    direction = sortCriteria[i].direction;
                    attribute = sortCriteria[i].attribute;
                    comparator = null;
                    if (sortComparators != null) {
                        comparator = sortComparators.comparators.get(attribute);
                    }
                    xval = ojarraydataproviderimpl.getVal(x.value, attribute);
                    yval = ojarraydataproviderimpl.getVal(y.value, attribute);
                    if (!comparator) {
                        comparator = ojdataprovider.SortUtils.getNaturalSortComparator();
                    }
                    const descendingResult = direction === 'descending' ? -1 : 1;
                    const comparatorResult = comparator(xval, yval) * descendingResult;
                    if (comparatorResult !== 0) {
                        return comparatorResult;
                    }
                }
                return 0;
            };
        }
        /**
         * Merge sort criteria
         */
        _mergeSortCriteria(sortCriteria) {
            const implicitSort = this.options != null ? this.options.implicitSort : null;
            if (implicitSort != null) {
                if (sortCriteria == null) {
                    return implicitSort;
                }
            }
            else {
                return sortCriteria;
            }
        }
    }
    const unwrapArrayIfNeeded = (arr) => {
        return arr && !(arr instanceof Array) ? arr() : arr;
    };
    ojeventtarget.EventTargetMixin.applyMixin(ArrayDataProvider);
    oj._registerLegacyNamespaceProp('ArrayDataProvider', ArrayDataProvider);

    return ArrayDataProvider;

});


define('ojs/ojarraytreedataprovider',['ojs/ojcore-base', 'ojs/ojarraydataprovider', 'ojs/ojeventtarget', 'ojs/ojlogger'], function (oj, ArrayDataProvider, ojeventtarget, Logger) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  ArrayDataProvider = ArrayDataProvider && Object.prototype.hasOwnProperty.call(ArrayDataProvider, 'default') ? ArrayDataProvider['default'] : ArrayDataProvider;

  /**
   * @preserve Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  /* jslint browser: true,devel:true*/
  /**
   *
   * @since 5.1.0
   * @export
   * @final
   * @class ArrayTreeDataProvider
   * @implements TreeDataProvider
   * @classdesc Note usage of {@link MutableArrayTreeDataProvider} is preferred over ArrayTreeDataProvider as it removes the dependency on knockout.
   *            This class implements {@link TreeDataProvider} and is used to represent hierarchical data available from an array.<br><br>
   *            Each array element represents a tree node, which can contain nested child object array for its subtree.
   *            Array elements can be in any shape and form, but is usually an object with a "children" property.  The name of the "children" property
   *            can optionally be specified with the "childrenAttribute" option.<br><br>
   *            For nodes that cannot have children, the "children" property should not be set.
   *            For nodes that can but don't have children, the "children" property should be set to an empty array.<br><br>
   *            Data can be passed as a regular array or a Knockout observableArray.  If a Knockout observableArray is
   *            used, any mutation must be performed with observableArray methods.<br/><br/>
   *            ArrayTreeDataProvider subscribes to all changes of Knockout observableArrays including root and any children observableArrays.<br/><br/>
   *            The events described below will be dispatched to the ArrayTreeDataProvider with the appropriate event payload.<br><br>
   *            Filtering is supported and, by default, applied only on leaf nodes. Empty tree nodes are not collapsed.
   *            The filtering on leaf nodes only works by combining the passed in filter definition with an OR expression
   *            of the "children" property to determine if a node is a tree or leaf.
   *
   * <h3 id="events-section">
   * Events
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
   * </h3>
   * <p>Consumers can add event listeners to listen for the following event types and respond to data change.
   * Event listeners should be added to the root-level ArrayTreeDataProvider created by the application. The root-level ArrayTreeDataProvider receives events for the entire tree.
   * Child-level ArrayTreeDataProvider returned by getChildDataProvider does not receive events.
   * </p>
   * <h4 id="event:mutate" class="name">
   * mutate
   * </h4>
   * This event is fired when items are added to, removed from, or updated in an observableArray.  The event is the observableArray specific.
   * <p>
   * Event payload is found under <code class="prettyprint">event.detail</code>, which implements the {@link DataProviderMutationEventDetail} interface.
   * </p>
   *
   * <h4 id="event:refresh" class="name">
   *   refresh
   * </h4>
   * <p>
   * This event with no payload is fired when the data has been refreshed and components need to re-fetch the data.
   * In this case, the re-fetch is from the root.
   * </p>
   * <p>This event with payload 'keys' is fired when updated nodes include any changes in their children.  The 'keys' is
   * the set of keys of the nodes with changes in their children, and components need to re-fetch the sub-tree of 'keys'.
   * In this case, the re-fetch should be from each key.
   * </p>
   * <p>
   * Event payload is found under <code class="prettyprint">event.detail</code>,
   * which implements the {@link DataProviderRefreshEventDetail} interface.
   * </p>
   *
   * <i>Example of a tree structured data:</i>
   * <pre class="prettyprint"><code>
   * // initiate a nested observable array
   * const obData = ko.observableArray([
   *   {title:"News", id:"news"},
   *   {title:"Blogs", id:"blogs", "children": ko.observableArray([
   *     {title:"Today", id:"today"},
   *     {title:"Yesterday", id:"yesterday"},
   *     {title:"Archive", id:"archive"}
   *   ])}
   * ]);
   * </code></pre>
   *
   * <p>With the data above, the following are actions on an observableArray and events expected.
   * </p>
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th width='15%'>Action</th>
   *       <th width='30%'>Data Mutation</th>
   *       <th width='20%'>Example</th>
   *       <th width='20%'>Code</th>
   *       <th width='15%'>Expected Events</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>add a node as a sibling</kbd></td>
   *       <td>Action is an 'add' on the observableArray containing the node.    This action has no impact to the parent node.</td>
   *       <td>Add sibling 'Links' to root level</td>
   *       <td>obData.push({title: "Links", id: "links"});</td>
   *       <td>'mutate' with 'add' for node</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>remove a node</kbd></td>
   *       <td>Action is a 'remove' on the observableArray containing the node.  This action has no impact to the parent node.</td>
   *       <td>Remove node 'Links'</td>
   *       <td>obData.splice(2,1);</td>
   *       <td>'mutate' with 'remove' for node</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>add a child to a leaf node </kbd></td>
         <td>The node doesn't have any children (null or undefined),
    action is an 'update' on the observableArray containing the node
    which replaces the node with a new node of the same value plus the child under it.</td>
   *       <td>Add a child under 'News'</td>
   *       <td>const newNode = obData.slice(0,1);<br/>
  newNode["children"] = new ko.observableArray([{title: "Child1", id: "child1"}]);<br/>
  obData.splice(0, 1, newNode);</td>
   *       <td>'mutate' with 'update' for parent<br/>
  'refresh' with 'keys' for parent</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Add a child to a non-leaf node </kbd></td>
   *       <td>The node already has children (including []) which is an observableArray,
   action is actually 'add a sibling to a node' where the node is one of the children node</td>
   *       <td>Add another child under 'News'</td>
   *       <td>obData()[0].children.push({title: "Child2", id: "child2"});</td>
   *       <td>'mutate' with 'add' for child</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Update a node without children changes</kbd></td>
   *       <td>Action is an 'update' on the observableArray containing the node.</td>
   *       <td>Update node 'News' to 'OldNews'</td>
   *       <td>obData.splice(0,1,{title: "OldNews", id: "news"});</td>
   *       <td>'mutate' with 'update' for node</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Update a node with children changes</kbd></td>
   *       <td>Action is an 'update' on the observableArray containing the node. Refer to the above 'Add a child to a node' as an example.
   The children changes could be any changes in the children of the node.</td>
   *       <td></td>
   *       <td></td>
   *       <td>'mutate' with 'update' for parent<br/>
  'refresh' with 'keys' for parent</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Reorder or move a node</kbd></td>
   *       <td>Action is a 'remove' on the original observableArray containing the node, and an 'add a child to a leaf node'
   if new parent is a leaf node, or 'Add a child to a non-leaf node' if the new parent is a non-leaf node.</td>
   *       <td>Move node 'Today' from 'Blogs' to 'News'</td>
   *       <td>const moveNode = obData()[1].children.splice(0,1);<br/>
  obData()[0].children.push(moveNode);</td>
   *       <td>'mutate' with 'remove' for node <br/>
  'mutate' with 'add' for node</td>
   *     </tr>
   *   </tbody>
   * </table>
   * <br/>
   *
   <i>Example of consumer listening for the events:</i>
   * <pre class="prettyprint"><code>
   * dataProvider.addEventListener("mutate", handleMutate);
   * dataProvider.addEventListener("refresh", handleRefresh);
   *
   * const handleMutate = function(event) {
   *   if (event.detail.remove) {
   *     const removeDetail = event.detail.remove;
   *     // Handle removed items
   *   }
   * };
   *
   * const handleRefresh = function(event) {
   *   const detail=event.detail;
   *   if (detail && detail.keys) {
   *     event.detail.keys.forEach ((key) => {
   *       // refresh children for key
   *     });
   *   }
   *   else {
   *     // refresh children for root
   *   }
   * }
   * </code></pre>
   *
   * <i>Example of when 'mutate' or 'refresh' event will be fired:</i>
   * <pre class="prettyprint"><code>
   * // initiate a nested observable array
   * const obData = ko.observableArray([
   *   {title:"News", id:"news"},
   *   {title:"Blogs", id:"blogs", "children": ko.observableArray([
   *     {title:"Today", id:"today"},
   *     {title:"Yesterday", id:"yesterday"},
   *     {title:"Archive", id:"archive"}
   *   ])}
   * ]);
   *
   * // add a new node to children of 'Blogs' by adding directly to the observableArray obData()[1].children.
   * // 'mutate' event with add will be fired on observableArray obData()[1].children.
   * const newNode = {title: 'Future', id: 'future'};
   * obData()[1].children.push(newNode);
   *
   * // add a new node to children of 'Blogs' by updating the node 'Blogs' of the observableArray obData with updated children.
   * // 'mutate' event with update will be fired on observableArray obData.
   * // 'refresh' event with 'keys' as 'blogs' will be fired since the children of 'blogs' is changed.
   * const newBlogsNode = {title:"Blogs", id:"blogs", "children": ko.observableArray([
   *     {title:"Today", id:"today"},
   *     {title:"Yesterday", id:"yesterday"},
   *     {title:"Archive", id:"archive"},
   *     newNode
   *   ])};
   * obData.splice(1, 1, newBlogsNode);
   * </code></pre>
   *
   * <p>Observe that these two ways of mutating data result to the same final data.  The observableArray methods apply to different observableArray
   * results to different events fired.
   * </p>
   *
   * @param {(Array|function():Array)} data data supported by the components
   *                                      <p>This can be either an Array, or a Knockout observableArray.</p>
   * @param {ArrayTreeDataProvider.Options=} options Options for the ArrayTreeDataProvider
   * @ojsignature [{target: "Type",
   *               value: "class ArrayTreeDataProvider<K, D> implements TreeDataProvider<K, D>",
   *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
   *               {target: "Type",
   *               value: "ArrayTreeDataProvider.Options<D>",
   *               for: "options"}
   * ]
   * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: "TreeDataProvider"}
   * @ojtsimport {module: "ojarraydataprovider", type: "AMD", importName: "ArrayDataProvider"}
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion",
   *   "FetchByKeysParameters","ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters", "FetchByOffsetResults",
   *   "FetchListResult","FetchListParameters"]}
   * @ojtsmodule
   * @example
   * // First initialize the tree data.  This can be defined locally or read from file.
   * const treeData = [
   *                  {"attr": {"id": "dir1", "title": "Directory 1"},
   *                   "children": [
   *                     {"attr": {"id": "subdir1", "title": "Subdirectory 1"},
   *                      "children": [
   *                        {"attr": {"id": "file1", "title": "File 1"}},
   *                        {"attr": {"id": "file2", "title": "File 2"}},
   *                        {"attr": {"id": "file3", "title": "File 3"}}
   *                      ]},
   *                     {"attr": {"id": "subdir2", "title": "Subdirectory 2"},
   *                      "children": []}
   *                   ]},
   *                  {"attr": {"id": "dir2", "title": "Directory 2"},
   *                   "children": [
   *                     {"attr": {"id": "file4", "title": "File 4"}},
   *                     {"attr": {"id": "file5", "title": "File 5"}},
   *                   ]}
   *                ];
   *
   * // Then create an ArrayTreeDataProvider object with the array
   * const dataprovider = new ArrayTreeDataProvider(treeData, {keyAttributes: 'attr.id'});
   */

  /**
   * @typedef {Object} ArrayTreeDataProvider.Options
   * @property {ArrayDataProvider.SortComparators=} sortComparators - Optional sortComparator to use for sort.
   * @property {SortCriterion=} implicitSort - Optional array of {@link SortCriterion} used to specify sort information when the data loaded into the dataprovider is already sorted.
   * This is used for cases where we would like display some indication that the data is already sorted.
   * For example, ojTable will display the column sort indicator for the corresponding column in either ascending or descending order upon initial render.
   * This option is not used for cases where we want the ArrayDataProvider to apply a sort on initial fetch.
   * For those cases, please wrap in a ListDataProviderView and set the sortCriteria property on it.
   * @property {string=} keyAttributes - Optionally the field name which stores the key in the data. Can be a string denoting a single key attribute or an array
   *                                                  of strings for multiple key attributes. Please note that the ids in ArrayDataProvider must always be unique. Please do not introduce duplicate ids, even during temporary mutation operations. @index causes ArrayDataProvider to use index as key and @value will
   *                                                  build an array of values from all enumerable attributes found on the data as the key. @index is the default.
   *                                                  <p>With "@index", the key generation is based on the item index only initially.  The key for an item, once assigned,
   *                                                  will not change even if the item index changes (e.g. by inserting/removing items from the array).  Assigned keys will
   *                                                  never be reassigned.  If the array is replaced with new items, the new items will be assigned keys that are different
   *                                                  from their indices.  In general, caller should specify keyAttributes whenever possible and should never assume that the
   *                                                  generated keys are the same as the item indices.</p>
   *                                                  <p>This option is ignored if the "keys" option is specified.</p>
   * @property {string=} textFilterAttributes - Optionally specify which attributes the filter should be applied on when a TextFilter filterCriteria is specified. If this option is not specified then the filter will be applied to all attributes.
   * @property {string=} keyAttributesScope - Optional scope of the key values in the fields specified by keyAttributes.  Supported values:<br>
   *                                           <ul>
   *                                             <li>'global': the key values are unique within the entire tree.
   *                                             <li>'siblings': the key values are unique among the siblings of each node.
   *                                           </ul>
   *                                           Default is 'global'.
   * @property {string=} childrenAttribute - Optional field name which stores the children of nodes in the data. Dot notation can be used to specify nested attribute. If this is not specified, the default is "children".
   * @property {string=} enforceKeyStringify - Optionally specify whether keys should be stringified version of keypath from root. Supported values:<br>
   *                                  <ul>
   *                                    <li>'off': the key values are returned as it is.
   *                                    <li>'on': the key values are stringified version of keypath from root unless useKeyPath is set to 'off'.
   *                                  </ul>
   *                                Default is 'off'.
   *                                Key stringify will directly call JSON.stringify on all keys passed out of the DataProvider. Use JSON.parse if you need to convert the key back to a complex type.
   *                                When used with useKeyPaths the JSON.stringify will happen after the pathing is finished. JSON.parse will then result in an K[]
   * @property {string=} useKeyPaths - Optionally indicate to the TreeDataProvider to generate key paths. Key paths will be represented as an array of type K[] (unless used with enforceKeyStringify - see enforceKeyStringify for more details)
   * with elements ordered according to their depth. Specifically, the first element in the array corresponds to the least depth, and subsequent elements represent increasing depths.
   * @ojsignature [
   *  {target: "Type", value: "<D>", for: "genericTypeParameters"},
   *  {target: "Type", value: "ArrayDataProvider.SortComparators<D>", for: "sortComparators"},
   *  {target: "Type", value: "Array<SortCriterion<D>>", for: "implicitSort"},
   *  {target: "Type", value: "string | Array<string>", for: "keyAttributes"},
   *  {target: "Type", value: "string[]", for: "textFilterAttributes"},
   *  {target: "Type", value: "'siblings' | 'global'", for: "keyAttributesScope"},
   *  {target: "Type", value: "string", for: "childrenAttribute"},
   *  {target: "Type", value: "'off' | 'on'", for: "enforceKeyStringify"},
   *  {target: "Type", value: "'off' | 'on'", for: "useKeyPaths"}
   * ]
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name getChildDataProvider
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name containsKeys
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name fetchFirst
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name fetchByKeys
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name fetchByOffset
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name getCapability
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name getTotalSize
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name isEmpty
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name createOptimizedKeySet
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name createOptimizedKeyMap
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name addEventListener
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name removeEventListener
   */

  /**
   * @inheritdoc
   * @memberof ArrayTreeDataProvider
   * @instance
   * @method
   * @name dispatchEvent
   */

  // end of jsdoc

  class ArrayTreeDataProvider {
      constructor(treeData, options, _rootDataProvider) {
          var _a;
          this.treeData = treeData;
          this.options = options;
          this._rootDataProvider = _rootDataProvider;
          this.TreeAsyncIterator = class {
              constructor(_parent, _baseIterable) {
                  this._parent = _parent;
                  this._baseIterable = _baseIterable;
              }
              ['next']() {
                  return this._baseIterable[Symbol.asyncIterator]()
                      .next()
                      .then((result) => {
                      const metadata = result.value.metadata;
                      for (let i = 0; i < metadata.length; i++) {
                          metadata[i] = this._parent._getTreeMetadata(metadata[i], result.value.data[i]);
                      }
                      return result;
                  });
              }
          };
          this.TreeAsyncIterable = (_a = class {
                  constructor(_parent, _asyncIterator) {
                      this._parent = _parent;
                      this._asyncIterator = _asyncIterator;
                      this[Symbol.asyncIterator] = () => {
                          return this._asyncIterator;
                      };
                  }
              },
              Symbol.asyncIterator,
              _a);
          const adpOptions = { ...options };
          if (this.options?.enforceKeyStringify === 'on') {
              adpOptions.enforceKeyStringify = 'off';
          }
          this._baseDataProvider = new ArrayDataProvider(treeData, adpOptions);
          this._mapKeyToNode = new Map();
          this._mapNodeToKey = new Map();
          this._mapArrayToSequenceNum = new Map();
          this._mapKoArrayToSubscriptions = new Map();
          this._mapKeyToParentNodePath = new Map();
          this._parentNodeKeys = new Set();
          this._childrenAttr =
              this.options && this.options['childrenAttribute']
                  ? this.options['childrenAttribute']
                  : 'children';
          // Subscribe to all children observableArray at the top-level
          if (_rootDataProvider == null) {
              this._parentNodePath = [];
              this._processTreeArray(treeData, []);
          }
          else {
              this._getTreeKeys(this.treeData);
          }
      }
      containsKeys(params) {
          return this.fetchByKeys(params).then((fetchByKeysResult) => {
              const results = new Set();
              params['keys'].forEach((key) => {
                  if (fetchByKeysResult['results'].get(key) != null) {
                      results.add(key);
                  }
              });
              return Promise.resolve({ containsParameters: params, results });
          });
      }
      getCapability(capabilityName) {
          if (capabilityName === 'key') {
              const isStringifiedOn = this.options?.enforceKeyStringify === 'on';
              const isKeyPathingOn = this.options?.useKeyPaths === 'on' ||
                  this.options?.keyAttributesScope === 'siblings' ||
                  (isStringifiedOn && !this.options?.useKeyPaths);
              if (isKeyPathingOn) {
                  if (isStringifiedOn) {
                      return { structure: 'pathArrayString' };
                  }
                  return { structure: 'pathArray' };
              }
              return { structure: 'none' };
          }
          return this._baseDataProvider.getCapability(capabilityName);
      }
      getTotalSize() {
          return this._baseDataProvider.getTotalSize();
      }
      isEmpty() {
          return this._baseDataProvider.isEmpty();
      }
      /**
       * Return an empty Set which is optimized to store keys
       */
      createOptimizedKeySet(initialSet) {
          return this._baseDataProvider.createOptimizedKeySet(initialSet);
      }
      /**
       * Returns an empty Map which will efficiently store Keys returned by the DataProvider
       */
      createOptimizedKeyMap(initialMap) {
          return this._baseDataProvider.createOptimizedKeyMap(initialMap);
      }
      getChildDataProvider(parentKey, options) {
          const rootDP = this._getRootDataProvider();
          const node = this._getNodeForKey(parentKey);
          if (node) {
              const children = this._getChildren(node);
              if (children) {
                  const childDataProvider = new ArrayTreeDataProvider(children, this.options, rootDP);
                  if (childDataProvider != null) {
                      const enforceKeyStringify = this.options?.enforceKeyStringify;
                      const parentKeyString = enforceKeyStringify === 'on' ? parentKey : JSON.stringify(parentKey);
                      childDataProvider._parentNodePath = rootDP._mapKeyToParentNodePath.get(parentKeyString);
                      rootDP.addEventListener('refresh', (e) => {
                          childDataProvider._getTreeKeys(children);
                      });
                      rootDP.addEventListener('mutate', (e) => {
                          childDataProvider._getTreeKeys(children);
                      });
                  }
                  return childDataProvider;
              }
          }
          return null;
      }
      fetchFirst(params) {
          params = this._applyLeafNodeFilter(params);
          const baseIterable = this._baseDataProvider.fetchFirst(params);
          return new this.TreeAsyncIterable(this, new this.TreeAsyncIterator(this, baseIterable));
      }
      fetchByOffset(params) {
          params = this._applyLeafNodeFilter(params);
          const basePromise = this._baseDataProvider.fetchByOffset(params);
          return basePromise.then((result) => {
              // Repackage the results with tree node metadata
              const results = result.results;
              const newResults = [];
              for (const result of results) {
                  let metadata = result['metadata'];
                  const data = result['data'];
                  metadata = this._getTreeMetadata(metadata, data);
                  newResults.push({ data, metadata });
              }
              const data = {
                  done: result['done'],
                  fetchParameters: result['fetchParameters'],
                  results: newResults
              };
              if (params.includeFilteredRowCount === 'enabled') {
                  data['totalFilteredRowCount'] = result.totalFilteredRowCount;
              }
              return data;
          });
      }
      fetchByKeys(params) {
          const results = new Map();
          params['keys'].forEach((key) => {
              if (this._parentNodePath.length === 0 || this._parentNodeKeys.has(key)) {
                  const node = this._getNodeForKey(key);
                  if (node) {
                      results.set(key, { metadata: { key }, data: node });
                  }
              }
          });
          return Promise.resolve({ fetchParameters: params, results });
      }
      _getTreeKeys(treeData) {
          const arrTreeData = treeData instanceof Array ? treeData : treeData();
          for (const node of arrTreeData) {
              const key = this._getKeyForNode(node);
              this._parentNodeKeys.add(key);
              if (node[this._childrenAttr]) {
                  this._getTreeKeys(node[this._childrenAttr]);
              }
          }
      }
      _getChildren(node) {
          // Pass true to _getVal so that we keep observableArray children in the same form
          return this._getVal(node, this._childrenAttr, true);
      }
      _getRootDataProvider() {
          if (this._rootDataProvider) {
              return this._rootDataProvider;
          }
          else {
              return this;
          }
      }
      _subscribeObservableArray(treeData, parentKeyPath) {
          if (!(typeof treeData === 'function' &&
              treeData.subscribe &&
              treeData['destroyAll'] !== undefined)) {
              // we only support Array or ko.observableArray
              throw new Error('Invalid data type. ArrayTreeDataProvider only supports Array or observableArray.');
          }
          let mutationEvent = null;
          let refreshEvent = null;
          const subscriptions = new Array(2);
          // subscribe to observableArray arrayChange event to get individual updates
          subscriptions[0] = treeData['subscribe']((changes) => {
              let i, dataArray = [], keyArray = [], indexArray = [], metadataArray = [];
              let j, index;
              const updatedIndexes = [];
              let operationUpdateEventDetail = null;
              let operationAddEventDetail = null;
              let operationRemoveEventDetail = null;
              const refreshKeySet = new Set();
              // squash deletes and adds into updates
              const removeDuplicate = [];
              // update index for delete/add
              const changesCopy = [];
              for (let i = 0; i < changes.length; i++) {
                  changesCopy[i] = { index: changes[i]['index'], status: changes[i]['status'] };
              }
              for (let i = 0; i < changesCopy.length; i++) {
                  const index = changesCopy[i].index;
                  const status = changesCopy[i].status;
                  if (status === 'deleted') {
                      for (let j = 0; j < changesCopy.length; j++) {
                          if (changesCopy[j].status === 'deleted' && changesCopy[j].index > index) {
                              changesCopy[j].index--;
                          }
                      }
                  }
                  else if (status === 'added') {
                      for (let j = 0; j < changesCopy.length; j++) {
                          if (changesCopy[j].status === 'added' && changesCopy[j].index > index) {
                              changesCopy[j].index++;
                          }
                      }
                  }
              }
              for (i = 0; i < changesCopy.length; i++) {
                  index = changesCopy[i].index;
                  status = changesCopy[i].status;
                  const iKey = this._getId(changes[i].value);
                  if (iKey) {
                      for (j = 0; j < changesCopy.length; j++) {
                          if (j !== i &&
                              index === changesCopy[j].index &&
                              status !== changesCopy[j]['status'] &&
                              updatedIndexes.indexOf(i) < 0 &&
                              removeDuplicate.indexOf(i) < 0) {
                              // Squash delete and add only if they have the same index and same key
                              const jKey = this._getId(changes[j].value);
                              if (oj.Object.compareValues(iKey, jKey)) {
                                  if (status === 'deleted') {
                                      removeDuplicate.push(i);
                                      updatedIndexes.push(j);
                                      this._releaseNode(changes[i].value);
                                  }
                                  else {
                                      removeDuplicate.push(j);
                                      updatedIndexes.push(i);
                                  }
                                  if (!this._compareChildren(changes[i].value, changes[j].value)) {
                                      refreshKeySet.add(iKey);
                                  }
                              }
                          }
                      }
                  }
              }
              // Prepare the "remove" event detail
              for (i = 0; i < changes.length; i++) {
                  if (changes[i]['status'] === 'deleted' &&
                      updatedIndexes.indexOf(i) < 0 &&
                      removeDuplicate.indexOf(i) < 0) {
                      const node = changes[i].value;
                      const key = this._getKeyForNode(node);
                      keyArray.push(key);
                      dataArray.push(node);
                      indexArray.push(changes[i].index);
                      this._releaseNode(node);
                  }
              }
              if (keyArray.length > 0) {
                  metadataArray = keyArray.map((value) => {
                      return { key: value };
                  });
                  const keySet = new Set();
                  keyArray.forEach((key) => {
                      keySet.add(key);
                  });
                  operationRemoveEventDetail = {
                      data: dataArray,
                      indexes: indexArray,
                      keys: keySet,
                      metadata: metadataArray
                  };
              }
              // Preprocessing for the "add" and "update" event detail
              dataArray = [];
              keyArray = [];
              indexArray = [];
              metadataArray = [];
              const nodeArray = treeData();
              const updateKeyArray = [];
              const updateDataArray = [];
              const updateIndexArray = [];
              const updateMetadataArray = [];
              for (i = 0; i < changes.length; i++) {
                  if (changes[i]['status'] === 'added' && removeDuplicate.indexOf(i) < 0) {
                      const node = changes[i].value;
                      const keyObj = this._processNode(node, parentKeyPath, treeData);
                      if (updatedIndexes.indexOf(i) < 0) {
                          keyArray.push(keyObj.key);
                          dataArray.push(node);
                          indexArray.push(changes[i].index);
                          metadataArray.push({ key: keyObj.key });
                      }
                      else {
                          updateKeyArray.push(keyObj.key);
                          updateDataArray.push(node);
                          updateIndexArray.push(changes[i].index);
                          updateMetadataArray.push({ key: keyObj.key });
                      }
                  }
              }
              // Prepare the "add" event detail
              if (keyArray.length > 0) {
                  const keySet = new Set();
                  keyArray.forEach((key) => {
                      keySet.add(key);
                  });
                  const afterKeySet = new Set();
                  const afterKeyArray = [];
                  const parentKeyArray = [];
                  let parentKey;
                  if (this.options &&
                      this.options.keyAttributes &&
                      this.options.keyAttributesScope !== 'siblings' &&
                      this.options.enforceKeyStringify !== 'on') {
                      // For global key, the last part of the parentKeyPath is the parent key
                      parentKey = parentKeyPath.length > 0 ? parentKeyPath[parentKeyPath.length - 1] : null;
                  }
                  else {
                      // For non-global key, the entire parentKeyPath is the parent key
                      parentKey = parentKeyPath.length > 0 ? parentKeyPath : null;
                  }
                  indexArray.forEach((addIndex) => {
                      let afterKey;
                      if (addIndex >= nodeArray.length - 1) {
                          afterKey = null;
                      }
                      else {
                          afterKey = this._getKeyForNode(nodeArray[addIndex + 1]);
                      }
                      afterKeySet.add(afterKey);
                      afterKeyArray.push(afterKey);
                      parentKeyArray.push(parentKey);
                  });
                  operationAddEventDetail = {
                      afterKeys: afterKeySet,
                      addBeforeKeys: afterKeyArray,
                      parentKeys: parentKeyArray,
                      data: dataArray,
                      indexes: indexArray,
                      keys: keySet,
                      metadata: metadataArray
                  };
              }
              // Prepare the "update" event detail
              if (updateKeyArray.length > 0) {
                  const updateKeySet = new Set();
                  updateKeyArray.forEach((key) => {
                      updateKeySet.add(key);
                  });
                  operationUpdateEventDetail = {
                      data: updateDataArray,
                      indexes: updateIndexArray,
                      keys: updateKeySet,
                      metadata: updateMetadataArray
                  };
              }
              if (operationAddEventDetail || operationRemoveEventDetail || operationUpdateEventDetail) {
                  mutationEvent = new oj.DataProviderMutationEvent({
                      add: operationAddEventDetail,
                      remove: operationRemoveEventDetail,
                      update: operationUpdateEventDetail
                  });
              }
              // Prepare refresh subtree
              if (refreshKeySet.size) {
                  refreshEvent = new oj.DataProviderRefreshEvent({ keys: refreshKeySet });
              }
          }, null, 'arrayChange');
          subscriptions[1] = treeData['subscribe']((changes) => {
              if (mutationEvent || refreshEvent) {
                  if (mutationEvent) {
                      this.dispatchEvent(mutationEvent);
                  }
                  if (refreshEvent) {
                      this.dispatchEvent(refreshEvent);
                  }
              }
              else {
                  this._flushMaps();
                  this._processTreeArray(this.treeData, []);
                  this.dispatchEvent(new oj.DataProviderRefreshEvent());
              }
              mutationEvent = null;
              refreshEvent = null;
          }, null, 'change');
          this._mapKoArrayToSubscriptions.set(treeData, subscriptions);
      }
      _flushMaps() {
          const rootDataProvider = this._getRootDataProvider();
          rootDataProvider._mapKeyToNode.clear();
          rootDataProvider._mapNodeToKey.clear();
          rootDataProvider._mapArrayToSequenceNum.clear();
          rootDataProvider._mapKoArrayToSubscriptions.forEach((subscription, treeData) => {
              this._unsubscribeObservableArray(treeData);
          });
      }
      _unsubscribeObservableArray(treeData) {
          if (typeof treeData === 'function' &&
              treeData.subscribe &&
              !(treeData['destroyAll'] === undefined)) {
              const subscriptions = this._mapKoArrayToSubscriptions.get(treeData);
              if (subscriptions) {
                  subscriptions[0].dispose();
                  subscriptions[1].dispose();
                  this._mapKoArrayToSubscriptions.delete(treeData);
              }
          }
      }
      /**
       * If observableArray, then subscribe to it
       */
      _processTreeArray(treeData, parentKeyPath) {
          let dataArray;
          if (treeData instanceof Array) {
              dataArray = treeData;
          }
          else {
              this._subscribeObservableArray(treeData, parentKeyPath);
              dataArray = treeData();
          }
          dataArray.forEach((node, i) => {
              this._processNode(node, parentKeyPath, treeData);
          });
      }
      _releaseTreeArray(treeData) {
          let dataArray;
          if (treeData instanceof Array) {
              dataArray = treeData;
          }
          else {
              this._unsubscribeObservableArray(treeData);
              dataArray = treeData();
          }
          dataArray.forEach((node, i) => {
              this._releaseNode(node);
          });
      }
      _processNode(node, parentKeyPath, treeData) {
          const keyObj = this._createKeyObj(node, parentKeyPath, treeData);
          this._setMapEntry(keyObj.key, node);
          const enforceKeyStringify = this.options?.enforceKeyStringify;
          const rootDataProvider = this._getRootDataProvider();
          const keyString = enforceKeyStringify === 'on' ? keyObj.key : JSON.stringify(keyObj.key);
          rootDataProvider._mapKeyToParentNodePath.set(keyString, keyObj.keyPath);
          const children = this._getChildren(node);
          if (children) {
              this._processTreeArray(children, keyObj.keyPath);
          }
          return keyObj;
      }
      _releaseNode(node) {
          const key = this._getKeyForNode(node);
          this._deleteMapEntry(key, node);
          const children = this._getChildren(node);
          if (children) {
              this._releaseTreeArray(children);
          }
      }
      _createKeyObj(node, parentKeyPath, treeData) {
          let key = this._getId(node);
          const keyPath = parentKeyPath ? parentKeyPath.slice() : [];
          const enforceKeyStringify = this.options?.enforceKeyStringify;
          if (key == null) {
              // _getId returns null if keyAttributes is not specified or invalid.  In this case we
              // use the index path of the node as the key.
              // However, if this is called after initialization, we can't use index
              // any more because node position can shift, so we need to keep track of
              // a sequence number.
              this._setUseIndexAsKey(true);
              keyPath.push(this._incrementSequenceNum(treeData));
              key = enforceKeyStringify === 'on' ? JSON.stringify(keyPath) : keyPath;
          }
          else {
              if (enforceKeyStringify === 'on') {
                  keyPath.push(JSON.parse(key));
              }
              else {
                  keyPath.push(key);
              }
              if (this.options &&
                  (this.options['keyAttributesScope'] === 'siblings' ||
                      (enforceKeyStringify === 'on' && !this.options.useKeyPaths) ||
                      this.options.useKeyPaths === 'on')) {
                  // If the id is only unique among siblings, we use the id path of the
                  // node as the key.
                  key = enforceKeyStringify === 'on' ? JSON.stringify(keyPath) : keyPath;
              }
          }
          return { key, keyPath };
      }
      /**
       * Get id value for row
       */
      _getId(row) {
          let id;
          const keyAttributes = this.options != null ? this.options['keyAttributes'] : null;
          const enforceKeyStringify = this.options?.enforceKeyStringify;
          if (keyAttributes != null) {
              if (Array.isArray(keyAttributes)) {
                  id = [];
                  for (let i = 0; i < keyAttributes.length; i++) {
                      id[i] = this._getVal(row, keyAttributes[i]);
                  }
              }
              else if (keyAttributes == '@value') {
                  id = this._getAllVals(row);
              }
              else {
                  id = this._getVal(row, keyAttributes);
              }
              if (enforceKeyStringify === 'on') {
                  return JSON.stringify(id);
              }
              return id;
          }
          else {
              return null;
          }
      }
      /**
       * Get value for attribute
       */
      _getVal(val, attr, keepFunc) {
          if (typeof attr === 'string') {
              const dotIndex = attr.indexOf('.');
              if (dotIndex > 0) {
                  const startAttr = attr.substring(0, dotIndex);
                  const endAttr = attr.substring(dotIndex + 1);
                  const subObj = val[startAttr];
                  if (subObj) {
                      return this._getVal(subObj, endAttr);
                  }
              }
          }
          // If keepFunc is true, don't resolve any function value.
          // e.g. Caller may want to preserve any observableArray for other operations.
          if (keepFunc !== true && typeof val[attr] === 'function') {
              return val[attr]();
          }
          return val[attr];
      }
      /**
       * Get all values in a row
       */
      _getAllVals(val) {
          if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
              return val;
          }
          return Object.keys(val).map((key) => {
              return this._getVal(val, key);
          });
      }
      _getNodeMetadata(node) {
          return { key: this._getKeyForNode(node) };
      }
      _getNodeForKey(key) {
          const enforceKeyStringify = this.options?.enforceKeyStringify;
          const keyString = enforceKeyStringify === 'on' ? key : JSON.stringify(key);
          const rootDataProvider = this._getRootDataProvider();
          return rootDataProvider._mapKeyToNode.get(keyString);
      }
      _getKeyForNode(node) {
          const rootDataProvider = this._getRootDataProvider();
          return rootDataProvider._mapNodeToKey.get(node);
      }
      _setMapEntry(key, node) {
          const enforceKeyStringify = this.options?.enforceKeyStringify;
          const rootDataProvider = this._getRootDataProvider();
          const keyCopy = enforceKeyStringify === 'on' ? key : JSON.stringify(key);
          if (rootDataProvider._mapKeyToNode.has(keyCopy)) {
              Logger.warn(`Duplicate key ${keyCopy} found in ArrayTreeDataProvider.  Keys must be unique when keyAttributes ${this.options.keyAttributes} is specified`);
          }
          rootDataProvider._mapKeyToNode.set(keyCopy, node);
          rootDataProvider._mapNodeToKey.set(node, key);
      }
      _deleteMapEntry(key, node) {
          const enforceKeyStringify = this.options?.enforceKeyStringify;
          const rootDataProvider = this._getRootDataProvider();
          const keyString = enforceKeyStringify === 'on' ? key : JSON.stringify(key);
          rootDataProvider._mapKeyToNode.delete(keyString);
          rootDataProvider._mapNodeToKey.delete(node);
      }
      _incrementSequenceNum(treeData) {
          const rootDataProvider = this._getRootDataProvider();
          const seqNum = rootDataProvider._mapArrayToSequenceNum.get(treeData) || 0;
          rootDataProvider._mapArrayToSequenceNum.set(treeData, seqNum + 1);
          // Return the previous sequence number
          return seqNum;
      }
      _getUseIndexAsKey() {
          const rootDataProvider = this._getRootDataProvider();
          return rootDataProvider._useIndexAsKey;
      }
      _setUseIndexAsKey(value) {
          const rootDataProvider = this._getRootDataProvider();
          return (rootDataProvider._useIndexAsKey = value);
      }
      _getLeafNodeFilter(filter) {
          const attributeFilter = filter;
          const childrenNull = { op: '$ne', attribute: this._childrenAttr, value: null };
          const childrenUndefined = { op: '$ne', attribute: this._childrenAttr, value: undefined };
          const excludeParentNodeFilter = { op: '$and', criteria: [childrenNull, childrenUndefined] };
          return { op: '$or', criteria: [attributeFilter, excludeParentNodeFilter] };
      }
      _applyLeafNodeFilter(params) {
          if (params && params.filterCriterion) {
              const paramsClone = { ...params };
              paramsClone.filterCriterion = this._getLeafNodeFilter(paramsClone.filterCriterion);
              paramsClone.filterCriterion.filter = params.filterCriterion.filter;
              params = paramsClone;
          }
          return params;
      }
      // Get tree array metadata from flat array metadata/data
      _getTreeMetadata(metadata, data) {
          let keyIsPath = false;
          let treeKey = metadata.key;
          if (this.options == undefined ||
              this.options.keyAttributes == undefined ||
              this.options.keyAttributesScope == 'siblings' ||
              this.options.keyAttributes == '@index' ||
              this._getUseIndexAsKey() ||
              (this.options.enforceKeyStringify === 'on' && !this.options.useKeyPaths) ||
              this.options.useKeyPaths === 'on') {
              keyIsPath = true;
          }
          if (keyIsPath) {
              treeKey = this._parentNodePath ? this._parentNodePath.slice() : [];
              treeKey.push(metadata.key);
          }
          if (this.options?.enforceKeyStringify === 'on') {
              treeKey = JSON.stringify(treeKey);
          }
          metadata = this._getNodeMetadata(this._getNodeForKey(treeKey));
          return metadata;
      }
      _compareChildren(node1, node2) {
          // this node has been updated.
          // check if children of each node are the same
          let bSame = true;
          const nodeChildren1 = node1[this._childrenAttr];
          const nodeChildren2 = node2[this._childrenAttr];
          const children1 = typeof nodeChildren1 === 'function' ? nodeChildren1() : nodeChildren1;
          const children2 = typeof nodeChildren2 === 'function' ? nodeChildren2() : nodeChildren2;
          if ((!children1 && children2) || (children1 && !children2)) {
              bSame = false;
          }
          else if (children1 && children2) {
              if (children1.length !== children2.length) {
                  bSame = false;
              }
              else {
                  //children has same length
                  for (let i = 0; i < children1.length; i++) {
                      if (!oj.Object.compareValues(children1[i], children2[i])) {
                          bSame = false;
                          break;
                      }
                  }
              }
          }
          return bSame;
      }
  }
  ojeventtarget.EventTargetMixin.applyMixin(ArrayTreeDataProvider);
  oj._registerLegacyNamespaceProp('ArrayTreeDataProvider', ArrayTreeDataProvider);

  return ArrayTreeDataProvider;

});


define('ojs/ojsuppressnodetreedataprovider',['exports', 'ojs/ojeventtarget', 'ojs/ojdataprovider'], function (exports, ojeventtarget, ojdataprovider) { 'use strict';

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 10.1.0
     * @export
     * @final
     * @class SuppressNodeTreeDataProvider
     * @implements TreeDataProvider
     * @classdesc SuppressNodeTreeDataProvider is a wrapping TreeDataProvider that provide an option to suppress certain nodes,
     * such as parent nodes with empty children.  The fetch methods will check if the returned nodes should be suppressed based on the provided option.
     *
     * @ojtsexample <caption>How to use the class</caption>
     * let data = [
     *   {label: "Task 1", id: "task1", children: [{label: "Task 1.1", id: "task1.1"}]},
     *   {label: "Task 2", id: "task2", children: [{label: "Task 2.1", id: "task2.1"}]},
     *   {label: "Task 3", id: "task3", children: []}];
     * let treeDP = new ArrayTreeDataProvider(data, {keyAttributes: "id"});
     * let suppressTDP = new SuppressNodeTreeDataProvider(treeDP, {suppressNode: 'ifEmptyChildren'});
     *
     * @param {TreeDataProvider} treeDataProvider The base tree data provider.
     * @param {SuppressNodeTreeDataProvider.Options=} options Options for the SuppressNodeTreeDataProvider
     * @ojsignature [{target: "Type",
     *               value: "class SuppressNodeTreeDataProvider<K, D> implements TreeDataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type", value: "TreeDataProvider<K,D>", for: "treeDataProvider"},
     *               {target: "Type", value: "SuppressNodeTreeDataProvider.Options", for: "options"}]
     * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: "TreeDataProvider"}
     * @ojtsimport {module: "ojarraydataprovider", type: "AMD", importName: "ArrayDataProvider"}
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion",
     *   "FetchByKeysParameters","ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters", "FetchByOffsetResults",
     *   "FetchListResult","FetchListParameters"]}
     */

    /**
     * @typedef {Object} SuppressNodeTreeDataProvider.Options
     * @property {string} suppressNode - potions to suppress certain nodes.  The possible value is
     *   <ul>
     *     <li>'never': do not suppress any nodes
     *     <li>'ifEmptyChildren': suppress the parent nodes if they have empty children
     *   </ul>
     *   Default is 'never'.
     * @ojsignature [{target: "Type", value: "'never' | 'ifEmptyChildren'", for: "suppressNode"}]
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name getChildDataProvider
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * Get an AsyncIterable object for iterating the data.
     * <p>
     * AsyncIterable contains a Symbol.asyncIterator method that returns an AsyncIterator.
     * AsyncIterator contains a next method for fetching the next block of data.
     * </p><p>
     * The "next" method returns a promise that resolves to an object, which contains a "value" property for the data and a "done" property
     * that is set to true when there is no more data to be fetched.  The "done" property should be set to true only if there is no "value"
     * in the result.  Note that "done" only reflects whether the iterator is done at the time "next" is called.  Future calls to "next"
     * may or may not return more rows for a mutable data source.
     * </p>
     * <p>
     * Please see the <a href="DataProvider.html#custom-implementations-section">DataProvider documentation</a> for
     * more information on custom implementations.
     * </p>
     *
     * @param {FetchListParameters=} params fetch parameters
     * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
     * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
     * @export
     * @expose
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name fetchFirst
     * @ojsignature {target: "Type",
     *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
     * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
     * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
     * let result = await asyncIterator.next();
     * let value = result.value;
     * let data = value.data;
     * let keys = value.metadata.map(function(val) {
     *   return val.key;
     * });
     * // true or false for done
     * let done = result.done;
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof SuppressNodeTreeDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    class SuppressNodeTreeDataProvider {
        constructor(treeDataProvider, options) {
            var _a, _b;
            this.treeDataProvider = treeDataProvider;
            this.options = options;
            this.SuppressNodeTreeAsyncIterable = (_b = class {
                    constructor(_parent, _asyncIterator) {
                        this._parent = _parent;
                        this._asyncIterator = _asyncIterator;
                        this[_a] = () => {
                            return new this._parent.SuppressNodeTreeAsyncIterator(this._parent, this._asyncIterator);
                        };
                    }
                },
                _a = Symbol.asyncIterator,
                _b);
            this.SuppressNodeTreeAsyncIterator = class {
                constructor(_parent, _baseIterator, _params) {
                    this._parent = _parent;
                    this._baseIterator = _baseIterator;
                    this._params = _params;
                }
                _fetchNext() {
                    return this._baseIterator.next();
                }
                ['next']() {
                    const signal = this._params?.signal;
                    const callback = (resolve) => {
                        const promise = this._fetchNext();
                        return resolve(promise.then((result) => {
                            return this._parent._suppressNodeIfEmptyChildrenFirst(result);
                        }));
                    };
                    return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
                }
            };
            this.AsyncIteratorYieldResult = class {
                constructor(value) {
                    this.value = value;
                    this.done = false;
                }
            };
            this.AsyncIteratorReturnResult = class {
                constructor(value) {
                    this.value = value;
                    this.done = true;
                }
            };
            this.FetchListResult = class {
                constructor(fetchParameters, data, metadata, totalFilteredRowCount) {
                    this.fetchParameters = fetchParameters;
                    this.data = data;
                    this.metadata = metadata;
                    this.totalFilteredRowCount = totalFilteredRowCount;
                }
            };
            this.FetchByOffsetResults = class {
                constructor(fetchParameters, results, done) {
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this.done = done;
                }
            };
            this.Item = class {
                constructor(metadata, data) {
                    this.metadata = metadata;
                    this.data = data;
                }
            };
            this._addEventListeners(treeDataProvider);
        }
        containsKeys(params) {
            return this.treeDataProvider.containsKeys(params);
        }
        getCapability(capabilityName) {
            return this.treeDataProvider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this.treeDataProvider.getTotalSize();
        }
        isEmpty() {
            return this.treeDataProvider.isEmpty();
        }
        createOptimizedKeySet(initialSet) {
            return this.treeDataProvider.createOptimizedKeySet(initialSet);
        }
        createOptimizedKeyMap(initialMap) {
            return this.treeDataProvider.createOptimizedKeyMap(initialMap);
        }
        getChildDataProvider(parentKey) {
            const child = this.treeDataProvider.getChildDataProvider(parentKey);
            return child === null ? null : new SuppressNodeTreeDataProvider(child, this.options);
        }
        fetchFirst(params) {
            const asyncIterable = this.treeDataProvider.fetchFirst(params);
            return new this.SuppressNodeTreeAsyncIterable(this, asyncIterable[Symbol.asyncIterator]());
        }
        fetchByOffset(params) {
            const signal = params?.signal;
            const callback = (resolve) => {
                return resolve(this.treeDataProvider.fetchByOffset(params).then((result) => {
                    return this._suppressNodeIfEmptyChildrenByOffset(result);
                }));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchByKeys(params) {
            const signal = params?.signal;
            const callback = (resolve) => {
                return resolve(this.treeDataProvider.fetchByKeys(params));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        _suppressNodeIfEmptyChildrenByOffset(result) {
            if (result.results && this.options && this.options.suppressNode == 'ifEmptyChildren') {
                const resultArray = [];
                const promises = [];
                const promiseItems = new Promise((resolve) => {
                    for (let i = 0; i < result.results.length; i++) {
                        const resulti = result.results[i];
                        promises[i] = this._suppressChild(resulti.metadata.key, result.fetchParameters ? result.fetchParameters.filterCriterion : null);
                    }
                    return Promise.all(promises).then((supressNodes) => {
                        for (let i = 0; i < supressNodes.length; i++) {
                            if (supressNodes[i] === false) {
                                resultArray.push(new this.Item(result.results[i].metadata, result.results[i].data));
                            }
                        }
                        return resolve(resultArray);
                    });
                });
                return promiseItems.then((resultArray) => {
                    return new this.FetchByOffsetResults(result.fetchParameters, resultArray, result.done);
                });
            }
            else {
                return Promise.resolve(result);
            }
        }
        _suppressNodeIfEmptyChildrenFirst(result) {
            const promises = [];
            if (!result.done && this.options && this.options.suppressNode == 'ifEmptyChildren') {
                const promiseItems = new Promise((resolve) => {
                    if (result && result.value && result.value.data) {
                        const metadata = result.value.metadata;
                        const data = result.value.data;
                        const retItems = [];
                        for (let i = 0; metadata && i < metadata.length; i++) {
                            promises[i] = this._suppressChild(metadata[i].key, result.value.fetchParameters ? result.value.fetchParameters.filterCriterion : null);
                        }
                        return Promise.all(promises).then((supressNodes) => {
                            for (let i = 0; i < supressNodes.length; i++) {
                                if (supressNodes[i] === false) {
                                    retItems.push({
                                        data: data[i],
                                        metadata: metadata[i],
                                        totalFilteredRowCount: result.value.totalFilteredRowCount
                                    });
                                }
                            }
                            return resolve(retItems);
                        });
                    }
                    else {
                        return {
                            data: result.value.data,
                            metadata: result.value.metadata,
                            totalFilteredRowCount: result.value.totalFilteredRowCount
                        };
                    }
                });
                return promiseItems.then((retItems) => {
                    const retData = [];
                    const retMetadata = [];
                    for (const item of retItems) {
                        retData.push(item.data);
                        retMetadata.push(item.metadata);
                    }
                    return new this.AsyncIteratorYieldResult(new this.FetchListResult(result.value.fetchParameters, retData, retMetadata, result.value.totalFilteredRowCount));
                });
            }
            else {
                return Promise.resolve(result);
            }
        }
        _suppressChild(key, filterCriterion) {
            const child = this.getChildDataProvider(key);
            if (child == null || child.isEmpty() === 'yes') {
                // do not suppress leaf node
                return Promise.resolve(child === null ? false : true);
            }
            else {
                if (filterCriterion) {
                    return child
                        .fetchByOffset({ offset: 0, filterCriterion: filterCriterion })
                        .then((childResult) => {
                        return childResult && childResult.results && childResult.results.length > 0
                            ? false
                            : true;
                    });
                }
                else if (child.isEmpty() === 'unknown') {
                    // If unknown, as is the case with RESTTreeDataProvider, attempt to fetch
                    // a small amount of data and check if anything is returned. If data is returned,
                    // do not suppress and vice-versa
                    return child.fetchByOffset({ offset: 0, size: 1 }).then((childResult) => {
                        return childResult && childResult.results && childResult.results.length > 0
                            ? false
                            : true;
                    });
                }
                else {
                    return Promise.resolve(false);
                }
            }
        }
        _addEventListeners(dataprovider) {
            dataprovider.addEventListener('refresh', (event) => {
                this.dispatchEvent(event);
            });
            dataprovider.addEventListener('mutate', (event) => {
                this.dispatchEvent(event);
            });
        }
    }
    ojeventtarget.EventTargetMixin.applyMixin(SuppressNodeTreeDataProvider);

    exports.SuppressNodeTreeDataProvider = SuppressNodeTreeDataProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdataprovideradapter-base',['ojs/ojcore-base', 'ojs/ojeventtarget'], function (oj, ojeventtarget) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    class DataSourceAdapter {
        constructor(dataSource) {
            var _a;
            this.dataSource = dataSource;
            this.AsyncIterable = (_a = class {
                    constructor(_asyncIterator) {
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = function () {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this.AsyncIterator = class {
                constructor(_nextFunc, _params) {
                    this._nextFunc = _nextFunc;
                    this._params = _params;
                    this._fetchFirst = true;
                }
                ['next']() {
                    const fetchFirst = this._fetchFirst;
                    this._fetchFirst = false;
                    return this._nextFunc(this._params, fetchFirst);
                }
            };
            this.AsyncIteratorYieldResult = class {
                constructor(_parent, value) {
                    this._parent = _parent;
                    this.value = value;
                    this[DataSourceAdapter._VALUE] = value;
                    this[DataSourceAdapter._DONE] = false;
                }
            };
            this.AsyncIteratorReturnResult = class {
                constructor(_parent, value) {
                    this._parent = _parent;
                    this.value = value;
                    this[DataSourceAdapter._VALUE] = value;
                    this[DataSourceAdapter._DONE] = true;
                }
            };
            this.FetchListResult = class {
                constructor(_parent, fetchParameters, data, metadata) {
                    this._parent = _parent;
                    this.fetchParameters = fetchParameters;
                    this.data = data;
                    this.metadata = metadata;
                    this[DataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
                    this[DataSourceAdapter._DATA] = data;
                    this[DataSourceAdapter._METADATA] = metadata;
                }
            };
            this.ItemMetadata = class {
                constructor(_parent, key) {
                    this._parent = _parent;
                    this.key = key;
                    this[DataSourceAdapter._KEY] = key;
                }
            };
            this.SortCriterion = class {
                constructor(_parent, attribute, direction) {
                    this._parent = _parent;
                    this.attribute = attribute;
                    this.direction = direction;
                    this[DataSourceAdapter._ATTRIBUTE] = attribute;
                    this[DataSourceAdapter._DIRECTION] = direction;
                }
            };
            this.DataProviderMutationEventDetail = class {
                constructor(_parent, add, remove, update) {
                    this._parent = _parent;
                    this.add = add;
                    this.remove = remove;
                    this.update = update;
                    this[DataSourceAdapter._ADD] = add;
                    this[DataSourceAdapter._REMOVE] = remove;
                    this[DataSourceAdapter._UPDATE] = update;
                }
            };
            this.DataProviderOperationEventDetail = class {
                constructor(_parent, keys, metadata, data, indexes) {
                    this._parent = _parent;
                    this.keys = keys;
                    this.metadata = metadata;
                    this.data = data;
                    this.indexes = indexes;
                    this[DataSourceAdapter._KEYS] = keys;
                    this[DataSourceAdapter._METADATA] = metadata;
                    this[DataSourceAdapter._DATA] = data;
                    this[DataSourceAdapter._INDEXES] = indexes;
                }
            };
            this.DataProviderAddOperationEventDetail = class {
                constructor(_parent, keys, afterKeys, addBeforeKeys, parentKeys, metadata, data, indexes) {
                    this._parent = _parent;
                    this.keys = keys;
                    this.afterKeys = afterKeys;
                    this.addBeforeKeys = addBeforeKeys;
                    this.parentKeys = parentKeys;
                    this.metadata = metadata;
                    this.data = data;
                    this.indexes = indexes;
                    this[DataSourceAdapter._KEYS] = keys;
                    this[DataSourceAdapter._AFTERKEYS] = afterKeys;
                    this[DataSourceAdapter._ADDBEFOREKEYS] = addBeforeKeys;
                    this[DataSourceAdapter._METADATA] = metadata;
                    this[DataSourceAdapter._DATA] = data;
                    this[DataSourceAdapter._INDEXES] = indexes;
                }
            };
        }
        getCapability(capabilityName) {
            if (capabilityName === DataSourceAdapter._SORT &&
                this.dataSource.getCapability(capabilityName) === 'full') {
                return { attributes: 'multiple' };
            }
            else if (capabilityName === 'fetchByKeys') {
                return { implementation: 'lookup' };
            }
            else if (capabilityName === 'fetchByOffset') {
                return { implementation: 'lookup' };
            }
            return null;
        }
        addListener(eventType, eventHandler) {
            this._eventHandlerFuncs[eventType] = eventHandler.bind(this);
            this.dataSource.on(eventType, this._eventHandlerFuncs[eventType]);
        }
        removeListener(eventType) {
            this.dataSource.off(eventType, this._eventHandlerFuncs[eventType]);
        }
        removeAllListeners() {
            this._eventHandlerFuncs = {};
        }
    }
    DataSourceAdapter._SORT = 'sort';
    DataSourceAdapter._DATA = 'data';
    DataSourceAdapter._KEY = 'key';
    DataSourceAdapter._ATTRIBUTE = 'attribute';
    DataSourceAdapter._DIRECTION = 'direction';
    DataSourceAdapter._VALUE = 'value';
    DataSourceAdapter._DONE = 'done';
    DataSourceAdapter._FETCHPARAMETERS = 'fetchParameters';
    DataSourceAdapter._METADATA = 'metadata';
    DataSourceAdapter._KEYS = 'keys';
    DataSourceAdapter._INDEXES = 'indexes';
    DataSourceAdapter._ADD = 'add';
    DataSourceAdapter._REMOVE = 'remove';
    DataSourceAdapter._UPDATE = 'update';
    DataSourceAdapter._AFTERKEYS = 'afterKeys';
    DataSourceAdapter._ADDBEFOREKEYS = 'addBeforeKeys';
    ojeventtarget.EventTargetMixin.applyMixin(DataSourceAdapter);
    oj._registerLegacyNamespaceProp('DataSourceAdapter', DataSourceAdapter);

    return DataSourceAdapter;

});


define('ojs/ojmodel',['exports', 'ojs/ojcore-base', 'ojs/ojlogger', 'jquery', 'ojs/ojconfig'], function (exports, oj, Logger, $, Config) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * @constructor
   * @final
   * @class Events
   * @classdesc Supports event system for the common model ([Collection]{@link Collection} and
   * [Model]{@link Model})
   * @since 1.0.0
   * @ojtsignore
   */
  const Events =
    /** @lends Events */
    {
      /**
       * Add an event handler for an event type to the model or collection object.
       * @param {string|Object} eventType Types of event handlers to add (may be a single event type, a
       * space-delimited set of event types, or an object mapping events to callbacks).
       * @param {function(Object, any=, any=)} callback User's event handler callback function (called with the
       * model or collection object and event specific values as parameters--the context will be the model or collection unless specified by context, below).
       * @param {Object=} context A context for the event
       * @return {undefined}
       * @ojsignature {target: "Type", for: "callback", value: "(context: Object, data?: any, data2?: any)=> void"}
       * @since 1.0.0
       * @memberof Events
       */
      on: function (eventType, callback, context) {
        return this.OnInternal(eventType, callback, context, false, false);
      },

      /**
       * Remove an event handler for an event type from the model or collection object.
       * @param {(string|Object)=} eventType Types of event handlers to remove (may be a single event type, a
       * space-delimited set of event types, or a map of events to callbacks). If omitted, remove all event handlers.
       * @param {function(Object, any=, any=)=} callback If provided, remove handlers only for eventType events with the
       * given callback function.
       * @param {Object=} context If provided, remove handlers only for eventType events with the given callback
       * function and context object.
       * @return {undefined}
       * @ojsignature {target: "Type", for: "callback", value: "(context: object, data?: any, data2?: any)=> void"}
       * @since 1.0.0
       * @memberof Events
       */
      off: function (eventType, callback, context) {
        return this._offInternal(eventType, callback, context, false);
      },

      /**
       * Fire the given event type(s) for all registered handlers.
       * @param {string} eventType Types of event handlers to fire (may be a single event type or a space-delimited
       * set of event types).
       * @return {undefined}
       * @since 1.0.0
       * @memberof Events
       */
      // eslint-disable-next-line no-unused-vars
      trigger: function (eventType) {
        var args = Array.prototype.slice.call(arguments);
        // Inject a silent setting in there: if this is being called outside we want to fire all relevant
        // events
        args.unshift(false);
        return Events.TriggerInternal.apply(this, args);
      },

      /**
       * Add an event handler for an event type to the model or collection object, but only fire it once, then remove
       * it from the list of handlers.
       * @param {string} eventType Types of event handlers to add (may be a single event type or a space-delimited
       * set of event types).
       * @param {function(Object, Object=, Object=)} callback User's event handler callback function (called with the
       * model or collection object and event specific values as parameters--the context will be the model or collection unless
       * specified by context, below).
       * @param {Object=} context A context for the event
       * @return {undefined}
       * @ojsignature {target: "Type", for: "callback", value: "(context: Object, data?: any, data2?: any)=> void"}
       * @since 1.0.0
       * @memberof Events
       */
      once: function (eventType, callback, context) {
        return this._onceInternal(eventType, callback, context, false, null);
      },

      /**
       * Add an event handler for an event type to a second model or collection object ("otherObj"), but track it on
       * the called object.
       * @param {Model|Collection} otherObj Model or collection object on which to add this event handler.
       * @param {string} eventType Types of event handlers to add (may be a single event type or a space-delimited
       * set of event types).
       * @param {function(Object, any=, any=)} callback User's event handler callback function (called with the
       * model or collection object and event specific values as parameters--the context will be the model or collection
       * unless specified by context, below).
       * @return {undefined}
       * @ojsignature {target: "Type", for: "callback", value: "(context: Object, data?: any, data2?: any)=> void"}
       * @since 1.0.0
       * @memberof Events
       */
      listenTo: function (otherObj, eventType, callback) {
        var eventArray;
        var e;
        var event;
        var attr;
        var eventString;
        var listenerObj;
        var eventMap = {};
        var prop;

        if (eventType.constructor === String) {
          // Create a map out of it
          eventMap[eventType] = callback;
        } else {
          eventMap = eventType;
        }

        // eslint-disable-next-line no-restricted-syntax
        for (prop in eventMap) {
          // eslint-disable-next-line no-prototype-builtins
          if (eventMap.hasOwnProperty(prop)) {
            eventArray = Events._getEvents(prop);
            for (e = 0; e < eventArray.length; e += 1) {
              event = eventArray[e].event;
              attr = eventArray[e].attribute;
              listenerObj = {
                event: event,
                attribute: attr,
                object: otherObj,
                callback: eventMap[prop]
              };
              eventString = attr ? event + ':' + attr : event;
              if (this._listeningTo === undefined) {
                this._listeningTo = [];
              }
              this._listeningTo.push(listenerObj);
              // fire
              otherObj.OnInternal(eventString, eventMap[prop], null, true, false);
            }
          }
        }
        return this;
      },

      /**
       * Add an event handler for an event type to a second model or collection object ("otherObj"), but track it on
       * the called object.  Only fire once.
       * @param {Model|Collection} otherObj Model or collection object on which to add this event handler.
       * @param {string} eventType Types of event handlers to add (may be a single event type or a space-delimited
       * set of event types).
       * @param {function(Object, any=, any=)} callback User's event handler callback function (called with the
       * model or collection object and event specific values as parameters--the context will be the model or collection unless
       * specified by context, below).
       * @ojsignature {target: "Type", for: "callback", value: "(context: Object, data?: any, data2?: any)=> void"}
       * @return {undefined}
       * @since 1.0.0
       * @memberof Events
       */
      listenToOnce: function (otherObj, eventType, callback) {
        var eventArray;
        var e;
        var event;
        var attr;
        var eventString;
        var listenerObj;
        var eventMap = {};
        var prop;

        if (eventType.constructor === String) {
          // Create a map out of it
          eventMap[eventType] = callback;
        } else {
          eventMap = eventType;
        }

        // eslint-disable-next-line no-restricted-syntax
        for (prop in eventMap) {
          // eslint-disable-next-line no-prototype-builtins
          if (eventMap.hasOwnProperty(prop)) {
            eventArray = Events._getEvents(prop);
            for (e = 0; e < eventArray.length; e += 1) {
              event = eventArray[e].event;
              attr = eventArray[e].attribute;
              listenerObj = {
                event: event,
                attribute: attr,
                object: otherObj,
                callback: eventMap[prop]
              };
              eventString = attr ? event + ':' + attr : event;
              if (this._listeningTo === undefined) {
                this._listeningTo = [];
              }
              this._listeningTo.push(listenerObj);
              // fire
              otherObj._onceInternal(eventString, eventMap[prop], null, true, this);
            }
          }
        }
        return this;
      },

      /**
       * Remove event handlers from a model or collection object. If the arguments are omitted, removes all event
       * handlers from the model or collection.
       * @param {Model|Collection=} otherObj If specified, remove event handlers that target otherObj from this model or
       * collection.
       * @param {string=} eventType If specified, remove the event handlers for the given event types from this
       * model or collection
       * @param {function(Object, any=, any=)=} callback If specified, remove event handlers that call the given user
       * callback function from this model or collection
       * @return {undefined}
       * @ojsignature {target: "Type", for: "callback", value: "(context: Object, data?: any, data2?: any)=> void"}
       * @since 1.0.0
       * @memberof Events
       */
      stopListening: function (otherObj, eventType, callback) {
        var eventArray;
        var actualType;
        var eventMap = {};
        var e;
        var oneEvent;
        var oneAttr;
        var event;
        var objEqual;
        var eventEqual;
        var callbackEqual;
        var attrEqual;
        var i;
        var len;
        var cb;
        var prop;

        if (arguments == null || arguments.length <= 1) {
          len = this._listeningTo ? this._listeningTo.length : 0;
          // Remove everything
          for (i = 0; i < len; i++) {
            event = this._listeningTo[i];
            // If we have an "otherObj" argument, make sure that passes muster
            objEqual = otherObj ? otherObj === event.object : true;
            if (objEqual) {
              cb = event.object._offInternal;
              cb.apply(event.object, [event.event, event.callback, event.context, true]);
            }
          }
          this._listeningTo = [];
          return this;
        }

        actualType = eventType;
        // Account for missing otherObj
        if (otherObj && otherObj.constructor === String) {
          actualType = otherObj;
        }

        if (actualType.constructor === String) {
          // Create a map out of it
          eventMap[actualType] = callback;
        } else {
          eventMap = actualType;
        }

        // eslint-disable-next-line no-restricted-syntax
        for (prop in eventMap) {
          // eslint-disable-next-line no-prototype-builtins
          if (eventMap.hasOwnProperty(prop)) {
            eventArray = Events._getEvents(prop);
            for (e = 0; e < eventArray.length; e += 1) {
              oneEvent = eventArray[e].event;
              oneAttr = eventArray[e].attribute;
              len = this._listeningTo ? this._listeningTo.length : 0;
              for (i = len - 1; i >= 0; i -= 1) {
                event = this._listeningTo[i];
                objEqual = otherObj ? otherObj === event.object : true;
                eventEqual = oneEvent ? oneEvent === event.event : true;
                callbackEqual = callback ? eventMap[prop] === event.callback : true;
                attrEqual = oneAttr ? oneAttr === event.attribute : true;
                if (objEqual && eventEqual && callbackEqual && attrEqual) {
                  cb = this._listeningTo[i].object._offInternal;
                  cb.apply(this._listeningTo[i].object, [
                    this._listeningTo[i].event,
                    this._listeningTo[i].callback,
                    this._listeningTo[i].context,
                    true
                  ]);
                  this._listeningTo.splice(i, 1);
                }
              }
            }
          }
        }
        return this;
      },

      /**
       * @export
       * Event types
       * @enum {string}
       * @memberof Events
       */
      EventType: {
        /** Triggered when a model is added to a collection<p>
         *  The event passes these arguments to the handler: <br>
         *  <ul>
         *  <b>model</b>: the model being added to the collection<br>
         *  <b>collection</b>: the collection to which the model has been added<br>
         *  <b>options</b>: any options passed in to the add call that triggered the event
         *  </ul>
         */
        ADD: 'add',
        /** Triggered by a collection during an add call once all models passed in have been added<p>
         * The event passes these arguments to the handler:<br>
         * <ul>
         * <b>collection</b>: the collection to which the models have been added<br>
         * <b>models</b>: the array of models that have been added <br>
         * <b>options</b>: any options passed in to the add call
         * </ul>
         */
        ALLADDED: 'alladded',
        /** Triggered when a model is removed from a collection<p>
         * The event passes these arguments to the handler: <br>
         * <ul>
         * <b>model</b>: the model being removed from the collection<br>
         * <b>collection</b>: the collection from which the model was removed<br>
         * <b>options</b>: <b>index</b>: the index of the model being removed
         * </ul>
         */
        REMOVE: 'remove',
        /** Triggered when a collection is reset (see Collection.reset)<p>
         *  The event passes these arguments to the handler:<br>
         *  <ul>
         *  <b>collection</b>: the collection being reset<br>
         *  <b>options</b>: any options passed in to the reset call
         *  </ul>
         */
        RESET: 'reset',
        /** Triggered when a collection is refreshed (see Collection.refresh)<p>
         *  The event passes these arguments to the handler: <br>
         *  <ul>
         *  <b>collection</b>: the collection being refreshed<br>
         *  <b>options</b>: any options passed in to the refresh call
         *  </ul>
         */
        REFRESH: 'refresh',
        /** Triggered when a collection is sorted.  If the second argument to the callback is set (options) and
         * 'add' is true, it means this sort event was triggered as a result of an add <p>
         *  The event passes these arguments to the handler:<br>
         *  <ul>
         *  <b>collection</b>: the collection being sorted<br>
         *  <b>options</b>: <b>add</b>: true if this sort event was triggered as the result of an add call,
         *  undefined or false if not
         *  </ul>
         */
        SORT: 'sort',
        /** Triggered when a model's attributes are changed.  This can be the result of a clear call on a model;
         * a property set call on a model; an unset call on a model; or the changing of properties due to the
         * merging of models (in an add, for example) <p>
         * The event passes these arguments to the handler:<br>
         * <ul>
         * <b>model</b>: the model on which the change occurred<br>
         * <b>value</b>: for property-specific change events, the new value of the property being changed<br>
         * <b>options</b>: any options passed in to the call that triggered the change event.  This is the second
         * argument passed for overall change events, and the third parameter (after value) for property-specific
         * change events.
         * </ul>
         */
        CHANGE: 'change',
        /** Triggered when a model is deleted from the data service (and thus from its Collection), due to a model
         * destroy call<p>
         * The event passes these arguments to the handler:<br>
         * <ul>
         * <b>model</b>: the model being deleted<br>
         * <b>collection</b>: the deleted model's collection, if any
         * </ul>
         */
        DESTROY: 'destroy',
        /** Triggered by a collection during a remove call once all models passed in have been removed and
         * destroyed<p>
         * The event passes these arguments to the handler:<br>
         * <ul>
         * <b>collection</b>: the collection from which the models have been removed<br>
         * <b>models</b>: the array of models that have been removed <br>
         * <b>options</b>: any options passed in to the remove call
         * </ul>
         */
        ALLREMOVED: 'allremoved',
        /** Triggered when a model or collection has sent a request to the data service <p>
         *  The event passes these arguments to the handler:<br>
         *  <ul>
         *  <b>collection or model</b>: the collection or model triggering the request<br>
         *  <b>xhr</b>: the xhr argument for the request<br>
         *  <b>options</b>: any options passed as part of the request
         *  </ul>
         */
        REQUEST: 'request',
        /** Triggered when a model or collection has been updated from the data service<p>
         *  The event passes these arguments to the handler:<br>
         *  <ul>
         *  <b>collection or model</b>: the collection or model that triggered the update<br>
         *  <b>response</b>: the response object from the data service<br>
         *  <b>options</b>: any options passed in to the call that triggered the update
         *  </ul>
         */
        SYNC: 'sync',
        /** Triggered when a model has failed to update on the data service<p>
         *  The event passes these arguments to the handler:<br>
         *  <b>collection or model</b>: the collection or model that made the call that resulted in the error<br>
         *  <b>xhr</b>: the xhr argument for the failing request, if any<br>
         *  <b>options</b>: any options passed in to the call that triggered the failing request, plus the status
         *  and error as textStatus and errorThrown
         *  </ul>
         */
        ERROR: 'error',
        /** Triggered on an error with data source interactions <p>
         * The event passes these arguments to the handler:<br>
         * <ul>
         * <b>model</b>: the model (or collection) on which the error operation happened <br>
         * <b>xhr</b>: the xhr involved, if relevant<br>
         * <b>options</b>: any options passed in to the call that triggered the invalid event
         * </ul>
         */
        INVALID: 'invalid',
        /** Triggered when all pending promises from Collection API calls have been resolved<p>
         * The event passes these arguments to the handler:<br>
         * <ul>
         * <b>collection</b>: the collection on which the promises have been resolved
         * </ul>
         */
        READY: 'ready',
        /** Triggered for any of the above events <p>
         * The event passes the name of the actual event and then any arguments normally passed to that event
         * following the name
         */
        ALL: 'all'
      }
    };

  // Aliases for backward compatibility
  Events.bind = Events.on;
  Events.unbind = Events.off;

  /**
   * @private
   * @param {Object} myClass
   * @param {Object=} source
   */
  Events.Mixin = function (myClass, source) {
    var methodName;
    var obj = source || this;
    // eslint-disable-next-line no-restricted-syntax
    for (methodName in obj) {
      if (typeof obj[methodName] === 'function') {
        myClass[methodName] = obj[methodName]; // eslint-disable-line no-param-reassign
      }
    }
    // Make sure actual vars are own copies
    myClass.eventHandlers = {}; // eslint-disable-line no-param-reassign
    myClass._listeningTo = []; // eslint-disable-line no-param-reassign
  };

  /**
   * @private
   */
  Events._onceInternal = function (eventType, callback, context, listenTo, otherObj) {
    var eventArray;
    var e;
    var event;
    var attr;
    var eventMap;
    var obj;
    var cxt = context;

    obj = this._getEventMap(eventType, callback, context);
    eventMap = obj.map;
    cxt = obj.context;

    var self = this;
    Object.keys(eventMap || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(eventMap, prop)) {
        eventArray = self._getEvents(prop);

        for (e = 0; e < eventArray.length; e += 1) {
          event = eventArray[e].event;
          attr = eventArray[e].attribute;
          if (self.eventHandlers === undefined) {
            self.eventHandlers = [];
          }
          if (self.eventHandlers[event] === undefined) {
            self.eventHandlers[event] = [];
          }

          self.eventHandlers[event].push({
            callback: eventMap[prop],
            context: cxt,
            attribute: attr,
            once: true,
            fired: false,
            listen: listenTo,
            otherObj: otherObj
          });
        }
      }
    });
    return this;
  };

  /**
   * @private
   */
  Events._shouldFire = function (handler) {
    if (handler.once) {
      if (!handler.fired) {
        handler.fired = true; // eslint-disable-line no-param-reassign
        return true;
      }
      return false;
    }
    return true;
  };

  /**
   * @private
   */
  Events._getContext = function (obj, handler) {
    return handler.context || handler.otherObj || obj;
  };

  /**
   * @protected
   */
  Events.TriggerInternal = function (silent, eventType) {
    var eventArray = this._getEvents(eventType);
    var e;
    var event;
    var attr;
    var eventsToFire;
    var handlers;
    var i;
    var args;
    var allHandlers;
    var callback;

    eventsToFire = [];
    for (e = 0; e < eventArray.length; e += 1) {
      event = eventArray[e].event;
      attr = eventArray[e].attribute;
      // Do specific event...
      eventsToFire.push({ event: event, attribute: attr });
    }
    for (e = 0; e < eventsToFire.length; e += 1) {
      allHandlers = this._getHandlers(this.eventHandlers, Events.EventType.ALL);
      handlers = Events._getHandlers(this.eventHandlers, eventsToFire[e].event, false);
      for (i = 0; i < (handlers ? handlers.length : 0); i += 1) {
        if (handlers[i].attribute === eventsToFire[e].attribute && handlers[i].callback) {
          args = Array.prototype.slice.call(arguments);
          if (handlers && handlers[i] && handlers[i].once) {
            // Remove it: only want to fire once--make sure we remove it from the original
            this._removeHandler(
              Events._getHandlers(this.eventHandlers, eventsToFire[e].event, true),
              handlers[i]
            );
            // Now take it out of the other object's "listen to" list, if relevant
            if (handlers[i].otherObj) {
              // Clean up the "other object" if this was a triggered listenOnce
              handlers[i].otherObj.stopListening(this, eventType, handlers[i].callback);
            }
          }
          if (handlers && handlers[i] && this._shouldFire(handlers[i])) {
            callback = handlers[i].callback;
            // If this isn't a silent firing or this handler always wants to be called, make the call
            if (!silent || handlers[i].ignoreSilent) {
              callback.apply(Events._getContext(this, handlers[i]), args.slice(2));
            }
          }
        }
      }
      // Handle all
      for (i = 0; i < (allHandlers ? allHandlers.length : 0); i += 1) {
        args = Array.prototype.slice.call(arguments);
        if (args.length > 0) {
          if (eventsToFire[e].attribute) {
            args[1] = eventsToFire[e].event + ':' + eventsToFire[e].attribute;
          } else {
            args[1] = eventsToFire[e].event;
          }
        }
        // All case--make sure to pass event name
        if (
          allHandlers &&
          allHandlers[i] &&
          allHandlers[i].callback &&
          this._shouldFire(allHandlers[i])
        ) {
          callback = allHandlers[i].callback;
          // If this isn't a silent firing or this handler always wants to be called, make the call
          if (!silent || allHandlers[i].ignoreSilent) {
            callback.apply(Events._getContext(this, allHandlers[i]), args.slice(1));
          }
        }
        if (allHandlers && allHandlers[i] && allHandlers[i].once) {
          // Remove it: only want to fire once
          this._removeHandler(
            this._getHandlers(this.eventHandlers, Events.EventType.ALL, true),
            allHandlers[i]
          );
          // Now take it out of the other object's "listen to" list, if relevant
          if (allHandlers[i].otherObj) {
            // Clean up the "other object" if this was a triggered listenOnce
            allHandlers[i].otherObj.stopListening(
              this,
              Events.EventType.ALL,
              allHandlers[i].callback
            );
          }
        }
      }
    }
    return this;
  };

  /**
   * @protected
   */
  Events.OnInternal = function (eventType, callback, context, listenTo, ignoreSilent) {
    var eventMap;
    var eventArray;
    var i;
    var event;
    var attr;
    var eventObj;
    var cxt;
    var prop;

    var obj = this._getEventMap(eventType, callback, context);
    eventMap = obj.map;
    cxt = obj.context;

    // eslint-disable-next-line no-restricted-syntax
    for (prop in eventMap) {
      // eslint-disable-next-line no-prototype-builtins
      if (eventMap.hasOwnProperty(prop)) {
        eventArray = this._getEvents(prop);

        for (i = 0; i < eventArray.length; i += 1) {
          event = eventArray[i].event;
          attr = eventArray[i].attribute;
          if (this.eventHandlers === undefined) {
            this.eventHandlers = [];
          }
          if (this.eventHandlers[event] === undefined) {
            this.eventHandlers[event] = [];
          }

          eventObj = {
            callback: eventMap[prop],
            context: cxt,
            attribute: attr,
            listen: listenTo,
            ignoreSilent: ignoreSilent
          };
          if (
            this._checkForHandler(this.eventHandlers[event], eventObj, Events._handlersIdentical) ===
            -1
          ) {
            this.eventHandlers[event].push(eventObj);
          }
        }
      }
    }
    return this;
  };

  /**
   * @private
   */
  Events._offInternal = function (eventType, callback, context, listen) {
    var eventMap;
    var obj;
    var cxt;
    var prop;

    if (arguments == null || arguments.length === 0) {
      // Remove everything
      this.eventHandlers = {};
      return this;
    }

    if (eventType == null) {
      this._removeEvent(eventType, callback, context, listen);
      return this;
    }

    obj = this._getEventMap(eventType, callback, context);
    eventMap = obj.map;
    cxt = obj.context;

    // eslint-disable-next-line no-restricted-syntax
    for (prop in eventMap) {
      // eslint-disable-next-line no-prototype-builtins
      if (eventMap.hasOwnProperty(prop)) {
        this._removeEvent(prop, eventMap[prop], cxt, listen);
      }
    }
    return this;
  };

  /**
   * @private
   */
  Events._getEventMap = function (eventType, callback, context) {
    var eventMap = {};

    if (eventType.constructor === String) {
      // Create a map out of it
      eventMap[eventType] = callback;
    } else {
      eventMap = eventType;
      // If eventType is a map of events->callbacks, then the callback argument is now context
      return { map: eventMap, context: callback };
    }
    return { map: eventMap, context: context };
  };

  /**
   * @private
   */
  Events._removeEvent = function (eventType, callback, context, listen) {
    var eventArray = [];
    var e;
    var evt;
    var i;
    var attr;
    var handlers;
    var callbacks;
    var contexts;
    var attrs;
    var listenEq;

    if (eventType) {
      eventArray = Events._getEvents(eventType);
    } else if (this.eventHandlers !== undefined) {
      // Walk entire eventHandlers property list
      var self = this;
      Object.keys(this.eventHandlers || {}).forEach(function (event) {
        if (Object.prototype.hasOwnProperty.call(self.eventHandlers, event)) {
          eventArray.push({ event: event });
        }
      });
    }

    for (e = 0; e < eventArray.length; e += 1) {
      evt = eventArray[e].event;
      attr = eventArray[e].attribute;
      if (this.eventHandlers !== undefined && this.eventHandlers[evt] instanceof Array) {
        handlers = this.eventHandlers[evt];
        for (i = handlers.length - 1; i >= 0; i -= 1) {
          callbacks =
            callback === undefined || callback === null || handlers[i].callback === callback;

          contexts = context === undefined || context === null || handlers[i].context === context;
          attrs = attr === undefined || attr === null || handlers[i].attribute === attr;
          listenEq = listen === undefined || listen === null || handlers[i].listen === listen;
          if (callbacks && contexts && attrs && listenEq) {
            handlers.splice(i, 1);
          }
        }
        if (handlers.length === 0) {
          // Delete the entry
          delete this.eventHandlers[evt];
        }
      }
    }
  };

  /**
   * @private
   */
  Events._removeHandler = function (handlers, handler) {
    var i;
    var callbacks;
    var contexts;
    var attrs;
    var listenEq;
    var onceEq;

    if (handlers) {
      for (i = handlers.length - 1; i >= 0; i -= 1) {
        callbacks =
          handler.callback === undefined ||
          handler.callback === null ||
          handlers[i].callback === handler.callback;

        contexts =
          handler.context === undefined ||
          handler.context === null ||
          handlers[i].context === handler.context;
        attrs =
          handler.attribute === undefined ||
          handler.attribute === null ||
          handlers[i].attribute === handler.attribute;
        listenEq =
          handler.listen === undefined ||
          handler.listen === null ||
          handlers[i].listen === handler.listen;
        onceEq =
          handler.once === undefined || handler.once === null || handlers[i].once === handler.once;
        if (callbacks && contexts && attrs && listenEq && onceEq) {
          handlers.splice(i, 1);
        }
      }
    }
  };

  /**
   * @private
   */
  Events._getEvents = function (eventString) {
    var eventList = eventString ? eventString.split(' ') : [];
    var retList = [];
    var i;
    var eventWithAttr;
    var name;
    var attr;

    for (i = 0; i < eventList.length; i += 1) {
      eventWithAttr = eventList[i].split(':');
      name = eventWithAttr[0];
      attr = eventWithAttr.length > 1 ? eventWithAttr[1] : null;
      retList.push({ event: name, attribute: attr });
    }
    return retList;
  };

  /**
   * @private
   */
  Events._handlersIdentical = function (handler1, handler2) {
    return (
      handler1.callback === handler2.callback &&
      handler1.attribute === handler2.attribute &&
      handler1.context === handler2.context &&
      handler1.listen === handler2.listen &&
      handler1.once === handler2.once
    );
  };

  /**
   * @private
   */
  Events._listenersIdentical = function (listener1, listener2) {
    return (
      listener1.event === listener2.event &&
      listener1.attribute === listener2.attribute &&
      listener1.context === listener2.context &&
      listener1.object === listener2.object
    );
  };

  /**
   * @private
   */
  Events._checkForHandler = function (handlerList, handler, handlerTest) {
    var i;
    if (handlerList === undefined) {
      return -1;
    }

    for (i = 0; i < handlerList.length; i += 1) {
      if (handlerTest(handlerList[i], handler)) {
        return i;
      }
    }
    return -1;
  };

  /**
   * @private
   */
  Events._getHandlers = function (handlers, eventType, original) {
    if (handlers && handlers[eventType] instanceof Array) {
      if (original) {
        return handlers[eventType];
      }
      // Make a copy
      var handlerReturn = [];
      var i;
      for (i = 0; i < handlers[eventType].length; i++) {
        handlerReturn.push(handlers[eventType][i]);
      }
      return handlerReturn;
    }
    return null;
  };
  oj._registerLegacyNamespaceProp('Events', Events);

  /**
   * @constructor
   * @final
   * @class oj.URLError
   * @classdesc Constructs a URLError, thrown when API calls are made that require a URL but no URL is
   * defined.
   * @since 1.0.0
   * @export
   */
  const URLError = function () {
    this.name = 'URLError';
    this.message = 'No URL defined';
  };
  oj._registerLegacyNamespaceProp('URLError', URLError);

  URLError.prototype = new Error();
  URLError.constructor = URLError;

  /**
   * @private
   * @constructor
   */
  const RestImpl = function (rootURL, model) {
    this.rootURL = rootURL;
    this.model = model;
    this.customURL = model.customURL;
    $.support.cors = true;
  };

  oj._registerLegacyNamespaceProp('RestImpl', RestImpl);

  RestImpl._HEADER_PROP = 'headers';

  // Add the properties in options to starter, if not already there
  RestImpl.addOptions = function (starter, options, customOptions) {
    var initial = $.extend(true, starter, customOptions);
    var tempOpt = options || {};
    Object.keys(tempOpt).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(tempOpt, prop) && prop !== 'oauthHeader') {
        if (!Object.prototype.hasOwnProperty.call(initial, prop)) {
          initial[prop] = tempOpt[prop];
        }
        if (prop === RestImpl._HEADER_PROP) {
          // Deep merge
          initial[prop] = $.extend(true, initial[prop], tempOpt[prop]);
        }
      }
    });

    if (options && options.oauthHeader) {
      // if there are no any headers then create a new one.
      if (!initial[RestImpl._HEADER_PROP]) initial[RestImpl._HEADER_PROP] = {};
      Object.keys(options.oauthHeader || {}).forEach(function (prop) {
        if (Object.prototype.hasOwnProperty.call(options.oauthHeader, prop)) {
          if (!Object.prototype.hasOwnProperty.call(initial[RestImpl._HEADER_PROP], prop)) {
            initial[RestImpl._HEADER_PROP][prop] = options.oauthHeader[prop];
          }
        }
      });
    }

    return initial;
  };

  RestImpl.prototype.getRecords = function (callback, errFunc, options, context) {
    var opt = options || {};
    var isJsonp = opt.dataType === 'jsonp';
    var urlInfo = this._getURL('read', this.rootURL, this.customURL, null, context, opt);
    var ajaxOptions = {
      crossDomain: opt.crossDomain || !isJsonp,
      dataType: this._getDataType(opt),
      jsonpCallback: opt.jsonpCallback,
      context: context !== null ? context : this,
      success: callback,
      error: errFunc
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = RestImpl.addOptions(ajaxOptions, opt, urlInfo);
    opt.xhr = this.ajax(ajaxOptions, context);
    return opt.xhr;
  };

  RestImpl.prototype._addHeaderProp = function (options) {
    var opt = options || {};
    if (!(this.model && this.model.omitLanguageHeader)) {
      opt[RestImpl._HEADER_PROP] = { 'Accept-Language': this.getLocale() };
    }
    return opt;
  };

  RestImpl.prototype.getRecord = function (success, error, recordID, options, context) {
    var opt = options || {};
    var isJsonp = opt.dataType === 'jsonp';
    var urlInfo = this._getURL('read', this.rootURL, this.customURL, recordID, context, opt);
    var ajaxOptions = {
      crossDomain: opt.crossDomain || !isJsonp,
      dataType: this._getDataType(opt),
      jsonpCallback: opt.jsonpCallback,
      context: context !== null ? context : this,
      success: success,
      error: error
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = RestImpl.addOptions(ajaxOptions, opt, urlInfo);
    opt.xhr = this.ajax(ajaxOptions, context);
    return opt.xhr;
  };

  RestImpl.prototype.updateRecord = function (
    callback,
    recordID,
    record,
    error,
    options,
    context,
    patch
  ) {
    var opt = options || {};
    var isJsonp = opt.dataType === 'jsonp';
    var urlInfo = this._getURL(
      patch ? 'patch' : 'update',
      this.rootURL,
      this.customURL,
      recordID,
      context,
      opt
    );
    var emulateHTTP = RestImpl._emulateHTTP(opt);
    var ajaxOptions = {
      crossDomain: opt.crossDomain || !isJsonp,
      contentType: this._getContentType(opt),
      dataType: this._getDataType(opt),
      jsonpCallback: opt.jsonpCallback,
      data: this._getData(JSON.stringify(record), opt, urlInfo),
      emulateHTTP: emulateHTTP,
      emulateJSON: RestImpl._emulateJSON(opt),
      success: callback,
      error: error,
      context: context !== null ? context : this
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = RestImpl.addOptions(ajaxOptions, opt, urlInfo);
    ajaxOptions = RestImpl._beforeSendMod(emulateHTTP, ajaxOptions);
    opt.xhr = this.ajax(ajaxOptions, context);
    return opt.xhr;
  };

  RestImpl._beforeSendMod = function (emulateHTTP, options) {
    var opt = options || {};
    if (emulateHTTP) {
      // Do a before send xhr mod for this case
      var beforeSend = opt.beforeSend;
      opt.beforeSend = function (xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', opt._method);
        if (beforeSend) {
          return beforeSend.apply(this, arguments);
        }
        return null;
      };
    }
    return opt;
  };

  RestImpl.prototype._getData = function (data, options, urlInfo) {
    if (RestImpl._emulateJSON(options)) {
      // Push record and _method into an object
      var retObj = { _method: urlInfo._method ? urlInfo._method : urlInfo.type };
      if (data) {
        retObj.model = data;
      }
      return retObj;
    }
    return data;
  };

  RestImpl.prototype._getHTTPMethod = function (operation, options) {
    if (options.type) {
      return { method: options.type };
    }
    var method = null;
    if (operation === 'create') {
      method = 'POST';
    }
    if (operation === 'delete') {
      method = 'DELETE';
    }
    if (operation === 'patch') {
      method = 'PATCH';
    }
    if (operation === 'update') {
      method = 'PUT';
    }
    if (RestImpl._emulateHTTP(options)) {
      // Convert method to POST, put original method under data._method
      return { method: 'POST', _method: method };
    }
    if (method === null) {
      method = 'GET';
    }
    return { method: method };
  };

  RestImpl._emulateHTTP = function (options) {
    return options.emulateHTTP || oj.emulateHTTP;
  };

  RestImpl._emulateJSON = function (options) {
    return options.emulateJSON || oj.emulateJSON;
  };

  RestImpl.prototype._getURL = function (operation, rootURL, customURL, recordID, context, options) {
    var httpMethod = this._getHTTPMethod(operation, options);
    if ($.isFunction(customURL)) {
      var result = customURL.call(
        this,
        operation,
        context,
        RestImpl.SetCustomURLOptions(recordID, context, options)
      );
      if (oj.StringUtils.isString(result)) {
        var ret = { url: result, type: httpMethod.method };
        if (httpMethod._method) {
          ret._method = httpMethod._method;
        }
        return ret;
      } else if (result) {
        result.url = Object.prototype.hasOwnProperty.call(result, 'url') ? result.url : rootURL;
        if (!Object.prototype.hasOwnProperty.call(result, 'type')) {
          result.type = httpMethod.method;
        }
        if (!Object.prototype.hasOwnProperty.call(result, 'data')) {
          if (httpMethod._method) {
            result._method = httpMethod._method;
          }
        }
        return result;
      }
    }
    var retObj = { url: RestImpl.GetPropValue(null, rootURL), type: httpMethod.method };
    if (httpMethod._method) {
      retObj._method = httpMethod._method;
    }
    return retObj;
  };

  RestImpl.prototype.deleteRecord = function (recordID, error, options, context) {
    var opt = options || {};
    var isJsonp = opt.dataType === 'jsonp';
    var urlInfo = this._getURL('delete', this.rootURL, this.customURL, recordID, context, opt);

    var emulateHTTP = RestImpl._emulateHTTP(opt);
    var emulateJSON = RestImpl._emulateJSON(opt);
    var ajaxOptions = {
      crossDomain: opt.crossDomain || !isJsonp,
      success: opt.success,
      error: error,
      context: context !== null ? context : this,
      emulateHTTP: emulateHTTP,
      emulateJSON: emulateJSON
    };
    var data = this._getData(null, opt, urlInfo);
    if (data) {
      ajaxOptions.data = data;
    }
    ajaxOptions = RestImpl.addOptions(ajaxOptions, opt, urlInfo);
    ajaxOptions = RestImpl._beforeSendMod(emulateHTTP, ajaxOptions);
    opt.xhr = this.ajax(ajaxOptions, context);
    return opt.xhr;
  };

  RestImpl.prototype.addRecord = function (record, error, options, context) {
    var opt = options || {};
    var recordStr = JSON.stringify(record);
    var isJsonp = opt.dataType === 'jsonp';
    var urlInfo = this._getURL('create', this.rootURL, this.customURL, null, context, opt);

    var emulateHTTP = RestImpl._emulateHTTP(opt);
    var ajaxOptions = {
      crossDomain: opt.crossDomain || !isJsonp,
      contentType: opt.contentType || 'application/json',
      dataType: this._getDataType(opt),
      jsonpCallback: opt.jsonpCallback,
      data: this._getData(recordStr, opt, urlInfo),
      success: opt.success,
      error: error,
      emulateHTTP: emulateHTTP,
      emulateJSON: RestImpl._emulateJSON(opt),
      context: context !== null ? context : this
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = RestImpl.addOptions(ajaxOptions, opt, urlInfo);
    opt.xhr = this.ajax(ajaxOptions, context);

    return opt.xhr;
  };

  RestImpl.prototype._getDataType = function (options) {
    if (RestImpl._emulateJSON(options) && !RestImpl._emulateHTTP(options)) {
      return 'application/x-www-form-urlencoded';
    }
    return options.dataType || 'json';
  };

  RestImpl.prototype._getContentType = function (options) {
    if (RestImpl._emulateJSON(options) && !RestImpl._emulateHTTP(options)) {
      return 'application/x-www-form-urlencoded';
    }

    return options.contentType || 'application/json';
  };

  RestImpl.prototype.getLocale = function () {
    return Config.getLocale();
  };

  RestImpl.prototype.ajax = function (settings, collection) {
    if (settings.url === null || settings.url === undefined) {
      throw new URLError();
    }

    var xhr = oj.ajax(settings);
    if (collection._addxhr) {
      collection._addxhr(xhr);
    }
    return xhr;
  };

  /**
   * Get all custom URL options
   * @protected
   */
  RestImpl.SetCustomURLOptions = function (recordID, context, opt) {
    var options = context instanceof oj.Collection ? context.ModifyOptionsForCustomURL(opt) : {};
    if (recordID) {
      options.recordID = recordID;
    }
    return options;
  };

  /**
   * @protected
   */
  RestImpl.GetPropValue = function (obj, property) {
    if (obj) {
      if ($.isFunction(obj[property])) {
        return obj[property]();
      }

      return obj[property];
    }
    return $.isFunction(property) ? property() : property;
  };

  /**
   * @export
   * @class Model
   * @classdesc Object representing name/value pairs for a data service record
   *
   * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Model object
   * @param {Object=} options
   *                  collection: collection for this model
   * @constructor
   * @final
   * @since 1.0
   * @mixes Events
   * @ojsignature {target: "Type", value: "class Model"}
   */
  const Model = function (attributes, options) {
    Model._init(this, attributes, options, null);
  };

  oj._registerLegacyNamespaceProp('Model', Model);

  /**
   * Subclass from oj.Object
   * @private
   */
  oj.Object.createSubclass(Model, oj.Object, 'oj.Model');

  /**
   * @private
   */
  Model.prototype.Init = function () {
    Model.superclass.Init.call(this);
  };

  /**
   *
   * @export
   * @desc Attribute/value pairs in the model.
   * @memberof Model
   *
   * @type Object
   * @since 1.0.0
   */
  Model.prototype.attributes = {};

  /**
   * @export
   * @desc The set of attribute/value pairs that serve as default values when new Model objects are created.
   * @memberof Model
   *
   * @type Object
   * @since 1.0.0
   */
  Model.prototype.defaults = {};

  /**
   * @export
   * @desc The model's unique ID.  This can be set by the application or retrieved from the data service. This ID
   * will be appended to the URL for single-record data operations (update, delete).
   * @memberof Model
   *
   * @type {string|null}
   * @since 1.0.0
   */
  Model.prototype.id = null;

  /**
   * @desc The name of the model property to be used as the unique ID. See [id]{@link Model#id}. This defaults to
   * a value of "id".
   * @memberof Model
   *
   * @type {string|null}
   * @since 1.0.0
   * @export
   */
  Model.prototype.idAttribute = 'id';

  /**
   * @export
   * @desc The base url on the data service used to perform CRUD operations on models.  If not defined, the model
   * will look to its collection.  One or the other must be defined before CRUD operations can succeed.
   * @memberof Model
   *
   * @type {string|null}
   * @since 1.0.0
   */
  Model.prototype.urlRoot = null;

  /**
   * @export
   * @desc A callback to allow users to completely customize the data service URLs
   * The callback should accept these parameters:<p>
   * <b>operation (string)</b>: one of "create", "read", "update", "patch", or "delete", indicating the type of
   * operation for which to return the URL<br>
   * <b>model (Object)</b>: the Model object requesting the URL<br>
   * <b>options (Object)</b>: one or more of the following properties:<br>
   * <ul>
   * <b>recordID</b>: id of the record involved, if relevant<br>
   * </ul>
   *
   * customURL callbacks should return either: null, in which case the default will be used; a url string, which
   * will be used with the standard HTTP method for the type of operation, or an Object with with any other
   * attributes that should be passed to the ajax call.<br>
   * This object must at minimum include the URL, and other attributes as follows:<br>
   * <ul>
   * <b>url</b>: giving the custom URL string<br>
   * <b>type</b>: (optional) a string indicating the type of HTTP method to use (GET, POST, DELETE, etc.)<br>
   * <b>(other)</b>: (optional) any other ajax attributes to pass in the ajax call
   * </ul>
   * <p>
   *
   * @memberof Model
   * @type {function(string,Model,Object):(string|Object|null)|null}
   * @ojsignature  {target: "Type", value: "function(string,Model,Model.CustomURLCallbackOptions):(string|Object|null)|null", for: "returns"}
   * @since 1.0.0
   */
  Model.prototype.customURL = null;

  /**
   * @typedef {Object} Model.CustomURLCallbackOptions
   * @property {string=} recordID id of the record involved, if relevant
   */

  /**
   * @export
   * @desc A callback to allow optional custom validation of model attributes during save, set, etc.
   * The callback should accept these parameters:<p>
   * <b>attributes (Object)</b>: the attributes to validation<br>
   * <b>options (Object)</b>: the options passed in to the model call making the validation check<br>
   *
   * The validate callback should return nothing if the attributes are valid, or an error string or object if the validation fails<br>
   * <p>
   *
   * @memberof Model
   * @type {function(Object,Object):(string|Object|null)|null}
   * @since 2.3.0
   */
  Model.prototype.validate = null;

  /**
   * @export
   * @memberof Model
   * @type {string|Object|null}
   * @desc The last value returned from a validate callback
   * @since 2.3.0
   */
  Model.prototype.validationError = null;

  /**
   * @export
   * @memberof Model
   *
   * @type {boolean}
   * @desc If true, do not insert the JET locale-based Accept-Language header.  If false, let the Ajax system set the header.
   * @since 5.0.0
   */
  Model.prototype.omitLanguageHeader = false;

  /**
   * @private
   */
  Model._idCount = 0;

  /**
   * @private
   */
  Model._init = function (model, attributes, opt, properties) {
    var parse;
    var attrCopy;
    var prop;

    if (Model._justExtending) {
      return;
    }

    model.Init(); // eslint-disable-line no-param-reassign

    // Augment with Event
    Events.Mixin(model);

    model._clearChanged(); // eslint-disable-line no-param-reassign
    model.previousAttrs = {}; // eslint-disable-line no-param-reassign
    model.nestedSet = false; // eslint-disable-line no-param-reassign
    model.index = -1; // eslint-disable-line no-param-reassign

    var options = opt || {};

    // Deep copy actual data if found
    model.attributes = {}; // eslint-disable-line no-param-reassign
    if (model.defaults && !options.ignoreDefaults) {
      // eslint-disable-next-line no-param-reassign
      model.attributes = Model._cloneAttributes(
        $.isFunction(model.defaults) ? model.defaults() : model.defaults,
        null
      );
    }

    // First, copy all properties passed in
    // eslint-disable-next-line no-restricted-syntax
    for (prop in properties) {
      if (Object.prototype.hasOwnProperty.call(properties, prop)) {
        model[prop] = properties[prop]; // eslint-disable-line no-param-reassign
      }
    }

    if (attributes) {
      parse = options.parse;
      if ($.isFunction(parse)) {
        model.parse = parse; // eslint-disable-line no-param-reassign
      }

      attrCopy = Model._cloneAttributes(attributes, model.attributes);
      model.attributes = attrCopy; // eslint-disable-line no-param-reassign

      attrCopy = parse ? model.parse(attrCopy) : attrCopy;
      if (attrCopy == null || attrCopy === undefined) {
        // Reset it
        model.attributes = {}; // eslint-disable-line no-param-reassign
      } else {
        // Move them in
        // eslint-disable-next-line no-restricted-syntax
        for (prop in attrCopy) {
          if (Object.prototype.hasOwnProperty.call(attrCopy, prop)) {
            model._setProp(prop, attrCopy[prop], false, false, options, true);
          }
        }
      }
    }

    model.SetCid();

    // Grab collection option, if there
    model.SetCollection(options.collection);

    if (options.customURL) {
      model.customURL = options.customURL; // eslint-disable-line no-param-reassign
    }

    // If URL is set, use that
    if (options.url) {
      model.url = options.url; // eslint-disable-line no-param-reassign
    }

    if (options.urlRoot) {
      model.urlRoot = options.urlRoot; // eslint-disable-line no-param-reassign
    }

    if (model.initialize) {
      model.initialize(attributes, options);
    }

    model.SetupId();
  };

  /**
   * Create a new, specific type of model object to represent single records from a JSON data set.
   * @param {Object=} properties Properties for the new Model class.<br>
   *                  <b>defaults</b>: an Object containing starting attribute/value pairs for some or all of the
   *                  model's potential attributes<br>
   *                  <b>parse</b>: a user callback function to allow parsing of JSON record objects as they are
   *                  returned from the data service<br>
   *                  <b>parseSave</b>: a user callback function to allow conversion of models back into a format
   *                  appropriate for the data service on save calls<br>
   *                  <b>urlRoot</b>: the URL to use to get records from the data service in the abscence of a
   *                  collection (when an id is appended)<br>
   *                  <b>initialize</b>: a user callback function to be called when this model is created<br>
   *                  <b>validate</b>: a user callback function that will be called before a save to the data
   *                  service occurs. The callback is passed the current set of attributes and save options.
   *                  <br>
   * @param {Object=} classProperties properties that attach to the whole class
   * @return {Model} new Model object
   * @export
   * @ojsignature [{target: "Type",
   *                value: "any",
   *                for: "returns"},
   *               {target: "Type", value:"{parse?: (data: any)=> any, parseSave?: (data: any)=> any, urlRoot?: string,
   *                                        initialize?: (models: Array<Model>, options: object)=> void,
   *                                        validate?: null|object|string|((attributes: object, options?: Model)=> number), [propName: string]: any}", for: "properties"}]
   * @memberof Model
   * @this {Model}
   * @since 1.0.0
   */
  Model.extend = function (properties, classProperties) {
    Model._justExtending = true;
    var obj;

    obj = new Model();
    Model._justExtending = false;

    // Add regular properties from this "parent"
    // Events.Mixin(obj, this.prototype);
    $.extend(obj, this.prototype);

    // Grab properties
    var props = properties || {};
    Object.keys(props).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(props, prop)) {
        obj[prop] = props[prop];
      }
    });

    var model;

    if (props && props.constructor && Object.prototype.hasOwnProperty.call(props, 'constructor')) {
      model = props.constructor;
    } else {
      model = function (attributes, options) {
        Model._init(this, attributes, options, props);
      };
    }

    $.extend(model, this);
    model.prototype = obj;

    // Allow extending resulting obj
    model.extend = Model.extend;

    model.prototype.constructor = model;

    // Add class properties from this
    Events.Mixin(model, this);

    if (classProperties) {
      Object.keys(classProperties).forEach(function (prop) {
        if (Object.prototype.hasOwnProperty.call(classProperties, prop)) {
          model[prop] = classProperties[prop];
        }
      });
    }

    return model;
  };

  /**
   * Placeholder for event mixins
   * @private
   */
  Model.prototype.TriggerInternal = function (silent, event, arg1, arg2, options) {}; // eslint-disable-line no-unused-vars

  /**
   * @protected
   */
  Model.prototype.SetCid = function () {
    // Create cid property if necessary
    if (!this.GetCid()) {
      this.cid = 'id' + Model._idCount;
      Model._idCount += 1;
    }
  };

  /**
   * @protected
   */
  Model.prototype.GetCid = function () {
    return this.cid;
  };

  /**
   * Index within collection
   * @protected
   */
  Model.prototype.SetIndex = function (index) {
    this.index = index;
  };

  /**
   * @protected
   */
  Model.prototype.GetIndex = function () {
    return this.index;
  };

  /**
   * LRU functions
   * @protected
   */
  Model.prototype.SetNext = function (model) {
    var retVal = this.nextModel;
    this.nextModel = model;
    return retVal;
  };

  /**
   * @protected
   */
  Model.prototype.GetNext = function () {
    return this.nextModel;
  };

  /**
   * @protected
   */
  Model.prototype.SetPrevious = function (model) {
    var retVal = this.previousModel;
    this.previousModel = model;
    return retVal;
  };

  /**
   * @protected
   */
  Model.prototype.GetPrevious = function () {
    return this.previousModel;
  };

  /**
   * Merge the given model's attributes with this model's attributes
   * @protected
   */
  Model.prototype.Merge = function (model, comparator, silent) {
    var needSort = false;
    var isStringComparator = oj.StringUtils.isString(comparator);
    var valueChange;
    var changes = false;

    var self = this;
    Object.keys(model.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(model.attributes, prop)) {
        valueChange = self.attributes[prop] !== model.attributes[prop];
        if (isStringComparator) {
          // We have a string comparator--does it match this property?  If we hit a property that doesn't
          // match, we need sort
          if (prop === comparator) {
            // The property matches the comparator property: are we changing the value?
            if (valueChange) {
              needSort = true;
            }
          }
        } else if (valueChange) {
          needSort = true;
        }
        if (valueChange) {
          changes = true;
          self.attributes[prop] = model.attributes[prop];
          self._addChange(prop, model.attributes[prop]);
          self._fireAttrChange(prop, self.attributes[prop], null, silent);
        }
      }
    });
    this.SetupId();
    // Only fire master change if there were any changes
    if (changes) {
      this._fireChange(null, silent);
    }
    return needSort;
  };

  /**
   * @private
   */
  Model._hasProperties = function (object) {
    if (object && object instanceof Object) {
      var prop;
      // eslint-disable-next-line no-restricted-syntax
      for (prop in object) {
        if (Object.prototype.hasOwnProperty.call(object, prop)) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * @protected
   */
  Model.prototype.SetCollection = function (coll) {
    if (coll == null) {
      delete this.collection;
      return;
    }
    this.collection = coll;
    // This can depend on the collection
    this.SetupId();
  };

  /**
   * @protected
   */
  Model.prototype.GetCollection = function () {
    return this.collection;
  };

  /**
   * @private
   */
  Model.prototype._fireAttrChange = function (prop, value, options, silent) {
    if (prop != null) {
      this.TriggerInternal(silent, Events.EventType.CHANGE + ':' + prop, this, value, options);
    }
  };

  /**
   * @private
   */
  Model.prototype._fireChange = function (options, silent) {
    this.TriggerInternal(silent, Events.EventType.CHANGE, this, options, null);
  };

  /**
   * @protected
   */
  Model.prototype.SetupId = function () {
    // Replicate id attribute at top level
    var id = null;
    // Ask for collection's function if available
    if (this.collection && this.collection.modelId) {
      var modFunc = this.collection.modelId;
      id = $.isFunction(modFunc) ? modFunc.call(this.collection, this.attributes) : modFunc;
    }
    if (!id) {
      var idAttr = this._getIdAttr();
      id = this.attributes != null ? this.attributes[idAttr] : null;
    }
    // Supposedly this should always be model.id...who knew?
    this.id = id;
  };

  /**
   * @private
   */
  Model.prototype._setPropInternal = function (prop, value, copyRegardless) {
    var equality = oj.Object.__innerEquals(this.attributes[prop], value);
    if (copyRegardless || !equality) {
      this.attributes[prop] = value;
      this.SetupId();
      // Return value management here seems bizarre due to backbone tests: do the direct set if copyRegardless,
      // but only return if the inner equals was different
      return !equality;
    }
    return false;
  };

  /**
   * @private
   */
  Model.prototype._clearChanged = function () {
    this.changed = {};
  };

  /**
   * @private
   */
  Model.prototype._addChange = function (property, value) {
    this.changed[property] = value;
  };

  /**
   * @ignore
   * @private
   * @param {Object|string} prop
   * @param {Object|null|undefined} value
   * @param {boolean} copyRegardless
   * @param {boolean} propertyBag
   * @param {Object} options
   * @param {boolean} init
   * @returns {boolean}
   */
  Model.prototype._setProp = function (prop, value, copyRegardless, propertyBag, options, init) {
    if (prop == null) {
      return true;
    }

    var attrs = {};
    var isNested = this.nestedSet;
    var opts;

    if (!propertyBag) {
      attrs[prop] = value;
    } else {
      // We've passed in a whole property bag at once: validate all together
      Object.keys(prop).forEach(function (p) {
        if (Object.prototype.hasOwnProperty.call(prop, p)) {
          attrs[p] = prop[p];
        }
      });
    }
    opts = options || {};

    if (!this._checkValid(attrs, { validate: opts.validate }, false)) {
      return false;
    }

    if (!isNested) {
      this._clearChanged();
      this.changes = [];
    }

    // Store old value
    if (!this.nestedSet && !init) {
      this.previousAttrs = Model._cloneAttributes(this.attributes, null);
    }

    this.nestedSet = true;
    var self = this;
    Object.keys(attrs).forEach(function (p) {
      if (Object.prototype.hasOwnProperty.call(attrs, p)) {
        if (self._setPropInternal(p, attrs[p], copyRegardless)) {
          // Trigger changes
          self._addChange(p, attrs[p]);
          self.changes.push(p);
        } else {
          delete attrs[p];
        }
      }
    });
    // Fire events: don't fire if silent
    var silent = opts.silent;
    Object.keys(attrs).forEach(function (p) {
      if (Object.prototype.hasOwnProperty.call(attrs, p)) {
        if (!silent && (self.changes.length > 0 || (isNested && self.changes.indexOf(p) === -1))) {
          self.pendingChanges = true;
          self.pendingOpts = opts;
        }
        self._fireAttrChange(p, attrs[p], opts, silent);
      }
    });

    if (isNested) {
      return true;
    }
    if (!silent && !isNested) {
      while (this.pendingChanges) {
        this.pendingChanges = false;
        this._fireChange(this.pendingOpts, silent);
      }
    }

    this.nestedSet = false;
    return true;
  };

  /**
   * Clears all attributes from the model<br>
   * Events:<p>
   * <ul>
   * <b>change:attr</b>: fired for each attribute cleared, passing the model, name of the changed property, and
   * options<br>
   * <b>change:all</b>: fired after all attributes have been cleaered, passing the model and options<br>
   * </ul>
   * <p>
   *
   * @param {Object=} options
   * @property {boolean=} silent if true, do not fire events
   * @property {boolean=} validate if true, validate the unsetting of all properties
   * @return {Model|boolean} the model, or false if validation on clear fails
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.clear = function (options) {
    // Use unset to silently clear, to track changes to attributes
    var unsetOpt = { silent: true };
    var silent;
    var p;
    var opt = options || {};
    silent = opt.silent;
    unsetOpt.validate = opt.validate;
    this._clearChanged();

    var self = this;
    // eslint-disable-next-line no-restricted-syntax
    for (p in self.attributes) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, p)) {
        if (!this._unsetInternal(p, unsetOpt, true)) {
          return false;
        }
        this.TriggerInternal(silent, Events.EventType.CHANGE + ':' + p, this, undefined, null);
      }
    }
    this.attributes = {};
    this.SetupId();

    this._fireAttrChange(null, null, null, silent);
    this._fireChange(null, silent);
    return this;
  };

  /**
   * @private
   */
  Model._cloneAttributes = function (oldData, nd) {
    var newData = nd || {};

    // Handle not overwriting defaults with undefined
    // IE11 issue with Object.keys
    var newDataKeys = typeof newData === 'object' ? Object.keys(newData) : [];

    var canUseJson = true;

    var prop;
    if (newDataKeys.length > 0) {
      // eslint-disable-next-line no-restricted-syntax
      for (prop in newData) {
        if (
          Object.prototype.hasOwnProperty.call(newData, prop) &&
          Object.prototype.hasOwnProperty.call(oldData, prop)
        ) {
          // They both have this: now is oldData undefined?
          if (oldData[prop] === undefined) {
            // Remove it so it doesn't get copied/overwritten
            delete oldData[prop]; // eslint-disable-line no-param-reassign
          }
        }
      }
      oj.CollectionUtils.copyInto(newData, oldData, undefined, true, 10000);
      return newData;
    }
    var type;
    // eslint-disable-next-line no-restricted-syntax, guard-for-in
    for (prop in oldData) {
      type = $.type(oldData[prop]);
      if (
        type === 'function' ||
        type === 'undefined' ||
        type === 'date' ||
        type === 'array' ||
        type === 'object'
      ) {
        canUseJson = false;
        break;
      }
    }

    if (canUseJson) {
      newData = JSON.parse(JSON.stringify(oldData));
    } else if (typeof oldData === 'object') {
      // IE11 issue with Object.keys
      oj.CollectionUtils.copyInto(newData, oldData, undefined, true, 10000);
    }
    return newData;
  };

  /**
   * Return a copy of the model with identical attributes and settings
   * @return {Model} copy of the model
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.clone = function () {
    var c = new this.constructor();
    var prop;

    // eslint-disable-next-line no-restricted-syntax
    for (prop in this) {
      // Shallow copy all but data
      if (Object.prototype.hasOwnProperty.call(this, prop) && this[prop] !== this.attributes) {
        c[prop] = this[prop];
      }
    }
    // Deep copy data
    c.attributes = Model._cloneAttributes(this.attributes, null);

    // Remove the cid--this should be unique
    delete c.cid;
    // Set a new cid
    c.SetCid();

    c.SetupId();

    return c;
  };

  /**
   * Does this model match the given id or cid?
   * @protected
   */
  Model.prototype.Match = function (id, cid) {
    var modId = this.GetId();
    var modCid;
    // eslint-disable-next-line eqeqeq
    if (modId !== undefined && modId == id) {
      return true;
    }
    modCid = this.cid;
    // eslint-disable-next-line eqeqeq
    if (modCid !== undefined && modCid == cid) {
      return true;
    }
    return false;
  };

  /**
   * Set the value(s) of one or more attributes of the model, and fire events.
   * Events:<p>
   * <ul>
   * <b>change:attr</b>: fired for each attribute set, passing the model, name of the changed property, and options<br>
   * <b>change:all</b>: fired after all attributes have been set, passing the model and options<br>
   * </ul>
   * <p>
   * @param {string|Object} property Property attribute name to set, or an Object containing attribute/value pairs
   * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
   * @param {Object=} options
   * @property {boolean=} silent prevent events from firing
   * @property {boolean=} unset delete all the properties passed in rather than setting them<br>
   * @returns {Model|boolean} the model itself, false if validation failed on set
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.set = function (property, value, options) {
    var opts = options || {};
    var prop;
    var valid = true;

    if (arguments && arguments.length > 0) {
      // Check if first arg is not a string (property name)
      if (!oj.StringUtils.isString(property)) {
        // Options, if present, must be second argument...value, because a string/value
        // pair wasn't what was passed in
        opts = value || {};
        // For set, pass entire thing to setProp
        if (opts.unset) {
          // eslint-disable-next-line no-restricted-syntax
          for (prop in property) {
            if (Object.prototype.hasOwnProperty.call(property, prop)) {
              this._unsetInternal(prop, null, false);
            }
          }
        } else if (!this._setProp(property, null, true, true, opts, false)) {
          valid = false;
        }
      } else if (opts.unset) {
        // Not a property bag?  We assume it's a property/value argument
        this._unsetInternal(property, null, false);
      } else if (!this._setProp(property, value, false, false, opts, false)) {
        valid = false;
      }
    }
    if (valid) {
      return this;
    }
    return false;
  };

  /**
   * Deletes the given property from the model.<br>
   * Events:<p>
   * <ul>
   * <b>change:attr</b>: fired for each attribute unset: passing the model, name of the changed property, and
   * options<br>
   * <b>change:all</b>: fired after all attributes have been unset: passing the model and options<br>
   * @param {string} property Property to remove from model
   * @param {Object=} options
   * @property {boolean=} silent do not fire change events if true
   * @returns {boolean} false if validation of the unset fails
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.unset = function (property, options) {
    return this._unsetInternal(property, options, false);
  };

  /**
   * @private
   */
  Model.prototype._unsetInternal = function (property, opts, clear) {
    var options = opts || {};
    var silent = options.silent;
    var attrs = {};

    if (this.has(property)) {
      if (!this._checkValid(attrs, options, false)) {
        return false;
      }
      if (!clear) {
        this._clearChanged();
      }

      delete this.attributes[property];
      this._addChange(property, undefined);
      this._fireAttrChange(property, null, null, silent);
      this._fireChange(null, silent);
    }
    this.SetupId();
    return true;
  };

  /**
   * Returns the value of a property from the model.
   * @param {string} property Property to get from model
   * @return {any} value of property
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.get = function (property) {
    return this.attributes[property];
  };

  /**
   * Determines if the Model has a certain property set, vs. undefined.
   * @param {string} property Property to check for
   * @return {boolean} true if the model contains the given property, false if undefined.
   * @memberof Model
   * @export
   */
  Model.prototype.has = function (property) {
    return oj.Collection._defined(this.attributes[property]);
  };

  /**
   * Loads the Model object from the data service URL. Performs a data "read."<br>
   * Events:<p>
   * <ul>
   * <b>request</b>: fired when the request to fetch is going to the server, passing the model, xhr object, and
   * options<br>
   * <b>sync</b>: fired when the model is fetched from the data service, passing the model and the raw response<br>
   * <b>error</b>: fired if there is an error during the fetch, passing the model, xhr ajax object, and options<br>
   * </ul>
   * <p>
   * @param {Object=} options Options to control fetch<p>
   * <b>success</b>: a user callback called when the fetch has completed successfully. This makes the fetch an
   * asynchronous process. The callback is called passing the Model object, raw response, and the fetch options
   * argument.<p>
   * <b>error</b>: a user callback function called if the fetch fails. The callback is called passing the model
   * object, error, options, xhr, and status.<p>
   * @return {Object} xhr ajax object, by default.  If [sync]{@link Model#sync} has been replaced, this would be
   * the value returned by the custom implementation.
   * @memberof Model
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (model: Model, response: any, options: object)=> void,
   *                                                  error?: (model: Model, error: any, options: object, xhr: any, status: any)=> void,
   *                                                  [propName: string]: any}", for: "options"}
   * @export
   */
  Model.prototype.fetch = function (options) {
    var tempOpts = options || {};
    var success = tempOpts.success;
    var userErr = tempOpts.error;
    var self = this;
    var opts;

    opts = Model._copyOptions(tempOpts);
    opts.error = function (xhr, status, err) {
      // Trigger an error event
      Model._triggerError(self, false, tempOpts, status, err, xhr);

      if (userErr) {
        userErr.apply(self, [self, err, options, xhr, status]);
      }
    };

    opts.success = function (response) {
      // Make sure we pass xhr
      if (opts.xhr) {
        tempOpts.xhr = opts.xhr;
      }
      Model._fireSyncEvent(self, response, opts, false);

      if ($.isFunction(self.parse)) {
        self.set(self.parse(response), opts);
      }
      if (success) {
        success.call(Model.GetContext(opts, self), self, response, tempOpts);
      }
    };
    return Model._internalSync('read', this, opts);
  };

  /**
   * @private
   */
  Model.prototype._parseImpl = function (rawData) {
    return rawData;
  };

  /**
   * Optional callback to parse responses from the server.  It is called with the server's response with a model's data and should return a response (possibly modified) for processing
   * @type {function(Object):Object}
   *
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.parse = Model.prototype._parseImpl;

  /**
   * Return the URL used to access this model in the data source
   *
   * @returns {string|null} url to access this model in the data source
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.url = function () {
    var urlRoot = this._getUrlRoot();
    var id = this.GetId();
    var coll;
    var collUrl;
    var slash;

    if (urlRoot) {
      return id ? urlRoot + '/' + encodeURIComponent(id) : urlRoot;
    }

    coll = this.collection;
    if (coll) {
      collUrl = RestImpl.GetPropValue(coll, 'url');
      if (id && collUrl) {
        slash = Model._getLastChar(collUrl) === '/' ? '' : '/';
        return collUrl + slash + encodeURIComponent(this.GetId());
      }
      return collUrl;
    }

    throw new URLError();
  };

  /**
   * Return all of the model's attributes as an array
   *
   * @returns {Array.<Object>} array of all the model's attributes
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.keys = function () {
    var retArray = [];
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        retArray.push(prop);
      }
    });
    return retArray;
  };

  /**
   * Return all of the model's attributes values as an array
   *
   * @returns {Array.<Object>} array of all the model's attributes values
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.values = function () {
    var retArray = [];
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        retArray.push(self.get(prop));
      }
    });
    return retArray;
  };

  /**
   * Return an array of attributes/value pairs found in the model
   *
   * @returns {Array.<Object>} returns the model's attribute/value pairs as an array
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.pairs = function () {
    var retObj = [];
    var item;
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        item = [];
        item.push(prop);
        item.push(self.get(prop));
        retObj.push(item);
      }
    });
    return retObj;
  };

  /**
   * Return attribute/value pairs for the model minus those attributes listed in keys
   *
   * @param {Array.<Object>|Object} keys keys to exclude from the returned attribute/value pairs
   *
   * @returns {Object} array of the model's attribute/value pairs except those listed in keys
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.omit = function (keys) {
    var keyArr = [];
    var i;
    var retObj = {};

    if (keys instanceof Array) {
      keyArr = keys;
    } else {
      for (i = 0; i < arguments.length; i++) {
        keyArr.push(arguments[i]);
      }
    }
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        if (keyArr.indexOf(prop) === -1) {
          retObj[prop] = self.get(prop);
        }
      }
    });
    return retObj;
  };

  /**
   * Return attribute/value pairs for the model for the keys
   *
   * @param {Array.<Object>|Object} keys keys for which to return attribute/value pairs
   *
   * @returns {Array.<Object>} array of the model's attribute/value pairs filtered by keys
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.pick = function (keys) {
    var keyArr = [];
    var i;
    var retObj = {};

    if (keys instanceof Array) {
      keyArr = keys;
    } else {
      for (i = 0; i < arguments.length; i++) {
        keyArr.push(arguments[i]);
      }
    }
    for (i = 0; i < keyArr.length; i++) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, keyArr[i])) {
        retObj[keyArr[i]] = this.get(keyArr[i]);
      }
    }
    return retObj;
  };

  /**
   * Return an array of value/attribute pairs found in the model
   *
   * @returns {Object} returns the model's value/attribute pairs as an array
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.invert = function () {
    var retObj = {};
    var val;
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        val = self.get(prop);
        retObj[val] = prop;
      }
    });
    return retObj;
  };

  /**
   * @private
   */
  Model._getLastChar = function (str) {
    return str.charAt(str.length - 1);
  };

  /**
   * @private
   */
  Model.prototype._saveUrl = function () {
    var urlRoot = this._getUrlRoot();
    if (urlRoot) {
      return urlRoot;
    }

    if (this.GetCollection()) {
      return this.GetCollection().url;
    }

    return null;
  };

  /**
   * @private
   */
  Model.prototype._getUrlRoot = function () {
    return RestImpl.GetPropValue(this, 'urlRoot');
  };

  /**
   * @private
   */
  Model.prototype._parseSaveImpl = function (modelData) {
    return modelData;
  };

  /**
   * Callback function when writing a model to the server
   * @type {function(Object):Object}
   * @since 1.0.0
   * @memberof Model
   *
   * @export
   */
  Model.prototype.parseSave = Model.prototype._parseSaveImpl;

  /**
   * Check to see if the model is valid by running the validate callback, if it is set
   *
   * @returns {boolean} true if validate passes or if no validate callback
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.isValid = function () {
    var options = { validate: this.validate };
    return this._checkValid(this.attributes, options, false);
  };

  /**
   * @private
   */
  Model._isValidateSet = function (opt, save) {
    var options = opt || {};
    if (options.validate !== undefined && options.validate !== null) {
      return options.validate;
    }
    // The "default" is different for save vs. set
    return save;
  };

  /**
   * @private
   */
  Model.prototype._checkValid = function (attributes, opt, save) {
    var options = opt || {};
    var validate = this.validate;
    if (validate && Model._isValidateSet(options, save)) {
      // If we have a validate override and it returns something, don't save
      this.validationError = validate.call(this, attributes, options);
      if (this.validationError) {
        this.TriggerInternal(false, Events.EventType.INVALID, this, this.validationError, options);
        return false;
      }
    }
    return true;
  };

  /**
   * @private
   */
  Model._processArgs = function (args) {
    var ignoreLastArg = false;
    var options = {};
    var attributes = {};
    var i;

    if (args) {
      if (args.length > 0) {
        // Check if the last argument is not the first argument
        if (args.length > 1) {
          if (args[args.length - 1] && Model._hasProperties(args[args.length - 1])) {
            // Last arg is options: ignore later
            ignoreLastArg = true;
            options = args[args.length - 1] || {};
          }
        }
        if (args[0] == null) {
          return { attributes: null, options: options };
        }

        // Check if first arg is property bag
        if (Model._hasProperties(args[0]) || oj.Object.isEmpty(args[0])) {
          Object.keys(args[0]).forEach(function (prop) {
            if (Object.prototype.hasOwnProperty.call(args[0], prop)) {
              attributes[prop] = args[0][prop];
            }
          });
        } else {
          // Not a property bag?  We assume arguments are a series of attr/values
          for (i = 0; i < args.length; i += 2) {
            // Process the arg as long as its: defined, and isn't the last argument where we're supposed to
            // ignore the last argument due to it being 'options'
            if (
              args[i] !== undefined ||
              i < args.length - 1 ||
              (!ignoreLastArg && i === args.length - 1)
            ) {
              attributes[args[i]] = args[i + 1];
            }
          }
        }
      }
    }
    return { attributes: attributes, options: options };
  };

  /**
   * @private
   */
  Model._copyOptions = function (opt) {
    var optReturn = {};
    var options = opt || {};

    Object.keys(options).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(options, prop)) {
        optReturn[prop] = options[prop];
      }
    });
    return optReturn;
  };

  /**
   * @private
   */
  Model._triggerError = function (self, silent, opt, status, err, xhr) {
    var options = opt || {};
    options.textStatus = status;
    options.errorThrown = err;
    self.TriggerInternal(silent, Events.EventType.ERROR, self, xhr, options);
  };

  /**
   * Saves the current Model object to the data service. Performs a data "update."<br>
   * Events:<p>
   * <ul>
   * <b>change:attr</b>: fired for each attribute changed, if passed in as part of the save: passing the model, name
   * of the changed property, and options<br>
   * <b>change:all</b>: fired after all attributes have been set, if passed in as part of the save: passing the
   * model and options<br>
   * <b>request</b>: fired when the request to save is going to the server, passing the model, xhr object, and
   * options<br>
   * <b>sync</b>: fired when the model is saved to the data service, passing the model and the raw response<br>
   * <b>error</b>: fired if there is an error during the save, passing the model, xhr ajax object, and options<br>
   * </ul>
   * <p>
   * @param {Object=} attributes One or more attribute name/value pairs to set on the model before the save.
   * @param {Object=} options Options to control save<br>
   * <b>success</b>: a user callback called when the save has completed successfully. This makes the save an
   * asynchronous process. The callback is called passing the Model object, response from the AJAX call, and the
   * fetch options argument.<p>
   * <b>error</b>: a user callback function called if the save fails. <p>
   * <b>contentType</b>: in case the user's REST service requires a different POST content type than the default,
   * 'application/json'<p>
   * <b>validate</b>: should the validation routine be called if available<p>
   * <b>wait</b>: if true, wait for the server call before setting the attributes on the model<p>
   * <b>patch</b>: should only changed attributes be sent via a PATCH?<p>
   * <b>attrs</b>: pass a set of attributes to completely control the set of attributes that are saved to the
   * server (generally used with patch)
   * @return {Object|boolean} returns false if validation failed, or the xhr object
   * @memberof Model
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (model: Model, response: any, options: object)=> void,
   *                                                  error?: (model: Model, error: any, options: object, xhr: any, status: any)=> void,
   *                                                  contentType?: string, valdiate?: boolean, wait?: boolean, patch?: boolean, attrs?: object,
   *                                                  [propName: string]: any}", for: "options"}
   * @export
   */
  Model.prototype.save = function (attributes, options) {
    var forceNew;
    var success;
    var callback;
    var self;
    var userErr;
    var patch;
    var argResults = Model._processArgs(arguments);
    var opts;
    var oldAttrs;
    var attrArgs;
    attrArgs = attributes === undefined ? undefined : argResults.attributes;

    var tempOpts = options || {};
    opts = Model._copyOptions(argResults.options);

    var validAttrs = $.extend(true, {}, this.attributes, attrArgs);
    if (!this._checkValid(validAttrs, opts, true)) {
      return false;
    }

    if (!opts.wait) {
      this.set(attrArgs);
    }

    forceNew = opts.forceNew === undefined ? false : opts.forceNew;
    self = this;
    userErr = opts.error;
    patch = opts.patch;

    opts.error = function (xhr, status, err) {
      // Trigger an error event
      Model._triggerError(self, false, tempOpts, status, err, xhr);

      if (userErr) {
        userErr.apply(self, [self, err, options, xhr, status]);
      }
    };

    opts.saveAttrs = opts.wait ? this._attrUnion(attrArgs) : this.attributes;

    // Must temporarily at least set attrs for toJSON()
    oldAttrs = this.attributes;
    // Swap in what's to be saved and call toJSON()
    this.attributes = opts.saveAttrs;
    opts.saveAttrs = this.toJSON();
    this.attributes = oldAttrs;

    if (!forceNew && !this.isNew()) {
      success = opts.success;
      opts.success = function (resp) {
        var attrs;

        // Make sure we pass xhr
        if (opts.xhr) {
          tempOpts.xhr = opts.xhr;
        }

        if (resp && !oj.Object.isEmpty(resp)) {
          if ($.isFunction(self.parse)) {
            attrs = self.parse(resp);
          } else {
            attrs = resp;
          }

          self.attributes = $.extend(true, self.attributes, attrs);

          // Merge attrs from response/parse into arg attrs if different--server takes priority in case
          // of 'wait'
          if (opts.wait) {
            Object.keys(attrArgs || {}).forEach(function (prop) {
              if (Object.prototype.hasOwnProperty.call(attrs, prop)) {
                // Prioritize the one in attrs
                attrArgs[prop] = attrs[prop];
              }
            });
          }
          self.SetupId();
        }
        Model._fireSyncEvent(self, resp, opts, false);

        if (opts.wait) {
          self.set(attrArgs);
        }

        if (success) {
          success.call(Model.GetContext(opts, self), self, resp, tempOpts);
        }
        self._clearChanged();
      };
      // If caller passes in attrs themselves, just use those
      if (!opts.attrs) {
        if (attrArgs === undefined) {
          opts.attrs = undefined;
        } else {
          opts.attrs = patch ? attrArgs : opts.saveAttrs;
        }
      }
      return Model._internalSync(patch ? 'patch' : 'update', this, opts);
    }

    callback = Model._getSuccess(opts);
    opts.success = function (resp) {
      var attrs;
      // Make sure we pass xhr
      if (opts.xhr) {
        tempOpts.xhr = opts.xhr;
      }
      if (resp && !oj.Object.isEmpty(resp)) {
        if ($.isFunction(self.parse)) {
          attrs = self.parse(resp);
        } else {
          attrs = resp;
        }
        if (!self._checkValid(attrs, opts, true)) {
          return;
        }

        self.attributes = $.extend(true, self.attributes, attrs);

        // Merge attrs from response/parse into arg attrs if different--server takes priority in case of 'wait'
        if (opts.wait) {
          Object.keys(attrArgs || {}).forEach(function (prop) {
            if (Object.prototype.hasOwnProperty.call(attrs, prop)) {
              // Prioritize the one in attrs
              attrArgs[prop] = attrs[prop];
            }
          });
        }
        self.SetupId();
      }
      Model._fireSyncEvent(self, resp, opts, false);
      if (opts.wait) {
        self.set(attrArgs);
      }

      if (callback) {
        callback.call(Model.GetContext(opts, self), self, resp, tempOpts);
      }
      self._clearChanged();
    };

    // If caller passed in attrs, just use those
    if (!opts.attrs) {
      opts.attrs = opts.saveAttrs;
    }

    // Turn on parse flag
    opts.parse = true;

    // Bizarre case tested by backboneJS--if this is a new model, but we're patching, make sure we only save the
    // explicit attrs if passed in by user
    if (patch) {
      opts.saveAttrs = opts.attrs;
    }
    return Model._internalSync('create', this, opts);
  };

  /**
   * @private
   */
  Model.prototype._attrUnion = function (attrs) {
    var attrReturn = {};
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        attrReturn[prop] = self.attributes[prop];
      }
    });
    Object.keys(attrs || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(attrs, prop)) {
        attrReturn[prop] = attrs[prop];
      }
    });
    return attrReturn;
  };

  /**
   * @protected
   */
  Model.IsComplexValue = function (val) {
    return (
      val &&
      Object.prototype.hasOwnProperty.call(val, 'value') &&
      Object.prototype.hasOwnProperty.call(val, 'comparator')
    );
  };

  /**
   * Does this model contain all of the given attribute/value pairs?
   * @private
   */
  Model.prototype._hasAttrs = function (attrs) {
    var prop;

    // eslint-disable-next-line no-restricted-syntax
    for (prop in attrs) {
      if (Object.prototype.hasOwnProperty.call(attrs, prop)) {
        if (!Object.prototype.hasOwnProperty.call(this.attributes, prop)) {
          return false;
        }

        var val = Array.isArray(attrs[prop]) ? attrs[prop] : [attrs[prop]];
        for (var i = 0; i < val.length; i++) {
          if (Model.IsComplexValue(val[i])) {
            var comparator = val[i].comparator;
            var value = val[i].value;
            if (oj.StringUtils.isString(comparator)) {
              throw new Error('String comparator invalid for local where/findWhere');
            }
            if (!comparator(this, prop, value)) {
              return false;
            }
          } else if (attrs[prop] !== this.attributes[prop]) {
            // Array case meaningless here.  Model can't be == value1 and value2
            return false;
          }
        }
      }
    }
    return true;
  };

  /**
   * Return a function that determines if this model contains all of the property/values in attrs
   *
   * @param {Object} attrs property/value pairs
   * @returns {function(Model):boolean} function taking an Model that returns true if all of attrs are contained within it
   * @memberof Model
   * @since 1.1.0
   * @export
   */
  Model.prototype.matches = function (attrs) {
    return (function (model) {
      // eslint-disable-next-line no-restricted-syntax
      for (var prop in attrs) {
        if (model.get(prop) !== attrs[prop]) {
          return false;
        }
      }
      return true;
    })(this);
  };

  /**
   * See if this model contains any of the given attribute/value pairs
   * @protected
   */
  Model.prototype.Contains = function (attrs) {
    var attrList = attrs.constructor === Array ? attrs : [attrs];
    var i;

    for (i = 0; i < attrList.length; i++) {
      if (this._hasAttrs(attrList[i])) {
        return true;
      }
    }
    return false;
  };

  /**
   * @private
   */
  Model._getSuccess = function (options) {
    return options != null && options.success ? options.success : null;
  };

  /**
   * @protected
   */
  Model.GetContext = function (options, model) {
    if (options !== undefined && options.context !== undefined) {
      return options.context;
    }
    return model;
  };

  /**
   * Determines if this model object has been assigned an id value yet. This indicates whether or not the model's
   * data has been saved to or fetched from the data service at any point.
   * @returns {boolean} true if the Model object has not had its id set yet, false if not.
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.isNew = function () {
    return this.GetId() === undefined;
  };

  /**
   * @private
   */
  Model.prototype._getIdAttr = function () {
    return this.idAttribute || 'id';
  };

  /**
   * @protected
   */
  Model.prototype.GetId = function () {
    return this.id;
  };

  /**
   * Return the set of attributes and values that have changed since the last set.  Note that a Model.fetch() uses
   * set to store the returned attribute data. If attribute/value pairs are passed in, check those to see if they're
   * different than the model.
   * Return false if there were no changes
   * @param {Object=} attributes One or more attribute/value pairs to check against the model for changes
   * @return {Object|boolean} the set of all attribute value pairs that have changed since last set, if no
   * attributes passed in; the set of all attribute value pairs that are different than those listed in the
   * attributes parameter, if present.  False if no changes
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.changedAttributes = function (attributes) {
    if (attributes) {
      var internalChanges = {};
      var self = this;
      Object.keys(attributes).forEach(function (prop) {
        if (Object.prototype.hasOwnProperty.call(attributes, prop)) {
          if (!oj.Object.__innerEquals(attributes[prop], self.attributes[prop])) {
            internalChanges[prop] = attributes[prop];
          }
        }
      });
      return oj.Object.isEmpty(internalChanges) ? false : internalChanges;
    }
    return oj.Object.isEmpty(this.changed) ? false : this.changed;
  };

  /**
   * Return true if the Model object has had any changes made to its values, or if any changes have been made to
   * the optional attribute passed in.
   * @param {string=} attribute attribute to check for changes
   * @returns {boolean} true if the Model object has had any changes since retrieval or last update at all (if no
   * attributes parameter); true if the Model object has had changes to the passed-in attribute
   * since retrieval or last update (if attribute parameter present).
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.hasChanged = function (attribute) {
    if (attribute !== undefined) {
      return (
        Model._hasProperties(this.changed) &&
        Object.prototype.hasOwnProperty.call(this.changed, attribute)
      );
    }
    return Model._hasProperties(this.changed);
  };

  /**
   * Delete the record represented by this model object from the data service.  If the server responds with virtual
   * mode response properties (such as totalResults), these will be picked up at the end of the delete by the
   * model's collection.  Note that by default, the delete isn't sent with an HTTP data type so the object
   * returning these properties needs to be a string version of the JSON object.<br>
   * Events:<p>
   * <ul>
   * <b>destroy</b>: fired when the model is destroyed, either before or after the server call, depending on the
   * setting of wait.  The model and model's collection are passed in<br>
   * <b>request</b>: fired right as the call is made to request the server delete the model.  Passes the model,
   * xhr ajax object, and options.<br>
   * <b>sync</b>: fired after the server succeeds in destroying the model.  Passes the model, the raw response data,
   * and options.
   * </ul>
   * @param {Object=} options Options for the destroy operation:<br>
   * <b>wait</b>: if true, wait until the server is done to fire the destroy event.  Otherewise, fire immediately
   * and regardless of success or failure<br>
   * <b>success</b>: callback function called if the server call succeeds, passing the model, response data, and
   * options<br>
   * <b>error</b>: callback function on failure of the server call, firing an error event and passing the model,
   * xhr, status, and error values.<br>
   * @return {boolean}
   * @memberof Model
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (model: Model, response: any, options: object)=> void,
   *                                                  error?: (model: Model, xhr: any, options: object)=> void,
   *                                                  wait?: boolean, [propName: string]: any}", for: "options"}
   * @export
   */
  Model.prototype.destroy = function (options) {
    var tempOpt = options || {};
    var isWait = tempOpt.wait;
    var callback;
    var userErr = tempOpt.error;
    var self = this;
    var xhr;
    var opts;

    opts = Model._copyOptions(tempOpt);
    callback = Model._getSuccess(opts);
    // Grab the collection off the model in case we need to update
    var collection = this.GetCollection();

    opts.success = function (data) {
      // Make sure we pass xhr
      if (opts.xhr) {
        tempOpt.xhr = opts.xhr;
      }

      // Give an opportunity to update any collection paging properties, like totalResults due to this destroy
      if (collection) {
        // Make sure to parse the data if necessary
        var props =
          oj.StringUtils.isString(data) && !oj.StringUtils.isEmpty(data) ? JSON.parse(data) : data;

        collection._setPagingReturnValues(props, null, data, true);
      }
      if (isWait) {
        self._fireDestroy(false);
      }
      Model._fireSyncEvent(self, data, opts, false);

      if (callback) {
        callback.call(Model.GetContext(opts, self), self, data, tempOpt);
      }
    };
    opts.error = function (xhrParam, status, err) {
      // Trigger an error event
      self.TriggerInternal(false, Events.EventType.ERROR, self, xhrParam, tempOpt);

      if (userErr) {
        userErr.apply(self, [self, err, options, xhrParam, status]);
      }
    };

    if (!this.isNew()) {
      xhr = Model._internalSync('delete', this, opts);
      if (!isWait) {
        this._fireDestroy(false);
      }
      return xhr;
    }
    if (!isWait) {
      this._fireDestroy(false);
    }
    if (callback) {
      callback.call(Model.GetContext(opts, self), self, null, tempOpt);
    }
    return false;
  };

  /**
   * Fire request event
   * @private
   */
  Model.prototype._fireRequest = function (model, xhr, options, silent) {
    this.TriggerInternal(silent, Events.EventType.REQUEST, model, xhr, options);
  };

  /**
   * Fire destroy event to all listeners
   * @private
   */
  Model.prototype._fireDestroy = function (silent) {
    this.TriggerInternal(silent, Events.EventType.DESTROY, this, this.collection, null);
  };

  /**
   * Fire sync event to all listeners
   * @private
   */
  Model._fireSyncEvent = function (model, resp, options, silent) {
    model.TriggerInternal(silent, Events.EventType.SYNC, model, resp, options);
  };

  /**
   * Return a copy of Model's current attribute/value pairs
   * @return {Object} a copy of the Model's current set of attribute/value pairs.
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.toJSON = function () {
    var retObj = {};
    var self = this;

    Object.keys(self.attributes || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(self.attributes, prop)) {
        if (Array.isArray(self.attributes[prop])) {
          retObj[prop] = self.attributes[prop].slice(0);
        } else {
          retObj[prop] = self.attributes[prop];
        }
      }
    });
    return retObj;
  };

  /**
   * Return the previous value of the given attribute, if any.
   *
   * @param {string} attr
   * @returns {Object} previous value of attr, if any.  If the attribute has not changed, returns undefined
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.previous = function (attr) {
    return this.previousAttrs[attr];
  };

  /**
   * Return a copy of the model's previously set attributes
   *
   * @returns {Object} a copy of the model's previous attributes
   * @memberof Model
   * @since 1.0.0
   * @export
   */
  Model.prototype.previousAttributes = function () {
    return this.previousAttrs;
  };

  /**
   * @export
   * Performs communications with the server.  Can be overridden/replaced by clients
   *
   * @param {string} method "create", "read", "update", or "delete"
   * @param {Model} model Model to be read/saved/deleted/created
   * @param {Object=} options to control sync:<br>
   * <b>success</b>: called if sync succeeds:<br>
   * <ul>
   * For create, called with the response (attribute/value pairs); status (Ajax by default, but user-defined);
   * xhr object (Ajax--if available)<br>
   * For read, called with the response (attribute/value pairs being fetched)<br>
   * For update, same as create<br>
   * For delete, called with the Model deleted, the data response (ignored), and the options passed to the
   * destroy call<br>
   * </ul>
   * <b>error</b>: called if sync fails.  Called with xhr, status, and error info, per jQuery Ajax (all if
   * available)<p>
   *
   * @return {Object} xhr object
   * @memberof Model
   * @instance
   * @since 1.0.0
   * @alias sync
   */
  Model.prototype.sync = function (method, model, options) {
    return oj.sync(method, model, options);
  };

  /**
   * Internal processing before sync-- we want this stuff to happen even if user replaces sync
   * @private
   */
  Model._internalSync = function (method, model, opt) {
    var options = opt || {};
    // If Model/Collection has OAuth object, then create Authorization header (see RestImpl.addOptions)
    if (model.oauth) {
      options.oauthHeader = model.oauth.getHeader();
    }

    // Make sure to transfer the data type if it's set on the calling object
    if (!options.dataType && model.dataType) {
      options.dataType = model.dataType;
    }
    if (!options.jsonpCallback && model.jsonpCallback) {
      options.jsonpCallback = model.jsonpCallback;
    }

    // Do parsing if necessary and tuck it on options
    if (method === 'create' || method === 'patch' || method === 'update') {
      options.parsedData = model.parseSave.call(
        model,
        method === 'patch' ? options.attrs : options.saveAttrs
      );
    }
    var recordId = null;
    if (model instanceof Model) {
      recordId = model.GetId();
    }
    var newOpt = {};
    Object.keys(options).forEach(function (prop) {
      newOpt[prop] = options[prop];
    });
    var urlOpt = RestImpl.SetCustomURLOptions(recordId, model, options);
    Object.keys(urlOpt || {}).forEach(function (prop) {
      newOpt[prop] = urlOpt[prop];
    });
    // Make sure we send back xhr in options-- can come from return value or passed back through options
    options.xhr = model.sync(method, model, newOpt);
    if (newOpt.xhr) {
      options.xhr = newOpt.xhr;
    }
    return options.xhr;
  };

  /**
   * @export
   * @class sync
   * @desc Master server access method for all models and collections.  Replace oj.sync with a new implementation
   * to customize all Model and Collection server interactions
   *
   * @param {string} method "create", "read", "update", "patch", or "delete"
   * @param {Model|Collection} model Model (or Collection to be read) to be read/saved/deleted/created
   * @param {Object=} options to control sync<br>
   * success: called if sync succeeds<br>
   * error: called if sync fails<br>
   * others are passed to jQuery<br>
   * Options that would normally be passed to a customURL callback are also included<br>
   *
   *
   * @return {Object} xhr object
   * @memberof oj
   * @global
   * @since 1.0.0
   */
  const sync = function (method, model, options) {
    var tempOpt = options || {};
    function _fireAndReturn(xhr) {
      model._fireRequest(model, xhr, tempOpt, tempOpt.silent);
      return xhr;
    }

    var restService;
    var success = tempOpt.success;
    var error = tempOpt.error;
    var url;

    if (method.valueOf() === 'create') {
      url = model._saveUrl();
      url = url || RestImpl.GetPropValue(model, 'url');
      restService = new RestImpl(url, model);
      return _fireAndReturn(restService.addRecord(tempOpt.parsedData, error, tempOpt, model));
    }

    if (method.valueOf() === 'read') {
      if (model instanceof Model) {
        url = tempOpt.url ? tempOpt.url : RestImpl.GetPropValue(model, 'url');
        restService = new RestImpl(url, model);
        return _fireAndReturn(
          restService.getRecord(
            success,
            error,
            model.GetId(),
            tempOpt,
            Model.GetContext(tempOpt, model)
          )
        );
      }
      // Collection fetch
      url = model.GetCollectionFetchUrl(tempOpt);
      restService = new RestImpl(url, model);
      return _fireAndReturn(restService.getRecords(success, error, tempOpt, model));
    }

    restService = new RestImpl(RestImpl.GetPropValue(model, 'url'), model);
    var recordId = null;
    if (model instanceof Model) {
      recordId = model.GetId();
    }
    if (method.valueOf() === 'update') {
      return _fireAndReturn(
        restService.updateRecord(success, recordId, tempOpt.parsedData, error, tempOpt, model, false)
      );
    }
    if (method.valueOf() === 'patch') {
      return _fireAndReturn(
        restService.updateRecord(success, recordId, tempOpt.parsedData, error, tempOpt, model, true)
      );
    }
    if (method.valueOf() === 'delete') {
      return _fireAndReturn(restService.deleteRecord(recordId, error, tempOpt, model));
    }
    return null;
  };
  oj._registerLegacyNamespaceProp('sync', sync);

  /**
   * @private
   */
  Model._urlError = function (ajaxOptions) {
    if (!ajaxOptions.url) {
      throw new Error('The url property or function must be specified');
    }
  };

  /**
   * @export
   * @class ajax
   * @desc Master Ajax entry point for all Model and Collection server interactions, when they are using the
   * default sync implementations.  oj.ajax passes through to jQuery ajax by default.
   * See {@link http://api.jquery.com/jquery.ajax/} for expected parameters and return value.
   * @param {Object=} settings optional ajax settings
   *
   * @return {Object} xhr object
   * @memberof oj
   * @global
   * @since 1.0.0
   */
  // eslint-disable-next-line no-unused-vars
  const ajax = function (settings) {
    if (arguments && arguments.length > 0) {
      Model._urlError(arguments[0]);
    }
    return $.ajax.apply(oj, arguments);
  };

  oj._registerLegacyNamespaceProp('ajax', ajax);

  /**
   * @export
   * @class Collection
   * @classdesc Collection of Model objects
   *
   * @param {Array.<Model>=} models Set of model objects to put into collection at construction
   *                 time.  If models contain actual
   *                 Model objects, then any custom parse callback set on the collection must
   *                 be able to handle Model objects as a possible argument
   * @param {Object=} options Passed through to the user's initialize routine, if any, upon
   *                  construction
   * @constructor
   * @final
   * @since 1.0
   * @mixes Events
   * @ojsignature {target: "Type", value: "class Collection"}
   */
  const Collection = function (models, options) {
    if (Collection._justExtending) {
      return;
    }

    // Initialize
    Collection._init(this, models, options, null);
  };

  oj._registerLegacyNamespaceProp('Collection', Collection);

  /**
   * Subclass from oj.Object
   * @private
   */
  oj.Object.createSubclass(Collection, oj.Object, 'oj.Collection');

  /**
   * @desc Property specifying the [model]{@link Model} class object used by the collection
   * @memberof Collection
   * @type Model
   * @export
   */
  Collection.prototype.model = null;

  /**
   * @desc Function specifying how to construct the id for models in this collection.  Override to
   * change the construction of the id.
   * @memberof Collection
   * @param {Object} attrs attributes of a model
   * @returns {null|string}
   * @since 1.0.0
   * @export
   */
  Collection.prototype.modelId = function (attrs) {
    var model = this.model;
    if (model && attrs) {
      return attrs[model.idAttribute || model.prototype.idAttribute || 'id'];
    }
    return null;
  };

  /**
   * @export
   * @desc Total number of models in the collection.  When the collection is virtual, not all of the
   * models may be locally available.
   * @memberof Collection
   *
   * @type number
   * @since 1.0.0
   */
  Collection.prototype.length = null;

  /**
   * @export
   * @desc Direct access to the collection's list of models objects<br/>
   * Note that this property should not be used directly when a collection is virtual, as
   * automatic fetches will not be triggered for undefined elements in the model.  Use at()
   * instead.
   * @memberof Collection
   *
   * @type {Array.<Model>}
   * @since 1.0.0
   */
  Collection.prototype.models = null;

  /**
   * Tracking indices used
   * @private
   */
  Collection.prototype._modelIndices = [];

  /**
   * @export
   * @desc The data service's server URL.
   * @memberof Collection
   *
   * @type {null|string|function():string}
   * @since 1.0.0
   */
  Collection.prototype.url = null;

  /**
   * @export
   * @desc Changes that have occured due to adds/removes since the last fetch.  This is a list of
   * indicies that have changed (location at which a model was added, deleted, or set).  They do
   * not shift with subsequent operations
   * @memberof Collection
   * @type {Array.<number>}
   * @since 1.0.0
   */
  Collection.prototype.changes = [];

  /**
   * A callback to allow users to customize the data service URLs.  The callback should accept
   * these parameters:<p>
   * <b>operation</b>: one of "create", "read", "update", "patch", or "delete", indicating the
   * type of operation for which to return the URL<p>
   * <b>collection</b>: the Collection object requesting the URL<p>
   * <b>options</b>: any of the following properties:<br>
   * <ul>
   * <b>recordID</b>: id of the record involved, if relevant<br>
   * <b>fetchSize</b>: how many records to return.  If not set, return all.<br>
   * <b>startIndex</b>: Starting record number of the set to return.<br>
   * <b>startID</b>: Retrieve records starting with the record with the given unique ID.<br>
   * <b>since</b>: Retrieve records with timestamps after the given timestamp.<br>
   * <b>until</b>: Retrieve records with timestamps up to the given timestamp. Default is "until"<br>
   * <b>sort</b>:  field(s) by which to sort, if set<br>
   * <b>sortDir</b>: sort ascending or descending (asc/dsc)<br>
   * <b>query</b>: a set of attributes indicating filtering that should be done on the server.  See
   * [where]{@link Collection#where} for complete documentation of query values<br>
   * <b>all</b>: true (along with 'query', above) indicates that this is a findWhere or where type
   * call that is expecting all models meeting the query condition to be returned<br>
   * </ul>
   * <p>
   * customURL callbacks should return either: null, in which case the default will be used; a
   * url string, which will be used with the standard HTTP method for the type of operation, or
   * an Object with any other attributes that should be passed to the ajax call.<br>
   * This object must at minimum include the URL, and other attributes as follows:<br>
   * <ul>
   * <b>url</b>: the custom URL string<br>
   * <b>type</b>: (optional) a string indicating the type of HTTP method to use (GET, POST,
   *              DELETE, etc.)<br>
   * <b>(other)</b>: (optional) any other attributes to pass in the ajax call<br>
   * </ul>
   * <p>
   * @type {function(string,Collection,Object):(string|Object|null)|null}
   * @memberof Collection
   * @ojsignature  {target: "Type", value: "function(string,Collection,Collection.CustomURLCallbackOptions):(string|Object|null)|null", for: "returns"}
   *
   * @export
   * @since 1.0.0
   */
  Collection.prototype.customURL = null;

  /**
   * @typedef {Object} Collection.CustomURLCallbackOptions
   * @property {string=} recordID id of the record involved, if relevant
   * @property {number=} fetchSize how many records to return.  If not set, return all
   * @property {number=} startIndex Starting record number of the set to return
   * @property {string=} startID Retrieve records starting with the record with the given unique ID
   * @property {string=} since Retrieve records with timestamps after the given timestamp
   * @property {string=} until Retrieve records with timestamps up to the given timestamp. Default is "until"
   * @property {string=} sort field(s) by which to sort, if set
   * @property {string=} sortDir sort ascending or descending (asc/dsc)
   * @property {Object=} query a set of attributes indicating filtering that should be done on the server.  See
   * [where]{@link Collection#where} for complete documentation of query values
   * @property {boolean=} all true (along with 'query', above) indicates that this is a findWhere or where type
   * call that is expecting all models meeting the query condition to be returned
   *
   * @example <caption>Sample information that is commonly passed to customURL to give information about the collection's request.  The customURL implementer should use this information to return a custom URL for their REST service./caption>
   * <pre class="prettyprint"><code>
   * {
   *   fetchSize: 20,       // Number of records the collection is requesting
   *   startIndex: 40,      // Absolute index of the starting record requested
   *   sort: 'name',        // Field by which the collection would like the results sorted, if any
   *   sortDir: 'asc'       // Desired sort direction, if any
   * }
   * </code></pre>
   */

  /**
   * A callback function allowing users to extract their own paging/virtualization
   * return values from the server's response.<p>
   * It should accept these parameters:<p>
   * <b>response</b>: the Object data response coming back from the fetch call<p>
   * <p>
   * The callback should return either null, in which case the collection will look for the
   * default properties, or an object containing one or more of the following attribute/value
   * pairs (note that the Collection will look back to the response for default paging return
   * properties if not found in the returned object):<br>
   * <ul>
   * <b>totalResults</b>: the total number of records available on the server side, not just
   * in the current result.  By default the collection looks in the response for "totalResults"<br>
   * <b>limit</b>: the actual fetchSize from the server.  This may not be the client's fetchSize
   * or the number of records in the current result.  By default the collection looks in the
   * response for "limit".  This becomes the collection's "lastFetchSize" property<br>
   * <b>count</b>: the actual number of records returned by the server in the last result.  This
   * becomes the collection's "lastFetchCount".  By default the collection looks in the response
   * for "count".<br>
   * <b>offset</b>: the actual starting record number of the current result.  By default the
   * collection looks in the response for "offset"<br>
   * <b>hasMore</b>: boolean indicating whether or not there are more records available beyond
   * the current result.  By default the collection looks in the response for "hasMore"<br>
   * </ul>
   * <p>
   *
   * @type {(function(Object):(Object|null)|null)}
   * @memberof Collection
   * @ojsignature {target: "Type",
   * value: "((response: object)=> Collection.CustomPagingOptionsReturn|null)|null"}
   * @export
   * @since 1.0.0
   */
  Collection.prototype.customPagingOptions = null;

  /**
   * @typedef {Object} Collection.CustomPagingOptionsReturn
   * @property {number=} totalResults
   * @property {number=} limit
   * @property {number=} count
   * @property {number=} offset
   * @property {boolean=} hasMore
   *
   * @example <caption>Map paging return properties from a sample REST service to the properties expected by the Collection.  Here is an example customPagingOptions callback function implementation:</caption>
   * <pre class="prettyprint"><code>
   * collection.customPagingOptions = function(response) {
   *   return {
   *     totalResults: response.allRecordCount,     // REST service returns total possible record count as 'allRecordCount'
   *     limit: repsonse.fetchBlockSize,    // REST service returns its fetch size block as 'fetchBlockSize'
   *     count: response.recordsFetched,    // REST service returns the number of records actually fetched as 'recordsFetched'
   *     offset: response.startRecord,    // REST service returns the starting index of the block fetched here as 'startRecord'
   *     hasMore: (response.startRecord + response.recordsFetched < response.allRecordCount-1)  // Calculate whether this fetch got the last records available to return a boolean to indicate whether more records are available
   *   };
   * }
   * </code></pre>
   */

  /**
   * @export
   * @desc The server's fetch size.  This may not match [fetchSize]{@link Collection#fetchSize}.
   * @memberof Collection
   *
   * @type number
   * @since 1.0.0
   */
  Collection.prototype.lastFetchSize = null;

  /**
   * @export
   * @desc Indicates whether or not there are more records available on the server, at indices
   * beyond the last fetch.
   * @memberof Collection
   *
   * @type boolean
   * @since 1.0.0
   */
  Collection.prototype.hasMore = false;

  /**
   * @export
   * @desc The total number of records available for this collection regardless of whether they
   * have been fetched or not.  For non-virtual collections this will equal the length.
   * @memberof Collection
   *
   * @type number
   */
  Collection.prototype.totalResults = null;

  /**
   *
   * @export
   * @desc The number of records actually fetched the last time the collection fetched from the
   * server.  This may or may not match [fetchSize]{@link Collection#fetchSize} or
   * [lastFetchSize]{@link Collection#lastFetchSize}
   * @memberof Collection
   *
   * @type number
   */
  Collection.prototype.lastFetchCount = null;

  /**
   * @export
   * @desc For virtual collections, the number of records to be kept in memory at any one
   * time.  The default of -1 indicates that no records are thrown out
   * @memberof Collection
   *
   * @type number
   */
  Collection.prototype.modelLimit = -1;

  /**
   * @export
   * @desc The actual starting index number at which models from the last server fetch
   * were inserted into the collection.
   * @memberof Collection
   *
   * @type number
   */
  Collection.prototype.offset = null;

  /**
   * @export
   * @desc The number of records to be fetched from the server in any one round trip.
   * The server's fetch size comes back as the "limit" property.  The default value
   * of -1 indicates that virtualization is not being used or is not available,
   * and all records will be fetched.<br>
   * @memberof Collection
   *
   * @type number
   */
  Collection.prototype.fetchSize = -1;

  /**
   * @export
   * @desc Sort direction for string-based sort comparators (model attribute names).  A value
   * of 1 indicates ascending sorts, -1 indicates descending.  The default is 1 (ascending).<br>
   * Users should call sort() after changing sort direction to ensure that models in the
   * collection are sorted correctly, or, for virtual collections, that there are no left
   * over models in an incorrect order.
   * @memberof Collection
   *
   * @type number
   */
  Collection.prototype.sortDirection = 1;

  /**
   * @export
   * @desc If set to a string, sort the collection using the given attribute of a model.<p>
   * If set to a function(Model), the function should return a string giving the model
   * attribute by which the sort should take place.<p>
   * If set to a function(Model1, Model2), then this function is called comparing Model1
   * and Model2 (see the JavaScript array.sort() for details)<p>
   * In the virtual case, comparator must be a string-based field comparator, which will
   * be passed to the server.<p>
   * Users should call sort() after making any changes to the comparator to ensure that
   * the models are correctly sorted, or that there are no leftover models sorted incorrectly
   * in the virtual case.
   * @memberof Collection
   *
   * @type {null|string|function(Model,Model=):number}
   * @since 1.0.0
   */
  Collection.prototype.comparator = null;

  /**
   * @export
   *
   * @memberof Collection
   * @type {boolean}
   * @desc If true, do not insert the JET locale-based Accept-Language header.  If false,
   * let the Ajax system set the header.
   * @since 5.0.0
   */
  Collection.prototype.omitLanguageHeader = false;

  /**
   * @private
   */
  Collection.prototype.Init = function () {
    Collection.superclass.Init.call(this);
  };

  /**
   * Create a new, specific type of Collection object to represent a collection of records
   * from a JSON data set.
   * @param {Object=} properties Properties for the new Collection class.<p>
   * <b>parse</b>: a user callback function to allow parsing of the JSON collection after it's
   * returned from the data service.  If a collection is initialized with actual Models or
   * collection.set is used with actual Models, the parse callback must expect that the argument
   * passed to it may contain raw JSON data *or* Model objects<br>
   * <b>model</b>: the specific type of [model]{@link Model} object to use for each member of
   * the collection<br>
   * <b>url</b>: the URL string to use to get records from the data service<br>
   * <b>initialize</b>: a user callback function to be called when this collection is created.
   * Called in the context of the collection and passed: models, options.<br>
   * <b>comparator</b>: a user callback used on sort calls. May also be set to false to prevent
   * sorting.  See [comparator]{@link Collection#comparator}<br>
   * <b>fetchSize</b>: the number of records to be fetched on each round trip to the server.
   * Overrides [fetchSize]{Collection#fetchSize}. If not set, the collection will not consider
   * itself virtual<br>
   * <b>modelLimit</b>: the number of records to be held in memory at any one time, if
   * virtualization is in force.  The default is all records.  This uses an LRU algorithm to
   * determine which to roll off as more records are added.<br>
   * @param {Object=} classProperties optional properties that get attached to the constructor
   * of the extended Collection
   * @return {Collection} new Collection object
   * @ojsignature [{target: "Type",
   *                value: "any",
   *                for: "returns"},
   * {target: "Type", value:"{parse?: (data: any)=> any, model?: Model, url?: string,
   * initialize?: (models: Array<Model>, options: object)=> void,
   * comparator?: null|string|((model1: Model, model2?: Model)=> number),
   * fetchSize?: number, modelLimit?: number, [propName: string]: any}", for: "properties"}]
   * @memberof Collection
   * @this {Collection}
   * @since 1.0.0
   * @export
   */
  Collection.extend = function (properties, classProperties) {
    var obj = null;
    Collection._justExtending = true;
    obj = new Collection();
    Collection._justExtending = false;

    // Add regular properties from this "parent"
    // Events.Mixin(obj, this.prototype);
    $.extend(obj, this.prototype);

    var coll;
    if (
      properties &&
      properties.constructor &&
      Object.prototype.hasOwnProperty.call(properties, 'constructor')
    ) {
      coll = properties.constructor;
    } else {
      coll = function (models, options) {
        Collection._init(this, models, options, properties);
      };
    }

    if (classProperties) {
      Object.keys(classProperties).forEach(function (prop) {
        if (Object.prototype.hasOwnProperty.call(classProperties, prop)) {
          coll[prop] = classProperties[prop];
        }
      });
    }

    if (properties) {
      Object.keys(properties).forEach(function (prop) {
        if (Object.prototype.hasOwnProperty.call(properties, prop)) {
          obj[prop] = properties[prop];
        }
      });
    }

    $.extend(coll, this);
    coll.prototype = obj;

    // Allow extending resulting obj
    coll.extend = Collection.extend;

    coll.prototype.constructor = coll;

    return coll;
  };

  /**
   * @private
   */
  Collection._init = function (collection, models, options, properties) {
    var i;
    var optionlist;
    var modelList;
    var prop;

    collection.Init();

    // Augment with Event
    Events.Mixin(collection);

    // First, copy all properties passed in
    if (properties) {
      // eslint-disable-next-line no-restricted-syntax
      for (prop in properties) {
        if (Object.prototype.hasOwnProperty.call(properties, prop)) {
          collection[prop] = properties[prop]; // eslint-disable-line no-param-reassign
        }
      }
    }

    // Check options
    var opt = options || {};
    optionlist = [
      'comparator',
      'customPagingOptions',
      'customURL',
      Collection._FETCH_SIZE_PROP,
      'model',
      'modelLimit',
      'sortDirection',
      'url'
    ];
    for (i = 0; i < optionlist.length; i++) {
      if (
        Object.prototype.hasOwnProperty.call(opt, optionlist[i]) &&
        opt[optionlist[i]] !== undefined
      ) {
        collection[optionlist[i]] = opt[optionlist[i]]; // eslint-disable-line no-param-reassign
      }
    }
    if (collection._getFetchSize(null) === undefined) {
      collection.setFetchSize(-1);
    }
    if (collection.modelLimit === undefined) {
      collection.setModelLimit(-1);
    }
    collection.hasMore = false; // eslint-disable-line no-param-reassign
    collection.lruCount = 0; // eslint-disable-line no-param-reassign

    collection._setModels([], true);
    var localModels = models;
    if (opt.parse) {
      localModels = collection.parse(models);
    }
    if (localModels != null) {
      opt.noparse = true;
      modelList = localModels instanceof Array ? localModels : [localModels];
      collection._addInternal(modelList, opt, true, false);
    }
    collection._setLength();
    if (!localModels) {
      // Make sure totalResults is uninitialized at first, though, for non virtual case--0 could be the length of the first fetch
      collection.totalResults = undefined; // eslint-disable-line no-param-reassign
    }

    if (properties && properties.initialize) {
      properties.initialize.call(collection, localModels, opt);
    }
  };

  // Placeholder for event mixins
  Collection.prototype.on = function (event, callback) {}; // eslint-disable-line no-unused-vars
  Collection.prototype.OnInternal = function (event, callback, context, listenTo, ignoreSilent) {}; // eslint-disable-line no-unused-vars
  Collection.prototype.TriggerInternal = function (silent, event, arg1, arg2, options) {}; // eslint-disable-line no-unused-vars

  /**
   * Fire request event
   * @private
   */
  Collection.prototype._fireRequest = function (collection, xhr, options, silent) {
    this.TriggerInternal(silent, Events.EventType.REQUEST, collection, xhr, options);
  };

  /**
   * @private
   */
  Collection.prototype._resetChanges = function () {
    this.changes = [];
  };

  /**
   * @private
   */
  Collection.prototype._setChangeAt = function (start, count) {
    for (var at = start; at < start + count; at++) {
      if (this.changes.indexOf(at) === -1) {
        this.changes.push(at);
      }
    }
  };

  /**
   * @private
   */
  Collection.prototype._setModels = function (models, clearing) {
    this.models = models;
    if (clearing) {
      this._modelIndices = [];
      this._resetChanges();
    } else {
      for (var i = 0; i < models.length; i++) {
        if (models[i]) {
          this._modelIndices.push(i);
        }
      }
    }
  };

  /**
   * @private
   */
  Collection.prototype._getModels = function () {
    return this.models;
  };

  /**
   * @private
   */
  Collection.prototype._getModelsLength = function () {
    return this._getModels().length;
  };

  /**
   * Designed to check if index exceeds the length of the models.  If we're in a virtual and "no totalResults" case,
   * we're never over the upper limit
   * @private
   */
  Collection.prototype._overUpperLimit = function (index) {
    if (index < this._getModelsLength()) {
      return false;
    }
    if (this.IsVirtual()) {
      if (!this._hasTotalResults() || this._getModelsLength() === 0) {
        return false;
      }
    }
    return true;
  };

  /**
   * @private
   */
  Collection.prototype._hasTotalResults = function () {
    return Collection._defined(this.totalResults);
  };

  /**
   * @private
   */
  Collection._defined = function (value) {
    return value != null;
  };

  /**
   * @private
   */
  Collection.prototype._pushModel = function (model) {
    this._getModels().push(model);
    this._modelIndices.push(this._getModelsLength() - 1);
    this._setChangeAt(this._getModelsLength() - 1, 1);
  };

  /**
   * @private
   */
  Collection.prototype._pushModels = function (model) {
    // Model is being added to the end, it should be made the head
    this._makeModelHead(model);
    this._pushModel(model);
    this.lruCount += 1;
    model.SetIndex(this._getModelsLength() - 1);
  };

  /**
   * @private
   */
  Collection.prototype._reduceLRU = function (removed) {
    if (removed) {
      for (var i = 0; i < removed.length; i++) {
        if (removed[i]) {
          this.lruCount -= 1;
        }
      }
    }
  };

  /**
   * @param {number} start
   * @param {number} count
   * @param {Object=} model
   * @private
   */
  Collection.prototype._spliceModels = function (start, count, model) {
    // Clean up prev/next links for models being removed
    for (var i = start; i < start + count; i++) {
      this._removePrevNext(this._getModel(i));
    }
    if (model === undefined) {
      this._reduceLRU(this._getModels().splice(start, count));
      this._spliceModelIndices(start, start + count - 1);
    } else {
      this._reduceLRU(this._getModels().splice(start, count, model));
      this._spliceModelIndices(start, start + count - 1);
      this._insertModelIndex(start);
      this._makeModelHead(model);
    }
    this._setChangeAt(start, count);
    if (this.lruCount < 0) {
      this.lruCount = 0;
    }
    this._realignModelIndices(start);
  };

  /**
   * @private
   */
  Collection.prototype._getModel = function (index) {
    return this._getModels()[index];
  };

  /**
   * Realign all the indices of the models (after sort for example)
   * @private
   */
  Collection.prototype._realignModelIndices = function (start) {
    var index;
    for (var i = 0; i < this._modelIndices.length; i++) {
      index = this._modelIndices[i];
      if (index >= start && this._getModel(index)) {
        this._getModel(index).SetIndex(index);
      }
    }
  };

  /**
   * Update next/prev pointers as though the given model were being removed
   * @private
   */
  Collection.prototype._removePrevNext = function (model) {
    if (!model) {
      return;
    }

    var oldPrev = model.GetPrevious();
    var oldNext = model.GetNext();
    // Link the two surrounding previous/next elements to each other, because this one is being replaced and moved
    // to the head
    if (oldPrev) {
      oldPrev.SetNext(oldNext);
    } else {
      // This element used to be the head
      this.head = oldNext;
    }
    if (oldNext) {
      oldNext.SetPrevious(oldPrev);
    } else {
      // This element used to be the tail
      this.tail = oldPrev;
    }
  };

  /**
   * @private
   */
  Collection.prototype._makeModelHead = function (model) {
    // Make this new model the most recently used: the head
    model.SetNext(this.head);
    if (this.head) {
      this.head.SetPrevious(model);
    } else {
      // No head: list is empty-->make tail the same element
      this.tail = model;
    }
    model.SetPrevious(null);
    this.head = model;
  };

  /**
   * Mark the model index tracker as having a used slot
   * @private
   */
  Collection.prototype._setModelIndex = function (index) {
    if (this._modelIndices.indexOf(index) === -1) {
      this._modelIndices.push(index);
    }
  };

  /**
   * Insert the given model at the given index
   * @private
   */
  Collection.prototype._insertModelIndex = function (start) {
    // Up all the indices of models with index greater than start
    for (var i = 0; i < this._modelIndices.length; i++) {
      if (this._modelIndices[i] >= start) {
        this._modelIndices[i] += 1;
      }
    }
    // Now add the new one
    this._modelIndices.push(start);
  };

  /**
   * Splice out the given model index
   * @private
   */
  Collection.prototype._spliceModelIndices = function (start, end) {
    var localEnd = end === undefined ? start : end;
    this._clearModelIndices(start, localEnd);

    var count = localEnd - start + 1;
    // Reduce the indexes of any models above the endpoint by the number of models removed
    for (var i = 0; i < this._modelIndices.length; i++) {
      if (this._modelIndices[i] > localEnd) {
        this._modelIndices[i] -= count;
      }
    }
  };

  /**
   * Clear the given model index
   * @private
   */
  Collection.prototype._clearModelIndices = function (start, end) {
    var localEnd = end === undefined ? start : end;
    // Knock out any of the deleted model's indexes from the list
    for (var i = start; i <= localEnd; i++) {
      var idx = this._modelIndices.indexOf(start);
      if (idx > -1) {
        this._modelIndices.splice(idx, 1);
      }
    }
  };

  /**
   * @private
   */
  Collection.prototype._setModel = function (index, model) {
    var oldModel = this._getModel(index);
    this._removePrevNext(oldModel);
    if (!oldModel) {
      // Newly "inserted" model
      this.lruCount += 1;
    }
    this._setChangeAt(index, 1);
    this._getModels()[index] = model;
    if (model) {
      this._setModelIndex(index);
      model.SetIndex(index);
      this._makeModelHead(model);
    }
  };

  /**
   * Clean off n models from tail (oldest) of prev/next list
   * @private
   */
  Collection.prototype._clearOutModels = function (n) {
    var current = this.tail;
    var index;
    var model;
    var i = 0;

    this.tail = null;
    while (current && i < n) {
      // Erase this model from collection, iff it hasn't changed
      index = current.GetIndex();
      model = this._getModel(index);
      if (!(model && model.hasChanged())) {
        this.lruCount -= 1;
        if (index > -1) {
          this._setModel(index, undefined);
          this._clearModelIndices(index, index);
        }

        // Clear its pointers
        current.SetNext(null);
        current = current.SetPrevious(null);
        i += 1;
      } else {
        // Lock down the tail to this one we're not deleting
        if (!this.tail) {
          this.tail = current;
        }
        current = current.GetPrevious();
      }
    }
    // Make sure we set tail if not already set
    if (!this.tail) {
      this.tail = current;
    }
    if (this.lruCount < 0) {
      this.lruCount = 0;
    }
    if (this.lruCount === 0) {
      this.head = null;
      this.tail = null;
    }
  };

  /**
   * Reset the LRU list
   * @private
   */
  Collection.prototype._resetLRU = function () {
    this.lruCount = 0;
    this.head = null;
    this.tail = null;
  };

  /**
   * Make sure we have room in the LRU
   * @private
   */
  Collection.prototype._manageLRU = function (incoming) {
    if (this.IsVirtual()) {
      var limit = this._getModelLimit();
      if (limit > -1) {
        if (this.lruCount + incoming > limit) {
          // Must flush the amount over the limit
          this._clearOutModels(this.lruCount + incoming - limit);
        }
      }
    }
  };

  /**
   * @export
   * @desc Return a copy of the Collection
   * @memberof Collection
   *
   * @return {Collection} copy of the Collection
   */
  Collection.prototype.clone = function () {
    return this._cloneInternal(true);
  };

  /**
   * @private
   */
  Collection.prototype._cloneInternal = function (withProperties) {
    var c = new this.constructor();
    var i;

    // Only copy locally if virtual
    var model;
    if (this.IsVirtual()) {
      c = this._copyFetchProperties(c);
      c._resetModelsToFullLength(this.totalResults);
    }

    c = this._copyProperties(c);
    if (withProperties) {
      // Try to copy models only if told to--we may only need the shell of the collection with properties
      // Make a copy of the model indices (it will be modified by this process)
      var indices = [];
      for (i = 0; i < this._modelIndices.length; i++) {
        indices.push(this._modelIndices[i]);
      }
      // Sort them in reverse order so we eliminate the higher indexes first so as not to disrupt the position of
      // the earlier ones
      indices.sort(function (a, b) {
        return a - b;
      });

      var index;
      for (i = 0; i < indices.length; i++) {
        index = indices[i];
        model = this._atInternal(index, null, true, false);
        if (model) {
          c._addInternal(model.clone(), { at: index }, true, false);
        }
      }
    }
    return c;
  };

  /**
   * Copy critical properties in clone
   * @private
   */
  Collection.prototype._copyProperties = function (collection) {
    var props = ['comparator', 'model', 'modelId'];
    var prop;
    var i;

    for (i = 0; i < props.length; i++) {
      prop = props[i];
      collection[prop] = this[prop]; // eslint-disable-line no-param-reassign
    }
    return collection;
  };

  /**
   * Copy critical fetch properties in clone
   * @private
   */
  Collection.prototype._copyFetchProperties = function (collection) {
    var props = ['totalResults', 'hasMore', Collection._FETCH_SIZE_PROP];
    var prop;
    var i;

    for (i = 0; i < props.length; i++) {
      prop = props[i];
      collection[prop] = this[prop]; // eslint-disable-line no-param-reassign
    }
    return collection;
  };

  /**
   * @private
   */
  Collection.prototype._getLength = function () {
    return this.length;
  };

  /**
   * @private
   */
  Collection.prototype._setLength = function () {
    var modelsLen = this._getModelsLength();
    this.length = modelsLen;
    if (!this.IsVirtual()) {
      this.totalResults = modelsLen;
    }
  };

  /**
   * Create a model instance using the model property if set
   * @param {Object} collection
   * @param {Object=} attrs
   * @param {Object=} options
   * @returns {null|Object}
   * @private
   */
  Collection._createModel = function (collection, attrs, options) {
    if (collection.model) {
      return $.isFunction(collection.model)
        ? new collection.model(attrs, options) // eslint-disable-line new-cap
        : new collection.model.constructor(attrs, options); // eslint-disable-line new-cap
    }
    return null;
  };

  /**
   * @private
   */
  Collection.prototype._newModel = function (m, parse, options, ignoreDefaults) {
    var newModel = null;
    var validationValue;
    var opt = options || {};

    opt.ignoreDefaults = ignoreDefaults;

    if (m instanceof Model) {
      newModel = m;
    } else if (this.model) {
      // model is defined
      newModel = Collection._createModel(this, m, opt);
    } else {
      // Set this collection on the model
      opt.collection = this;
      newModel = new Model(m, opt);
    }
    // Validate
    if (opt.validate && newModel.validate) {
      validationValue = newModel.validate(newModel.attributes);
      if (validationValue) {
        opt.validationError = validationValue;
        this.TriggerInternal(false, Events.EventType.INVALID, newModel, validationValue, opt);
        return null;
      }
    }
    return newModel;
  };

  /**
   * Add a model or models to the end of the collection.<br>
   * Events:<p>
   * <ul>
   * <b>add</b>: fired for each model added, passing the collection, model added, and options<br>
   * <b>alladded</b>: fired after all models have been added, passing the collection, array of models added, and
   * options<br>
   * </ul>
   * <p>
   * Note that for virtual collections, if a new model is added after being saved up to the server, no add event
   * will be fired as the
   * collection will already "see" the model as existing.  Note that a warning will be logged if this add is not
   * a force, not merging, and duplicate IDs are found.
   * @param {Model|Object|Array.<Object>|Array.<Model>} m Model object (or array of models) to add. These can be already-created instance of
   * the Model object, or sets of attribute/values, which will be wrapped by add() using the collection's model.
   * @param {Object=} options <b>silent</b>: if set, do not fire events<br>
   *                          <b>at</b>: splice the new model into the collection at the value given (at:index)<br>
   *                          <b>merge</b>: if set, and if the given model already exists in the collection (matched
   *                          by [id]{@link Model#id}), then merge the attribute/value sets, firing change
   *                          events<br>
   *                          <b>sort</b>: if set, do not re-sort the collection even if the comparator is set.<br>
   *                          <b>force</b>: if set to true, do an add to the collection no matter whether the item is
   *                          found or not<br>
   *                          <b>deferred</b>: if true, return a promise as though this collection were virtual
   *                          whether it is or not<br>
   *
   * @returns {Promise.<Array>|Array.<Model>} The model or models added to the collection (or found/merged if appropriate).  If
   * deferred or virtual, return the model or models added in a promise when the set has completed
   * @memberof Collection
   * @ojsignature [{target: "Type", value:"{silent?: boolean, at?: number, merge?: boolean, sort?: boolean, force?: boolean, deferred?: boolean,
   *               [propName: string]: any}", for: "options"},
   *               {target: "Type", value: "Promise<Array<Model>>|Array<Model>", for: "returns"}]
   * @since 1.0.0
   * @export
   */
  Collection.prototype.add = function (m, options) {
    this._manageLRU(1);
    var opt = options || {};
    return this._handlePromise(this._addInternal(m, options, false, opt.deferred));
  };

  /**
   * fillIn: true indicates that we're just trying to use add() after a fetch to
   * insert into a preallocated list of models, not truly do an add/merge from the API
   * @private
   */
  Collection.prototype._addInternal = function (m, options, fillIn, deferred) {
    // Get options
    var opt = options || {};
    var modelArray = [];
    var at = opt.at;
    var silent = opt.silent;
    var force = opt.force;
    var i;
    var index;
    var cid;
    var merge = opt.merge || false;
    var sort = opt.sort;
    var needSort = true;
    var added = false;
    var addedModels = [];
    var modelReturnList = [];

    if (at !== undefined && at < 0) {
      // Normalize it using the length-- another BackboneJS test case
      at += this._getLength() + 1;
    }

    if (m instanceof Array) {
      modelArray = m;
    } else {
      modelArray.push(m);
    }

    function addToCollection(collection, newModel) {
      if (at === undefined) {
        collection._pushModels(newModel);
        index = collection._getModelsLength() - 1;
        collection._getModel(index).SetCid();
      } else {
        index = at;
        if (collection.IsVirtual() && fillIn) {
          // Array has been preallocated in this case
          collection._setModel(index, newModel);
        } else {
          collection._spliceModels(index, 0, newModel);
        }
        collection._getModel(index).SetCid();
        // Increment at so that later models will be added right after their predecessors, if an array is
        // passed in
        at += 1;
      }
      if (newModel.GetCollection() === undefined) {
        newModel.SetCollection(collection);
      }
      collection._setLength();
      collection._listenToModel(newModel);
      added = true;
    }

    function resortAndFireEvents(
      collection,
      existingModel,
      modelFoundInCollection,
      newModel,
      resortDeferred
    ) {
      // Now resort if required (don't resort if either told not to, or if 'at' option is set)
      // and if there's more than one model
      var resortOpt = opt || {};
      if (fillIn) {
        resortOpt.fillIn = true;
      }
      var comparator = resortOpt.comparator || collection._hasComparator();
      // If we're filling in to a blank, also check that there's no comparator
      var fillInSort = !fillIn || (fillIn && comparator);
      if (
        fillInSort &&
        needSort &&
        existingModel === undefined &&
        !sort &&
        at === undefined &&
        collection._getLength() > 1
      ) {
        if (index > -1) {
          cid = collection._getModel(index).cid;
        }
        var sortOpt = {};
        oj.CollectionUtils.copyInto(sortOpt, resortOpt);
        sortOpt.add = true;
        collection.sort(sortOpt);
        // Reset index--can't get it back if virtual--set to -1
        if (index > -1) {
          if (collection.IsVirtual()) {
            index = -1;
          } else {
            index = collection.indexOf(collection.getByCid(cid), resortDeferred);
          }
        }
      }

      if (added) {
        // Pass index property in resortOpt, if at is specified
        if (resortOpt.at) {
          resortOpt.index = index;
        }
        if (newModel) {
          newModel.TriggerInternal(silent, Events.EventType.ADD, newModel, collection, resortOpt);
          addedModels.push(newModel);
        } else {
          modelFoundInCollection.TriggerInternal(
            silent,
            Events.EventType.ADD,
            modelFoundInCollection,
            collection,
            resortOpt
          );
          addedModels.push(modelFoundInCollection);
        }
      }
    }

    function mergeAttrs(
      collection,
      modelToTryAndMerge,
      modelFoundInCollection,
      newModel,
      mergeDeferred
    ) {
      var existingModel;
      var modelAdded = null;

      if (!force && merge && modelFoundInCollection) {
        // Try to merge the attributes--we're merging and the model (by id) was already in the collection
        needSort = modelFoundInCollection.Merge(modelToTryAndMerge, collection.comparator, silent);
        modelAdded = modelFoundInCollection;
      } else {
        // Make sure model is not already in there
        if (!force) {
          if (fillIn) {
            // Only bother if we have a real id set--comparing cids on a fill in is useless
            existingModel = !newModel.isNew() ? collection._getLocal(newModel) : undefined;
          } else {
            existingModel = collection._getLocal(newModel);
          }
          if (existingModel && fillIn && at !== existingModel.index) {
            // We're filling in a virtual collection: we should *not* be finding the new model already in
            // the collection if we're not merging and not forcing: this indicates duplicate ids
            // throw new Error("Duplicate IDs fetched or added without merging");
            Logger.warn(
              'Duplicate ID fetched or added without merging, the id = ' + existingModel.GetId()
            );
          }
        }

        if (existingModel === undefined) {
          addToCollection(collection, newModel);
          modelAdded = newModel;
        } else {
          modelAdded = existingModel;
        }
      }

      resortAndFireEvents(collection, existingModel, modelFoundInCollection, newModel, mergeDeferred);

      return modelAdded;
    }

    function doAdd(collection, model, addDeferred) {
      added = false;
      var newModel = collection._newModel(model, true, opt, false);
      var modelToTryAndMerge = null;
      var modelFoundInCollection = null;
      if (newModel != null) {
        index = -1;
        // Make sure ID is up to date
        newModel.SetupId();

        // Use original model array not cloned model if merging--otherwise we won't find the model in the
        // collection
        modelToTryAndMerge = model instanceof Model ? model : newModel;
        if (addDeferred) {
          if (force) {
            return new Promise(function (resolve) {
              var mergedModel = mergeAttrs(
                collection,
                modelToTryAndMerge,
                undefined,
                newModel,
                addDeferred
              );
              modelReturnList.push(mergedModel);
              resolve(mergedModel);
            });
          }
          return collection
            ._getInternal(modelToTryAndMerge, { silent: true }, addDeferred, true)
            .then(function (modInfo) {
              modelFoundInCollection = modInfo.m;
              var mod = mergeAttrs(
                collection,
                modelToTryAndMerge,
                modelFoundInCollection,
                newModel,
                addDeferred
              );
              modelReturnList.push(mod);
            });
        }
        if (!force && merge) {
          // Grab the actual model we want to merge from the collection, if the caller has indicated that
          // we aren't forcing an add and we want to merge
          modelFoundInCollection = fillIn
            ? collection._getLocal(modelToTryAndMerge)
            : collection.get(modelToTryAndMerge);
        }
        var modelAdded = mergeAttrs(
          collection,
          modelToTryAndMerge,
          modelFoundInCollection,
          newModel,
          addDeferred
        );
        if (modelAdded) {
          modelReturnList.push(modelAdded);
        }
      } else {
        // Add boolean falses for invalid models
        modelReturnList.push(false);
      }
      return Promise.resolve();
    }

    function _parse(collection, array) {
      // Must stop parsing if coming in from reset or constructor
      if (collection.parse && opt.parse && !opt.noparse) {
        return collection.parse(array);
      }
      return array;
    }

    if (!fillIn && (this.IsVirtual() || deferred)) {
      var self = this;
      return new Promise(function (allResolve, allReject) {
        var doTask = function (loc) {
          return new Promise(function (resolve, reject) {
            doAdd(self, modelArray[loc], true).then(function () {
              resolve(loc + 1);
            }, reject);
          });
        };

        var currentStep = Promise.resolve(0);

        modelArray = _parse(self, modelArray);
        for (i = 0; i < modelArray.length; i++) {
          currentStep = currentStep.then(doTask);
        }
        currentStep.then(function () {
          if (addedModels.length > 0) {
            self.TriggerInternal(opt.silent, Events.EventType.ALLADDED, self, addedModels, opt);
          }
          allResolve(Collection._returnModels(modelReturnList));
        }, allReject);
      });
    }

    modelArray = _parse(this, modelArray);
    for (i = 0; i < modelArray.length; i++) {
      doAdd(this, modelArray[i], false);
    }
    if (addedModels.length > 0) {
      this.TriggerInternal(opt.silent, Events.EventType.ALLADDED, this, addedModels, opt);
    }
    return Collection._returnModels(modelReturnList);
  };

  /**
   * @private
   */
  Collection._returnModels = function (modelReturnList) {
    if (modelReturnList.length === 1) {
      return modelReturnList[0];
    }
    return modelReturnList;
  };

  /**
   * @private
   */
  Collection.prototype._hasComparator = function () {
    return Collection._defined(this.comparator);
  };

  /**
   * Sort the models in the collection.  For virtual collections, any locally stored models are cleaned out in
   * preparation for new fetches sending server-sorted models down to the client.  No fetch is automatically
   * performed.<p>
   * For non-virtual collections, the models are sorted based on the comparator property.<p>
   * See [comparator}{@link Collection#comparator}<p>
   * For virtual collections, all sorting must be handled by the server.  If the string (attribute) comparator and
   * sortDirection are set, then this information
   * will be passed back via URL parameters, or passed to the customURL callback for application-construction of the
   * appropriate URL.  Function-based custom comparators are ignored in virtual collections.
   * Events:<p>
   * Fires a sort event, passing the collection and options<p>
   * @param {Object=} options <b>silent</b>: if true, do not fire the sort event<br>
   * <b>startIndex</b>: if provided, and if collection is virtual, do a fetch of startIndex+fetchSize immediately
   * after the sort and return a promise.  See [comparator}{@link Collection#setRangeLocal}<p>
   * @return {Promise|null} if virtual and if startIndex is provided in options, a promise Object that resolves upon
   * completion.  The promise will be passed an Object containing start and count properties that represent
   * the *actual* starting position (start), count (count), and array (models) of the Models fetched, which may be
   * fewer than what was requested.  The promise will be rejected on an error and will pass the ajax status,
   * xhr object, error, and collection, if relevant.
   *
   * @memberof Collection
   * @ojsignature  [{target: "Type", value:"{silent?: boolean, startIndex?: number, [propName: string]: any}", for: "options"},
   *                {target: "Type", value: "Promise<Collection.SetRangeLocalPromise>|null", for: "returns"}]
   * @since 1.0.0
   * @export
   */
  Collection.prototype.sort = function (options) {
    var opt = options || {};
    var silent = opt.silent;
    var comparator = this.comparator;
    var self;
    var eventOpts;

    // Check for comparator
    if (!this._hasComparator()) {
      return null;
    }

    // This is a no-op in case of virtualization: we should just clear things out so that
    // any elements will be refetched
    if (this.IsVirtual()) {
      var totalResults = this.totalResults;
      if (this._hasTotalResults()) {
        // Make sure to set up the array if the length changes (i.e., from 0 to totalResults--need to
        // preallocate)
        this._setModels(new Array(totalResults), true);
      } else {
        // No totalresults
        this._setModels([], true);
        this._resetLRU();
        this._setLength();
      }
      eventOpts = opt.add ? { add: true } : null;
      this.TriggerInternal(silent, Events.EventType.SORT, this, eventOpts, null);
      var startIndex = opt.startIndex;
      if (startIndex !== undefined && startIndex !== null) {
        return this.setRangeLocal(startIndex, this._getFetchSize(opt));
      }
      return null;
    }

    self = this;
    this._getModels().sort(function (a, b) {
      return Collection.SortFunc(a, b, comparator, self, self);
    });
    this._realignModelIndices(0);
    // Indicate this sort is due to an add
    eventOpts = opt.add ? { add: true } : null;
    this.TriggerInternal(silent, Events.EventType.SORT, this, eventOpts, null);
    return null;
  };

  /**
   * @private
   */
  Collection._getKey = function (val, attr) {
    if (val instanceof Model) {
      return val.get(attr);
    }
    return RestImpl.GetPropValue(val, attr);
  };

  /**
   * @private
   */
  Collection.SortFunc = function (a, b, comparator, collection, self) {
    var keyA;
    var keyB;
    var i;
    var retVal;

    if ($.isFunction(comparator)) {
      // How many args?
      if (comparator.length === 1) {
        // "sortBy" comparator option
        keyA = comparator.call(self, a);
        keyB = comparator.call(self, b);
        var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(',') : [keyA];
        var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(',') : [keyB];
        for (i = 0; i < attrs1.length; i++) {
          retVal = Collection._compareKeys(attrs1[i], attrs2[i], collection.sortDirection);
          if (retVal !== 0) {
            return retVal;
          }
        }
      }
      // "sort" comparator option
      return comparator.call(self, a, b);
    }
    // String option
    if (oj.StringUtils.isString(comparator)) {
      var attrs = comparator.split(',');

      for (i = 0; i < attrs.length; i++) {
        keyA = Collection._getKey(a, attrs[i]);
        keyB = Collection._getKey(b, attrs[i]);
        retVal = Collection._compareKeys(keyA, keyB, collection.sortDirection);
        if (retVal !== 0) {
          return retVal;
        }
      }
    }
    return 0;
  };

  /**
   * Return the index at which the given model would be inserted, using the collection comparator See
   * [sort}{@link Collection#sort}.  Not supported for virtual collections.
   *
   * @param {string|function(Model,Model=):Object=} comparator optional comparator to override the default
   * @returns {number} index at which model would be inserted.  -1 if no comparator
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @export
   * @since 1.0.0
   */
  Collection.prototype.sortedIndex = function (model, comparator) {
    var comp = comparator || this.comparator;
    var self;
    var test;

    // Check for comparator
    if (!comp) {
      return -1;
    }

    this._throwErrIfVirtual('sortedIndex');

    self = this;
    test = function (a, b) {
      var keyA;
      var keyB;

      if ($.isFunction(comp)) {
        // How many args?
        if (comp.length === 1) {
          // "sortBy" comparator option
          keyA = comp.call(self, a);
          keyB = comp.call(self, b);
          var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(',') : [keyA];
          var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(',') : [keyB];
          var retVal;
          var i;
          for (i = 0; i < attrs1.length; i++) {
            retVal = Collection._compareKeys(attrs1[i], attrs2[i], self.sortDirection);
            if (retVal !== 0) {
              return retVal;
            }
          }
        }
        // "sort" comparator option
        return comp.call(self, a, b);
      }
      // String option
      if (oj.StringUtils.isString(comp)) {
        keyA = a.get(comp);
        keyB = b.get(comp);
        return Collection._compareKeys(keyA, keyB, self.sortDirection);
      }
      return 0;
    };
    return Collection._find(this._getModels(), model, test);
  };

  /**
   * Binary search and return the index at which model would be inserted into sorted modelArray
   * @private
   */
  Collection._find = function (modelArray, model, comparator) {
    function search(min, max) {
      var cid;
      var id;
      var mid;

      if (min > max) {
        return -1;
      }

      cid = model.GetCid();
      id = model.GetId();
      if (modelArray[min].Match(id, cid)) {
        return min;
      }
      if (modelArray[max].Match(id, cid)) {
        return max;
      }

      mid = Math.floor((max + min) / 2);
      if (comparator(modelArray[mid], model) === -1) {
        return search(min + 1, mid);
      }
      if (comparator(modelArray[mid], model) === 1) {
        return search(mid, max - 1);
      }
      return mid;
    }

    return search(0, modelArray.length - 1);
  };

  /**
   * @private
   */
  Collection._compareKeys = function (keyA, keyB, sortDirection) {
    if (sortDirection === -1) {
      if (keyA < keyB) {
        return 1;
      }
      if (keyB < keyA) {
        return -1;
      }
    } else {
      if (keyA > keyB) {
        return 1;
      }
      if (keyB > keyA) {
        return -1;
      }
    }
    return 0;
  };

  /**
   * Add the given model to the front of the collection<br>
   * For events that may be fired, see [add]{@link Collection#add}.<br>
   * @param {Model|Object} m model (or set of attribute/value pairs) to add to the beginning of the collection
   * @param {Object=} options See [add]{@link Collection#add}
   * @returns {Promise.<Array>|Array.<Model>} The model or models added to the collection.  If
   * deferred or virtual, return the model or models added in a promise when the set has completed
   * @memberof Collection
   * @ojsignature [{target: "Type", value:"{silent?: boolean, at?: number, merge?: boolean, sort?: boolean, force?: boolean, deferred?: boolean,
   *               [propName: string]: any}", for: "options"},
   *               {target: "Type", value: "Promise<Array<Model>>|Array<Model>", for: "returns"}]
   * @export
   * @since 1.0.0
   */
  Collection.prototype.unshift = function (m, options) {
    // Like an add but set 'at' to zero if not specified
    var opt = {};
    oj.CollectionUtils.copyInto(opt, options || {});
    if (!opt.at) {
      opt.at = 0;
    }
    this._manageLRU(1);
    return this._handlePromise(this._addInternal(m, opt, false, opt.deferred));
  };

  /**
   * @private
   */
  Collection.prototype._handlePromise = function (result) {
    if ($.isFunction(result.then)) {
      return this._addPromise(function () {
        return result;
      });
    }
    return result;
  };

  /**
   * Remove the first model from the collection and return it.<br>
   * For events that may be fired, see [remove]{@link Collection#remove}.<br>
   * @param {Object=} options same as remove
   * @property {boolean=} silent if set, do not fire events
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual whether it is or not
   * @return {Model|Promise.<Model>|null} model that was removed.  If this is a virtual collection, this will return a promise
   *                  which will resolve passing the model value that was removed
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.shift = function (options) {
    var opt = options || {};
    var deferred = this._getDeferred(opt);
    var retVal;
    if (this.IsVirtual() || deferred) {
      var self = this;
      return this._atInternal(0, opt, false, true).then(function (model) {
        retVal = self._removeInternal(model, 0, opt);
        self.TriggerInternal(opt.silent, Events.EventType.ALLREMOVED, self, [retVal], opt);

        return retVal;
      });
    }
    retVal = this._removeInternal(this.at(0), 0, opt);
    this.TriggerInternal(opt.silent, Events.EventType.ALLREMOVED, this, [retVal], opt);
    return retVal;
  };

  /**
   * @export
   * @desc Return an array of models found in the Collection, excepting the last n.
   * @memberof Collection
   * @param {number=} n number of models to leave off the returned array; defaults to 1
   * @return {Array.<Model>} array of models from 0 to the length of the collection - n - 1
   * @throws {Error} when called on a virtual collection
   * @since 1.0.0
   */
  Collection.prototype.initial = function (n) {
    var index = n === undefined ? 1 : n;

    this._throwErrIfVirtual('initial');

    var array = [];
    var i;
    for (i = 0; i < this._getLength() - index; i += 1) {
      array.push(this.at(i));
    }
    return array;
  };

  /**
   * @private
   */
  Collection.prototype._getDeferred = function (options) {
    var opt = options || {};
    return opt.deferred;
  };

  /**
   * Return the last model in the collection.  If n is passed in, then the last n models are returned as an array
   * Note that if the collection is virtual, and totalResults is not returned by the server, the results returned
   * by last can be difficult to predict.  They depend on the fetch sizes, last known offset of a fetch, etc.
   * If code is using a server that does not return totalResults the use of last is not recommended.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   * @param {number=} n number of models to return.  Defaults to 1
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual whether it is or not
   * @return {Promise.<Model>|Array.<Model>|null} array of n models from the end of the Collection.  If this is a virtual collection,
   *                             this will return a promise which will resolve passing the array or single model
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.last = function (n, options) {
    var deferred = this._getDeferred(options);
    var index = n === undefined ? 1 : n;
    var len;

    if (index === 1) {
      len = this._getModelsLength();
      if (len === 0) {
        len = index;
      }
      if (len > 0) {
        return this._atInternal(len - 1, options, false, deferred);
      }
      return null;
    }

    var array = [];
    var i;
    len = this._getLength();
    if (deferred || this.IsVirtual()) {
      // Loop using deferred
      var start = len - n;

      // Handle edge or no totalResults cases
      if (start < 0) {
        start = 0;
      }
      if (len === 0) {
        // No totalresults, probably
        len = n;
      }

      var self = this;
      return this._addPromise(function () {
        return self.IterativeAt(start, len);
      });
    }

    for (i = len - n; i < len; i += 1) {
      array.push(this.at(i));
    }
    return array;
  };

  /**
   * Loop calling at() in a deferred way and return a promise to be resolved when all the elements are sequentially
   * fetched
   * @protected
   */
  Collection.prototype.IterativeAt = function (start, end) {
    var array = [];
    var i;
    var self = this;
    return new Promise(function (allResolve, allReject) {
      var doTask = function (index) {
        // Make sure we're not asking beyond what we know the server can deliver, if virtual
        if (self.IsVirtual() && self._hasTotalResults() && index >= self.totalResults) {
          return Promise.resolve(index + 1);
        }
        return new Promise(function (resolve, reject) {
          self._deferredAt(index, null).then(function (model) {
            array.push(model);
            resolve(index + 1);
          }, reject);
        });
      };

      var currentStep = Promise.resolve(start);
      for (i = start; i < end; i++) {
        currentStep = currentStep.then(doTask);
      }
      currentStep.then(function () {
        allResolve(array);
      }, allReject);
    });
  };

  /**
   * @private
   */
  Collection.prototype._getDefaultFetchSize = function (n) {
    if (n === undefined || n === null) {
      return this[Collection._FETCH_SIZE_PROP];
    }

    return n;
  };

  /**
   * @private
   */
  Collection.prototype._calculateNextStart = function () {
    var lastFetch = this.lastFetchCount;
    if (lastFetch === undefined || lastFetch === null) {
      lastFetch = this[Collection._FETCH_SIZE_PROP];
    }
    if (this.offset === undefined || this.offset === null) {
      // Assume zero offset (0+lastFetch)
      return lastFetch;
    }
    return this.offset + lastFetch;
  };

  /**
   * Fetch the next set of models from the server.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   *
   * @param {number} n number of models to fetch.  If undefined or null, the collection will attempt to use the
   * overall [fetchSize]{@link Collection#fetchSize} property value
   * @param {Object=} options Options to control next<p>
   *                  <b>success</b>: a user callback called when the fetch has completed successfully. This makes
   *                  the fetch an asynchronous process. The callback is called passing the Collection object, raw
   *                  response, and the options argument.<br>
   *                  <b>error</b>: a user callback function called if the fetch fails. The callback is called
   *                  passing the collection object, xhr, and options arguments.<br>
   * @return {Object|null} xhr ajax object, by default.  null if nothing to fetch (the success callback will still be
   * called).  Note if [sync]{@link Collection#sync} has been replaced, this would be the value returned by the
   * custom implementation.
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (collection: Collection, response: any, options: object)=> void,
   *                                                  error?: (collection: Collection, xhr: any, options: object)=> void, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.next = function (n, options) {
    var opt = options || {};
    opt[Collection._FETCH_SIZE_PROP] = this._getDefaultFetchSize(n);

    var start = this._calculateNextStart();
    var length = this._getLength();
    if (length === 0 && opt[Collection._FETCH_SIZE_PROP] > 0) {
      // If we have a fetch size and we have no length let next() do a fetchSize fetch starting at zero to
      // kick things off
      start = 0;
    } else if (start >= length) {
      // No op -- still call success because the items are already fetched.
      var self = this;
      if (opt.success) {
        opt.success.call(Model.GetContext(opt, self), self, null, opt);
      }

      return null;
    }
    opt.startIndex = start;
    return this.fetch(opt);
  };

  /**
   * @private
   */
  Collection.prototype._calculatePrevStart = function (n) {
    if (this.offset === undefined || this.offset === null) {
      // Assume zero: we can't back up beyond that so if the offset wasn't set there's nothing to do
      return 0;
    }
    return this.offset - n;
  };

  /**
   * Fetch the previous set of models from the server.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   * @param {number} n number of models to fetch.  If undefined or null, the collection will attempt to use the
   * overall fetchSize property value
   * @param {Object=} options Options to control previous<p>
   *                  <b>success</b>: a user callback called when the fetch has completed successfully. This makes
   *                  the fetch an asynchronous process. The callback is called passing the Collection object, raw
   *                  response, and the options argument.<p>
   *                  <b>error</b>: a user callback function called if the fetch fails. The callback is called
   *                  passing the collection object, xhr, and options arguments.<p>
   * @return {Object} xhr ajax object, by default. null if there is nothing earlier to fetch (no fetch has happened
   * or the last fetch started at 0).  The success callback will still be called.  Note if
   * [sync]{@link Collection#sync} has been replaced, this would be the value returned by the custom
   * implementation.
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (collection: Collection, response: any, options: object)=> void,
   *                                                  error?: (collection: Collection, xhr: any, options: object)=> void, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.previous = function (n, options) {
    var opt = options || {};
    if (this.offset === 0) {
      // No op -- still call success (if we've fetched before--lastFetchCount is other than zero) because the
      // items are already fetched.
      var self = this;
      if (opt.success && this.lastFetchCount) {
        opt.success.call(Model.GetContext(opt, self), self, null, opt);
      }

      return null;
    }
    opt[Collection._FETCH_SIZE_PROP] = this._getDefaultFetchSize(n);
    var start = this._calculatePrevStart(opt[Collection._FETCH_SIZE_PROP]);
    if (start < 0) {
      // Only fetch from 0 to the last fetch's starting point...
      opt[Collection._FETCH_SIZE_PROP] = this.offset;
      start = 0;
    }
    opt.startIndex = start;
    return this.fetch(opt);
  };

  /**
   * Set or change the number of models held at any one time
   *
   * @param {number} n maximum number of models to keep at a time
   * @return {undefined}
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.setModelLimit = function (n) {
    this.modelLimit = n;
    // Clean out down to the new limit, if necessary
    this._manageLRU(0);
  };

  /**
   * @private
   */
  Collection.prototype._getModelLimit = function () {
    return this.modelLimit;
  };

  /**
   * Set or change the number of models to fetch with each server request
   *
   * @param {number} n number of models to fetch with each request
   * @return {undefined}
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.setFetchSize = function (n) {
    this[Collection._FETCH_SIZE_PROP] = n;
  };

  /**
   * Return the array of models found in the Collection starting with index n.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   * @param {number=} n index at which to start the returned array of models.  Defaults to 1.
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual whether it is or not
   * @return {Array.<Model>|Promise} array of models from the collection.  If this is a virtual collection, or
   *                  if deferred is passed as true, return a promise which resolves passing the array of models.
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.rest = function (n, options) {
    var deferred = this._getDeferred(options);
    var index = n === undefined ? 1 : n;

    var array = [];
    var i;
    // TODO
    if (this.IsVirtual() || deferred) {
      var self = this;
      return this._addPromise(function () {
        return self.IterativeAt(index, self._getLength());
      });
    }

    for (i = index; i < this._getLength(); i += 1) {
      array.push(this.at(i));
    }
    return array;
  };

  /**
   * Remove a model from the collection, if found.<br>
   * Events:<p>
   * <ul>
   * <b>remove</b>: fired for each model removed, passing the model removed, collection, and options<br>
   * <b>allremoved</b>: fired after all models have been removed, passing the collection, array of models removed,
   * and options<br>
   * </ul>
   * <p>
   * @param {Model|Array.<Model>} m model object or array of models to remove.
   * @param {Object=} options
   * @property {boolean=} silent if set, do not fire events
   * @return {Array.<Model>|Model} an array of models or single model removed
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.remove = function (m, options) {
    var opt = options || {};
    var modArray = [];
    var mod;

    if (m instanceof Array) {
      modArray = m;
    } else {
      modArray.push(m);
    }

    var modsRemoved = [];
    for (mod = modArray.length - 1; mod >= 0; mod -= 1) {
      // Done to keep array in order matching one passed in--we do removal in reverse
      modsRemoved.unshift(this._removeInternal(modArray[mod], -1, opt));
    }
    this.TriggerInternal(opt.silent, Events.EventType.ALLREMOVED, this, modArray, opt);
    return Collection._returnModels(modsRemoved);
  };

  /**
   * @private
   */
  Collection.prototype._removeInternal = function (model, index, options) {
    var optCopy = options || {};
    var modInfo = index === -1 ? this._getInternal(model) : Collection._getModinfo(index, model);
    var silent = optCopy.silent;

    var n = modInfo.index;
    if (n > -1) {
      var mod = modInfo.m;
      // only unset the collection setting if it's mine
      if (mod !== undefined && mod.GetCollection() === this) {
        mod.SetCollection(null);
      }
      this._spliceModels(n, 1);
      this._setLength();
      var opt = {};
      oj.CollectionUtils.copyInto(opt, optCopy);
      opt.index = n;
      if (mod !== undefined) {
        mod.TriggerInternal(silent, Events.EventType.REMOVE, mod, this, opt);
      }
      // Unlisten after event fired
      this._unlistenToModel(mod);
    }
    return modInfo.m;
  };

  /**
   * @private
   */
  Collection.prototype._unlistenToModel = function (m) {
    if (m !== undefined) {
      m.off(null, null, this);
    }
  };

  /**
   * @private
   */
  Collection.prototype._listenToModel = function (m) {
    m.OnInternal(Events.EventType.ALL, this._modelEvent, this, false, true);
  };

  /**
   * Handle model destroyed events via the all listener
   * @private
   */
  Collection.prototype._modelEvent = function (event, model, collection, options) {
    if (event === Events.EventType.DESTROY) {
      this.remove(model);
    }

    // Don't process general events if we're not the target
    if (collection !== undefined && collection instanceof Collection && collection !== this) {
      return;
    }

    // Throw up to the collection
    var silent = options && options.silent;
    this.TriggerInternal(silent, event, model, collection, options);
  };

  /**
   * Clear all data from the collection and refetch (if non-virtual).  If virtual, clear all data.
   * If fetch() cannot be called (e.g., there is no URL) then the caller must reload the collection wtih data.
   * The existing data is still cleared.
   * Events (if silent is not set):<p>
   * <ul>
   * <b>refresh</b>: fired passing the collection and options<br>
   * For more events that may be fired if the collection is not virtual, see [fetch]{@link Collection#fetch}.
   * </ul>
   * <p>
   * @param {Object=} options user options<p>
   *                          <b>silent</b>: if set, do not fire a refresh event<p>
   * <b>startIndex</b>: if provided, and if collection is virtual, do a fetch of startIndex+fetchSize immediately
   * after the refresh and return a promise.  See [comparator}{@link Collection#setRangeLocal}<p>
   * @return {Promise.<undefined|Object>} promise object resolved when complete (in case there is a fetch for non-virtual mode).  If
   * startIndex is provided as an option, the returned promise resolution is the same as setRangeLocal.
   * @ojsignature  {target: "Type", value: "Promise<Collection.SetRangeLocalPromise|undefined>", for: "returns"}
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{silent?: boolean, startIndex?: number, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.refresh = function (options) {
    var optCopy = options || {};

    var self = this;
    var silent;
    return this._addPromise(function () {
      return new Promise(function (resolve, reject) {
        if (!self.IsVirtual()) {
          silent = optCopy.silent !== undefined && optCopy.silent;
          try {
            // Do a reset, with silent
            self.reset(null, { silent: true });
            // Local: do a fetch to fill back up
            // In case options are passed to refresh-->fetch
            var opt = {};
            Object.keys(optCopy).forEach(function (prop) {
              if (Object.prototype.hasOwnProperty.call(optCopy, prop)) {
                opt[prop] = optCopy[prop];
              }
            });
            opt.success = function (collection, response, successOpts) {
              self.TriggerInternal(silent, Events.EventType.REFRESH, self, successOpts, null);
              resolve({ collection: collection, response: response, options: successOpts });
            };
            opt.error = function (collection, error, xhr, optarg, status) {
              reject(Collection._createRejectionError(xhr, status, error, self, optCopy, false));
            };
            self._fetchInternal(opt, -1, false);
            return;
          } catch (e) {
            // This is OK if it's a URLError: just fire the event: local collection without custom sync
            if (e instanceof URLError) {
              // if it's a completely local collection, it's a no-op other than the event
              self.TriggerInternal(silent, Events.EventType.REFRESH, self, optCopy, null);
              resolve({ collection: self, options: optCopy });
              return;
            }
            throw e;
          }
        }
        // Virtual
        var startIndex = optCopy.startIndex;

        self._setModels([], true);
        self._resetLRU();

        // Clear totalresults.
        self.totalResults = undefined;
        self._setLength();

        silent = optCopy.silent !== undefined && optCopy.silent;
        self.TriggerInternal(silent, Events.EventType.REFRESH, self, optCopy, null);
        if (startIndex === undefined || startIndex === null) {
          startIndex = 0;
        }
        if (startIndex !== undefined && startIndex !== null) {
          // Do a set range local
          self._setRangeLocalInternal(startIndex, self._getFetchSize(optCopy)).then(
            function (actual) {
              resolve(actual);
            },
            function (err) {
              reject(err);
            }
          );
        } else {
          resolve(undefined);
        }
      });
    });
  };

  /**
   * Remove and replace the collection's entire list of models with a new set of models, if provided. Otherwise,
   * empty the collection.  totalResults is reset when no new data is passed in, set to the new length in the
   * non-virtual case if data is passed in, and left as was in the virtual case if data is passed in.<br>
   * Events (if silent is not set):<p>
   * <ul>
   * <b>reset</b>: fired passing the collection and options.  The new length of the collection should be in effect
   * when the event is fired<br>
   * For events that may be fired if data is passed in, see [add]{@link Collection#add}.
   * </ul>
   * <p>
   * @param {Object=} data Array of model objects or attribute/value pair objects with which to replace the
   * collection's data.
   * @param {Object=} options user options, passed to event, unless silent<br>
   *                          <b>silent</b>: if set, do not fire events<p>
   * @returns {Model|Array.<Model>} The model or models added to the collection, if passed in
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{silent?: boolean, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.reset = function (data, options) {
    var opts = {};
    oj.CollectionUtils.copyInto(opts, options || {});

    opts.previousModels = this._getModels();

    var index;
    var model;
    for (var i = 0; i < this._modelIndices.length; i++) {
      index = this._modelIndices[i];
      model = this._getModel(index);
      if (model) {
        this._unlistenToModel(model);
        model.SetCollection(null);
      }
    }
    this._setModels([], true);
    this._resetLRU();

    var silent = opts.silent !== undefined && opts.silent;
    if (!data) {
      this._setLength();
      // Clear totalresults
      this.totalResults = undefined;
      this.TriggerInternal(silent, Events.EventType.RESET, this, opts, null);
      return null;
    }

    var retObj = null;
    // Parse collection
    var newData = data;
    if (opts.parse) {
      newData = this.parse(data);
    }

    this._manageLRU(newData instanceof Array ? newData.length : 1);
    opts.noparse = true;
    retObj = this._addInternal(newData, opts, true, false);
    this._setLength();
    this.TriggerInternal(silent, Events.EventType.RESET, this, opts, null);

    return this._handlePromise(retObj);
  };

  /**
   * Return the model object found at the given index of the collection, or a promise object that will pass the model
   * as an argument when it resolves.<p>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.
   * @param {number} index Index for which to return the model object.
   * @param {Object=} options <b>fetchSize</b>: fetch size to use if the call needs to fetch more records from the
   * server, if virtualized.  Overrides the overall fetchSize setting <br>
   *                  <b>deferred</b>: if true, return a deferred/promise object as described below.  If not
   *                  specified, the type of return value will be determined by whether or not the collection is
   *                  virtual<br>
   *
   * @return {Model|Promise.<Model>|null} Model [model]{@link Model} located at index. If index is out of range, returns null.
   * If this is a virtual collection, or if deferred is specified and true, at will return a Promise object which
   * will resolve passing the model at the given index (or null if out of range)
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{fetchSize?: number, deferred?: boolean, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.at = function (index, options) {
    var deferred = this._getDeferred(options);
    return this._atInternal(index, options, false, deferred);
  };

  /**
   * Local indicates that only what's stored locally should be returned (if true)--no fetching
   * @private
   */
  Collection.prototype._atInternal = function (index, options, local, deferred) {
    var n = index;
    if (n < 0) {
      // Normalize it using the length-- another BackboneJS test case
      n += this._getLength();
    }

    if (n < 0 || this._overUpperLimit(n)) {
      if (!local && (this.IsVirtual() || deferred)) {
        return this._addPromise(function () {
          return Promise.resolve(null);
        });
      }
      return null;
    }
    var self = this;
    if (!local && (this.IsVirtual() || deferred)) {
      return this._addPromise(function () {
        return self._deferredAt(n, options);
      });
    }
    return this._getModel(n);
  };

  /**
   * Return a promise, the resolution of which indicates that all promise-returning API in process have completed.
   *
   * @returns {Promise} a promise that when resolved, indicates that all unresolved promise-returning API calls
   * made at the moment of the whenReady have completed
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.whenReady = function () {
    if (this._promises) {
      // If we have an active chain, return it
      return this._promises;
    }
    // Otherwise return an immediately resolved promise that means nothing...
    return Promise.resolve();
  };

  /**
   * Add a task to a chained list of Promises
   * @private
   */
  Collection.prototype._addPromise = function (promiseTask) {
    var self = this;
    // Undefined, so set it up initially
    if (this._promises === undefined) {
      this._promiseCount = 0;
      this._promises = Promise.resolve();
    }
    // Track the number we have left to resolve
    this._promiseCount += 1;
    // Chain this new promise callback task to the end of the list
    this._promises = this._promises.then(promiseTask.bind(self)).then(
      function (arg) {
        // Resolved successfully--decrement our count and clean up if we have none left to resolve
        self._promiseCount -= 1;
        if (self._promiseCount === 0) {
          self._promises = undefined;
          // Fire the ready event
          self.TriggerInternal(false, Events.EventType.READY, self, null, null);
        }
        // Resolve the true promise with the value we're given
        return arg;
      },
      function (error) {
        // Rejected--decrement our count and clean up if we have none left to resolve
        self._promiseCount -= 1;
        if (self._promiseCount === 0) {
          self._promises = undefined;
        }
        // Reject the promise
        return Promise.reject(error);
      }
    );

    // Return the chain with the new promise at the end
    return this._promises;
  };

  /**
   * Add an xhr to a list of active xhrs
   * @private
   */
  Collection.prototype._addxhr = function (xhr) {
    if (xhr && xhr.abort) {
      if (this._xhrs === undefined) {
        this._xhrs = [];
      }
      // Listen to this xhr to know when to remove it
      var self = this;
      this._xhrs.push(xhr);
      xhr.done(function () {
        // Find the xhr
        var loc = self._xhrs ? self._xhrs.indexOf(xhr) : -1;
        if (loc > -1) {
          // Remove it from the list
          self._xhrs.splice(loc, 1);
        }
      });
    }
  };

  /**
   * Cancel all xhr requests known to this collection as still pending.  Return a promise that is resolved when all of the requests abort, and all
   * the promises tied to those requests resolve with an error
   *
   * @returns {Promise.<null>} a promise that when resolved, indicates that all the open xhr objects generated by this collection have aborted
   * @memberof Collection
   * @since 2.1.0
   * @export
   */
  Collection.prototype.abort = function () {
    // Abort all pending XHR requests
    var self = this;
    function createPromise(index, resolve) {
      self._xhrs[index].then(
        function (data, status) {
          if (status === 'abort') {
            // Remove from list
            self._xhrs.splice(index, 1);
            // If this is the last one, resolve the promise we returned
            if (self._xhrs.length === 0) {
              self.whenReady().then(
                function () {
                  resolve(null);
                },
                function () {
                  resolve(null);
                }
              );
            }
          }
        },
        function () {
          // Remove from list
          self._xhrs.splice(index, 1);
          // If this is the last one, resolve the promise we returned
          if (self._xhrs.length === 0) {
            self.whenReady().then(
              function () {
                resolve(null);
              },
              function () {
                resolve(null);
              }
            );
          }
        }
      );
    }

    if (this._xhrs && this._xhrs.length > 0) {
      return new Promise(function (resolve) {
        // Count down so we can remove them
        for (var i = self._xhrs.length - 1; i >= 0; i--) {
          createPromise(i, resolve);
          self._xhrs[i].abort();
        }
      });
    }
    return Promise.resolve();
  };

  /**
   * @private
   */
  Collection.prototype._deferredAt = function (index, options) {
    var self = this;
    // If it's virtual, we need to see if this item has been fetched or not: if not, we need to fetch it + fetchSize
    var model = self._getModel(index);
    if (model === undefined) {
      return new Promise(function (resolve, reject) {
        // Go fetch
        var opts = {};
        oj.CollectionUtils.copyInto(opts, options || {});
        opts.context = self;
        opts.startIndex = index;
        opts.error = function (collection, error, optarg, xhr, status) {
          // Handle potential errors
          reject(Collection._createRejectionError(xhr, status, error, self, options, false));
        };

        opts.success = function () {
          resolve(self._getModel(index));
        };

        self._fetchInternal(opts, -1, false);
      });
    }
    return new Promise(function (resolve) {
      resolve(model);
    });
  };

  /**
   * Return the first model object from the collection whose client ID is the given model cid
   * @param {string} clientId Client ID (see Model cid) for which to return the model object, if found.
   * @return {Model|null} First model object in the collection where model.cid = clientId. If none are found,
   * returns null.
   *
   * @throws {Error} when called on a virtual Collection if the item isn't found in memory
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.getByCid = function (clientId) {
    var models = this._getModels();
    var index;
    var foundModel = null;
    for (var i = 0; i < this._modelIndices.length; i++) {
      index = this._modelIndices[i];
      if (models[index] && clientId === models[index].cid) {
        foundModel = models[index];
        break;
      }
    }
    if (foundModel) {
      return foundModel;
    }
    if (this.IsVirtual()) {
      throw new Error('Not found locally and not supported by server for virtual collections');
    }
    return null;
  };

  /**
   * Return the first model object from the collection whose model id value is the given id or cid, or the id or
   * cid from a passed in model
   * Note this method will not function as expected if the id or cid is not set<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   *
   * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found.
   * @param {Object=} options
   * @property {number=} fetchSize fetch size to use if the call needs to fetch more records from the server,
   *                  if virtualized.  Overrides the overall fetchSize setting<p>
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual whether it
   *                  is or not
   * @return {Model|null|Promise.<Model>} First model object in the collection where model.id = id or model.cid = id. If
   *                  none are found, returns null.  If deferred or virtual, return a promise passing the model
   *                  when done
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.get = function (id, options) {
    var deferred = this._getDeferred(options);
    var internalGet = this._getInternal(id, options, deferred);
    if (internalGet) {
      // Is this a deferred object?
      if ($.isFunction(internalGet.then)) {
        return this._addPromise(function () {
          return new Promise(function (resolve, reject) {
            internalGet.then(
              function (modInfo) {
                resolve(modInfo.m);
              },
              function (err) {
                reject(err);
              }
            );
          });
        });
      }
      if (this.IsVirtual()) {
        return this._addPromise(function () {
          return new Promise(function (resolve) {
            resolve(internalGet.m);
          });
        });
      }
      if (Object.prototype.hasOwnProperty.call(internalGet, 'm')) {
        return internalGet.m;
      }
    }
    return null;
  };

  /**
   * @private
   */
  Collection.prototype._getLocal = function (id) {
    var internalGet = this._getLocalInternal(id);
    if (internalGet) {
      return internalGet.m;
    }
    return null;
  };

  /**
   * @private
   */
  Collection.prototype._getLocalInternal = function (id) {
    var cid = id;
    var localId = id;
    if (id instanceof Model) {
      // Get the cid
      cid = id.GetCid();
      // Get the id
      localId = id.GetId();
    } else if (Collection._defined(id) && id.id !== undefined) {
      localId = id.id;
    }
    var foundObj = null;
    var len = this._modelIndices.length;
    var model;
    var models = this._getModels();
    var index;
    for (var i = 0; i < len; i++) {
      index = this._modelIndices[i];
      model = models[index];
      if (model !== undefined && model.Match(localId, cid)) {
        foundObj = Collection._getModinfo(index, model);
        break;
      }
    }
    if (foundObj) {
      return foundObj;
    }
    return Collection._getModinfo(-1, undefined);
  };

  /**
   * @private
   * @param {Object|null|string} id
   * @param {Object=} options
   * @param {boolean=} deferred
   * @param {boolean=} fillIn
   * @returns {Object}
   */
  Collection.prototype._getInternal = function (id, options, deferred, fillIn) {
    var cid = id;
    var localId = id;
    var fill = fillIn === undefined ? false : fillIn;
    if (id instanceof Model) {
      // Get the cid
      cid = id.GetCid();
      // Get the id
      localId = id.GetId();
    } else if (Collection._defined(id) && id.id !== undefined) {
      localId = id.id;
    }

    var foundObj = null;
    var models = this._getModels();
    var index;
    for (var i = 0; i < this._modelIndices.length; i++) {
      index = this._modelIndices[i];
      if (models[index] && models[index].Match(localId, cid)) {
        var retObj = Collection._getModinfo(index, models[index]);
        foundObj = retObj;
        break;
      }
    }

    if (foundObj) {
      if (deferred) {
        return new Promise(function (resolve) {
          resolve(foundObj);
        });
      }
      return foundObj;
    }
    // If virtual, might be undefined because it needs to be fetched
    if (this.IsVirtual()) {
      // Try to fetch using start ID.  cid not supported
      if (localId === undefined && cid !== undefined) {
        return new Promise(function (resolve) {
          resolve(Collection._getModinfo(-1, undefined));
        });
      }
      var self = this;
      return new Promise(function (resolve, reject) {
        var resp = function (response) {
          if (response != null) {
            var ind = self._getOffset();
            // Check that the model at index is the right one
            var model = self._getModel(ind);
            if (model !== undefined && model.Match(localId, cid)) {
              resolve(Collection._getModinfo(ind, model));
            } else {
              resolve(Collection._getModinfo(-1, undefined));
            }
          } else {
            resolve(Collection._getModinfo(-1, undefined));
          }
        };

        // Go fetch
        var opts = {};
        oj.CollectionUtils.copyInto(opts, options || {});
        opts.context = self;
        opts.startID = localId;
        opts.error = function (collection, error, optarg, xhr, status) {
          // Handle potential errors
          reject(Collection._createRejectionError(xhr, status, error, self, options, false));
        };
        opts.success = function (collection, response) {
          resp(response);
        };

        self._fetchInternal(opts, -1, fill);
      });
    }

    var undefinedModInfo = Collection._getModinfo(-1, undefined);
    if (deferred) {
      return new Promise(function (resolve) {
        resolve(undefinedModInfo);
      });
    }
    return undefinedModInfo;
  };

  /**
   * @private
   */
  Collection._getModinfo = function (index, model) {
    return { index: index, m: model };
  };

  /**
   * @private
   */
  Collection.prototype._parseImpl = function (response) {
    // Try to interpret ADFbc like controls where a collection is hanging off a property
    if (response instanceof Array) {
      return response;
    }

    if (!response) {
      return response;
    }

    // See if any of the properties contain arrays
    var prop;
    // eslint-disable-next-line no-restricted-syntax
    for (prop in response) {
      if (Object.prototype.hasOwnProperty.call(response, prop)) {
        if (response[prop] instanceof Array) {
          return response[prop];
        }
      }
    }
    return response;
  };

  /**
   * Optional callback to parse responses from the server.  It is called with the server's response and should return a response (possibly modified) for processing
   *
   * @type {function(Object):Object}
   * @since 1.0.0
   * @memberof Collection
   * @export
   */
  Collection.prototype.parse = Collection.prototype._parseImpl;

  /**
   * Determine if actual means we are complete
   * @private
   */
  Collection.prototype._checkActual = function (start, count, actual) {
    // Are we at the end with what actually came back?  Then this request should satisfy the setLocalRange
    if (this._hasTotalResults() && actual.start + actual.count >= this.totalResults) {
      return true;
    }
    return actual.start === start && actual.count === count;
  };

  /**
   *
   * Tell the collection to try and ensure that the given range is available locally.  Note that if the collection
   * is virtual, setRangeLocal may make repeated fetch calls to the server to satisfy the request, stopping only
   * when the range has been made local or the end of the records on the server is reached.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   *
   * @param {number} start starting index to make local
   * @param {number} count number of elements to make local
   * @param {Object=} options Options to control whether events are fired by this call (silent: true)
   * @return {Promise} a promise Object that resolves upon completion.  The promise will be passed an Object
   * containing start and count properties that represent the *actual* starting position (start), count (count),
   * and array (models) of the Models fetched, which may be fewer than what was requested.  The promise will be
   * rejected on an error and will pass the ajax status, xhr object, error, and collection, if relevant.
   * @memberof Collection
   * @ojsignature  [{target: "Type", value:"{silent?: boolean}", for: "options"}, {target: "Type", value: "Promise<Collection.SetRangeLocalPromise>", for: "returns"}]
   * @since 1.0.0
   * @export
   */
  Collection.prototype.setRangeLocal = function (start, count, options) {
    var self = this;
    return this._addPromise(function () {
      return self._setRangeLocalInternal(start, count, options);
    });
  };

  /**
   * @typedef {Object} Collection.SetRangeLocalPromise
   * @property {number} start starting index of fetched models
   * @property {number} count number of models fetched
   * @property {Array.<Model>} models array of models fetched
   * @ojsignature  [{target: "Type", value: "Model[]", for: "models"}]
   *
   * @example <caption>Information about a fetch made from a REST service.  If the return fulfilled a request to get records 20 through 39, for example:</caption>
   * <pre class="prettyprint"><code>
   * {
   *   start: 20,
   *   count: 20,
   *   models: [modelObjects]
   * }
   * </code></pre>
   */

  /**
   * @private
   */
  Collection.prototype._setRangeLocalInternal = function (start, count, options) {
    if (this.IsVirtual()) {
      // make sure we reconcile the length to what we think the totalresults are--if there have been any non
      // fetched changes in length we don't want to be placing things wrong
      this._resetModelsToFullLength(this.totalResults);
    }
    var actual = this._getLocalRange(start, count);
    var self = this;
    if (this._checkActual(start, count, actual)) {
      return new Promise(function (resolve) {
        resolve(actual);
      });
    }

    // Manage the LRU - set model limit at least as high as the count we're trying to fetch
    var modelLimit = this._getModelLimit();
    if (modelLimit > -1 && modelLimit < count) {
      this.modelLimit = count;
    }
    return new Promise(function (resolve, reject) {
      self._setRangeLocalFetch(
        start,
        count,
        -1,
        { start: start, count: count },
        resolve,
        reject,
        true,
        options
      );
    });
  };

  /**
   * @private
   */
  Collection.prototype._setRangeLocalFetch = function (
    start,
    count,
    placement,
    original,
    resolve,
    reject,
    fill,
    options
  ) {
    var self = this;
    var localStart = start;
    var resp = function () {
      var actual = self._getLocalRange(original.start, original.count);
      if (fill && self._hasTotalResults() && actual.count < original.count) {
        // The range wasn't fulfilled: try again
        var newPlacement = actual.start + actual.count;
        // Try the next block...don't repeat the request
        var newStart = localStart + (self.lastFetchCount ? self.lastFetchCount : count);
        if (newStart < self.totalResults) {
          self._setRangeLocalFetch(
            newStart,
            count,
            newPlacement,
            original,
            resolve,
            reject,
            fill,
            options
          );
        } else {
          // Can't go any further
          resolve(actual);
        }
      } else {
        resolve(actual);
      }
    };

    // Go fetch
    var limit = localStart + count;
    // Get the greater of the limit-localStart or fetchSize
    if (this[Collection._FETCH_SIZE_PROP] && this[Collection._FETCH_SIZE_PROP] > count) {
      limit = this[Collection._FETCH_SIZE_PROP] + localStart;
    }

    // Now, to optimize, move localStart up to the first undefined model in the sequence
    var opts = null;
    if (this.IsVirtual()) {
      var newStart = this._getFirstMissingModel(localStart, limit);
      if (newStart > localStart) {
        localStart = newStart;
        // Recheck the limit
        limit = localStart + count;
        // Get the greater of the limit-localStart or fetchSize
        if (this[Collection._FETCH_SIZE_PROP] && this[Collection._FETCH_SIZE_PROP] > count) {
          limit = this[Collection._FETCH_SIZE_PROP] + localStart;
        }
      }
      opts = { context: this, startIndex: localStart, fetchSize: limit - localStart };
    } else {
      opts = { context: this };
    }
    opts.error = function (collection, error, optarg, xhr, status) {
      // Handle potential errors
      reject(Collection._createRejectionError(xhr, status, error, self, null, false));
    };
    opts.success = function () {
      resp();
    };
    if (options && options.silent) {
      opts.silent = options.silent;
    }

    try {
      this._fetchInternal(opts, placement, placement > -1);
    } catch (e) {
      // This is OK if it's a URLError: local collection with no means of fetching: just resolve
      if (e instanceof URLError) {
        var actual = self._getLocalRange(localStart, count);
        resolve(actual);
      }
    }
  };

  /**
   * @private
   */
  Collection._createRejectionError = function (xhr, status, error, collection, options, fireError) {
    var silent = false;
    if (options && options.silent) {
      silent = options.silent;
    }
    // To avoid duplication in many cases...
    if (fireError) {
      Model._triggerError(collection, silent, options, status, error, xhr);
    }
    var err = new Error(status);
    err.xhr = xhr;
    err.error = error;
    err.collection = collection;
    err.status = status;
    return err;
  };

  /**
   * @private
   */
  Collection.prototype._getMaxLength = function (start, count) {
    var len = this._getModelsLength();
    if (len === 0) {
      // This is an exception: could be uninitialized
      return start + count;
    }
    return start + count > len ? len : start + count;
  };

  /**
   * Determine if every element of the given range is filled in locally
   *
   * @param {number} start starting index to check
   * @param {number} count number of elements to check
   * @return {boolean} true if all elements are local, false otherwise
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.isRangeLocal = function (start, count) {
    var localRange = this._getLocalRange(start, count);
    if (this._getModelsLength() === 0) {
      // If we have no models length, then range cannot be thought of as local unless the count
      // is zero--edge case
      return count === 0;
    }
    return (
      start === localRange.start &&
      (count === localRange.count || start + count > this._getModelsLength())
    );
  };

  /**
   * @private
   */
  Collection.prototype._getModelArray = function (start, count) {
    var retArr = [];
    var models = this._getModels();
    var end = start + count;
    for (var i = start; i < end; i++) {
      retArr.push(models[i]);
    }
    return retArr;
  };

  /**
   * For a given range of models, return the actual range which are local within that set.
   * @private
   */
  Collection.prototype._getLocalRange = function (start, count) {
    // Not virtual, local if there are any models
    if (!this.IsVirtual()) {
      if (this._getModelsLength() > 0) {
        if (start + count > this._getModelsLength()) {
          // Over the boundary
          var c = this._getModelsLength() - start;
          return { start: start, count: c, models: this._getModelArray(start, c) };
        }

        return { start: start, count: count, models: this._getModelArray(start, count) };
      }
      return { start: start, count: 0, models: [] };
    }
    var limit = this._getMaxLength(start, count);
    // Adjust for no totalResults
    if (!this._hasTotalResults() && limit < start + count) {
      // We don't know if it's local or not
      return {
        start: start,
        count: limit - start,
        models: this._getModelArray(start, limit - start)
      };
    }
    if (limit === 0) {
      // There nothing here
      return { start: start, count: 0, models: [] };
    }
    var firstMissingModel = this._getFirstMissingModel(start, limit);
    if (firstMissingModel > -1) {
      return {
        start: start,
        count: firstMissingModel - start,
        models: this._getModelArray(start, firstMissingModel - start)
      };
    }
    // Make sure start doesn't overrun the end!
    var localCount = count;
    if (start > limit) {
      localCount = 0;
    } else if (start + localCount > limit) {
      // Make sure that start+count doesn't overrun the end
      localCount = limit - start;
    }
    return { start: start, count: localCount, models: this._getModelArray(start, localCount) };
  };

  /**
   * Return the first model between start and limit that's undefined
   * @private
   */
  Collection.prototype._getFirstMissingModel = function (start, limit) {
    for (var i = start; i < limit; i++) {
      if (this._getModel(i) === undefined) {
        return i;
      }
    }
    return -1;
  };

  /**
   * Loads the Collection object from the data service URL. Performs a data "read."<p>
   * Events:<p>
   * <ul>
   * <b>request</b>: fired when the request to fetch is going to the server, passing the collection, xhr object, and
   * options<br>
   * <b>sync</b>: fired when the collection is fetched from the data service, passing the collection and the raw
   * response<br>
   * <b>error</b>: fired if there is an error during the fetch, passing the collection, xhr object, options<br>
   * </ul>
   * <p>
   * @param {Object=} options Options to control fetch<p>
   *                  <b>success</b>: a user callback called when the fetch has completed successfully. This makes
   *                  the fetch an asynchronous process. The callback is called passing the Collection object, raw
   *                  response, and the fetch options argument.<br>
   *                  <b>error</b>: a user callback function called if the fetch fails. The callback is called
   *                  passing the Collection, error, fetch options, xhr (if any) and status arguments (if any).<br>
   *                  <b>add</b>: if set, new records retrieved from the data service will be added to those models
   *                  already in the collection. If not set, the records retrieved will be passed to the reset()
   *                  method, effectively replacing the previous contents of the collection with the new data.
   *                  Not supported for virtual/paging cases.<br>
   *                  <b>set</b>: if true, fetch will try to use the set function to try and merge the fetched models
   *                  with those already in the collection, on the client.  The default behavior is to reset the
   *                  collection before adding back in the fetched models.  This default is the reverse of
   *                  Backbone's current default.<br>
   *                  <b>startIndex</b>: numeric index with which to start fetching Models from the server.  The
   *                  page setting controls the number of Models to be fetched.  startID takes precedence over
   *                  startIndex if both are specified.  If both are specified and startID isn't supported then
   *                  startIndex will be used instead.<br>
   *                  <b>startID</b>: unique ID of the Model to start fetching from the server.  The page setting
   *                  controls the number of Models to be fetched.  Note if this is not supported by the server
   *                  then startID will be ignored.<br>
   *                  <b>since</b>: fetch records having a timestamp since the given UTC time<br>
   *                  <b>until</b>: fetch records having a timestamp up to the given UTC time<br>
   *                  <b>fetchSize</b>: use specified page size instead of collection's setting<br>
   * @return {Object} xhr ajax object, by default.  If [sync]{@link Collection#sync} has been replaced, this
   * would be the value returned by the custom implementation.
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (collection: Collection, response: any, options: object)=> void,
   *                                                  error?: (collection: Collection, error:any, options: object, xhr?: any, status?: any)=> void,
   *                                                  add?: boolean, set?: boolean, startIndex?: number, startID?: any, since?: any,
   *                                                  until?: any, fetchSize?: number, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.fetch = function (options) {
    var xhr = this._fetchInternal(options, -1, false);
    this._addPromise(function () {
      return Promise.resolve(xhr);
    });
    return xhr;
  };

  /**
   * fillIn is used to indicate that this fetch is just the result of a get() or part of an add(), etc., when virtual
   * @private
   */
  Collection.prototype._fetchInternal = function (options, placement, fillIn) {
    function doReset(collection, opt, fill, totalResults) {
      if (!collection.IsVirtual()) {
        // If we're not doing a "fetch add", delete all the current models
        if (!opt.add && !opt.useset) {
          // Reset with internal model
          collection.reset(null, { silent: true });
        }
      } else if (!fill) {
        // If we're not infilling based on an at, get, etc., delete all the current local models
        collection._resetModelsToFullLength(totalResults);
      }
    }

    var opt = options || {};
    var success = opt.success;
    var self;
    var errFunc = opt.error;

    if (opt.set) {
      opt.useset = !!opt.set;
    }

    // Set up the parsing option
    if (opt.parse === undefined) {
      opt.parse = true;
    }
    self = this;

    opt.error = function (xhr, status, error) {
      Model._triggerError(self, false, options, status, error, xhr);
      if (errFunc) {
        errFunc.call(Model.GetContext(options, self), self, error, options, xhr, status);
      }
    };

    opt.success = function (response) {
      // Run the entire returned dataset through the collection's parser (either default no-op or user specified)
      var data;
      try {
        data = self.parse(response, options);
      } catch (e) {
        Collection._reportError(self, e, opt.error, options);
        return;
      }

      // Pull any virtualization properties out of the response
      var resetTotalResults;
      if (!self._setPagingReturnValues(response, options, data, fillIn)) {
        // totalResults was not calculated: tell the reset
        resetTotalResults = self.totalResults;
      }

      var dataList = null;

      var manageLRU = false;
      var locPlace = placement;
      if (!opt.add && !self.model) {
        // We're not doing a "fetch add" and we don't have a model set on the collection
        if (!fillIn) {
          if (self.IsVirtual()) {
            // Virtual case only
            // Clean out the collection
            doReset(self, opt, fillIn, resetTotalResults);

            // Check for passed in offset
            if (placement === -1) {
              manageLRU = true;
              locPlace = self._getOffset();
            }
            // Put the new data in
            dataList = self._putDataIntoCollection(data, locPlace, manageLRU);
          } else if (opt.useset) {
            // New backbone option to not reset
            self._setInternal(data, false, opt, false);
          } else {
            // Replace the data in the collection with a new set (non virtual)
            self.reset(data, { silent: true });
          }
        }
      } else {
        // We have a model and/or we're doing a "fetch add"
        // Clean out the old models if we're not "adding" or infilling for virtual
        doReset(self, opt, fillIn, resetTotalResults);

        // Parse each returned model (if appropriate), and put it into the collection, either from the
        // zeroth offset if non-virtual or using the appropriate offset if virtual
        try {
          // Check for passed in offset
          if (placement === -1) {
            manageLRU = true;
            locPlace = self._getOffset();
          }
          dataList = self._fillInCollectionWithParsedData(data, locPlace, manageLRU, opt);
        } catch (e) {
          Collection._reportError(self, e, opt.error, options);
          return;
        }
      }
      if (self.IsVirtual()) {
        // Take in the number of records actually fetched
        if (dataList) {
          self.lastFetchCount = dataList.length;
        }
      }

      // Fire the sync event
      var silent = !!opt.silent;
      self.TriggerInternal(silent, Events.EventType.SYNC, self, response, opt);
      // Call the caller's success callback, if specified
      if (success) {
        success.call(Model.GetContext(options, self), self, response, opt);
      }
    };
    // Make the actual fetch call using ajax, etc.
    return this._fetchCall(opt);
  };

  /**
   * Puts server data into an empty virtual collection using a "silent add"
   * @private
   */
  Collection.prototype._putDataIntoCollection = function (data, placement, manageLRU) {
    var dataList;

    if (data) {
      dataList = data instanceof Array ? data : [data];

      var addOpt = {};
      // Only manage the LRU if we're not trying to achieve a range
      if (manageLRU) {
        this._manageLRU(dataList.length);
      }
      var insertPos = placement;
      var virtual = this.IsVirtual();
      var prevItem = null;
      for (var i = 0; i < dataList.length; i += 1) {
        if (virtual) {
          addOpt = { at: insertPos };
          prevItem = this._atInternal(insertPos, null, true, false);
        }
        // Don't fire add events
        addOpt.silent = true;
        this._addInternal(dataList[i], addOpt, true, false);
        // If virtual, make sure the item was really added where we thought--in other words, what's there now
        // shouldn't match what was there otherwise could be duplicate id and don't increment counter
        if (this._atInternal(insertPos, null, true, false) !== prevItem) {
          insertPos += 1;
        }
      }
    }
    return dataList;
  };

  /**
   * Parse each model returned, if appropriate, and push them into the (empty) collection with appropriate offsets
   * if virtual
   * @private
   */
  Collection.prototype._fillInCollectionWithParsedData = function (
    data,
    placement,
    manageLRU,
    options
  ) {
    var opt = options || {};
    var parse = opt.parse;
    var modelInstance = Collection._createModel(this);
    var dataList = null;

    if (data) {
      dataList = data instanceof Array ? data : [data];

      var addOpt = {};
      var parsedModel;

      // Only manage the LRU if we're not trying to achieve a range
      if (manageLRU) {
        this._manageLRU(dataList.length);
      }
      var virtual = this.IsVirtual();
      var i;
      if (opt.useset && !virtual) {
        // New backbone option
        for (i = 0; i < dataList.length; i += 1) {
          if (modelInstance && parse) {
            parsedModel = modelInstance.parse(dataList[i]);
          } else {
            parsedModel = dataList[i];
          }

          dataList[i] = parsedModel;
        }
        this._setInternal(dataList, false, opt, false);
      } else {
        var prevItem = null;
        var insertPos = placement;
        for (i = 0; i < dataList.length; i += 1) {
          if (modelInstance && parse) {
            parsedModel = modelInstance.parse(dataList[i]);
          } else {
            parsedModel = dataList[i];
          }

          if (virtual) {
            addOpt = { at: insertPos };
            prevItem = this._atInternal(insertPos, addOpt, true, false);
          }
          // Don't fire add events
          addOpt.silent = true;
          this._addInternal(parsedModel, addOpt, true, false);
          // If virtual, make sure the item was really added where we thought--in other words, what's there
          // now shouldn't match what was there otherwise could be duplicate id and don't increment counter
          if (this._atInternal(insertPos, null, true, false) !== prevItem) {
            insertPos += 1;
          }
        }
      }
    }
    return dataList;
  };

  /**
   * @private
   */
  Collection._reportError = function (collection, e, errorFunc, options) {
    Logger.error(e.toString());
    if (errorFunc) {
      errorFunc.call(Model.GetContext(options, collection), collection, e, options);
    }
  };

  /**
   * Used in virtualization to conduct server-based searches: returns list of fetched models via a promise but does
   * not add them to the collection model list
   * @private
   */
  Collection.prototype._fetchOnly = function (options) {
    var opt = options || {};
    var success = opt.success;
    var parsedModel;
    var self;

    if (opt.parse === undefined) {
      opt.parse = true;
    }
    self = this;

    opt.success = function (response) {
      var i;
      var modelInstance;
      var dataList = null;
      var fetchedModels = [];

      var data;
      try {
        data = self.parse(response, options);
      } catch (e) {
        Collection._reportError(self, e, opt.error, options);
        return;
      }

      if (!opt.add && !self.model) {
        dataList = data instanceof Array ? data : [data];
      } else {
        modelInstance = Collection._createModel(self);

        if (data) {
          dataList = data instanceof Array ? data : [data];

          for (i = 0; i < dataList.length; i += 1) {
            if (modelInstance && opt.parse) {
              try {
                parsedModel = modelInstance.parse(dataList[i]);
              } catch (e) {
                Collection._reportError(self, e, opt.error, options);
                return;
              }
            } else {
              parsedModel = dataList[i];
            }
            fetchedModels.push(self._newModel(parsedModel));
          }
        }
      }

      self.TriggerInternal(false, Events.EventType.SYNC, self, response, opt);
      if (success) {
        success.call(Model.GetContext(options, self), self, fetchedModels, opt);
      }
    };
    return this._fetchCall(opt);
  };

  /**
   * @private
   */
  Collection.prototype._fetchCall = function (opt) {
    try {
      return Model._internalSync('read', this, opt);
    } catch (e) {
      // Some kind of error: trigger an error event
      Model._triggerError(this, false, opt, null, e, null);
      throw e;
    }
  };

  /**
   * @private
   */
  Collection.prototype._resetModelsToFullLength = function (totalResults) {
    if (totalResults !== undefined && this._getModelsLength() !== totalResults) {
      // Make sure to set up the array if the length changes (i.e., from 0 to totalResults--need to preallocate)
      this._setModels(new Array(totalResults), true);
      this._resetLRU();
      this._setLength();
      return true;
    }
    return false;
  };

  /**
   * @private
   */
  Collection.prototype._getFetchSize = function (options) {
    var opt = options || {};
    return opt[Collection._FETCH_SIZE_PROP] || this[Collection._FETCH_SIZE_PROP];
  };

  /**
   * Are we doing virtualization/paging?
   * @protected
   */
  Collection.prototype.IsVirtual = function () {
    return this._getFetchSize(null) > -1;
  };

  /**
   * @private
   */
  Collection.prototype._getReturnProperty = function (
    customObj,
    response,
    property,
    optionValue,
    defaultValue
  ) {
    var value = parseInt(Collection._getProp(customObj, response, property), 10);
    if (value === undefined || value === null || isNaN(value)) {
      // use fetchsize
      return optionValue || defaultValue;
    }
    return value;
  };

  /**
   * @private
   */
  Collection.prototype._cleanTotalResults = function (totalResults) {
    // In case server (incorrectly) passes back a -1, treat it as undefined
    if (totalResults === -1) {
      return undefined;
    }
    return totalResults;
  };

  /**
   * Parse out some of the paging return values we might expect in a virtual response
   * Return true if totalResults was calculated on a rest call that has none
   * @private
   */
  Collection.prototype._setPagingReturnValues = function (response, options, data, fillIn) {
    var customObj = {};
    // See if there's a custom call out
    if (this.customPagingOptions) {
      customObj = this.customPagingOptions.call(this, response);
      if (!customObj) {
        customObj = {};
      }
    }
    // What limit was actually used to generate this response?
    var opt = options || {};
    this.lastFetchSize = this._getReturnProperty(
      customObj,
      response,
      'limit',
      opt.fetchSize,
      this.fetchSize
    );

    // What offset was actually used to generate this response?
    this.offset = this._getReturnProperty(customObj, response, 'offset', opt.startIndex, 0);

    // How many records actually came back?
    this.lastFetchCount = this._getReturnProperty(
      customObj,
      response,
      'count',
      this.lastFetchCount,
      this.lastFetchCount
    );

    // What is the total number of records possible for this collection?
    this.totalResults = this._cleanTotalResults(
      this._getReturnProperty(
        customObj,
        response,
        'totalResults',
        this.totalResults,
        this.totalResults
      )
    );

    // Is there more?
    this.hasMore = this._getHasMore(
      Collection._getProp(customObj, response, 'hasMore'),
      this.offset,
      this.lastFetchSize,
      this.totalResults
    );

    // Adjust total results to account for the case where the server tells us there's no more data, and
    // totalResults wasn't set by the server...but don't do it for simple gets/adds
    var retVal = false;
    if (!fillIn) {
      // We want to know if the server *actually* returned values for these things, not if they defaulted above
      var totalResultsReturned = this._cleanTotalResults(
        parseInt(Collection._getProp(customObj, response, 'totalResults'), 10)
      );
      var lastFetchCountReturned = parseInt(Collection._getProp(customObj, response, 'count'), 10);
      this.totalResults = this._adjustTotalResults(
        totalResultsReturned,
        this.hasMore,
        this.offset,
        lastFetchCountReturned,
        data && Array.isArray(data) ? data.length : 0
      );
      retVal =
        totalResultsReturned === undefined ||
        isNaN(totalResultsReturned) ||
        totalResultsReturned === null;
    }

    // Was fetchSize set?  If not, set it to limit
    if (
      !this.IsVirtual() &&
      this.totalResults &&
      this.totalResults !== this.lastFetchCount &&
      this.lastFetchSize
    ) {
      this.setFetchSize(this.lastFetchSize);
    }
    return retVal;
  };

  /**
   * @private
   */
  Collection.prototype._adjustTotalResults = function (
    totalResultsReturned,
    hasMore,
    offset,
    lastFetchCount,
    dataLength
  ) {
    // Fix for : if hasMore is false, and totalResults wasn't set by the server, we should set it to
    // the last thing fetched here.  There is no more.
    if (!hasMore) {
      // No more data, per server
      if (isNaN(totalResultsReturned)) {
        // TotalResults was not returned by the server here
        // If lastFetchCount was set, use that as the final total.  Otherwise, use the length of data passed
        // in...all + offset
        var count = !isNaN(lastFetchCount) ? lastFetchCount : dataLength;
        return count + offset;
      }
    }
    return this.totalResults;
  };

  /**
   * @private
   */
  Collection.prototype._getHasMore = function (hasMore, offset, lastFetchSize, totalResults) {
    if (Collection._defined(hasMore)) {
      return hasMore;
    }
    // Special case: return true if totalResults not defined
    if (totalResults === undefined || totalResults === null) {
      return true;
    }
    // Not there: figure it out.  It's true unless we're walking off the end
    return !(offset + lastFetchSize > totalResults);
  };

  /**
   * @private
   */
  Collection._getProp = function (custom, response, prop) {
    if (Object.prototype.hasOwnProperty.call(custom, prop)) {
      return custom[prop];
    }
    return response ? response[prop] : undefined;
  };

  /**
   * @private
   */
  Collection.prototype._getOffset = function () {
    return Collection._defined(this.offset) ? this.offset : 0;
  };

  /**
   * Creates a new model, saves it to the data service, and adds it on to the collection.<p>
   * Events:<p>
   * <ul>
   * <b>add</b>: fired when the model is added, passing the collection, model added, and options, if not silent<br>
   * <b>alladded</b>: fired after all models have been added, passing the collection, array of models added, and
   * options<br>
   * <b>request:</b>: fired when the request to save is going to the server<br>
   * <b>sync:</b>: fired when the model is saved to the data service, passing the model and the raw response<br>
   * </ul>
   * @param {Object=} attributes Set of attribute/value pairs with which to initialize the new model object, or a new
   * Model object
   * @param {Object=} options Options to control save (see [save]{@link Model#save}), or add (see
   * [add]{@link Collection#add}).  Plus:<p>
   *                          <b>deferred</b>: if true, return a promise as though this collection were virtual
   *                          whether it is or not<br>
   * @return {Model|boolean|Promise.<Model>} new model or false if validation failed.  If virtual, returns a promise that
   * resolves with the new model
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{silent?: boolean, at?: number, merge?: boolean, sort?: boolean, force?: boolean, deferred?: boolean,
   *               [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.create = function (attributes, options) {
    var self = this;
    var opt = options || {};
    var deferred = this._getDeferred(opt);

    function doSave(collection, newModel, validate, localOpt) {
      newModel.save(attributes instanceof Model ? null : attributes, localOpt);

      return newModel;
    }

    function doAdd(newModel, addOpts) {
      if (opt.wait) {
        // Don't do adding now
        if (self.IsVirtual() || deferred) {
          return self._addPromise(function () {
            return Promise.resolve(undefined);
          });
        }
        return null;
      }
      return self.add(newModel, addOpts);
    }

    // Save the user's context and callback, if any
    var newModel = this._newModel(attributes, true, opt, false);
    var callback = opt.success;
    var context = opt.context;
    var validate = opt.validate;
    opt.context = this;
    opt.success = function (model, resp, successOpts) {
      // Make sure we pass xhr
      if (successOpts.xhr) {
        opt.xhr = successOpts.xhr;
      }
      if (opt.wait) {
        // Trigger delayed add events
        self.add(newModel, opt);
      }
      if (callback) {
        callback.call(context != null ? context : self, model, resp, opt);
      }
    };

    // Did validation pass?
    if (newModel == null) {
      return false;
    }

    // Force a save in case user has set value of idAttribute on the new Model
    opt.forceNew = newModel.GetId() != null;

    var addOpts = Model._copyOptions(opt);

    newModel.SetCollection(this);
    if (deferred || this.IsVirtual()) {
      return new Promise(function (resolve) {
        addOpts.merge = true;
        addOpts.deferred = true;
        doAdd(newModel, addOpts).then(function () {
          opt.success = function (model, resp, successOpts) {
            // Make sure we pass xhr
            if (successOpts.xhr) {
              opt.xhr = successOpts.xhr;
            }
            if (opt.wait) {
              // Trigger delayed add event
              // Force the add if virtual because we know it was successfully saved: we
              // don't want to go back to the server to check
              if (self.IsVirtual()) {
                addOpts.force = true;
              }
              self.add(newModel, addOpts).then(function () {
                if (callback) {
                  callback.call(context != null ? context : self, model, resp, opt);
                }
                resolve(model);
              });
            } else {
              if (callback) {
                callback.call(context != null ? context : self, model, resp, opt);
              }
              resolve(model);
            }
          };
          var model = doSave(self, newModel, validate, opt);
          // make sure that success is called first if successful...promise resolved
          // second
          if (!model) {
            // Failed: make sure we resolve the promise.  Otherwise promise will
            // be resolved by success call, above
            resolve(model);
          }
        });
      });
    }

    addOpts.merge = true;
    doAdd(newModel, addOpts);
    return doSave(this, newModel, validate, opt);
  };

  /**
   * Return a list of all the values of attr found in the collection
   *
   * @param {string} attr attribute to return
   * @return {Array.<Object>} array of values of attr
   *
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.pluck = function (attr) {
    var arr = [];
    var i;

    this._throwErrIfVirtual('pluck');

    for (i = 0; i < this._getLength(); i += 1) {
      arr.push(this.at(i).get(attr));
    }
    return arr;
  };

  /**
   * Return an array of models that contain the given attribute/value pairs.  Note that this function, along with
   * findWhere, expects server-resolved filtering to return *all* models that meet the criteria, even in virtual
   * cases.  The fetchSize will be set to the value of totalResults for this call to indicate that all should
   * be returned.<br>
   * Events: for events, if virtual, see [fetch]{@link Collection#fetch}
   *
   * @param {Object|Array.<Object>} attrs attribute/value pairs to find.  The attribute/value pairs are ANDed together.  If
   *                             attrs is an array of attribute/value pairs, then these are ORed together
   *                             If the value is an object (or an array of objects, in which case the single
   *                             attribute must meet all of the value/comparator conditions), then if it has both
   *                             'value' and 'comparator' parameters these will be interpreted as
   *                             expressions needing custom commparisons.  The comparator value may either be a
   *                             string or a comparator callback function.  Strings are only valid where the
   *                             filtering is sent back to the data service (virtual collections).  In the case of
   *                             a comparator function, the function always takes the signature function(model,
   *                             attr, value), and for non-virtual collections, is called for each
   *                             Model in the collection with the associated attribute and value.  The function
   *                             should return true if the model meets the attribute/value condition, and false if
   *                             not.  For cases where the filtering is to be done on the server, the function will
   *                             be called once per attr/value pair with a null model, and the function should
   *                             return the string to pass as the comparison in the expression for the filtering
   *                             parameter in the URL sent back to the server.  Note that the array of value object
   *                             case is really only meaningful for server-evaluated filters where a complex
   *                             construction on a single attribute might be needed (e.g., x>v1 && x <=v2)
   *                             For example:<p>
   *                             {Dept:53,Name:'Smith'}<br>
   *                             will return an array of models that have a Dept=53 and a Name=Smith, or, for
   *                             server-filtered collections, a ?q=Dept=53+Name=Smith parameter will be sent with
   *                             the URL.<p>
   *                             [{Dept:53},{Dept:90}]<br>
   *                             will return all models that have a Dept of 53 or 90.  Or, ?q=Dept=53,Dept=90 will
   *                             be sent to the server.<p>
   *                             {Dept:{value:53,comparator:function(model, attr, value) { return model.get(attr) !==
   *                             value;}}}<br>
   *                             will return all models that do not have a Dept of 53.<p>
   *                             {Dept:{value:53,comparator:'<>'}}<br>
   *                             For server-evaluated filters, a parameter ?q=Dept<>53 will be sent with the URL.
   *                             This form is an error on locally-evaluated colleection filters<p>
   *                             {Dept:{value:53,comparator:function(model, attr, value) { return "<>";}}}<br>
   *                             expresses the same thing for server-evaluated filters<p>
   *                             {Dept:[{value:53,comparator:'<'},{value:90,comparator:'<'}]}<br>
   *                             For server-evaluated filters, a parameter ?q=Dept>53+Dept<93 will be sent to the
   *                             server<p>
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not<p>
   *
   * @return {Array.<Model>|Promise.<Array>} array of models.  If virtual or deferred, a promise that resolves with the returned
   * array from the server
   * @ojsignature  {target: "Type", value: "Promise<Array<Model>>|Array<Model>", for: "returns"}
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.where = function (attrs, options) {
    return this._handlePromise(this._whereInternal(attrs, options));
  };

  /**
   * @private
   */
  Collection.prototype._whereInternal = function (attrs, options) {
    var opt = options || {};
    var deferred = this._getDeferred(opt);
    var self = this;
    if (this.IsVirtual()) {
      return new Promise(function (resolve, reject) {
        var success = function (collection, fetchedModels) {
          resolve(fetchedModels);
        };
        // Send the attributes for a server-based filter; also indicate that we need *all* the attributes.
        // In the standard REST URL construction this is accomplished by leaving off fetchSize/start indices,
        // etc.
        var opts = {
          query: attrs,
          all: true,
          success: success,
          error: function (xhr, status, error) {
            reject(Collection._createRejectionError(xhr, status, error, self, opt, true));
          }
        };
        self._fetchOnly(opts);
      });
    }

    var arr = [];
    var i;
    var m;
    for (i = 0; i < this._getLength(); i += 1) {
      m = this.at(i);
      if (m.Contains(attrs)) {
        arr.push(m);
      }
    }
    if (deferred) {
      return new Promise(function (resolve) {
        resolve(arr);
      });
    }
    return arr;
  };

  /**
   * Return a collection of models that contain the given attribute/value pairs.
   * Note that this returns a non-virtual collection with all the models returned by the server,
   * even if the original collection is virtual.  Virtual collections doing filtering on the server should return
   * all models that meet
   * the critera.  See [where]{@link Collection#where}
   * See [where]{@link Collection#where} for complete documentation of events and parameters
   * @param {Object|Array.<Object>} attrs attribute/value pairs to find.  The attribute/value pairs are ANDed together.  If
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not<p>
   *
   * @return {Collection|Promise.<Collection>} A collection containing models with given attribute/value pairs.  If virtual or
   * deferred, a promise that resolves with the collection returned by the server
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.whereToCollection = function (attrs, options) {
    var opt = options || {};
    var deferred = this._getDeferred(opt);
    var self = this;
    if (this.IsVirtual() || deferred) {
      return self._addPromise(function () {
        return new Promise(function (resolve, reject) {
          return self._whereInternal(attrs, opt).then(
            function (models) {
              var collection = self._makeNewCollection(models);
              resolve(collection);
            },
            function (err) {
              reject(err);
            }
          );
        });
      });
    }

    var models = this._whereInternal(attrs, opt);
    var newCollection = this._makeNewCollection(models);
    newCollection[Collection._FETCH_SIZE_PROP] = -1;
    newCollection._setLength();
    return newCollection;
  };

  /**
   * @private
   */
  Collection.prototype._makeNewCollection = function (models) {
    var collection = this._cloneInternal(false);
    collection._setModels(models, false);
    collection._resetLRU();
    collection._setLength();
    return collection;
  };

  /**
   * @private
   */
  Collection.prototype._throwErrIfVirtual = function (func) {
    if (this.IsVirtual()) {
      throw new Error(func + ' not valid on a virtual Collection');
    }
  };

  /**
   * Return an array whose entries are determined by the results of calling the passed iterator function.  The
   * iterator will be called for each model in the collection
   *
   * @param {function(Model):Object} iterator function to determine the mapped value for each model
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Array.<Object>} array of values determined by the return value of calls made to iterator for each model
   *
   * @throws {Error} when called on a virtual Collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.map = function (iterator, context) {
    var retArr = [];
    var value;

    this._throwErrIfVirtual('map');

    this._getModels().forEach(function (model) {
      value = iterator.call(context || this, model);
      retArr.push(value);
    });
    return retArr;
  };

  /**
   * @desc Iterates over the models in the collection and calls the given iterator function
   *
   * @param {function(Model)} iterator function to call for each model
   * @param {Object=} context context with which to make the calls on iterator
   * @return {undefined}
   *
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.each = function (iterator, context) {
    this._throwErrIfVirtual('each');

    this._getModels().forEach(iterator, context);
  };

  /**
   * Return the length of the collection
   * @returns {number} length of the collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.size = function () {
    return this._getLength();
  };

  /**
   * Return the models sorted determined by the iterator function (or property, if a string value).  If a function,
   * the function should return the attribute by which to sort.
   *
   * @param {string|function(Model):string} iterator method called or property used to get the attribute to sort by.
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Array.<Model>} models sorted using iterator
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.sortBy = function (iterator, context) {
    var retArr = [];
    var self;

    this._throwErrIfVirtual('sortBy');

    this._getModels().forEach(function (model) {
      retArr.push(model);
    });
    self = this;

    retArr.sort(function (a, b) {
      var keyA;
      var keyB;

      if ($.isFunction(iterator)) {
        // "sortBy" comparator option
        keyA = iterator.call(context || self, a);
        keyB = iterator.call(context || self, b);
        return Collection._compareKeys(keyA, keyB, self.sortDirection);
      }
      // String option
      keyA = a.get(iterator);
      keyB = b.get(iterator);
      return Collection._compareKeys(keyA, keyB, self.sortDirection);
    });

    return retArr;
  };

  /**
   * @desc Return the collection with models grouped into sets determined by the iterator function (or property, if
   * a string value)
   *
   * @param {string|function(Model):Object} iterator method called or property (if a string) used to get the group key
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Object} models grouped into sets
   *
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.groupBy = function (iterator, context) {
    var retObj = {};
    var groupVal;

    this._throwErrIfVirtual('groupBy');

    this._getModels().forEach(function (model) {
      if ($.isFunction(iterator)) {
        groupVal = iterator.call(context || this, model);
      } else {
        groupVal = model.get(iterator);
      }
      if (retObj[groupVal] === undefined) {
        retObj[groupVal] = [];
      }
      retObj[groupVal].push(model);
    }, this);
    return retObj;
  };

  /**
   * @desc Return an object with models as values for their properties determined by the iterator function or
   * property string
   *
   * @param {string|function(Model)} iterator method called or property (if a string) used to get the index attribute
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Object} models listed as property values where the properties are the values returned by iterator or
   * the attribute value given by the iterator string
   *
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.indexBy = function (iterator, context) {
    var retObj = {};
    var index;

    this._throwErrIfVirtual('indexBy');

    this._getModels().forEach(function (model) {
      if ($.isFunction(iterator)) {
        index = iterator.call(context || this, model);
      } else {
        index = model.get(iterator);
      }
      retObj[index] = model;
    }, this);
    return retObj;
  };

  /**
   * Return the "minimum" model in the collection, as determined by calls to iterator.  The return value of
   * iterator (called with a model passed in) will be compared against the current minimum
   *
   * @param {function(Model):Object} iterator function to determine a model's value for checking for the minimum
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Model} "Minimum" model in the collection
   *
   * @throws {Error} when called on a virtual Collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.min = function (iterator, context) {
    var minModel = {};
    var minModelValue;
    var currValue;

    this._throwErrIfVirtual('min');

    if (this._getModelsLength() === 0) {
      return null;
    }
    // Get vals started
    minModel = this._getModel(0);
    minModelValue = iterator.call(context || this, this._getModel(0));

    this._getModels().forEach(function (model, i) {
      if (i >= 1) {
        currValue = iterator.call(context || this, model);
        if (currValue < minModelValue) {
          minModel = model;
          minModelValue = currValue;
        }
      }
    }, this);
    return minModel;
  };

  /**
   * Return the "maximum" model in the collection, as determined by calls to iterator.  The return value of
   * iterator (called with a model passed in) will be compared against the current maximum
   *
   * @param {function(Model):Object} iterator function to determine a model's value for checking for the maximum
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Model} "Maximum" model in the collection
   *
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.max = function (iterator, context) {
    var maxModel = {};
    var maxModelValue;
    var currValue;

    this._throwErrIfVirtual('max');
    if (this._getModelsLength() === 0) {
      return null;
    }
    // Get vals started
    maxModel = this._getModel(0);
    maxModelValue = iterator.call(context, this._getModel(0));

    this._getModels().forEach(function (model, i) {
      if (i >= 1) {
        currValue = iterator.call(context || this, model);
        if (currValue > maxModelValue) {
          maxModel = model;
          maxModelValue = currValue;
        }
      }
    }, this);
    return maxModel;
  };

  /**
   * @export
   * @desc Return an array of models that cause passed-in iterator to return true
   * @memberof Collection
   *
   * @param {function(Model)} iterator function to determine if a model should be included or not.  Should return
   * true or false
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {Array.<Model>} array of models that caused iterator to return true
   *
   * @throws {Error} when called on a virtual Collection
   * @since 1.0.0
   */
  Collection.prototype.filter = function (iterator, context) {
    var retArr = [];

    this._throwErrIfVirtual('filter');

    this._getModels().forEach(function (model) {
      if (iterator.call(context || this, model)) {
        retArr.push(model);
      }
    });
    return retArr;
  };

  /**
   * Return an array of models minus those passed in as arguments
   * @param {...Model} var_args models models to remove from the returned array
   * @returns {Array.<Model>} array of models from the collection minus those passed in to models
   *
   * @throws {Error} when called on a virtual Collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  // eslint-disable-next-line
  Collection.prototype.without = function (var_args) {
    var retArr = [];
    var j;
    var id;
    var cid;
    var add;

    this._throwErrIfVirtual('without');

    var model;
    // Test each model in the collection
    for (var i = 0; i < this._getModels().length; i++) {
      add = true;
      model = this._getModel(i);
      for (j = 0; j < arguments.length; j += 1) {
        // Get the cid
        cid = arguments[j].GetCid();
        // Get the id
        id = arguments[j].GetId();
        if (model.Match(id, cid)) {
          // If it's found, don't return it--we're "subtracting" those from the return value, which starts
          // as all models in the collection
          add = false;
          break;
        }
      }
      if (add) {
        retArr.push(model);
      }
    }
    return retArr;
  };

  /**
   * Return an array of models in the collection but not passed in the array arguments
   * @param {...Array.<Model>} var_args models arrays of models to check against the collection
   * @returns {Array.<Model>} array of models from the collection not passed in as arguments
   * @ojsignature {target: "Type", for: "var_args", value: "Model[][]"}
   *
   * @throws {Error} when called on a virtual Collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  // eslint-disable-next-line
  Collection.prototype.difference = function (var_args) {
    var retArr = [];
    var j;
    var k;
    var id;
    var cid;
    var add;

    this._throwErrIfVirtual('difference');

    var model;
    for (var i = 0; i < this._getModels().length; i++) {
      add = true;
      model = this._getModel(i);
      for (j = 0; j < arguments.length; j += 1) {
        // Each argument is assumed to be an array of Models
        for (k = 0; k < arguments[j].length; k++) {
          // Get the cid
          cid = arguments[j][k].GetCid();
          // Get the id
          id = arguments[j][k].GetId();
          if (model.Match(id, cid)) {
            add = false;
            break;
          }
        }
        if (!add) {
          // We found this model somewhere in the arguments--we're not going to add it so get out
          break;
        }
      }
      if (add) {
        retArr.push(model);
      }
    }
    return retArr;
  };

  /**
   * Determine if the collection has any models
   *
   * @returns {boolean} true if collection is empty
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.isEmpty = function () {
    return this._getLength() === 0;
  };

  /**
   * @export
   * @desc Return true if any of the models in the collection pass the test made by calling the iterator function
   * parameter
   * @memberof Collection
   *
   * @param {function(Object)} iterator function called with each model to determine if it "passes".  The function
   * should return true or false.
   * @param {Object=} context context with which to make the calls on iterator
   * @returns {boolean} true if any of the models cause the iterator function to return true
   *
   * @throws {Error} when called on a virtual collection
   * @since 1.0.0
   */
  Collection.prototype.any = function (iterator, context) {
    this._throwErrIfVirtual('any');

    var model;
    for (var i = 0; i < this._getModelsLength(); i += 1) {
      model = this._getModel(i);
      if (iterator.call(context || this, model)) {
        return true;
      }
    }
    return false;
  };

  /**
   * @export
   * @desc A version of where that only returns the first element found<br>
   * Events: for events, if virtual, see [fetch]{@link Collection#fetch}<br>
   * @memberof Collection
   * @param {Object|Array.<Object>} attrs attribute/value pairs to find.
   * See [where]{@link Collection#where} for more details and examples.
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not<p>
   *
   * @returns {Model|Promise.<Model>} first model found with the attribute/value pairs.  If virtual or deferred, a promise
   * that resolves with the returned model from the server
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{deferred?: boolean, [propName: string]: any}", for: "options"}
   */
  Collection.prototype.findWhere = function (attrs, options) {
    var deferred = this._getDeferred(options);
    var self = this;
    if (this.IsVirtual() || deferred) {
      return this._addPromise(function () {
        return new Promise(function (resolve) {
          self._whereInternal(attrs, options).then(function (modelList) {
            if (modelList && modelList.length > 0) {
              resolve(modelList[0]);
            }
            resolve(null);
          });
        });
      });
    }

    var arr = this._whereInternal(attrs, options);
    if (arr.length > 0) {
      return arr[0];
    }
    return null;
  };

  /**
   * Return a shallow copy of the models from start to end (if specified), in an array<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   *
   * @param {number} start model to start the return array with
   * @param {number=} end model to end the return array with, if specified (not inclusive).  If not, returns to the
   * end of the collection
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not
   * @return {Array.<Model>|Promise} array of model objects from start to end, or a promise that resolves specifying the
   * returned array when done
   * @memberof Collection
   * @ojsignature  {target: "Type", value: "Promise<Array<Model>>|Array<Model>", for: "returns"}
   * @since 1.0.0
   * @export
   */
  Collection.prototype.slice = function (start, end, options) {
    var deferred = this._getDeferred(options);
    var ret = [];
    var i;
    var localEnd = end;
    if (localEnd === undefined) {
      if (this.IsVirtual() && !this._hasTotalResults()) {
        // We can't set the end: throw an error
        throw new Error('End must be set for virtual collections with no totalResults');
      }
      localEnd = this._getModelsLength();
    }

    if (deferred || this.IsVirtual()) {
      var self = this;
      return this._addPromise(function () {
        // Loop using deferred
        return self.IterativeAt(start, localEnd);
      });
    }

    for (i = start; i < localEnd; i += 1) {
      ret.push(this._getModel(i));
    }
    return ret;
  };

  /**
   * Update the collection with a model or models.  Depending on the options, new models will be added, existing
   * models will be merged, and unspecified models will be removed.
   * The model cid is used to determine whether a given model exists or not.<br>
   * May fire events as specified by [add]{@link Collection#add} or [remove]{@link Collection#remove},
   * depending on the options.
   *
   * @param {Object} models an array of or single model with which to update the collection.  If models contains
   * actual Model objects, then any custom 'parse' function set on the collection needs to take that into
   * account and be prepared to handle an array of Model.
   * @param {Object=} options <b>add</b>:false stops the addition of new models<br>
   *                          <b>remove</b>: false stops the removal of missing models<br>
   *                          <b>merge</b>: false prevents the merging of existing models<br>
   *                          <b>silent</b>: true prevents notifications on adds, removes, etc.<br>
   *                          <b>deferred</b>: if true, return a promise as though this collection were virtual
   *                          whether it is or not
   *
   * @returns {Promise|null} if deferred or virtual, return a promise that resolves when the set has completed
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{add?: boolean, remove?: boolean, merge?: boolean, silent?: boolean, deferred?: boolean,
   *               [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.set = function (models, options) {
    var deferred = this._getDeferred(options);
    return this._setInternal(models, true, options, deferred || this.IsVirtual());
  };

  Collection._removeAfterSet = function (collection, models, remove, foundModels, options) {
    // Now remove models that weren't found
    // get an array of all models

    // Can't avoid looping over everything because we *have* to clean up even unfetched models, in order to fire
    // events, etc.
    if (remove) {
      for (var i = models.length - 1; i >= 0; i -= 1) {
        if (foundModels.indexOf(i) === -1) {
          collection._removeInternal(models[i], i, options);
        }
      }
    }
  };

  /**
   * Swap two models, and indicate if anything was actually swapped
   * @private
   */
  Collection.prototype._swapModels = function (oldIndex, newIndex, remove, add) {
    if (this._hasComparator() || !remove || !add) {
      return { index: oldIndex, swapped: false };
    }
    // Make sure in range
    var len = this._getModelsLength();
    if (oldIndex >= len || newIndex >= len) {
      return { index: oldIndex, swapped: false };
    }
    // Swap
    var oldModel = this._getModel(oldIndex);
    var newModel = this._getModel(newIndex);
    this._setModel(oldIndex, newModel);
    newModel.SetIndex(oldIndex);
    this._setModel(newIndex, oldModel);
    oldModel.SetIndex(newIndex);

    return { index: newIndex, swapped: newIndex !== oldIndex };
  };

  /**
   * @private
   */
  Collection.prototype._setInternal = function (models, parse, opt, deferred) {
    // Determine if any of the options are set
    var options = opt || {};
    var add = options.add === undefined ? true : options.add;
    var remove = options.remove === undefined ? true : options.remove;
    var merge = options.merge === undefined ? true : options.merge;
    var foundModels = [];
    var currModel = null;
    var i;
    var modelList;

    var mods = parse ? this.parse(models) : models;

    modelList = Array.isArray(mods) ? mods : [mods];

    if (deferred) {
      var self = this;
      return this._addPromise(function () {
        return self._deferredSet(modelList, self._getModels(), options, remove, add, merge, parse);
      });
    }

    // Go through the passed in models and determine what to do
    var swapped = false;
    for (i = 0; i < modelList.length; i += 1) {
      currModel = this._updateModel(
        this._newModel(modelList[i], parse, options, true),
        add,
        merge,
        deferred
      );
      if (currModel !== -1) {
        // And swap it into the position as passed in, if no comparator and we're removing, so that the slots
        // are exact
        var obj = this._swapModels(currModel, i, remove, add);
        var newLoc = obj.index;
        if (obj.swapped) {
          swapped = true;
        }
        // Save its new location as found
        if (foundModels.indexOf(newLoc) === -1) {
          foundModels.push(newLoc);
        }
      }
    }
    if (swapped) {
      var eventOpts = options.add ? { add: true } : null;
      this.TriggerInternal(options.silent, Events.EventType.SORT, this, eventOpts, null);
    }

    Collection._removeAfterSet(this, this._getModels(), remove, foundModels, options);
    return null;
  };

  /**
   * Handle the updates/removes on virtual collections
   * @private
   */
  Collection.prototype._deferredSet = function (
    modelList,
    modelsCopy,
    options,
    remove,
    add,
    merge,
    parse
  ) {
    var foundModels = [];
    var i;

    // Go through the passed in models and determine what to do
    var self = this;
    return new Promise(function (allResolve, allReject) {
      var doTask = function (index) {
        return new Promise(function (resolve, reject) {
          self
            ._updateModel(self._newModel(modelList[index], parse, options, true), add, merge, true)
            .then(function (currModel) {
              if (currModel !== -1) {
                foundModels.push(currModel);
              }
              resolve(index + 1);
            }, reject);
        });
      };

      var currentStep = Promise.resolve(0);

      for (i = 0; i < modelList.length; i += 1) {
        currentStep = currentStep.then(doTask);
      }
      currentStep.then(function () {
        Collection._removeAfterSet(self, modelsCopy, remove, foundModels, options);
        allResolve(undefined);
      }, allReject);
    });
  };

  /**
   * Return the index of the given model after updating it, if it was found.  Otherwise it is added and a -1 is
   * returned
   * @private
   */
  Collection.prototype._updateModel = function (model, add, merge, deferred) {
    function update(collection, found, def) {
      var index = found ? found.index : -1;
      var foundModel = found ? found.m : null;

      var opt = {};
      if (foundModel) {
        if (merge) {
          // Do merge if not overridden
          opt = { merge: merge };
          if (def) {
            return new Promise(function (resolve) {
              collection._addInternal(model, opt, false, true).then(function () {
                resolve(index);
              });
            });
          }
          collection.add(model, opt);
        }
      } else if (add) {
        if (def) {
          return new Promise(function (resolve) {
            collection._addInternal(model, opt, false, true).then(function () {
              resolve(collection._getLength() - 1);
            });
          });
        }
        collection.add(model);
        index = collection._getLength() - 1;
      }
      return index;
    }

    // Check to see if this model is in the collection
    if (deferred || this.IsVirtual()) {
      var self = this;

      return new Promise(function (resolve) {
        self._getInternal(model, { silent: true }, deferred).then(function (found) {
          update(self, found, true).then(function (index) {
            resolve(index);
          });
        });
      });
    }

    var found = this._getInternal(model);
    return update(this, found, false);
  };

  /**
   * Return a copy of the Collection's list of current attribute/value pairs.
   *
   * @return {Array.<Object>} an array containing all the Collection's current sets of attribute/value pairs.
   * @throws {Error} when called on a virtual collection
   *
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.toJSON = function () {
    var retArr = [];

    this._throwErrIfVirtual('toJSON');

    this._getModels().forEach(function (model) {
      retArr.push(model.toJSON());
    });
    return retArr;
  };

  /**
   * Return the first model object in the collection, or an array of the first n model objects from the collection.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   * @param {number=} n Number of model objects to include in the array, starting with the first.
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual whether it is or not
   * @return {Array.<Model>|null|Promise} An array of n model objects found in the collection, starting with the first. If n
   * is not included, returns all of the collection's models as an array.  If deferred or virtual, returns a promise
   * that resolves with the array or model
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.first = function (n, options) {
    var deferred = this._getDeferred(options);
    var elementCount = this._getLength();
    var retArray = [];
    var i;
    var self = this;

    var num = n;
    if (num) {
      elementCount = num;
    } else {
      num = 1;
    }

    var virtual = this.IsVirtual() || deferred;

    if (num === 1) {
      if (virtual) {
        return this._addPromise(function () {
          return self._deferredAt(0, null);
        });
      }

      if (this._getModelsLength() > 0) {
        return this._getModel(0);
      }
      return null;
    }

    if (elementCount > this._getModelsLength()) {
      if (this.IsVirtual() && !this._hasTotalResults()) {
        // Virtual, no total results: don't restrict elementCount
      } else {
        elementCount = this._getModelsLength();
      }
    }

    if (virtual) {
      return this._addPromise(function () {
        return self.IterativeAt(0, elementCount);
      });
    }

    for (i = 0; i < elementCount; i += 1) {
      retArray.push(this._getModel(i));
    }
    return retArray;
  };

  /**
   * Return the array index location of the given model object.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   * @param {Model|string} model Model object (or Model id) to locate
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not
   * @return {number|Promise.<number>} The index of the given model object, or a promise that will resolve with the index
   * when complete.  If the object is not found, returns -1.
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.indexOf = function (model, options) {
    var location;
    var deferred = this._getDeferred(options);

    if (this.IsVirtual() || deferred) {
      var self = this;
      return this._addPromise(function () {
        return self._getInternal(model, null, true).then(function (loc) {
          return loc.index;
        });
      });
    }
    location = this._getInternal(model);

    return location.index;
  };

  /**
   * Determine if the given model object is present in the collection.<br>
   * For events that may be fired if the collection is virtual, see [fetch]{@link Collection#fetch}.<br>
   * @param {Object} model Model object (or Model id) to locate
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not
   * @return {boolean|Promise.<boolean>} true if the model is contained in the collection, false if not. If deferred, a
   * promise that will resolve with true or false when complete.
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.contains = function (model, options) {
    var location;
    var deferred = this._getDeferred(options);

    if (this.IsVirtual() || deferred) {
      var self = this;
      return this._addPromise(function () {
        return self._getInternal(model, null, true).then(function (loc) {
          return loc.index > -1;
        });
      });
    }
    location = this._getInternal(model);

    return location.index > -1;
  };

  /**
   * An alias for [contains]{@link Collection#contains}
   * @param {Object} model Model object (or Model id) to locate
   * @param {Object=} options
   * @property {boolean=} deferred if true, return a promise as though this collection were virtual
   * whether it is or not
   * @return {boolean|Promise.<boolean>} true if the model is contained in the collection, false if not. If deferred, a
   * promise that will resolve with true or false when complete.
   * @kind function
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.include = Collection.prototype.contains;

  // Only look on models already fetched
  Collection.prototype._localIndexOf = function (model) {
    var location = this._getLocalInternal(model);

    return location !== undefined ? location.index : -1;
  };

  /**
   * Remove the last model from the collection and return it<br>
   * For events that may be fired if the collection is virtual, see [remove]{@link Collection#remove}.<br>
   * @param {Object=} options Options for the method:<p>
   * <b>silent</b>: if set, do not fire a remove event <br>
   * <b>deferred</b>: if true, return a promise as though this collection were virtual whether it is or not<br>
   * @return {Model|Promise.<Model>} the model that was removed, or a promise that will resolve with the model that was
   * removed when complete
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{silent?: boolean, deferred?: boolean, [propName: string]: any}", for: "options"}
   * @export
   */
  Collection.prototype.pop = function (options) {
    var deferred = this._getDeferred(options);
    if (this.IsVirtual() || deferred) {
      var self = this;
      return this._atInternal(this._getLength() - 1, options, false, true).then(function (model) {
        self.remove(model, options);
        return model;
      });
    }

    var m = /** @type {Model} */ (this.at(this._getLength() - 1));
    this.remove(m, options);
    return m;
  };

  /**
   * Add the given model to the end of the Collection<br>
   * For events that may be fired if the collection is virtual, see [add]{@link Collection#add}.<br>
   * @param {Model|Object} m model to add to the end of the Collection (or a set of attribute value pairs)
   * @param {Object=} options same options as [add]{@link Collection#add}
   * @return {Promise.<Array>|undefined} if deferred or virtual, a promise that will be resolved when the function is done.  Otherwise
   * undefined
   * @memberof Collection
   * @ojsignature [{target: "Type", value:"{silent?: boolean, at?: number, merge?: boolean, sort?: boolean,
   *                                        force?: boolean, deferred?: boolean, [propName: string]: any}", for: "options"},
   *               {target: "Type", value: "Promise<Array<Model>>|undefined", for: "returns"}]
   * @since 1.0.0
   * @export
   */
  Collection.prototype.push = function (m, options) {
    var deferred = this._getDeferred(options);
    this._manageLRU(1);
    return this._handlePromise(this._addInternal(m, options, false, deferred));
  };

  /**
   * Returns the index of the last location of the given model.  Not supported in virtual cases.
   * @param {Model} model Model object to locate
   * @param {number=} fromIndex optionally start search at the given index
   * @return {number} The last index of the given model object.  If the object is not found, returns -1.
   * @throws {Error} when called on a virtual collection
   * @memberof Collection
   * @since 1.0.0
   * @export
   */
  Collection.prototype.lastIndexOf = function (model, fromIndex) {
    var i;
    var locIndex = fromIndex;

    this._throwErrIfVirtual('lastIndexOf');

    if (locIndex === undefined) {
      locIndex = 0;
    }

    for (i = this._getLength() - 1; i >= locIndex; i -= 1) {
      if (oj.Object.__innerEquals(model, this.at(i))) {
        return i;
      }
    }
    return -1;
  };

  /**
   * @private
   */
  Collection.prototype._getSortAttrs = function (sortStr) {
    if (sortStr === undefined) {
      return [];
    }
    return sortStr.split(',');
  };

  /**
   * Return a URL query string based on an array of or a single attr/value pair set
   * @private
   */
  Collection._getQueryString = function (q) {
    function expression(left, right, compare) {
      return left + compare + right;
    }

    function processQuery(query, input) {
      var exp;
      var str = input;
      Object.keys(query || {}).forEach(function (prop) {
        if (Object.prototype.hasOwnProperty.call(query, prop)) {
          var val = Array.isArray(query[prop]) ? query[prop] : [query[prop]];
          for (var j = 0; j < val.length; j++) {
            if (Model.IsComplexValue(val[j])) {
              var value = val[j].value;
              var compare = null;
              var comparator = val[j].comparator;
              if ($.isFunction(comparator)) {
                compare = comparator(null, prop, value);
              } else {
                compare = comparator;
              }
              exp = expression(prop, value, compare);
            } else {
              exp = expression(prop, query[prop], '=');
            }
            str += exp + '+';
          }
        }
      });
      // Remove trailing '+'
      str = str.substring(0, str.length - 1) + ',';
      return str;
    }

    var queries = Array.isArray(q) ? q : [q];
    var str = '';
    var i;
    for (i = 0; i < queries.length; i++) {
      str = processQuery(queries[i], str);
    }
    // Remove trailing ','
    if (str.substring(str.length - 1) === ',') {
      return str.substring(0, str.length - 1);
    }
    return str;
  };

  /**
   * @protected
   */
  Collection.prototype.ModifyOptionsForCustomURL = function (options) {
    var opt = {};
    Object.keys(options || {}).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(options, prop)) {
        opt[prop] = options[prop];
      }
    });
    var comparator = this.comparator;
    if (comparator && oj.StringUtils.isString(comparator)) {
      var attrs = this._getSortAttrs(comparator);
      for (var i = 0; i < attrs.length; i++) {
        if (i === 0) {
          opt.sort = attrs[i];
        } else {
          opt.sort += ',' + attrs[i];
        }
      }
      opt.sortDir = this._getSortDirStr();
    }
    // Put fetchSize on if appropriate, and not already set
    if (this.IsVirtual()) {
      opt[Collection._FETCH_SIZE_PROP] = this._getFetchSize(opt);
    }
    return opt;
  };

  /**
   * Determine if this collection is URL-based
   * @private
   */
  Collection.prototype.IsUrlBased = function (options) {
    var customURL = this.customURL;
    if ($.isFunction(customURL)) {
      return true;
    }
    var url = this.GetCollectionFetchUrl(options);
    return Collection._defined(url);
  };

  /**
   * Build a URL with parameters for the collection fetch
   * @protected
   */
  Collection.prototype.GetCollectionFetchUrl = function (opt) {
    var url = RestImpl.GetPropValue(this, 'url');

    // Adorn it with options, if any
    if (this.IsVirtual()) {
      var options = opt || {};
      var all = options.all;

      // Put in page size
      var limit = null;
      if (all) {
        var totalResults = this.totalResults;
        limit = totalResults || this._getFetchSize(options);
      } else {
        limit = this._getFetchSize(options);
      }
      if (url && url.indexOf('?') > -1) {
        // Already have a param coming in
        url += '&';
      } else {
        url += '?';
      }
      url += 'limit=' + limit;

      if (!all) {
        if (Collection._defined(options.startIndex)) {
          url += '&offset=' + options.startIndex;
        }
        if (options.startID) {
          url += '&fromID=' + options.startID;
        }
        if (options.since) {
          url += '&since=' + options.since;
        }
        if (options.until) {
          url += '&until=' + options.until;
        }
      }
      // Query
      if (options.query) {
        var queryString = Collection._getQueryString(options.query);
        if (queryString && queryString.length > 0) {
          url += '&q=' + queryString;
        }
      }

      // Add sorting
      var comparator = this.comparator;
      if (comparator && oj.StringUtils.isString(comparator)) {
        var attrs = this._getSortAttrs(comparator);
        var sortDirStr = this._getSortDirStr();
        var i;
        for (i = 0; i < attrs.length; i++) {
          if (i === 0) {
            url += '&orderBy=' + attrs[i] + ':' + sortDirStr;
          } else {
            url += ',' + attrs[i] + ':' + sortDirStr;
          }
        }
      }
      // Always ask for totalresults
      url += '&totalResults=true';
    }
    return url;
  };

  /**
   * @private
   */
  Collection.prototype._getSortDirStr = function () {
    if (this.sortDirection === -1) {
      return 'desc';
    }
    return 'asc';
  };

  /**
   * Called to perfrom server interactions, such as reading the collection.  Designed to be overridden by users.
   *
   * @param {string} method "read"
   * @param {Collection} collection the collection to be read (fetched)
   * @param {Object=} options to control sync<br>
   * <b>success</b>: called if sync succeeds.  Called with the data being fetched<br>
   * <b>error</b>: called if sync fails.  Called with xhr, status, and error info, per jQuery Ajax (all if
   * available)<br>
   * @return {Object} xhr response from ajax by default
   * @memberof Collection
   * @since 1.0.0
   * @ojsignature {target: "Type", value:"{success?: (response?: any)=> void,
   *                                                  error?: (xhr: any, status: any, error: any)=> void, [propName: string]: any}", for: "options"}
   */
  Collection.prototype.sync = function (method, collection, options) {
    return oj.sync(method, collection, options);
  };

  /**
   * Constants
   * @private
   */
  Collection._FETCH_SIZE_PROP = 'fetchSize';

  /**
   * @export
   * @class OAuth
   * @classdesc Member of Model objects. Object representing name/value pairs for a data service record
   *
   * @param {Object} attributes Initial set of attribute/value pairs with which to seed this OAuth object
   * @param {string} header Actual name for the Authorization header (default 'Authorization')
   * @example <caption>Initialize OAuth with client credentials</caption>
   * var myOAuth = new OAuth('X-Authorization', {...Client Credentials ...});
   *
   * @example <caption>Initialize OAuth with access_token</caption>
   * var myOAuth = new OAuth('X-Authorization', {...Access Token...});
   *
   * @example <caption>Initialize empty OAuth and set access_token</caption>
   * var myOAuth = new OAuth();
   * myOAuth.setAccessTokenResponse({...Access Token...});
   *
   * @constructor
   * @final
   * @since 1.0.0
   */
  const OAuth = function (header, attributes) {
    OAuth._init(this, attributes || {}, header || 'Authorization');
  };

  oj._registerLegacyNamespaceProp('OAuth', OAuth);

  // Subclass from oj.Object
  oj.Object.createSubclass(OAuth, oj.Object, 'oj.OAuth');

  OAuth.prototype.Init = function () {
    OAuth.superclass.Init.call(this);
  };

  /**
   * Calculates Authorization header based on client credentials or access_token
   * @return {Object} OAuth 2.0 Authorization header
   * @example <caption>Get Authorization header</caption>
   * myOAuth.getHeader();
   *
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.getHeader = function () {
    var headers = {};
    if (!this.accessTokenResponse.access_token) {
      this.clientCredentialGrant();
    }
    headers[this.accessTokenRequest.auth_header] = 'Bearer ' + this.accessTokenResponse.access_token;
    return headers;
  };

  /**
   * Check is OAuth initialized (not null access_token).
   * @return {boolean} true/false
   * @example <caption>Check if OAuth initialized</caption>
   * if(myOAuth.isInitialized()) console.log('Initialized');
   *
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.isInitialized = function () {
    if (this.accessTokenResponse && this.accessTokenResponse.access_token) {
      return true;
    }
    return false;
  };

  /**
   * Request for access_token(bearer token) using Client Credential Authorization Grant.
   * Initialize response part of the OAuth object (access_token, e.t.c.)
   * @return {undefined}
   * @example <caption>Set/Re-set response part of the OAuth object using Client Credentials</caption>
   * myOAuth.clientCredentialGrant();
   *
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.clientCredentialGrant = function () {
    var headers = {};
    var self = this;
    headers[self.accessTokenRequest.auth_header] =
      'Basic ' +
      OAuth._base64_encode(
        self.accessTokenRequest.client_id + ':' + self.accessTokenRequest.client_secret
      );

    $.ajax({
      type: 'POST',
      async: false,
      url: this.accessTokenRequest.bearer_url,
      data: 'grant_type=client_credentials',
      headers: headers,
      success: function (data) {
        self.accessTokenResponse = OAuth._initAccessToken(self.accessTokenResponse, data);
      },
      error: function (jqXHR) {
        throw new Error(jqXHR.responseText);
      }
    });
  };

  /**
   * Set response part of the OAuth object (access_token, e.t.c.)
   * @param {Object} data current response
   * @return {undefined}
   * @example <caption>'Initialize' response part of the OAuth object with access_token</caption>
   * myOAuth.setAccessTokenResponse({...Access Token...});
   *
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.setAccessTokenResponse = function (data) {
    this.accessTokenResponse = OAuth._initAccessToken(this.accessTokenResponse, data);
  };

  /**
   * Get response part of the OAuth object (access_token, e.t.c.)
   * @return {Object} cached response
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.getAccessTokenResponse = function () {
    return this.accessTokenResponse;
  };

  /**
   * Clean response part of the OAuth object (access_token, e.t.c.)
   * Null and remove all data from response part of the OAuth object
   * @return {undefined}
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.cleanAccessTokenResponse = function () {
    OAuth._cleanAccessToken(this.accessTokenResponse);
  };

  /**
   * Set request part of the OAuth object (client credentials, uri endpoint)
   * @param {Object} data current client credentials and uri
   * @return {undefined}
   * @example <caption>'Initialize' request part of the OAuth object with client credentials and calculate
   * access_token</caption>
   * myOAuth.setAccessTokenRequest({...Client Credentials ...});
   * myOAuth.clientCredentialGrant();
   *
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.setAccessTokenRequest = function (data) {
    this.accessTokenRequest = OAuth._initAccessToken(this.accessTokenRequest, data);
  };

  /**
   * Get request part of the OAuth object (client credentials, uri endpoint)
   * @return {Object} cached request
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.getAccessTokenRequest = function () {
    return this.accessTokenRequest;
  };

  /**
   * Clean request part of the OAuth object (client credentials, uri endpoint)
   * Null and remove all data from request part of the OAuth object
   * @return {undefined}
   * @memberof OAuth
   * @export
   */
  OAuth.prototype.cleanAccessTokenRequest = function () {
    OAuth._cleanAccessToken(this.accessTokenRequest);
  };

  /**
   * @private
   * @param {Object} oauth
   * @param {Object} attributes
   * @param {string|null} header
   */
  OAuth._init = function (oauth, attributes, header) {
    var oa = oauth;
    oa.Init();
    oa.accessTokenRequest = {};
    oa.accessTokenResponse = {};

    if (attributes.access_token) {
      // access_token has higher preference
      oa.accessTokenResponse = OAuth._initAccessToken(oa.accessTokenResponse, attributes);
    } else if (attributes.client_id && attributes.client_secret && attributes.bearer_url) {
      // Client Credential Grant
      oa.accessTokenResponse = OAuth._initAccessToken(oa.accessTokenRequest, attributes);
    }
    oa.accessTokenRequest.auth_header = header;
  };

  /**
   * @private
   * @param {Object} oauthObj - Request/Response object to deal with
   * @param {Object} data - object to populate
   */
  OAuth._initAccessToken = function (oauthObj, data) {
    var dat = data || {};
    var obj = oauthObj || {};
    Object.keys(dat).forEach(function (prop) {
      if (Object.prototype.hasOwnProperty.call(dat, prop)) {
        obj[prop] = dat[prop];
      }
    });
    return obj;
  };

  /**
   * @private
   * @param {Object} oauthObj - Request/Response object to deal with
   */
  OAuth._cleanAccessToken = function (oauthObj) {
    var obj = oauthObj || {};

    Object.keys(obj).forEach(function (key) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        if (key !== 'auth_header') {
          obj[key] = null;
          delete obj[key];
        }
      }
    });
  };

  /**
   * @private
   * @param {string} a The data to calculate the base64 representation from
   * @return {string} The base64 representation
   */
  OAuth._base64_encode = function (a) {
    var d;
    var e;
    var f;
    var b;
    var g = 0;
    var h = 0;
    var i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var c = [];

    do {
      d = a.charCodeAt(g);
      g += 1;
      e = a.charCodeAt(g);
      g += 1;
      f = a.charCodeAt(g);
      g += 1;
      b = (d << 16) | (e << 8) | f; // eslint-disable-line no-bitwise
      d = (b >> 18) & 63; // eslint-disable-line no-bitwise
      e = (b >> 12) & 63; // eslint-disable-line no-bitwise
      f = (b >> 6) & 63; // eslint-disable-line no-bitwise
      b &= 63; // eslint-disable-line no-bitwise
      c[h] = i.charAt(d) + i.charAt(e) + i.charAt(f) + i.charAt(b);
      h += 1;
    } while (g < a.length);
    c = c.join('');
    d = a.length % 3;
    return (d ? c.slice(0, d - 3) : c) + '==='.slice(d || 3);
  };

  exports.Collection = Collection;
  exports.Events = Events;
  exports.Model = Model;
  exports.OAuth = OAuth;
  exports.URLError = URLError;
  exports.ajax = ajax;
  exports.sync = sync;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdataprovideradapter',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojmodel', 'ojs/ojdataprovideradapter-base', 'ojs/ojeventtarget'], function (oj, ojdataprovider, ojmodel, DataSourceAdapter, ojeventtarget) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    DataSourceAdapter = DataSourceAdapter && Object.prototype.hasOwnProperty.call(DataSourceAdapter, 'default') ? DataSourceAdapter['default'] : DataSourceAdapter;

    class TableDataSourceAdapter extends DataSourceAdapter {
        constructor(tableDataSource) {
            super(tableDataSource);
            this.tableDataSource = tableDataSource;
            this.FetchByKeysResults = class {
                constructor(_parent, fetchParameters, results) {
                    this._parent = _parent;
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this[TableDataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
                    this[TableDataSourceAdapter._RESULTS] = results;
                }
            };
            this.ContainsKeysResults = class {
                constructor(_parent, containsParameters, results) {
                    this._parent = _parent;
                    this.containsParameters = containsParameters;
                    this.results = results;
                    this[TableDataSourceAdapter._CONTAINSPARAMETERS] = containsParameters;
                    this[TableDataSourceAdapter._RESULTS] = results;
                }
            };
            this.Item = class {
                constructor(_parent, metadata, data) {
                    this._parent = _parent;
                    this.metadata = metadata;
                    this.data = data;
                    this[TableDataSourceAdapter._METADATA] = metadata;
                    this[TableDataSourceAdapter._DATA] = data;
                }
            };
            this.FetchByOffsetResults = class {
                constructor(_parent, fetchParameters, results, done) {
                    this._parent = _parent;
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this.done = done;
                    this[TableDataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
                    this[TableDataSourceAdapter._RESULTS] = results;
                    this[TableDataSourceAdapter._DONE] = done;
                }
            };
            this.FetchListParameters = class {
                constructor(_parent, size, sortCriteria) {
                    this._parent = _parent;
                    this.size = size;
                    this.sortCriteria = sortCriteria;
                    this[TableDataSourceAdapter._SIZE] = size;
                    this[TableDataSourceAdapter._SORTCRITERIA] = sortCriteria;
                }
            };
            this._addTableDataSourceEventListeners();
            this[TableDataSourceAdapter._OFFSET] = 0;
            this._ignoreDataSourceEvents = new Array();
        }
        destroy() {
            this._removeTableDataSourceEventListeners();
        }
        containsKeys(params) {
            const self = this;
            const resultsPromiseArray = [];
            params[TableDataSourceAdapter._KEYS].forEach(function (key) {
                resultsPromiseArray.push(self.tableDataSource.get(key, { silent: true }));
            });
            return Promise.all(resultsPromiseArray).then(function (resultsArray) {
                const results = new Set();
                resultsArray.forEach((value) => {
                    if (value != null) {
                        results.add(value[TableDataSourceAdapter._KEY]);
                    }
                });
                return Promise.resolve(new self.ContainsKeysResults(self, params, results));
            });
        }
        fetchByKeys(params) {
            const self = this;
            const resultsPromiseArray = [];
            params[TableDataSourceAdapter._KEYS].forEach(function (key) {
                resultsPromiseArray.push(self.tableDataSource.get(key));
            });
            return Promise.all(resultsPromiseArray).then(function (resultsArray) {
                const results = new Map();
                for (let i = 0; i < resultsArray.length; i++) {
                    const value = resultsArray[i];
                    if (value != null) {
                        const itemKey = value[TableDataSourceAdapter._KEY];
                        const data = value[TableDataSourceAdapter._DATA];
                        const itemMetadata = new self.ItemMetadata(self, itemKey);
                        // tabledatasource get returns an index property
                        const index = value[TableDataSourceAdapter._INDEX];
                        self._extractMetaData(self.dataSource, index, itemMetadata);
                        results.set(itemKey, new self.Item(self, itemMetadata, data));
                    }
                }
                return Promise.resolve(new self.FetchByKeysResults(self, params, results));
            });
        }
        fetchByOffset(params) {
            const self = this;
            const size = params != null ? params[TableDataSourceAdapter._SIZE] : -1;
            const sortCriteria = params != null ? params[TableDataSourceAdapter._SORTCRITERIA] : null;
            const offset = params != null
                ? params[TableDataSourceAdapter._OFFSET] > 0
                    ? params[TableDataSourceAdapter._OFFSET]
                    : 0
                : 0;
            const fetchParams = new this.FetchListParameters(this, size, sortCriteria);
            this._startIndex = 0;
            return this._getFetchFunc(fetchParams, offset)(fetchParams, true).then(function (iteratorResults) {
                const value = iteratorResults[TableDataSourceAdapter._VALUE];
                const done = iteratorResults[TableDataSourceAdapter._DONE];
                const data = value[TableDataSourceAdapter._DATA];
                const keys = value[TableDataSourceAdapter._METADATA].map(function (value) {
                    return value[TableDataSourceAdapter._KEY];
                });
                const resultsArray = new Array();
                data.map(function (value, index) {
                    resultsArray.push(new self.Item(self, new self.ItemMetadata(self, keys[index]), data[index]));
                });
                for (let i = 0; i < resultsArray.length; i++) {
                    // metadata is technically already in iteratorResults but reuse method for ease
                    self._extractMetaData(self.dataSource, i + offset, resultsArray[i][TableDataSourceAdapter._METADATA]);
                }
                return new self.FetchByOffsetResults(self, params, resultsArray, done);
            });
        }
        fetchFirst(params) {
            if (!this._isPagingModelTableDataSource()) {
                this._startIndex = 0;
            }
            return new this.AsyncIterable(new this.AsyncIterator(this._getFetchFunc(params), params));
        }
        getCapability(capabilityName) {
            if (capabilityName == TableDataSourceAdapter._SORT &&
                this.tableDataSource.getCapability(capabilityName) == 'full') {
                return { attributes: 'multiple' };
            }
            else if (capabilityName == 'fetchByKeys') {
                return { implementation: 'lookup' };
            }
            else if (capabilityName == 'fetchByOffset') {
                return { implementation: 'lookup' };
            }
            return null;
        }
        getTotalSize() {
            return Promise.resolve(this.tableDataSource.totalSize());
        }
        isEmpty() {
            return this.tableDataSource.totalSize() > 0 ? 'no' : 'yes';
        }
        // Start PagingModel APIs
        getPage() {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.getPage();
            }
            return -1;
        }
        setPage(value, options) {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.setPage(value, options);
            }
            return Promise.reject(null);
        }
        getStartItemIndex() {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.getStartItemIndex();
            }
            return -1;
        }
        getEndItemIndex() {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.getEndItemIndex();
            }
            return -1;
        }
        getPageCount() {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.getPageCount();
            }
            return -1;
        }
        totalSize() {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.totalSize();
            }
            return -1;
        }
        totalSizeConfidence() {
            if (this._isPagingModelTableDataSource()) {
                return this.tableDataSource.totalSizeConfidence();
            }
            return null;
        }
        // End PagingModel APIs
        /**
         * Get the function which performs the fetch
         */
        _getFetchFunc(params, offset) {
            const self = this;
            if (params != null && params[TableDataSourceAdapter._SORTCRITERIA] != null) {
                const attribute = params[TableDataSourceAdapter._SORTCRITERIA][0][TableDataSourceAdapter._ATTRIBUTE];
                const direction = params[TableDataSourceAdapter._SORTCRITERIA][0][TableDataSourceAdapter._DIRECTION];
                this._ignoreSortEvent = true;
                if (!this._isPagingModelTableDataSource()) {
                    this._startIndex = 0;
                }
                return (function (attribute, direction) {
                    return function (params, fetchFirst) {
                        if (fetchFirst) {
                            const sortParam = {};
                            sortParam[TableDataSourceAdapter._KEY] = attribute;
                            sortParam[TableDataSourceAdapter._DIRECTION] = direction;
                            self[TableDataSourceAdapter._OFFSET] = 0;
                            return self.tableDataSource.sort(sortParam).then(function () {
                                self._ignoreSortEvent = false;
                                return self._getTableDataSourceFetch(params, offset)(params);
                            });
                        }
                        else {
                            return self._getTableDataSourceFetch(params, offset)(params);
                        }
                    };
                })(attribute, direction);
            }
            else {
                return this._getTableDataSourceFetch(params, offset);
            }
        }
        /**
         * Extract the datasource metadata to the result ItemMetadata.
         */
        _extractMetaData(tableDataSource, index, itemMetadata) {
            let dataSource = tableDataSource;
            if (this._isPagingModelTableDataSource()) {
                dataSource = dataSource.getWrappedDataSource();
            }
            if (dataSource._getMetadata) {
                const metadata = dataSource._getMetadata(index);
                if (metadata) {
                    Object.keys(metadata).forEach(function (key) {
                        itemMetadata[key] = metadata[key];
                    });
                }
            }
        }
        /**
         * Get the function which invokes fetch() on TableDataSource
         */
        _getTableDataSourceFetch(params, offset) {
            const self = this;
            return function (params, fetchFirst) {
                const options = {};
                offset = offset > 0 ? offset : 0;
                if (self._startIndex != null) {
                    options[TableDataSourceAdapter._STARTINDEX] = self._startIndex + offset;
                }
                options[TableDataSourceAdapter._PAGESIZE] =
                    params != null && params[TableDataSourceAdapter._SIZE] > 0
                        ? params[TableDataSourceAdapter._SIZE]
                        : null;
                // to maintain backward compatibility, Table will specify silent flag
                if (!self._isPagingModelTableDataSource() && params?.[TableDataSourceAdapter._SILENT]) {
                    options[TableDataSourceAdapter._SILENT] = params[TableDataSourceAdapter._SILENT];
                }
                if (self.tableDataSource[TableDataSourceAdapter._SORTCRITERIA] != null &&
                    params[TableDataSourceAdapter._SORTCRITERIA] == null) {
                    const sortCriterion = new self.SortCriterion(self, self.tableDataSource[TableDataSourceAdapter._SORTCRITERIA][TableDataSourceAdapter._KEY], self.tableDataSource[TableDataSourceAdapter._SORTCRITERIA][TableDataSourceAdapter._DIRECTION]);
                    params = { ...params, [TableDataSourceAdapter._SORTCRITERIA]: [sortCriterion] };
                }
                options[TableDataSourceAdapter._FETCHTYPE] = params[TableDataSourceAdapter._FETCHTYPE];
                self._isFetching = true;
                return new Promise(function (resolve, reject) {
                    self._fetchResolveFunc = resolve;
                    self._fetchRejectFunc = reject;
                    self._fetchParams = params;
                    if (!self._requestEventTriggered) {
                        // set a flag so that we can ignore request and sync events
                        if (!self._isPagingModelTableDataSource() && !options[TableDataSourceAdapter._SILENT]) {
                            self._ignoreDataSourceEvents.push(true);
                        }
                        self.tableDataSource.fetch(options).then(function (result) {
                            if (!self._isPagingModelTableDataSource() &&
                                !options[TableDataSourceAdapter._SILENT]) {
                                self._ignoreDataSourceEvents.pop();
                            }
                            if (result !== null) {
                                self._isFetching = false;
                                if (result === undefined) {
                                    // fetch was not executed due to startFetch='disabled'
                                    result = {};
                                    result[TableDataSourceAdapter._KEYS] = [];
                                    result[TableDataSourceAdapter._DATA] = [];
                                }
                                let resultMetadata = [];
                                if (result[TableDataSourceAdapter._KEYS] != null) {
                                    resultMetadata = result[TableDataSourceAdapter._KEYS].map(function (value) {
                                        return new self.ItemMetadata(self, value);
                                    });
                                }
                                if (self._startIndex == null) {
                                    self._startIndex = 0;
                                }
                                for (let i = 0; i < resultMetadata.length; i++) {
                                    self._extractMetaData(self.dataSource, self._startIndex + i, resultMetadata[i]);
                                }
                                let done = false;
                                self._startIndex = self._startIndex + result[TableDataSourceAdapter._DATA].length;
                                if (self.tableDataSource.totalSizeConfidence() == 'actual' &&
                                    self.tableDataSource.totalSize() > 0 &&
                                    result.startIndex + result[TableDataSourceAdapter._DATA].length >=
                                        self.tableDataSource.totalSize()) {
                                    done = true;
                                }
                                else if (options[TableDataSourceAdapter._PAGESIZE] > 0 &&
                                    result[TableDataSourceAdapter._DATA].length <
                                        options[TableDataSourceAdapter._PAGESIZE]) {
                                    done = true;
                                }
                                else if (result[TableDataSourceAdapter._DATA].length === 0) {
                                    done = true;
                                }
                                self._fetchResolveFunc = null;
                                self._fetchParams = null;
                                if (done) {
                                    resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, params, result[TableDataSourceAdapter._DATA], resultMetadata)));
                                }
                                else {
                                    resolve(new self.AsyncIteratorYieldResult(self, new self.FetchListResult(self, params, result[TableDataSourceAdapter._DATA], resultMetadata)));
                                }
                            }
                        }, function (error) {
                            if (!self._isPagingModelTableDataSource() &&
                                !options[TableDataSourceAdapter._SILENT]) {
                                self._ignoreDataSourceEvents.pop();
                            }
                            reject(error);
                        });
                    }
                });
            };
        }
        /**
         * Adjust the last offset for iterators.
         */
        _adjustIteratorOffset(removeIndexes, addIndexes) {
            // this._mapClientIdToOffset.forEach((offset, clientId) => {
            let offset = this._startIndex;
            let deleteCount = 0;
            if (removeIndexes) {
                removeIndexes.forEach(function (index) {
                    // only count the changes below the last offset
                    if (index < offset) {
                        ++deleteCount;
                    }
                });
            }
            offset -= deleteCount;
            if (addIndexes) {
                addIndexes.forEach(function (index) {
                    // only count the changes below the last offset
                    if (index < offset) {
                        ++offset;
                    }
                });
            }
            this._startIndex = offset;
            //   this._mapClientIdToOffset.set(clientId, offset);
            // });
        }
        _handleSync(event) {
            const self = this;
            // checks for sync triggered by own fetch
            if (self._ignoreDataSourceEvents.length > 0) {
                return;
            }
            self._startIndex = null;
            if (event[TableDataSourceAdapter._STARTINDEX] > 0) {
                self._startIndex = event[TableDataSourceAdapter._STARTINDEX];
                self[TableDataSourceAdapter._OFFSET] = self._startIndex;
            }
            if (self._fetchResolveFunc && event[TableDataSourceAdapter._KEYS] != null) {
                self._isFetching = false;
                const resultMetadata = event[TableDataSourceAdapter._KEYS].map(function (value) {
                    return new self.ItemMetadata(self, value);
                });
                for (let i = 0; i < resultMetadata.length; i++) {
                    // expect startIndex to be set in sync event but null check
                    let indexToExtract = self._startIndex != null ? self._startIndex + i : i;
                    self._extractMetaData(self.dataSource, indexToExtract, resultMetadata[i]);
                }
                let done = false;
                if (self.tableDataSource.totalSizeConfidence() == 'actual' &&
                    self.tableDataSource.totalSize() > 0 &&
                    self._startIndex + event[TableDataSourceAdapter._DATA].length >=
                        self.tableDataSource.totalSize()) {
                    done = true;
                }
                if (done) {
                    self._fetchResolveFunc(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, self._fetchParams, event[TableDataSourceAdapter._DATA], resultMetadata)));
                }
                else {
                    self._fetchResolveFunc(new self.AsyncIteratorYieldResult(self, new self.FetchListResult(self, self._fetchParams, event[TableDataSourceAdapter._DATA], resultMetadata)));
                }
                self._fetchResolveFunc = null;
                self._fetchParams = null;
            }
            else if (!self._requestEventTriggered) {
                self.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
            }
            self._requestEventTriggered = false;
        }
        _handleAdd(event) {
            const self = this;
            const metadataArray = event[TableDataSourceAdapter._KEYS].map(function (value) {
                return new self.ItemMetadata(self, value);
            });
            const keySet = new Set();
            event[TableDataSourceAdapter._KEYS].map(function (key) {
                keySet.add(key);
            });
            const operationEventDetail = new self.DataProviderAddOperationEventDetail(self, keySet, null, null, null, metadataArray, event[TableDataSourceAdapter._DATA], event[TableDataSourceAdapter._INDEXES]);
            const mutationEventDetail = new self.DataProviderMutationEventDetail(self, operationEventDetail, null, null);
            self.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationEventDetail));
            this._adjustIteratorOffset(null, mutationEventDetail.add?.indexes);
        }
        _handleRemove(event) {
            const self = this;
            const metadataArray = event[TableDataSourceAdapter._KEYS].map(function (value) {
                return new self.ItemMetadata(self, value);
            });
            const keySet = new Set();
            event[TableDataSourceAdapter._KEYS].map(function (key) {
                keySet.add(key);
            });
            const operationEventDetail = new self.DataProviderOperationEventDetail(self, keySet, metadataArray, event[TableDataSourceAdapter._DATA], event[TableDataSourceAdapter._INDEXES]);
            const mutationEventDetail = new self.DataProviderMutationEventDetail(self, null, operationEventDetail, null);
            self.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationEventDetail));
            this._adjustIteratorOffset(mutationEventDetail.remove?.indexes, null);
        }
        _handleReset(event) {
            const self = this;
            // Dispatch a dataprovider refresh event except for the following situations:
            // 1. If a datasource request event was triggered, a dataprovider refresh event has been dispatched;
            // 2. If the datasource is a paging datasource, the pagingcontrol reset handler will indirectly trigger
            //    a datasource request event, which in turn will dispatch a dataprovider refresh event.
            //
            if (!self._requestEventTriggered && !self._isPagingModelTableDataSource()) {
                self._startIndex = 0;
                self.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
            }
        }
        _handleSort(event) {
            const self = this;
            if (!self._ignoreSortEvent) {
                self._startIndex = null;
                self.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
            }
        }
        _handleChange(event) {
            const self = this;
            const metadataArray = event[TableDataSourceAdapter._KEYS].map(function (value) {
                return new self.ItemMetadata(self, value);
            });
            const keySet = new Set();
            event[TableDataSourceAdapter._KEYS].map(function (key) {
                keySet.add(key);
            });
            const operationEventDetail = new self.DataProviderOperationEventDetail(self, keySet, metadataArray, event[TableDataSourceAdapter._DATA], event[TableDataSourceAdapter._INDEXES]);
            const mutationEventDetail = new self.DataProviderMutationEventDetail(self, null, null, operationEventDetail);
            self.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationEventDetail));
        }
        _handleRefresh(event) {
            const self = this;
            if (!self._isFetching && !self._requestEventTriggered) {
                if (event[TableDataSourceAdapter._OFFSET] != null) {
                    // reset _startIndex & offset for refresh event
                    self._startIndex = event[TableDataSourceAdapter._OFFSET];
                    if (self.tableDataSource._fetchType === 'loadMore') {
                        self.offset = event[TableDataSourceAdapter._OFFSET];
                    }
                }
                else {
                    self._startIndex = null;
                }
                self.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
            }
            self._requestEventTriggered = false;
        }
        _handleRequest(event) {
            const self = this;
            // checks for sync triggered by own fetch
            if (self._ignoreDataSourceEvents.length > 0) {
                return;
            }
            // to test backward compatibility we still need to be able to access Model from the oj namespace
            if (typeof ojmodel.Model !== 'undefined' && event instanceof ojmodel.Model) {
                // ignore request events by Model. Those will be followed by row
                // mutation events anyway
                return;
            }
            if (!self._isFetching) {
                if (event[TableDataSourceAdapter._STARTINDEX] > 0 && self.getStartItemIndex() === 0) {
                    self._startIndex = event[TableDataSourceAdapter._STARTINDEX];
                }
                // dispatch a refresh event which will trigger a the component to
                // do a fetchFirst. However, the fact that we are receiving a request
                // event means that a fetch was already done on the underlying TableDataSource.
                // So we don't need to do another fetch once a fetchFirst comes in, we can
                // just resolve with the results from the paired sync event.
                self._requestEventTriggered = true;
                self.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
            }
        }
        _handleError(event) {
            const self = this;
            if (self._fetchRejectFunc) {
                self._fetchRejectFunc(event);
            }
            self._isFetching = false;
            self._requestEventTriggered = false;
        }
        _handlePage(event) {
            const self = this;
            self._isFetching = false;
            self._requestEventTriggered = false;
            const options = {};
            options['detail'] = event;
            self.dispatchEvent(new ojeventtarget.GenericEvent(oj.PagingModel.EventType['PAGE'], options));
        }
        /**
         * Add event listeners to TableDataSource
         */
        _addTableDataSourceEventListeners() {
            this.removeAllListeners();
            this.addListener('sync', this._handleSync);
            this.addListener('add', this._handleAdd);
            this.addListener('remove', this._handleRemove);
            this.addListener('reset', this._handleReset);
            this.addListener('sort', this._handleSort);
            this.addListener('change', this._handleChange);
            this.addListener('refresh', this._handleRefresh);
            this.addListener('request', this._handleRequest);
            this.addListener('error', this._handleError);
            this.addListener('page', this._handlePage);
        }
        /**
         * Remove event listeners to TableDataSource
         */
        _removeTableDataSourceEventListeners() {
            this.removeListener('sync');
            this.removeListener('add');
            this.removeListener('remove');
            this.removeListener('reset');
            this.removeListener('sort');
            this.removeListener('change');
            this.removeListener('refresh');
            this.removeListener('request');
            this.removeListener('error');
            this.removeListener('page');
        }
        /**
         * Check if it's a PagingModel TableDataSource
         */
        _isPagingModelTableDataSource() {
            if (this.tableDataSource['getStartItemIndex'] != null) {
                return true;
            }
            return false;
        }
    }
    TableDataSourceAdapter._STARTINDEX = 'startIndex';
    TableDataSourceAdapter._SILENT = 'silent';
    TableDataSourceAdapter._SORTCRITERIA = 'sortCriteria';
    TableDataSourceAdapter._PAGESIZE = 'pageSize';
    TableDataSourceAdapter._OFFSET = 'offset';
    TableDataSourceAdapter._SIZE = 'size';
    TableDataSourceAdapter._CONTAINSPARAMETERS = 'containsParameters';
    TableDataSourceAdapter._RESULTS = 'results';
    TableDataSourceAdapter._FETCHTYPE = 'fetchType';
    TableDataSourceAdapter._INDEX = 'index';
    ojeventtarget.EventTargetMixin.applyMixin(TableDataSourceAdapter);
    oj._registerLegacyNamespaceProp('TableDataSourceAdapter', TableDataSourceAdapter);

    return TableDataSourceAdapter;

});


define('ojs/ojobservable',['exports'], function (exports) { 'use strict';

    /**
     * A behavior subject implementation of observable
     * @class BehaviorSubject
     *
     * @classdesc a internal class behavior subject implementation of observable
     * @constructor
     * @hideconstructor
     * @ojignore
     * @ojtsignore
     * @param {any} value
     * @since 7.0.0
     */
    const BehaviorSubject = function (value) {
        this.observers = [];
        this._value = value;
    };
    BehaviorSubject.prototype.subscribe = function (onNextOrSubscriber, onError, onComplete) {
        let subscriber = onNextOrSubscriber;
        if (typeof subscriber === 'function') {
            subscriber = {
                next: onNextOrSubscriber,
                error: onError,
                complete: onComplete
            };
        }
        else if (typeof subscriber !== 'object') {
            subscriber = {};
        }
        this.observers.push(subscriber);
        const subscription = new SubjectSubscription(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.next = function (value) {
        this._value = value;
        const { observers } = this;
        const len = observers.length;
        const copy = observers.slice();
        for (let i = 0; i < len; i++) {
            copy[i].next(value);
        }
    };
    const SubjectSubscription = function (subject, subscriber) {
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    };
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        const subject = this.subject;
        const observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0) {
            return;
        }
        const subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    SubjectSubscription.prototype.closed = function () {
        return this.closed;
    };

    exports.BehaviorSubject = BehaviorSubject;
    exports.SubjectSubscription = SubjectSubscription;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojlistdataproviderview',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojeventtarget', 'ojs/ojobservable'], function (oj, ojdataprovider, ojeventtarget, ojobservable) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 4.1.0
     * @export
     * @final
     * @class ListDataProviderView
     * @ojtsmodule
     * @implements DataProvider
     * @classdesc Provides list based optimizations for DataProvider and adds some support for providing state
     * for certain operations. e.g supports {@link DataProvider#fetchFirst} starting at arbitrary key or index offset, sortCriteria,
     * and field mapping. Please see the select demos for examples of DataMapping [Select]{@link oj.ojSelect}
     * @param {DataProvider} dataProvider the DataProvider.
     * @param {ListDataProviderView.Options=} options Options for the ListDataProviderView
     * @ojsignature [{target: "Type",
     *               value: "class ListDataProviderView<K, D, Kin, Din> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of output key"}, {"name": "D", "description": "Type of output data"},
     *                    {"name": "Kin", "description": "Type of input key"}, {"name": "Din", "description": "Type of input data"}]},
     *               {target: "Type",
     *               value: "DataProvider<Kin, Din>",
     *               for: "dataProvider"},
     *               {target: "Type",
     *                value: "ListDataProviderView.Options<K, D, Kin, Din>",
     *                for: "options"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     *   "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults", "DataMapping",
     *   "FetchListResult","FetchListParameters", "FetchAttribute", "DataFilter"]}
     */

    /**
     * @typedef {Object} ListDataProviderView.Options
     * @property {any=} from - key to start fetching from. This will be applied first before offset is applied.
     * @property {number=} offset - offset to start fetching from.
     * @property {Array=} sortCriteria - {@link SortCriterion} to apply to the data.
     * @property {DataMapping=} dataMapping - mapping to apply to the data.
     * @property {Array=} attributes - fetch attributes to apply
     * @property {DataFilter.Filter=} filterCriterion - filter criterion to apply. If the DataProvider does not support filtering then
     *        ListDataProviderView will do local filtering of the data.
     * @property {string=} includeFilteredRowCount - Optionally specifies whether an observable need to be created for total filtered row count. Supported values:<br>
     *                                  <ul>
     *                                    <li>'enabled': observable for total filtered row count is created and getTotalFilteredRowCountObservable method can be used to get the observable. Also fetch parameter includeFilteredRowCount is set
     *                                          to 'enabled' when calling fetchFirst and fetchByOffset on base dataprovider.
     *                                    <li>'disabled': no observable is created for total filtered row count. getTotalFilteredRowCountObservable method returns null.
     *                                  </ul>
     * @ojsignature [
     *  {target: "Type", value: "<K, D, Kin, Din>", for: "genericTypeParameters"},
     *  {target: "Type", value: "Kin", for: "from"},
     *  {target: "Type", value: "number", for: "offset"},
     *  {target: "Type", value: "Array.<SortCriterion<D>>", for: "sortCriteria"},
     *  {target: "Type", value: "DataMapping<K, D, Kin, Din>", for: "dataMapping"},
     *  {target: "Type", value: "Array<string | FetchAttribute>", for: "attributes"},
     *  {target: "Type", value: "DataFilter.Filter<D>", for: "filterCriterion"},
     *  {target: "Type", value: "'enabled' | 'disabled'", for: "includeFilteredRowCount"},
     * ]
     */

    /**
     * @typedef {Object} ListDataProviderView.NotFetchedRowCount
     * @property {'notFetched'} type
     */

    /**
     * @typedef {Object} ListDataProviderView.UnknownRowCount
     * @property {'unknown'} type
     */

    /**
     * @typedef {Object} ListDataProviderView.ExactRowCount
     * @property {'exact'} type
     * @property {number} count
     */

    /**
     * @typedef {Object} ListDataProviderView.RowCount
     * @ojsignature {target: "Type",
     *               value: "ListDataProviderView.NotFetchedRowCount | ListDataProviderView.UnknownRowCount | ListDataProviderView.ExactRowCount"}
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * Get an AsyncIterable object for iterating the data.
     * <p>
     * AsyncIterable contains a Symbol.asyncIterator method that returns an AsyncIterator.
     * AsyncIterator contains a next method for fetching the next block of data.
     * </p><p>
     * The "next" method returns a promise that resolves to an object, which contains a "value" property for the data and a "done" property
     * that is set to true when there is no more data to be fetched.  The "done" property should be set to true only if there is no "value"
     * in the result.  Note that "done" only reflects whether the iterator is done at the time "next" is called.  Future calls to "next"
     * may or may not return more rows for a mutable data source.
     * </p>
     * <p>
     * Please see the <a href="DataProvider.html#custom-implementations-section">DataProvider documentation</a> for
     * more information on custom implementations.
     * </p>
     *
     * @param {FetchListParameters=} params fetch parameters
     * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
     * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name fetchFirst
     * @ojsignature {target: "Type",
     *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
     * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
     * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
     * let result = await asyncIterator.next();
     * let value = result.value;
     * let data = value.data;
     * let keys = value.metadata.map(function(val) {
     *   return val.key;
     * });
     * // true or false for done
     * let done = result.done;
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name dispatchEvent
     */

    /**
     * Get the observable with information of totalFilterRowCount to subscribe to.
     * Consumers can call subscribe and unsubscribe to receive changes to the totalFilterRowCount. Method returns observable only if <b>includeFilteredRowCount</b> option is set to 'enabled' otherwise it will return null.
     * <p>On the first subscribe call, the initial value will be passed to the subscriber.
     * <p>The observed value is an object of type {@link ListDataProviderView.RowCount}.
     * RowCount type can be as follow based on different states:
     * <ul>
     *  <li>Initial value is {@link ListDataProviderView.NotFetchedRowCount}.</li>
     *  <li>When fetch result is returned, if totalFilteredRowCount is -1 then RowCount will be {@link ListDataProviderView.UnknownRowCount} otherwise {@link ListDataProviderView.ExactRowCount}.<br/>
     *      If underlying dataprovider doesn't support totalFilteredRowCount capability for fetch then RowCount will be set to {@link ListDataProviderView.UnknownRowCount}.</li>
     *  <li>When a new fetch request is started, RowCount will be changed to {@link ListDataProviderView.NotFetchedRowCount}.</li>
     *  <li>When filter criteria is changed, RowCount will be changed to {@link ListDataProviderView.NotFetchedRowCount}.</li>
     * </ul>
     *
     * <i>Example of getting the observable and subscribing for totalFilteredRowCount change:</i>
     * <pre class="prettyprint"><code>totalFilteredRowCountObservable = dataprovider.getTotalFilteredRowCountObservable();
     * subscriber = getTotalFilteredRowCountObservable.subscribe(value => {
     *  type = value.type;
     *  rowCount = value.rowCount;
     * });
     * </code></pre>
     * @return {Object | null} an object to call subscribe on to receive changes to totalFilteredRowCount. The subscribe function returns an object to call unsubscribe on.
     *
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @method
     * @name getTotalFilteredRowCountObservable
     * @see {@link https://github.com/tc39/proposal-observable} for further information on Observable and Subscription.
     * @ojsignature {target: "Type",
     *               value: "():{ subscribe( subscriber : ((rowCount: ListDataProviderView.RowCount) => void) ): {unsubscribe(): void, closed(): boolean}} | null" }
     */

    /**
     * Optional key to start fetching from. Used to set on the ListDataProviderView instance instead of through the constructor.
     *
     *
     * @since 4.1.0
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @name from
     * @type {any}
     * @ojsignature {target: "Type",
     *               value: "?Kin"}
     * @ojtsexample <caption>set the key to start fetching from</caption>
     * dataprovider.from = '1234';
     */

    /**
     * Optional offset to start fetching from. Used to set on the ListDataProviderView instance instead of through the constructor.. Should be greater than or equal to zero.
     * If a negative offset is used then it will be treated as zero.
     *
     *
     * @since 4.1.0
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @name offset
     * @type {number=}
     * @ojsignature {target: "Type",
     *               value: "?number"}
     * @ojtsexample <caption>set the offset to start fetching from</caption>
     * dataprovider.offset = 5;
     */

    /**
     * Optional sortCriteria to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
     *
     *
     * @since 4.1.0
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @name sortCriteria
     * @type {Array.<SortCriterion>=}
     * @ojsignature {target: "Type",
     *               value: "?Array<SortCriterion<D>>"}
     * @ojtsexample <caption>set the sortCriteria for fetching</caption>
     * dataprovider.sortCriteria = [{attribute: 'DepartmentName', direction: 'ascending'}];
     */

    /**
     * Optional dataMapping to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
     *
     *
     * @since 4.1.0
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @name dataMapping
     * @type {DataMapping=}
     * @ojsignature {target: "Type",
     *               value: "?DataMapping<K, D, Kin, Din>"}
     * @ojtsexample <caption>set the data mapping for fetching</caption>
     * dataprovider.dataMapping = function (item) {
     *   let data = item.data;
     *   let mappedItem = {};
     *   mappedItem.data = {};
     *   mappedItem.data.label = data.name;
     *   mappedItem.data.value = data.id;
     *   mappedItem.metadata = { key: data.id };
     *   return mappedItem;
     * };
     */

    /**
     * Optional fetch attributes to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
     *
     *
     * @since 4.1.0
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @name attributes
     * @type {Array<string | FetchAttribute>=}
     * @ojsignature {target: "Type",
     *               value: "?Array<string | FetchAttribute>"}
     * @ojtsexample <caption>set the attribute filter for fetching</caption>
     * dataprovider.attributes = ['!lastName', '@default']; // all attributes except lastName
     */

    /**
     * Optional filter criterion to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
     *
     *
     * @since 7.0.0
     * @export
     * @expose
     * @memberof ListDataProviderView
     * @instance
     * @name filterCriterion
     * @type {DataFilter.Filter=}
     * @ojsignature {target: "Type",
     *               value: "?DataFilter.Filter<D>"}
     * @ojtsexample <caption>set the filter criterion for fetching</caption>
     * let filterDef = {op: '$or', criteria: [{op: '$eq', value: {name: 'Bob'}}, {op: '$gt', value: {level: 'Low'}}]};
     * dataprovider.filterCriterion = FilterFactory.getFilter({filterDef}); // create a standard filter using the filterFactory.
     */

    // end of jsdoc

    /**
     * Class which provides list based optimizations
     */
    class ListDataProviderView {
        constructor(dataProvider, options) {
            var _a;
            this.dataProvider = dataProvider;
            this.options = options;
            this._noFilterSupport = false;
            this._totalFilteredRowCountObservable = null;
            this.AsyncIterable = (_a = class {
                    constructor(_parent, _asyncIterator) {
                        this._parent = _parent;
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = () => {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this.AsyncIterator = class {
                constructor(_parent, _nextFunc, _params) {
                    this._parent = _parent;
                    this._nextFunc = _nextFunc;
                    this._params = _params;
                }
                ['next']() {
                    const signal = this._params?.signal;
                    const callback = (resolve) => {
                        const result = this._nextFunc(this._params);
                        return resolve(result);
                    };
                    return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
                }
            };
            this.AsyncIteratorYieldResult = class {
                constructor(_parent, value) {
                    this._parent = _parent;
                    this.value = value;
                    this[ListDataProviderView._VALUE] = value;
                    this[ListDataProviderView._DONE] = false;
                }
            };
            this.AsyncIteratorReturnResult = class {
                constructor(_parent, value) {
                    this._parent = _parent;
                    this.value = value;
                    this[ListDataProviderView._VALUE] = value;
                    this[ListDataProviderView._DONE] = true;
                }
            };
            this.FetchListResult = class {
                constructor(_parent, fetchParameters, data, metadata, totalFilteredRowCount) {
                    this._parent = _parent;
                    this.fetchParameters = fetchParameters;
                    this.data = data;
                    this.metadata = metadata;
                    this.totalFilteredRowCount = totalFilteredRowCount;
                    this[ListDataProviderView._FETCHPARAMETERS] = fetchParameters;
                    this[ListDataProviderView._DATA] = data;
                    this[ListDataProviderView._METADATA] = metadata;
                    if (fetchParameters && fetchParameters.includeFilteredRowCount === 'enabled') {
                        this[ListDataProviderView._TOTALFILTEREDROWCOUNT] = totalFilteredRowCount;
                    }
                }
            };
            this.Item = class {
                constructor(_parent, metadata, data) {
                    this._parent = _parent;
                    this.metadata = metadata;
                    this.data = data;
                    this[ListDataProviderView._METADATA] = metadata;
                    this[ListDataProviderView._DATA] = data;
                }
            };
            this.ItemMetadata = class {
                constructor(_parent, key) {
                    this._parent = _parent;
                    this.key = key;
                    this[ListDataProviderView._KEY] = key;
                }
            };
            this.FetchListParameters = class {
                constructor(_parent, params, size, sortCriteria, filterCriterion, attributes, signal, includeFilteredRowCount) {
                    this._parent = _parent;
                    this.params = params;
                    this.size = size;
                    this.sortCriteria = sortCriteria;
                    this.filterCriterion = filterCriterion;
                    this.attributes = attributes;
                    this.signal = signal;
                    this.includeFilteredRowCount = includeFilteredRowCount;
                    if (params) {
                        Object.keys(params).forEach((prop) => {
                            this[prop] = params[prop];
                        });
                    }
                    this[ListDataProviderView._SIZE] = size;
                    if (sortCriteria) {
                        this[ListDataProviderView._SORTCRITERIA] = sortCriteria;
                    }
                    if (filterCriterion) {
                        this[ListDataProviderView._FILTERCRITERION] = filterCriterion;
                    }
                    if (attributes) {
                        this[ListDataProviderView._FETCHATTRIBUTES] = attributes;
                    }
                    if (signal) {
                        this[ListDataProviderView._SIGNAL] = signal;
                    }
                    if (includeFilteredRowCount) {
                        this[ListDataProviderView._INCLUDEFILTEREDROWCOUNT] = includeFilteredRowCount;
                    }
                }
            };
            this.FetchByKeysParameters = class {
                constructor(_parent, keys, params, attributes) {
                    this._parent = _parent;
                    this.keys = keys;
                    this.params = params;
                    this.attributes = attributes;
                    if (params) {
                        Object.keys(params).forEach((prop) => {
                            this[prop] = params[prop];
                        });
                    }
                    if (keys) {
                        this[ListDataProviderView._KEYS] = keys;
                    }
                    if (attributes) {
                        this[ListDataProviderView._FETCHATTRIBUTES] = attributes;
                    }
                }
            };
            this.FetchByOffsetParameters = class {
                constructor(_parent, offset, params, size, sortCriteria, filterCriterion, attributes, signal, includeFilteredRowCount) {
                    this._parent = _parent;
                    this.offset = offset;
                    this.params = params;
                    this.size = size;
                    this.sortCriteria = sortCriteria;
                    this.filterCriterion = filterCriterion;
                    this.attributes = attributes;
                    this.signal = signal;
                    this.includeFilteredRowCount = includeFilteredRowCount;
                    if (params) {
                        Object.keys(params).forEach((prop) => {
                            this[prop] = params[prop];
                        });
                    }
                    if (size) {
                        this[ListDataProviderView._SIZE] = size;
                    }
                    if (sortCriteria) {
                        this[ListDataProviderView._SORTCRITERIA] = sortCriteria;
                    }
                    if (offset) {
                        this[ListDataProviderView._OFFSET] = offset;
                    }
                    if (filterCriterion) {
                        this[ListDataProviderView._FILTERCRITERION] = filterCriterion;
                    }
                    if (attributes) {
                        this[ListDataProviderView._FETCHATTRIBUTES] = attributes;
                    }
                    if (signal) {
                        this[ListDataProviderView._SIGNAL] = signal;
                    }
                    if (includeFilteredRowCount) {
                        this[ListDataProviderView._INCLUDEFILTEREDROWCOUNT] = includeFilteredRowCount;
                    }
                }
            };
            this.FetchByKeysResults = class {
                constructor(_parent, fetchParameters, results) {
                    this._parent = _parent;
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this[ListDataProviderView._FETCHPARAMETERS] = fetchParameters;
                    this[ListDataProviderView._RESULTS] = results;
                }
            };
            this.ContainsKeysResults = class {
                constructor(_parent, containsParameters, results) {
                    this._parent = _parent;
                    this.containsParameters = containsParameters;
                    this.results = results;
                    this[ListDataProviderView._CONTAINSPARAMETERS] = containsParameters;
                    this[ListDataProviderView._RESULTS] = results;
                }
            };
            this.FetchByOffsetResults = class {
                constructor(_parent, fetchParameters, results, done, totalFilteredRowCount) {
                    this._parent = _parent;
                    this.fetchParameters = fetchParameters;
                    this.results = results;
                    this.done = done;
                    this.totalFilteredRowCount = totalFilteredRowCount;
                    this[ListDataProviderView._FETCHPARAMETERS] = fetchParameters;
                    this[ListDataProviderView._RESULTS] = results;
                    this[ListDataProviderView._DONE] = done;
                    if (fetchParameters && fetchParameters.includeFilteredRowCount === 'enabled') {
                        this[ListDataProviderView._TOTALFILTEREDROWCOUNT] = totalFilteredRowCount;
                    }
                }
            };
            this[ListDataProviderView._INTERNAL_FROM] =
                this.options == null ? null : this.options[ListDataProviderView._FROM];
            this[ListDataProviderView._INTERNAL_OFFSET] =
                this.options == null
                    ? 0
                    : this.options[ListDataProviderView._OFFSET] > 0
                        ? this.options[ListDataProviderView._OFFSET]
                        : 0;
            this[ListDataProviderView._INTERNAL_SORTCRITERIA] =
                this.options == null ? null : this.options[ListDataProviderView._SORTCRITERIA];
            this[ListDataProviderView._INTERNAL_DATAMAPPING] =
                this.options == null ? null : this.options[ListDataProviderView._DATAMAPPING];
            this[ListDataProviderView._INTERNAL_FETCHATTRIBUTES] =
                this.options == null ? null : this.options[ListDataProviderView._FETCHATTRIBUTES];
            this[ListDataProviderView._INTERNAL_FILTERCRITERION] =
                this.options == null ? null : this.options[ListDataProviderView._FILTERCRITERION];
            this._addEventListeners(dataProvider);
            if (this.options?.includeFilteredRowCount === 'enabled') {
                this._totalFilteredRowCountObservable = new ojobservable.BehaviorSubject({ type: 'notFetched' });
            }
            if (dataProvider.getCapability && !dataProvider.getCapability('filter')) {
                this._noFilterSupport = true;
            }
            Object.defineProperty(this, 'from', {
                set(value) {
                    this[ListDataProviderView._INTERNAL_FROM] = value;
                    this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
                },
                get() {
                    return this[ListDataProviderView._INTERNAL_FROM];
                },
                enumerable: true
            });
            Object.defineProperty(this, 'offset', {
                set(value) {
                    this[ListDataProviderView._INTERNAL_OFFSET] = value;
                    this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
                },
                get() {
                    return this[ListDataProviderView._INTERNAL_OFFSET];
                },
                enumerable: true
            });
            Object.defineProperty(this, 'sortCriteria', {
                set(value) {
                    this[ListDataProviderView._INTERNAL_SORTCRITERIA] = value;
                    this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
                },
                get() {
                    return this[ListDataProviderView._INTERNAL_SORTCRITERIA];
                },
                enumerable: true
            });
            Object.defineProperty(this, 'dataMapping', {
                set(value) {
                    this[ListDataProviderView._INTERNAL_DATAMAPPING] = value;
                    this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
                },
                get() {
                    return this[ListDataProviderView._INTERNAL_DATAMAPPING];
                },
                enumerable: true
            });
            Object.defineProperty(this, 'attributes', {
                set(value) {
                    this[ListDataProviderView._INTERNAL_FETCHATTRIBUTES] = value;
                    this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
                },
                get() {
                    return this[ListDataProviderView._INTERNAL_FETCHATTRIBUTES];
                },
                enumerable: true
            });
            Object.defineProperty(this, 'filterCriterion', {
                set(value) {
                    this[ListDataProviderView._INTERNAL_FILTERCRITERION] = value;
                    this.getTotalFilteredRowCountObservable()?.next({ type: 'notFetched' });
                    this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
                },
                get() {
                    return this[ListDataProviderView._INTERNAL_FILTERCRITERION];
                },
                enumerable: true
            });
        }
        getTotalFilteredRowCountObservable() {
            return this._totalFilteredRowCountObservable;
        }
        containsKeys(params) {
            if (this.dataProvider[ListDataProviderView._CONTAINSKEYS]) {
                return this.dataProvider[ListDataProviderView._CONTAINSKEYS](params);
            }
            else {
                return this.fetchByKeys(params).then((fetchByKeysResult) => {
                    const results = new Set();
                    params[ListDataProviderView._KEYS].forEach((key) => {
                        if (fetchByKeysResult[ListDataProviderView._RESULTS].get(key) != null) {
                            results.add(key);
                        }
                    });
                    return Promise.resolve(new this.ContainsKeysResults(this, params, results));
                });
            }
        }
        fetchByKeys(params) {
            const keys = params != null ? params[ListDataProviderView._KEYS] : null;
            let fetchAttributes = params != null ? params[ListDataProviderView._FETCHATTRIBUTES] : null;
            if (fetchAttributes == null) {
                fetchAttributes = this[ListDataProviderView._INTERNAL_FETCHATTRIBUTES];
            }
            const signal = params?.signal;
            const callback = (resolve) => {
                const updatedParams = new this.FetchByKeysParameters(this, keys, params, fetchAttributes);
                if (this.dataProvider[ListDataProviderView._FETCHBYKEYS]) {
                    return resolve(this.dataProvider[ListDataProviderView._FETCHBYKEYS](updatedParams).then((value) => {
                        const resultMap = value[ListDataProviderView._RESULTS];
                        const mappedResultMap = new Map();
                        resultMap.forEach((value, key) => {
                            const mappedItem = this._getMappedItems([value]);
                            mappedResultMap.set(key, mappedItem[0]);
                        });
                        return new this.FetchByKeysResults(this, updatedParams, mappedResultMap);
                    }));
                }
                else {
                    const options = new this.FetchListParameters(this, null, ListDataProviderView._DEFAULT_SIZE, null, null, fetchAttributes);
                    const resultMap = new Map();
                    const dataProviderAsyncIterator = this.dataProvider[ListDataProviderView._FETCHFIRST](options)[Symbol.asyncIterator]();
                    return resolve(this._fetchNextSet(params, dataProviderAsyncIterator, resultMap).then((resultMap) => {
                        const mappedResultMap = new Map();
                        resultMap.forEach((value, key) => {
                            const mappedItem = this._getMappedItems([value]);
                            mappedResultMap.set(key, mappedItem[0]);
                        });
                        return new this.FetchByKeysResults(this, updatedParams, mappedResultMap);
                    }));
                }
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchByOffset(params) {
            const offset = params != null ? params[ListDataProviderView._OFFSET] : null;
            const size = params != null ? params[ListDataProviderView._SIZE] : null;
            let fetchAttributes = params != null ? params[ListDataProviderView._FETCHATTRIBUTES] : null;
            if (fetchAttributes == null) {
                fetchAttributes = this[ListDataProviderView._INTERNAL_FETCHATTRIBUTES];
            }
            let sortCriteria = params != null ? params[ListDataProviderView._SORTCRITERIA] : null;
            if (sortCriteria == null) {
                sortCriteria = this[ListDataProviderView._INTERNAL_SORTCRITERIA];
            }
            this.getTotalFilteredRowCountObservable()?.next({ type: 'notFetched' });
            const mappedSortCriteria = this._getMappedSortCriteria(sortCriteria);
            const filterCriterion = this._combineFilters(params);
            const signal = params?.signal;
            const callback = (resolve) => {
                const mappedFilterCriterion = this._getMappedFilterCriterion(filterCriterion);
                const updatedParams = new this.FetchByOffsetParameters(this, offset, params, size, mappedSortCriteria, mappedFilterCriterion, fetchAttributes, signal, this.options?.includeFilteredRowCount);
                return resolve(this.dataProvider[ListDataProviderView._FETCHBYOFFSET](updatedParams).then((value) => {
                    const resultArray = value[ListDataProviderView._RESULTS];
                    const done = value[ListDataProviderView._DONE];
                    const totalFilteredRowCount = value[ListDataProviderView._TOTALFILTEREDROWCOUNT];
                    const mappedResultArray = new Array();
                    resultArray.forEach((value) => {
                        const mappedItem = this._getMappedItems([value]);
                        mappedResultArray.push(mappedItem[0]);
                    });
                    const resultFetchParams = value[ListDataProviderView._FETCHPARAMETERS];
                    const resultSortCriteria = resultFetchParams?.[ListDataProviderView._SORTCRITERIA];
                    const resultFilterCriterion = resultFetchParams?.[ListDataProviderView._FILTERCRITERION];
                    const unmappedResultSortCriteria = this._getUnmappedSortCriteria(resultSortCriteria);
                    const unmappedResultFilterCriterion = this._getUnmappedFilterCriterion(resultFilterCriterion);
                    this._updateFilteredRowCountObservable(totalFilteredRowCount, updatedParams);
                    return new this.FetchByOffsetResults(this, {
                        ...updatedParams,
                        sortCriteria: unmappedResultSortCriteria,
                        filterCriterion: unmappedResultFilterCriterion
                    }, mappedResultArray, done, totalFilteredRowCount);
                }));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchFirst(params) {
            // this fetchFirst applies the offset and from properties on the this.
            // If fetchByOffset is supported by the underlying dataprovider then that is used for offset.
            // Otherwise, fetches are made in chunks until from and offset are fulfilled.
            this.getTotalFilteredRowCountObservable()?.next({ type: 'notFetched' });
            const cachedData = {};
            cachedData[ListDataProviderView._ITEMS] = [];
            cachedData[ListDataProviderView._DONE] = false;
            cachedData[ListDataProviderView._STARTINDEX] = 0;
            cachedData[ListDataProviderView._LASTDONEHASDATA] = false;
            const size = params != null ? params[ListDataProviderView._SIZE] : null;
            const signal = params?.signal;
            let sortCriteria = params != null ? params[ListDataProviderView._SORTCRITERIA] : null;
            if (sortCriteria == null) {
                sortCriteria = this[ListDataProviderView._INTERNAL_SORTCRITERIA];
            }
            const mappedSortCriteria = this._getMappedSortCriteria(sortCriteria);
            const filterCriterion = this._combineFilters(params);
            const mappedFilterCriterion = this._getMappedFilterCriterion(filterCriterion);
            let fetchAttributes = params != null ? params[ListDataProviderView._FETCHATTRIBUTES] : null;
            if (fetchAttributes == null) {
                fetchAttributes = this[ListDataProviderView._INTERNAL_FETCHATTRIBUTES];
            }
            if (this[ListDataProviderView._INTERNAL_FROM] == null &&
                this[ListDataProviderView._INTERNAL_OFFSET] > 0) {
                let offset = this[ListDataProviderView._INTERNAL_OFFSET];
                return new this.AsyncIterable(this, new this.AsyncIterator(this, ((cachedData) => {
                    return () => {
                        const updatedParams = new this.FetchByOffsetParameters(this, offset, null, size, mappedSortCriteria, mappedFilterCriterion, fetchAttributes, signal, this.options?.includeFilteredRowCount);
                        return this.dataProvider[ListDataProviderView._FETCHBYOFFSET](updatedParams).then((result) => {
                            const results = result['results'];
                            offset = offset + results.length;
                            const mappedResult = this._getMappedItems(results);
                            this._cacheResult(cachedData, mappedResult);
                            cachedData[ListDataProviderView._DONE] = result[ListDataProviderView._DONE];
                            const totalFilteredRowCount = result[ListDataProviderView._TOTALFILTEREDROWCOUNT];
                            const data = mappedResult.map((value) => {
                                return value[ListDataProviderView._DATA];
                            });
                            const metadata = mappedResult.map((value) => {
                                return value[ListDataProviderView._METADATA];
                            });
                            const resultFetchParams = result[ListDataProviderView._FETCHPARAMETERS];
                            const resultSortCriteria = resultFetchParams != null
                                ? resultFetchParams[ListDataProviderView._SORTCRITERIA]
                                : null;
                            const resultFilterCriterion = resultFetchParams != null
                                ? resultFetchParams[ListDataProviderView._FILTERCRITERION]
                                : null;
                            const unmappedResultSortCriteria = this._getUnmappedSortCriteria(resultSortCriteria);
                            const unmappedResultFilterCriterion = this._getUnmappedFilterCriterion(resultFilterCriterion);
                            const resultParams = new this.FetchByOffsetParameters(this, this[ListDataProviderView._INTERNAL_OFFSET], null, size, unmappedResultSortCriteria, unmappedResultFilterCriterion);
                            this._updateFilteredRowCountObservable(totalFilteredRowCount, resultParams);
                            // if the dataprovider supports fetchByOffset then we use that to do an offset based fetch
                            if (cachedData[ListDataProviderView._DONE]) {
                                return Promise.resolve(new this.AsyncIteratorReturnResult(this, new this.FetchListResult(this, resultParams, data, metadata, totalFilteredRowCount)));
                            }
                            return Promise.resolve(new this.AsyncIteratorYieldResult(this, new this.FetchListResult(this, resultParams, data, metadata, totalFilteredRowCount)));
                        });
                    };
                })(cachedData), params));
            }
            else {
                const updatedParams = new this.FetchListParameters(this, params, size, mappedSortCriteria, mappedFilterCriterion, fetchAttributes, signal, this.options?.includeFilteredRowCount);
                const cachedAsyncIterator = this.dataProvider[ListDataProviderView._FETCHFIRST](updatedParams)[Symbol.asyncIterator]();
                return new this.AsyncIterable(this, new this.AsyncIterator(this, ((cachedData, cachedAsyncIterator) => {
                    return () => {
                        // If the underlying DP has returned done=true with data in the last call,
                        // we have modified it to returned done=false with the data.
                        // So just return done=true with empty data on this call.
                        // However, we want to reset _LASTDONEHASDATA because live iterator is
                        // supposed to allow calling next again after done=true.
                        if (cachedData[ListDataProviderView._LASTDONEHASDATA]) {
                            cachedData[ListDataProviderView._LASTDONEHASDATA] = false;
                            return Promise.resolve(new this.AsyncIteratorReturnResult(this, new this.FetchListResult(this, params, [], [], this._totalFilteredRowCount)));
                        }
                        return cachedAsyncIterator.next().then((result) => {
                            let resultValue = result[ListDataProviderView._VALUE];
                            // It's valid for iterator to return null value when done=true
                            if (!resultValue) {
                                resultValue = { data: [], metadata: [], fetchParameters: null };
                            }
                            const data = resultValue[ListDataProviderView._DATA];
                            const totalFilteredRowCount = resultValue.totalFilteredRowCount;
                            const metadata = resultValue[ListDataProviderView._METADATA];
                            const items = data.map((value, index) => {
                                return new this.Item(this, metadata[index], data[index]);
                            });
                            if (this._noFilterSupport) {
                                this._filterResult(mappedFilterCriterion, items);
                            }
                            // apply any mapping defined in the DataMapping parameter
                            const mappedResult = this._getMappedItems(items);
                            this._cacheResult(cachedData, mappedResult);
                            cachedData[ListDataProviderView._DONE] = result[ListDataProviderView._DONE];
                            const size = params != null ? params[ListDataProviderView._SIZE] : null;
                            const offset = params != null ? params[ListDataProviderView._OFFSET] : null;
                            const resultFetchParams = resultValue[ListDataProviderView._FETCHPARAMETERS];
                            const resultSortCriteria = resultFetchParams != null
                                ? resultFetchParams[ListDataProviderView._SORTCRITERIA]
                                : null;
                            const resultFilterCriterion = resultFetchParams != null
                                ? resultFetchParams[ListDataProviderView._FILTERCRITERION]
                                : null;
                            const unmappedResultSortCriteria = this._getUnmappedSortCriteria(resultSortCriteria);
                            const unmappedResultFilterCriterion = this._getUnmappedFilterCriterion(resultFilterCriterion);
                            const resultParams = new this.FetchListParameters(this, params, size, unmappedResultSortCriteria, unmappedResultFilterCriterion);
                            return this._fetchUntilKey(resultParams, this[ListDataProviderView._INTERNAL_FROM], cachedData, cachedAsyncIterator).then(() => {
                                return this._fetchUntilOffset(resultParams, this[ListDataProviderView._INTERNAL_OFFSET] +
                                    cachedData[ListDataProviderView._STARTINDEX], data.length, cachedData, cachedAsyncIterator, totalFilteredRowCount);
                            });
                        });
                    };
                })(cachedData, cachedAsyncIterator), params));
            }
        }
        getCapability(capabilityName) {
            return this.dataProvider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this.dataProvider.getTotalSize();
        }
        isEmpty() {
            return this.dataProvider.isEmpty();
        }
        /**
         * Fetches the next block
         */
        _fetchNextSet(params, dataProviderAsyncIterator, resultMap) {
            return dataProviderAsyncIterator.next().then((result) => {
                let value = result[ListDataProviderView._VALUE];
                if (!value) {
                    value = { data: [], metadata: [], fetchParameters: null };
                }
                const data = value[ListDataProviderView._DATA];
                const metadata = value[ListDataProviderView._METADATA];
                const keys = metadata.map((metadata) => {
                    return metadata[ListDataProviderView._KEY];
                });
                let foundAllKeys = true;
                params[ListDataProviderView._KEYS].forEach((findKey) => {
                    if (!resultMap.has(findKey)) {
                        keys.map((key, index) => {
                            if (oj.Object.compareValues(key, findKey)) {
                                resultMap.set(findKey, new this.Item(this, metadata[index], data[index]));
                            }
                        });
                    }
                    if (!resultMap.has(findKey)) {
                        foundAllKeys = false;
                    }
                });
                if (!foundAllKeys && !result[ListDataProviderView._DONE]) {
                    return this._fetchNextSet(params, dataProviderAsyncIterator, resultMap);
                }
                else {
                    return resultMap;
                }
            });
        }
        /**
         * Fetches until we find the key
         */
        _fetchUntilKey(params, key, cachedData, cachedAsyncIterator) {
            if (key != null) {
                // first check if the key is in our cache
                const resultItems = cachedData[ListDataProviderView._ITEMS].filter((resultItem) => {
                    if (oj.KeyUtils.equals(resultItem[ListDataProviderView._METADATA][ListDataProviderView._KEY], key)) {
                        return true;
                    }
                });
                if (resultItems.length > 0) {
                    // if the key is in our cache, then trim the cache so that it starts from the key
                    const itemIndex = cachedData[ListDataProviderView._ITEMS].indexOf(resultItems[0]);
                    cachedData[ListDataProviderView._ITEMS] = cachedData[ListDataProviderView._ITEMS].slice(itemIndex, cachedData[ListDataProviderView._ITEMS].length);
                }
                else if (!cachedData[ListDataProviderView._DONE]) {
                    // if the key is not in our cache and we are not done then fetch the next block and call _fetchUntilKey again.
                    return cachedAsyncIterator.next().then((nextResult) => {
                        let value = nextResult[ListDataProviderView._VALUE];
                        if (!value) {
                            value = { data: [], metadata: [], fetchParameters: null };
                        }
                        const data = value[ListDataProviderView._DATA];
                        const metadata = value[ListDataProviderView._METADATA];
                        const items = data.map((value, index) => {
                            return new this.Item(this, metadata[index], data[index]);
                        });
                        const mappedResult = this._getMappedItems(items);
                        this._cacheResult(cachedData, mappedResult);
                        cachedData[ListDataProviderView._DONE] = nextResult[ListDataProviderView._DONE];
                        return this._fetchUntilKey(nextResult[ListDataProviderView._FETCHPARAMETERS], mappedResult[ListDataProviderView._KEYS], cachedData, cachedAsyncIterator);
                    });
                }
                else {
                    // if we are done then this means that the key is not in the entire data set
                    cachedData[ListDataProviderView._ITEMS] = [];
                }
            }
            return Promise.resolve(null);
        }
        /**
         * Fetches until we fulfill the offset
         */
        _fetchUntilOffset(params, offset, resultSize, cachedData, cachedAsyncIterator, totalFilteredRowCount) {
            const fetchSize = params != null
                ? params[ListDataProviderView._SIZE] > 0
                    ? params[ListDataProviderView._SIZE]
                    : resultSize
                : resultSize;
            offset = offset > 0 ? offset : 0;
            const cachedItems = cachedData[ListDataProviderView._ITEMS].slice(offset, offset + fetchSize);
            if (this._noFilterSupport) {
                const mappedFilterCriterion = this._getMappedFilterCriterion(params[ListDataProviderView._FILTERCRITERION]);
                this._filterResult(mappedFilterCriterion, cachedItems);
            }
            // Only recurse if there is a size parameter we haven't satisified and the iterator is not done.
            // Otherwise just return whatever data we've got.
            if (params &&
                params[ListDataProviderView._SIZE] > 0 &&
                cachedItems.length < fetchSize &&
                !cachedData[ListDataProviderView._DONE]) {
                return cachedAsyncIterator.next().then((nextResult) => {
                    let value = nextResult[ListDataProviderView._VALUE];
                    if (!value) {
                        value = { data: [], metadata: [], fetchParameters: null };
                    }
                    const data = value[ListDataProviderView._DATA];
                    const metadata = value[ListDataProviderView._METADATA];
                    const items = data.map((value, index) => {
                        return new this.Item(this, metadata[index], data[index]);
                    });
                    if (this._noFilterSupport) {
                        const mappedFilterCriterion = this._getMappedFilterCriterion(params[ListDataProviderView._FILTERCRITERION]);
                        this._filterResult(mappedFilterCriterion, items);
                    }
                    if (nextResult.done && items.length > 0) {
                        // This is coming from a DP that doesn't follow AsyncIterable spec.
                        // Just remember it and ignore the done flag for this call.
                        // We will return done=true with empty data on the next call.
                        cachedData[ListDataProviderView._LASTDONEHASDATA] = true;
                    }
                    const mappedResult = this._getMappedItems(items);
                    this._cacheResult(cachedData, mappedResult);
                    cachedData[ListDataProviderView._DONE] = nextResult[ListDataProviderView._DONE];
                    return this._fetchUntilOffset(params, offset, data.length, cachedData, cachedAsyncIterator, totalFilteredRowCount);
                });
            }
            return this._createResultPromise(params, cachedData, cachedItems, totalFilteredRowCount);
        }
        _createResultPromise(params, cachedData, cachedItems, totalFilteredRowCount) {
            cachedData[ListDataProviderView._STARTINDEX] =
                cachedData[ListDataProviderView._STARTINDEX] + cachedItems.length;
            const data = cachedItems.map((item) => {
                return item[ListDataProviderView._DATA];
            });
            const metadata = cachedItems.map((item) => {
                return item[ListDataProviderView._METADATA];
            });
            // 1. If the underlying DP returns done=true with data, it's not compliant with the AsyncIterable spec.
            // We want to set done=false with data in this case and return done=true with empty data on the next call.
            // 2. If the underlying DP returns done=false with empty data, it is a valid condition,
            // so we want to return that as is.
            let isDone = false;
            if (cachedData[ListDataProviderView._DONE]) {
                if (data.length === 0) {
                    isDone = true;
                }
            }
            this._updateFilteredRowCountObservable(totalFilteredRowCount, params);
            if (isDone) {
                return Promise.resolve(new this.AsyncIteratorReturnResult(this, new this.FetchListResult(this, params, data, metadata, totalFilteredRowCount)));
            }
            return Promise.resolve(new this.AsyncIteratorYieldResult(this, new this.FetchListResult(this, params, data, metadata, totalFilteredRowCount)));
        }
        /**
         * Cache the data and keys
         */
        _cacheResult(cachedData, items) {
            items.forEach((value) => {
                cachedData[ListDataProviderView._ITEMS].push(value);
            });
        }
        _filterResult(filterCriterion, items) {
            if (filterCriterion) {
                if (!filterCriterion.filter) {
                    filterCriterion = ojdataprovider.FilterFactory.getFilter({ filterDef: filterCriterion });
                }
                let i = items.length - 1;
                while (i >= 0) {
                    if (!filterCriterion.filter(items[i][ListDataProviderView._DATA])) {
                        items.splice(i, 1);
                    }
                    i--;
                }
            }
        }
        /**
         * Apply DataMapping to the items
         */
        _getMappedItems(items) {
            if (this[ListDataProviderView._INTERNAL_DATAMAPPING] != null) {
                const mapFields = this[ListDataProviderView._INTERNAL_DATAMAPPING][ListDataProviderView._MAPFIELDS];
                if (mapFields != null && items != null && items.length > 0) {
                    const mappedItems = items.map((value) => {
                        return mapFields.bind(this)(value);
                    });
                    return mappedItems;
                }
            }
            return items;
        }
        /**
         * combine filters from various sources
         */
        _combineFilters(params) {
            const filters = [];
            let i = 0;
            if (params != null && params[ListDataProviderView._FILTERCRITERION] != null) {
                filters[i] = params[ListDataProviderView._FILTERCRITERION];
                i++;
            }
            if (this[ListDataProviderView._INTERNAL_FILTERCRITERION] != null) {
                filters[i] = this[ListDataProviderView._INTERNAL_FILTERCRITERION];
            }
            let filterCriterion;
            if (filters.length == 0) {
                filterCriterion = null;
            }
            else if (filters.length == 1) {
                filterCriterion = filters[0];
            }
            else {
                filterCriterion = ojdataprovider.FilterFactory.getFilter({ filterDef: { op: '$and', criteria: filters } });
            }
            return filterCriterion;
        }
        /**
         * Apply mapping to the filterCriterion
         */
        _getMappedFilterCriterion(filterCriterion) {
            if (this[ListDataProviderView._INTERNAL_DATAMAPPING] != null) {
                const mappedFilterCriterion = this[ListDataProviderView._INTERNAL_DATAMAPPING][ListDataProviderView._MAPFILTERCRITERION];
                if (mappedFilterCriterion != null && filterCriterion != null) {
                    return mappedFilterCriterion(filterCriterion);
                }
            }
            return filterCriterion;
        }
        /**
         * Apply mapping to the sortCriteria
         */
        _getMappedSortCriteria(sortCriteria) {
            if (this[ListDataProviderView._INTERNAL_DATAMAPPING] != null) {
                const mapSortCriteria = this[ListDataProviderView._INTERNAL_DATAMAPPING][ListDataProviderView._MAPSORTCRITERIA];
                if (mapSortCriteria != null && sortCriteria != null && sortCriteria.length > 0) {
                    return mapSortCriteria(sortCriteria);
                }
            }
            return sortCriteria;
        }
        /**
         * Unmapping the sortCriteria
         */
        _getUnmappedSortCriteria(sortCriteria) {
            if (this[ListDataProviderView._INTERNAL_DATAMAPPING] != null) {
                const unmapSortCriteria = this[ListDataProviderView._INTERNAL_DATAMAPPING][ListDataProviderView._UNMAPSORTCRITERIA];
                if (unmapSortCriteria != null && sortCriteria != null && sortCriteria.length > 0) {
                    return unmapSortCriteria(sortCriteria);
                }
            }
            return sortCriteria;
        }
        /**
         * Unmapping the FilterCriterion
         */
        _getUnmappedFilterCriterion(filter) {
            if (this[ListDataProviderView._INTERNAL_DATAMAPPING] != null) {
                const unmapFilterCriterion = this[ListDataProviderView._INTERNAL_DATAMAPPING][ListDataProviderView._UNMAPFILTERCRITERION];
                if (unmapFilterCriterion != null && filter != null) {
                    return unmapFilterCriterion(filter);
                }
            }
            return filter;
        }
        /**
         * Add event listeners
         */
        _addEventListeners(dataprovider) {
            dataprovider[ListDataProviderView._ADDEVENTLISTENER](ListDataProviderView._REFRESH, (event) => {
                this.dispatchEvent(event);
            });
            dataprovider[ListDataProviderView._ADDEVENTLISTENER](ListDataProviderView._MUTATE, (event) => {
                this.dispatchEvent(event);
            });
        }
        /**
         * Updates filtered row count observable
         */
        _updateFilteredRowCountObservable(totalFilteredRowCount, fetchParameters) {
            if (this.options?.includeFilteredRowCount === 'enabled' ||
                (fetchParameters && fetchParameters.includeFilteredRowCount === 'enabled')) {
                let rowCount = {
                    type: 'unknown'
                };
                if (totalFilteredRowCount != null && totalFilteredRowCount >= 0) {
                    rowCount = {
                        type: 'exact',
                        count: totalFilteredRowCount
                    };
                }
                this.getTotalFilteredRowCountObservable()?.next(rowCount);
            }
        }
    }
    ListDataProviderView._KEY = 'key';
    ListDataProviderView._KEYS = 'keys';
    ListDataProviderView._DATA = 'data';
    ListDataProviderView._STARTINDEX = 'startIndex';
    ListDataProviderView._SORT = 'sort';
    ListDataProviderView._INTERNAL_SORTCRITERIA = '_sortCriteria';
    ListDataProviderView._SORTCRITERIA = 'sortCriteria';
    ListDataProviderView._INTERNAL_FILTERCRITERION = '_filterCriterion';
    ListDataProviderView._FILTERCRITERION = 'filterCriterion';
    ListDataProviderView._METADATA = 'metadata';
    ListDataProviderView._ITEMS = 'items';
    ListDataProviderView._INTERNAL_FROM = '_from';
    ListDataProviderView._INTERNAL_OFFSET = '_offset';
    ListDataProviderView._FROM = 'from';
    ListDataProviderView._OFFSET = 'offset';
    ListDataProviderView._REFRESH = 'refresh';
    ListDataProviderView._MUTATE = 'mutate';
    ListDataProviderView._SIZE = 'size';
    ListDataProviderView._FETCHPARAMETERS = 'fetchParameters';
    ListDataProviderView._VALUE = 'value';
    ListDataProviderView._DONE = 'done';
    ListDataProviderView._LASTDONEHASDATA = 'lastDoneHasData';
    ListDataProviderView._INTERNAL_DATAMAPPING = '_dataMapping';
    ListDataProviderView._DATAMAPPING = 'dataMapping';
    ListDataProviderView._MAPFIELDS = 'mapFields';
    ListDataProviderView._MAPSORTCRITERIA = 'mapSortCriteria';
    ListDataProviderView._MAPFILTERCRITERION = 'mapFilterCriterion';
    ListDataProviderView._UNMAPSORTCRITERIA = 'unmapSortCriteria';
    ListDataProviderView._UNMAPFILTERCRITERION = 'unmapFilterCriterion';
    ListDataProviderView._RESULTS = 'results';
    ListDataProviderView._CONTAINSPARAMETERS = 'containsParameters';
    ListDataProviderView._DEFAULT_SIZE = 25;
    ListDataProviderView._CONTAINSKEYS = 'containsKeys';
    ListDataProviderView._FETCHBYKEYS = 'fetchByKeys';
    ListDataProviderView._FETCHBYOFFSET = 'fetchByOffset';
    ListDataProviderView._FETCHFIRST = 'fetchFirst';
    ListDataProviderView._ADDEVENTLISTENER = 'addEventListener';
    ListDataProviderView._INTERNAL_FETCHATTRIBUTES = '_attributes';
    ListDataProviderView._FETCHATTRIBUTES = 'attributes';
    ListDataProviderView._TOTALFILTEREDROWCOUNT = 'totalFilteredRowCount';
    ListDataProviderView._SIGNAL = 'signal';
    ListDataProviderView._INCLUDEFILTEREDROWCOUNT = 'includeFilteredRowCount';
    ojeventtarget.EventTargetMixin.applyMixin(ListDataProviderView);
    oj._registerLegacyNamespaceProp('ListDataProviderView', ListDataProviderView);

    return ListDataProviderView;

});


define('ojs/ojcss',['css'], function (cssmodule) { 'use strict';

  const cssAPI = {};

  cssAPI.load = function (name, req, onload, config) {
    var skipcssload = false;
    if (config) {
      var ojcss = config.ojcss;
      var filename = name + '.css';
      if (this.isExcluded(filename, ojcss)) {
        skipcssload = true;
      }
    }
    if (!skipcssload) {
      // delegate the call to the CSS plugin
      // eslint-disable-next-line no-undef
      cssmodule.load(name, req, onload, config);
    } else {
      // signal to require that we are done "loading" the resource
      onload(name);
    }
  };

  // used for building with the optimizer r.js
  cssAPI.pluginBuilder = 'css-builder';

  cssAPI.normalize = cssmodule.normalize;

  /**
   * This function will check if the css file (specified by the filepath parameter) should be excluded from the css load step.
   * @param {string} filepath the name of the css file that the plugin aught to load.
   * @param {object} ojcss the value of the ojcss key in the requirejs config option
   * @ignore
   * @private
   */

  cssAPI.isExcluded = function (filepath, ojcss) {
    var excluded = false;
    // see if we have an explicit include directive
    if (ojcss && ojcss.include) {
      var include = ojcss.include;
      if (Array.isArray(include)) {
        if (include.length > 0) {
          excluded = true;
          for (var j = 0; j < include.length; j++) {
            var includepath = include[j];
            if (filepath.substr(0, includepath.length) === includepath) {
              excluded = false;
              break;
            }
          }
        }
      } else {
        var includePattern = this.makeRegExp(include);
        if (includePattern.test(filepath)) {
          excluded = false;
        }
      }
    }

    if (!excluded && ojcss && ojcss.exclude) {
      var exclude = ojcss.exclude;
      if (Array.isArray(exclude)) {
        for (var i = 0; i < exclude.length; i++) {
          var excludepath = exclude[i];
          if (filepath.substr(0, excludepath.length) === excludepath) {
            excluded = true;
            break;
          }
        }
      } else {
        var excludePattern = this.makeRegExp(exclude);
        if (excludePattern.test(filepath)) {
          excluded = true;
        }
      }
    }

    return excluded;
  };

  /**
   * Creates a RegExp object from a given string pattern.
   * @param {string} pattern A regular expression
   */
  cssAPI.makeRegExp = function (pattern) {
    var regExp = null;

    if (pattern) {
      regExp = typeof pattern === 'string' ? new RegExp(pattern) : pattern;
    }

    return regExp;
  };

  return cssAPI;

});


define('ojs/ojpreact-patch',['exports'], function (exports) { 'use strict';

    const OJ_REPLACER = Symbol();
    const OJ_POPUP = Symbol();
    const OJ_SLOT_REMOVE = Symbol();
    /**
     * Patches .removeChild() on the slot's parent to delegate slot removal to an implementation
     * that was provided by slot management code via the OJ_SLOT_REMOVE symbol. That implementation uses
     * ref counting to decide whether the slot node can be removed. The need for ref counting arises from
     * the fact that the slot nodes will not be simply discarded after unmount as normal
     * live DOM nodes that are created by VDom would. Consider an example where the slot node needs to
     * be wrapped in a <div> during component re-render. The VDom engine will clone the slot VNode and
     * place its element (slot node) inside the newly created DIV. Then the old VNode will be unmounted,
     * and .removeChild() will be called in the current parent of the slot node. This would remove the slot
     * node what just got inserted into the <div>. The ref counting allows us to determine when the slot
     * node is truly no longer used and thus can be safely removed.
     *
     * Note that the patch will be installed once, but will never be uninstalled
     * @ignore
     */
    function patchSlotParent(parent) {
        if (!parent[_PATCHED]) {
            parent[_PATCHED] = true;
            const original = parent.removeChild;
            parent.removeChild = (child) => {
                const handler = child[OJ_SLOT_REMOVE];
                if (handler) {
                    handler();
                    return null;
                }
                return original.call(parent, child);
            };
        }
    }
    /**
     * patches .firstChild on the popup's parent element to work around Preact's placeChild() using .firstChild to get the
     * first physical element within the parent (as opposed to getting an element from child VDOM). These two may not match
     * when the poupup framework moves the popup element into the layer container.
     * @ignore
     */
    function patchPopupParent(parent) {
        if (!parent[_PATCHED]) {
            parent[_PATCHED] = true;
            Object.defineProperty(parent, 'firstChild', {
                get() {
                    let child = parent.childNodes[0];
                    if (!child) {
                        return null;
                    }
                    return child[OJ_POPUP] || child;
                },
                enumerable: true
            });
        }
    }
    const _PATCHED = Symbol();

    exports.OJ_POPUP = OJ_POPUP;
    exports.OJ_SLOT_REMOVE = OJ_SLOT_REMOVE;
    exports.patchPopupParent = patchPopupParent;
    exports.patchSlotParent = patchSlotParent;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojlayerutils',['exports', 'ojs/ojcore-base'], function (exports, oj) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    /**
     * Contains utility functions intended to be used to configure layer
     * @ojmodulecontainer ojlayerutils
     * @ojtsmodule
     * @ojhidden
     * @since 19.0.0
     */
    /**
     * Function to get layer context. This context allows to determines if legacy popup support is available  or if it should use pure corepack solution with no legacy dependency
     *
     * @ojexports
     * @memberof ojlayerutils
     * @ojsignature {target: "Type",
     *               value: "(baseElem:HTMLElement): { getRootLayerHost?:(priority?:'popup' | 'dialog' | 'messages' | 'tooltip') => Element;
     *               getLayerHost?:(priority?:'popup' | 'dialog' | 'messages' | 'tooltip') => Element; onLayerUnmount?:(element:HTMLElement) => void; }"}
     * @method
     * @name getLayerContext
     */

    const NEW_DEFAULT_LAYER_ID = '__root_layer_host';
    const getLayerHost = (element, level, priority) => {
        let parentLayerHost = null;
        if (level === 'nearestAncestor') {
            parentLayerHost = element.closest('[data-oj-layer]');
        }
        if (parentLayerHost) {
            return parentLayerHost;
        }
        let rootLayerHost = document.getElementById(NEW_DEFAULT_LAYER_ID);
        // get/create the default layer host
        if (!rootLayerHost) {
            rootLayerHost = document.createElement('div');
            rootLayerHost.setAttribute('id', NEW_DEFAULT_LAYER_ID);
            // explicitly specifying a binding provider of 'preact' here otherwise
            // custom elements inside the Layer may walk up the DOM and think that
            // they are in a ko-activated subtree and wait forever for bindings to be applied
            rootLayerHost.setAttribute('data-oj-binding-provider', 'preact');
            rootLayerHost.style.position = 'relative';
            rootLayerHost.style.zIndex = '999';
            document.body.prepend(rootLayerHost); // @HTMLUpdateOK
        }
        return rootLayerHost;
    };
    function getLayerContext(baseElem) {
        const layerHostResolver = oj.VLayerUtils ? oj.VLayerUtils.getLayerHost : getLayerHost;
        const onLayerUnmountResolver = oj.VLayerUtils ? oj.VLayerUtils.onLayerUnmount : null;
        return {
            getRootLayerHost: layerHostResolver.bind(null, baseElem, 'topLevel'),
            getLayerHost: layerHostResolver.bind(null, baseElem, 'nearestAncestor'),
            onLayerUnmount: onLayerUnmountResolver?.bind(null, baseElem)
        };
    }

    exports.getLayerContext = getLayerContext;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtranslationbundleutils',['exports', 'ojs/ojconfig', '@oracle/oraclejet-preact/utils/UNSAFE_matchTranslationBundle', '@oracle/oraclejet-preact/resources/nls/supportedLocales'], function (exports, ojconfig, UNSAFE_matchTranslationBundle, supportedLocales) { 'use strict';

    supportedLocales = supportedLocales && Object.prototype.hasOwnProperty.call(supportedLocales, 'default') ? supportedLocales['default'] : supportedLocales;

    const SUPPORTED_LOCALES = new Set(supportedLocales);
    const _loaders = new Map();
    const _promises = new Map();
    /**
     * Registers translation bundle loaders.
     * This function is meant to be called during the registration of the VComponent
     * custom element if that custom element or its dependencies are using V2 translation
     * bundles.
     *
     * @param bundles a JS object with keys representing bundle Ids and values representing loaders
     * @private
     */
    const registerTranslationBundleLoaders = (bundles) => {
        const keys = Object.keys(bundles);
        keys.forEach((key) => {
            if (!_loaders.has(key)) {
                _loaders.set(key, bundles[key]);
            }
        });
    };
    /**
     * Returns a Promise that resolves to a translationBundle for the current locale.
     *
     * @param bundleId - the Id of the bundle
     * @returns a Promise that will resolve to the translation bundle contents
     * @private
     */
    const getTranslationBundlePromise = (bundleId) => {
        let promise = _promises.get(bundleId);
        if (!promise) {
            promise = _loaders.get(bundleId)(getTranslationBundleLocale(bundleId));
            _promises.set(bundleId, promise);
        }
        return promise;
    };
    /**
     * Returns a Promise for all currently registered V2 translation bundles
     *
     * @returns a Promise that will resolve when all pending V2 translation bundles are loaded
     * @private
     */
    const loadAllPendingBundles = () => {
        // We are not caching the Promise because some new components using other bundle Ids may be registered later
        const promises = Array.from(_loaders.keys(), (bundleId) => getTranslationBundlePromise(bundleId));
        return Promise.all(promises);
    };
    /**
     * Finds the best match for a given locale within a set of supported locales.
     * @param {string} locale - user's locale
     * @param {Set} supportedLocales - the set of supported locales
     * @return {string|null} a locale representing the best match for the user's locale, or null if no match was found
     */
    const matchTranslationBundle = (locale, supportedLocales) => UNSAFE_matchTranslationBundle.matchTranslationBundle([locale], supportedLocales);
    /**
     * This is an IIFE which returns a function that returns the best-matching locale amongst the supported
     * locales based on the current RT locale (as indicated by ojconfig).  This matching is done once and the result
     * is stored in closure scope (hence the IIFE).
     *
     * Note that getTranslationBundleLocale() currently handles ONLY '@oracle/oraclejet-preact' translation bundle.
     * However, the rest of the methods in this module are ready to deal with other bundle Ids.
     * To support random bundle Ids, we will most likely have to enhance our custom TSC to inlude the list of supported
     * locales for each entry in the translation bundle map.
     *
     * @private
     */
    const getTranslationBundleLocale = (() => {
        let translationBundleLocale;
        return (bundleId) => {
            if (translationBundleLocale === undefined) {
                translationBundleLocale = UNSAFE_matchTranslationBundle.matchTranslationBundle([ojconfig.getLocale()], SUPPORTED_LOCALES);
            }
            return translationBundleLocale;
        };
    })();

    exports.getTranslationBundlePromise = getTranslationBundlePromise;
    exports.loadAllPendingBundles = loadAllPendingBundles;
    exports.matchTranslationBundle = matchTranslationBundle;
    exports.registerTranslationBundleLoaders = registerTranslationBundleLoaders;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojvcomponent',['require', 'exports', 'preact/compat', 'preact/jsx-runtime', 'preact', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry', 'preact/hooks', '@oracle/oraclejet-preact/UNSAFE_Environment', 'ojs/ojcore-base', 'ojs/ojpreact-patch', 'ojs/ojlogger', 'ojs/ojmetadatautils', '@oracle/oraclejet-preact/UNSAFE_Layer', 'ojs/ojlayerutils', 'ojs/ojconfig', 'ojs/ojcontext', 'ojs/ojtranslationbundleutils', '@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext'], function (require, exports, compat, jsxRuntime, preact, ojcustomelementUtils, ojcustomelementRegistry, hooks, UNSAFE_Environment, oj, ojpreactPatch, Logger, MetadataUtils, UNSAFE_Layer, ojlayerutils, ojconfig, Context, ojtranslationbundleutils, UNSAFE_useBusyStateContext) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = {};
      if (e) {
        Object.keys(e).forEach(function (k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        });
      }
      n['default'] = e;
      return n;
    }
  }

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  let _slotIdCount = 0;
  let _originalCreateElementNS;
  // A map of host elements to the set of active slot Ids. Note the the same slot
  // node with an Id may be shared by several components if the parent componenent
  // redistributes slots to a child component.
  // Although the parent and child are not really being re-rendered on the same tick together today,
  // each VComponent will get a different VNode for the redistributed slot, and it seems safer to
  // account for active slots on a per-host-component basis.
  const _ACTIVE_SLOTS_PER_ELEMENT = new Map();
  // Active Slot nodes to support the .createElement() override. See the comment above for _ACTIVE_SLOTS_PER_ELEMENT for the
  // explanation on how the same slot node may be rendered by more than one VComponent and may have more than one VNode
  // associated with it.
  // This map will maintain each slot node while its VNodes are being rendered. All slot nodes will be removed together when
  // all their associated VNodes are done rendering.
  const _ACTIVE_SLOTS = new Map();
  const _OJ_SLOT_ID = Symbol();
  const _OJ_SLOT_PREFIX = '@oj_s';
  /**
   * Wraps a live DOM node in a VNode, so that a custom element slot can be
   * inserted inside of a component that has a VDom-based renderer.
   * The overall strategy is as follows:
   * 1. Generate a unique id for each slot element.
   * 2. Temporarily place slot element into a static map under its unique id.
   * 3. With the unique id from (1), generate a unique, fake element name that we are going to pass into Preact
   *    as VNode's type.
   * 4. Temporarily patch document.createElement() for 'fake' names that follow a certain pattern.
   * 5. When we see attempts to create the fake element, instead of actually creating a new element, return the existing slot element.
   * 6. Remove our document.createElement patch and remove slot elements from the static map as soon as Preact reaches the commit phase.
   * @ignore
   */
  function convertToVNode(hostElement, node, handleSlotMount, handleSlotUnmount) {
      const key = _getSlotKey(node);
      let _refCount = 0;
      function _incrementRefCount() {
          _refCount++;
      }
      function _decrementRefCount() {
          _refCount--;
          if (_refCount < 0) {
              throw new ojcustomelementUtils.JetElementError(hostElement, 'Slot reference count underflow');
          }
          if (_refCount === 0) {
              handleSlotUnmount(node);
          }
          else {
              // Recent Preact versions invoke unmount callbacks for removed nodes before invoking
              // mount callbacks for added nodes.
              // Note that we have been always patching the parent element in the mount callback.
              // The patching is done to short-circuit .removeChild() for a slot whose ref count
              // indicates that it has already been re-inserted elsewhere. The code below is now calling patchSlotParent()
              // in the *unmount* callback to handle the case where it is invoked when the slot has already been
              // moved to the new location.
              // Note that patchSlotParent() is safe to call on the same element multiple times (it will be a no-op). It will
              // also not affect removal of child elements that are not slots.
              const parent = node.parentElement;
              // The fact that we check for .parentElement here and are not making the check in the mount case is intentional:
              // if Preact restores the old behavior with mounts always coming first, the slot element may be relocated to the
              // new location before the unmount callback for the old location is invoked. Also, want to see the exception in the
              // mount case if our assumptions are wrong.
              if (parent) {
                  ojpreactPatch.patchSlotParent(parent);
              }
          }
      }
      const slotRemoveHandler = () => {
          // The only way the slots should be removed if by parking, so
          // short-circuit all removes here
          return null;
      };
      node[ojpreactPatch.OJ_SLOT_REMOVE] = slotRemoveHandler;
      const ref = function (n) {
          if (n) {
              _incrementRefCount();
              ojpreactPatch.patchSlotParent(node.parentElement);
              handleSlotMount(node);
          }
          else {
              _decrementRefCount();
          }
      };
      // The slot's VNode is a render function that always returns a VNode
      // with the ref and key from the closure scope
      // Using a function is needed because Preact does not copy the 'ref' property
      // when it clones a VNode with an existing DOM element. This scenario occurs when
      // the slot is being moved to a different parent element upon component's re-render
      return preact.h(() => {
          _registerSlot(hostElement, key, node);
          // we need to increment ref count on rendering to accommodate a change in Preact
          // where the unmounts get reported before mounts
          _incrementRefCount();
          hooks.useLayoutEffect(() => {
              _unregisterSlot(hostElement, key);
              _decrementRefCount();
          });
          return preact.h(key, { ref, key });
      }, null);
  }
  function _registerSlot(hostElement, id, node) {
      let activeSlots = _ACTIVE_SLOTS_PER_ELEMENT.get(hostElement);
      const wasEmpty = _ACTIVE_SLOTS_PER_ELEMENT.size === 0;
      if (!activeSlots) {
          activeSlots = new Set();
          _ACTIVE_SLOTS_PER_ELEMENT.set(hostElement, activeSlots);
      }
      else if (activeSlots.has(id)) {
          _logInvalidSlotRenderError(hostElement, node);
      }
      activeSlots.add(id);
      _ACTIVE_SLOTS.set(id, node);
      if (wasEmpty) {
          _patchCreateElement();
      }
  }
  function _logInvalidSlotRenderError(hostElement, node) {
      const slotName = node.nodeType === Node.ELEMENT_NODE ? node.getAttribute('slot') ?? '' : '';
      Logger.error(`Custom Element "<${hostElement.localName}>" with id "${hostElement.id}" 
  is distributing slot "${slotName}" more than once`);
  }
  function _unregisterSlot(hostElement, id) {
      const activeSlots = _ACTIVE_SLOTS_PER_ELEMENT.get(hostElement);
      activeSlots?.delete(id);
      if (activeSlots?.size === 0) {
          _ACTIVE_SLOTS_PER_ELEMENT.delete(hostElement);
      }
      if (_ACTIVE_SLOTS_PER_ELEMENT.size === 0) {
          // empty the map by recreating it
          _ACTIVE_SLOTS.clear();
          _restoreCreateElement();
      }
  }
  function _getSlotKey(n) {
      let key = n[_OJ_SLOT_ID];
      if (key === undefined) {
          key = _OJ_SLOT_PREFIX + _slotIdCount++;
          n[_OJ_SLOT_ID] = key;
      }
      return key;
  }
  function _patchCreateElement() {
      _originalCreateElementNS = document.createElementNS;
      document.createElementNS = _createElementOverride;
  }
  function _restoreCreateElement() {
      document.createElementNS = _originalCreateElementNS;
  }
  function _createElementOverride(namespace, tagName, opts) {
      if (tagName.startsWith(_OJ_SLOT_PREFIX)) {
          return _ACTIVE_SLOTS.get(tagName);
      }
      return _originalCreateElementNS.call(document, namespace, tagName, opts);
  }

  class Parking {
      parkNode(node) {
          this._getLot().appendChild(node);
      }
      /**
       * Called when bindings are disposed on the host component
       * @ignore
       */
      disposeNodes(nodeMap, cleanFunc) {
          Parking._iterateSlots(nodeMap, (node) => {
              const parent = node.parentElement;
              if (this._lot === parent) {
                  cleanFunc(node);
                  this._lot.__removeChild(node);
              }
              else if (!parent) {
                  // Completely disconnected slots should be cleaned when bindings are disposed.
                  // Slots that are still connected to the component will be disposed together with their parent
                  cleanFunc(node);
              }
          });
      }
      /**
       * Called when the host component is verifiably disconnected
       * @ignore
       */
      disconnectNodes(nodeMap) {
          Parking._iterateSlots(nodeMap, (node) => {
              if (this._lot === node.parentElement) {
                  this._lot.__removeChild(node);
              }
          });
      }
      /**
       * Called when the host component is reconnected
       * @ignore
       */
      reconnectNodes(nodeMap) {
          Parking._iterateSlots(nodeMap, (node) => {
              if (!node.parentElement) {
                  this._lot.appendChild(node);
              }
          });
      }
      /**
       * Rerurns true if a node is parked, false otherwise
       * @ignore
       */
      isParked(n) {
          return n?.parentElement === this._lot;
      }
      _getLot() {
          if (!this._lot) {
              const div = document.createElement('div');
              // Disallow removeChild() calls from outside to deal
              // with Preact trying to remove the node after the unmount callback
              div.__removeChild = div.removeChild;
              div.removeChild = (n) => n;
              div.style.display = 'none';
              document.body.appendChild(div);
              this._lot = div;
          }
          return this._lot;
      }
      static _iterateSlots(nodeMap, callback) {
          const keys = Object.keys(nodeMap);
          keys.forEach((key) => {
              const nodes = nodeMap[key];
              nodes.forEach((node) => {
                  callback(node);
              });
          });
      }
  }
  const ParkingLot = new Parking();

  /* MODIFIED: defined internal Preact constant */
  const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  /**
   * Diff the old and new properties of a VNode and apply changes to the DOM node
   * @param {import('../internal').PreactElement} dom The DOM node to apply
   * changes to
   * @param {object} newProps The new props
   * @param {object} oldProps The old props
   * @param {boolean} isSvg Whether or not this node is an SVG node
   * @param {boolean} hydrate Whether or not we are in hydration mode
   */
  /* MODIFIED: added setPropertyOverrides parameter to take over handling of certain properties */
  function diffProps(dom, newProps, oldProps, isSvg, hydrate, setPropertyOverrides) {
      let i;
      for (i in oldProps) {
          if (i !== 'children' && i !== 'key' && !(i in newProps)) {
              /* MODIFIED: call setPropertyOverrides() to take over handling of certain properties */
              setPropertyOverrides(dom, i, null, oldProps[i], isSvg) ||
                  setProperty(dom, i, null, oldProps[i], isSvg);
          }
      }
      for (i in newProps) {
          if ((!hydrate || typeof newProps[i] == 'function') &&
              i !== 'children' &&
              i !== 'key' &&
              i !== 'value' &&
              i !== 'checked' &&
              oldProps[i] !== newProps[i]) {
              /* MODIFIED: call setPropertyOverrides() to take over handling of certain properties */
              setPropertyOverrides(dom, i, newProps[i], oldProps[i], isSvg) ||
                  setProperty(dom, i, newProps[i], oldProps[i], isSvg);
          }
      }
  }
  function setStyle(style, key, value) {
      if (key[0] === '-') {
          style.setProperty(key, value);
      }
      else if (value == null) {
          style[key] = '';
      }
      else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {
          style[key] = value;
      }
      else {
          style[key] = value + 'px';
      }
  }
  /**
   * Set a property value on a DOM node
   * @param {import('../internal').PreactElement} dom The DOM node to modify
   * @param {string} name The name of the property to set
   * @param {*} value The value to set the property to
   * @param {*} oldValue The old value the property had
   * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not
   */
  function setProperty(dom, name, value, oldValue, isSvg) {
      let useCapture;
      o: if (name === 'style') {
          if (typeof value == 'string') {
              dom.style.cssText = value;
          }
          else {
              if (typeof oldValue == 'string') {
                  dom.style.cssText = oldValue = '';
              }
              if (oldValue) {
                  for (name in oldValue) {
                      if (!(value && name in value)) {
                          setStyle(dom.style, name, '');
                      }
                  }
              }
              if (value) {
                  for (name in value) {
                      if (!oldValue || value[name] !== oldValue[name]) {
                          setStyle(dom.style, name, value[name]);
                      }
                  }
              }
          }
      }
      // Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6
      else if (name[0] === 'o' && name[1] === 'n') {
          useCapture = name !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));
          // Infer correct casing for DOM built-in events:
          if (name.toLowerCase() in dom || name === 'onFocusOut' || name === 'onFocusIn')
              name = name.toLowerCase().slice(2);
          else
              name = name.slice(2);
          if (!dom._listeners)
              dom._listeners = {};
          dom._listeners[name + useCapture] = value;
          if (value) {
              if (!oldValue) {
                  const handler = useCapture ? eventProxyCapture : eventProxy;
                  dom.addEventListener(name, handler, useCapture);
              }
          }
          else {
              const handler = useCapture ? eventProxyCapture : eventProxy;
              dom.removeEventListener(name, handler, useCapture);
          }
      }
      else if (name !== 'dangerouslySetInnerHTML') {
          if (isSvg) {
              // Normalize incorrect prop usage for SVG:
              // - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)
              // - className --> class
              name = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');
          }
          else if (name != 'width' &&
              name != 'height' &&
              name !== 'href' &&
              name !== 'list' &&
              name !== 'form' &&
              // Default value in browsers is `-1` and an empty string is
              // cast to `0` instead
              name != 'tabIndex' &&
              name != 'download' &&
              name != 'rowSpan' &&
              name != 'colSpan' &&
              name != 'role' &&
              name != 'popover' &&
              name in dom) {
              try {
                  dom[name] = value == null ? '' : value;
                  // labelled break is 1b smaller here than a return statement (sorry)
                  break o;
              }
              catch (e) { }
          }
          // ARIA-attributes have a different notion of boolean values.
          // The value `false` is different from the attribute not
          // existing on the DOM, so we can't remove it. For non-boolean
          // ARIA-attributes we could treat false as a removal, but the
          // amount of exceptions would cost us too many bytes. On top of
          // that other VDOM frameworks also always stringify `false`.
          if (typeof value == 'function') {
              // never serialize functions as attribute values
          }
          else if (value != null && (value !== false || name[4] === '-')) {
              dom.setAttribute(name, name == 'popover' && value == true ? '' : value); // @HTMLUpdateOK
          }
          else {
              dom.removeAttribute(name);
          }
      }
  }
  /**
   * Proxy an event to hooked event handlers
   * @param {Event} e The event object from the browser
   * @private
   */
  function eventProxy(e) {
      this._listeners[e.type + false](preact.options.event ? preact.options.event(e) : e);
  }
  function eventProxyCapture(e) {
      this._listeners[e.type + true](preact.options.event ? preact.options.event(e) : e);
  }

  const ELEMENT_REF = Symbol();
  const ROOT_VNODE_PATCH = Symbol();
  // This is a wrapper around base component represented by IntrincicElement.
  // The base component is wrapped into necessary context providers - LayerContext, EnvironmentProvider and
  // any other custom provider requested by the component.
  // The wrapper is also used to deliver updates on property changes. The updates are triggered
  // by this component state update.
  class ComponentWithContexts extends preact.Component {
      constructor(props) {
          super(props);
          /**
           * Method creates or updates an Environment object that is stored on instance as
           * _rootEnvironment property. The object is needed for providing environment context
           * this component.
           */
          this.getEnvironmentContextObj = (currentEnv, env, colorScheme, scale, translationBundleMap) => {
              /**
               * The logic of this method is based on the assumption that the element will have
               * either an EnvironmentContext value in __oj_private_contexts (when used in JSX) or
               * __oj_private_color_scheme/__oj_private_scale (when used in HTML) or nothing.
               * We do not expect the element to have all 3 private properties at the same time.
               *
               * Initially the _rootEnvironment property will be set to existing __oj_private_contexts property
               * or created as a new object with the available values. The translation property will be extended with
               * values from translationBundleMap to cover the case that custom element has an extra bundle
               * that was not passed from environment.
               *
               * On updates we check whether env or colorScheme/scale are changed. If they are changed the _rootEnvironment
               * will be updated.
               */
              let newEnv = currentEnv;
              if (!newEnv) {
                  newEnv = env || {
                      colorScheme: colorScheme,
                      scale: scale,
                      user: { locale: ojconfig.getLocale() }
                  };
                  this.extendTranslationBundleMap(newEnv, translationBundleMap);
              }
              else if (env && env !== newEnv) {
                  newEnv = env;
                  this.extendTranslationBundleMap(newEnv, translationBundleMap);
              }
              else if ((colorScheme && colorScheme !== newEnv.colorScheme) ||
                  (scale && scale !== newEnv.scale)) {
                  newEnv = Object.assign({}, newEnv, colorScheme && { colorScheme }, scale && { scale });
              }
              return newEnv;
          };
          /**
           * Merges translations specified on custom element into translation property
           * on environment object.
           */
          this.extendTranslationBundleMap = (env, translationBundleMap) => {
              if (!env.translations) {
                  env.translations = translationBundleMap;
              }
              else if (env.translations !== translationBundleMap) {
                  Object.keys(translationBundleMap).forEach((key) => {
                      // Note, the code just compares keys but does not merge the bundles.
                      if (!env.translations[key]) {
                          env.translations[key] = translationBundleMap[key];
                      }
                  });
              }
          };
          this.state = { compProps: props.initialCompProps, renderCount: 0, connected: true };
          this._layerContext = ojlayerutils.getLayerContext(props.baseElem);
      }
      shouldComponentUpdate(nextProps, nextState) {
          // this component's props are never mutated so we can ignore that, just need to compare the contents
          // of state to ensure that either the connected state has changed, or IntrinsicElement has
          // queued a new render
          return (this.state.renderCount !== nextState.renderCount ||
              this.state.connected !== nextState.connected);
      }
      render(props) {
          // Unmount content if we're disconnected
          if (!this.state.connected) {
              return null;
          }
          const compProps = this.state.compProps;
          const BaseComponent = props.baseComp;
          const componentVDom = jsxRuntime.jsx(BaseComponent, { ...compProps });
          const rootEnv = customMemo(this.getEnvironmentContextObj, [
              props.baseElem['__oj_private_contexts']?.get(UNSAFE_Environment.EnvironmentContext),
              props.baseElem['__oj_private_color_scheme'],
              props.baseElem['__oj_private_scale'],
              props.translationBundleMap
          ]);
          // Wrap VDom in Providers for any propagated contexts
          const contexts = props.baseElem['__oj_private_contexts'];
          const contextWrappers = contexts
              ? Array.from(contexts).reduce((acc, [context, value]) => {
                  if (context === UNSAFE_Environment.EnvironmentContext) {
                      // Skip, RootEnvironmentProvider is handled separately
                      return acc;
                  }
                  const provider = jsxRuntime.jsx(context.Provider, { value: value, children: acc });
                  return provider;
              }, componentVDom)
              : componentVDom;
          // Add additional props based on Symbol that we could not add during initial creation.
          const vdomProps = componentVDom.props;
          vdomProps[ELEMENT_REF] = props.baseElem;
          // Pass the root VNode patching implementation to the render override
          vdomProps[ROOT_VNODE_PATCH] = props.rootPatchCallback;
          return (jsxRuntime.jsx(UNSAFE_Layer.LayerContext.Provider, { value: this._layerContext, children: jsxRuntime.jsx(UNSAFE_Environment.RootEnvironmentProvider, { environment: rootEnv, children: contextWrappers }) }));
      }
  }
  /**
   * Custom memoization function
   * @param fn Callback for getting the value
   * @param args arguments to compare
   * @returns new value
   */
  const customMemo = (fn, args) => {
      if (!fn.memoState) {
          fn.memoState = {
              value: undefined,
              prevArgs: undefined
          };
      }
      if (argsChanged(fn.memoState.prevArgs, args)) {
          fn.memoState.value = fn(fn.memoState.value, ...args);
          fn.memoState.prevArgs = args;
      }
      return fn.memoState.value;
  };
  /**
   * Function to compare old and new args arrays
   * @returns if args changed
   */
  const argsChanged = (oldArgs, newArgs) => {
      return (!oldArgs ||
          oldArgs.length !== newArgs.length ||
          newArgs.some((arg, index) => arg !== oldArgs[index]));
  };

  const applyRef = (ref, value) => {
      if (ref) {
          if (typeof ref == 'function') {
              return ref(value);
          }
          else {
              ref.current = value;
          }
      }
  };
  const _EMPTY_SET = new Set();
  const _LISTENERS = Symbol();
  const _CAPTURE_LISTENERS = Symbol();
  const _SUBPROP = 'subproperty';
  const _PROP_CHANGE = 'propChange';
  const _ACTION = 'action';
  class IntrinsicElement {
      constructor(element, component, metadata, rootAttributes, rootProperties, defaultProps) {
          // The Preact Component instance
          this.ref = preact.createRef();
          this._compWithContextsRef = preact.createRef();
          this._initialized = false;
          // Flag to prevent us from queueing a render during patching of virtual to live DOM
          this._isPatching = false;
          this._props = { ref: this.ref }; // used for initial render
          // Used to verify a true connect/disconnect vs a reparent
          this._verifyingState = ConnectionState.Unset;
          // We track property sets before bindings have resolved so we can play these
          // back after binding property sets occur to ensure property ordering
          this._earlySets = [];
          this._eventQueue = [];
          this._isRenderQueued = false;
          this._state = ojcustomelementUtils.CustomElementUtils.getElementState(element);
          this._element = element;
          this._metadata = metadata;
          this._component = component;
          this._controlledProps = rootProperties?.length > 0 ? new Set(rootProperties) : _EMPTY_SET;
          this._controlledAttrs = rootAttributes?.length > 0 ? new Set(rootAttributes) : _EMPTY_SET;
          this._defaultProps = defaultProps;
          this._rootPatchCallback = this._patchRootElement.bind(this);
          this._renderCount = 0;
      }
      connectedCallback() {
          this._verifyConnectDisconnect(ConnectionState.Connect);
      }
      disconnectedCallback() {
          this._verifyConnectDisconnect(ConnectionState.Disconnect);
      }
      attributeChangedCallback(name, oldValue, newValue) {
          // This callback is called when the component is instantiated and before the connected
          // callback. We need to walk up the DOM tree to determine the binding provider so in order
          // to skip data bound attributes, delay handling until component is created
          // and initialize properties from DOM for component creation instead of this handler.
          if (!this._isPatching && this._state.canHandleAttributes()) {
              const propName = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(name);
              const topProp = propName.split('.')[0];
              // Note that we need to check whether the property has been marked dirty
              // since we don't reflect property values back to the DOM attribute.
              if (this._state.dirtyProps.has(topProp)) {
                  this._state.dirtyProps.delete(topProp);
              }
              else if (oldValue === newValue) {
                  return;
              }
              if (newValue === null) {
                  newValue = undefined;
              }
              if ('knockout' === this._state.getBindingProviderType()) {
                  // The CustomElementBinding listens for these events
                  if (!ojcustomelementUtils.AttributeUtils.isGlobalOrData(propName)) {
                      this._element.dispatchEvent(new CustomEvent('attribute-changed', {
                          detail: { attribute: name, value: newValue, previousValue: oldValue }
                      }));
                  }
              }
              const { propPath, propValue, propMeta, subPropMeta } = this._getPropValueInfo(name, newValue);
              if (propPath) {
                  this._updatePropsAndQueueRenderAsNeeded(propPath, propValue, propMeta, subPropMeta);
              }
          }
      }
      getProperty(name) {
          const meta = MetadataUtils.getPropertyMetadata(name, this._metadata?.properties);
          if (!meta) {
              return this._element[name];
          }
          else {
              let value = ojcustomelementUtils.CustomElementUtils.getPropertyValue(this._props, name);
              // Check for the value in defaultProps if not defined
              if (value === undefined && this._defaultProps) {
                  value = ojcustomelementUtils.CustomElementUtils.getPropertyValue(this._defaultProps, name);
              }
              return value;
          }
      }
      setProperty(name, value) {
          // Component property setters, data bound attributes,
          // and direct setProperty/setProperties method calls go
          // through here
          if (this._isPatching)
              return;
          const { prop: propMeta, subProp: subPropMeta } = MetadataUtils.getComplexPropertyMetadata(name, this._metadata?.properties);
          if (!propMeta) {
              // If not a JET component property, just set the value directly on the element
              this._element[name] = value;
          }
          else {
              if (this._state.allowPropertySets()) {
                  // eslint-disable-next-line no-param-reassign
                  value = ojcustomelementUtils.transformPreactValue(this._element, name, subPropMeta, value);
                  // Property triggered renders are asynchronous, but values are updated synchronously
                  this._updatePropsAndQueueRenderAsNeeded(name, value, propMeta, subPropMeta);
              }
              else {
                  this._earlySets.push({ property: name, value });
              }
          }
      }
      setProperties(properties) {
          if (this._isPatching) {
              return;
          }
          Object.keys(properties).forEach((prop) => {
              this.setProperty(prop, properties[prop]);
          });
      }
      getProps() {
          return this._props;
      }
      // we want to suppress property change events during early property sets, which get played back
      // immediately before this._vdom is created
      isInitialized() {
          return !!this._vdom;
      }
      appendChildHelper(element, newNode) {
          if (ojcustomelementUtils.CustomElementUtils.canRelocateNode(element, newNode)) {
              return HTMLElement.prototype.appendChild.call(element, newNode);
          }
          return newNode;
      }
      insertBeforeHelper(element, newNode, refNode) {
          if (ojcustomelementUtils.CustomElementUtils.canRelocateNode(element, newNode)) {
              // In case of slot nodes the refNode might be moved by the parent component
              // and it is not a direct child of that parent component anymore.
              // Preact is not aware of this movement so it uses incorrect parent for inserting a node.
              // Lets use the correct parent of refNode to insert newNode before it.
              if (refNode && refNode.parentNode !== element) {
                  Logger.info(`Using insertBefore where ${element.tagName} is not a parent of ${refNode.tagName}`);
              }
              if (refNode && refNode.parentNode) {
                  return HTMLElement.prototype.insertBefore.call(refNode.parentNode, newNode, refNode);
              }
              return HTMLElement.prototype.insertBefore.call(element, newNode, refNode);
          }
          return newNode;
      }
      _render() {
          if (!this._initialized) {
              this._initialized = true;
              // We delay initializing properties until the first connected callback
              // due to the fact that the binding provider isn't known when the custom element
              // is first instantiated so an attribute value coming as "[[hello]]" could be either
              // bound to a hello knockout variable or be the literal string "[[hello]]".
              // Another reason to delay initializing properties is to avoid type coercion for
              // components that may never be connected to the DOM, e.g. those inside an oj-bind-if.
              this._initializePropsFromDom();
              // After initializing properties from DOM attributes, go through
              // event metadata and writeback properties to add action and
              // writeback callbacks
              const eventsMeta = this._metadata.events;
              if (eventsMeta) {
                  this._initializeActionCallbacks(eventsMeta);
              }
              const writebackProps = this._metadata.extension?.['_WRITEBACK_PROPS'];
              if (writebackProps) {
                  this._initializeWritebackCallbacks(writebackProps);
              }
              // Property sets need to be saved and played back since they may occur during knocout
              // bindings of disconnected DOM like in the case of an oj-bind-for-each.
              // TODO: 04/11/2024 - Potentially we don't need early property set at all for VComponents
              // and can rely on the correct order of this._props.
              this._playbackEarlyPropertySets();
          }
          if (!this._vdom) {
              this._vdom = (jsxRuntime.jsx(ComponentWithContexts, { ref: this._compWithContextsRef, baseComp: this._component, baseElem: this._element, initialCompProps: this._props, rootPatchCallback: this._rootPatchCallback, translationBundleMap: this._state.getTranslationBundleMap() }));
              preact.render(this._vdom, this._element);
          }
          else {
              throw new Error(`Unexpected render call for already rendered component ${this._element.tagName}`);
          }
      }
      /**
       * Returns an object with property path, value, property and subproperty metadata if the attribute is either a
       * controlled root property or a non readOnly component property.
       * Otherwise, an empty object will be returned.
       * @param attrName
       * @param attrValue
       */
      _getPropValueInfo(attrName, attrValue) {
          // Skip data bound attributes
          if ('knockout' !== this._state.getBindingProviderType() ||
              !ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrValue).expr) {
              const propPath = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(attrName);
              const { prop: propMeta, subProp: subPropMeta } = MetadataUtils.getComplexPropertyMetadata(propPath, this._metadata?.properties);
              if (propMeta) {
                  if (propMeta.readOnly) {
                      return {};
                  }
                  return {
                      propPath,
                      propValue: ojcustomelementUtils.AttributeUtils.attributeToPropertyValue(this._element, attrName, attrValue, subPropMeta),
                      propMeta,
                      subPropMeta
                  };
              }
              // Try and get the property so the type is correct, if not available
              // get the attribute value, e.g. data-, aria-, tabindex (since property is tabIndex)
              const globalPropName = ojcustomelementUtils.AttributeUtils.getGlobalPropForAttr(attrName);
              if (this._controlledProps.has(globalPropName)) {
                  return {
                      propPath: globalPropName,
                      propValue: this._element[ojcustomelementUtils.AttributeUtils.getGlobalValuePropForAttr(attrName)] ?? attrValue
                  };
              }
          }
          return {};
      }
      _updatePropsAndQueueRenderAsNeeded(propPath, value, propMeta, subPropMeta, isOuter = true) {
          const previousValue = this.getProperty(propPath);
          const newValue = value === undefined
              ? ojcustomelementUtils.CustomElementUtils.getPropertyValue(this._defaultProps, propPath)
              : value;
          if (propMeta &&
              ojcustomelementUtils.ElementUtils.comparePropertyValues(propMeta.writeback, newValue, previousValue)) {
              return;
          }
          const propArray = propPath.split('.');
          const topProp = propArray[0];
          const isSubprop = propArray.length > 1;
          // If the top level property is an object, make a copy otherwise the old/new values
          // will be the same.
          let topPropPrevValue = this.getProperty(topProp);
          if (oj.CollectionUtils.isPlainObject(topPropPrevValue)) {
              topPropPrevValue = oj.CollectionUtils.copyInto({}, topPropPrevValue, undefined, true);
          }
          // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
          if (isOuter) {
              this._verifyProps(propPath, value, propMeta, subPropMeta);
          }
          this._updateProps(propArray, value);
          // We may need to update a component property or a controlled root property.
          // We do not need to trigger property changed events for the latter.
          if (!isOuter ||
              (this._state.allowPropertyChangedEvents() && !ojcustomelementUtils.AttributeUtils.isGlobalOrData(propPath))) {
              this._state.dirtyProps.add(topProp);
              const updatedFrom = isOuter ? 'external' : 'internal';
              const detail = {
                  value: this.getProperty(topProp),
                  previousValue: topPropPrevValue,
                  updatedFrom
              };
              if (isSubprop) {
                  detail[_SUBPROP] = {
                      path: propPath,
                      value,
                      previousValue
                  };
              }
              const type = topProp + 'Changed';
              const collapseFunc = isSubprop
                  ? null
                  : (oldDef) => {
                      if (oldDef.kind !== _PROP_CHANGE || oldDef.type !== type || oldDef.detail[_SUBPROP]) {
                          return null;
                      }
                      const mergedDetail = Object.assign({}, detail, {
                          previousValue: oldDef.detail.previousValue
                      });
                      return { type, detail: mergedDetail, collapse: collapseFunc, kind: _PROP_CHANGE };
                  };
              // Both property change event firing and re-rendering are queued as microtasks.
              // Since busy state resolves using window.setImmediate, we don't need to register
              // busy states. Preact also uses microtasks for rendering.
              this._queueFireEventsTask({ type, detail, collapse: collapseFunc, kind: _PROP_CHANGE });
          }
          // Ensure that Preact knows the latest values of the controlled properties when they have
          // been set directly on the custom element (custom-element-first case).
          // Otherwise, preact diffing will be comparing against an old value that is no longer reflected
          // in the DOM
          const oldProps = this._oldRootProps;
          if (oldProps && this._controlledProps.has(propPath)) {
              oldProps[propPath] = value;
          }
          // TODO handle interrupted render
          // Skip rendering if prop update is a readOnly property
          if (this._vdom && !propMeta?.readOnly) {
              // JET-56604: We have to handle a scenario when a component updates a property in
              // its constructor. In this case the component is connected, _vdom is created,
              // but the component is not mounted and the ref is not set yet. Wait a tick
              // before setState() call.
              if (!this._compWithContextsRef?.current) {
                  window.queueMicrotask(() => {
                      this._queueRender();
                  });
              }
              else {
                  this._queueRender();
              }
          }
      }
      _queueRender() {
          if (this._compWithContextsRef?.current) {
              this._renderCount++;
              this._compWithContextsRef.current.setState({
                  compProps: this._props,
                  renderCount: this._renderCount
              });
          }
          else {
              throw new Error(`Render requested for a disconnected component ${this._element.tagName}`);
          }
      }
      _verifyProps(prop, value, propMeta, subPropMeta) {
          // Skip verification step for global properties
          if (!propMeta) {
              return;
          }
          // Check readOnly property for top level property
          if (propMeta.readOnly) {
              throw new ojcustomelementUtils.JetElementError(this._element, `Read-only property '${prop}' cannot be set.`);
          }
          try {
              MetadataUtils.checkEnumValues(this._element, prop, value, subPropMeta);
          }
          catch (error) {
              throw new ojcustomelementUtils.JetElementError(this._element, error.message);
          }
      }
      _updateProps(propPath, value) {
          const topProp = propPath[0];
          let propsObj = this._props;
          // Set subproperty, initializing parent objects along the way
          if (propPath.length > 1) {
              // Make a copy of the current value or default value
              const currentValue = this._props[topProp] ?? this._defaultProps?.[topProp];
              if (currentValue && oj.CollectionUtils.isPlainObject(currentValue)) {
                  propsObj[topProp] = oj.CollectionUtils.copyInto({}, currentValue, undefined, true);
              }
              else {
                  propsObj[topProp] = {};
              }
          }
          // Walk to the correct location
          while (propPath.length) {
              const subprop = propPath.shift();
              if (propPath.length === 0) {
                  propsObj[subprop] = value;
              }
              else if (!propsObj[subprop]) {
                  propsObj[subprop] = {};
              }
              propsObj = propsObj[subprop];
          }
      }
      /**
       * Queues events to be fired asynchronously and returns the queued event Promise to be used
       * for dealing with cancelable events.
       * @param eventDef Definition of the event to queue
       * @private
       */
      _queueFireEventsTask(eventDef) {
          let newDef = eventDef;
          const collapseInfo = this._getEventCollapseInfo(eventDef, this._eventQueue);
          if (collapseInfo) {
              const [removeIndex, def] = collapseInfo;
              this._eventQueue.splice(removeIndex, 1);
              newDef = def;
          }
          this._eventQueue.push(newDef);
          if (!this._queuedEvents) {
              this._queuedEvents = new Promise((resolve) => {
                  window.queueMicrotask(() => {
                      try {
                          while (this._eventQueue.length) {
                              const def = this._eventQueue.shift();
                              const evt = def.kind === _PROP_CHANGE
                                  ? new CustomEvent(def.type, { detail: def.detail })
                                  : def.event;
                              this._element.dispatchEvent(evt);
                          }
                      }
                      finally {
                          resolve();
                          this._queuedEvents = null;
                      }
                  });
              });
          }
          return this._queuedEvents;
      }
      // If the new event can be combined with an existing event in the queue, this method will
      // return the index of that existing event and the definition of the combined event.
      // Otherwise the method will return null
      _getEventCollapseInfo(newDef, queue) {
          if (newDef.kind !== _PROP_CHANGE) {
              return null;
          }
          for (let i = 0; i < queue.length; i++) {
              const combined = newDef.collapse?.(queue[i]);
              if (combined) {
                  return [i, combined];
              }
          }
          return null;
      }
      _verifyConnectDisconnect(state) {
          if (this._state.isComplete()) {
              // Notify ComponentWithContexts of the change in connection state so that any queued
              // Preact renders can either render or short-circuit appropriately
              // Reparents will not result in rerenders due to shouldComponentUpdate in ComponentWithContexts
              this._compWithContextsRef?.current?.setState({
                  connected: state === ConnectionState.Connect
              });
          }
          if (this._verifyingState === ConnectionState.Unset) {
              window.queueMicrotask(() => {
                  // This checks that we don't call any lifecycle hooks
                  // for reparent case where _verifyingState has been
                  // updated but the initial state we called
                  // this Promise with is different
                  if (this._verifyingState === state) {
                      if (this._verifyingState === ConnectionState.Connect) {
                          this._verifiedConnect();
                      }
                      else {
                          this._verifiedDisconnect();
                      }
                  }
                  this._verifyingState = ConnectionState.Unset;
              });
          }
          this._verifyingState = state;
      }
      _verifiedConnect() {
          if (this._state.isComplete()) {
              this._reconnectSlots();
          }
          else {
              // If the component has not finished its creation cycle,
              // attempt to create it vs handling as a reattached since
              // the component could have finished in an error state.
              // The element state will no-op the creation process if
              // the component is already in an error state.
              this._state.startCreationCycle();
              if (this._state.isCreating()) {
                  const createComponentCallback = () => {
                      // Set a non enumerable flag that this element owns a preact subtree
                      // for when we walk up the parent hierarchy to determine the binding
                      // provider for any custom element children rendered by this preact
                      // component.
                      this._element[ojcustomelementUtils.CHILD_BINDING_PROVIDER] = 'preact';
                      let slotMap = this._state.getSlotMap();
                      if (!slotMap) {
                          slotMap = this._state.getSlotMap(true);
                          const slotProps = this._removeAndConvertSlotsToProps(slotMap);
                          Object.assign(this._props, slotProps);
                      }
                      else {
                          this._reconnectSlots();
                      }
                      this._render();
                  };
                  this._state.setCreateCallback(createComponentCallback);
                  this._state.setBindingsDisposedCallback(() => this._handleBindingsDisposed());
              }
          }
          this._state.executeLifecycleCallbacks(true);
      }
      _verifiedDisconnect() {
          this._state.executeLifecycleCallbacks(false);
          if (this._state.isComplete()) {
              this._disconnectSlots();
              this._state.resetCreationCycle();
              preact.render(null, this._element);
              applyRef(this.ref, null);
              applyRef(this._compWithContextsRef, null);
              if (typeof this._oldRootCleanupCallback == 'function') {
                  this._oldRootCleanupCallback();
                  this._oldRootCleanupCallback = undefined;
              }
              applyRef(this._oldRootRef, null);
              this._oldRootRef = undefined;
              // We need to recreate our parent stub the next time we reconnect since Preact
              // stashes the last rendered vdom tree in a private variable and will assume
              // we are picking up from that spot instead of starting over.
              this._vdom = null;
          }
          else {
              this._state.pauseCreationCycle();
          }
      }
      /**
       * Initialize this._props from DOM attributes
       */
      _initializePropsFromDom() {
          const attrs = this._element.attributes;
          // Pass everything through, the overridden component render
          // will patch uncontrolled properties back to the custom element
          for (let i = 0; i < attrs.length; i++) {
              const { name, value } = attrs[i];
              const { propPath, propValue, propMeta, subPropMeta } = this._getPropValueInfo(name, value);
              if (propPath) {
                  this._verifyProps(propPath, propValue, propMeta, subPropMeta);
                  this._updateProps(propPath.split('.'), propValue);
              }
          }
      }
      _playbackEarlyPropertySets() {
          // Once the binding provider has resolved and we are about
          // to render the component, we no longer need to track early
          // property sets to avoid overriding data bound DOM attributes
          while (this._earlySets.length) {
              const setObj = this._earlySets.shift();
              const meta = MetadataUtils.getPropertyMetadata(setObj.property, this._metadata?.properties);
              const updatedValue = ojcustomelementUtils.transformPreactValue(this._element, setObj.property, meta, setObj.value);
              this.setProperty(setObj.property, updatedValue);
          }
      }
      _patchRootElement(newVNode) {
          const oldProps = this._oldRootProps || this._getInitialRootProps();
          const newProps = newVNode.props;
          this._isPatching = true;
          try {
              diffProps(this._element, newProps, oldProps, false, false, IntrinsicElement._setPropertyOverrides);
          }
          finally {
              this._isPatching = false;
          }
          const newRef = newVNode.ref;
          if (this._oldRootRef !== newRef) {
              if (typeof this._oldRootCleanupCallback == 'function') {
                  this._oldRootCleanupCallback();
              }
              this._oldRootCleanupCallback = applyRef(newRef, this._element);
              // reset the old ref if the new one is not null
              if (newRef) {
                  applyRef(this._oldRootRef, null);
              }
          }
          this._oldRootProps = newProps;
          this._oldRootRef = newRef;
      }
      /**
       * Customizations for the setProperty behavior in Preact's diffProps()
       * License header above
       * Return true if the property has been handled, false otherwise
       * @ignore
       */
      static _setPropertyOverrides(dom, name, value, oldValue) {
          if (name === 'style' && typeof value == 'string') {
              throw new Error('CSS style must be an object. CSS text is not supported');
          }
          // Mutate classes in a non-destructive way using classList instead of className to allow
          // classes being set from outside
          if (name === 'class' || name === 'className') {
              const oldClasses = oldValue == null ? _EMPTY_SET : ojcustomelementUtils.CustomElementUtils.getClassSet(oldValue);
              const newClasses = value == null ? _EMPTY_SET : ojcustomelementUtils.CustomElementUtils.getClassSet(value);
              for (const cl of oldClasses.values()) {
                  if (!newClasses.has(cl)) {
                      dom.classList.remove(cl);
                  }
              }
              for (const cl of newClasses.values()) {
                  if (!oldClasses.has(cl)) {
                      dom.classList.add(cl);
                  }
              }
              return true;
          }
          else if (name[0] === 'o' && name[1] === 'n') {
              const useCapture = name !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));
              // Infer correct casing for DOM built-in events:
              if (name.toLowerCase() in dom || name === 'onFocusOut' || name === 'onFocusIn')
                  name = name.toLowerCase().slice(2);
              else
                  name = name.slice(2);
              IntrinsicElement._getRootListeners(dom, useCapture)[name] = value;
              const proxy = useCapture ? IntrinsicElement._eventProxyCapture : IntrinsicElement._eventProxy;
              if (value) {
                  if (!oldValue)
                      dom.addEventListener(name, proxy, useCapture);
              }
              else {
                  dom.removeEventListener(name, proxy, useCapture);
              }
              return true;
          }
          else if (name === 'role') {
              // Safari doesn't fire the custom element reaction synchronously when role is set as a property
              // (unlike other global props or even like 'role' when set as an attribute).  Overriding preact's
              // default behavior here to always patch role as an attribute (note this is already the behavior
              // in Firefox where 'role' isn't a global prop)
              if (value) {
                  dom.setAttribute(name, value); // @HTMLUpdateOK
              }
              else {
                  dom.removeAttribute(name);
              }
              return true;
          }
          return false;
      }
      static _getRootListeners(dom, useCapture) {
          const key = useCapture ? _CAPTURE_LISTENERS : _LISTENERS;
          let listeners = dom[key];
          if (!listeners) {
              listeners = dom[key] = {};
          }
          return listeners;
      }
      // Populate initial root props with values of the controlled properties, so that
      // they can be overridden by the component's render
      _getInitialRootProps() {
          const props = {};
          // Controlled property values have already been copied into cthe component props
          // by _initializePropsFromDom(), so we can just copy them from _props here
          for (const name of this._controlledProps.values()) {
              if (name in this._props) {
                  props[name] = this._props[name];
              }
          }
          return props;
      }
      /**
       * Removes component's slot children and converts them to properties
       */
      _removeAndConvertSlotsToProps(slotMap) {
          // dynamicSlot is an object of form { prop: [propName], isTemplate: [1 for true and 0 for false]}
          const dynamicSlotMetadata = this._metadata.extension?._DYNAMIC_SLOT;
          const dynamicSlotProp = dynamicSlotMetadata?.prop;
          const slotsMetadata = this._metadata?.slots;
          const slots = Object.keys(slotMap);
          const slotProps = {};
          if (slots.length > 0) {
              slots.forEach((slot) => {
                  const slotNodes = slotMap[slot];
                  slotNodes.forEach((node) => {
                      ParkingLot.parkNode(node);
                      this._propagateSubtreeHidden(node);
                  });
                  const slotMetadata = MetadataUtils.getPropertyMetadata(slot, slotsMetadata);
                  if (slotMetadata) {
                      // static slot or templateSlot
                      const isTemplateSlot = !!slotMetadata?.data;
                      const slotProperty = !isTemplateSlot && slot === '' ? 'children' : slot;
                      this._assignSlotProperty(slotProps, slotProperty, undefined, slot, isTemplateSlot, slotNodes);
                  }
                  else {
                      // dynamic slot or templateSlot
                      // Stop processing if node doesn't match any named slots and component
                      // does not define a dynamic slot.
                      // TODO do we throw an error or log a warning if we encounter a slot item
                      // that should go into a dynamic prop but there's no dynamic prop, basically
                      // meaning the slot content was marked incorrectly?
                      if (!dynamicSlotProp) {
                          return;
                      }
                      if (!slotProps[dynamicSlotProp]) {
                          slotProps[dynamicSlotProp] = {};
                      }
                      const isTemplateSlot = dynamicSlotMetadata.isTemplate;
                      this._assignSlotProperty(slotProps, slot, dynamicSlotProp, slot, isTemplateSlot, slotNodes);
                  }
              });
          }
          if (this._state.getBindingProviderType() === 'knockout') {
              // Remove and clean non-slot children (comment nodes, etc.) to prevent them from being
              // removed by Preact without being cleaned
              let child;
              while ((child = this._element.firstChild)) {
                  this._state.getBindingProviderCleanNode()(child);
                  child.remove(); // No ts definition for remove() yet
              }
          }
          return slotProps;
      }
      _assignSlotProperty(slotProps, propName, containerPropName, slotName, isTemplateSlot, slotNodes) {
          const propContainer = containerPropName ? slotProps[containerPropName] : slotProps;
          if (isTemplateSlot) {
              if (slotNodes[0]?.nodeName === 'TEMPLATE') {
                  // Handle template slots
                  const templateNode = slotNodes[0];
                  let renderer = templateNode['render'];
                  if (renderer) {
                      propContainer[propName] = renderer;
                      // Handle the case where the renderer gets updated on the template
                      Object.defineProperties(templateNode, {
                          render: {
                              enumerable: true,
                              get: () => {
                                  return renderer;
                              },
                              set: (newRenderer) => {
                                  renderer = newRenderer;
                                  if (newRenderer) {
                                      this._updateProps([propName], newRenderer);
                                      this._queueRender();
                                  }
                              }
                          }
                      });
                  }
                  else {
                      propContainer[propName] = this._getSlotRenderer(templateNode, propName, containerPropName);
                  }
              }
              else {
                  throw new ojcustomelementUtils.JetElementError(this._element, `Slot content for template slot ${slotName} must be a template element.`);
              }
          }
          else {
              const vnodes = slotNodes.map((node, index) => convertToVNode(this._element, node, this._handleSlotMount.bind(this), this._handleSlotUnmount.bind(this)));
              propContainer[propName] = vnodes;
          }
      }
      _getSlotRenderer(templateNode, slotProp, containerProp) {
          const bindingProvider = this._state.getBindingProvider();
          const mutationCallback = bindingProvider
              ? () => {
                  const propContainer = containerProp ? this._props[containerProp] : this._props;
                  propContainer[slotProp] = this._getSlotRenderer(templateNode, slotProp, containerProp);
                  this._queueRender();
              }
              : null;
          return (context) => {
              const cachedTemplateEngine = this._state.getTemplateEngine();
              if (!cachedTemplateEngine) {
                  throw new ojcustomelementUtils.JetElementError(this._element, 'Unexpected call to render a template slot');
              }
              return cachedTemplateEngine.execute(this._element, templateNode, context, bindingProvider, mutationCallback);
          };
      }
      _handleBindingsDisposed() {
          ParkingLot.disposeNodes(this._state.getSlotMap(), this._state.getBindingProviderCleanNode());
          this._state.disposeTemplateCache();
      }
      _disconnectSlots() {
          ParkingLot.disconnectNodes(this._state.getSlotMap());
      }
      _reconnectSlots() {
          ParkingLot.reconnectNodes(this._state.getSlotMap());
      }
      _propagateSubtreeHidden(node) {
          // Notiify legacy JET components within the slot that they are now in a hidden subtree
          if (node.nodeType === Node.ELEMENT_NODE) {
              ojcustomelementUtils.CustomElementUtils.subtreeHidden(node);
          }
      }
      _handleSlotUnmount(node) {
          // Check for complete state to avoid parking slots when the entire component
          // is unmounted
          if (this._state.isPostCreateCallbackOrComplete() && this._element.isConnected) {
              ParkingLot.parkNode(node);
              // Check if the node is still parked after a microtask
              // to avoid .subtreeHidden traversal for slots that get
              // redistributed to a new parent
              window.queueMicrotask(() => {
                  if (ParkingLot.isParked(node)) {
                      this._propagateSubtreeHidden(node);
                  }
              });
          }
      }
      _handleSlotMount(node) {
          // Notiify legacy JET components within the slot that they are no longer in a hidden subtree
          const handleMount = ojcustomelementUtils.CustomElementUtils.subtreeShown;
          if (handleMount && node.nodeType === Node.ELEMENT_NODE) {
              if (node.isConnected) {
                  handleMount(node);
              }
              else {
                  // Since legacy JET expects the node to be fully connected with when subtreeShown is invoked,
                  // invoke the callback when Preact's diff is done
                  window.queueMicrotask(() => handleMount(node));
              }
          }
      }
      static _eventProxy(e) {
          this[_LISTENERS][e.type](preact.options.event ? preact.options.event(e) : e);
      }
      static _eventProxyCapture(e) {
          this[_CAPTURE_LISTENERS][e.type](preact.options.event ? preact.options.event(e) : e);
      }
      _initializeActionCallbacks(eventsMeta) {
          Object.keys(eventsMeta).forEach((event) => {
              const eventMeta = eventsMeta[event];
              // Preact expects jsx custom event listeners to be of the form
              // on[eventType], e.g. onojAction which is different than our DOM
              // event listener syntax of on[EventType], e.g. onOjAction.
              const eventProp = ojcustomelementUtils.AttributeUtils.eventTypeToEventListenerProperty(event);
              this._props[eventProp] = (detailObj) => {
                  const detail = Object.assign({}, detailObj);
                  // If we're firing a cancelable event, inject an accept function into
                  // the event detail so the consumer can asynchronously cancel the event.
                  // We only support an asynchronously cancelable event at the moment.
                  const cancelable = !!eventMeta.cancelable;
                  const acceptPromises = [];
                  if (cancelable) {
                      detail.accept = (promise) => {
                          acceptPromises.push(promise);
                      };
                  }
                  const eventDescriptor = { detail, bubbles: !!eventMeta.bubbles, cancelable };
                  const customEvent = new CustomEvent(event, eventDescriptor);
                  const eventPromise = this._queueFireEventsTask({ event: customEvent, kind: _ACTION });
                  if (cancelable) {
                      return eventPromise.then(() => {
                          return customEvent.defaultPrevented
                              ? Promise.reject()
                              : Promise.all(acceptPromises).then(() => Promise.resolve(), (reason) => Promise.reject(reason));
                      });
                  }
                  return undefined;
              };
          });
      }
      _initializeWritebackCallbacks(writebackProps) {
          writebackProps.forEach((propPath) => {
              // e.g. value -> onValueChanged
              const callbackProp = ojcustomelementUtils.AttributeUtils.propertyNameToChangedCallback(propPath);
              const { prop: propMeta, subProp: subPropMeta } = MetadataUtils.getComplexPropertyMetadata(propPath, this._metadata?.properties);
              this._props[callbackProp] = (value) => {
                  // The inner set will trigger a call to _updateProperty
                  // to mutate the property and queue the property changed event
                  this._updatePropsAndQueueRenderAsNeeded(propPath, value, propMeta, subPropMeta, false);
              };
          });
      }
  }
  var ConnectionState;
  (function (ConnectionState) {
      ConnectionState[ConnectionState["Connect"] = 0] = "Connect";
      ConnectionState[ConnectionState["Disconnect"] = 1] = "Disconnect";
      ConnectionState[ConnectionState["Unset"] = 2] = "Unset";
  })(ConnectionState || (ConnectionState = {}));

  // This method is added to support ref cleanup feature. It is added for the future use
  // when the outer component will need to pass a ref with cleanup callback.
  // Currently both refs wrapped by EnvironmentWrapper are created by JET
  // and do not have cleanup callbacks - the 'ref' added by ManageTabStops component and
  // child.ref added by VComponentTemplate.
  const getCleanupFunc = (c1, c2) => {
      return c1 || c2
          ? () => {
              if (typeof c1 == 'function') {
                  c1();
              }
              if (typeof c2 == 'function') {
                  c2();
              }
          }
          : undefined;
  };
  const EnvironmentWrapper = compat.forwardRef((props, ref) => {
      // The props.children is guaranteed to be a single IntrinsicElement.
      // See how EnvironmentWrapper is used in preactOptions.
      let child = props.children;
      // This list will never change, so we're not using any hooks on a conditional basis
      const contexts = ojcustomelementRegistry.getElementRegistration(child.type).cache
          .contexts;
      const allContexts = [UNSAFE_Environment.EnvironmentContext, ...(contexts ?? [])];
      const allValues = allContexts.map((context) => {
          // Get the provided value from __oj_provided_contexts property.
          // Use provided if exists, otherwise use the value from Preact context.
          // Note, that __oj_provided_contexts might be assigned via VTemplateEngine code.
          const ctxValue = hooks.useContext(context);
          const providedValue = child.props.__oj_provided_contexts?.get(context);
          return providedValue !== undefined ? providedValue : ctxValue;
      });
      // use memo here so that we only push a new value into __oj_private_contexts if there's actually been a change
      // to one of the Context values
      const contextMap = hooks.useMemo(() => {
          const map = new Map();
          for (let i = 0; i < allContexts.length; i++) {
              map.set(allContexts[i], allValues[i]);
          }
          return map;
      }, allValues);
      if (child.props.__oj_private_contexts !== undefined &&
          child.props.__oj_private_contexts !== contextMap) {
          // Clone the memoized child to trigger child rendering in preact.
          // The cloneElement(child) will wrap the child in another EnvironmentWrapper, so we need to take a child of the wrapper.
          child = preact.cloneElement(child).props.children;
      }
      child.props.__oj_private_contexts = contextMap;
      // We need this code to handle ManageTabStops component that will wrap the EnvironmentWrapper and
      // wants to set a ref on a child component to access it for updating tabindex. See JET-54400 for details.
      // See note for getCleanupFunc().
      if (ref) {
          if (child.ref) {
              const originalRef = child.ref;
              child.ref = (el) => {
                  let cleanup1, cleanup2;
                  // Process original ref from this child element
                  cleanup1 = applyRef(originalRef, el);
                  // Process new ref passed to the EnvironmentWrapper
                  cleanup2 = applyRef(ref, el);
                  return getCleanupFunc(cleanup1, cleanup2);
              };
          }
          else {
              child.ref = ref;
          }
      }
      return jsxRuntime.jsx(preact.Fragment, { children: child });
  });
  EnvironmentWrapper['__ojIsEnvironmentWrapper'] = true;

  const injectSymbols = (props, property) => {
      if (Object.prototype.hasOwnProperty.call(props, property)) {
          const newKey = ojcustomelementUtils.publicToPrivateName.get(property);
          props[newKey] = ojcustomelementUtils.toSymbolizedValue(props[property]);
          delete props[property];
      }
  };
  const oldVNodeHook = preact.options.vnode;
  let isCloningElement = false; // flag to avoid infinite loop
  preact.options.vnode = (vnode) => {
      const type = vnode.type;
      // preact/compat coerces null property values to undefined.  this tends not
      // to matter in most cases since preact's diffing checks tend to rely on ==
      // comparison rather than ===.  however, for the 'value' and 'checked' properties,
      // preact itself ignores undefined values in a props object.  as a result,
      // there's no way to set a custom element property to null or undefined.
      //
      // this will hopefully be addressed via preact issue https://github.com/preactjs/preact/issues/3276
      // but in the meantime we replace these values with Symbols that we can recognize
      // in our custom element property setters so that we can honor the JSX author's
      // original intent.
      //
      // specifically checking for known JET custom elements rather than a more
      // generic check for the '-' character to avoid injecting our JET-specific
      // Symbols into some third party component which won't know what to do with them
      // (and all this call does is a map lookup)
      if (typeof type === 'string' && ojcustomelementRegistry.isElementRegistered(type)) {
          const props = vnode.props;
          injectSymbols(props, 'value');
          injectSymbols(props, 'checked');
      }
      if (typeof type === 'string' && !isCloningElement && ojcustomelementRegistry.isVComponent(type)) {
          isCloningElement = true;
          try {
              const origVNode = preact.cloneElement(vnode);
              const wrapper = jsxRuntime.jsx(EnvironmentWrapper, { children: origVNode });
              Object.assign(vnode, wrapper);
          }
          finally {
              isCloningElement = false;
          }
      }
      oldVNodeHook?.(vnode);
  };
  // Replace requestAnimationFrame option to add JET busy context logic.
  const RAF_TIMEOUT = 100;
  const originalRAF = preact.options.requestAnimationFrame;
  function _requestAnimationFrame(task) {
      // Create RAF promise that mimics Preact RAF timeout logic.
      const rafPromise = new Promise((res) => {
          const callback = () => {
              res();
              Context.__removePreactPromise(rafPromise);
              task();
          };
          if (originalRAF) {
              originalRAF(callback);
          }
          else {
              const done = () => {
                  clearTimeout(timeout);
                  cancelAnimationFrame(raf);
                  setTimeout(callback);
              };
              const timeout = setTimeout(done, RAF_TIMEOUT);
              const raf = requestAnimationFrame(done);
          }
      });
      // Add the the promise to the map of preact promises.
      Context.__addPreactPromise(rafPromise, 'Preact requestAnimationFrame');
  }
  preact.options.requestAnimationFrame = _requestAnimationFrame;

  // Override for preact options used by preact/debug to check validity of the component hook.
  // The preact/debug logic is based on a global 'hooksAllowed' flag that does not check
  // which component uses the hook. The hook check logic can be broken, when
  // the render flow is interrupted by independent preact.render() calls.
  // This override is an attempt to fix the problem for JET applications that might
  // use preact.render() to clean legacy component templates as necessary.
  // Specifically the fix is related to JET-69144 - a vcomponent based on oj-tree-view updates DP
  // in useEffect() that triggeres templates clean for oj-tree-view.
  const opts = preact.options;
  let isPreactDebugEnabled = opts.__m || opts._hydrationMismatch;
  if (isPreactDebugEnabled) {
      const componentStack = [];
      // It is possible to have two versions of _render option.
      // The preact-devtools extension defines both variants, but if preact/compat was
      // loaded after preact-devtools it will override one of those.
      // It is not the case for _catchError or _hook.
      // Lets store both of them but call only one based on the knowledge
      // whether preact is mangled or not (vcomponent._component property)
      const isPreactMangled = opts._hydrationMismatch ? false : true;
      const oldRender = isPreactMangled ? opts.__r : opts._render;
      const oldCatchError = isPreactMangled ? opts.__e : opts._catchError;
      const oldDiffed = opts.diffed;
      const removeCompFromStack = (vnode) => {
          const testComp = componentStack[componentStack.length - 1];
          const comp = vnode.__c || vnode._component;
          if (testComp === comp) {
              componentStack.pop();
          }
      };
      // options._render
      opts._render = opts.__r = (vnode) => {
          const comp = isPreactMangled ? vnode.__c : vnode._component;
          componentStack.push(comp);
          if (oldRender)
              oldRender(vnode);
      };
      // options._hook
      opts._hook = opts.__h = (comp, index, type) => {
          const testComp = componentStack[componentStack.length - 1];
          if (!comp || testComp !== comp) {
              throw new Error('Hook can only be invoked from render methods.');
          }
      };
      // options._catchError
      opts._catchError = opts.__e = (error, vnode, oldVNode, errorInfo) => {
          removeCompFromStack(vnode);
          if (oldCatchError)
              oldCatchError(error, vnode, oldVNode, errorInfo);
      };
      // options.diffed
      opts.diffed = (vnode) => {
          removeCompFromStack(vnode);
          if (oldDiffed)
              oldDiffed(vnode);
      };
  }

  /**
   * Class decorator for VComponent custom elements. Takes the tag name
   * of the custom element.
   * @param {string} tagName The custom element tag name
   * @name customElement
   * @function
   * @ojexports
   * @memberof ojvcomponent
   * @ojdecorator
   */

  /**
   * Class decorator for VComponent custom elements that specifies a list of Preact Contexts
   * whose values should be made available to the inner virtual dom tree of the VComponent when
   * rendered as an intrinsic element.  This allows the inner virtual dom tree to have access to
   * the Context values from the parent component when rendered either directly as part of the parent
   * component's virtual dom tree or when rendered as template slot content in a parent VComponent.  Note
   * that any intrinsic elements within the inner virtual dom tree must also specify a list of Contexts
   * to further propagate their values.
   *
   * @param {$$$Array<Context<any>>} contexts The list of Preact Contexts
   * @name consumedContexts
   * @function
   * @ojexports
   * @memberof ojvcomponent
   * @ojdecorator
   */

  /**
   * Method decorator for VComponent class methods that should be exposed on the custom element
   * as part of its public API. Non-decorated VComponent class methods will not be made available
   * on the custom element.
   * @name method
   * @function
   * @ojexports
   * @memberof ojvcomponent
   * @ojdecorator
   */

  /**
   * @ojmodulecontainer ojvcomponent
   * @ojhidden
   * @since 11.0.0
   * @ojtsimport {module: "ojmetadata", type: "AMD", importName:"MetadataTypes"}
   * @classdesc
   * <p>The VComponent API is a mechanism for creating virtual DOM-based
   * Web Components.  VComponents are authored in TypeScript as either
   * <a href="https://preactjs.com/">Preact</a> class-based
   * components or function-based components.  Class-based components specify their
   * custom element tag via the <a href="#customElement">&#64;customElement</a> decorator:
   * </p>
   * <pre class="prettyprint"><code>import { Component, ComponentChild } from 'preact';
   * import { customElement, GlobalProps } from 'ojs/ojvcomponent';
   *
   * &#64;customElement('oj-hello-world')
   * export class HelloWorld extends Component&lt;GlobalProps&gt; {
   *   render(): ComponentChild {
   *     return &lt;div&gt;Hello, World!&lt;/div&gt;;
   *   }
   * }
   * </code></pre>
   * Function-based components register their custom element tag with the VComponent
   * framework via the <a href="#registerCustomElement">registerCustomElement</a>
   * function:
   * <pre class="prettyprint"><code>import { registerCustomElement } from 'ojs/ojvcomponent';
   *
   * export const HelloWorld = registerCustomElement(
   *   'oj-hello-world',
   *   () => {
   *     return &lt;div&gt;Hello, World!&lt;/div&gt;;
   *   }
   * );
   * </code></pre>
   * <p>
   *   In order to prepare the component for use, the VComponent must be run
   *   through the <a href="https://www.npmjs.com/package/@oracle/ojet-cli">ojet
   *   CLI</a> build process.  Running <code>ojet build</code> will do the
   *   following:
   * </p>
   * <ul>
   *   <li>Inject necessary information into the module to enable Web Component
   *   usage.</li>
   *   <li>Generate a type definition that includes Web Component type info.</li>
   *   <li>Generate a component.json metadata file for enabling integration
   *   with <a href="https://developer.oracle.com/visual-builder/">Oracle
   *   Visual Builder</a></li>
   * </ul>
   * <p>
   *   Once the VComponent has been built, it can either be consumed as a
   *   plain old Web Component in HTML content, for example:
   * </p>
   * <pre class="prettyprint"><code>&lt;!-- This is HTML: --&gt;
   * &lt;oj-hello-world&gt;&lt;/oj-hello-world&gt;
   * </code></pre>
   * <p>
   *   Or via the Preact component class in JSX:
   * </p>
   * <pre class="prettyprint"><code>// This is JSX:
   * const hw =  &lt;HelloWorld /&gt;
   * </code></pre>
   * <p>
   *   These both produce the same DOM content.  That is, in both cases, an
   *   &lt;oj-hello-world&gt; custom element is created and added to the DOM.  In
   *   the case where the VComponent is referenced via its Preact component
   *   class, this custom element is automatically created and wrapped around
   *   the rendered content (the &lt;div&gt; in the above example) by the
   *   VComponent framework.
   * </p>
   * <h3 id="creating">
   *  Creating VComponents
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#creating"></a>
   * </h3>
   * <p>
   *   VComponents can be created either by hand or via the ojet
   *   CLI's "create component" command, for example:
   * </p>
   * <pre class="prettyprint"><code>$ ojet create component oj-hello-world --vcomponent
   * </code></pre>
   * <p>
   *   When running the <code>ojet create component</code> commmand, the custom
   *   element tag name is specified as an argument, and the --vcomponent flag
   *   indicates that a VComponent (as opposed to a Composite Component) should
   *   be created.
   * </p>
   * <p>
   *   (Note: if the application was originally created using the --vdom
   *   flag, the <code>ojet create component</code> command will default to
   *   creating VComponents and the --vcomponent flag can be omitted.
   * </p>
   * <p>
   * The ojet create component command creates some
   * supporting artifacts, including:
   * </p>
   * <ul>
   *   <li>A loader module</li>
   *   <li>A style sheet and SASS files for theming</li>
   *   <li>A resource module for translated strings</li>
   * </ul>
   * <p>
   *   In addition, ojet will ensure that the path to the VComponent is
   *   properly configured in the application's tsconfig.json
   * </p>
   * <h3 id="properties">
   *  Properties
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#properties"></a>
   * </h3>
   * <p>
   *   VComponents/Preact components declare their supported properties
   *   via a type parameter. For example, as we saw above:
   * </p>
   * <pre class="prettyprint"><code>export class HelloWorld extends Component&lt;GlobalProps&gt; {
   * </code></pre>
   * <p>
   *   With this declaration, the component indicates that it supports
   *   the properties specified via the
   *   <a href="#GlobalProps">GlobalProps</a> type.  This type
   *   includes a subset of the
   *   <a href="https://html.spec.whatwg.org/#global-attributes">
   *   global HTML attributes</a> which represent
   *   the minimally required set of properties that all VComponents
   *   must support.
   * </p>
   * <p>
   *   VComponents can, of course, expose other non-global,
   *   component-specific properties as well.  This is typically done by
   *   declaring a type alias:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *   greeting?: string;
   *   name?: string;
   * }
   * </code></pre>
   * <p>
   *   And associating this type with the first type parameter in the
   *   <a href="https://preactjs.com/guide/v10/api-reference#component">
   *   Component</a> class declaration.
   * </p>
   * <p>
   *   Since VComponents are minimally required to support the
   *   global HTML attributes defined by GlobalProps, the
   *   component-specific props must be combined with GlobalProps.  The
   *   VComponent API includes a utility type to help with this:
   *   <a href="#ExtendGlobalProps">ExtendGlobalProps</a>.
   *   Using ExtendGlobalProps, a component with
   *   the above Props type (including some default values) ends up looking like:
   * </p>
   * <pre class="prettyprint"><code>import { Component, ComponentChild } from 'preact';
   * import { customElement, ExtendGlobalProps } from 'ojs/ojvcomponent';
   *
   * type Props = {
   *   greeting?: string;
   *   name?: string;
   * }
   *
   * &#64;customElement('oj-hello-world-with-props')
   * export class HelloWorld extends Component&lt;ExtendGlobalProps&lt;Props&gt;&gt; {
   *   render(props: Readonly&lt;Props&gt;): ComponentChild {
   *     const { greeting, name } = props;
   *
   *     return &lt;div&gt;{ greeting }, { name }!&lt;/div&gt;;
   *   }
   *
   *   static defaultProps: Props = {
   *     greeting: "Hello",
   *     name: "World"
   *   };
   * }
   * </code></pre>
   * <p>
   *   In Preact, properties can be accessed either through this.props
   *   or via the first argument of the render method.
   * </p>
   * <p>
   *   Properties can be set on the component in various ways, including:
   * </p>
   * <ol>
   *   <li>As attributes in HTML markup</li>
   *   <li>As properties in JSX</li>
   *   <li>As properties on the DOM element</li>
   * </ol>
   * <p>
   *   One note on naming conventions: when referencing properties within JSX
   *   or on a DOM element (#2 and #3), the property name as specified in the
   *   component type is always used.
   * </p>
   * <p>
   *   However, for attributes in HTML markup (#1), JET uses a different
   *   naming convention for multi-word attributes.  As discussed in
   *   <a href="CustomElementOverview.html#ce-proptoattr-section">
   *   Property-to-Attribute Mapping</a>, JET converts camelCased property names
   *   into hyphen-separated, kebab-case attribute names.  As such, given the
   *   following property:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *     preferredGreeting?: string;
   * }
   * </code></pre>
   * <p>
   *   The attribute name "preferred-greeting" is used in HTML markup:
   * </p>
   * <pre class="prettyprint"><code>&lt;!-- This is HTML --&gt;
   * &lt;oj-hello-world preferred-greeting="Hi"&gt;&lt;/oj-hello-world&gt;
   * </code></pre>
   * <p>
   *   And the unmodified property name is used everywhere else:
   * </p>
   * <pre class="prettyprint"><code>// This is JSX
   * function Parent() {
   *   return &lt;HelloWorld preferredGreeting="Hi" /&gt;
   * }
   *
   * // This is also JSX
   * function ParentOfCustomElement() {
   *   return &lt;oj-hello-world preferredGreeting="Hi" /&gt;
   * }
   *
   * // This is plain old DOM
   * const helloWorld = document.createElement("oj-hello-world");
   * helloWorld.preferredGreeting = "Hi";
   * </code></pre>
   * </p>
   * <h3 id="children">
   *  Children and Slots
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#children"></a>
   * </h3>
   * <p>
   *   Many Web Components allow children to be specified, either as
   *   direct children or via named
   *   <a href="CustomElementOverview.html#ce-slots-section">slots</a>.
   *   A VComponent indicates
   *   that it takes arbitrary (non-named) children by declaring a "children"
   *   property using Preact's ComponentChildren type.  Named slots are
   *   declared in a similar fashion, using the
   *   VComponent-specific <a href="#Slot">Slot</a> type:
   * </p>
   * <pre class="prettyprint"><code>import { Component, ComponentChildren } from 'preact';
   * import { customElement, ExtendGlobalProps, Slot } from 'ojs/ojvcomponent';
   *
   * type Props = {
   *   // This indicates that the VComponent accepts arbitrary
   *   // (non-slot) children:
   *   children?: ComponentChildren;
   *
   *   // And this indicates that the VComponent accepts a
   *   // slot named "start"
   *   start?: Slot;
   * }
   * </code></pre>
   * <p>
   *   Both children and slots can be embedded directly in a virtual DOM
   *   tree:
   * </p>
   * <pre class="prettyprint"><code>  render(props: Readonly&lt;Props&gt;): ComponentChild {
   *     return (
   *       &lt;div&gt;
   *         // Place the start slot before our greeting
   *         { props.start }
   *
   *         Hello, World!
   *
   *         &lt;div&gt;
   *           // And dump any other children in a wrapper div
   *           { props.children }
   *         &lt;/div&gt;
   *       &lt;/div&gt;
   *     );
   *   }
   * </code></pre>
   * <p>
   *   In cases where the VComponent needs to inspect children or
   *   slot content, these values must first be normalized to a
   *   flattened array by calling Preact's
   *   <a href="https://preactjs.com/guide/v10/api-reference/#tochildarray">
   *   toChildArray</a>.
   * </p>
   * <p>
   *   When consuming the VComponent as a custom element, slots are
   *   specified using the slot attribute:
   * </p>
   * <pre class="prettyprint"><code>      &lt;!-- This is HTML --&gt;
   *       &lt;oj-hello-world-with-children&gt;
   *         &lt;!-- This is the start slot content: --&gt;
   *         &lt;oj-avatar slot="start" initials="HW"&gt;&lt;/oj-avatar&gt;
   *
   *         &lt;!-- This is other child content: --&gt;
   *         &lt;span&gt;Child content&lt;/span&gt;
   *       &lt;/oj-hello-world-with-children&gt;
   * </code></pre>
   * <p>
   *   However, when referencing the VComponent as a Preact component,
   *   slots are configured as plain old component properties:
   * </p>
   * <pre class="prettyprint"><code>function Parent() {
   *   return (
   *     &lt;HelloWorldWithChildren start={ &lt;oj-avatar initials="OJ" /&gt; }&gt;
   *       &lt;span&gt;Child content&lt;/span&gt;
   *     &lt;/HelloWorldWithChildren&gt;
   *   )
   * }
   * </code></pre>
   * <p>
   *   In some scenarios, JET application developers may require runtime access to a
   *   <a href="oj.BusyContext.html">BusyContext</a> scoped to a VComponent's children
   *   or to a particular named slot's contents. For example, application developers may
   *   require a mechanism for waiting until all of a slot's component contents have been created
   *   and initialized before programmatically interacting with the contents. For these scenarios,
   *   the VComponent API provides a <a href="#ImplicitBusyContext">ImplicitBusyContext</a> marker type
   *   that can be included via intersection with the ComponentChildren or Slot property declaration.
   * </p>
   * <h3 id="template-slots">
   *  Template Slots
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#template-slots"></a>
   * </h3>
   * <p>
   *   As with other JET components, VComponents can expose
   *   <a href="CustomElementOverview.html#ce-slots-template-section">
   *   template slots.</a>
   *   Template slots differ from plain old slots in that they are invoked
   *   with some context.  Template slots are most commonly used within
   *   iterating "collection" components, which need to stamp out some bit of
   *   content corresponding to each value/row/item in a data set.
   * </p>
   * <p>
   *   Like other slots, template slots are declared as properties.  Rather
   *   than using the Slot type, the <a href="#TemplateSlot">TemplateSlot</a>
   *   type is used:
   * </p>
   * <pre class="prettyprint"><code>import { Component } from "preact";
   * import { customElement, ExtendGlobalProps, TemplateSlot } from "ojs/ojvcomponent";
   *
   * type Props = {
   *   // This indicates that the VComponent exposes a template
   *   // slot named "itemTemplate":
   *   itemTemplate?: TemplateSlot&lt;ItemContext&gt;;
   * }
   *
   * // This is the type for the context that we'll
   * // pass into the itemTemplate slot
   * type ItemContext = {
   *   index?: number;
   *   label?: string;
   *   value?: string;
   * }
   * </code></pre>
   * <p>
   *   TemplateSlot is a function type that takes a single parameter:
   *   the context that is passed in when the template slot is
   *   rendered.  The VComponent invokes the template slot function
   *   with this context and embeds the results in the virtual DOM tree:
   * </p>
   * <pre class="prettyprint"><code>// Invoke the template slot and embed the results
   * // in a list item:
   * &lt;li&gt; {
   *   props.itemTemplate?.({
   *     index: currentIndex,
   *     label: currentLabel,
   *     value: currentValue
   *   })
   * }
   * &lt;/li&gt;
   * </code></pre>
   * <p>For each template slot, type alias definitions representing the context and renderer function signature are generated
   * at build time as part of the corresponding custom element namespace. The names of these type alias definitions
   * are derived from a base which, by default, is the template slot name. This base is converted from <i>camelCase</i> to
   * <i>PascalCase</i> to determine a <code>&lt;RootName&gt;</code>, and then the resulting type alias names are
   * '<code>&lt;RootName&gt;</code>Context' for the context type and 'Render<code>&lt;RootName&gt;</code>' for the
   * renderer function signature type. In addition:
   * <ul><li>if a template slot is defined with an empty context object, then no corresponding context type alias definition will
   * be generated;</li>
   * <li>the VComponent author can override the default base used to derive a particular template slot's type alias definition names
   * by specifying a value for an optional <code>templateSlotAlias</code> metadata property associated with that template slot.</li></ul></p>
   * <p>Note that while component consumers specify the contents for a template slot using a
   * &lt;template> element and standard HTML markup, the component implementation sees template slots as functions
   * that return virtual DOM nodes.  This transformation between live DOM and virtual DOM is performed
   * through the use of a <a href="oj.CspExpressionEvaluator.html">CSPExpressionEvaluator</a> instance.  This has
   * two consequences:
   * <ul><li>expressions used within VComponent template slots are subject to the syntax
   * <a href="oj.CspExpressionEvaluator.html#invalidExpressions">limitations</a> documented by
   * CSPExpressionEvaluator;</li>
   * <li>globally-scoped variables are not available within expressions unless the
   * application has registered a CSPExpressionEvaluator with a
   * <a href="oj.CspExpressionEvaluator.html#CspExpressionEvaluator">global scope</a> that exposes
   * these variables.</li></ul></p>
   * <h3 id="actions">
   *  Actions and Events
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#actions"></a>
   * </h3>
   * <p>
   *   As with other types of Web Components, VComponents can be the source
   *   of events, typically fired in response to some user interaction.
   *   VComponents specify their event contracts by declaring properties of
   *   the form "on&lt;PascalCaseEventName&gt;" of type
   *   <a href="#Action">Action</a>.  For example, the
   *   following declaration indicates that the component fires a
   *   "greetingComplete" event:
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps, Action } from 'ojs/ojvcomponent';
   *
   * type Props = {
   *   onGreetingComplete?: Action;
   *
   *   // Other component props...
   * }
   * </code></pre>
   * <p>
   *   Action is a function type that optionally takes an argument
   *   representing the event detail payload.  For events that include a
   *   detail payload, the detail type is specified via a type parameter:
   * </p>
   * <pre class="prettyprint"><code>type Detail = {
   *   status: "success" | "failure";
   * }
   *
   * type Props = {
   *   onGreetingComplete?: Action&lt;Detail&gt;;
   * }
   * </code></pre>
   * <p>
   *   The VComponent triggers the event by invoking the Action property and
   *   providing the detail payload:
   * </p>
   * <pre class="prettyprint"><code>  this.props.onGreetingComplete?.({ status: "success"});
   * </code></pre>
   * <p>
   *   When used in custom element form, this dispatches an
   *   actual DOM
   *   <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent">
   *   CustomEvent</a>.  See the
   *   <a href="CustomElementOverview.html#ce-events-section">Events and
   *   Listeners</a> topic for
   *   details on how to respond to these events.
   * </p>
   * <p>
   *   By default, events that are dispatched by the VComponent framework do
   *   not bubble.  See the <a href="#Bubbles">Bubbles</a> type for info on
   *   how to declare bubbling events.
   * </p>
   * <p>
   *   When consumed as a Preact component, no DOM events are created or
   *   dispatched.  Instead, the Action callback is simply invoked directly.
   *   There is no automatic event bubbling-like behavior in this case.
   * </p>
   * <p>
   *  The VComponent API also supports a contract for actions/events that
   *  can be vetoed by the consumer.  See the
   *  <a href="#CancelableAction">CancelableAction</a> type for details.
   * </p>
   * <h3 id="methods">
   *  Methods
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#methods"></a>
   * </h3>
   * <p>
   *  Some Web Components need to expose non-standard, component specific
   *  methods on their custom elements.  For example, the
   *  <a href="oj.ojPopup.html">&lt;oj-popup&gt;</a>
   *  custom element exposes
   *  <a href="oj.ojPopup.html#open">open</a>,
   *  <a href="oj.ojPopup.html#isOpen">isOpen</a> and
   *  <a href="oj.ojPopup.html#close">close</a> methods.
   * </p>
   * <p>
   *  While it is preferable to favor declarative, property-driven APIs over
   *  imperative, method-centric contracts, the VComponent API does allow
   *  components to expose methods on their custom elements.
   * </p>
   * <p>
   *  By default, no methods defined on a VComponent class are surfaced
   *  on the custom element.  To indicate that a VComponent class method should be
   *  included in the custom element's public API, simply mark the method with the
   *  <a href="#method">&#64;method</a> decorator.
   * </p>
   * <p>
   *  Function-based VComponents that wish to expose public methods must wrap their Preact
   *  functional component implementation in a call to
   *  <a href="https://preactjs.com/guide/v10/switching-to-preact/#forwardref">forwardRef</a>
   *  at the time of registration with the VComponent framework, and leverage the
   *  <code>useImperativeHandle</code> hook within their Preact implementation. See
   *  the <a href="#registerCustomElement">registerCustomElement</a> function for further details.
   * </p>
   * <h3 id="writeback">
   *  Writeback Properties
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#writeback"></a>
   * </h3>
   * <p>
   *   JET-based Web Components support a mechanism by which components can
   *   trigger changes to their own properties.  For example, the JET input
   *   and select components notify consumers of changes to the value
   *   property as the user enters new values.  When combined with two-way
   *   binding, this can be used to update values referenced via JET binding
   *   expressions.  This process is known as "writeback".  See the
   *   <a href="CustomElementOverview.html#ce-databind-writeback-section">
   *   Writeback</a> section in the
   *   <a href="CustomElementOverview.html">JET Web Components</a> topic
   *   for background.
   * </p>
   * <p>
   *   VComponents declare writeback properties by pairing a normal property
   *   declaration with a companion callback property that is invoked when the
   *   component wants to trigger a writeback.  For example, this plain old
   *   (non-writeback) value property:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *
   *   // This is a plain old (non-writeback) value property:
   *   value?: string;
   * }
   * </code></pre>
   * <p>
   *   Can be converted into a writeback property by adding a second property named
   *   "onValueChanged":
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps, PropertyChanged } from "ojs/ojvcomponent";
   *
   * type Props = {
   *   value?: string;
   *
   *   // The presence of this callback promotes "value" into a
   *   // writeback property
   *   onValueChanged?: PropertyChanged&lt;string&gt;;
   * }
   * </code></pre>
   * <p>
   *   Both the event name and type are significant.  In order to be
   *   recognizable as a writeback property, the companion callback property
   *   must follow the naming convention "on&lt;PropertyName&gt;Changed" and must
   *   be of type <a href="#PropertyChanged">PropertyChanged</a>.
   * </p>
   * <p>
   *   Similar to Actions, invoking a PropertyChanged callback has different
   *   implications depending on whether the VComponent is being consumed as
   *   a custom element or as a Preact component.
   * </p>
   * <p>
   *   When the VComponent is used in its custom element form, invoking the
   *   PropertyChanged callback results in an actual DOM
   *   <a href="CustomElementOverview.html#ce-properties-changed-section">
   *   propertyChanged event</a>
   *   being created and dispatched.  This allows JET's two-way binding
   *   mechanism to kick in.  If the property is configured with a two-way
   *   binding, the new value will be written back into the expression.
   * </p>
   * <p>
   *   In addition, when used as a custom element, triggering a writeback
   *   automatically queues a render of the VComponent, allowing the
   *   VComponent to re-render with the new value.
   * </p>
   * <p>
   *   When the VComponent is used via its Preact component class, no DOM
   *   event is created or dispatched.  Instead, the PropertyChanged callback
   *   is simply invoked with the new value.  The parent component is then
   *   responsible for deciding whether re-render with the new value or not.
   * </p>
   * <p>
   *   The VComponent API also supports writeback properties which can be
   *   read/observed by the consumer, but are only ever written by the
   *   component itself.  These are known as
   *   <a href="CustomElementOverview.html#ce-properties-readonlywriteback-section">
   *   read-only writeback properties</a>.
   *   See the <a href="#ReadOnlyPropertyChanged">ReadOnlyPropertyChanged<a> type for info on how
   *   to configure these properties.
   * </p>
   * <h3 id="observed">
   *  Observed Global Properties
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#observed"></a>
   * </h3>
   * <p>
   *   As discussed above, all VComponents minimally support the set of
   *   global HTML attributes defined by the GlobalProps/ExtendGlobalProps
   *   types.  This means that when consuming a VComponent either via its
   *   custom element tag or VComponent class, global attributes (e.g., id,
   *   tabIndex, title, etc...) can be specified:
   * </p>
   * <pre class="prettyprint"><code>function Parent() {
   *   // We can pass GlobalProps like id into any VComponent:
   *   return &lt;HelloWorld id="hw" /&gt;
   * }
   * </code></pre>
   * <p>
   *   The VComponent framework automatically transfers any global properties
   *   through to the underlying custom element in the DOM.
   * <p>
   *   In some cases, the VComponent implementation may need to inspect the
   *   values of these global properties.  In addition, VComponents may need
   *   to respond by re-rendering themselves when a global property is
   *   modified on the custom element.  In such cases, VComponents can
   *   express interest in specific global properties via the
   *   <a href="#ObservedGlobalProps">ObservedGlobalProps</a>
   *   utility type.  This type allows specific global
   *   properties to be selected for observation via a type parameter.  This
   *   type is combined with the component's other properties as part of the
   *   property declaration.
   * </p>
   * <p>
   *   The following property declaration indicates that the component
   *   exposes "greeting" and "name" properties and also observes the global
   *   "id" and "tabIndex" props:
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps, ObservedGlobalProps } from 'ojs/ojvcomponent';
   *
   * type Props = {
   *   greeting?: string;
   *   name?: string;
   * } & ObservedGlobalProps&lt;'id' | 'tabIndex'&gt;
   * </code></pre>
   * <p>
   *   Any props that are specified via ObservedGlobalProps are automatically
   *   included in the custom element's observed attributes set.  As a
   *   result, any mutations to the one of these attributes on the custom
   *   element will automatically trigger a re-render of the VComponent with
   *   the new values. Note that event listener props are <i>not</i> eligible
   *   for inclusion in the observed attributes set.
   * </p>
   * <p>
   *   Global attributes referenced with the ObservedGlobalProps utility type do not appear in the
   *   VComponent's generated API Doc. If any observed global properties require context-specific
   *   documentation in the generated API Doc, then an alternate syntax is also supported:  simply include
   *   the global prop in the VComponent's Props definition, specifying as its declaration a GlobalProps
   *   indexed access type reference to the same global prop. Note that the following variation of the
   *   previous example is functionally equivalent:
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps, GlobalProps, ObservedGlobalProps } from 'ojs/ojvcomponent';
   *
   * type Props = {
   *   greeting?: string;
   *   name?: string;
   *
   *   /&#42;&#42;
   *    &#42; Specifies this custom element's focusable behavior during sequential keyboard navigation.
   *    &#42; A value of -1 indicates that this component is not reachable through keyboard navigation.
   *    &#42;/
   *   tabIndex?: GlobalProps['tabIndex'];  // include 'tabIndex' in the observed attribute set AND the API Doc
   *
   * } & ObservedGlobalProps&lt;'id'&gt;    // include 'id' in the observed attribute set
   * </code></pre>
   * <h3 id="root-element">
   *  Root Element
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#root-element"></a>
   * </h3>
   * <p>
   *   In all of the VComponents that we have seen so far, the root custom
   *   element is not included in the rendered output.  Instead, this element
   *   is implicitly injected into the DOM by the VComonent framework.
   * </p>
   * <p>
   *   In some rare cases, it may be necessary to have more control over how
   *   the the root element is rendered.
   * </p>
   * <p>
   *   For example, consider this case of a VComponent that renders a link:
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps, ObservedGlobalProps } from "ojs/ojvcomponent";
   * import { Component, ComponentChild } from "preact";
   *
   * type Props = {
   *   href?: string;
   * } & ObservedGlobalProps&lt;'tabIndex'&gt;;
   *
   * &#64;customElement("oj-demo-link")
   * export class OjDemoLink extends Component&lt;ExtendGlobalProps&lt;Props&gt;&gt; {
   *
   *   render(props: Props): ComponentChild {
   *     return &lt;a href={ props.href } tabIndex={ props.tabIndex }&gt;Hello, World&lt;/a&gt;;
   *   }
   * }
   * </code></pre>
   * <p>
   *   The intent is that the value of the global tabIndex attribute will be
   *   transferred from the root element down to the link.
   * </p>
   * <p>
   *   However, since the tabIndex value will be automatically rendered on
   *   the root custom element, we end up with the tabIndex on two elements:
   *   on the root &lt;oj-demo-link&gt; and on the &lt;a&gt;.
   * </p>
   * <p>
   *   To address this, we can update the render method to render both the
   *   link *and* the root custom element.  The VComponent API includes a
   *   simple component that acts as a placeholder for the root element,
   *   named "Root".  The <a href="#Root">Root</a> component is exported from the
   *   "ojs/ojvcomponent" module, so we add this in our import list:
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps, ObservedGlobalProps, Root } from "ojs/ojvcomponent";
   * </code></pre>
   * <p>
   *   And then we can include the Root component in the virtual DOM tree,
   *   adjusting exactly which properties are rendered:
   * </p>
   * <pre class="prettyprint"><code>  render(props: Props): ComponentChild {
   *     return (
   *       // Suppress the tabIndex on the root custom element since
   *       // we are transferring this to the link
   *       &lt;Root tabIndex={ -1 }&gt;
   *
   *         // Render the tabIndex here:
   *         &lt;a href={ props.href } tabIndex={ props.tabIndex }&gt;Hello, World&lt;/a&gt;
   *       &lt;/Root&gt;
   *     );
   *   }
   * </code></pre>
   * <p>
   *   The presence of the Root component impacts how global properties are
   *   managed.  When the Root component is omitted, all global properties,
   *   both observed and non-observed, are automatically passed through to the
   *   root custom element.  When the Root component is included at the root
   *   of the rendered virtual DOM tree, non-observed global properties are
   *   still passed through to the root custom element.  However only those
   *   observed global properties that are explicitly rendered on the Root
   *   component will be passed through.
   * </p>
   */

  // TYPEDEFS

  /**
   * <p>
   *  The Action type is used to identify properties as action callbacks.
   *  Actions are functions that the VComponent invokes when it wants to
   *  communicate some activity to the outside world.  When the VComponent
   *  is being consumed as a custom element, this results in an actual DOM
   *  <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent">
   *  CustomEvent</a> being dispatched.  Alternatively, when the VComponent is
   *  referenced via its Preact Component class, the provided callback is
   *  invoked directly and no CustomEvent is produced.
   * </<p>
   * <p>
   *  Actions have an optional detail type, specified by an optional generic
   *  type parameter to the Action type.  If the type parameter is supplied when the
   *  the action callback property is defined, then a detail value of that specified type
   *  is either passed to the consumer via the CustomEvent detail payload for the custom element case,
   *  or is directly passed as an argument of the callback function for the Preact component case.
   * </p>
   * <p>
   *  Note that Action properties must adhere to a specific naming
   *  convention: "on&lt;PascalCaseEventName&gt;".  For the custom element case,
   *  the type of the CustomEvent will be derived by converting the first
   *  character of the event name to lower case.  Thus, the
   *  "onGreetingComplete" property will generate a CustomEvent of type
   *  "greetingComplete".
   * </p>
   * <p>
   *  See <a href="#actions">Actions and Events</a> for more info.
   * </p>
   * @typedef {Function} Action
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [
   *   {target:"Type", value:"<Detail = {}>", for:"genericTypeParameters"},
   *   {target: "Type", value: "[keyof Detail] extends [never] ? (detail?: Detail) => void : (detail: Detail) => void"}
   * ]
   */

  /**
   * <p>
   *  As discussed in <a href="#actions">Actions and Events</a>,  the custom
   *  events generated by Actions do not bubble by default.  The
   *  Bubbles marker type can be combined with the <a href="#Action">Action</a>
   *  type to indicate that the Action's custom events should bubble.
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *   // This action generates bubbling custom events
   *   onThisActionBubbles?: Action & Bubbles;
   *
   *   // This action generates non-bubbling custom events
   *   onThisActionDoesNotBubble?: Action;
   * }
   * </code></pre>
   * @typedef {Object} Bubbles
   * @ojexports
   * @memberof ojvcomponent
   */

  /**
   * <p>
   *   Some JET Web Components support an asynchronous, event-based
   *   cancelation contract where prior to performing some operation, the
   *   component dispatches a "cancelable" event.  If the application cancels
   *   the event, the operation is not performed.  The
   *   <a href="oj.ojFilePicker.html">&lt;oj-file-picker&gt;</a>'s
   *   <a href="oj.ojFilePicker.html#event:beforeSelect">ojBeforeSelect</a>
   *   event is one example of such an API.
   * </p>
   * <p>
   *   The VComponent API has built-in support for this pattern via the
   *   CancelableAction type.  Like the plain old <a href="#Action">Action</a>
   *   type, CancelableAction is a function type that is used for defining
   *   callback-centric properties.  One key difference between these types
   *   is that CancelableAction returns a Promise.  If the Promise resolves
   *   successfully, the action is considered to be accepted.  If the Promise
   *   is rejected, the action is canceled.
   * </p>
   * <p>
   *   As with Action-typed properties, CancelableActions exhibit different
   *   behavior depending on whether the VComponent is being consumed as a
   *   custom element or via its Preact Component class.
   * </p>
   * <p>
   *   When consumed as a custom element, invoking a CancelableAction results
   *   in a CustomEvent being created and dispatched.  The detail payload of
   *   this custom event is augmented with one extra field: an "accept"
   *   method.  The accept method takes a single argument: the Promise that
   *   produces the cancelation result.
   * </p>
   * <p>
   *   When consumed via the Preact Component class, no custom event is
   *   dispatched.  Instead, the callback function returns the cancelation promise
   *   directly.
   * </p>
   * @typedef {Function} CancelableAction
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [
   *   {target:"Type", value:"<Detail extends object = {}>", for:"genericTypeParameters"},
   *   {target: "Type", value: "[keyof Detail] extends [never] ? (detail?: Detail) => Promise<void> : (detail: Detail) => Promise<void>"}
   * ]
   */

  /**
   * <p>
   *   In most cases when a Web Component accepts slot content, the number
   *   and names of the slots are known, as these are defined by the
   *   component's public API.  However, in some cases components may allow
   *   an arbitrary number of slots to be specified, where the slot names are not
   *   known up front.  The &lt;oj-switcher&gt; component
   *   is an example of a component that accepts a dynamically defined
   *   (rather than predefined) set of slots.
   * </p>
   * <p>
   *   The VComponent API supports such cases via the DynamicSlots and
   *   <a href="#DynamicTemplateSlots">DynamicTemplateSlots</a> types.  A
   *   single property can be marked with the DynamicSlots type:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *
   *   // This property will be populated with all
   *   // "unknown" slots.
   *   items?: DynamicSlots;
   *
   *   // Other properties go here...
   * }
   * </code></pre>
   * <p>
   *   When the VComponent is consumed in custom element form, this property
   *   will be populated with entries for each "dynamic" slot.  That is,
   *   an entry will be added for each child element with a slot attribute that
   *   does not correspond to a known  Slot-typed property.
   *   The property acts as a map from slot name to <a href="#Slot">Slot</a>
   *   instance.  The VComponent can use whatever heuristic it prefers to
   *   decide which (if any) slots should be included in the rendered output.
   * </p>
   * @typedef {Object} DynamicSlots
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target: "Type", value: "Record<string, Slot>" }]
   */

  /**
   * <p>
   *  The DynamicTemplateSlots type is a companion to
   *  <a href="#DynamicSlots">DynamicSlots</a> that is used in cases
   *  where the component accepts an arbitrary number of
   *  <a href="#template-slots">template slots</a>.  VComponents may declare a
   *  single property of type DynamicTemplateSlots.  When the component is used as
   *  a custom element, this property will be populated with one entry for each
   *  "dynamic" template slot, where the key is the slot name and the value is a
   *  corresponding <a href="#TemplateSlot">TemplateSlot</a> function.
   * </p>
   * <p>
   *  Different TemplateSlot functions may require different context objects as arguments,
   *  so DynamicTemplateSlots can accept a union type for its type parameter.  The
   *  DynamicTemplateSlots type definition is structured to ensure that each union sub-type
   *  gets mapped to a separate TemplateSlot function.
   * </p>
   * <p>
   *   Note that each VComponent can only contain a single dynamic slot property.
   *   That is, each VComponent can have one property of type DynamicSlots or
   *   one property of type DynamicTemplateSlots, but not both.
   * </p>
   * @typedef {Object} DynamicTemplateSlots
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target:"Type", value:"<Data>", for:"genericTypeParameters"},
   *               {target: "Type", value: "Record<string, (Data extends object ? TemplateSlot<Data> : never)>" }]
   */

  /**
   * <p>
   *   By default, writeback property mutations can be driven either by the
   *   component, typically in response to some user interaction, or by the
   *   consumer of the component.  In some cases, writeback properties are
   *   exclusively mutated by the component itself.  Writeback properties
   *   that cannot be mutated by the consumer are known as
   *   <a href="CustomElementOverview.html#ce-properties-readonlywriteback-section">
   *   read-only writeback properties</a>.  The
   *   <a href="oj.ojInputText.html">&lt;oj-input-text&gt;</a>'s
   *   <a href="oj.ojInputText.html#rawValue">rawValue</a> property is an
   *   example of such a property.
   * </p>
   * <p>
   *   The ReadOnlyPropertyChanged type is used to identify callback properties that
   *   notify VComponent consumers of read-only writeback property mutations.
   *   Read-only writeback property callbacks must adhere to the naming convention of
   *   "on&lt;PropertyName&gt;Changed", where "PropertyName" is the name of the
   *   writeback property with the first character converted to upper case.
   * </p>
   * <p>
   *   Note that, unlike normal writeback properties that are declared by pairing
   *   a normal property declaration with a companion callback property, a read-only
   *   writeback property is declared solely by its callback property.
   * </p>
   * <p>
   *   Declarations for both forms of writeback properties can be seen below:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *
   *   // The following two fields establish a writeback property
   *   // named 'value'
   *   value?: string;
   *   onValueChanged?: PropertyChanged&lt;string&gt;
   *
   *   // The following field establishes a read-only writeback property
   *   // named 'rawValue'
   *   onRawValueChanged?: ReadOnlyPropertyChanged&lt;string&gt;
   * }
   * </code></pre>
   * @typedef {Object} ReadOnlyPropertyChanged
   * @ojexports
   * @memberof ojvcomponent
   */

  /**
   * <p>
   *   By default, writeback property mutations can be driven either by the
   *   component, typically in response to some user interaction, or by the
   *   consumer of the component.  In some cases, writeback properties are
   *   exclusively mutated by the component itself.  Writeback properties
   *   that cannot be mutated by the consumer are known as
   *   <a href="CustomElementOverview.html#ce-properties-readonlywriteback-section">
   *   read-only writeback properties</a>.  The
   *   <a href="oj.ojInputText.html">&lt;oj-input-text&gt;</a>'s
   *   <a href="oj.ojInputText.html#rawValue">rawValue</a> property is an
   *   example of such a property.
   * </p>
   * <p>
   *   Read-only writeback properties are declared in a similar manner to
   *   <a href="#writeback">plain old writeback properties</a>, with one important
   *   difference: the ElementReadOnly utility type is used as a marker to
   *   identify the that the property is read-only.
   * </p>
   * <p>
   *   Declarations for both forms of writeback properties can be seen below:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *
   *   // This is a normal writeback property:
   *   value?: string;
   *   onValueChanged?: PropertyChanged&lt;string&gt;
   *
   *   // This is a read-only writeback property:
   *   rawValue?: ElementReadOnly&lt;string&gt;;
   *   onRawValueChanged?: PropertyChanged&lt;string&gt;
   * }
   * </code></pre>
   * @typedef {Object} ElementReadOnly
   * @ojexports
   * @memberof ojvcomponent
   * @ojdeprecated {since: '12.0.0', description: 'Use the ReadOnlyPropertyChanged type instead.'}
   * @ojsignature [{target:"Type", value:"<T>", for:"genericTypeParameters"},
   *               {target: "Type", value: "T"}]
   */

  /**
   * <p>
   *   As discussed in the <a href="#properties">Properties</a> section,
   *   all VComponents must minimally include the
   *   <a href="#GlobalProps">GlobalProps</a> in their property types.
   *   ExtendGlobalProps is a convenience type for combining component-specific
   *   properties with GlobalProps, e.g.:
   * </p>
   * <pre class="prettyprint"><code>import { customElement, ExtendGlobalProps } from 'ojs/ojvcomponent';
   *
   * // These are the component-specific props:
   * type Props = {
   *   greeting?: string;
   *   name?: string;
   * }
   *
   * // Below we merge the component props with the
   * // global props using ExtendGlobalProps
   * &#64;customElement('oj-hello-world-with-props')
   * export class HelloWorld extends Component&lt;ExtendGlobalProps&lt;Props&gt;&gt; {
   * </code></pre>
   * @typedef {Object} ExtendGlobalProps
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target:"Type", value:"<Props>", for:"genericTypeParameters"},
   *               {target: "Type", value: "Readonly<Props> & GlobalProps"}]
   */

  /**
   * <p>
   *   The GlobalProps type defines the set of global properties that are
   *   supported by all VComponents.  This includes three categories of
   *   properties:
   * </p>
   * <ol>
   *   <li><a href="https://html.spec.whatwg.org/#global-attributes">
   *   Global HTML attributes</a></li>
   *   <li><a href="https://www.w3.org/TR/wai-aria-1.1/#state_prop_def">ARIA
   *     attributes</a></li>
   *   <li><a href="https://html.spec.whatwg.org/#event-handlers-on-elements,-document-objects,-and-window-objects">
   *     Global event listeners</a></li>
   * </ol>
   * <p>
   *   The following properties are included from category 1:
   * </p>
   * <ul>
   *   <li>accessKey</li>
   *   <li>autocapitalize</li>
   *   <li>autofocus</li>
   *   <li>class</li>
   *   <li>contentEditable</li>
   *   <li>dir</li>
   *   <li>draggable</li>
   *   <li>enterKeyHint</li>
   *   <li>hidden</li>
   *   <li>id</li>
   *   <li>inputMode</li>
   *   <li>lang</li>
   *   <li>role</li>
   *   <li>slot</li>
   *   <li>spellcheck</li>
   *   <li>style</li>
   *   <li>tabIndex</li>
   *   <li>title</li>
   *   <li>translate</li>
   * </ul>
   * <p>
   *   The following ARIA-specific attributes are included from category 2:
   * </p>
   * <ul>
   *   <li>aria-activedescendant</li>
   *   <li>aria-atomic</li>
   *   <li>aria-autocomplete</li>
   *   <li>aria-busy</li>
   *   <li>aria-checked</li>
   *   <li>aria-colcount</li>
   *   <li>aria-colindex</li>
   *   <li>aria-colspan</li>
   *   <li>aria-controls</li>
   *   <li>aria-current</li>
   *   <li>aria-describedby</li>
   *   <li>aria-details</li>
   *   <li>aria-disabled</li>
   *   <li>aria-errormessage</li>
   *   <li>aria-expanded</li>
   *   <li>aria-flowto</li>
   *   <li>aria-haspopup</li>
   *   <li>aria-hidden</li>
   *   <li>aria-invalid</li>
   *   <li>aria-keyshortcuts</li>
   *   <li>aria-label</li>
   *   <li>aria-labelledby</li>
   *   <li>aria-level</li>
   *   <li>aria-live</li>
   *   <li>aria-modal</li>
   *   <li>aria-multiline</li>
   *   <li>aria-multiselectable</li>
   *   <li>aria-orientation</li>
   *   <li>aria-owns</li>
   *   <li>aria-placeholder</li>
   *   <li>aria-posinset</li>
   *   <li>aria-pressed</li>
   *   <li>aria-readonly</li>
   *   <li>aria-relevant</li>
   *   <li>aria-required</li>
   *   <li>aria-roledescription</li>
   *   <li>aria-rowcount</li>
   *   <li>aria-rowindex</li>
   *   <li>aria-rowspan</li>
   *   <li>aria-selected</li>
   *   <li>aria-setsize</li>
   *   <li>aria-sort</li>
   *   <li>aria-valuemax</li>
   *   <li>aria-valuemin</li>
   *   <li>aria-valuenow</li>
   *   <li>aria-valuetext</li>
   * </ul>
   * <p>
   *   The following event listener properties are included
   *   from category 3:
   * </p>
   * <ul>
   *   <li>onBlur</li>
   *   <li>onClick</li>
   *   <li>onContextMenu</li>
   *   <li>onDblClick</li>
   *   <li>onDrag</li>
   *   <li>onDragEnd</li>
   *   <li>onDragEnter</li>
   *   <li>onDragExit</li>
   *   <li>onDragLeave</li>
   *   <li>onDragOver</li>
   *   <li>onDragStart</li>
   *   <li>onDrop</li>
   *   <li>onFocus</li>
   *   <li>onKeyDown</li>
   *   <li>onKeyPress</li>
   *   <li>onKeyUp</li>
   *   <li>onMouseDown</li>
   *   <li>onMouseEnter</li>
   *   <li>onMouseLeave</li>
   *   <li>onMouseMove</li>
   *   <li>onMouseOut</li>
   *   <li>onMouseOver</li>
   *   <li>onMouseUp</li>
   *   <li>onPointerOver</li>
   *   <li>onPointerEnter</li>
   *   <li>onPointerDown</li>
   *   <li>onPointerMove</li>
   *   <li>onPointerUp</li>
   *   <li>onPointerCancel</li>
   *   <li>onPointerOut</li>
   *   <li>onPointerLeave</li>
   *   <li>onTouchCancel</li>
   *   <li>onTouchEnd</li>
   *   <li>onTouchMove</li>
   *   <li>onTouchStart</li>
   *   <li>onWheel</li>
   *   <li>onfocusin</li>
   *   <li>onfocusout</li>
   * </ul>
   * <p>
   *   The above event listener properties can also be specified with
   *   the "Capture" suffix (e.g., "onClickCapture") to indicate that the
   *   listener should be registered as a capture listener.
   * </p>
   * @typedef {Object} GlobalProps
   * @ojexports
   * @memberof ojvcomponent
   */

  /**
   * <p>
   *   The ObservedGlobalProps type is used to identify the subset of
   *   <a href="#GlobalProps">GlobalProps</a> that the VComponent implementation
   *   needs to observe.  When a VComponent is used as a custom element,
   *   ObservedGlobalProps determines which of the GlobalProps values will be
   *   extracted from the DOM and passed into the VComponent.  Properties
   *   that are selected using ObservedGlobalProps are also included in
   *   the custom element's observedAttributes list.  As a result, updates to
   *   observed global properties will trigger the VComponent to render
   *   with the new values.
   * </p>
   * <p>
   *   The ObservedGlobalProps type acts as a Pick type, where properties are
   *   implicitly picked from GlobalProps.  The resulting type is typically
   *   merged with any component-specific properties via a union.
   * </p>
   * <p>
   *   See the <a href="#observed">Observed Global Properties</a> section for
   *   more details.
   * </p>
   * @typedef {Object} ObservedGlobalProps
   * @ojexports
   * @memberof ojvcomponent
   */

  /**
   * <p>
   *   The PropertyBindings type maps function-based VComponent property names to their corresponding
   *   <a href="MetadataTypes.html#PropertyBinding">PropertyBinding</a> metadata.
   * </p>
   * @typedef {Object} PropertyBindings
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "Partial<Record<keyof P, MetadataTypes.PropertyBinding>>"}]
   */

  /**
   * <p>
   *   The PropertyChanged type is used to identify callback properties that
   *   notify VComponent consumers of writeback property mutations.
   *   Writeback property callbacks must adhere to the naming convention of
   *   "on&lt;PropertyName&gt;Changed", where "PropertyName" is the name of the
   *   writeback property with the first character converted to upper case:
   * </p>
   * <pre class="prettyprint"><code>type Props = {
   *   // This is a writeback property
   *   value?: string;
   *
   *   // This is the corresponding property changed callback
   *   onValueChanged?: PropertyChanged&lt;string&gt;;
   * }
   * </code></pre>
   * <p>
   *   See the <a href="#writeback">Writeback Properties</a> section for
   *   more details.
   * </p>
   * @typedef {Object} PropertyChanged
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target:"Type", value:"<T>", for:"genericTypeParameters"},
   *               {target: "Type", value: "(value: T) => void"}]
   */

  /**
   * <p>
   *   The Slot type identifies properties as representing named slot
   *   children.  This type is an alias for Preact's ComponentChildren type.  As
   *   such, the value of a slot property can either be embedded directly in
   *   a virtual DOM tree or can be passed to Preact's
   *   <a href="https://preactjs.com/guide/v10/api-reference/#tochildarray">
   *   toChildArray</a>.
   * </p>
   * <p>
   *   See <a href="#children">Children and Slots</a> for more details.
   * </p>
   * @typedef {Function} Slot
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target: "Type", value: "ComponentChildren"}]
   */

  /**
   * <p>
   *   As discussed in <a href="#children">Children and Slots</a>, JET application developers
   *   may require a mechanism for waiting at runtime until all of a slot's component contents
   *   have been created and initialized before programmatically interacting with the contents.
   *   VComponent developers can request that a <a href="oj.BusyContext.html">BusyContext</a> instance,
   *   scoped to a VComponent's children or to a particular named slot's contents, be created
   *   at runtime by using the ImplicitBusyContext marker type. This marker type can be combined
   *   with Preact's ComponentChildren type or with the <a href="#Slot">Slot</a> type as needed:
   * </p>
   * <pre class="prettyprint"><code>import { Component, ComponentChildren } from 'preact';
   * import { customElement, ExtendGlobalProps, ImplicitBusyContext, Slot } from 'ojs/ojvcomponent';
   *
   * type Props = {
   *   // This indicates that the VComponent accepts arbitrary (non-slot) children,
   *   // and that a BusyContext scoped to this child content should be created at runtime
   *   children?: ComponentChildren & ImplicitBusyContext;
   *
   *   // This indicates that the VComponent accepts a slot named "end",
   *   // and that a BusyContext scoped to the slot's content should be created at runtime
   *   end?: Slot & ImplicitBusyContext;
   * }
   * </code></pre>
   * @typedef {unknown} ImplicitBusyContext
   * @ojexports
   * @memberof ojvcomponent
   */

  /**
   * <p>
   *  The Methods type specifies optional design-time method metadata that can be passed in the
   *  <code>options</code> argument when calling <a href=#registerCustomElement>registerCustomElement</a>
   *  to register a function-based VComponent that exposes custom element methods.
   * </p>
   * <p>
   *  The Methods type makes several adjustments to the
   *  <a href=MetadataTypes.html#ComponentMetadataMethods>MetadataTypes.ComponentMetadataMethods</a> type:
   *  <ul>
   *   <li>
   *    The <code>internalName</code> property does not apply to VComponents.
   *   </li>
   *   <li>
   *    The return type and parameter types are explicitly omitted from
   *    <a href=MetadataTypes.html#ComponentMetadataMethods>MetadataTypes.ComponentMetadataMethods</a> and
   *    <a href=MetadataTypes.html#MethodParam>MetadataTypes.MethodParam</a> respectively, as these should
   *    come from the function signatures passed as a type parameter to the
   *    <a href=#registerCustomElement>registerCustomElement</a> call.
   *   </li>
   *   <li>
   *    Optional <code>apidocDescription</code> and <code>apidocRtnDescription</code> properties are added
   *    to specify markup text for inclusion in the generated API Doc describing the method and its return
   *    value, respectively. If <code>apidocDescription</code> is unspecified, then the
   *    <code>description</code> property is used in the API Doc.
   *   </li>
   *  </ul>
   * </p>
   * @typedef {Object} Methods
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [
   *   {target:"Type", value:"<M>", for:"genericTypeParameters"},
   *   {target:"Type", value: "{Partial<Record<keyof M, Omit<MetadataTypes.ComponentMetadataMethods, 'internalName' | 'params' | 'return'> & { params?: Array<Omit<MetadataTypes.MethodParam, 'type'>>; apidocDescription?: string; apidocRtnDescription?: string; }>>}"}
   * ]
   * @ojdeprecated {since: "16.0.0", description: "Use doclet metadata within the type alias that maps method names to function signatures instead."}
   */

  /**
   * <p>
   *  The Contexts type allows a function-based VComponent to specify a list of Preact Contexts
   *  whose values should be made available to the inner virtual dom tree of the VComponent when
   *  rendered as an intrinsic element.  This allows the inner virtual dom tree to have access to
   *  the Context values from the parent component when rendered either directly as part of the parent
   *  component's virtual dom tree or when rendered as template slot content in a parent VComponent.  Note
   *  that any intrinsic elements within the inner virtual dom tree must also specify a list of Contexts
   *  to further propagate their values.
   * </p>
   * @typedef {Object} Contexts
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [
   *   {target:"Type", value: "$$${ consume?: Array<Context<any>> }"}
   * ]
   */

  /**
   * <p>
   *   The Options type specifies additional options that can be passed when calling
   *   <a href=#registerCustomElement>registerCustomElement</a> to register a function-based
   *   VComponent with the JET framework.
   * </p>
   * <p>
   *   These additional options come into play under certain circumstances:
   *   <ul>
   *    <li>
   *      Optional <code>bindings</code> metadata (see <a href="#PropertyBindings">PropertyBindings</a>
   *      for further details) are only honored when the VComponent custom element is used in a Knockout
   *      binding environment.
   *    </li>
   *    <li>
   *      Optional <code>contexts</code> metadata (see <a href="#Contexts">Contexts</a>
   *      for further details) are only honored when the VComponent is rendered as an intrinsic element
   *      in a virtual dom tree.
   *    </li>
   *   </ul>
   * </p>
   * <p>
   *   In the following example:
   *    <ul>
   *      <li>
   *        <code>FormFunctionalComponent</code> is a VComponent implementing a form that consumes
   *        'labelEdge' and 'readonly' properties from its parent container. It also provides values
   *        for 'labelEdge' and 'readonly' properties to its children with any necessary transformations.
   *      </li>
   *      <li>
   *        The implementation includes an input element, and the parent function-based VComponent exposes
   *        a public <code>focusInitialInput</code> method to set the focus on this element as needed.
   *      </li>
   *    </ul>
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, Ref } from 'preact';
   * import { useImperativeHandle, useRef } from 'preact/hooks';
   * import { forwardRef } from 'preact/compat';
   * import { registerCustomElement } from 'ojs/ojvcomponent';
   *
   * type Props = Readonly<{
   *   labelEdge?: 'inside' | 'start' | 'top';
   *   readonly?: boolean;
   * }>;
   *
   * type FormHandle = {
   *   // The doclet description appears in the generated API Doc, whereas the
   *   // @ojmetadata description appears in the generated component.json file.
   *   /&#42;&#42;
   *    * Sets the focus on the initial &lt;code&gt;FormInput&lt;/code&gt; control in this form.
   *    * @ojmetadata description 'Sets the focus on this form.'
   *    *&#47;
   *   focusInitialInput: () => void;
   * };
   *
   * export const FormFunctionalComponent =
   *   registerCustomElement&lt;Props, FormHandle&gt;(
   *     'my-form-functional-component',
   *     forwardRef(
   *       ({ labelEdge = 'inside', readonly = false }: Props, ref: Ref&lt;FormHandle&gt;) => {
   *         const formInputRef = useRef&lt;HTMLInputElement&gt;(null);
   *
   *         useImperativeHandle(ref, () => ({
   *           focusInitialInput: () => formInputRef.current?.focus()
   *         }));
   *
   *         return (
   *           &lt;input
   *             ref={formInputRef}
   *             readOnly={readonly}
   *             ...
   *           /&gt;
   *           ...
   *         );
   *       }
   *     ),
   *     {
   *       bindings: {
   *         // Indicate that the component's 'labelEdge' property will consume
   *         // the 'containerLabelEdge' variable provided by its parent, as well as
   *         // provide the 'labelEdge' property value under different keys and with
   *         // different transforms as required for different consumers.
   *         labelEdge: {
   *           consume: { name: 'containerLabelEdge' },
   *           provide: [
   *             { name: 'containerLabelEdge', default: 'inside' },
   *             { name: 'labelEdge', default: 'inside', transform: { top: 'provided', start: 'provided' } }
   *           ]
   *         },
   *         // Indicate that the component's 'readonly' property will consume
   *         // the 'containerReadonly' variable provided by its parent, as well as
   *         // provide the 'readonly' property value under different keys for different
   *         // consumers.
   *         readonly: {
   *           consume: { name: 'containerReadonly' },
   *           provide: [
   *             { name: 'containerReadonly' },
   *             { name: 'readonly' }
   *           ]
   *         }
   *       }
   *     }
   *   );
   * </code>
   * </pre>
   * @ojtypedef ojvcomponent.Options
   * @ojsignature {target:"Type", value:"<P, M extends Record<string, (...args) => any> = {}>", for:"genericTypeParameters"}
   */
  /**
   * @expose
   * @name bindings
   * @ojtypedefmember
   * @memberof! ojvcomponent.Options
   * @type {object=}
   * @ojsignature {target:"Type", value:"PropertyBindings<P>", jsdocOverride: true}
   */
  /**
   * @expose
   * @name contexts
   * @ojtypedefmember
   * @memberof! ojvcomponent.Options
   * @type {object=}
   * @ojsignature {target:"Type", value:"Contexts", jsdocOverride: true}
   */
  /**
   * @expose
   * @name methods
   * @ojtypedefmember
   * @memberof! ojvcomponent.Options
   * @type {object=}
   * @ojsignature {target:"Type", value:"Methods<M>", jsdocOverride: true}
   * @ojdeprecated {since: "16.0.0", description: "Use doclet metadata within the type alias that maps method names to function signatures instead."}
   */

  /**
   * <p>
   *   The TemplateSlot type identifies properties as representing named
   *   template slot children.  Unlike the <a href="#Slot">Slot</a> type,
   *   TemplateSlot is a functional type that takes some context and returns
   *   the slot children.
   * </p>
   * <p>
   *   See the <a href="#template-slots">Template Slots</a> section for more details.
   * </p>
   * @typedef {Function} TemplateSlot
   * @ojexports
   * @memberof ojvcomponent
   * @ojsignature [{target:"Type", value:"<Data extends object>", for:"genericTypeParameters"},
   *               {target: "Type", value: "(data: Data) => Slot"}]
   */

  // STATIC METHODS

  /**
   * <p>
   *   For the most part, VComponents should not need to render ids on child
   *   content.  However, in some cases this may be necessary.  For example,
   *   in order to set up a relationship between a label and the element that
   *   the label references, the label and labeled content must rendezvous on
   *   a common id.  Specifying fixed ids is problematic as this can
   *   lead to conflicts with other ids on the page.  The getUniqueId()
   *   method helps solve this problem by creating producing an id that is
   *   guaranteed not to conflict with ids rendered by other components.
   * </p>
   * <p>
   *   The id returned by getUniqueId() is typically used to provide a prefix
   *   (or suffix) for what would otherwise be a static id for some element
   *   rendered by the VComponent.
   * </p>
   * <p>
   *   The usage model is:
   * </p>
   * <ol>
   *   <li>
   *   In the VComponent's constructor, check to see whether the
   *   VComponent already has a props.id value.  If so, this can be used as a
   *   prefix for other ids and calling getUniqueId() is unnecessary.
   *   </li>
   *   <li>
   *   Otherwise, call getUniqueId() to retrieve the unique prefix for
   *   this component
   *   </li>
   *   <li>
   *   Store the result of the #1/#2 in an instance variable for later
   *   use.
   *   </li>
   *   <li>
   *   When rendering, use the previously stored prefix to generate
   *   unique ids for any elements that need them.
   *   </li>
   *   <li>
   *   Don't forget to include "id" in the list of
   *   <a href="#ObservedGlobalProps">ObservedGlobalProps</a> in
   *   order to ensure that the VComponent receives the value of this global
   *   HTML attribute.
   *   </li>
   * </ol>
   * <p>
   *   Putting this all together, we end up with a component like this:
   * </p>
   * <pre class="prettyprint"><code>import { Component, ComponentChild } from 'preact';
   * import { customElement, ExtendGlobalProps, ObservedGlobalProps, getUniqueId } from 'ojs/ojvcomponent';
   * import "ojs/ojinputtext";
   * import "ojs/ojlabel";
   *
   * export type Props = ObservedGlobalProps&lt;'id'&gt;;
   *
   * &#64;customElement('oj-demo-unique-id')
   * export class DemoUniqueId extends Component&lt;ExtendGlobalProps&lt;Props&gt;&gt; {
   *
   *   private uniquePrefix: string;
   *
   *   constructor(props: Readonly&lt;Props&gt;) {
   *     super(props)
   *
   *     this.uniquePrefix = props.id ?? getUniqueId();
   *   }
   *
   *   render(): ComponentChild {
   *
   *     const inputTextId = `${this.uniquePrefix}_input`;
   *
   *     return (
   *       &lt;div&gt;
   *         &lt;oj-label for={ inputTextId }&gt;Label&lt;/oj-label&gt;
   *         &lt;oj-input-text id={ inputTextId } value="Value"/&gt;
   *       &lt;/div&gt;
   *     );
   *   }
   * }
   * </code></pre>
   *
   * @function getUniqueId
   * @return {string}
   *
   * @memberof ojvcomponent
   * @expose
   * @ojexports
   */

  /**
   * <p>
   *   Class-based VComponents use the <a href="#customElement">&#64;customElement</a> decorator
   *   to specify the VComponent's custom element tag name (also known as its full name) and to register
   *   the custom element with the JET framework.  However, function-based VComponents cannot utilize this
   *   approach because decorators are only supported for classes and their constituent fields.
   * </p>
   * <p>
   *   JET provides an alternate mechanism for registering a function-based VComponent and specifying its
   *   custom element tag name. The registerCustomElement method accepts three arguments:  the custom element
   *   tag name to be associated with the VComponent, a reference to the Preact functional component that
   *   supplies the VComponent implementation, and a reference to additional options that can be specified
   *   when registering the function-based VComponent (see <a href="#Options">Options</a>
   *   for futher details).  It returns a higher-order VComponent that is registered with the
   *   framework using the specified custom element tag name.
   * </p>
   * <p>
   *   Here is a simple example:
   * </p>
   * <pre class="prettyprint"><code>
   * import { registerCustomElement } from 'ojs/ojvcomponent';
   *
   * export type Props = Readonly<{
   *   message?: string;
   * }>;
   *
   * export const DemoFunctionBasedVComp = registerCustomElement(
   *   'oj-demo-based-vcomp',
   *   ({ message='This is a function-based VComponent!' }: Props) => {
   *     return &lt;div&gt;{message}&lt;/div&gt;;
   *   }
   * );
   * </code></pre>
   * <p>
   *   There are some other considerations to keep in mind when implementing function-based VComponents:
   *   <ul>
   *    <li>Function-based VComponents can use an anonymous function to implement their Preact
   *        functional component, and expose the returned higher-order VComponent as their public API.</li>
   *    <li>The registration call ensures that the returned higher-order VComponent extends the Preact functional
   *        component's custom properties with the required global HTML attributes defined by <a href="#GlobalProps">GlobalProps</a>.</li>
   *    <li>Default custom property values are specified using destructuring assignment syntax in the function implementation.</li>
   *    <li>TypeScript can typically infer the type parameters to the <code>registerCustomElement</code> call without having
   *        to explicitly specify them in your code. However, if the function-based VComponent exposes public methods then
   *        the second <code>M</code> type parameter (which maps public method names to their function signatures)
   *        <i>must</i> be provided. In addition:
   *
   *        <ol>
   *          <li>the Preact functional component that implements VComponent must be wrapped inline with a
   *            <a href="https://preactjs.com/guide/v10/switching-to-preact/#forwardref">forwardRef</a> call, and</li>
   *          <li>the <code>useImperativeHandle</code> hook must be used within the Preact implementation.</li>
   *        </ol>
   *
   *        See the <a href="#Options">Options</a> type for a detailed example.</li>
   *  </ul>
   * </p>
   *
   * @function registerCustomElement
   * @param {string} tagName The custom element tag name for the registered function-based VComponent.
   * @param {function} functionalComponent The Preact functional component that supplies the VComponent implementation.
   * @param {Options<P, M>=} options Additional options for the function-based VComponent.
   * @returns {VComponent} Higher-order VComponent that wraps the Preact functional component.
   * @ojsignature [{target:"Type", value:"<P, M extends Record<string, (...args) => any> = {}>", for:"genericTypeParameters"}]
   *
   * @memberof ojvcomponent
   * @expose
   * @ojexports
   */

  /**
   * <p>
   *   Root is a Preact component that can be used to wrap the
   *   VComponent's child content.  This component should only be used
   *   for cases where the VComponent needs to control how
   *   <a href="#observed">observed global properties</a> are rendered on
   *   the component's root custom element.  In all other cases the
   *   non-wrapped child content should be returned directly.
   * </p>
   * <p>
   *   See the <a href="#root-element">Root Element</a> section for more details.
   * </p>
   *
   * @function Root
   *
   * @memberof ojvcomponent
   * @expose
   * @ojexports
   */

  class ValueBasedElement {
      constructor() {
          this.appendChildHelper = (element, newNode) => HTMLElement.prototype.appendChild.call(element, newNode);
          this.insertBeforeHelper = (element, newNode, refNode) => HTMLElement.prototype.insertBefore.call(element, newNode, refNode);
      }
      connectedCallback() { }
      disconnectedCallback() { }
      attributeChangedCallback(name, oldValue, newValue) { }
      getProperty(name) {
          return undefined;
      }
      setProperty(name, value) { }
      setProperties(properties) { }
  }
  const valueBasedElement = new ValueBasedElement();

  class HTMLJetElement extends HTMLElement {
      static get observedAttributes() {
          let observed = [];
          if (this.metadata.properties) {
              observed = observed.concat(MetadataUtils.getFlattenedAttributes(this.metadata.properties));
          }
          if (this.rootObservedAttributes) {
              observed = observed.concat(this.rootObservedAttributes);
          }
          return observed;
      }
      connectedCallback() {
          this._getHelper().connectedCallback();
      }
      disconnectedCallback() {
          this._helper?.disconnectedCallback();
      }
      attributeChangedCallback(name, oldValue, newValue) {
          // The _getHelper call will instantiate either a class that either no-ops for DOM calls
          // or suppors the custom element first case. We decide which class to instantiate by checking
          // the DOM for an attribute flag which if we call it at the first attributeChangedCallback call,
          // may not yet be in the DOM since this callback is called for all element attributes when it's first
          // instantiated. To prevent instantiating the wrong helper class and since we don't need to handle
          // the initial DOM attribute sets, we check if helper is already instantiated first by either the connected
          // or setProperty calls.
          this._helper?.attributeChangedCallback(name, oldValue, newValue);
      }
      getProperty(name) {
          return this._getHelper().getProperty(name);
      }
      setProperty(name, value) {
          this._getHelper().setProperty(name, value);
      }
      setProperties(properties) {
          this._getHelper().setProperties(properties);
      }
      appendChild(newNode) {
          return this._getHelper().appendChildHelper(this, newNode);
      }
      insertBefore(newNode, refNode) {
          return this._getHelper().insertBeforeHelper(this, newNode, refNode);
      }
      // Override set/removeAttribute to only allow toggling of classes applied by application/parent component
      // This is necessary to work with Preact's class patching logic
      setAttribute(qualifiedName, value) {
          if (qualifiedName === 'class') {
              const outerClasses = ojcustomelementUtils.CustomElementUtils.getClassSet(value);
              ojcustomelementUtils.CustomElementUtils.getElementState(this).setOuterClasses(outerClasses);
          }
          else {
              HTMLElement.prototype.setAttribute.call(this, qualifiedName, value);
          }
      }
      removeAttribute(qualifiedName) {
          if (qualifiedName === 'class') {
              this.setAttribute('class', '');
          }
          else {
              HTMLElement.prototype.removeAttribute.call(this, qualifiedName);
          }
      }
      _getHelper() {
          // Decide which helper to instantiate after the first connected
          // callback
          if (!this._helper) {
              if (this.hasAttribute('data-oj-jsx')) {
                  this.removeAttribute('data-oj-jsx');
                  // We won't go through the complete component cycle so just add oj-complete here
                  this.classList.add('oj-complete');
                  this._helper = valueBasedElement;
              }
              else {
                  this._helper = new IntrinsicElement(this, this.constructor['component'], this.constructor['metadata'], this.constructor['rootObservedAttributes'], this.constructor['rootObservedProperties'], this.constructor['defaultProps']);
              }
          }
          return this._helper;
      }
  }
  const getDescriptiveTransferAttributeValue = (element, attrName) => {
      const elementVal = element.getAttribute(attrName);
      if (elementVal) {
          return elementVal;
      }
      // cast as any to access private _getHelper metod
      const helper = element._getHelper();
      const vprops = helper.getProps?.() || {};
      return vprops[attrName];
  };
  const isInitialized = (element) => {
      // cast as any to access private _getHelper metod
      const helper = element._getHelper();
      return !!helper.isInitialized?.();
  };

  const RootContext = preact.createContext(null);
  function isGlobalProperty(prop, metadata) {
      return (prop === 'className' ||
          ojcustomelementUtils.AttributeUtils.isGlobalOrData(prop) ||
          isGlobalEventListenerProperty(prop, metadata));
  }
  // Although an expression with negative lookbehind like /^on([A-Za-z])([A-Za-z]*)(?<!Changed)$/
  // would be cleaner, we have to use negative lookahead because negative lookbehind is
  // not yet supported by Safari
  const _GLOBAL_EVENT_MATCH_EXP = /^on(?!.*Changed$)([A-Za-z])([A-Za-z]*)$/;
  function isGlobalEventListenerProperty(prop, metadata) {
      // A VComponent could have a non-event listener component property that
      // matches our regular expression below (eg. "once" or "only"). To avoid
      // treating these like global event listeners, we first check to see whether the
      // prop corresponds to a component property.
      if (metadata?.properties?.[prop]) {
          return false;
      }
      // Any property name starting with "on" followed by at least one character
      // and not ending with 'Changed' will be considered a global event property
      // unless the event type matches component's action callback property
      const match = prop.match(_GLOBAL_EVENT_MATCH_EXP);
      if (match) {
          const eventType = match[1].toLowerCase() + match[2];
          return !metadata?.events?.[eventType];
      }
      return false;
  }

  /*
   * This component is used when the VComponent is not taking any responsibility for managing the Root element
   */
  const InternalRoot = ({ children }) => {
      const { tagName, metadata, isElementFirst, vcompProps, elemRefObj } = hooks.useContext(RootContext);
      if (isElementFirst) {
          // When the component chooses not to render the root node in custom-element-first scenario,
          // we will be rendering implementation VDOM into the custom element 'as is'. No reconciliation
          // of custom element propewrties will occur.
          return children;
      }
      // For VComponent first, the framework is responsible for making sure global
      // attributes are rendered on the root vnode
      const refFunc = function (ref) {
          // Create a ref callback so that we can store the properties object onto
          // the element. Needed for WebElement property retrieval
          if (ref) {
              ref[ojcustomelementUtils.CustomElementUtils.VCOMP_INSTANCE] = {
                  props: vcompProps
              };
          }
          elemRefObj.current = ref; // Used by BusyContextProvider
      };
      // We don't have a reference to the element so we need to render something onto the DOM
      // to let the custom element logic know not to instantiate the vcomponent and to act as a
      // shell where most APIs are no-ops
      const globalPropKeys = Object.keys(vcompProps).filter((prop) => isGlobalProperty(prop, metadata));
      const globalProps = globalPropKeys.reduce((acc, cur) => {
          acc[cur] = vcompProps[cur];
          return acc;
      }, {});
      // We want to prevent creation of unnecessary EnvironmentWrapper component around element
      // represented by the tagName. In order to do so let's render into a 'div' and change the type
      // after that.
      const elem = (jsxRuntime.jsx("div", { ref: refFunc, "data-oj-jsx": "", ...globalProps, children: children }));
      elem.type = tagName;
      return elem;
  };

  const _CLASS = 'class';
  const Root = compat.forwardRef((props, ref) => {
      const { tagName, metadata, isElementFirst, vcompProps, observedPropsSet, elemRefObj } = hooks.useContext(RootContext);
      if (isElementFirst) {
          // Invoke root VNode's patch implementation passed by the IntrinsicElement
          // This will ensure that root element refs are set before the componentDidMount() callback
          // is invoked
          const artificialRoot = jsxRuntime.jsx("div", { ...props, ref: ref });
          artificialRoot.type = tagName;
          vcompProps[ROOT_VNODE_PATCH](artificialRoot);
          return jsxRuntime.jsx(preact.Fragment, { children: props.children });
      }
      const propFixups = {};
      // Merge style values with those in the DOM.
      if (vcompProps.style && props['style']) {
          propFixups['style'] = Object.assign({}, vcompProps.style, props['style']);
      }
      const componentClass = vcompProps[_CLASS];
      if (componentClass) {
          const nodeClass = props[_CLASS] || '';
          propFixups[_CLASS] = `${componentClass} ${nodeClass}`;
      }
      // Merge back global attributes not overidden by component
      // to root vnode since the component won't render these, but
      // they are set by parent and should show up in the DOM.
      const parentGlobalKeys = Object.keys(vcompProps).filter((prop) => !(prop in props) && !observedPropsSet.has(prop) && isGlobalProperty(prop, metadata));
      const parentGlobals = parentGlobalKeys.reduce((acc, cur) => {
          acc[cur] = vcompProps[cur];
          return acc;
      }, {});
      // Create a ref callback so that we can store the properties object onto
      // the element. Needed for WebElement property retrieval.
      const refFunc = (el) => {
          let cleanupFunc;
          if (ref) {
              cleanupFunc = applyRef(ref, el);
          }
          if (el) {
              el[ojcustomelementUtils.CustomElementUtils.VCOMP_INSTANCE] = {
                  props: vcompProps
              };
          }
          elemRefObj.current = el; // Used by BusyContextProvider
          return cleanupFunc;
      };
      const elem = jsxRuntime.jsx("div", { ...props, ...propFixups, ...parentGlobals, ref: refFunc, "data-oj-jsx": "" });
      elem.type = tagName;
      return elem;
  });

  /**
   * @ignore
   */
  class VComponentState extends ojcustomelementUtils.LifecycleElementState {
      constructor(element) {
          super(element);
          this._translationBundleMap = {};
      }
      /**
       * Gets translation bundle map
       */
      getTranslationBundleMap() {
          return this._translationBundleMap;
      }
      /**
       * @override
       */
      getTemplateEngine() {
          return VComponentState._cachedTemplateEngine;
      }
      /**
       * @override
       */
      getTrackChildrenOption() {
          return 'immediate';
      }
      /**
       * @override
       */
      allowPropertyChangedEvents() {
          return super.allowPropertyChangedEvents() && isInitialized(this.Element);
      }
      /**
       * @override
       */
      allowPropertySets() {
          return this._allowPropertySets || super.allowPropertySets();
      }
      /**
       * @override
       */
      resetCreationCycle() {
          this._allowPropertySets = super.allowPropertySets();
          super.resetCreationCycle();
      }
      /**
       * Dispose cached entries that might be stored on a template slot
       */
      disposeTemplateCache() {
          const slotMap = this.getSlotMap();
          const slots = Object.keys(slotMap);
          const metadata = ojcustomelementRegistry.getElementDescriptor(this.Element.tagName).metadata;
          // dynamicSlot is an object of form { prop: [propName], isTemplate: [1 for true and 0 for false]}
          const dynamicSlotMetadata = metadata?.extension?._DYNAMIC_SLOT;
          const hasDynamicTemplateSlots = !!dynamicSlotMetadata?.isTemplate;
          const templateSlots = slots.filter((slot) => {
              const slotMetadata = MetadataUtils.getPropertyMetadata(slot, metadata?.slots);
              if (slotMetadata) {
                  if (slotMetadata.data) {
                      // static template slot
                      return true;
                  }
              }
              else {
                  if (hasDynamicTemplateSlots) {
                      // dynamic template slot
                      return true;
                  }
              }
              return false;
          });
          templateSlots.forEach((slot) => {
              const slotNodes = slotMap[slot];
              if (slotNodes[0]?.nodeName === 'TEMPLATE') {
                  this.getTemplateEngine().cleanupTemplateCache(slotNodes[0]);
              }
          });
      }
      /**
       * @override
       */
      GetPreCreatedPromise() {
          let translationPromise;
          let templateEnginePromise;
          // If the element requests translation bundles, lets load them using best fitted locale.
          // Delay component creation until bundles are loaded.
          if (this.Element.constructor.translationBundleMap) {
              translationPromise = this._getTranslationBundlesPromise();
          }
          // If the template engine has not yet been loaded, and we have have some template elements as direct children,
          // chain the base class's pre-create promise with the promise for the template engine becoming
          // loaded and cached
          // eslint-disable-next-line no-use-before-define
          if (!VComponentState._cachedTemplateEngine && this._hasDirectTemplateChildren()) {
              templateEnginePromise = this._getTemplateEnginePromise();
          }
          // The isConnected check is made because the translationPromise and templateEnginePromise might
          // take longer than a microtask to resolve and the element might disconnect while waiting for the promises.
          // This makes the binding provider promise a) irrelevant and b) likely to blow up if we proceeded.
          return Promise.all([translationPromise, templateEnginePromise]).then(() => {
              return this.Element.isConnected ? super.GetPreCreatedPromise() : Promise.reject();
          });
      }
      /**
       * @override
       */
      IsTransferAttribute(attrName) {
          return this.Element.constructor.rootObservedAttrSet.has(attrName);
      }
      /**
       * @override
       */
      GetDescriptiveTransferAttributeValue(attrName) {
          return getDescriptiveTransferAttributeValue(this.Element, attrName);
      }
      _getTranslationBundlesPromise() {
          const translationBundleMap = this.Element.constructor.translationBundleMap;
          const bundleKeys = Object.keys(translationBundleMap);
          const translationBundlePromises = [];
          bundleKeys.forEach((key) => {
              translationBundlePromises.push(ojtranslationbundleutils.getTranslationBundlePromise(key));
          });
          return Promise.all(translationBundlePromises).then((resolvedBundlesArray) => {
              bundleKeys.forEach((key, index) => {
                  this._translationBundleMap[key] = resolvedBundlesArray[index];
              });
          });
      }
      /**
       * Returns a Promise for when the template engine is loaded.
       * Once loaded, the template engine is cached in a class variable.
       */
      _getTemplateEnginePromise() {
          return new Promise(function (resolve, reject) { require(['ojs/ojvcomponent-template'], function (m) { resolve(_interopNamespace(m)); }, reject) }).then((eng) => {
              VComponentState._cachedTemplateEngine = eng;
          });
      }
      /**
       * Helper to determine whether the custom element has
       * template children.
       */
      _hasDirectTemplateChildren() {
          const childNodeList = this.Element.childNodes;
          for (let i = 0; i < childNodeList.length; i++) {
              const child = childNodeList[i];
              if (child.localName === 'template') {
                  return true;
              }
          }
          return false;
      }
  }

  function BusyContextProvider({ elemRefObj, children }) {
      const addBusyState = hooks.useCallback((description) => {
          // If the component is not mounted, return a noop
          if (elemRefObj.current) {
              const baseDescription = `${elemRefObj.current.tagName.toLowerCase()}: `;
              const busyContext = Context.getContext(elemRefObj.current).getBusyContext();
              return busyContext.addBusyState({ description: `${baseDescription}${description}` });
          }
          throw new Error(`Cannot call addBusyState() when the component is not connected to the DOM. Ensure the component is mounted before attempting to add a busy state.`);
      }, [elemRefObj]);
      const busyContext = hooks.useMemo(() => ({ addBusyState }), [addBusyState]);
      return jsxRuntime.jsx(UNSAFE_useBusyStateContext.BusyStateContext.Provider, { value: busyContext, children: children });
  }

  const FUNCTIONAL_COMPONENT = Symbol('functional component');
  const ELEMENT_REF_OBJ = Symbol(); // Symbol for passing element RefObject to support BusyContextProvider
  function customElement(tagName) {
      return function (constructor) {
          const metadata = constructor['_metadata'] || constructor['metadata'] || {};
          extendMetadata(metadata);
          const observedProps = metadata?.extension?.['_OBSERVED_GLOBAL_PROPS'] || [];
          const observedAttrs = observedProps.map((prop) => ojcustomelementUtils.AttributeUtils.getGlobalAttrForProp(prop));
          overrideRender(tagName, constructor, metadata, new Set(observedProps));
          registerElement(tagName, metadata, constructor, observedProps, observedAttrs, constructor['_translationBundleMap'] || constructor['translationBundleMap']);
          if (!constructor['_metadata'] && constructor['metadata']) {
              Logger.warn(`Component ${tagName} is compiled with JET version prior to 14.0.0`);
          }
      };
  }
  /**
   * Register a functional component for the custom element
   * @param {string} tagName The element tag name to register
   * @param {function} fcomp The functional component
   * @param {object?} options Additional options for the functional VComponent
   * @returns A Component class which encapsulates the renderer
   */
  function registerCustomElement(tagName, fcomp, options) {
      class VCompWrapper extends preact.Component {
          constructor() {
              super();
              this.__refCallback = (instance) => {
                  if (this.__vcompRef) {
                      this.__vcompRef.current = instance;
                  }
                  const innerRef = this.props['innerRef'];
                  return applyRef(innerRef, instance);
              };
              if (VCompWrapper._metadata?.['methods']) {
                  this.__vcompRef = preact.createRef();
                  // NOTE:  RT methods metadata will not include standard methods for
                  //        getting/setting properties - those only get included in the DT metadata
                  const rtMethodMD = VCompWrapper._metadata['methods'];
                  const extendableInstance = this;
                  // Set up pass-through methods
                  for (let mName in rtMethodMD) {
                      extendableInstance[mName] = (...args) => this.__vcompRef.current?.[mName].apply(this.__vcompRef.current, args);
                  }
              }
          }
          render() {
              arguments[0]['ref'] = this.__refCallback;
              return fcomp(arguments[0]);
          }
      }
      // NOTE:  If the optional 'options' argument was supplied, custom-tsc
      //        already processed and incorporated the PropertyBinding and/or
      //        Methods metadata into the undocumented 'metadata' argument, so the
      //        optional argument was removed from the arguments array!
      //
      //        If, at some later point, we decide that we DO need to pass along
      //        the 'options' argument to the VComponent framework during
      //        registration, then we will need to make adjustments both here
      //        and in custom-tsc.
      // 'displayName' is passed by custom-tsc as a 3rd argument. Use it to
      // set a default value for the returned class's displayName property.
      VCompWrapper.displayName = arguments[2];
      // 'metadata' is passed by custom-tsc as an optional 4th argument. Assign the
      // runtime metadata to the class so that customElement can find it.
      if (arguments.length >= 4 && arguments[3]) {
          VCompWrapper._metadata = arguments[3];
          // 'defaultProps' is passed by custom-tsc as an optional 5th argument.
          if (arguments.length >= 5 && arguments[4]) {
              VCompWrapper._defaultProps = arguments[4];
          }
      }
      // A 'translationBundleMap' (object mapping bundleIDs to loader functions)
      // is passed by custom-tsc as an optional 6th argument. Assign the object map
      // to the class so that customElement can find it.
      if (arguments.length >= 6) {
          VCompWrapper._translationBundleMap = arguments[5];
      }
      // A Contexts map (of type Options<P,M>['contexts']) is passed by custom-tsc
      // as an optional 7th argument. Assign the consumed Contexts to the class
      // so that customElement can find it.
      if (arguments.length >= 7) {
          VCompWrapper['_consumedContexts'] = arguments[6]['consume'];
      }
      // Mark this class so that we can identify functional vcomponents
      VCompWrapper[FUNCTIONAL_COMPONENT] = true;
      customElement(tagName)(VCompWrapper);
      return compat.forwardRef((props, ref) => jsxRuntime.jsx(VCompWrapper, { ...props, innerRef: ref }));
  }
  function extendMetadata(metadata) {
      if (!metadata.properties) {
          metadata.properties = {};
      }
      // Add __oj_private_color_scheme and __oj_private_scale properties
      // to support binding propagation of colorScheme/scale values
      // in VComponents used in HTML. The values will be passed to the
      // EnvironmentProvider.
      metadata.properties.__oj_private_color_scheme = {
          type: 'string',
          binding: { consume: { name: 'colorScheme' } }
      };
      metadata.properties.__oj_private_scale = {
          type: 'string',
          binding: { consume: { name: 'scale' } }
      };
      // Add __oj_private_contexts property to support
      // propagation of Context objects to VComponents.
      // Without this, there won't be a setter and Preact
      // will call setAttribute, which isn't what we want.
      //
      // EnvironmentContext will only be passed here within JSX trees.
      // Other Contexts may be propagated both within JSX + HTML trees.
      metadata.properties.__oj_private_contexts = {
          type: 'object'
      };
      // The member is used to pass provided context from VComponentTemplate
      // to EnvironmentWrapper component.
      metadata.properties.__oj_provided_contexts = {
          type: 'object'
      };
      // Add __oj_private_identifier_to_* properties to ensure correct behavior
      // during VComponentTemplate compilation. These properties help preserve
      // non-primitive property values on the JET components that remain essentially
      // unchanged when templates are updated.
      metadata.properties.__oj_private_identifier_to_prop = {
          type: 'object',
          writeback: true // set writeback key to true to force deep compare in comparePropertyValues().
      };
      metadata.properties.__oj_private_identifier_to_value = {
          type: 'object',
          writeback: true // set writeback key to true to force deep compare in comparePropertyValues().
      };
  }
  function registerElement(tagName, metadata, constructor, observedProps, observedAttrs, translationBundleMap) {
      if (translationBundleMap) {
          ojtranslationbundleutils.registerTranslationBundleLoaders(translationBundleMap);
      }
      class HTMLPreactElement extends HTMLJetElement {
      }
      HTMLPreactElement.metadata = metadata;
      HTMLPreactElement.component = constructor;
      HTMLPreactElement.rootObservedAttributes = observedAttrs;
      HTMLPreactElement.rootObservedAttrSet = new Set(observedAttrs);
      HTMLPreactElement.rootObservedProperties = observedProps;
      HTMLPreactElement.defaultProps = constructor['defaultProps'] || constructor['_defaultProps']
          ? MetadataUtils.deepFreeze(constructor['defaultProps'] || constructor['_defaultProps'])
          : null;
      HTMLPreactElement.translationBundleMap = translationBundleMap;
      // Define getters/setters for metadata properties
      addPropGetterSetters(HTMLPreactElement.prototype, metadata?.properties);
      addMethods(HTMLPreactElement.prototype, metadata?.methods);
      ojcustomelementRegistry.registerElement(tagName, {
          descriptor: { metadata },
          stateClass: VComponentState,
          vcomp: true,
          cache: { contexts: constructor['_consumedContexts'] }
      }, HTMLPreactElement);
  }
  const InternalComp = ({ instance, tagName, metadata, baseRender, props, state, context }) => {
      let vdom = baseRender.call(instance, props, state, context);
      // The various cases to handle:
      // 1) The VComponent directly returns the Root component
      // 2) The VComponent directly returns the custom element tag (not recommended, but still supported)
      //    This case will be converted to case 1
      // 3) The VComponent returns only the children of the custom element (note that they may or may not be wrapped in a forwardRef)
      //    This case should be wrapped in the InternalRoot component
      // 4) The VComponent is a functional component that is exposing methods
      //    a) *must* be wrapped in (at least) a top-level forwardRef
      //    b) *must* ultimately return the Root component
      // Fixing infinite recursion for case 2.
      // The root element will be wrapped into EnvironmentWrapper component. We should discard
      // the wrapper component in this case.
      //
      // Also convert into case 1 -- i.e. <custom-element/> -> <Root/>
      if (vdom?.type?.['__ojIsEnvironmentWrapper'] && vdom.props.children.type === tagName) {
          // props.children for EnvironmentWrapper contains a single element
          const customElementNode = vdom.props.children;
          // the simple thing here would be to clone and change the type of the clone to Root.
          // however, cloning the custom element directly will trigger an infinite loop of unwrapping/wrapping
          // instead, we'll mutate the original to Root, clone, and then restore the original.
          customElementNode.type = Root;
          try {
              vdom = preact.cloneElement(customElementNode);
          }
          finally {
              customElementNode.type = tagName;
          }
      }
      const vdomType = vdom?.type;
      if (vdomType !== Root) {
          if (!isForwardRef(vdomType) ||
              !vdomType[FUNCTIONAL_COMPONENT] ||
              Object.keys(metadata.methods || {}).length === 0) {
              // Case 3
              vdom = jsxRuntime.jsx(InternalRoot, { children: vdom });
          }
      }
      return vdom;
  };
  function overrideRender(tagName, constructor, metadata, observedPropsSet) {
      // Save the original component render method
      const componentRender = constructor.prototype.render;
      // Override the component render to know how to handle the dual mounting case
      constructor.prototype.render = function (props, state, context) {
          // We need to remove readOnly properties so they're not available to VComponents in this.props.
          // We don't want components relying on readOnly props because props come from the parent and parent components
          // will not be updating readOnly properties
          const readOnlyProps = metadata?.extension?.['_READ_ONLY_PROPS'];
          if (readOnlyProps) {
              readOnlyProps.forEach((prop) => delete props[prop]);
          }
          // If a flag isn't passed through the props indicating that the custom
          // element initiated the render, we will add a marker attribute indicating that
          // the component has already been rendered so the custom element won't try and
          // instantiate the component again on connected
          const element = props[ELEMENT_REF];
          const isElementFirst = !!element;
          if (isElementFirst) {
              ojcustomelementUtils.CustomElementUtils.getElementState(element).disposeTemplateCache();
          }
          // Fix for Preact 10.21.0 (https://github.com/preactjs/preact/pull/4337).
          // Prior to the optimization Symbols were filtered from vnode props, but after
          // the optiomization JET added Symbols can sip into child properties. We want to avoid this and
          // filter the Symbols out from property object before rendering.
          let componentProps = props;
          if (props[ELEMENT_REF]) {
              const { [ELEMENT_REF]: remove1, [ROOT_VNODE_PATCH]: remove2, ...keep } = props;
              componentProps = keep;
          }
          this[ELEMENT_REF_OBJ] = this[ELEMENT_REF_OBJ] || { current: props[ELEMENT_REF] };
          return (jsxRuntime.jsx(RootContext.Provider, { value: {
                  tagName,
                  metadata,
                  isElementFirst,
                  vcompProps: props,
                  observedPropsSet,
                  elemRefObj: this[ELEMENT_REF_OBJ]
              }, children: jsxRuntime.jsx(BusyContextProvider, { elemRefObj: this[ELEMENT_REF_OBJ], children: jsxRuntime.jsx(InternalComp, { instance: this, baseRender: componentRender, props: componentProps, state: state, context: context, tagName: tagName, metadata: metadata }) }) }));
      };
  }
  function addPropGetterSetters(proto, properties) {
      if (!properties)
          return;
      for (let name in properties) {
          Object.defineProperty(proto, name, {
              get() {
                  return this.getProperty(name);
              },
              set(value) {
                  this.setProperty(name, value);
              }
          });
          ojcustomelementUtils.addPrivatePropGetterSetters(proto, name);
      }
  }
  function addMethods(proto, methods) {
      if (!methods)
          return;
      for (let method in methods) {
          proto[method] = function () {
              if (this._helper === valueBasedElement) {
                  throw new ojcustomelementUtils.JetElementError(this, 'Cannot access element methods when rendered as a value based element.');
              }
              // The VComponent is asynchronously instantiated by CreateComponent so we
              // need to check that this has happened before we call any methods defined on it.
              // Custom elements are upgraded synchronously meaning the method will be available
              // on the HTMLElement, but we tell applications to wait on the component busy context
              // before accessing properties and methods due to the asynch CreateComponent call.
              const comp = this._helper.ref.current;
              if (!comp) {
                  throw new ojcustomelementUtils.JetElementError(this, 'Cannot access methods before element is upgraded.');
              }
              return comp[method].apply(comp, arguments);
          };
      }
  }
  // in preact/compat/src/forwardRef, the $$typeof expando is added for react compatibility.
  // we're relying on the fact that this is unobfuscated to identify the internal Forwarded
  // component that preact/compat creates
  function isForwardRef(type) {
      return get$$typeof(type) === getForwardRef$$typeof();
  }
  function get$$typeof(type) {
      return type?.['$$typeof'];
  }
  let forwardRefSymbol;
  function getForwardRef$$typeof() {
      if (!forwardRefSymbol) {
          forwardRefSymbol = get$$typeof(compat.forwardRef(() => null));
      }
      return forwardRefSymbol;
  }

  // The following are decorator stubs needed for component imports, but
  // that are removed at compile time and will not show up in the js code.
  function method(target, propertyKey, descriptor) { }
  function consumedContexts(contexts) {
      return function (constructor) { };
  }

  (function () {
      /**
       * Preact checks to see that a property is defined on an element before
       * calling the property setter so we will add the render property to the template
       * element prototype so we can set the render function on the template instance
       * when using the template engine in vdom logic.
       * @ignore
       */
      if (typeof window !== 'undefined') {
          if (!HTMLTemplateElement.prototype.hasOwnProperty('render')) {
              Object.defineProperty(HTMLTemplateElement.prototype, 'render', {
                  value: null,
                  writable: true
              });
          }
      }
  })();

  const ReportBusyContext = preact.createContext(null);

  const getUniqueId = ojcustomelementUtils.ElementUtils.getUniqueId.bind(null, null);

  exports.ReportBusyContext = ReportBusyContext;
  exports.Root = Root;
  exports.consumedContexts = consumedContexts;
  exports.customElement = customElement;
  exports.getUniqueId = getUniqueId;
  exports.method = method;
  exports.registerCustomElement = registerCustomElement;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojpopupcore',['exports', 'ojs/ojcore-base', 'jquery', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojdomutils', 'ojs/ojpreact-patch', 'jqueryui-amd/position', 'ojs/ojcontext', 'preact/jsx-runtime', 'preact', 'ojs/ojcustomelement-utils'], function (exports, oj, $, Components, Logger, DomUtils, ojpreactPatch, position, Context, jsxRuntime, preact, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   * Invokes the callback function with the touchstart event if the touch sequence
   * resulted in a "Tap".  The goal is to distinguish a touchstart that doesn't result
   * in scroll.
   * @extends {oj.Object}
   * @public
   * @constructor
   * @class SimpleTapRecognizer
   * @since 1.1.0
   * @param {function(!Event)} tapCallback function invoked when a Tap is detected
   * @ignore
   * @ojtsignore
   */
  const SimpleTapRecognizer = function (tapCallback) {
    this._tapCallback = tapCallback;
    this.Init();
  };
  oj._registerLegacyNamespaceProp('SimpleTapRecognizer', SimpleTapRecognizer);

  oj.Object.createSubclass(SimpleTapRecognizer, oj.Object, 'oj.SimpleTapRecognizer');

  /**
   * Sets up the touch listeners ready to fire the callback.
   * @override
   * @instance
   * @protected
   */
  SimpleTapRecognizer.prototype.Init = function () {
    SimpleTapRecognizer.superclass.Init.call(this);
    var eventHandlerCallback = this._eventHandler.bind(this);
    this._eventHandlerCallback = eventHandlerCallback;

    var docElement = document.documentElement;
    var eventType;
    for (var i = 0; i < SimpleTapRecognizer._TOUCHEVENTS.length; i++) {
      eventType = SimpleTapRecognizer._TOUCHEVENTS[i];
      if (eventType === 'touchstart' || eventType === 'touchmove') {
        docElement.addEventListener(eventType, eventHandlerCallback, {
          passive: false,
          capture: true
        });
      } else {
        docElement.addEventListener(eventType, eventHandlerCallback, true);
      }
    }
  };

  /**
   * Keeps reference to the last touchstart event.  If at touchend is encountered before a
   * touchmove or touchcancel, then fire the tap callback with the touchstart event.
   * @private
   * @param {Event} event native touch event
   */
  SimpleTapRecognizer.prototype._eventHandler = function (event) {
    var tapCallback = this._tapCallback;
    var eventType = event.type;
    if (eventType === 'touchstart') {
      this._touchStartEvent = event;
      this._touchStartEvent._tapStart = new Date().getTime();
    } else if (eventType === 'touchmove' || eventType === 'touchcancel') {
      this._touchStartEvent = null;
    } else if (eventType === 'touchend') {
      if (this._touchStartEvent) {
        var tapStart = this._touchStartEvent._tapStart;
        if (!isNaN(tapStart)) {
          var now = new Date().getTime();
          // if the period of ms between touchstart and touchend is less than the long touch
          // thresshold, invoke the callback
          if (now - tapStart < SimpleTapRecognizer._PRESSHOLDTHRESSHOLD) {
            tapCallback(this._touchStartEvent);
          }
        } else {
          tapCallback(this._touchStartEvent);
        }
      }

      this._touchStartEvent = null;
    }
  };

  /**
   * Unregisters touch listeners and deletes references to callbacks.
   * @public
   */
  SimpleTapRecognizer.prototype.destroy = function () {
    this._tapCallback = null;

    var eventHandlerCallback = this._eventHandlerCallback;
    this._eventHandlerCallback = null;

    var docElement = document.documentElement;
    var eventType;
    for (var i = 0; i < SimpleTapRecognizer._TOUCHEVENTS.length; i++) {
      eventType = SimpleTapRecognizer._TOUCHEVENTS[i];
      if (eventType === 'touchstart' || eventType === 'touchmove') {
        docElement.removeEventListener(eventType, eventHandlerCallback, {
          passive: false,
          capture: true
        });
      } else {
        docElement.removeEventListener(eventType, eventHandlerCallback, true);
      }
    }
  };

  /**
   * Touch events that we are interested in listening for.
   *
   * @const
   * @private
   * @type {Array.<string>}
   */
  SimpleTapRecognizer._TOUCHEVENTS = ['touchstart', 'touchmove', 'touchcancel', 'touchend'];

  /**
   * Period of milliseconds for determining a long tap.  The normal threshold is 750ms.
   * The auto dismissal listeners for capture events versus bubble by the rest of the
   * framework.  Make the window for determining a long tap shorter than normal
   *
   * @const
   * @private
   * @type {number}
   */
  SimpleTapRecognizer._PRESSHOLDTHRESSHOLD = 700;

  /* jslint browser: true*/

  /**
   * Internal framework service for managing popup instances.
   *
   * @extends {oj.Object}
   * @protected
   * @constructor
   * @since 1.1.0
   * @class oj.PopupService
   * @ignore
   * @ojtsignore
   */
  const PopupService = function () {
    this.Init();
  };
  oj._registerLegacyNamespaceProp('PopupService', PopupService);

  oj.Object.createSubclass(PopupService, oj.Object, 'oj.PopupService');

  // Classes defined here to avoid ESLint no-use-before-define requirement
  const PopupServiceImpl = function () {
    this.Init();
  };
  const ZOrderUtils = {};

  /**
   * @override
   * @instance
   * @protected
   */
  PopupService.prototype.Init = function () {
    PopupService.superclass.Init.call(this);
  };

  /**
   * @param {Object=} options used by the factory method for service instantiation
   * @return {!oj.PopupService} singleton instance of the manager
   * @public
   */
  // eslint-disable-next-line no-unused-vars
  PopupService.getInstance = function (options) {
    // in the future we might need a JET Island impl
    if (!PopupService._popupService) {
      PopupService._popupService = new PopupServiceImpl();
    }
    return PopupService._popupService;
  };

  /**
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for opening the popup
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars
  PopupService.prototype.open = function (options) {
    oj.Assert.failedInAbstractFunction();
  };

  /**
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars
  PopupService.prototype.close = function (options) {
    oj.Assert.failedInAbstractFunction();
  };

  /**
   * @param {!Object.<PopupService.OPTION, ?>} options property bag to change
   * the state of the target popup.
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars
  PopupService.prototype.changeOptions = function (options) {
    oj.Assert.failedInAbstractFunction();
  };

  /**
   * @param {!jQuery} popup to target triggering the event on decendents
   * @param {!PopupService.EVENT} event to trigger
   * @param {Array=} argsArray to pass to the associated callback for the event
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars
  PopupService.prototype.triggerOnDescendents = function (popup, event, argsArray) {
    oj.Assert.failedInAbstractFunction();
  };

  /**
   * @return {void}
   * @instance
   * @public
   */
  PopupService.prototype.destroy = function () {
    PopupService._popupService = null;
  };

  /**
   * Dialog modality states.
   * @enum {string}
   * @public
   * @ojtsignore
   */
  PopupService.MODALITY = {
    /** Type of popup that doesn't support modality */
    NONE: 'none',
    /** Dialog that that blocks user input of the primary window.*/
    MODAL: 'modal',
    /** Type of dialog that doesn't block user input of the primary window */
    MODELESS: 'modeless'
  };

  /**
   * Event names used to identify the {@link PopupService.OPTION.EVENT} option
   * property.
   * @enum {string}
   * @public
   * @ojtsignore
   */
  PopupService.EVENT = {
    /**
     * Event called by the popup service when the surrogate is removed in the document
     * resulting in the popup getting implicitly closed and associated bound element
     * is removed */
    POPUP_REMOVE: 'ojPopupRemove',
    /**
     * Event called when a parent popup is closed causing implicit closure of
     * descendent popups.
     */
    POPUP_CLOSE: 'ojPopupClose',
    /**
     * Event called on when a parent popup is refreshed triggering a cascade
     * refresh on children.
     */
    POPUP_REFRESH: 'ojPopupRefresh',
    /**
     * Event called to enforce auto dismissal rules specific to each popup category.
     */
    POPUP_AUTODISMISS: 'ojPopupAutoDismiss',
    /**
     * Event called before the popup is open but after it has been reparented into the
     * zorder container.  The callback should be used for implementing open animation.
     * The callback function should return a Promise if animation is reqired or void/undefined
     * if no animation is necessary. The callback is passed the open options
     * {!Object.<PopupService.OPTION, ?>} as the only argument.
     * @since 3.0.0
     */
    POPUP_BEFORE_OPEN: 'ojPopupBeforeOpen',
    /**
     * Event called after the popup is open. The callback should implement component
     * open finalization actions such as triggering an open event.  The resultant of
     * the callback function is void.  The callback is passed the
     * open options {!Object.<PopupService.OPTION, ?>} as the only argument.
     */
    POPUP_AFTER_OPEN: 'ojPopupAfterOpen',
    /**
     * Event called before the popup is close.  When invoked, the popup dom is still
     * located within the zorder container.  The callback is a good place to implement
     * close animation. The callback should return a Promise if animation is required
     * or void/undefined if no animation is required.  The callback is passed the
     * close options {!Object.<PopupService.OPTION, ?>} as the only argument.
     * @since 3.0.0
     */
    POPUP_BEFORE_CLOSE: 'ojPopupBeforeClose',
    /**
     * Event called after the popup is closed and reparented back into its original
     * location within the document.  The callback is for close finalization logic.
     * It's a good places to trigger a component close event. The resultant of the
     * callback is expected to be void. The callback is passed the
     * close options {!Object.<PopupService.OPTION, ?>} as the only argument.
     * @since 3.0.0
     */
    POPUP_AFTER_CLOSE: 'ojPopupAfterClose'
  };

  /**
   * Layer level used to identify the {@link PopupService.OPTION.LAYER_LEVEL} option
   * property.
   * @enum {string}
   * @public
   * @ojtsignore
   */
  PopupService.LAYER_LEVEL = {
    /**
     * Option used by dialogs.  Dialogs are always top rooted.
     */
    TOP_LEVEL: 'topLevel',
    /**
     * The default layer option.  Popups will be reparented to the nearest ancestor layer defined
     * relative to the associated {@link PopupService.OPTION.LAUNCHER}.
     */
    NEAREST_ANCESTOR: 'nearestAncestor'
  };

  /**
   * Property names in the options property bag passed to popup service api.
   * @enum {string}
   * @public
   * @see oj.PopupService#close
   * @see oj.PopupService#open
   * @ojtsignore
   */
  PopupService.OPTION = {
    /**
     * Parameter holding the jQuery element that is the root of the popup.  This
     * element is reparented into the zorder container when open. It is a required
     * option.
     */
    POPUP: 'popup',
    /**
     * Map of event names to callbacks.  The event names are defined by the
     * {@link PopupService.EVENT} enumerated type.
     */
    EVENTS: 'events',
    /**
     * Defines the modal state of a popup.  The value of this attribute is defined
     * by the {@link PopupService.MODALITY} enumeration.
     */
    MODALITY: 'modality',
    /**
     * The jQuery element that is associated with the popup being open.  The launcher
     * is used to find the target popups reparented location within the zorder
     * container when open.  This is an optional parameter.  Dialogs don't require a launcher.
     */
    LAUNCHER: 'launcher',
    /**
     * The jQuery UI position object that defines where the popup should be aligned.
     * This is an optional parameter.
     */
    POSITION: 'position',
    /**
     * The CSS selector names applied to the layer for the target type of popup.  These
     * selectors will define the stacking context for the popup and its children.  Multiple
     * selector names should be delimited by a space similar to the syntax for the jquery
     * addClass API.  This option is required.
     */
    LAYER_SELECTORS: 'layerSelectors',
    /**
     * The initial level that the popup will be reparented to when open.  Dialogs are reparented
     * into the top level.  Other types of popups will be parented to their nearest ancestor layer.
     * The values of this attribute are defined by {@link PopupService.LAYER_LEVEL}.
     */
    LAYER_LEVEL: 'layerLevel',
    /**
     * General purpose context that the "open" and "close" can add to the options and it will be
     * passed thru to the corresponding "before" and "after" operations. Use this context to pass
     * variables declared locally in the open to the associated before and after
     * callbacks.
     * @since 3.0.0
     */
    CONTEXT: 'context',

    /**
     * Indicates the component with the associated popup was instantiated as a custom element.
     * This switch determines how the associated surrogate will be created.
     * @since 4.0.0
     */
    CUSTOM_ELEMENT: 'customElement'
  };

  oj.__registerWidget('oj.ojSurrogate', $.oj.baseComponent, {
    version: '1.0.0',
    widgetEventPrefix: 'oj',
    options: {
      beforeDestroy: null
    },
    _ComponentCreate: function () {
      this._super();
      this.element.uniqueId();
    },
    _invokeBeforeDestroy: function () {
      var callback = this.options.beforeDestroy;
      this.options.beforeDestroy = null;
      if (callback) {
        callback();
      }
    },
    _destroy: function () {
      this._invokeBeforeDestroy();
      this.element.removeUniqueId();
      this._super();
    },
    _NotifyDetached: function () {
      this._invokeBeforeDestroy();
      this._super();
    },
    // This method is designed to be triggered by jquery cleanData override.
    $$cleanElement: function () {
      this._invokeBeforeDestroy();
    }
  });

  var ojSurrogateMeta = {
    properties: {
      beforeDestroy: {
        type: 'function'
      }
    },
    methods: {
      $$cleanElement: {}
    },
    extension: {
      _WIDGET_NAME: 'ojSurrogate'
    }
  };
  oj.CustomElementBridge.register('oj-surrogate', { metadata: ojSurrogateMeta });

  oj._registerLegacyNamespaceProp('PopupServiceImpl', PopupServiceImpl);

  oj.Object.createSubclass(PopupServiceImpl, PopupService, 'oj.PopupServiceImpl');

  /**
   * Establishes a popup to be open and managed by the framework.  Managed popups will
   * by reparented to the zorder container appended to the document body.  The
   * location within that container is determined by the launcher or modality options.
   *
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for opening the popup
   * @return {void}
   * @instance
   * @public
   * @override
   */
  PopupServiceImpl.prototype.open = function (options) {
    oj.Assert.assertObject(options);

    /** @type {!jQuery} */
    var popup = $(options[PopupService.OPTION.POPUP]);
    oj.Assert.assertPrototype(popup, $);

    // Trying to open a popup that is either already opening, open or closing.
    // Evaulate if global dom listeners are still needed and ignore the request.
    // This is generally and indicator something wacky has happened that needs recovery.
    var status = ZOrderUtils.getStatus(popup);
    if (
      !(
        status === ZOrderUtils.STATUS.UNKNOWN ||
        status === ZOrderUtils.STATUS.BEFORE_OPEN ||
        status === ZOrderUtils.STATUS.CLOSE
      )
    ) {
      this._assertEventSink();
      return;
    }

    /** @type {jQuery} */
    var launcher = $(options[PopupService.OPTION.LAUNCHER]);
    oj.Assert.assertPrototype(launcher, $);

    /** @type {Object} */
    var position = options[PopupService.OPTION.POSITION];
    oj.Assert.assertObjectOrNull(position);

    /** @type {!Object.<PopupService.EVENT, function(...)>} **/
    var events = options[PopupService.OPTION.EVENTS];
    oj.Assert.assertObject(events);

    var modality = options[PopupService.OPTION.MODALITY];
    if (
      !modality ||
      !(PopupService.MODALITY.MODELESS === modality || PopupService.MODALITY.MODAL === modality)
    ) {
      modality = PopupService.MODALITY.NONE;
    }

    var layerClass = options[PopupService.OPTION.LAYER_SELECTORS];
    oj.Assert.assertString(layerClass);

    var isCustomElement = options[PopupService.OPTION.CUSTOM_ELEMENT];

    var layerLevel = options[PopupService.OPTION.LAYER_LEVEL];
    if (
      !layerLevel ||
      !(
        PopupService.LAYER_LEVEL.TOP_LEVEL === layerLevel ||
        PopupService.LAYER_LEVEL.NEAREST_ANCESTOR === layerLevel
      )
    ) {
      layerLevel = PopupService.LAYER_LEVEL.NEAREST_ANCESTOR;
    }

    var beforeOpenCallback = events[PopupService.EVENT.POPUP_BEFORE_OPEN];
    if (!beforeOpenCallback || !$.isFunction(beforeOpenCallback)) {
      beforeOpenCallback = PopupServiceImpl._defaultBeforeOpenCallback;
    }

    var afterOpenCallback = events[PopupService.EVENT.POPUP_AFTER_OPEN];

    ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.OPENING);

    // set logical parent
    DomUtils.setLogicalParent(popup, launcher);

    ZOrderUtils.addToAncestorLayer(
      popup,
      launcher,
      modality,
      layerClass,
      layerLevel,
      isCustomElement
    );

    // JET-69585: remove aria-hidden from the container before adding and focusing content (not after)
    popup.removeAttr('aria-hidden');

    var _finalize = function () {
      try {
        this._assertEventSink();
      } catch (e) {
        Logger.error('Error opening popup:\n%o', e);
      } finally {
        ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.OPEN);
        // invoke the after open callback if one is provided.
        if (afterOpenCallback) {
          afterOpenCallback(options);
        }

        // delay activating event callbacks until after open is resolved
        // preventing a race condition
        var layer = ZOrderUtils.getFirstAncestorLayer(popup);
        oj.Assert.assertPrototype(layer, $);

        // JET-70327: apply aria-hidden now, after focus has been moved
        if (PopupService.MODALITY.MODAL === modality) {
          ZOrderUtils._setAriaHiddenOnBackround(layer);
        }

        ZOrderUtils.applyEvents(layer, events);

        // if the originating subtree where the popup was defined is removed during
        // open animation, invoke the popup remove event callback.  It's registered
        // late (applyEvents above) to prevent removing the popup while it's animating open.
        if (
          !ZOrderUtils._getSurrogate(layer) &&
          $.isFunction(events[PopupService.EVENT.POPUP_REMOVE])
        ) {
          var surrogateRemoveCallback = events[PopupService.EVENT.POPUP_REMOVE];
          surrogateRemoveCallback();
        }
      }
    };
    _finalize = _finalize.bind(this);

    var resultant;
    try {
      resultant = beforeOpenCallback(options);
      Components.subtreeShown(popup[0]);
    } catch (e) {
      Logger.error('Error before open popup:\n%o', e);
    } finally {
      if (resultant && resultant instanceof Promise) {
        resultant.then(_finalize);
      } else {
        _finalize();
      }
    }
  };

  /**
   * Default {@link PopupService.EVENT.POPUP_BEFORE_OPEN} if one is not provided.
   * @private
   * @since 3.0.0
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {Promise|void}
   */
  PopupServiceImpl._defaultBeforeOpenCallback = function (options) {
    /** @type {!jQuery} */
    var popup = $(options[PopupService.OPTION.POPUP]);
    oj.Assert.assertPrototype(popup, $);

    /** @type {Object} */
    var position = options[PopupService.OPTION.POSITION];

    popup.show();
    if (position) {
      popup.position(position);
    }

    return undefined;
  };

  /**
   * Closes a open popup managed by the framework.  The popup element is reparented
   * to its original location within the document.  Any open descendent popups are
   * implicitly closed.
   *
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {void}
   * @instance
   * @public
   * @override
   */
  PopupServiceImpl.prototype.close = function (options) {
    oj.Assert.assertObject(options);

    /** @type {!jQuery} */
    var popup = $(options[PopupService.OPTION.POPUP]);
    oj.Assert.assertPrototype(popup, $);

    /** @type {!jQuery} */
    var layer = ZOrderUtils.getOpenPopupLayer(popup);
    oj.Assert.assertPrototype(layer, $);

    /** @type {!Object.<PopupService.EVENT, function(...)>} **/
    var events = options[PopupService.OPTION.EVENTS];
    if (!events) {
      events = ZOrderUtils.getEvents(layer);
      // eslint-disable-next-line no-param-reassign
      options[PopupService.OPTION.EVENTS] = events;
    } else {
      events = $.extend(ZOrderUtils.getEvents(layer), events);
    }

    // Popup is not in a open status or there are no events registered for the popup,
    // then it is opening, closing or already closed. Evaluate if the document level
    // dom listeners are still needed and ignore the request.
    var status = ZOrderUtils.getStatus(popup);
    if (
      !(status === ZOrderUtils.STATUS.OPEN || status === ZOrderUtils.STATUS.BEFORE_CLOSE) ||
      !events
    ) {
      this._assertEventSink();
      return;
    }

    var beforeCloseCallback = events[PopupService.EVENT.POPUP_BEFORE_CLOSE];
    if (!beforeCloseCallback || !$.isFunction(beforeCloseCallback)) {
      beforeCloseCallback = PopupServiceImpl._defaultBeforeCloseCallback;
    }

    var afterCloseCallback = events[PopupService.EVENT.POPUP_AFTER_CLOSE];

    ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.CLOSING);
    // Unregister events during before close callback
    ZOrderUtils.applyEvents(layer, {});

    // JET-70327 - clear aria-hidden before returning focus to the launcher
    ZOrderUtils._resetAriaHiddenOnBackround(layer);

    var _finalize = function () {
      try {
        popup.hide();
        // If 'null' value was provided as the position option, do not reset it.
        // Consumer handles positioning by his own (DrawerPopup)
        if (options[PopupService.OPTION.POSITION] !== null) {
          // reset position units
          popup.css({ top: 'auto', bottom: 'auto', left: 'auto', right: 'auto' });
        }

        ZOrderUtils.removeFromAncestorLayer(popup);

        // remove the logical parent
        DomUtils.setLogicalParent(popup, null);

        this._assertEventSink();
        Components.subtreeHidden(popup[0]);
      } catch (e) {
        Logger.error('Error closing popup:\n%o', e);
      } finally {
        ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.CLOSE);
        if (afterCloseCallback && $.isFunction(afterCloseCallback)) {
          afterCloseCallback(options);
        }
        // set aria-hidden on the popup when completely closed
        popup.attr('aria-hidden', 'true');
      }
    };
    _finalize = _finalize.bind(this);

    var resultant;
    try {
      resultant = beforeCloseCallback(options);
    } catch (e) {
      Logger.error('Error before close popup:\n%o', e);
    } finally {
      if (resultant && resultant instanceof Promise) {
        resultant.then(_finalize);
      } else {
        _finalize();
      }
    }
  };

  /**
   * Default {@link PopupService.EVENT.POPUP_BEFORE_CLOSE} if one is not provided.
   *
   * @private
   * @since 3.0.0
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {Promise|void} undefined is returned indicating no animation (sync operation)
   */
  PopupServiceImpl._defaultBeforeCloseCallback = function (options) {
    /** @type {!jQuery} */
    var popup = $(options[PopupService.OPTION.POPUP]);
    oj.Assert.assertPrototype(popup, $);

    popup.hide();
    return undefined;
  };

  /**
   * Applies a new {@link PopupService.OPTION.EVENTS} callback linkage or
   * applies changes a popup dialogs {@link PopupService.OPTION.MODALITY},
   * {@link PopupService.OPTION.EVENTS}, or {@link PopupService.OPTION.LAYER_SELECTORS}.
   * @param {!Object.<PopupService.OPTION, ?>} options property bag including target popup
   * @return {void}
   * @instance
   * @public
   * @override
   */
  PopupServiceImpl.prototype.changeOptions = function (options) {
    oj.Assert.assertObject(options);

    /** @type {!jQuery} */
    var popup = $(options[PopupService.OPTION.POPUP]);
    oj.Assert.assertPrototype(popup, $);

    if (ZOrderUtils.getStatus(popup) !== ZOrderUtils.STATUS.OPEN) {
      return;
    }

    /** @type {!jQuery} */
    var layer = ZOrderUtils.getOpenPopupLayer(popup);
    oj.Assert.assertPrototype(layer, $);

    /** @type Object.<PopupService.EVENT, function(...)> */
    var events = options[PopupService.OPTION.EVENTS];
    if (events) {
      ZOrderUtils.applyEvents(layer, events);
    }

    /** @type {PopupService.MODALITY} */
    var modality = options[PopupService.OPTION.MODALITY];
    if (modality) {
      ZOrderUtils.applyModality(layer, popup, modality);
    }

    /** @type {?} */
    var layerClass = options[PopupService.OPTION.LAYER_SELECTORS];
    if (!oj.StringUtils.isEmptyOrUndefined(layerClass)) {
      layer.attr('class', layerClass);
    }
  };

  /**
   * Triggers the target event defined on all open descendent popups.
   * @param {!jQuery} popup to target triggering the event on decendents
   * @param {!PopupService.EVENT} event to trigger
   * @param {Array=} argsArray to pass "apply" to the associated callback for the event
   * @return {void}
   * @instance
   * @override
   * @public
   */
  PopupServiceImpl.prototype.triggerOnDescendents = function (popup, event, argsArray) {
    // if the popup is not open, there are not descendents
    if (!ZOrderUtils.isPopupOpen(popup)) {
      return;
    }

    var context = {};
    context.event = event;
    context.argsArray = argsArray;

    /** @type {!jQuery} */
    var layer = ZOrderUtils.getFirstAncestorLayer(popup);
    ZOrderUtils.postOrderVisit(layer, this._triggerOnDescendentsVisitCallback, context);
  };

  /**
   * The {@link ZOrderUtils.postOrderVisit} callback implementation for
   * {@link PopupServiceImpl#triggerOnDescendents}.
   *
   * @param {!jQuery} layer
   * @param {!Object} context
   * @instance
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see PopupServiceImpl#triggerOnDescendents
   */
  PopupServiceImpl.prototype._triggerOnDescendentsVisitCallback = function (layer, context) {
    var event = context.event;
    var argsArray = context.argsArray;

    var events = ZOrderUtils.getEvents(layer);
    if (events && $.isFunction(events[event])) {
      events[event].apply(this, argsArray);
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  /**
   * Depending on if popups are open, adds or removes event listeners redistributed
   * to open popups.
   * @return {void}
   * @instance
   * @private
   */
  PopupServiceImpl.prototype._assertEventSink = function () {
    var hasPopupsOpen = ZOrderUtils.hasPopupsOpen();
    var callbackEventFilter = this._callbackEventFilter;
    var i;
    var docElement;
    var event;

    if (!hasPopupsOpen && callbackEventFilter) {
      window.removeEventListener('resize', PopupServiceImpl._refreshCallback, true);
      window.removeEventListener('scroll', PopupServiceImpl._refreshCallback, true);

      docElement = document.documentElement;
      docElement.removeEventListener('mousewheel', PopupServiceImpl._refreshCallback, {
        passive: true,
        capture: true
      });
      docElement.removeEventListener('DOMMouseScroll', PopupServiceImpl._refreshCallback, true);

      this._callbackEventFilter = null;
      for (i = 0; i < PopupServiceImpl._REDISTRIBUTE_EVENTS.length; i++) {
        event = PopupServiceImpl._REDISTRIBUTE_EVENTS[i];
        docElement.removeEventListener(event, callbackEventFilter, true);
      }

      var simpleTapRecognizer = this._simpleTapRecognizer;
      if (simpleTapRecognizer) {
        simpleTapRecognizer.destroy();
        this._simpleTapRecognizer = null;
      }
    } else if (hasPopupsOpen && !callbackEventFilter) {
      window.addEventListener('resize', PopupServiceImpl._refreshCallback, true);
      window.addEventListener('scroll', PopupServiceImpl._refreshCallback, true);

      docElement = document.documentElement;
      docElement.addEventListener('mousewheel', PopupServiceImpl._refreshCallback, {
        passive: true,
        capture: true
      });
      docElement.addEventListener('DOMMouseScroll', PopupServiceImpl._refreshCallback, true);

      callbackEventFilter = this._eventFilterCallback.bind(this);
      this._callbackEventFilter = callbackEventFilter;
      for (i = 0; i < PopupServiceImpl._REDISTRIBUTE_EVENTS.length; i++) {
        event = PopupServiceImpl._REDISTRIBUTE_EVENTS[i];
        docElement.addEventListener(event, callbackEventFilter, true);
      }

      if (DomUtils.isTouchSupported()) {
        this._simpleTapRecognizer = new SimpleTapRecognizer(callbackEventFilter);
      }
    }
  };

  /**
   * Event callback for events defined by {@link PopupServiceImpl._REDISTRIBUTE_EVENTS}.
   * This callback handles applying the ".oj-focus-within" selector to the popup that
   * is active.  It also handles redistributing events to open popups.
   *
   * @param {Event} event from document capture listeners
   * @return {void}
   * @instance
   * @private
   */
  PopupServiceImpl.prototype._eventFilterCallback = function (event) {
    var target = $(event.target);

    var hasPopupsOpen = ZOrderUtils.hasPopupsOpen();
    if (!hasPopupsOpen) {
      this._assertEventSink();
      return;
    }

    // Ignore mouse events on the scrollbar. FF and Chrome, raises focus events on the
    // scroll container too.
    if (DomUtils.isChromeEvent(event) || (event.type === 'focus' && !target.is(':focusable'))) {
      return;
    }

    var defaultLayer = ZOrderUtils.getDefaultLayer();
    if (
      event.type === 'keydown' &&
      ZOrderUtils.hasModalDialogOpen() &&
      !DomUtils.isAncestor(defaultLayer[0], target[0])
    ) {
      // Inexpensive check to make sure that if a modal dialog is open,
      // we prevent a keydown outside the zorder layer that contains all
      // popups.  This handles the scenario where focus is placed in the
      // location bar and you start tabbing.  The browser will try to tab to
      // the first tabstop in the document.  Eat this event if it's under the
      // modal glass (not within the zorder container) and don't redistribute.

      ZOrderUtils.eatEvent(event);
      return;
    }

    var targetWithinLayer = ZOrderUtils.getFirstAncestorLayer(target);
    var $lastFocusLayer = defaultLayer.find('.' + PopupServiceImpl._FOCUS_WITHIN_SELECTOR).first();
    var targetIsOverlay = event.target.classList.contains(ZOrderUtils._OVERLAY_SELECTOR);

    // toggle the oj-focus-within pseudo state
    if (defaultLayer[0] !== targetWithinLayer[0]) {
      if (!targetWithinLayer.hasClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR)) {
        if ($lastFocusLayer.length) {
          $lastFocusLayer.removeClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
        }
        targetWithinLayer.addClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
      }
    } else if ($lastFocusLayer.length && !targetIsOverlay) {
      // focus relinquished outside any managed popup
      $lastFocusLayer.removeClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
    }

    // Don't redistribute a focus event targeted for an element that doesn't normally take focus.
    // Clicking on the scrollbars sometimes targets focus on containers with a -1 tabindex.
    // However, we still need to process the focus-within logic for this scenario.
    if (event.type === 'focus' && target.attr('tabindex') === '-1') {
      return;
    }

    // redistribute events for auto dismissal
    var context = {};
    context.targetIsOverlay = targetIsOverlay;

    // Capture all interesting event properties.  Similar to jQuery.event.fix.
    var _COPY_SAFE_EVENT_PROPERTIES = PopupServiceImpl._COPY_SAFE_EVENT_PROPERTIES;
    var props = {};
    for (var i = 0; i < _COPY_SAFE_EVENT_PROPERTIES.length; i++) {
      var key = _COPY_SAFE_EVENT_PROPERTIES[i];
      var value = event[key];
      if (value !== undefined && !$.isFunction(value)) {
        props[key] = value;
      }
    }

    // Wrap a native event in a jQuery.Event
    context.event = $.Event(event, props);
    ZOrderUtils.postOrderVisit(defaultLayer, PopupServiceImpl._redistributeVisitCallback, context);
  };

  /**
   * The {@link ZOrderUtils.postOrderVisit} callback for redistributing
   * {@link PopupService.EVENT.POPUP_AUTODISMISS} events to open popups.
   * @param {!jQuery} layer
   * @param {!Object} context
   * @return {ZOrderUtils.VISIT_RESULT}
   * @instance
   * @private
   * @see PopupServiceImpl#_eventFilterCallback
   */
  PopupServiceImpl._redistributeVisitCallback = function (layer, context) {
    var events = ZOrderUtils.getEvents(layer);
    var event = context.event;

    if (events && $.isFunction(events[PopupService.EVENT.POPUP_AUTODISMISS])) {
      events[PopupService.EVENT.POPUP_AUTODISMISS](event);
    } else if (event.type === 'mousedown' && context.targetIsOverlay) {
      // JET-50124: if no autodismiss handler is registered and the event is 'mousedown'
      // on overlay div, we need to prevent focus from escaping to the document body
      event.preventDefault();
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  /**
   * Event listener added to the window for the resize and scroll events.
   *
   * @param {Event} event resize,scroll or mousewheel event
   * @return {void}
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  PopupServiceImpl._refreshCallback = function (event) {
    var refreshTimerId = PopupServiceImpl._refreshTimerId;
    if (!isNaN(refreshTimerId)) {
      return;
    }

    // Throttle redistributing the refresh listener to intervals of ? ms.
    // This will help performance for chatty events such as scroll.

    PopupServiceImpl._refreshTimerId = window.setTimeout(function () {
      PopupServiceImpl._refreshTimerId = Number.NaN;
      var defaultLayer = ZOrderUtils.getDefaultLayer();

      if ($.isFunction(window.requestAnimationFrame)) {
        PopupServiceImpl._afRequestId = window.requestAnimationFrame(function () {
          PopupServiceImpl._afRequestId = null;
          ZOrderUtils.postOrderVisit(defaultLayer, PopupServiceImpl._refreshVisitCallback);
        });
      } else {
        ZOrderUtils.postOrderVisit(defaultLayer, PopupServiceImpl._refreshVisitCallback);
      }
    }, PopupServiceImpl._REFRESH_DELAY);
  };

  /**
   * The {@link ZOrderUtils.postOrderVisit} callback for invoking the
   * {@link PopupService.EVENT.POPUP_REFRESH} function for open popups.
   *
   * @param {!jQuery} layer
   * @param {!Object} context
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see PopupServiceImpl._refreshCallback
   */
  PopupServiceImpl._refreshVisitCallback = function (layer, context) {
    // Only need to call on the first level of popups as they will recursively
    // call on children.
    var level = context.level;
    if (level > 0) {
      return ZOrderUtils.VISIT_RESULT.REJECT;
    }

    var events = ZOrderUtils.getEvents(layer);
    if (events && $.isFunction(events[PopupService.EVENT.POPUP_REFRESH])) {
      events[PopupService.EVENT.POPUP_REFRESH]();
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  /**
   * @return {void}
   * @instance
   * @public
   * @override
   */
  PopupServiceImpl.prototype.destroy = function () {
    PopupServiceImpl.superclass.destroy.call(this);
  };

  /**
   * The pseudo select name applied to the popup that has focus.
   *
   * @const
   * @private
   * @type {string}
   */
  PopupServiceImpl._FOCUS_WITHIN_SELECTOR = 'oj-focus-within';

  /**
   * Array of events that are redistributed to open popups.
   *
   * @const
   * @private
   * @type {Array.<string>}
   */
  PopupServiceImpl._REDISTRIBUTE_EVENTS = ['focus', 'mousedown', 'keydown'];

  /**
   * Map of event properties that are interesting to capture when creating a jQuery.Event
   * wrapper from a native event.  This is similar to what is done in jQuery.event.fix.
   * This list is needed to prevent warning messages for event properties that have been
   * deprecated.
   *
   * @const
   * @private
   * @type {Object}
   */
  PopupServiceImpl._COPY_SAFE_EVENT_PROPERTIES = [
    'altKey',
    'bubbles',
    'cancelable',
    'ctrlKey',
    'currentTarget',
    'eventPhase',
    'metaKey',
    'relatedTarget',
    'shiftKey',
    'target',
    'timeStamp',
    'view',
    'which',
    'button',
    'buttons',
    'clientX',
    'clientY',
    'offsetX',
    'offsetY',
    'pageX',
    'pageY',
    'screenX',
    'screenY',
    'toElement',
    'char',
    'charCode',
    'key',
    'keyCode'
  ];

  /**
   * Milliseconds that is used to throttle processing of native resize, scroll and mousewheel
   * events. Dispatching refresh events to open popups will happen after the delay.
   * This is to guard against chatty events.
   *
   * @const
   * @private
   * @type {number}
   */
  PopupServiceImpl._REFRESH_DELAY = 10;

  /**
   * Utilities used by the popup framework.
   * @since 1.1.0
   * @ignore
   * @ojtsignore
   */
  oj._registerLegacyNamespaceProp('ZOrderUtils', ZOrderUtils);

  /**
   * Operation status for a target popup.
   * @enum {number}
   * @public
   * @see ZOrderUtils.getStatus
   * @see ZOrderUtils.setStatus
   * @ojtsignore
   */
  ZOrderUtils.STATUS = {
    /** Node has not interacted with the popup service. */
    UNKNOWN: 0,
    /** triggering the before open event */
    BEFORE_OPEN: 0.5,
    /** Popup is in the process of opening. */
    OPENING: 1,
    /** Popup is currently open. */
    OPEN: 2,
    /** triggering the before close event */
    BEFORE_CLOSE: 2.5,
    /** Popup is in the process of closing */
    CLOSING: 3,
    /** Popup previously open is now closed **/
    CLOSE: 4
  };

  /**
   * Key to annotate the modal overlay.
   */
  ZOrderUtils.MODAL_OVERLAY = Symbol.for('oj-modal-overlay');

  /**
   * Key to store the current operation status of the popup.
   * @const
   * @private
   * @type {Symbol}
   * @see ZOrderUtils.getStatus
   * @see ZOrderUtils.setStatus
   */
  ZOrderUtils._STATUS_DATA = Symbol('PopupStatus');

  /**
   * Returns the current operation status of the target popup element.
   * @param {jQuery|Element} popup
   * @returns {ZOrderUtils.STATUS}
   * @see ZOrderUtils.setStatus
   */
  ZOrderUtils.getStatus = function (popup) {
    if (popup instanceof Element) {
      // eslint-disable-next-line no-param-reassign
      popup = $(popup);
    }

    /** @type {?} */
    var status = ZOrderUtils.STATUS.UNKNOWN;
    if (popup.length) {
      status = popup[0][ZOrderUtils._STATUS_DATA];
      if (isNaN(status)) {
        status = ZOrderUtils.STATUS.UNKNOWN;
      }
    }
    return status;
  };

  /**
   * Sets the current operational status of the popup element.
   * @param {jQuery|Element} popup
   * @param {ZOrderUtils.STATUS} status
   * @see ZOrderUtils.getStatus
   */
  ZOrderUtils.setStatus = function (popup, status) {
    if (popup instanceof Element) {
      // eslint-disable-next-line no-param-reassign
      popup = $(popup);
    }
    var popupDom = popup[0];

    if (status >= ZOrderUtils.STATUS.UNKNOWN && status <= ZOrderUtils.STATUS.CLOSE) {
      popupDom[ZOrderUtils._STATUS_DATA] = status;
    }
  };

  /**
   * Accepts a launcher associated with the target popup being open.  The
   * resultant is the nearest layer or default zorder container that the
   * popup should be reparented to when open.  It can also return the
   * layer "stacking context" of a popup that is already open.
   *
   * @param {jQuery=} launcher associated with the target popup
   * @return {!jQuery}
   * @public
   */
  ZOrderUtils.getFirstAncestorLayer = function (launcher) {
    // dialogs will not have launchers and will be top rooted
    if (!launcher) {
      return ZOrderUtils.getDefaultLayer();
    }

    var parent = launcher;
    while (
      parent &&
      parent.length > 0 &&
      parent.attr(ZOrderUtils._SURROGATE_ATTR) !== ZOrderUtils._DEFAULT_LAYER_ID
    ) {
      if (ZOrderUtils._hasSurrogate(parent[0])) {
        return parent;
      }
      parent = parent.parent();
    }

    return ZOrderUtils.getDefaultLayer();
  };

  /**
   * Returns the jQuery DIV element that represents the zorder container prepended to the
   * document body.  All open popups will be a descendent of the resultant node.
   *
   * @return {!jQuery}
   * @public
   */
  ZOrderUtils.getDefaultLayer = function () {
    /** @type {jQuery} */
    var defaultLayer = $(document.getElementById(ZOrderUtils._DEFAULT_LAYER_ID));
    if (defaultLayer.length > 0) {
      return defaultLayer;
    }

    defaultLayer = $('<div>');
    defaultLayer.attr('role', 'presentation');
    defaultLayer.attr('id', ZOrderUtils._DEFAULT_LAYER_ID);
    defaultLayer.prependTo($(document.body)); // @HTMLUpdateOK attach programmatic generated node

    return defaultLayer;
  };

  /**
   * Adds the target popup to the nearest ancestor layer within the zorder container.
   * A surrogate script element will be added to mark where the popup root element
   * was prior to reparenting.
   *
   * @param {!jQuery} popup root widget
   * @param {?jQuery} launcher associated with a popup
   * @param {!PopupService.MODALITY} modality of the popup being open
   * @param {string} layerClass selector that defines the stacking context "z-index" of the popup
   * @param {PopupService.LAYER_LEVEL} layerLevel defines where the popup will be reparented
   * @param {boolean} isCustomElement indicates if the owning component is a custom element
   * @return {void}
   * @public
   */
  ZOrderUtils.addToAncestorLayer = function (
    popup,
    launcher,
    modality,
    layerClass,
    layerLevel,
    isCustomElement
  ) {
    var popupDom = popup[0];
    if (ZOrderUtils._hasSurrogate(popupDom.parentNode)) {
      throw new Error('JET Popup is already open - id: ' + popupDom.getAttribute('id'));
    }

    var ancestorLayer = ZOrderUtils.getFirstAncestorLayer(
      layerLevel === PopupService.LAYER_LEVEL.TOP_LEVEL ? null : launcher
    );

    var layer = $('<div>');

    /** @type {?} */
    var popupId = popup.attr('id');
    if (oj.StringUtils.isEmptyOrUndefined(popupId)) {
      layer.uniqueId();
    } else {
      layer.attr('id', [popupId, 'layer'].join('_'));
    }

    layer.attr('role', 'presentation');
    layer.addClass(layerClass);
    popup.after(layer); // @HTMLUpdateOK

    const surrogate = ZOrderUtils._createSurrogate(layer, isCustomElement);

    Components.subtreeDetached(popupDom);
    popup.appendTo(layer); // @HTMLUpdateOK

    // link the popup to the layer @see ZOrderUtils.getOpenPopupLayer
    popupDom[ZOrderUtils._LAYER_ID_DATA] = layer.attr('id');

    layer.appendTo(ancestorLayer); // @HTMLUpdateOK
    Components.subtreeAttached(popupDom);

    ZOrderUtils._applyVDomPatch(surrogate[0], popupDom);

    ZOrderUtils.applyModality(layer, popup, modality);
  };

  /**
   * @ignore
   */
  ZOrderUtils._applyVDomPatch = function (surrogate, popup) {
    // It does not seem that a surrogate is ever reused, so we should not have to
    // clear the OJ_POPUP symbol when the dialog is closed
    // eslint-disable-next-line no-param-reassign
    surrogate[ojpreactPatch.OJ_POPUP] = popup;

    ojpreactPatch.patchPopupParent(surrogate.parentElement);
  };

  /**
   * @param {!jQuery} layer of the target popup
   * @return {jQuery} surrogate element associated with the layer
   * @private
   */
  ZOrderUtils._getSurrogate = function (layer) {
    var surrogateId = layer.attr(ZOrderUtils._SURROGATE_ATTR);
    if (surrogateId) {
      return document.getElementById(surrogateId);
    }
    return undefined;
  };

  /**
   * Replaces the event callback map associated with an open popup.  The event
   * callbacks are used for auto dismissal or handling implicit dismissal when
   * the surrogate element associated with a layer is removed from the document.
   *
   * @param {!jQuery} layer of the target popup
   * @param {!Object.<PopupService.EVENT, function(...)>} events map of event name to callback
   * @param {?Object=} surrogate saves position within the document where popup is
   *             defined
   * @return {void}
   * @public
   */
  ZOrderUtils.applyEvents = function (layer, events, surrogate) {
    if (!surrogate) {
      // eslint-disable-next-line no-param-reassign
      surrogate = $(ZOrderUtils._getSurrogate(layer));
    }

    layer.data(ZOrderUtils._EVENTS_DATA, events);

    if (surrogate.length > 0 && events && $.isFunction(events[PopupService.EVENT.POPUP_REMOVE])) {
      // if the surrogate script element gets replaced in the dom it will trigger closure of the
      // popup.
      Components.setComponentOption(
        surrogate[0],
        'beforeDestroy',
        events[PopupService.EVENT.POPUP_REMOVE]
      );
    }
  };

  /**
   * Returns the map of event callbacks associated with an open popup.
   *
   * @param {!jQuery} layer of an open popup
   * @return {!Object.<PopupService.EVENT, function(...)>}
   * @public
   */
  ZOrderUtils.getEvents = function (layer) {
    /** @type {?} */
    var events = layer.data(ZOrderUtils._EVENTS_DATA);
    return events;
  };

  /**
   * Creates a script element before the target layer bound to the simple jquery UI
   * surrogate component.  Links this element to the layer by attribute named
   * {@link ZOrderUtils._SURROGATE_ATTR}.
   *
   * @param {!jQuery} layer stacking context
   * @param {boolean} isCustomElement
   * @return {jQuery}
   * @private
   * @see ZOrderUtils.addToAncestorLayer
   */
  ZOrderUtils._createSurrogate = function (layer, isCustomElement) {
    var nodeName = 'script'; // @HTMLUpdateOK
    if (isCustomElement) {
      nodeName = 'oj-surrogate';
    }

    /** @type {?} */
    var surrogate = $(document.createElement(nodeName)); // @HTMLUpdateOK

    /** @type {?} */
    var layerId = layer.attr('id');
    if (!oj.StringUtils.isEmptyOrUndefined(layerId)) {
      surrogate.attr('id', [layerId, 'surrogate'].join('_'));
    }

    if (isCustomElement) {
      // programmatically created elements not managed by a binding stratagy like knockout
      // needs this attribute to signal the component should be created.
      surrogate.attr('data-oj-binding-provider', 'none');
    }

    surrogate.insertBefore(layer); // @HTMLUpdateOK

    if (!isCustomElement) {
      // create the jquery ui component bound to the script node
      surrogate.ojSurrogate();
    }

    /** @type {?} */
    var surrogateId = surrogate.attr('id');
    // loosely associate the popup to the surrogate element
    layer.attr(ZOrderUtils._SURROGATE_ATTR, surrogateId); // @HTMLUpdateOK

    return surrogate;
  };

  /**
   * Reparents the layer after the associated surrogate script element removing
   * the surrogate script element.
   *
   * @param {!jQuery} layer stacking context of the popup
   * @return {boolean} true if the original location the popup was defined still exists
   * @private
   * @see ZOrderUtils.removeFromAncestorLayer
   */
  ZOrderUtils._removeSurrogate = function (layer) {
    /** @type {?} */
    var surrogateId = layer.attr(ZOrderUtils._SURROGATE_ATTR);
    layer.removeAttr(ZOrderUtils._SURROGATE_ATTR);

    /** @type {jQuery} */
    var surrogate = $(document.getElementById(surrogateId));
    var originatingSubtreeExists = surrogate.length > 0;
    if (originatingSubtreeExists) {
      layer.insertAfter(surrogate); // @HTMLUpdateOK
      Components.setComponentOption(surrogate[0], 'beforeDestroy', null);
      surrogate.remove();
    }

    return originatingSubtreeExists;
  };

  /**
   * Returns the layer associated with a popup.  The layer should be the immediate parent of an open
   * popup unless it was disconnected from the document.
   *
   * @param {!jQuery} popup
   * @returns {!jQuery} open popup's layer
   * @public
   */
  ZOrderUtils.getOpenPopupLayer = function (popup) {
    /** @type {?} */
    var layer = popup.parent();
    var popupDom = popup[0];

    if (!layer || layer.length === 0) {
      // the open popup has been detached from the layer before it was closed
      // use the backup pointer for better cleanup
      /** @type {?} */
      var layerId = popupDom[ZOrderUtils._LAYER_ID_DATA];
      layer = $(document.getElementById(layerId));
    }

    return layer;
  };

  /**
   * Closes a open popup by reparenting it back to its original location within
   * the document marked by the surrogate.  Recursively calls the
   * {@link PopupService.EVENT.POPUP_CLOSE} event callback on descendent popups.
   * @param {!jQuery} popup root widget
   * @return {void}
   * @public
   */
  ZOrderUtils.removeFromAncestorLayer = function (popup) {
    var layer = ZOrderUtils.getOpenPopupLayer(popup);

    ZOrderUtils.preOrderVisit(layer, ZOrderUtils._closeDescendantPopupsCallback);

    ZOrderUtils._removeOverlayFromAncestorLayer(layer);
    ZOrderUtils._restoreBodyOverflow();

    layer.removeData(ZOrderUtils._EVENTS_DATA);
    layer.removeData(ZOrderUtils._MODALITY_DATA);

    var popupDom = popup[0];
    delete popupDom[ZOrderUtils._LAYER_ID_DATA];

    Components.subtreeDetached(popupDom);
    var originatingSubtreeExists = ZOrderUtils._removeSurrogate(layer);

    // if the popup is not orphaned
    if (originatingSubtreeExists && popupDom && popupDom.parentElement) {
      DomUtils.unwrap(popup, layer);
      Components.subtreeAttached(popupDom);
    } else {
      layer.remove();
    }
  };

  /**
   * The {@link ZOrderUtils.preOrderVisit} callback that invokes the
   * {@link PopupService.EVENT.POPUP_CLOSE} function for descendent
   * popups.
   * @param {!jQuery} layer to be dismissed
   * @param {!Object} context for visit tree
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see ZOrderUtils.removeFromAncestorLayer
   */
  ZOrderUtils._closeDescendantPopupsCallback = function (layer, context) {
    var level = context.level;
    // Only need to visit the immediate children as the children will recursively
    // close any open child popups.
    if (level > 0) {
      return ZOrderUtils.VISIT_RESULT.REJECT;
    }

    var events = layer.data(ZOrderUtils._EVENTS_DATA);
    if (events && $.isFunction(events[PopupService.EVENT.POPUP_CLOSE])) {
      events[PopupService.EVENT.POPUP_CLOSE]();
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  ZOrderUtils._disableBodyOverflow = function (layer) {
    const body = document.body;
    const popup = layer.children()[0];
    if (
      Math.floor($(popup).width()) <= window.innerWidth &&
      Math.floor($(popup).height()) <= window.innerHeight
    ) {
      // JET-44685: setting 'overflow:hidden' on body is not enough to lock background scrolling on iOS.
      // There is the address bar which gets hidden/revealed when swiping the screen vertically and
      // iOS seems to ignore 'overflow:hidden' until the address bar is visible.
      // The generally recommended workaround is setting 'position: fixed' on body while preserving
      // the current scroll position.
      if (oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS) {
        if (this._iosScrollLockBackup) {
          return;
        }
        const offsetLeft = window.visualViewport.offsetLeft;
        const offsetTop = window.visualViewport.offsetTop;
        const windowScrollX = window.pageXOffset;
        const windowScrollY = window.pageYOffset;

        this._iosScrollLockBackup = {
          windowScrollX: windowScrollX,
          windowScrollY: windowScrollY,
          bodyPosition: body.style.position,
          bodyOverflow: body.style.overflow,
          bodyTop: body.style.top,
          bodyLeft: body.style.left,
          bodyRight: body.style.right
        };

        body.style.position = 'fixed';
        body.style.overflow = 'hidden';
        body.style.top = `${-(windowScrollY - Math.floor(offsetTop))}px`;
        body.style.left = `${-(windowScrollX - Math.floor(offsetLeft))}px`;
        body.style.right = '0';
      } else {
        // JET-44685: anywhere else but iOS, setting body.style.overflow='hidden' is sufficient
        body.classList.add('oj-component-modal-open');
      }
    }
  };

  ZOrderUtils._restoreBodyOverflow = function () {
    // if there are no more modals left, enable scrolling on body
    if (!ZOrderUtils.hasModalDialogOpen()) {
      const body = document.body;

      // JET-44685: if on iOS, revert the previously applied scroll lock patch
      if (oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS) {
        if (!this._iosScrollLockBackup) {
          return;
        }

        const backup = this._iosScrollLockBackup;

        body.style.position = backup.bodyPosition;
        body.style.overflow = backup.bodyOverflow;
        body.style.top = backup.bodyTop;
        body.style.left = backup.bodyLeft;
        body.style.right = backup.bodyRight;

        window.scrollTo(backup.windowScrollX, backup.windowScrollY);

        delete this._iosScrollLockBackup;
      } else {
        body.classList.remove('oj-component-modal-open');
      }
    }
  };

  ZOrderUtils._removeFocusWithinFromOverlayedContent = function () {
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    var $lastFocusLayer = defaultLayer.find('.' + PopupServiceImpl._FOCUS_WITHIN_SELECTOR).first();

    if ($lastFocusLayer.length) {
      // focus relinquished outside any managed popup
      $lastFocusLayer.removeClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
    }
  };

  /**
   * Handles adding or removing a sibling overlay blocking pane before the dialog
   * based on the modality option.  The overlay pane is associated with the dialog
   * vai a attribute pointing to the id of the overlay.
   *
   * @param {!jQuery} layer for the target popup
   * @param {PopupService.MODALITY} modality
   * @return {void}
   * @public
   */
  ZOrderUtils.applyModality = function (layer, popup, modality) {
    /** @type {?} */
    var currModality = layer.data(ZOrderUtils._MODALITY_DATA);
    layer.data(ZOrderUtils._MODALITY_DATA, modality);

    if (oj.StringUtils.isEmptyOrUndefined(currModality)) {
      if (PopupService.MODALITY.MODAL === modality) {
        ZOrderUtils._addOverlayToAncestorLayer(layer);
        ZOrderUtils._disableBodyOverflow(layer);
        ZOrderUtils._removeFocusWithinFromOverlayedContent();
      } else {
        // Note: Calling this is probably not necessary as this is initial opening of a popup
        ZOrderUtils._removeOverlayFromAncestorLayer(layer);
      }
    } else if (currModality !== modality) {
      if (modality === PopupService.MODALITY.MODAL) {
        ZOrderUtils._addOverlayToAncestorLayer(layer);
        ZOrderUtils._disableBodyOverflow(layer);
        ZOrderUtils._removeFocusWithinFromOverlayedContent();
      } else {
        ZOrderUtils._removeOverlayFromAncestorLayer(layer);
        ZOrderUtils._restoreBodyOverflow();
      }
    }
    if (modality === PopupService.MODALITY.MODAL) {
      // JET-65003: only set aria-modal, if role is 'dialog' or 'alertdialog'
      const role = popup.attr('role');
      if (role === 'dialog' || role === 'alertdialog') {
        popup.attr('aria-modal', 'true');
      }
    } else {
      // saw a tech note that a "false" value doesn't convey the same information as
      // if the attribute wasnt present at all screen readers.
      popup.removeAttr('aria-modal');
    }
  };

  /**
   * Adds aria-hidden="true" on elements outside of the modal popup hierarchy.
   * This is a required workaround for screen readers that do not honor
   * the aria-modal="true" setting on the popup and allow elements under
   * the modal overlay to be read and accessed.
   *
   * @param {!jQuery} layer for the target popup
   * @return {void}
   * @private
   */
  ZOrderUtils._setAriaHiddenOnBackround = function (layer) {
    var $node = layer;
    var $hidden = $();
    do {
      $hidden = $hidden.add($node.siblings(':not(script):not([aria-hidden="true"])'));
      $node = $node.parent();
    } while ($node[0] && $node[0].tagName.toLowerCase() !== 'body');
    $hidden.attr('aria-hidden', true);
    layer.data(ZOrderUtils._ARIA_HIDDEN_ELEMS, $hidden);
  };

  /**
   * Removes aria-hidden="true" on elements outside of the modal popup hierarchy
   * when the modal closes or modality status changes.
   *
   * @param {!jQuery} layer for the target popup
   * @return {void}
   * @private
   */
  ZOrderUtils._resetAriaHiddenOnBackround = function (layer) {
    var $hidden = layer.data(ZOrderUtils._ARIA_HIDDEN_ELEMS);
    if ($hidden) {
      $hidden.removeAttr('aria-hidden');
      layer.removeData(ZOrderUtils._ARIA_HIDDEN_ELEMS);
    }
  };

  /**
   * @return {boolean} <code>true</code> if one or more modal dialogs are open
   * @public
   */
  ZOrderUtils.hasModalDialogOpen = function () {
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    var children = defaultLayer.children();
    var childrenCount = children.length;
    for (var i = childrenCount - 1; i > -1; i--) {
      var child = $(children[i]);
      if (child.hasClass(ZOrderUtils._OVERLAY_SELECTOR)) {
        return true;
      }
    }

    return false;
  };

  /**
   * Creates a overlay div assigned the {@link ZOrderUtils._OVERLAY_SELECTOR}
   * selector inserted before the dialog layer.  The layer is associated to the
   * overlay by the {@link ZOrderUtils._OVERLAY_ATTR} assigned to the root layer
   * element.
   * @param {!jQuery} layer root widget
   * @return {void}
   * @private
   * @see ZOrderUtils.applyModality
   */
  ZOrderUtils._addOverlayToAncestorLayer = function (layer) {
    /** @type {jQuery} */
    var overlay = $('<div>');
    overlay.addClass(ZOrderUtils._OVERLAY_SELECTOR);
    overlay.addClass(layer[0].className);
    overlay.attr('role', 'presentation');

    /** @type {?} */
    var layerId = layer.attr('id');
    if (oj.StringUtils.isEmptyOrUndefined(layerId)) {
      overlay.uniqueId();
    } else {
      overlay.attr('id', [layerId, 'overlay'].join('_'));
    }

    overlay[0][ZOrderUtils.MODAL_OVERLAY] = true;

    layer.before(overlay); // @HTMLUpdateOK

    /** @type {?} */
    var overlayId = overlay.attr('id');
    layer.attr(ZOrderUtils._OVERLAY_ATTR, overlayId); // @HTMLUpdateOK
  };

  /**
   * Removes the overlay associated with a modal dialog and removes the the attribute
   * that associates the popup with the overlay.
   *
   * @param {!jQuery} layer root widget
   * @return {void}
   * @private
   * @see ZOrderUtils.applyModality
   */
  ZOrderUtils._removeOverlayFromAncestorLayer = function (layer) {
    /** @type {?} */
    var overlayId = layer.attr(ZOrderUtils._OVERLAY_ATTR);

    if (!oj.StringUtils.isEmptyOrUndefined(overlayId)) {
      layer.removeAttr(ZOrderUtils._OVERLAY_ATTR);
      var overlay = $(document.getElementById(overlayId));
      overlay.remove();
    }
  };

  /**
   * Resultant enumerated type used to control the popup visit (pre/post order)
   * traversal.
   * @enum {number}
   * @public
   * @see ZOrderUtils.postOrderVisit
   * @see ZOrderUtils.preOrderVisit
   * @ojtsignore
   */
  ZOrderUtils.VISIT_RESULT = {
    /** Continue to descend into current subtree. */
    ACCEPT: 0,
    /** Halt processing the subtree but contine visiting */
    REJECT: 1,
    /** Halt tree visit **/
    COMPLETE: 2
  };

  /**
   * Defines the visit traversal type.
   * @enum {number}
   * @private
   */
  ZOrderUtils._VISIT_TRAVERSAL = {
    /** The callback is invoked on the target popup before any children. */
    PRE_ORDER: 0,
    /** The callback is invoked on the target popup after first visiting all descendents. */
    POST_ORDER: 1
  };

  /**
   * Visits all open popups invoking the callback function on the target popup after first
   * visiting all children in order of last open.
   * @param {!jQuery} layer to begin searching for popups
   * @param {function(!jQuery, !Object) : ZOrderUtils.VISIT_RESULT} callback invoked for each
   *        child popup
   * @param {Object=} context passed to the visit
   * @return {void}
   * @public
   */
  ZOrderUtils.postOrderVisit = function (layer, callback, context) {
    var _context = context;
    if (!context) {
      _context = {};
    }

    _context.level = 0;
    _context.type = ZOrderUtils._VISIT_TRAVERSAL.POST_ORDER;
    ZOrderUtils._visitTree(layer, callback, _context);
  };

  /**
   * Visits all open popups invoking the callback on the target popup before any
   * popups that are descendents.
   * @param {!jQuery} layer to begin searching for popups
   * @param {function(!jQuery, !Object) : ZOrderUtils.VISIT_RESULT} callback invoked for each child
   *         popup
   * @param {Object=} context passed to the visit
   * @return {void}
   * @public
   */
  ZOrderUtils.preOrderVisit = function (layer, callback, context) {
    var _context = context;
    if (!context) {
      _context = {};
    }

    _context.level = 0;
    _context.type = ZOrderUtils._VISIT_TRAVERSAL.PRE_ORDER;
    ZOrderUtils._visitTree(layer, callback, _context);
  };

  /**
   * Visits popups in order defined by {@link ZOrderUtils._VISIT_TRAVERSAL.PRE_ORDER}
   * invoking the callback for each popup.
   * @param {!jQuery} layer to begin searching for popups
   * @param {function(!jQuery, !Object) : ZOrderUtils.VISIT_RESULT} callback
   *        invoked for each child popup
   * @param {!Object} context passed to the visit
   * @return {ZOrderUtils.VISIT_RESULT} instructions on how to proceed
   * @private
   * @see ZOrderUtils.preOrderVisit
   * @see ZOrderUtils.postOrderVisit
   */
  ZOrderUtils._visitTree = function (layer, callback, context) {
    // Patterned from the RC visit APIs
    var level = context.level;

    var children = layer.children();
    var childrenCount = children.length;
    for (var i = childrenCount - 1; i > -1; i--) {
      var child = $(children[i]);
      if (ZOrderUtils._hasSurrogate(child[0])) {
        var vrtn;

        // handle visit pre-order
        if (context.type === ZOrderUtils._VISIT_TRAVERSAL.PRE_ORDER) {
          vrtn = callback(child, context);
          if (vrtn === ZOrderUtils.VISIT_RESULT.COMPLETE) {
            return vrtn;
          } else if (vrtn === ZOrderUtils.VISIT_RESULT.REJECT) {
            break;
          }
        }

        // visit children
        // eslint-disable-next-line no-param-reassign
        context.level = level + 1;
        vrtn = ZOrderUtils._visitTree(child, callback, context);
        // eslint-disable-next-line no-param-reassign
        context.level = level;
        if (vrtn === ZOrderUtils.VISIT_RESULT.COMPLETE) {
          return vrtn;
        }

        // handle visit post-order
        if (context.type === ZOrderUtils._VISIT_TRAVERSAL.POST_ORDER) {
          vrtn = callback(child, context);
          if (vrtn === ZOrderUtils.VISIT_RESULT.COMPLETE) {
            return vrtn;
          } else if (vrtn === ZOrderUtils.VISIT_RESULT.REJECT) {
            break;
          }
        }
      }
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  /**
   * Determines the target element is an open popup by checking for the
   * {@link ZOrderUtils._SURROGATE_ATTR} attribute assigned to open popup layers.
   *
   * @param {!Element} element to check for a stand-in component
   * @return {boolean} <code>true</code> if the element is associated with a placeholder element
   * @private
   */
  ZOrderUtils._hasSurrogate = function (element) {
    if (element && element.nodeType === 1 && element.hasAttribute(ZOrderUtils._SURROGATE_ATTR)) {
      return true;
    }
    return false;
  };

  /**
   * @return {boolean} <code>true</code> if one or more popups are open
   * @public
   */
  ZOrderUtils.hasPopupsOpen = function () {
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    return defaultLayer.children().length > 0;
  };

  /**
   * @return {number} total number of open popups
   * @public
   */
  ZOrderUtils.getOpenPopupCount = function () {
    var context = {};
    context.popupCount = 0;

    var defaultLayer = ZOrderUtils.getDefaultLayer();
    ZOrderUtils.preOrderVisit(defaultLayer, ZOrderUtils._openPopupCountCallback, context);

    return context.popupCount;
  };

  /**
   * The {@link ZOrderUtils.preOrderVisit} callback for counting the total number of
   * open popups.
   * @param {!jQuery} layer
   * @param {!Object} context for visit tree
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see ZOrderUtils.getOpenPopupCount
   */
  ZOrderUtils._openPopupCountCallback = function (layer, context) {
    // eslint-disable-next-line no-param-reassign
    context.popupCount += 1;
    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  /**
   * Returns a jQuery set of all open popup layer dom elements.  Popups open last will appear at the
   * end of the set. Used by automated testing.
   * @return {!jQuery} set of all open popup root elements managed by the popup service
   * @public
   */
  ZOrderUtils.findOpenPopups = function () {
    var context = {};

    /** @type {Array.<Element>} */
    var popups = [];

    context.popups = popups;
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    ZOrderUtils.preOrderVisit(defaultLayer, ZOrderUtils._openPopupsCallback, context);
    popups = context.popups;

    return $(popups);
  };

  /**
   * The {@link ZOrderUtils.preOrderVisit} callback that collects a set of open
   * popups.
   * @param {!jQuery} layer
   * @param {!Object} context for visit tree
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see ZOrderUtils.findOpenPopups
   */
  ZOrderUtils._openPopupsCallback = function (layer, context) {
    /** @type {Array.<Element>} */
    var popups = context.popups;
    popups.push(layer[0]);
    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };

  /**
   * @public
   * @param {!Element} element to determine if it's above the top modal popup
   * @returns {boolean} returns <code>true</code> if the element is above the top modal popup
   */
  ZOrderUtils.isAboveTopModalLayer = function (element) {
    /**
     * @return {Element|undefined}
     */
    function getTopLayer() {
      // traverses the first level of popups looking for the popup with the highest
      // stacking context.
      // pre-order traversal
      function callback(layer, context) {
        var level = context.level;

        // first level traversal only
        if (level > 0) {
          return ZOrderUtils.VISIT_RESULT.REJECT;
        }

        var prevLayer = context.topLayer;
        if (prevLayer) {
          // if the current layer has a higher context than the prev, it becomes the top
          if (ZOrderUtils.compareStackingContexts($(layer), $(prevLayer)) > 0) {
            // eslint-disable-next-line no-param-reassign
            context.topLayer = layer;
          }
        } else {
          // eslint-disable-next-line no-param-reassign
          context.topLayer = layer;
        }
        return ZOrderUtils.VISIT_RESULT.ACCEPT;
      }

      var context = { topLayer: null };
      var defaultLayer = ZOrderUtils.getDefaultLayer();
      ZOrderUtils.preOrderVisit(defaultLayer, callback, context);
      if (context.topLayer) {
        return context.topLayer[0];
      }
      return undefined;
    }

    /**
     *
     * @param {!Element} topLayer
     * @return {Element|undefined}
     */
    function getTopModalLayer(topLayer) {
      // post-order traversal starting at the topLayer.  Retuns the modal popup at the
      // highest deepest level.
      function callback(layer, context) {
        if (layer[0].hasAttribute(ZOrderUtils._OVERLAY_ATTR)) {
          // eslint-disable-next-line no-param-reassign
          context.topModalPopup = layer;
          return ZOrderUtils.VISIT_RESULT.COMPLETE;
        }
        return ZOrderUtils.VISIT_RESULT.ACCEPT;
      }

      var context = {
        topModalPopup: null
      };
      if (topLayer.hasAttribute(ZOrderUtils._OVERLAY_ATTR)) {
        context.topModalPopup = $(topLayer);
      }

      ZOrderUtils.postOrderVisit($(topLayer), callback, context);

      if (context.topModalPopup) {
        return context.topModalPopup[0];
      }
      return undefined;
    }

    // inexpensive prerequisite check
    if (!element || !ZOrderUtils.hasPopupsOpen()) {
      return true;
    }

    // Popups closest to the body will have the greatest stacking context weight.
    // Find the top first level layer.
    var topLayer = getTopLayer();
    if (!topLayer) {
      return true;
    }

    // look for the last modal popup open starting from the top layer
    var topModalLayer = getTopModalLayer(topLayer);
    if (!topModalLayer) {
      return true;
    }

    // Returns true if the target element is a child of the top most modal layer.
    return (
      DomUtils.isAncestorOrSelf(topModalLayer, element) ||
      ZOrderUtils.compareStackingContexts($(topModalLayer), $(element)) < 0
    );
  };

  /**
   * Utility used for testing. Compares two jquery singleton wappered elements
   * determining which element has the greatest stacking context.
   * @public
   * @param {jQuery} el1 first element to compare
   * @param {jQuery} el2 second element to compare
   * @return {number} 0 if elements have the same stacking context;
   *                  1 if the first element has a greater stacking context;
   *                 -1 when the second element has a greater stacking context;
   */
  ZOrderUtils.compareStackingContexts = function (el1, el2) {
    oj.Assert.assertPrototype(el1, $);
    oj.Assert.assertPrototype(el2, $);

    function describeStackingContext(element, allLevels) {
      var positions = ['absolute', 'relative', 'fixed'];
      var parents = element.parents();

      var tmp = [];
      var i;
      for (i = parents.length - 1; i > -1; i--) {
        tmp.push($(parents[i]));
      }
      parents = tmp;

      parents.push(element);

      var stack = [];
      var level = 0;
      for (i = 0; i < parents.length; i++) {
        var parent = parents[i];
        var position = parent.css('position');
        var opacity = DomUtils.getCSSLengthAsFloat(parent.css('opacity'));
        var zindex = DomUtils.getCSSLengthAsInt(parent.css('z-index'));
        var order = $.inArray(parent[0], parent.parent().children());
        if ($.inArray(position, positions) > -1 && zindex > 0) {
          stack.push({ weight: [level, zindex, order], order: [order] });
          level += 1;
        } else if (opacity < 1) {
          stack.push({ weight: [level, 1, order], order: [order] });
          level += 1;
        } else if (allLevels) {
          stack.push({ weight: [0, 0, order], order: [order] });
        }
      }
      return stack;
    }

    function compareSets(n1, n2) {
      var maxLen = Math.max(n1.length, n2.length);
      for (var i = 0; i < maxLen; i++) {
        var _e1 = i < n1.length ? n1[i] : 0;
        var _e2 = i < n2.length ? n2[i] : 0;
        if (_e1 !== _e2) {
          if (_e1 < _e2) {
            return -1;
          }
          return 1;
        }
      }
      return 0;
    }

    var n1 = describeStackingContext(el1, false);
    var n2 = describeStackingContext(el2, false);
    var i;
    var c;
    var e1;
    var e2;

    var maxLen = Math.max(n1.length, n2.length);
    for (i = 0; i < maxLen; i++) {
      e1 = i < n1.length ? n1[i].weight : [-1];
      e2 = i < n2.length ? n2[i].weight : [-1];

      c = compareSets(e1, e2);
      if (c !== 0) {
        return c;
      }
    }

    // include all elements for tie breaker
    n1 = describeStackingContext(el1, true);
    n2 = describeStackingContext(el2, true);

    maxLen = Math.max(n1.length, n2.length);
    // tie breaker based on document order
    for (i = 0; i < maxLen; i++) {
      e1 = i < n1.length ? n1[i].order : [-1];
      e2 = i < n2.length ? n2[i].order : [-1];

      c = compareSets(e1, e2);
      if (c !== 0) {
        return c;
      }
    }

    return 0;
  };

  /**
   * Event listener that will stop propagation and prevent default on the event.
   * @param {jQuery.Event|Event} event
   * @return {void}
   * @public
   */
  ZOrderUtils.eatEvent = function (event) {
    event.stopPropagation();
    event.preventDefault();
  };

  /**
   * @public
   * @param {jQuery} popup jQuery element
   * @return {boolean} <code>true</code> if the popup is reparented into the zorder container
   */
  ZOrderUtils.isPopupOpen = function (popup) {
    // only open popups will be associated with a surrogate via parent layer
    var parent = popup.parent();
    if (parent && parent.length === 1 && ZOrderUtils._hasSurrogate(parent[0])) {
      return true;
    }
    return false;
  };

  /**
   * Key used to store the popup event callbacks on the popup layer
   * as a jQuery data property.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._EVENTS_DATA = 'oj-popup-events';

  /**
   * Key used to store the modality of a popup layer as a jQuery data property.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._MODALITY_DATA = 'oj-popup-modality';

  /**
   * Key used to store the aria-hidden elems outside of a modal popup layer
   * as a jQuery data property.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._ARIA_HIDDEN_ELEMS = 'oj-aria-hidden-elems';

  /**
   * The id assigned to the zorder container that will house all open popups.
   * The zorder container will be appended to the document body.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._DEFAULT_LAYER_ID = '__oj_zorder_container';

  /**
   * The attribute name assigned to the associated layer of open popups.  The value of the
   * attribute will point to the script element that holds the place in the document
   * that the popup originated from prior to being open.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._SURROGATE_ATTR = 'data-oj-surrogate-id';

  /**
   * This key that captures the popups layer id.  The layer should always be the immediate parent
   * of the popup after open but if the popup is disconnected from the layer, this is a secondary
   * link to the layer for better cleanup.
   *
   * @const
   * @private
   * @type {Symbol}
   * @see ZOrderUtils.getOpenPopupLayer
   */
  ZOrderUtils._LAYER_ID_DATA = Symbol('PopupLayerId');

  /**
   * The attribute name assigned to the popup layer for open dialogs that have a
   * modality state of "modal".  The value of the attribute points to the associated
   * overlay element.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._OVERLAY_ATTR = 'data-oj-overlayid';

  /**
   * The CSS selector name assigned to the modal overlay DIV.
   * @const
   * @private
   * @type {string}
   */
  ZOrderUtils._OVERLAY_SELECTOR = 'oj-component-overlay';

  /* eslint-disable no-param-reassign */

  /**
   * Utilities used in conjunction with the jquery positon utility.
   * @ignore
   * @class PositionUtils
   * @ojtsignore
   */
  const PositionUtils = {};
  oj._registerLegacyNamespaceProp('PositionUtils', PositionUtils);

  /**
   * <p>Of the properties on the position object, "my" and "at" are of interest. The base jQuery
   * horizontal alignment mnemonics are "right", "center" and "left". For better JET RTL
   * support we have added "start" and "end".  Depending on the rtl direction, "start" and
   * "end" will be replaced with "left" or "right". The resultant postion object will
   * be a new instance that extends the position passed as the first argument.
   *
   * <p>Likewise, JET supports "<" and ">" operators wherever "-" and "+" are supported.
   * The "<" value means "- in LTR; + in RTL", while the ">" value means "+ in LTR; - in RTL".
   * E.g. a "my" value of "start<40" shifts the menu 40px "startward," while a "my" value of
   * "start>40" shifts the menu 40px "endward."
   *
   * @param {Object} position source position object
   * @param {boolean} isRtl
   * @return {Object} position object that has normalized jquery horizontal mnemonics.
   */
  PositionUtils.normalizeHorizontalAlignment = function (position, isRtl) {
    // This assertion prevents security testing: someone could pass in a bogus position
    // oj.Assert.assertObject(position, "position");
    var target = $.extend({}, position);
    for (var i = 0; i < PositionUtils._ALIGN_RULE_PROPERTIES.length; i++) {
      var propName = PositionUtils._ALIGN_RULE_PROPERTIES[i];
      var align = target[propName];
      if (align) {
        if (oj.StringUtils.isString(align)) {
          target[propName] = align
            .replace('start', isRtl ? 'right' : 'left')
            .replace('end', isRtl ? 'left' : 'right')
            .replace('<', isRtl ? '+' : '-')
            .replace('>', isRtl ? '-' : '+');
        } else {
          for (var s = 0; s < PositionUtils._SUB_ALIGN_RULE_PROPERTIES.length; s++) {
            var subPropName = PositionUtils._SUB_ALIGN_RULE_PROPERTIES[s];
            var subAlign = align[subPropName];
            if (oj.StringUtils.isString(subAlign)) {
              align[subPropName] = subAlign
                .replace('start', isRtl ? 'right' : 'left')
                .replace('end', isRtl ? 'left' : 'right')
                .replace('<', isRtl ? '+' : '-')
                .replace('>', isRtl ? '-' : '+');
            }
          }
        }
      }
    }

    return target;
  };

  /**
   * <p>In the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility,
   * the "of" field specifies the element or event relative to which the popup should
   * be positioned.
   *
   * <p>Popup components like Menu often need to position themselves relative to their
   * launcher (e.g. MenuButton), or the launching event (e.g. right-click event), both
   * of which can vary on a per-launch basis.  To facilitate specifying these policies
   * in advance, in a component option, it's useful to support "launcher" and "event"
   * keywords in the "of" field.  Without these keywords, the app would have to set
   * this field at each popup launch, via either the open() method or a beforeOpen listener,
   * at which point they could supply the actual event or launcher element for this
   * particular launch.
   *
   * <p>This method is intended to be called by the popup component at launch time.  It
   * takes an "of" field possibly containing these keywords, and the event and launcher
   * for the current launch, and returns a new "of" value where those keywords have
   * been replaced by the event or launcher, so that the resulting "position" object
   * is ready to be passed to the JQUI utility.
   *
   * <p>Since callers may have different needs, this method does not log if, say,
   * of==="event" && event==null.  Callers should log or throw if this condition
   * indicates application error.
   *
   * <p>While the code is simple, it's useful to centralize the logic to avoid subtle
   * differences in behavior among JET popup components.
   *
   * @param of the "of" field of a position object.  Defaults to "launcher" if null/undefined.
   * @param launcher launcher element
   * @param event event that opened the popup
   * @return normalized "of" value
   */
  PositionUtils.normalizePositionOf = function (of, launcher, event) {
    if (of === 'event') {
      return event;
    } else if (of == null || of === 'launcher') {
      return launcher;
    }
    return of;
  };

  // TODO: file a JQ bug and link to it here.
  /**
   * On iOS and Android, the JQ Event object wrapping touch* events lacks pageX and pageY properties, which is contrary to the
   * contract [1].  This breaks JQ's position() API [2], which assumes that the contract is obeyed.  Specifically, it
   * relies on the pageX/Y fields of the Event object passed as the "of" field (and publicly docs that it does so).
   *
   * Per W3C [3], pageX/Y are found in originalEvent.touches[i] or originalEvent.changedTouches[i], where originalEvent is
   * the native (not JQ) event, and i is 0 for us.  In practice, for touchstart at least, iOS7 and 8 Mobile Safari, but
   * apparently not Android Chrome, also put pageX and pageY on the top-level native event, and the values seem to be the
   * same as those in the touches array.  We'll use the cross-platform W3C location.
   *
   * To workaround the JQ bug, popup components like Menu can call this method at open() time.  This method copies the properties
   * to the wrapper JQ event.
   *
   * [1] http://api.jquery.com/category/events/event-object/
   * [2] http://api.jqueryui.com/position/
   * [3] http://www.w3.org/TR/touch-events/#touch-interface et. seq.
   *
   * @private
   * @param event
   */
  PositionUtils._normalizeEventForPosition = function (event) {
    $.each(['pageX', 'pageY'], function (index, pagePos) {
      if (event && event[pagePos] === undefined && event.originalEvent) {
        var originalEvent = event.originalEvent;
        var type = originalEvent.type;
        var touchList;

        if (type === 'touchstart' || type === 'touchmove') {
          touchList = 'touches';
        } else if (type === 'touchend') {
          touchList = 'changedTouches';
        } else {
          touchList = null;
        }

        if (touchList) {
          var firstTouch = originalEvent[touchList][0];
          if (firstTouch) {
            // eslint-disable-next-line no-param-reassign
            event[pagePos] = firstTouch[pagePos];
          }
        }
      }
    });
  };

  /**
   * @private
   * @const
   */
  PositionUtils._ALIGN_RULE_PROPERTIES = ['my', 'at'];

  /**
   * @private
   * @const
   */
  PositionUtils._SUB_ALIGN_RULE_PROPERTIES = ['vertical', 'horizontal'];

  /**
   * A common utilty that is designed be be called for a jquery ui position "using" callback
   * that will check to see if the target aligning "of" position is clipped in an overflow
   * container.  Used by popups that should auto dismiss when what they are aligning to is
   * no longer visible.  The aligning position can be either an element, event or a rect.
   *
   * @param {Object} props second argument to the jquery ui position "using" callback.
   * @returns {boolean} <code>true</code> if the point aligned is not totally visible in and overflow container
   */
  PositionUtils.isAligningPositionClipped = function (props) {
    // Alignment can be to an element, event or a rect but we only care to make this
    // check if alignment is to an element - .
    if (props.target && props.target.height > 0 && props.target.width > 0) {
      // if the target has a width and height greater than zero then it's an element
      /** @type {jQuery} */
      var positionOf = props.target.element;
      return !PositionUtils.isWithinViewport(positionOf);
    }
    return false;
  };

  /**
   * Returns <code>true</code> if the jquery element is visible within overflow an
   * overflow container. The check only considers statically positioned elements and
   * stops short of the body.
   *
   * The first positioned ancestor is treated as the root viewport. Positioned elements need be
   * compared with the window viewport versus its ancestors.  Visibility of positioned
   * elements also need to compare stacking contexts within the document to determine
   * what is on top "visible" - thus excluded from this check.
   *
   * @param {jQuery} element jquery element to test
   * @returns {boolean}
   */
  PositionUtils.isWithinViewport = function (element) {
    function isVisible(alignBox, containerBox) {
      var scrollBarWidth;
      if (['hidden', 'scroll', 'auto'].indexOf(containerBox.overflowY) > -1) {
        // 1px fudge factor for rounding errors
        if (alignBox.bottom - containerBox.top < -1) {
          return false;
        }

        // find horizontal scrollbar size. always present when "scroll", or when "auto" and scrollWidth > innerWidth
        scrollBarWidth =
          (containerBox.overflowX === 'auto' && containerBox.scrollWidth > containerBox.innerWidth) ||
          containerBox.overflowX === 'scroll'
            ? DomUtils.getScrollBarWidth()
            : 0;
        if (containerBox.bottom - scrollBarWidth - alignBox.top < 1) {
          return false;
        }
      }

      if (['hidden', 'scroll', 'auto'].indexOf(containerBox.overflowX) > -1) {
        // find vertical scrollbar width. always present when "scroll", or when "auto" and scrollHeight > innerHeight
        scrollBarWidth =
          (containerBox.overflowY === 'auto' &&
            containerBox.scrollHeight > containerBox.innerHeight) ||
          containerBox.overflowY === 'scroll'
            ? DomUtils.getScrollBarWidth()
            : 0;

        // depending on ltr vs rtl, the vertical scrollbar can be on either side of the container, so only include the side its on
        if (
          alignBox.right -
            (containerBox.left + (DomUtils.getReadingDirection() === 'rtl' ? scrollBarWidth : 0)) <
            -1 ||
          alignBox.left -
            (containerBox.right - (DomUtils.getReadingDirection() === 'ltr' ? scrollBarWidth : 0)) >
            -1
        ) {
          return false;
        }
      }

      return true;
    }

    function hasOverflow(_element) {
      return _element.css('overflow-x') !== 'visible' || _element.css('overflow-y') !== 'visible';
    }

    function getRect(_element) {
      var domElement = _element[0];
      if (domElement.nodeType === 1) {
        var rec = $.extend({}, domElement.getBoundingClientRect());
        rec.overflowX = _element.css('overflow-x');
        rec.overflowY = _element.css('overflow-y');
        rec.innerHeight = _element.innerHeight();
        rec.innerWidth = _element.innerWidth();
        rec.scrollHeight = domElement.scrollHeight;
        rec.scrollWidth = domElement.scrollWidth;
        return rec;
      }
      return { height: 0, width: 0 };
    }

    function isPositioned(_element) {
      return (
        ['fixed', 'absolute', 'relative', 'sticky'].indexOf(_element.css('position')) > -1 &&
        (!isNaN(parseInt(_element.css('top'), 10)) ||
          !isNaN(parseInt(_element.css('bottom'), 10)) ||
          !isNaN(parseInt(_element.css('left'), 10)) ||
          !isNaN(parseInt(_element.css('right'), 10)))
      );
    }

    if (!element) {
      return false;
    } else if ($.isWindow(element[0]) || isPositioned(element)) {
      return true;
    }

    var alignBox = getRect(element);

    // check that the element is not hidden in overflow
    var isWithinViewPort = true;
    var parent = element.parent();
    while (
      isWithinViewPort &&
      parent &&
      parent.length > 0 &&
      parent[0].nodeName !== 'BODY' &&
      parent[0].nodeType === 1 &&
      !isPositioned(parent)
    ) {
      if (hasOverflow(parent)) {
        var parentBox = getRect(parent);
        // ignore elements with empty border-boxes
        if (parentBox.height > 0 && parentBox.width > 0) {
          isWithinViewPort = isVisible(alignBox, parentBox);
        }
      }
      parent = parent.parent();
    }

    return isWithinViewPort;
  };

  /**
   * Mapping of horizontal-vertical (x,y) alignment positon to the corresponding css
   * "transform-origin" attribute.
   *
   * horizontal: right, left, center
   * vertical: top, bottom, middle
   *
   * @private
   * @const
   */
  PositionUtils._ANIMATION_TRANSFORM_ORIGIN_RULES = {
    'right-top': 'right top',
    'right-middle': 'right center',
    'right-bottom': 'right bottom',
    'left-top': 'left top',
    'left-middle': 'left center',
    'left-bottom': 'left bottom',
    'center-top': 'center top',
    'center-middle': 'center center',
    'center-bottom': 'center bottom'
  };

  /**
   * Data attribute key used to store the alignment of the popup relative
   * to the aligning element - position.of
   *
   * @private
   * @const
   * @type {string}
   */
  PositionUtils._ALIGN_MNEMONIC_DATA = 'oj-popup-align-mnemonic';

  /**
   * Pass the root popup element and the second argument of the jquery ui position utils using
   * callback.  Stashes away the alignment hints returned by the position utility as a data property
   * on the target jquery element.  The alignment hints are used to define the transform-origin
   * of animation effects.
   *
   * @see PositionUtils.addTransformOriginAnimationEffectsOption
   * @param {jQuery} element popup root node
   * @param {Object} props second argument to the jquery ui position "using" callback.
   * @return {void}
   */
  PositionUtils.captureTransformOriginAnimationEffectsOption = function (element, props) {
    var alignMnemonic = [props.horizontal, props.vertical].join('-');
    element.data(PositionUtils._ALIGN_MNEMONIC_DATA, alignMnemonic);
  };

  /**
   * Pass "open" or "close" animation effects.  Replaces occurances of
   * "transformOrigin":"#myPositon" with a value that represents the popups alignment.
   *
   * @see PositionUtils.captureTransformOriginAnimationEffectsOption
   * @param {jQuery} element popup root node
   * @param {string|Object|Array} effects animation instructions
   * @returns {string|Object|Array} effects with the transformOrign property resolved
   */
  PositionUtils.addTransformOriginAnimationEffectsOption = function (element, effects) {
    var effectsAsString;
    var isEffectsTypeofString;

    if (!oj.StringUtils.isString(effects)) {
      isEffectsTypeofString = false;
      effectsAsString = JSON.stringify(effects);
    } else {
      isEffectsTypeofString = true;
      effectsAsString = effects;
    }

    var exp = /#myPosition/g;
    if (effectsAsString.match(exp)) {
      var alignMnemonic = /** @type {string} */ (element.data(PositionUtils._ALIGN_MNEMONIC_DATA));
      if (oj.StringUtils.isEmptyOrUndefined(alignMnemonic)) {
        alignMnemonic = 'center-middle';
      }

      var transformOrigin = PositionUtils._ANIMATION_TRANSFORM_ORIGIN_RULES[alignMnemonic];

      effectsAsString = effectsAsString.replace(exp, transformOrigin);

      // eslint-disable-next-line no-param-reassign
      effects = isEffectsTypeofString
        ? effectsAsString
        : /** @type {Object} */ (JSON.parse(effectsAsString));
    }

    return effects;
  };

  /**
   * Splits the jquery UI vertical mnemonic into 3 groups.
   * @private
   * @constant {RegExp}
   */
  PositionUtils._JQUI_MNEMONIC_GRP_REGX = /^(\w+)(\+|-)?(\d+)?/;

  /**
   * Verify vertical mnemonic.
   * @private
   * @constant {RegExp}
   */
  PositionUtils._VERTICAL_ENUM_TST_REGX = /^top$|^center$|^bottom$/;

  /**
   * Verify horizontal mnemonic.
   * @private
   * @constant {RegExp}
   */
  PositionUtils._HORIZONTAL_ENUM_TST_REGX = /^start$|^left$|^center$|^end$|^right$/;

  /**
   * Verify collision mnemonic.
   * @private
   * @constant {RegExp}
   */
  PositionUtils._COLLISION_ENUM_TST_REGX = /^none$|^flip$|^flipfit$|^fit$|^flipcenter$/;

  /**
   * @private
   * @param {string} token containing a position alignment rule
   * @param {RegExp} testRegX regular expression to verify the token enumerations
   * @returns {Array} array of two values [alignment, offset].
   */
  PositionUtils._parsePositionNmnemonic = function (token, testRegX) {
    var data = [null, Number.NaN];
    var groups = PositionUtils._JQUI_MNEMONIC_GRP_REGX.exec(token);

    if (groups[1] && testRegX.test(groups[1])) {
      data[0] = groups[1];

      // has an offset prefiex by +|-
      if (groups[2]) {
        var offset = parseInt(groups[3], 10);
        if (!isNaN(offset)) {
          offset *= groups[2] === '-' ? -1 : 1;
          data[1] = offset;
        }
      }
    }
    return data;
  };

  /**
   *
   * @private
   * @param {?} value that might be a json string
   * @returns {?} returns an object if the value is a json string; otherwise,
   *          a null value is returned.
   */
  PositionUtils._parseJSON = function (value) {
    if (oj.StringUtils.isString(value) && /^{/.test(value) && /}$/.test(value)) {
      try {
        return JSON.parse(value);
      } catch (e) {
        // Ignore errors
      }
    }

    return null;
  };

  /**
   * Converts a source "position.my" or "position.at" into a suitable state held by jet components.
   *
   * @param {string} type "my" or "at"
   * @param {Object} source postion.my or position.at to shape into a Jet position object
   * @param {Object=} offsetSource position.offset
   * @param {Object=} sourceDefault default values
   * @returns {Object} internal position impl
   * @private
   */
  PositionUtils._coerceMyAtToJet = function (type, source, offsetSource, sourceDefault) {
    var obj = PositionUtils._parseJSON(source);
    if (obj) {
      // eslint-disable-next-line no-param-reassign
      source = obj;
    }

    obj = PositionUtils._parseJSON(offsetSource);
    if (obj) {
      // eslint-disable-next-line no-param-reassign
      offsetSource = obj;
    }

    if (!sourceDefault) {
      // eslint-disable-next-line no-param-reassign
      sourceDefault = {};
    }

    var target = $.extend({}, sourceDefault);
    var offsetTarget = { x: 0, y: 0 };
    if (offsetSource && 'x' in offsetSource && 'y' in offsetSource) {
      offsetTarget.x = DomUtils.getCSSLengthAsInt(offsetSource.x);
      offsetTarget.y = DomUtils.getCSSLengthAsInt(offsetSource.y);
    }

    var groups;

    if (oj.StringUtils.isString(source)) {
      // jquery ui
      // split horizontal and vertical tokens
      var tokens = source.split(/\s/);

      // parse horizontal
      if (tokens.length > 0 && !oj.StringUtils.isEmpty(tokens[0])) {
        groups = PositionUtils._parsePositionNmnemonic(
          tokens[0],
          PositionUtils._HORIZONTAL_ENUM_TST_REGX
        );

        // verify horizontal enum
        if (groups[0]) {
          target.horizontal = groups[0];
          if (!isNaN(groups[1])) {
            offsetTarget.x = groups[1];
          }
        }
      }

      // parse vertical
      if (tokens.length > 1 && !oj.StringUtils.isEmpty(tokens[1])) {
        groups = PositionUtils._parsePositionNmnemonic(
          tokens[1],
          PositionUtils._VERTICAL_ENUM_TST_REGX
        );

        // verify vertical enum
        if (groups[0]) {
          target.vertical = groups[0];
          if (!isNaN(groups[1])) {
            offsetTarget.y = groups[1];
          }
        }
      }
    } else if (source) {
      // my is is in the jet position format
      if ('horizontal' in source) {
        groups = PositionUtils._parsePositionNmnemonic(
          source.horizontal,
          PositionUtils._HORIZONTAL_ENUM_TST_REGX
        );

        if (groups[0]) {
          target.horizontal = groups[0];
          if (!isNaN(groups[1])) {
            offsetTarget.x = groups[1];
          }
        }
      }

      if ('vertical' in source) {
        groups = PositionUtils._parsePositionNmnemonic(
          source.vertical,
          PositionUtils._VERTICAL_ENUM_TST_REGX
        );

        if (groups[0]) {
          target.vertical = groups[0];
          if (!isNaN(groups[1])) {
            offsetTarget.y = groups[1];
          }
        }
      }
    }

    var targetPosition = {};
    targetPosition[type] = target;
    targetPosition.offset = offsetTarget;
    return targetPosition;
  };

  /**
   * Converts a source "position.collision" into a suitable state held by jet components.
   *
   * @param {string} collisionSource postion.collision to shape into a Jet position object
   * @param {string=} collisionDefault default values
   * @returns {Object} internal position impl
   * @private
   */
  PositionUtils._coerceCollisionToJet = function (collisionSource, collisionDefault) {
    var collisionTarget = collisionDefault;

    if (PositionUtils._COLLISION_ENUM_TST_REGX.test(collisionSource)) {
      collisionTarget = collisionSource;
    }

    return { collision: collisionTarget };
  };

  /**
   * Converts a source "position.of" into a suitable state held by jet components.
   *
   * @param {Object} ofSource position.of
   * @param {Object=} ofDefault default value
   * @return {Object} internal postion object
   * @private
   */
  PositionUtils._coerceOfToJet = function (ofSource, ofDefault) {
    function _escapeId(id) {
      var targetId = [];
      var regex = /\w|_|-/;

      for (var i = 0; i < id.length; i++) {
        var c = id.substring(i, i + 1);
        if (regex.test(c)) {
          targetId.push(c);
        } else {
          targetId.push('\\' + c);
        }
      }
      return targetId.join('');
    }

    var obj = PositionUtils._parseJSON(ofSource);
    if (obj) {
      // eslint-disable-next-line no-param-reassign
      ofSource = obj;
    }

    var targetOf = ofDefault;

    if (oj.StringUtils.isString(ofSource)) {
      targetOf = ofSource; // assume a valid selector
    } else if ($.isWindow(ofSource)) {
      targetOf = 'window';
    } else if (ofSource instanceof Element || ofSource instanceof $) {
      // eslint-disable-next-line no-param-reassign
      ofSource = $(ofSource);
      ofSource.uniqueId();
      var id = ofSource.attr('id');
      targetOf = '#' + _escapeId(id);
    } else if (ofSource instanceof Event || ofSource instanceof $.Event) {
      if ('pageX' in ofSource || 'pageY' in ofSource) {
        targetOf = {};
        targetOf.x = DomUtils.getCSSLengthAsFloat(ofSource.pageX);
        targetOf.y = DomUtils.getCSSLengthAsFloat(ofSource.pageY);
      }
    } else if (ofSource) {
      if ('x' in ofSource || 'y' in ofSource) {
        targetOf = {};
        targetOf.x = DomUtils.getCSSLengthAsFloat(ofSource.x);
        targetOf.y = DomUtils.getCSSLengthAsFloat(ofSource.y);
      }
    }

    return { of: targetOf };
  };

  /**
   * Converts a source "position" into a suitable state held by jet components.
   *
   * @param {Object} source position
   * @param {Object=} defaults for target position
   * @return {Object} internal postion object
   */
  PositionUtils.coerceToJet = function (source, defaults) {
    if (!source) {
      // eslint-disable-next-line no-param-reassign
      source = {};
    }

    var obj = PositionUtils._parseJSON(source);
    if (obj) {
      // eslint-disable-next-line no-param-reassign
      source = obj;
    }

    if (!defaults) {
      // eslint-disable-next-line no-param-reassign
      defaults = {};
    }

    function _coerceUsingToJet(usingSource, usingDefault) {
      var targetUsing = $.isFunction(usingSource) ? usingSource : usingDefault;
      return { using: targetUsing };
    }

    var myDefault = defaults.my;
    var atDefault = defaults.at;
    var collisionDefault = defaults.collision;
    var ofDefault = defaults.of;
    var usingDefault; // to dangerous to inherit

    var targetMy = PositionUtils._coerceMyAtToJet('my', source.my, source.offset, myDefault);
    var targetAt = PositionUtils._coerceMyAtToJet('at', source.at, null, atDefault);

    // sum the "at" and "my" offsets
    var targetOffset = {
      offset: {
        x: targetMy.offset.x + targetAt.offset.x,
        y: targetMy.offset.y + targetAt.offset.y
      }
    };
    delete targetMy.offset;
    delete targetAt.offset;

    var target = $.extend(
      {},
      targetMy,
      targetAt,
      targetOffset,
      PositionUtils._coerceCollisionToJet(source.collision, collisionDefault),
      PositionUtils._coerceOfToJet(source.of, ofDefault),
      _coerceUsingToJet(source.using, usingDefault)
    );

    return target;
  };

  /**
   * Converts the jet position object into the jQuery UI object used by the position utility.
   *
   * @param {Object} source internal position object
   * @return {Object} jQuery UI position Object
   */
  PositionUtils.coerceToJqUi = function (source) {
    function alignToJqUi(align, direction) {
      var tokens = [];
      if (source[align][direction]) {
        tokens.push(source[align][direction]);
      } else {
        tokens.push('center');
      }

      if (align === 'my' && source.offset) {
        var offsetDirection = direction === 'horizontal' ? 'x' : 'y';
        var offset = source.offset[offsetDirection];
        if (!isNaN(offset) && offset !== 0) {
          tokens.push(offset > 0 ? '+' : '');
          tokens.push(Math.floor(offset).toString());
        }
      }

      return tokens.join('');
    }

    var target = {};

    // convert my and at
    ['my', 'at'].forEach(function (align) {
      if (source[align]) {
        var tokens = [];
        tokens.push(alignToJqUi(align, 'horizontal'));
        tokens.push(' ');
        tokens.push(alignToJqUi(align, 'vertical'));
        target[align] = tokens.join('');
      }
    });

    // convert of
    var ofSource = source.of;
    if (oj.StringUtils.isString(ofSource)) {
      if (ofSource === 'window') {
        target.of = window;
      } else {
        target.of = ofSource;
      }
    } else if (ofSource && !oj.StringUtils.isString(ofSource) && 'x' in ofSource && 'y' in ofSource) {
      var x = ofSource.x;
      var y = ofSource.y;
      var nativeEvent = document.createEvent('MouseEvents');
      nativeEvent.initMouseEvent(
        'click',
        true,
        true,
        window,
        1,
        x,
        y,
        x,
        y,
        false,
        false,
        false,
        false,
        0,
        null
      );
      target.of = $.Event(nativeEvent, { pageX: x, pageY: y });
    } else {
      target.of = ofSource;
    }

    if (source.collision) {
      target.collision = source.collision;
    }

    // convert using
    if (source.using) {
      target.using = source.using;
    }

    return target;
  };

  /**
   * Calculates available width and height for a popup based on the position 'using'
   * callback feedback.
   *
   * @param {Object} pos current popup position (left, top) returned by jqueryui.position
   * @param {Object} feedback an object with target and popup coordinates passed to
   *                          the position 'using' callback
   * @param {Element=} withinElem optional bounding element for popup position calculation
   *                          default is 'window'
   * @return {Object} object with max available popup width and height within current constraints
   */
  PositionUtils.calcAvailablePopupSize = function (pos, feedback, withinElem) {
    var within = $.position.getWithinInfo(withinElem || window);
    var scrollInfo = $.position.getScrollInfo(within);
    var isRtl = DomUtils.getReadingDirection() === 'rtl';

    var paddingLeft = isRtl ? scrollInfo.width : 0;
    var paddingRight = isRtl ? 0 : scrollInfo.width;

    var element = feedback.element;
    var target = feedback.target;

    var scrollLeft = within.isWindow ? within.scrollLeft : 0;
    var scrollTop = within.isWindow ? within.scrollTop : 0;

    var elemLeft = element.left;
    var elemRight = element.left + element.width;
    var elemTop = element.top;
    var elemBottom = element.top + element.height;
    var targetLeft = target.left;
    var targetRight = target.left + target.width;
    var targetTop = target.top;
    var targetBottom = target.top + target.height;
    var withinLeft = within.offset.left + scrollLeft + paddingLeft;
    // eslint-disable-next-line no-mixed-operators
    var withinRight = within.offset.left + within.width + scrollLeft - paddingRight;
    var withinTop = within.offset.top + scrollTop;
    // eslint-disable-next-line no-mixed-operators
    var withinBottom = within.offset.top + within.height + scrollTop - scrollInfo.height;

    var minLeft;
    var maxRight;
    var minTop;
    var maxBottom;

    if (elemLeft < targetLeft) {
      minLeft = withinLeft;
      if (elemRight <= targetLeft) {
        maxRight = targetLeft;
      } else if (elemRight <= targetRight) {
        maxRight = Math.min(targetRight, withinRight);
      } else {
        maxRight = withinRight;
      }
    } else if (elemLeft === targetLeft) {
      if (targetLeft - withinLeft > withinRight - targetRight) {
        minLeft = withinLeft;
        maxRight = targetRight;
      } else {
        minLeft = targetLeft;
        maxRight = withinRight;
      }
    } else if (elemLeft < targetRight) {
      minLeft = targetLeft;
      if (elemRight <= targetRight) {
        maxRight = targetRight;
      } else {
        maxRight = withinRight;
      }
    } else {
      minLeft = targetRight;
      maxRight = withinRight;
    }

    if (elemTop < targetTop) {
      minTop = withinTop;
      if (elemBottom <= targetTop) {
        maxBottom = targetTop;
      } else if (elemBottom <= targetBottom) {
        maxBottom = Math.min(targetBottom, withinBottom);
      } else {
        maxBottom = withinBottom;
      }
    } else if (elemTop === targetTop) {
      minTop = targetTop;
      maxBottom = withinBottom;
    } else if (elemTop < targetBottom) {
      minTop = targetTop;
      if (elemBottom <= targetBottom) {
        maxBottom = targetBottom;
      } else {
        maxBottom = withinBottom;
      }
    } else {
      minTop = targetBottom;
      maxBottom = withinBottom;
    }

    return {
      width: maxRight - minLeft,
      height: maxBottom - minTop
    };
  };

  /**
   * Forked version of jQueryUI.position() API with JET bug fixes.
   *
   */
  (function () {
    /**
     * @ojtsignore
     */
    var cachedScrollbarWidth;
    var max = Math.max;
    var abs = Math.abs;
    const rhorizontal = /left|center|right/;
    const rvertical = /top|center|bottom/;
    const roffset = /[+-]\d+(\.[\d]+)?%?/;
    const rposition = /^\w+/;
    const rpercent = /%$/;
    var _position = $.fn.position;

    var _origGetWithinInfo = $.position.getWithinInfo; // stash away the original getWithinInfo method

    function getOffsets(offsets, width, height) {
      return [
        parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
        parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
      ];
    }

    function parseCss(element, property) {
      return parseInt($.css(element, property), 10) || 0;
    }

    function isWindow(obj) {
      return obj != null && obj === obj.window;
    }

    function getDimensions(elem) {
      var raw = elem[0];
      if (raw.nodeType === 9) {
        return {
          width: elem.width(),
          height: elem.height(),
          offset: { top: 0, left: 0 }
        };
      }
      if (isWindow(raw)) {
        // JET-41302: jQuery's $(window).height() does not reflect changing window height
        // for dynamic browser adress bar and toolbar behavior while scrolling.
        // Need to use window.innerHeight on mobile.
        var agentInfo = oj.AgentUtils.getAgentInfo();
        var isMobile =
          oj.AgentUtils.OS.ANDROID === agentInfo.os || oj.AgentUtils.OS.IOS === agentInfo.os;
        return {
          width: elem.width(),
          height: isMobile ? raw.innerHeight : elem.height(),
          offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
        };
      }
      if (raw.preventDefault) {
        return {
          width: 0,
          height: 0,
          offset: { top: raw.pageY, left: raw.pageX }
        };
      }
      return {
        width: elem.outerWidth(),
        height: elem.outerHeight(),
        offset: elem.offset()
      };
    }

    /**
     * Forked jqueryUI $.position.scrollbarWidth() implementation.
     *
     * The original implementation in jqueryUI is not CSP compliant as
     * it creates a div with inline style. Our implementation replaces
     * the inline style definition with individual style property settings
     * on a temporary div element.
     *
     * The fork also includes the $.position.getScrollInfo method which depends
     * on $.position.scrollbarWidth via a local reference, so we cannot simply
     * delegate to the original method, because it would use the old
     * scrollbarWidth() version.
     *
     */
    $.position = {
      getWithinInfo: _origGetWithinInfo.bind(this),

      scrollbarWidth: function () {
        if (cachedScrollbarWidth !== undefined) {
          return cachedScrollbarWidth;
        }
        var w1;
        var w2;
        var div = document.createElement('div');
        div.style.display = 'block';
        div.style.position = 'absolute';
        div.style.width = '50px';
        div.style.height = '50px';
        div.style.overflow = 'hidden';
        var innerDiv = document.createElement('div');
        innerDiv.style.height = '100px';
        innerDiv.style.width = 'auto';
        div.appendChild(innerDiv); // @HTMLUpdateOK
        $('body').append($(div)); // @HTMLUpdateOK
        w1 = innerDiv.offsetWidth;
        div.style.overflow = 'scroll';
        w2 = innerDiv.offsetWidth;
        if (w1 === w2) {
          w2 = div.clientWidth;
        }
        $(div).remove();
        cachedScrollbarWidth = w1 - w2;
        return cachedScrollbarWidth;
      },

      getScrollInfo: function (within) {
        var overflowX = within.isWindow || within.isDocument ? '' : within.element.css('overflow-x');
        var overflowY = within.isWindow || within.isDocument ? '' : within.element.css('overflow-y');
        var hasOverflowX =
          overflowX === 'scroll' ||
          (overflowX === 'auto' && within.width < within.element[0].scrollWidth);
        var hasOverflowY =
          overflowY === 'scroll' ||
          (overflowY === 'auto' && within.height < within.element[0].scrollHeight);

        return {
          width: hasOverflowY ? $.position.scrollbarWidth() : 0,
          height: hasOverflowX ? $.position.scrollbarWidth() : 0
        };
      }
    };

    $.fn.position = function (options) {
      if (!options || !options.of) {
        return _position.apply(this, arguments);
      }

      // Make a copy, we don't want to modify arguments
      options = $.extend({}, options);

      var atOffset;
      var targetWidth;
      var targetHeight;
      var targetOffset;
      var basePosition;
      var dimensions;

      // Make sure string options are treated as CSS selectors
      var target = typeof options.of === 'string' ? $(document).find(options.of) : $(options.of);

      var within = $.position.getWithinInfo(options.within);
      var scrollInfo = $.position.getScrollInfo(within);
      var collision = (options.collision || 'flip').split(' ');
      var offsets = {};

      dimensions = getDimensions(target);
      if (target[0].preventDefault) {
        // Force left top to allow flipping
        options.at = 'left top';
      }
      targetWidth = dimensions.width;
      targetHeight = dimensions.height;
      targetOffset = dimensions.offset;

      // Clone to reuse original targetOffset later
      basePosition = $.extend({}, targetOffset);

      // Force my and at to have valid horizontal and vertical positions
      // if a value is missing or invalid, it will be converted to center
      $.each(['my', 'at'], function () {
        var pos = (options[this] || '').split(' ');
        var horizontalOffset;
        var verticalOffset;

        if (pos.length === 1) {
          pos = rhorizontal.test(pos[0])
            ? pos.concat(['center'])
            : rvertical.test(pos[0])
            ? ['center'].concat(pos)
            : ['center', 'center'];
        }
        pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center';
        pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center';

        // Calculate offsets
        horizontalOffset = roffset.exec(pos[0]);
        verticalOffset = roffset.exec(pos[1]);
        offsets[this] = [
          horizontalOffset ? horizontalOffset[0] : 0,
          verticalOffset ? verticalOffset[0] : 0
        ];

        // Reduce to just the positions without the offsets
        options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];
      });

      // Normalize collision option
      if (collision.length === 1) {
        collision[1] = collision[0];
      }

      if (options.at[0] === 'right') {
        basePosition.left += targetWidth;
      } else if (options.at[0] === 'center') {
        basePosition.left += targetWidth / 2;
      }

      if (options.at[1] === 'bottom') {
        basePosition.top += targetHeight;
      } else if (options.at[1] === 'center') {
        basePosition.top += targetHeight / 2;
      }

      atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
      basePosition.left += atOffset[0];
      basePosition.top += atOffset[1];

      return this.each(function () {
        var collisionPosition;
        var using;
        var elem = $(this);
        var elemWidth = elem.outerWidth();
        var elemHeight = elem.outerHeight();
        var marginLeft = parseCss(this, 'marginLeft');
        var marginTop = parseCss(this, 'marginTop');
        var collisionWidth =
          elemWidth + marginLeft + parseCss(this, 'marginRight') + scrollInfo.width;
        var collisionHeight =
          elemHeight + marginTop + parseCss(this, 'marginBottom') + scrollInfo.height;
        var position = $.extend({}, basePosition);
        var myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

        if (options.my[0] === 'right') {
          position.left -= elemWidth;
        } else if (options.my[0] === 'center') {
          position.left -= elemWidth / 2;
        }

        if (options.my[1] === 'bottom') {
          position.top -= elemHeight;
        } else if (options.my[1] === 'center') {
          position.top -= elemHeight / 2;
        }

        position.left += myOffset[0];
        position.top += myOffset[1];

        collisionPosition = {
          marginLeft: marginLeft,
          marginTop: marginTop
        };

        $.each(['left', 'top'], function (i, dir) {
          if ($.ui.position[collision[i]]) {
            $.ui.position[collision[i]][dir](position, {
              targetWidth: targetWidth,
              targetHeight: targetHeight,
              elemWidth: elemWidth,
              elemHeight: elemHeight,
              collisionPosition: collisionPosition,
              collisionWidth: collisionWidth,
              collisionHeight: collisionHeight,
              offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
              my: options.my,
              at: options.at,
              within: within,
              elem: elem
            });
          }
        });

        // JET-56620: normalize position left/top to integer values to avoid unnecessary
        // repositioning caused by potential floating number oscillations
        position.left = Math.round(position.left);
        position.top = Math.round(position.top);

        if (options.using) {
          // Adds feedback as second argument to using callback, if present
          using = function (props) {
            var left = targetOffset.left - position.left;
            var right = left + targetWidth - elemWidth;
            var top = targetOffset.top - position.top;
            var bottom = top + targetHeight - elemHeight;
            var feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight
              },
              horizontal: right < 0 ? 'left' : left > 0 ? 'right' : 'center',
              vertical: bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle'
            };
            if (targetWidth < elemWidth && Math.abs(left + right) < targetWidth) {
              feedback.horizontal = 'center';
            }
            if (targetHeight < elemHeight && Math.abs(top + bottom) < targetHeight) {
              feedback.vertical = 'middle';
            }
            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
              feedback.important = 'horizontal';
            } else {
              feedback.important = 'vertical';
            }
            options.using.call(this, props, feedback);
          };
        }

        elem.offset($.extend(position, { using: using }));
      });
    };

    /**
     * Forked the jquery UI "flip" position collision rule in version 1.11.4.
     * The jquery version doesn't consider the best fit in terms of
     * top/bottom. The rule favors top when there is no fit versus choosing the
     * best fit, lesser of two evils. The new JET spin of this rule will pick
     * the better fit versus favoring top when there is no fit.
     *
     * Outside of making the code closure compiler friendly, there is only
     * a single line difference.  It's noted with a bug number.
     * @private
     */
    var _origLeftFlipCollisionRule = $.ui.position.flip.left; // stash away the original left flip rule

    /**
     * @ojtsignore
     */
    $.ui.position.flip = {
      left: _origLeftFlipCollisionRule.bind(this),
      /**
       * @param {{top: number, left: number}} position
       * @param {{targetWidth: number,
       *         targetHeight: number,
       *         elemWidth: number,
       *         elemHeight: number,
       *         collisionPosition: {marginLeft: number, marginTop: number},
       *         collisionWidth: number,
       *         collisionHeight: number,
       *         offset: Array.<number>,
       *         my: Array.<string>,
       *         at: Array.<string>,
       *         within: {element: jQuery, isWindow: boolean, isDocument: boolean, offset: {left: number, top: number}, scrollLeft: number, scrollTop: number, width: number, height: number},
       *         elem: jQuery
       *        }} data
       * @returns {undefined}
       */
      top: function (position, data) {
        var within = data.within;
        var withinOffset = within.offset.top + within.scrollTop;
        var outerHeight = within.height;
        var offsetTop = within.isWindow ? within.scrollTop : within.offset.top;
        var collisionPosTop = position.top - data.collisionPosition.marginTop;
        var overTop = collisionPosTop - offsetTop;
        var overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop;
        var top = data.my[1] === 'top';

        var myOffset;
        if (top) {
          myOffset = -data.elemHeight;
        } else if (data.my[1] === 'bottom') {
          myOffset = data.elemHeight;
        } else {
          myOffset = 0;
        }

        var atOffset;
        if (data.at[1] === 'top') {
          atOffset = data.targetHeight;
        } else if (data.at[1] === 'bottom') {
          atOffset = -data.targetHeight;
        } else {
          atOffset = 0;
        }

        var offset = -2 * data.offset[1];
        var newOverBottom;
        var newOverTop;
        if (overTop < 0) {
          newOverBottom =
            position.top +
            myOffset +
            atOffset +
            offset +
            data.collisionHeight -
            outerHeight -
            withinOffset;
          if (newOverBottom < 0 || newOverBottom < Math.abs(overTop)) {
            //  - only flip up if there is more "over" on top than bottom
            if (overBottom < 0 && overTop > overBottom) {
              // eslint-disable-next-line no-param-reassign
              position.top += myOffset + atOffset + offset;
            }
          }
        } else if (overBottom > 0) {
          newOverTop =
            position.top -
            data.collisionPosition.marginTop +
            myOffset +
            atOffset +
            offset -
            offsetTop;
          if (newOverTop > 0 || Math.abs(newOverTop) < overBottom) {
            // eslint-disable-next-line no-param-reassign
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    };

    /**
     * Forked the jquery UI "fit" position collision rule.
     * The jquery version can return negative left and top positions. This
     * is a problem because the page cannot be scrolled to negative
     * coordinates and parts of the popup may not be accessible.
     *
     * Outside of making the code closure compiler friendly, the only
     * difference is the test whether the returned position is negative.
     * If so, it is set to 0 to make the popup "fit" in the page.
     */

    /**
     * @ojtsignore
     */
    $.ui.position.fit = {
      left: function (position, data) {
        var within = data.within;
        var withinOffset = within.isWindow ? within.scrollLeft : within.offset.left;
        var outerWidth = within.width;
        var collisionPosLeft = position.left - data.collisionPosition.marginLeft;
        var overLeft = withinOffset - collisionPosLeft;
        var overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset;
        var newOverRight;

        // Element is wider than within
        if (data.collisionWidth > outerWidth) {
          // Element is initially over the left side of within
          if (overLeft > 0 && overRight <= 0) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;

            // Element is initially over right side of within
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset;

            // Element is initially over both left and right sides of within
          } else {
            // eslint-disable-next-line no-lonely-if
            if (overLeft > overRight) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }

          // Too far left -> align with left edge
        } else if (overLeft > 0) {
          position.left += overLeft;

          // Too far right -> align with right edge
        } else if (overRight > 0) {
          position.left -= overRight;

          // Adjust based on position and margin
        } else {
          position.left = Math.max(position.left - collisionPosLeft, position.left);
        }

        // JET-43962: Do not allow left position to be < 0
        if (position.left < 0) {
          position.left = 0;
        }
      },

      top: function (position, data) {
        var within = data.within;
        var withinOffset = within.isWindow ? within.scrollTop : within.offset.top;
        var outerHeight = data.within.height;
        var collisionPosTop = position.top - data.collisionPosition.marginTop;
        var overTop = withinOffset - collisionPosTop;
        var overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset;
        var newOverBottom;

        // Element is taller than within
        if (data.collisionHeight > outerHeight) {
          // Element is initially over the top of within
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom =
              position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;

            // Element is initially over bottom of within
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset;

            // Element is initially over both top and bottom of within
          } else {
            // eslint-disable-next-line no-lonely-if
            if (overTop > overBottom) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }

          // Too far up -> align with top
        } else if (overTop > 0) {
          position.top += overTop;

          // Too far down -> align with bottom edge
        } else if (overBottom > 0) {
          position.top -= overBottom;

          // Adjust based on position and margin
        } else {
          position.top = Math.max(position.top - collisionPosTop, position.top);
        }

        // JET-43962: Do not allow top position to be < 0
        if (position.top < 0) {
          position.top = 0;
        }
      }
    };

    /**
     * Custom jquery UI position collision rule that will first apply the "flip" rule and follow with "center" alignment.
     * @ojtsignore
     */
    $.ui.position.flipcenter = {
      /**
       * @param {{top: number, left: number}} position
       * @param {{targetWidth: number,
       *         targetHeight: number,
       *         elemWidth: number,
       *         elemHeight: number,
       *         collisionPosition: {marginLeft: number, marginTop: number},
       *         collisionWidth: number,
       *         collisionHeight: number,
       *         offset: Array.<number>,
       *         my: Array.<string>,
       *         at: Array.<string>,
       *         within: {element: jQuery, isWindow: boolean, isDocument: boolean, offset: {left: number, top: number}, scrollLeft: number, scrollTop: number, width: number, height: number},
       *         elem: jQuery
       *        }} data
       * @returns {undefined}
       */
      left: function (position, data) {
        // stash away the initial position calculated from the at alignment
        var posLeft = position.left;

        // call on the flip rule
        $.ui.position.flip.left.call(this, position, data);

        // These calcs were taken from the "fit" rule.
        var within = data.within;
        var withinOffset = within.isWindow ? within.scrollLeft : within.offset.left;
        var outerWidth = within.width;
        var collisionPosLeft = position.left - data.collisionPosition.marginLeft;
        var overLeft = withinOffset - collisionPosLeft;
        var overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset;

        // if popup is not within, center align it
        if (overLeft > 0 || overRight > 0) {
          // find the center of the target element
          if (data.at[0] === 'right') {
            posLeft -= data.targetWidth / 2;
          } else if (data.at[0] === 'left') {
            posLeft += data.targetWidth / 2;
          }

          var isRTL = DomUtils.getReadingDirection() === 'rtl';
          var dirFactor = isRTL ? -1 : 1;

          // factor in half the width of the popup
          posLeft -= dirFactor * (data.elemWidth / 2);

          // JET-53426: need to check if the popup element fits the screen after centering
          // otherwise it could cause text reflow and popup resize which might result
          // in another positioning cycle with a potential endless loop.
          // If the element does not fit, apply the 'fit' collision to avoid the resize.
          if (posLeft < withinOffset || posLeft + data.elemWidth > outerWidth - withinOffset) {
            $.ui.position.fit.left.call(this, position, data);
            posLeft = position.left;
          }

          // Force the popup start to be within the viewport.
          // This collision rule is only used by input components internally. The notewindow will auto dismiss when
          // what it is aligned to is hidden in a scroll container.
          // eslint-disable-next-line no-param-reassign
          position.left = Math.max(0, posLeft);
        }
      },

      /**
       * @param {{top: number, left: number}} position
       * @param {{targetWidth: number,
       *         targetHeight: number,
       *         elemWidth: number,
       *         elemHeight: number,
       *         collisionPosition: {marginLeft: number, marginTop: number},
       *         collisionWidth: number,
       *         collisionHeight: number,
       *         offset: Array.<number>,
       *         my: Array.<string>,
       *         at: Array.<string>,
       *         within: {element: jQuery, isWindow: boolean, isDocument: boolean, offset: {left: number, top: number}, scrollLeft: number, scrollTop: number, width: number, height: number},
       *         elem: jQuery
       *        }} data
       * @returns {undefined}
       */
      top: function (position, data) {
        // stash away the initial position calculated from the at alignment
        var posTop = position.top;

        $.ui.position.flip.top.call(this, position, data);

        // These calcs were taken from the "fit" rule.
        var within = data.within;
        var withinOffset = within.isWindow ? within.scrollTop : within.offset.top;
        var outerHeight = data.within.height;
        var collisionPosTop = position.top - data.collisionPosition.marginTop;
        var overTop = withinOffset - collisionPosTop;
        var overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset;

        if (overTop > 0 || overBottom > 0) {
          // find the center of the target element
          if (data.at[1] === 'top') {
            posTop += data.targetHeight / 2;
          } else if (data.at[1] === 'bottom') {
            posTop -= data.targetHeight / 2;
          }

          // factor in half the height of the popup
          posTop += data.elemHeight / 2;

          // Force the popup top to be within the viewport.
          // This collision rule is only used by input components internally. The notewindow will auto dismiss when
          // what it is aligned to is hidden in a scroll container.
          // eslint-disable-next-line no-param-reassign
          position.top = Math.max(0, posTop);
        }
      }
    };
  })();

  /**
   * Utility for handling popup voice over messages sent to a aria live region.
   * @extends {oj.Object}
   * @public
   * @constructor
   * @since 1.1
   * @class PopupLiveRegion
   * @ignore
   * @ojtsignore
   */
  const PopupLiveRegion = function () {
    this.Init();
  };
  oj._registerLegacyNamespaceProp('PopupLiveRegion', PopupLiveRegion);

  oj.Object.createSubclass(PopupLiveRegion, oj.Object, 'oj.PopupLiveRegion');

  /**
   * Adds one to the reference counter instance.
   * @override
   * @instance
   * @protected
   */
  PopupLiveRegion.prototype.Init = function () {
    PopupLiveRegion.superclass.Init.call(this);
    if (isNaN(PopupLiveRegion._refCounter)) {
      PopupLiveRegion._refCounter = 1;
    } else {
      PopupLiveRegion._refCounter += 1;
    }
  };

  /**
   * Decrements the reference counter destroying the assocaited shared DOM aria
   * live region element when there are no longer any popups using it.
   * @instance
   * @public
   */
  PopupLiveRegion.prototype.destroy = function () {
    if (!isNaN(PopupLiveRegion._refCounter)) {
      PopupLiveRegion._refCounter -= 1;
      if (PopupLiveRegion._refCounter < 1) {
        var liveRegion = $(document.getElementById(PopupLiveRegion._POPUP_LIVE_REGION_ID));
        if (liveRegion.length > 0) {
          liveRegion.remove();
        }
      }
    }
  };

  /**
   * Sends a message to the aria live region for voice over mode.
   * @instance
   * @public
   * @param {string} message to be announce in the live region
   */
  PopupLiveRegion.prototype.announce = function (message) {
    if (!oj.StringUtils.isEmpty(message)) {
      var liveRegion = PopupLiveRegion._getLiveRegion();
      liveRegion.children().remove();
      // JET-39406: Chrome does not read out messages inside aria-live.
      // This inconsistency happenes may be due to the container is not getting add to the DOM long enough before the contents are changed
      // After discuss with acc team, we decide to put a setTimeout here to resolve the issue. 20ms is the minimum delay time to make Chrome JAWS read out the content.
      // We will need to revisit if the bug is not resolved on user side.
      // JET-46575: Update: the 20ms delay turned out to be too short in specific real-case scenarios. Increasing the delay to 250ms to give Chrome JAWS
      // a chance to pick up the live region change.
      setTimeout(function () {
        $('<div>').text(message).appendTo(liveRegion); // @HTMLUpdateOK the "messsage" comes from a
      }, 250);
      // translated string that can be overridden by
      // an option on the ojPopup.  The jquery "text"
      // function will escape script.
    }
  };

  /**
   * Creates or returns an existing aria live region used by popups.
   * @returns {jQuery} aria live region
   * @private
   */
  PopupLiveRegion._getLiveRegion = function () {
    var liveRegion = $(document.getElementById(PopupLiveRegion._POPUP_LIVE_REGION_ID));
    if (liveRegion.length === 0) {
      liveRegion = $('<div>');
      liveRegion.attr({
        id: PopupLiveRegion._POPUP_LIVE_REGION_ID,
        role: 'log',
        'aria-live': 'polite',
        'aria-relevant': 'additions'
      });
      liveRegion.addClass('oj-helper-hidden-accessible');
      liveRegion.appendTo(document.body); // @HTMLUpdateOK
    }
    return liveRegion;
  };

  /**
   * Id assigned to the popup aria live region dom element.
   * @const
   * @private
   * @type {string}
   */
  PopupLiveRegion._POPUP_LIVE_REGION_ID = '__oj_popup_arialiveregion';

  /**
   * Utility that injects a hidden link relative to another for voice support
   * @class PopupSkipLink
   * @extends {oj.Object}
   * @public
   * @constructor
   * @since 1.1
   * @ignore
   * @param {jQuery} sibling element to the new skip link element
   * @param {string} message text assigned to the skip link
   * @param {function(!Event)} callback fired for activation of the skip link
   * @param {string=} id assigned to the skiplink component
   * @param {{insertBefore:boolean, preventKeyEvents: boolean}=} options overrides default behaviors
   * @ojtsignore
   */
  const PopupSkipLink = function (sibling, message, callback, id, options) {
    oj.Assert.assertPrototype(sibling, $);
    oj.Assert.assertString(message);
    oj.Assert.assertFunction(callback);
    oj.Assert.assertStringOrNull(id);

    this._options = { insertBefore: false, preventKeyEvents: true };
    if (options) {
      this._options = Object.assign({}, this._options, options);
    }

    this._sibling = sibling;
    this._message = message;
    this._callback = callback;
    this._id = id;
    this.Init();
  };
  oj._registerLegacyNamespaceProp('PopupSkipLink', PopupSkipLink);

  oj.Object.createSubclass(PopupSkipLink, oj.Object, 'oj.PopupSkipLink');

  /**
   * Creates an invisible anchor relative to the sibling and hooks up the activation callack.
   * @override
   * @instance
   * @protected
   */
  PopupSkipLink.prototype.Init = function () {
    PopupSkipLink.superclass.Init.call(this);
    var sibling = this._sibling;
    var callback = this._callback;
    var message = this._message;
    var insertBefore = this._options.insertBefore;
    var preventKeyEvents = this._options.preventKeyEvents;
    this._message = null;
    var id = this._id;
    this._id = null;

    var link = $(document.getElementById(id));
    if (link.length < 1) {
      link = $('<a>').attr({ tabindex: '-1', href: '#', role: 'link' });
    }
    link.attr('id', id);
    link.addClass('oj-helper-hidden-accessible');
    link.text(message);
    if (!insertBefore) {
      link.insertAfter(sibling); // @HTMLUpdateOK
    } else {
      link.insertBefore(sibling); // @HTMLUpdateOK
    }

    link.on('click', PopupSkipLink._activateHandler.bind(this, callback));

    if (preventKeyEvents) {
      // This could only happen in some kind of simulator as this skip link is only used on the iOS
      // platform. Prevent click generated from an "enter" key press by eating the event.
      link.on('keydown keyup keypress', PopupSkipLink._keyHandler);
    }

    sibling[0][PopupSkipLink._SKIPLINK_ATTR] = link;
  };

  /**
   * Handles activation of the skiplink.  Cancels the click event.
   * @private
   * @param {?} listener
   * @param {Event} event
   */
  PopupSkipLink._activateHandler = function (listener, event) {
    ZOrderUtils.eatEvent(event);
    window.setImmediate(listener);
  };

  /**
   * Listener registered on the skip link element to prevent an enter key from generating a click
   * @private
   * @param {jQuery.Event|Event} event
   */
  PopupSkipLink._keyHandler = function (event) {
    if (event.keyCode === $.ui.keyCode.ENTER) {
      ZOrderUtils.eatEvent(event);
    }
  };

  /**
   * Removes the voice over skip link.
   * @instance
   * @public
   */
  PopupSkipLink.prototype.destroy = function () {
    var sibling = this._sibling;
    delete this._sibling;
    delete this._callback;

    if (sibling) {
      var link = sibling[0][PopupSkipLink._SKIPLINK_ATTR];
      delete sibling[0][PopupSkipLink._SKIPLINK_ATTR];
      if (link) {
        link.off('click keydown keyup keypress');
        link.remove();
      }
    }
  };

  /**
   * Returns the skip link jQuery element.
   * @instance
   * @public
   * @return {jQuery} skip link
   */
  PopupSkipLink.prototype.getLink = function () {
    /** @type {?} */
    var sibling = this._sibling;
    /** @type {jQuery} */
    var link;
    if (sibling) {
      link = sibling[0][PopupSkipLink._SKIPLINK_ATTR];
    }
    return link;
  };

  /**
   * Data attribute name assigned to the sibling element that tracks a
   * reference for the associated skip link.
   * @const
   * @private
   * @type {Symbol}
   */
  PopupSkipLink._SKIPLINK_ATTR = Symbol('ojSkipLink');

  /**
   * Coordinate communications between an event being fulfilled and one or more promises
   * being resolved.  The window of time between the instance creation and the associated event
   * triggered is guarded by the {@link oj.BusyContext}.  The
   * @link{PopupWhenReadyMediator#getWhenReadyPromise} promise will resolve when either the
   * target event is triggered or instance destroyed.
   * @class PopupWhenReadyMediator
   * @extends {oj.Object}
   * @constructor
   * @since 3.0.0
   * @ignore
   * @param {jQuery} element to subscribe on the event type triggered on completion of the operation
   * @param {string} operation that completion will resolve one or more promises
   * @param {string} widgetName component constructor
   * @param {boolean} isCustomElement <code>true</code> if the widget is created as a custom element
   * @ojtsignore
   */
  const PopupWhenReadyMediator = function (element, operation, widgetName, isCustomElement) {
    this._element = element;
    this._operation = operation;
    this._widgetName = widgetName;
    this._isCustomElement = !!isCustomElement;

    this.Init();
  };
  oj._registerLegacyNamespaceProp('PopupWhenReadyMediator', PopupWhenReadyMediator);

  oj.Object.createSubclass(PopupWhenReadyMediator, oj.Object, 'oj.PopupWhenReadyMediator');

  /**
   * Registers an event handler on the element associated with the target operation.
   * The event handler will resolve one or more pending promises.  The convention
   * is the operation will raise a "oj" + operation event upon completion. The
   * event hander is one and done - unregistered after first delivery.
   *
   * @override
   * @instance
   * @protected
   */
  PopupWhenReadyMediator.prototype.Init = function () {
    PopupWhenReadyMediator.superclass.Init.call(this);
    this._resolvedQueue = [];
    this._callback = this._eventHandler.bind(this);

    var operation = this._operation;
    var tokens = ['oj'];
    if (this._isCustomElement) {
      tokens.push(operation.charAt(0).toUpperCase());
      tokens.push(operation.slice(1));
    } else {
      tokens.push(operation);
    }

    var eventType = tokens.join('');
    this._eventType = eventType;
    this._element.on(eventType, this._callback);

    // Add a busy state for the pending operation.  The busy state resolver will
    // be invoked when the resolved queue is delivered (operation completes).
    var busyContext = Context.getContext(this._element[0]).getBusyContext();
    var options = {
      description: this._getBusyStateDescription.bind(
        this,
        this._element,
        this._operation,
        this._widgetName
      )
    };
    var resolve = busyContext.addBusyState(options);
    this.AddPromiseExecutor(resolve);

    // setup the when ready promise
    this._whenReadyPromise = new Promise(this.AddPromiseExecutor.bind(this));
  };

  /**
   * @private
   * @param {jQuery} element to subscribe on the event type triggered on completion of the operation
   * @param {string} operation that completion will resolve one or more promises
   * @param {string} widgetName component constructor
   * @returns {string} description of the busy state animation operation.
   */
  PopupWhenReadyMediator.prototype._getBusyStateDescription = function (
    element,
    operation,
    widgetName
  ) {
    return (
      widgetName +
      " identified by '" +
      element.attr('id') +
      "' is busy animating on " +
      "the '" +
      operation +
      "' operation."
    );
  };

  /**
   * Resolves the pending promises.
   *
   * @private
   * @param {string=} operation override sent to the resolverdQueue
   */
  PopupWhenReadyMediator.prototype._deliverResolved = function (operation) {
    // Critical section - the registered resolve queue is disconnect from the
    // instance state so that a race condition will not occur - resolve promoise
    // adding new operations to the same queue.

    var resolvedQueue = this._resolvedQueue;
    this._resolvedQueue = null;

    var _operation = !operation ? this._operation : operation;
    this._operation = null;

    for (var i = 0; i < resolvedQueue.length; i++) {
      try {
        resolvedQueue[i](_operation);
      } catch (e) {
        Logger.error('Error resolving whenReady promises:\n%o', e);
      }
    }

    this._whenReadyPromise = Promise.resolve('none');
  };

  /**
   * Force delivery of unresolved promises.
   */
  PopupWhenReadyMediator.prototype.destroy = function () {
    // If the promise is swapped (component is destroyed)
    // before the event is fired, resolve with a "none" operation.
    if (this._resolvedQueue) {
      this._deliverResolved('none');
    }

    if (this._callback) {
      var eventType = this._eventType;
      this._element.off(eventType, this._callback);
    }

    this._callback = null;
    this._element = null;
    this._operation = null;
    this._whenReadyPromise = null;
    this._widgetName = null;
    this._eventType = null;
  };

  /**
   * @returns {Promise} returns an instance of the current whenReadyPromise
   */
  PopupWhenReadyMediator.prototype.getWhenReadyPromise = function () {
    return this._whenReadyPromise;
  };

  /**
   * Event handler associated with completion of the target operation.
   * @private
   * @param {jQuery.Event} event
   */
  PopupWhenReadyMediator.prototype._eventHandler = function (event) {
    if (event.target === this._element[0]) {
      this._element.off(event.type, this._callback);
      this._deliverResolved();
      this._callback = null;
    }
  };

  /**
   * @private
   * @return {string} Returns the pending operation
   */
  PopupWhenReadyMediator.prototype._getPendingOperation = function () {
    return this._operation ? this._operation : 'none';
  };

  /**
   * A function that will be passed to other functions via the arguments resolve and reject.
   * The resolve function will be invoked when the event associated with completion of the
   * target operation is delivered to the target element.
   *
   * @protected
   * @param {Function} resolve resultant function that will resovle a promise executor
   * @param {Function=} reject (not interested in the reject)
   */
  // eslint-disable-next-line no-unused-vars
  PopupWhenReadyMediator.prototype.AddPromiseExecutor = function (resolve, reject) {
    if (this._resolvedQueue) {
      this._resolvedQueue.push(resolve);
    }
  };

  /**
   * Checks to see if there is a pending "open" or "close" operation.  If pending and it
   * is the same as the requested operation, the request silently fails.  If the current
   * operation is the inverse operation, we queue the current operation after the pending
   * operation is resolved.
   *
   * @param {Object} widgetInstance this mediator is negotiating on behalf of
   * @param {string} operation currently requested
   * @param {string} methodName that should be invoked on the widgetInstance if the operation is the
   *                 inverse of the pending operation
   * @param {Array} methodArgs passed to a queue method invocation
   * @returns {boolean} <code>true</code> if a "close" or "open" operation is pending completion.
   */
  PopupWhenReadyMediator.prototype.isOperationPending = function (
    widgetInstance,
    operation,
    methodName,
    methodArgs
  ) {
    var isPending = false;
    var widgetName = this._widgetName;
    var pendingOperation = this._getPendingOperation();
    if (operation === pendingOperation) {
      // Same request is already pending. Silently fail.
      Logger.info(
        "An %s instance invoked a '%s' operation while pending animation of " +
          'the same type of operation.  The second request will be ignored.',
        widgetName,
        operation
      );
      isPending = true;
    } else if (pendingOperation !== 'none') {
      Logger.info(
        "An %s instance invoked a '%s' operation while pending animation of a " +
          "'%s' operation. The second request will be invoked after the pending operation " +
          'completes.',
        widgetName,
        operation,
        pendingOperation
      );

      // Queue the operation after the pending operation has completed
      // register another resolve promise with the mediator that will be
      // call when the pending operation finishes.
      var promise = new Promise(this.AddPromiseExecutor.bind(this));
      promise.then(
        function () {
          this[methodName].apply(this, methodArgs);
        }.bind(widgetInstance)
      );
      isPending = true;
    }
    return isPending;
  };

  /**
   * Component that encapsulates the PopupService to open a popup when the
   * VPopup is rendered and close a popup when the VPopup is removed.
   * The content passed into the VPopup by a parent is the popup content.
   * NOTE: The popup content must be single rooted and cannot change node type,
   * meaning the popup content cannot change from a div to a span on
   * subsequent renders, but the div content and div properties can change.
   */
  class VPopup extends preact.Component {
      constructor() {
          super(...arguments);
          this._setRootRef = (element) => {
              this._rootRef = element;
          };
      }
      render(props) {
          return (jsxRuntime.jsx("div", { style: { display: 'none' }, ref: this._setRootRef, children: props.children }));
      }
      componentDidMount() {
          // The PopupService expects jQuery objects.
          // TODO Move jQuery logic to inside PopupService and have it wrap DOM nodes
          this._popup = $(this._rootRef.firstChild);
          // Using @type to provide type checking for this internal type
          // TODO remove when we figure out how to expose internal only type declarations
          /** @type {!Object.<PopupService.OPTION, ?>} */
          const options = {
              [PopupService.OPTION.POPUP]: this._popup,
              [PopupService.OPTION.EVENTS]: {
                  [PopupService.EVENT.POPUP_AUTODISMISS]: this.props.autoDismiss,
                  [PopupService.EVENT.POPUP_REFRESH]: function () {
                      // JET-35914 - dropdown is not being positioned correctly
                      // reposition the popup when refreshed
                      this._popup.position(this._getPosition());
                  }.bind(this)
              },
              [PopupService.OPTION.LAYER_SELECTORS]: this.props.layerSelectors,
              [PopupService.OPTION.CUSTOM_ELEMENT]: true,
              [PopupService.OPTION.LAUNCHER]: $(this._rootRef),
              [PopupService.OPTION.POSITION]: this._getPosition()
          };
          PopupService.getInstance().open(options);
      }
      componentWillUnmount() {
          PopupService.getInstance().close({ [PopupService.OPTION.POPUP]: this._popup });
      }
      componentDidUpdate() {
          // JET-35914 - dropdown is not being positioned correctly
          // reposition the popup after rendering
          this._popup.position(this._getPosition());
      }
      _getPosition() {
          // TODO should PositionUtils.normalizeHorizontalAlignment always be called by the PopupService?
          return PositionUtils.normalizeHorizontalAlignment(this.props.position, DomUtils.getReadingDirection() === 'rtl');
      }
  }
  VPopup.defaultProps = {
      autoDismiss: null,
      layerSelectors: '', // Required PopupService option
      position: {}
  };

  var _a;
  const getUniqueId = ojcustomelementUtils.ElementUtils.getUniqueId.bind(null, null);
  const V_LAYER_HOST_ID_REF = Symbol();
  class VLayerUtils {
  }
  _a = VLayerUtils;
  VLayerUtils._getPopupServiceOptions = (element, launcherElement, level, priority) => {
      // PopupService
      const PSOptions = {};
      const PSoption = PopupService.OPTION;
      PSOptions[PSoption.POPUP] = element;
      PSOptions[PSoption.LAUNCHER] = launcherElement;
      PSOptions[PSoption.LAYER_SELECTORS] =
          priority === 'messages' ? 'oj-messages-layer' : 'oj-popup-layer';
      PSOptions[PSoption.LAYER_LEVEL] = level ?? PopupService.LAYER_LEVEL.NEAREST_ANCESTOR;
      PSOptions[PSoption.CUSTOM_ELEMENT] = false;
      const PSEvent = PopupService.EVENT;
      PSOptions[PSoption.EVENTS] = {
          [PSEvent.POPUP_BEFORE_OPEN]: () => { },
          [PSEvent.POPUP_AFTER_OPEN]: () => { },
          [PSEvent.POPUP_BEFORE_CLOSE]: () => { },
          [PSEvent.POPUP_AFTER_CLOSE]: () => { },
          [PSEvent.POPUP_AUTODISMISS]: () => { },
          [PSEvent.POPUP_REFRESH]: () => {
              _a._refresh(element);
          },
          [PSEvent.POPUP_CLOSE]: () => {
              _a._closeLayerHost(element, launcherElement);
          },
          [PSEvent.POPUP_REMOVE]: () => { }
      };
      return PSOptions;
  };
  VLayerUtils.getLayerHost = (element, level, priority) => {
      const anchorRef = element['anchorRef'];
      let layerHost;
      if (!element[V_LAYER_HOST_ID_REF]) {
          element[V_LAYER_HOST_ID_REF] = `__v_layer_host_${getUniqueId()}`;
      }
      else {
          layerHost = document.getElementById(element[V_LAYER_HOST_ID_REF]);
      }
      if (layerHost) {
          return layerHost;
      }
      let launcherElement;
      if (anchorRef != undefined) {
          launcherElement = anchorRef.current;
      }
      else {
          launcherElement = element;
      }
      return _a._openLayerHost(element[V_LAYER_HOST_ID_REF], launcherElement, level, priority);
  };
  VLayerUtils._openLayerHost = (elementId, launcherElement, level, priority) => {
      if (!elementId)
          return;
      let vpopupCoreElement = document.getElementById(elementId);
      if (!vpopupCoreElement) {
          vpopupCoreElement = document.createElement('div');
          vpopupCoreElement.setAttribute('id', elementId);
          // explicitly specifying a binding provider of 'preact' here otherwise
          // custom elements inside the Layer may walk up the DOM and think that
          // they are in a ko-activated subtree and wait forever for bindings to be applied
          vpopupCoreElement.setAttribute('data-oj-binding-provider', 'preact');
          document.body.appendChild(vpopupCoreElement);
      }
      const popupServiceInstance = PopupService.getInstance();
      const popupServiceOptions = _a._getPopupServiceOptions(vpopupCoreElement, launcherElement, level, priority);
      popupServiceInstance.open(popupServiceOptions);
      return vpopupCoreElement;
  };
  VLayerUtils._closeLayerHost = (element, launcherElement) => {
      if (!element)
          return;
      const popupServiceInstance = PopupService.getInstance();
      const popupServiceOptions = _a._getPopupServiceOptions(element, launcherElement);
      popupServiceInstance.close(popupServiceOptions);
      element.remove();
  };
  VLayerUtils._refresh = (element) => {
      if (!element)
          return;
      PopupService.getInstance().triggerOnDescendents($(element), PopupService.EVENT.POPUP_REFRESH);
  };
  VLayerUtils.onLayerUnmount = (element, layer) => {
      if (!element)
          return;
      const layerHost = document.getElementById(element[V_LAYER_HOST_ID_REF]);
      if (!layerHost)
          return;
      if (layerHost.children.length === 0) {
          delete element[V_LAYER_HOST_ID_REF];
          const popupServiceInstance = PopupService.getInstance();
          const popupServiceOptions = _a._getPopupServiceOptions(layerHost, null);
          popupServiceInstance.close(popupServiceOptions);
          layerHost.remove();
      }
  };
  oj._registerLegacyNamespaceProp('VLayerUtils', VLayerUtils);

  exports.PopupLiveRegion = PopupLiveRegion;
  exports.PopupService = PopupService;
  exports.PopupSkipLink = PopupSkipLink;
  exports.PopupWhenReadyMediator = PopupWhenReadyMediator;
  exports.PositionUtils = PositionUtils;
  exports.VLayerUtils = VLayerUtils;
  exports.VPopup = VPopup;
  exports.ZOrderUtils = ZOrderUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojkeyboardfocus-utils',['exports', 'jquery', 'ojs/ojcore-base', 'ojs/ojpopupcore', 'ojs/ojdomutils'], function (exports, $, oj, ojpopupcore, DomUtils) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @private
   */
  const _ARIA_READONLY = 'aria-readonly';

  /**
   * @private
   */
  const _DATA_OJ_TABMOD = 'data-oj-tabmod';

  /**
   * @private
   */
  const _DATA_OJ_ARIA_READONLY_MOD = 'data-oj-ariareadonlymod';

  /**
   * @private
   */
  const _FOCUSABLE_ELEMENTS_QUERY =
    'input, select, button, a[href], textarea, object, [tabIndex]:not([tabIndex="-1"]), [tabindex]:not([tabindex="-1"])';
  /**
   * @private
   */
  const _ACTIONABLE_ELEMENTS_QUERY = '[' + _DATA_OJ_TABMOD + '], ' + _FOCUSABLE_ELEMENTS_QUERY;

  /** ******************* focusable/editable element related methods *****************/

  /**
   * Check if the specified element is visible
   * @param {Element} element
   * @ignore
   * @export
   */
  const checkVisibility = function (element) {
    return !(
      element.offsetHeight === 0 ||
      element.offsetWidth === 0 ||
      window.getComputedStyle(element).visibility === 'hidden'
    );
  };

  /**
   * @export
   * @ignore
   */
  const getActionableElementsInNode = function (element) {
    var actionableElems = [];
    let nodes = element.querySelectorAll(_ACTIONABLE_ELEMENTS_QUERY);
    for (var i = 0; i < nodes.length; i++) {
      var elem = nodes[i];
      if (!elem.disabled && checkVisibility(elem)) {
        actionableElems.push(elem);
      }
    }
    return actionableElems;
  };

  /**
   * @export
   * @ignore
   */
  const isActionableElement = function (node) {
    var parentNode = node.parentNode;
    if (parentNode != null) {
      var nodes = getActionableElementsInNode(parentNode);
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i] === node) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * Finds all the focusable elements in a node
   * @param {Element} node
   * @param {boolean=} skipVisibilityCheck
   * @param {boolean=} includeSelf
   * @return {Element[]} An array of all of the focusable elements in a node
   * @export
   * @ignore
   */
  const getFocusableElementsInNode = function (node, skipVisibilityCheck, includeSelf) {
    var inputElems = [];

    // a nodes without href are not focusable
    var agentInfo = oj.AgentUtils.getAgentInfo();
    var check = true;
    if (oj.AgentUtils.BROWSER.IE === agentInfo.browser) {
      if (node.parentNode == null) {
        check = false;
      }
    }
    if (check) {
      var nodes = [...node.querySelectorAll(_FOCUSABLE_ELEMENTS_QUERY)];
      if (includeSelf && node.matches(_FOCUSABLE_ELEMENTS_QUERY)) {
        nodes.push(node);
      }
      var nodeCount = nodes.length;
      // in IE, each 'option' after 'select' elem will be counted as an input element(and cause duplicate input elems returned)
      // this will cause problem with TAB/Shift-TAB (recognizing whether to go to next cell or to tab within the current cell
      for (var i = 0; i < nodeCount; i++) {
        var elem = nodes[i];
        if (!elem.disabled && (skipVisibilityCheck || checkVisibility(elem))) {
          var tabIndex = elem.tabIndex;
          if (tabIndex >= 0) {
            inputElems.push(elem);
          }
        }
      }
    }
    return inputElems;
  };

  /**
   * Remove the aria-readonly attribute from the specified element
   * @param {Element} element
   * @export
   * @ignore
   */
  const removeAriaReadonly = function (element) {
    var ariaReadonly = element.getAttribute(_ARIA_READONLY);
    // store the aria-readonly value as an attribute
    element.setAttribute(_DATA_OJ_ARIA_READONLY_MOD, ariaReadonly); // @HTMLUpdateOK
    element.removeAttribute(_ARIA_READONLY);
  };

  /**
   * Make the specified element unfocusable
   * @param {Element} element
   * @export
   * @ignore
   */
  const disableElement = function (element) {
    var tabIndex = element.tabIndex;
    // store the tabindex as an attribute
    element.setAttribute(_DATA_OJ_TABMOD, tabIndex); // @HTMLUpdateOK
    // eslint-disable-next-line no-param-reassign
    element.tabIndex = -1;
  };

  /**
   * Make all focusable elements within the specified element unfocusable
   * @param {Element} element
   * @param {boolean=} excludeActiveElement
   * @param {boolean=} includeReadonly
   * @param {boolean=} includeSelf
   * @param {Element[]} dialogs An array of the dialog elements
   * @return {Element[]} An array of the disabled elements
   * @export
   * @ignore
   */
  const disableAllFocusableElements = function (
    element,
    excludeActiveElement,
    includeReadonly,
    includeSelf,
    dialogs
  ) {
    var disabledElems = [];
    // make all focusable elements non-focusable, since we want to manage tab stops
    var focusElems = getFocusableElementsInNode(element, true, includeSelf);
    for (var i = 0; i < focusElems.length; i++) {
      const elem = focusElems[i];
      const isInsideDialog = Array.from(dialogs || []).find((dialog) => dialog.contains(elem));
      if (isInsideDialog === undefined) {
        if (!excludeActiveElement || focusElems[i] !== document.activeElement) {
          disableElement(focusElems[i]);
          disabledElems.push(focusElems[i]);
        }
        if (includeReadonly && focusElems[i].hasAttribute(_ARIA_READONLY)) {
          removeAriaReadonly(focusElems[i]);
        }
      }
    }
    return disabledElems;
  };

  /**
   * Enable all focusable elements within the specified element that were previously disabled
   * @param {Element} element
   * @param {boolean=} includeSelf
   * @return {NodeList} An array of the enabled elements
   * @export
   * @ignore
   */
  const enableAllFocusableElements = function (element, includeSelf) {
    // make all non-focusable elements focusable again
    var focusElems = [...element.querySelectorAll('[' + _DATA_OJ_TABMOD + ']')];
    if (includeSelf && element.matches('[' + _DATA_OJ_TABMOD + ']')) {
      focusElems.push(element);
    }
    for (var i = 0; i < focusElems.length; i++) {
      var tabIndex = parseInt(focusElems[i].getAttribute(_DATA_OJ_TABMOD), 10);
      focusElems[i].removeAttribute(_DATA_OJ_TABMOD);
      // restore tabIndex
      focusElems[i].tabIndex = tabIndex;
      if (focusElems[i].hasAttribute(_DATA_OJ_ARIA_READONLY_MOD)) {
        var ariaReadonly = focusElems[i].getAttribute(_DATA_OJ_ARIA_READONLY_MOD);
        focusElems[i].removeAttribute(_DATA_OJ_ARIA_READONLY_MOD);
        focusElems[i].setAttribute(_ARIA_READONLY, ariaReadonly); // @HTMLUpdateOK
      }
    }
    return focusElems;
  };

  /**
   * Components that open popups (such as ojSelect, ojCombobox, ojInputDate, etc.) will trigger
   * focusout, but components don't want to exit actionable/edit mode in those cases.
   * This method should be used inside the component's focusout handler.
   * @param elem the component element
   * @return the logical popup element if one has been launched from within the component, null otherwise.
   * @ignore
   */
  const getLogicalChildPopup = function (componentElement) {
    var popups = ojpopupcore.ZOrderUtils.findOpenPopups();
    for (var i = 0; i < popups.length; i++) {
      // Get the launcher of the popup.
      // popups[i] is just a wrapper with the real popup as its child.
      var popupElem = popups[i].firstElementChild;
      var launcher = DomUtils.getLogicalParent($(popupElem));

      // Check if the component contains the launcher
      if (launcher != null && $(componentElement).has(launcher.get(0)).length > 0) {
        // only return the popup if the child popup is currently open
        if (ojpopupcore.ZOrderUtils.getStatus(popupElem) === ojpopupcore.ZOrderUtils.STATUS.OPEN) {
          return popupElem;
        }
      }
    }
    return null;
  };

  /**
   * Components that open popups (such as ojSelect, ojCombobox, ojInputDate, etc.) will trigger
   * focusout, but components don't want to exit actionable/edit mode in those cases.
   * This method should be used inside the component's focusout handler.
   * @param elem the component element
   * @return an array of logical popup elements if any have been launched from within the component
   * or from within any of those popups launched from within the component.
   * @ignore
   */
  const getAllLogicalChildPopups = function (componentElement) {
    var allPopups = {
      popups: ojpopupcore.ZOrderUtils.findOpenPopups()
    };

    var _getLogicalChildPopups = function (parentElement) {
      var i;
      var childPopups = [];
      for (i = 0; i < allPopups.popups.length; i++) {
        // Get the launcher of the popup.
        // popups[i] is just a wrapper with the real popup as its child.
        var popupElem = allPopups.popups[i].firstElementChild;
        var launcher = DomUtils.getLogicalParent($(popupElem));

        // Check if the parent contains the launcher
        if (launcher != null && $(parentElement).has(launcher.get(0)).length > 0) {
          childPopups.push(popupElem);
        }
      }
      return { popups: childPopups };
    };

    var allLogicalChildPopups = _getLogicalChildPopups(componentElement);

    var _addChildPopups = function (popupElement) {
      var popupsObj = _getLogicalChildPopups(popupElement);
      for (let j = 0; j < popupsObj.popups.length; j++) {
        if (allLogicalChildPopups.popups.indexOf(popupsObj.popups[j]) === -1) {
          allLogicalChildPopups.popups.push(popupsObj.popups[j]);
        }
      }
    };

    var i;
    var popupCheckIndex = 0;
    while (popupCheckIndex < allLogicalChildPopups.popups.length) {
      for (i = popupCheckIndex; i < allLogicalChildPopups.popups.length; i++) {
        _addChildPopups(allLogicalChildPopups.popups[i]);
      }
      popupCheckIndex = i;
    }

    // return total array of all logical child popups (vDom included)
    return allLogicalChildPopups.popups;
  };

  exports.checkVisibility = checkVisibility;
  exports.disableAllFocusableElements = disableAllFocusableElements;
  exports.disableElement = disableElement;
  exports.enableAllFocusableElements = enableAllFocusableElements;
  exports.getActionableElementsInNode = getActionableElementsInNode;
  exports.getAllLogicalChildPopups = getAllLogicalChildPopups;
  exports.getFocusableElementsInNode = getFocusableElementsInNode;
  exports.getLogicalChildPopup = getLogicalChildPopup;
  exports.isActionableElement = isActionableElement;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojpreact-managetabstops',['exports', 'preact/jsx-runtime', 'preact', 'preact/hooks', '@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode', 'ojs/ojkeyboardfocus-utils'], function (exports, jsxRuntime, preact, hooks, UNSAFE_useTabbableMode, ojkeyboardfocusUtils) { 'use strict';

    /**
     * The ManageTabStops component is used to provide tabbable mode for legacy components
     * when they are used inside a template slot of a Preact component.
     * See JET-54400 for details.
     * @ignore
     */
    function ManageTabStops({ children }) {
        let childRef = hooks.useRef(null);
        let isInitialized = hooks.useRef(false);
        const { isTabbable } = UNSAFE_useTabbableMode.useTabbableMode();
        hooks.useEffect(() => {
            let observer;
            if (childRef.current) {
                if (!isInitialized.current || !isTabbable) {
                    // include childRef.current as well as any child elements
                    ojkeyboardfocusUtils.disableAllFocusableElements(childRef.current, false, false, true);
                    isInitialized.current = true;
                }
                if (isTabbable) {
                    // include childRef.current as well as any child elements
                    ojkeyboardfocusUtils.enableAllFocusableElements(childRef.current, true);
                }
                else {
                    observer = new MutationObserver((entries) => {
                        if (!isTabbable && childRef.current?.isConnected) {
                            // The tabindex attribute might be modified multiple times
                            // before the MutationObserver invokes its callback.
                            // Lets accumulate the relevant nodes in a Set and
                            // update them after all entries are processed.
                            const nodesToUpdate = new Set();
                            for (const entry of entries) {
                                const addedNodes = entry.addedNodes;
                                for (let i = 0; i < addedNodes.length; i++) {
                                    if (addedNodes[i].nodeType === 1) {
                                        ojkeyboardfocusUtils.disableAllFocusableElements(addedNodes[i], false, false, true);
                                    }
                                }
                                if (entry.type === 'attributes' && entry.target.tabIndex > -1) {
                                    nodesToUpdate.add(entry.target);
                                }
                            }
                            nodesToUpdate.forEach((entry) => ojkeyboardfocusUtils.disableAllFocusableElements(entry, false, false, true));
                        }
                    });
                    observer.observe(childRef.current, {
                        subtree: true,
                        childList: true,
                        attributeFilter: ['tabindex']
                    });
                }
                return () => {
                    if (observer) {
                        observer.disconnect();
                    }
                };
            }
        }, [isTabbable]);
        // Define refCallback method on a child.
        // The component should only have a single child, since it wraps an element with a specific attribute.
        const childComp = children;
        if (childComp.ref) {
            const origRefCallback = childComp.ref;
            childComp.ref = (el) => {
                childRef.current = el;
                if (typeof origRefCallback === 'function') {
                    origRefCallback(el);
                }
                else {
                    origRefCallback.current = el;
                }
            };
        }
        else {
            childComp.ref = childRef;
        }
        return jsxRuntime.jsx(preact.Fragment, { children: children });
    }

    exports.ManageTabStops = ManageTabStops;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojvcomponent-binding',['exports'], function (exports) { 'use strict';

    /**
     * @ojmodulecontainer ojvcomponent-binding
     * @ojhidden
     * @since 10.0.0
     * @ojtsimport {module: "ojmetadata", type: "AMD", importName:"MetadataTypes"}
     *
     * @classdesc
     * This module contains VComponent property binding decorators.
     * <p>These decorators are designed to be used on VComponent classes when a particular property value
     * has to propagate to descendant components or a particular property value should be received
     * from a parent component, if that property value is provided by the parent.</p>
     * <p>Additional considerations:
     *  <ul>
     *    <li>Property binding decorators are only honored when the VComponent custom element
     *      is used in a Knockout binding environment.</li>
     *    <li>Functional VComponents rely upon the 'options' argument to <code>registerCustomElement</code>
     *      for registering this runtime metadata with the custom element.  See the
     *      <a href='ojvcomponent.html#registerCustomElement'>registerCustomElement</a> API Doc
     *      for additional information.</li>
     *  </ul>
     * </p>
     *
     * <pre class="prettyprint">
     * <code>
     * import { consumedBindings, providedBindings } from "ojs/ojvcomponent-binding";
     * import { customElement, ExtendGlobalProps } from "ojs/ojvcomponent";
     * import { Component } from "preact";
     *
     * type Props = Readonly<{
     *   labelEdge?: 'inside' | 'start' | 'top';
     *   readonly?: boolean;
     * }>;
     *
     * // Indicate that the component's 'labelEdge' and 'readonly' properties will consume
     * // the 'containerLabelEdge' and 'containerReadonly' variable values, respectively,
     * // provided by the parent.
     * &#64;consumedBindings( { labelEdge: { name: 'containerLabelEdge' },
     *                      readonly: { name: 'containerReadonly' }
     *                    } )
     * // Indicate that the component will provide the 'labelEdge' and 'readonly' property values
     * // under different keys and with different transforms as required for different consumers.
     * &#64;providedBindings( { labelEdge: [
     *                                  { name: 'containerLabelEdge', default: 'inside' },
     *                                  { name: 'labelEdge', default: 'inside', transform: {  top: 'provided', start: 'provided'  } }
     *                                 ],
     *                      readonly: [
     *                                  { name: 'containerReadonly' },
     *                                  { name: 'readonly' }
     *                                ]
     *                    } )
     * &#64;customElement('my-form-subsection-component')
     * class FormSubsectionComponent extends Component&lt;ExtendGlobalProps&lt;Props&gt;&gt; {
     *   static defaultProps = {
     *     labelEdge: 'inside',
     *     readonly: false
     *   };
     *
     *   render(props: Props) {
     *     return &lt;div&gt;Label position = {props.labelEdge}, sub-section is {props.readonly ? 'read only' : 'editable'}&lt;/div&gt;;
     *   }
     * }
     * </code>
     * </pre>
     */

    /**
     * Class decorator for VComponent specifying that one or more component properties can consume a value provided by an ancestor component.
     * The value will be consumed only if the specified component property's attribute has not been set, i.e. the consumed value is used as a default.
     * The 'name' property should be set to the name of the variable published by an ancestor component that is the source of the consumed value.
     * @param {object} consumes Object that maps component properties to the names of variables published by an ancestor component.
     * @return {Function}
     * @name consumedBindings
     * @function
     * @ojexports
     * @memberof ojvcomponent-binding
     * @ojsignature {target:"Type", value: "{ [key: string]: { name: string } }", for: "consumes"}
     * @ojdecorator
     */

    /**
     * Class decorator for VComponent specifying that one or more component properties will provide one or more values to be consumed by descendant components.
     * See example above. Provided values will come from the literal attribute values, explicit expression bindings, or implicit (consumed) bindings
     * provided by an ancestor component.
     * @param {object} provides Object that maps component properties to one or more variables published to its descendant components.
     * @return {Function}
     * @name providedBindings
     * @function
     * @ojexports
     * @ojsignature {target:"Type", value:"{ [key: string]: Array<MetadataTypes.ProvideProperty> }", for: "provides"}
     * @memberof ojvcomponent-binding
     * @ojdecorator
     */

    /**
     * Class decorator for VComponent. This is a compile time decorator that should add
     * "binding: {consume: {name: value}}" to the specified property's metadata.
     * @ignore
     */
    function consumedBindings(consumes) {
        return function (constructor) { };
    }
    /**
     * Class decorator for VComponent. This is a compile time decorator that should add
     * "binding: {provide: Array.[MetadataTypes.ProvideProperty]}" to the specified property's metadata.
     * @ignore
     */
    function providedBindings(provides) {
        return function (constructor) { };
    }

    exports.consumedBindings = consumedBindings;
    exports.providedBindings = providedBindings;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojvcomponent-remounter',['exports', 'preact'], function (exports, preact) { 'use strict';

    /**
     * The Remounter component should be used to remount a custom element when its slot layout
     * chnages. This is useful for cases when (1) a custom element does not use shadow DOM, and
     * (2) parent component's re-render may rearrange slots in a way that would affect their patching
     * and distribution
     * Example:
     * <pre class="prettyprint">
     * <code>
     * &lt;Remounter>
     *   <oj-button>
     *    &lt;span slot="startIcon" class="start">&lt;/span>
     *    {props.showEnd &&
     *      &lt;span slot="endIcon" class>="end"&lt;/span>
     *    }
     *  &lt;/oj-button>
     * &lt;/Remounter>
     * </code>
     * </pre>
     * In the example above, the "endIcon" slot is rendered conditionally, and the Remounter is responsible for remounting
     * the <oj-button> element whenever the condition changes.
     *
     * Note that the Remounter will not be tracking slots produced by the custom element's class-based component or
     * functional component children.
     *
     * The Remounter will throw an error if its number of children is not equal to one, or if its child is not an element node.
     * @ignore
     */
    class Remounter extends preact.Component {
        render(props) {
            let children = preact.toChildArray(props?.children);
            let first = children[0];
            if (this._isVNode(first) &&
                typeof first.type === 'function' &&
                first.type['__ojIsEnvironmentWrapper']) {
                // The node type is a constructor, so assume that this is an EnvironmentWrapper.
                // Lets get its children for cloning.
                children = preact.toChildArray(first.props?.children);
                first = children[0];
            }
            if (children.length !== 1 || !this._isVNode(first) || typeof first.type !== 'string') {
                throw new Error('The only child of the Remounter must be a custom element node');
            }
            const key = this._getElementKey(first);
            // There is no need to clone the EnvironmentWrapper, it is going to be added again
            // at the cloneElement() step.
            return [preact.cloneElement(first, { key })];
        }
        _getElementKey(elem) {
            // toChildArray will return empty array if children are undefined
            const slots = preact.toChildArray(elem.props?.children);
            // String and number are used 'as is', VNodes are turned into objects
            // with 'key', 'slot' and 'type' as keys
            const slotInfos = slots.map((slot) => this._isVNode(slot) ? this._getSlotInfo(slot) : slot);
            return JSON.stringify(slotInfos);
        }
        _getSlotInfo(slot) {
            let type = slot.type;
            // If the type is not a string, try getting 'name' for function or class
            type = typeof type === 'string' ? type : type.name || String(type);
            // object keys that have undefined values will be skipped by JSON.stringify
            return { key: slot.key, type, slot: slot.props?.slot };
        }
        _isVNode(node) {
            // toChildArray() will remove null, undefined and boolean nodes
            return typeof node !== 'string' && isNaN(node);
        }
    }

    exports.Remounter = Remounter;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdataproviderhandler',['exports', 'preact/jsx-runtime', 'preact'], function (exports, jsxRuntime, preact) { 'use strict';

    /**
     * @classdesc
     * A utility class containing helper functions related to dataprovider
     * functionalities for preact based components
     */
    class DataProviderHandlerUtils {
        /**
         * Constructs a new array with updates applied to the copy of the current data array.
         * An optional dataProvider can be passed which will be used to fetch
         * data, in case the data is not available in the mutation event detail.
         *
         * @param detail The mutation detail object
         * @param currentData The current data array
         * @param dataProvider The dataprovider instance
         * @returns The updated data array
         */
        static async getUpdatedItemsFromMutationDetail(detail, currentData, dataProvider) {
            const { add, remove, update } = detail ?? {};
            const keyIndexMap = new Map();
            // Build the keyIndex map for the current, so that future ops will be cheap
            for (const [index, item] of currentData.entries()) {
                keyIndexMap.set(item.key, index);
            }
            let mutatedData = [...currentData];
            // First remove the items
            if (remove) {
                mutatedData = DataProviderHandlerUtils._removeItemsFromDetail(remove, mutatedData, keyIndexMap);
            }
            // Now add the new items
            if (add) {
                mutatedData = await DataProviderHandlerUtils._addItemsFromDetail(add, mutatedData, keyIndexMap, dataProvider);
            }
            // Finally perform updates
            if (update) {
                mutatedData = await DataProviderHandlerUtils._updateItemsFromDetail(update, mutatedData, keyIndexMap, dataProvider);
            }
            return mutatedData;
        }
        ////////////////////////////
        // Private Helper Methods //
        ////////////////////////////
        /**
         * Adds items to the original array at the end
         *
         * @param itemsToAdd The new items to be added
         * @param itemMetadataToAdd The new itemMetaData to be added
         * @param items The original array of items
         * @returns The mutated items array
         */
        static _addItemsAtEnd(itemsToAdd, itemMetadataToAdd, items) {
            // make a shallow copy of the data array to mutate
            const returnItems = [...items];
            itemsToAdd.forEach((item, index) => {
                const addItem = {
                    data: item,
                    key: itemMetadataToAdd[index]?.key,
                    metadata: itemMetadataToAdd[index]
                };
                returnItems.push(addItem);
            });
            return returnItems;
        }
        /**
         * Adds items to the original array at the specified indices with the corresponding
         * data
         *
         * @param indices The indices at which the new items are to be added
         * @param itemsToAdd The new items to be added
         * @param itemMetadataToAdd The new metadata corresponding to the items
         * @param items The original array of items
         * @returns The mutated items array
         */
        static _addItemsAtIndices(indices, itemsToAdd, itemMetadataToAdd, items) {
            // make a shallow copy of the data array to mutate
            const returnItems = [...items];
            indices.forEach((addAtIndex, index) => {
                const addItem = {
                    data: itemsToAdd[index],
                    key: itemMetadataToAdd[index]?.key,
                    metadata: itemMetadataToAdd[index]
                };
                // For all positive indices, add at the index
                if (addAtIndex >= 0) {
                    returnItems.splice(addAtIndex, 0, addItem);
                }
                else {
                    // id index is negative, then add the item to the end
                    returnItems.push(addItem);
                }
            });
            return returnItems;
        }
        /**
         * Adds items to the original array at before the items with the specified keys
         * with the corresponding data
         *
         * @param beforeKeys The keys before which the new data should be added
         * @param itemsToAdd The new items to be added
         * @param items The original array of items
         * @param keyIndexMap A map containing key-index mapping
         * @returns The mutated items array
         */
        static _addItemsBeforeKeys(beforeKeys, itemsToAdd, items, keyIndexMap) {
            const addIndices = [];
            const itemMetadataToAdd = [];
            beforeKeys.forEach((key) => {
                addIndices.push(DataProviderHandlerUtils._getIndexByKey(keyIndexMap, key));
                itemMetadataToAdd.push({ key });
            });
            return DataProviderHandlerUtils._addItemsAtIndices(addIndices, itemsToAdd, itemMetadataToAdd, items);
        }
        /**
         * Adds items to the array from the add operation detail
         *
         * @param detail The add operation detail
         * @param items The current items array
         * @param keyIndexMap A map containing key-index mapping
         * @param dataProvider The instance of DataProvider for fetching data
         * @returns Promise that resolves to the new items array
         */
        static async _addItemsFromDetail(detail, items, keyIndexMap, dataProvider) {
            const { addBeforeKeys, afterKeys, data, indexes, keys, metadata } = detail;
            let mutatedData = [...items];
            let treatedData = data || [];
            let treatedMetaData = metadata || [];
            // Check if keys are available but the data is not, then fetch the data from the DP
            if (treatedData.length === 0 && keys?.size) {
                const fetchResults = (await DataProviderHandlerUtils._fetchDataByKeys(dataProvider, keys)) ?? [];
                treatedData = fetchResults.map((itemContext) => itemContext.data);
                treatedMetaData = fetchResults.map((itemContext) => itemContext.metadata);
            }
            // Check if metadata is empty and keys are available, populate metadata from key
            if (treatedMetaData.length === 0 && keys?.size) {
                treatedMetaData = [...keys].map((key) => ({ key }));
            }
            // Perform the addition only if the data is available
            if (treatedData.length) {
                // Check in the following order of where the items need to be inserted
                // - indexes
                // - addBeforeKeys
                // - afterKeys
                // if none of them are available, just append to the end of the data
                if (indexes?.length) {
                    mutatedData = DataProviderHandlerUtils._addItemsAtIndices(indexes, treatedData, treatedMetaData, mutatedData);
                }
                else if (addBeforeKeys?.length) {
                    mutatedData = DataProviderHandlerUtils._addItemsBeforeKeys(addBeforeKeys, treatedData, mutatedData, keyIndexMap);
                }
                else if (afterKeys?.size) {
                    mutatedData = DataProviderHandlerUtils._addItemsBeforeKeys([...afterKeys], treatedData, mutatedData, keyIndexMap);
                }
                else {
                    mutatedData = DataProviderHandlerUtils._addItemsAtEnd(treatedData, treatedMetaData, mutatedData);
                }
            }
            return mutatedData;
        }
        /**
         * Fetches the data from the dataprovider for the keys specified and returns the fetched data
         *
         * @param dataProvider The dataProvider instance for fetching the data
         * @param keys The set of keys whose data needs to be fetched
         * @returns A promise that resolves with the fetched data
         */
        static async _fetchDataByKeys(dataProvider, keys) {
            const fetchedData = [];
            const results = (await dataProvider.fetchByKeys({ keys })).results;
            for (const key of keys) {
                if (results.has(key)) {
                    const result = results.get(key);
                    fetchedData.push({ ...result, key });
                }
            }
            return fetchedData;
        }
        /**
         * Fetches the index of the item with the corresponding key
         *
         * @param keyIndexMap A map containing key-index mapping
         * @param key The key whose index has to be found
         * @returns The index of the item with the provided key
         */
        static _getIndexByKey(keyIndexMap, key) {
            if (keyIndexMap.has(key)) {
                return keyIndexMap.get(key);
            }
            // If key is not in the data return -1
            return -1;
        }
        /**
         * Removes items from the original items array with the corresponding indices
         *
         * @param indices An array of indices to be removed
         * @param items The original items array
         * @returns The mutated items array
         */
        static _removeItemsAtIndices(indices, items) {
            // make a shallow copy of the data array to mutate
            const returnItems = [...items];
            // sort the indices in desc order so the items can be removed from
            // the end
            indices.sort((a, b) => b - a);
            // iterate through indices and remove items
            indices.forEach((index) => {
                if (index < returnItems.length) {
                    returnItems.splice(index, 1);
                }
            });
            return returnItems;
        }
        /**
         * Removes items from the original items array with the corresponding keys
         *
         * @param keys A set of keys whose corresponding data has to be removed
         * @param items The original items array
         * @param keyIndexMap A map containing key-index mapping
         * @returns The mutated items array
         */
        static _removeItemsAtKeys(keys, items, keyIndexMap) {
            const indicesToRemove = [];
            keys.forEach((key) => {
                const index = DataProviderHandlerUtils._getIndexByKey(keyIndexMap, key);
                if (index !== -1) {
                    indicesToRemove.push(index);
                }
            });
            return DataProviderHandlerUtils._removeItemsAtIndices(indicesToRemove, items);
        }
        /**
         * Removes items from the array using the remove operation detail
         *
         * @param detail The remove operation detail
         * @param items The current items array
         * @param keyIndexMap A map containing key-index mapping
         * @returns Promise that resolves to the new items array
         */
        static _removeItemsFromDetail(detail, items, keyIndexMap) {
            const { indexes, keys } = detail;
            let mutatedData = [...items];
            // Check for list of indices first
            if (indexes?.length) {
                mutatedData = DataProviderHandlerUtils._removeItemsAtIndices(indexes, mutatedData);
            }
            else if (keys?.size) {
                mutatedData = DataProviderHandlerUtils._removeItemsAtKeys(keys, mutatedData, keyIndexMap);
            }
            return mutatedData;
        }
        /**
         * Updates items in the original array at the specified indices with the corresponding
         * data
         *
         * @param indices The indices at which the items are to be updated
         * @param itemsToUpdate The new items with updated data
         * @param itemMetadataToUpdate The new metadata corresponding to the items
         * @param items The original array of items
         * @returns The mutated items array
         */
        static _updateItemsAtIndices(indices, itemsToUpdate, itemMetadataToUpdate, items) {
            // make a shallow copy of the data array to mutate
            const returnItems = [...items];
            indices.forEach((updateAtIndex, index) => {
                // Update values only for existing items
                if (returnItems[updateAtIndex]) {
                    const addItem = {
                        data: itemsToUpdate[index],
                        key: itemMetadataToUpdate[index]?.key,
                        metadata: itemMetadataToUpdate[index]
                    };
                    returnItems.splice(updateAtIndex, 1, addItem);
                }
            });
            return returnItems;
        }
        /**
         * Updates items in the original array at the specified indices with the corresponding
         * data
         *
         * @param keys The keys at which the items are to be updated
         * @param itemsToUpdate The new items with updated data
         * @param itemMetadataToUpdate The new metadata corresponding to the items
         * @param items The original array of items
         * @param keyIndexMap A map containing key-index mapping
         * @returns The mutated items array
         */
        static _updateItemsAtKeys(keys, itemsToUpdate, itemMetadataToUpdate, items, keyIndexMap) {
            // make a shallow copy of the data array to mutate
            const returnItems = [...items];
            keys.forEach((key) => {
                const index = this._getIndexByKey(keyIndexMap, key);
                const addItem = {
                    data: itemsToUpdate[index],
                    key: itemMetadataToUpdate[index]?.key,
                    metadata: itemMetadataToUpdate[index]
                };
                // Update only if item exists in the current data
                if (index >= 0) {
                    returnItems.splice(index, 1, addItem);
                }
            });
            return returnItems;
        }
        /**
         * Updates items in the array using the update operation detail
         *
         * @param detail The update operation detail
         * @param items The current items array
         * @param keyIndexMap A map containing key-index mapping
         * @param dataProvider The instance of DataProvider for fetching data
         * @returns Promise that resolves to the new items array
         */
        static async _updateItemsFromDetail(detail, items, keyIndexMap, dataProvider) {
            const { data, indexes, keys, metadata } = detail;
            let mutatedData = [...items];
            let treatedData = data || [];
            let treatedMetaData = metadata || [];
            // Check if keys are available but the data is not, then fetch the data from the DP
            if (treatedData.length === 0 && keys?.size) {
                const fetchResults = (await DataProviderHandlerUtils._fetchDataByKeys(dataProvider, keys)) ?? [];
                treatedData = fetchResults.map((itemContext) => itemContext.data);
                treatedMetaData = fetchResults.map((itemContext) => itemContext.metadata);
            }
            // Check if metadata is empty and keys are available, populate metadata from key
            if (treatedMetaData.length === 0 && keys?.size) {
                treatedMetaData = [...keys].map((key) => ({ key }));
            }
            // Perform the update only if the data is available
            if (treatedData.length) {
                // Check in the following order for updating data
                // - indexes
                // - keys
                if (indexes?.length) {
                    mutatedData = DataProviderHandlerUtils._updateItemsAtIndices(indexes, treatedData, treatedMetaData, mutatedData);
                }
                else if (keys?.size) {
                    mutatedData = DataProviderHandlerUtils._updateItemsAtKeys(keys, treatedData, treatedMetaData, mutatedData, keyIndexMap);
                }
            }
            return mutatedData;
        }
    }

    /**
     * @classdesc
     * This class handles DataProvider mechanisms for the preact components
     * @ignore
     */
    class DataProviderHandler {
        ///////////////////////////
        // Handler functions end //
        ///////////////////////////
        /**
         * Instantiates the MessagesDataProviderHandler.
         *
         * @param dataProvider The data provider instance that is being used by the component
         * @param addBusyState A function reference that set busy state in the component
         * @param callback A callback that will be invoked whenever data changes
         */
        constructor(dataProvider, addBusyState, callback) {
            ////////////////////////////////////////////////////////////////////////
            // Handler functions are created as members to have them 'this' bound //
            ////////////////////////////////////////////////////////////////////////
            /**
             * Handles the mutation event triggered by the dataprovider and calls corresponding
             * callbacks.
             *
             * @param event DP mutation event object containing details relevant to the event
             */
            this._handleMutateEvent = async (event) => {
                const { detail } = event;
                // Add busy state while updating the data
                const resolver = this._addBusyState('updating data from mutation event');
                const updatedData = await DataProviderHandlerUtils.getUpdatedItemsFromMutationDetail(detail, this._currentData, this._dataProvider);
                // Resolve the busy state
                resolver?.();
                // store the newly created data and notify the consumer with the new data
                this._currentData = updatedData;
                this._callback?.onDataUpdated?.(updatedData);
            };
            /**
             * Handles the refresh event triggered by the dataprovider and calls corresponding
             * callbacks.
             *
             * @param event DP mutation event object containing details relevant to the event
             */
            this._handleRefreshEvent = (event) => {
                // For refresh event, we will simply fetch new data and notify
                this._fetchDataAndNotify();
            };
            this._addBusyState = addBusyState;
            this._callback = callback;
            this._dataProvider = dataProvider;
            this._currentData = [];
            // Subscribe to the data provider events
            dataProvider.addEventListener('refresh', this._handleRefreshEvent);
            dataProvider.addEventListener('mutate', this._handleMutateEvent);
            // Initialize a fetch
            this._fetchDataAndNotify();
        }
        ////////////////////
        // Public Methods //
        ////////////////////
        /**
         * Destroys all resources un-registers all events
         */
        destroy() {
            // Clean up callbacks so that existing fetches will not update the component
            this._callback = undefined;
            // empty the store data
            this._currentData = [];
            // Clean up data provider
            this._dataProvider.removeEventListener('refresh', this._handleRefreshEvent);
            this._dataProvider.removeEventListener('mutate', this._handleMutateEvent);
        }
        ////////////////////////
        // Public Methods End //
        ////////////////////////
        ////////////////////////////
        // Private Helper Methods //
        ////////////////////////////
        /**
         * Fetches the data from the dataprovider and returns the fetched data
         *
         * @returns A promise that resolves with the fetched data
         */
        async _fetchData() {
            const fetchedData = [];
            const asyncIterable = this._dataProvider.fetchFirst({ size: -1 });
            for await (const results of asyncIterable) {
                const contextArray = results.data.map((item, index) => {
                    return {
                        data: item,
                        key: results.metadata[index].key,
                        metadata: results.metadata[index]
                    };
                });
                fetchedData.push(...contextArray);
            }
            // Store a copy of data before returning
            this._currentData = fetchedData.slice();
            return fetchedData;
        }
        /**
         * Fetches the data from the dataprovider and calls the corresponding
         * callback with the fetched data.
         */
        async _fetchDataAndNotify() {
            // Set the busy state
            const resolver = this._addBusyState('fetching data');
            const fetchedData = await this._fetchData();
            this._callback?.onDataUpdated?.(fetchedData);
            // Now that the data is fetched, clear the busy state
            resolver();
        }
    }

    /**
     * A HOC for converting a DataProvider<K, D> into an Array<ItemContext<K, D>
     * data source. This component also subscribes to the DP events and updates
     * the data prop of the WrappedComponent automatically. The HOC expects the
     * Prop specified as the data property of the WrappedComponent to accept an
     * Array of ItemContext<K, D>.
     *
     * @template K type of the key in DP
     * @template D type of the Data in DP
     * @template P type of the Props of the WrappedComponent
     *
     * @param WrappedComponent The Class Component or Functional Component to be wrapped
     * @param dataProp The name of the data Prop in the WrappedComponent. This property
     *                 should accept an Array of ItemContext<K, D>
     * @returns The HOC generated component that does DP -> array conversion for the data prop
     */
    function withDataProvider(WrappedComponent, dataProp) {
        var _a;
        return _a = class extends preact.Component {
                ///////////////////////////
                // Handler functions end //
                ///////////////////////////
                /**
                 * Instantiates Banner Component
                 *
                 * @param props The component properties
                 */
                constructor(props) {
                    super(props);
                    ////////////////////////////////////////////////////////////////////////
                    // Handler functions are created as members to have them 'this' bound //
                    ////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles when the component receives fresh data from the DP handler
                     *
                     * @param fetchedData The newly fetched data
                     */
                    this._handleDataUpdate = (fetchedData) => {
                        this.setState({ fetchedData });
                    };
                    this.state = {
                        fetchedData: []
                    };
                }
                //////////////////////////////////////
                // Component Life Cycle Hooks Start //
                //////////////////////////////////////
                /**
                 * Life Cycle hook that gets called when the component is mounted to the DOM.
                 * Do one-time initializations here.
                 */
                componentDidMount() {
                    // Fetch the data only after the component is mounted on to the DOM.
                    this._initDataProviderHandler();
                }
                /**
                 * Life Cycle hook that gets called when the component's state or props is updated
                 * after it is rendered for the first time.
                 *
                 * @param previousProps Previous Props
                 */
                componentDidUpdate(previousProps) {
                    // Check if the data source is modified and reinitialize the data provider handler
                    if (this.props.data !== previousProps.data) {
                        this._resetDataProviderHandler();
                    }
                }
                /**
                 * Life Cycle hook that gets called right before the component gets unmounted from the DOM.
                 * Release all resources here.
                 */
                componentWillUnmount() {
                    this._releaseDataProviderHandler();
                }
                ////////////////////////////////////
                // Component Life Cycle Hooks End //
                ////////////////////////////////////
                /**
                 * Renders the WrappedComponent instance
                 *
                 * @param props The current properties of the component
                 * @param state The current state of the component
                 *
                 * @returns The rendered component
                 */
                render(props, state) {
                    const { data, addBusyState, ...passThroughProps } = props;
                    const { fetchedData } = state;
                    const childProps = {
                        [dataProp]: fetchedData,
                        ...passThroughProps
                    };
                    return jsxRuntime.jsx(WrappedComponent, { ...childProps });
                }
                ////////////////////////////
                // Private helper methods //
                ////////////////////////////
                /**
                 * Initializes the DataProviderHandler. By default fetches the data.
                 */
                _initDataProviderHandler() {
                    const { data, addBusyState } = this.props;
                    // Initialize only if data provider exists in the current props.
                    if (data != null) {
                        this._dataProviderHandler = new DataProviderHandler(data, addBusyState, {
                            onDataUpdated: this._handleDataUpdate
                        });
                    }
                }
                /**
                 * Destroys the current DataProviderHandler instance
                 */
                _releaseDataProviderHandler() {
                    this._dataProviderHandler?.destroy();
                    this._dataProviderHandler = undefined;
                }
                /**
                 * Resets the DataProviderHandler. By default fetches the data.
                 */
                _resetDataProviderHandler() {
                    // Destroy existing dataprovider handler
                    this._releaseDataProviderHandler();
                    // Reinitialize a new one
                    this._initDataProviderHandler();
                }
            },
            /**
             * Display Name of the component
             */
            _a.displayName = `WithDataProvider(${getDisplayName(WrappedComponent)})`,
            _a;
    }
    /**
     * Obtains a Component's display name.
     *
     * @param WrappedComponent The Component whose displayName has to be obtained
     * @returns The displayName of the component if one exists or uses 'Component' as default
     */
    function getDisplayName(WrappedComponent) {
        return WrappedComponent.displayName ?? WrappedComponent.name ?? 'Component';
    }

    exports.withDataProvider = withDataProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojexpparser',['exports'], function (exports) { 'use strict';

  /**
   * @license
   * Copyright (c) 2019 2025, Oracle and/or its affiliates.
   * Licensed under The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   *
   * Portions of this code are based on on JSEP Parser
   * @license
   * JavaScript Expression Parser (JSEP) 1.3.8
   * https://github.com/EricSmekens/jsep
   */

  /* eslint-disable no-use-before-define */
  /* eslint-disable one-var-declaration-per-line */
  /* eslint-disable no-plusplus */
  /* eslint-disable camelcase */
  /* eslint-disable one-var */
  /* eslint-disable no-param-reassign */

  /**
   * @ignore
   */
  // eslint-disable-next-line no-unused-vars
  const ExpParser = function () {
    // Parsing
    // -------
    // `expr` is a string with the passed in expression
    this.parse = function (expr) {
      // `index` stores the character number we are currently at.
      // All of the gobbles below will modify `index` as we move along.
      var context = {
        index: 0,
        expr: expr
      };

      var nodes = _gobbleExpressions(context);

      // If there's only one expression just try returning the expression
      if (nodes.length === 1) {
        return nodes[0];
      }
      return {
        type: COMPOUND,
        body: nodes
      };
    };

    // Top-level parser, that can be reused within as well
    // Takes context and optional untilICode character.
    // Returns an array of AST nodes.
    function _gobbleExpressions(context, untilICode) {
      const expr = context.expr;
      const length = expr.length;
      const nodes = [];
      while (context.index < length) {
        _gobbleSpaces(context);
        const ch_i = expr.charCodeAt(context.index);
        // Expressions can be separated by semicolons, commas, or just inferred without any
        // separators
        // They are not used as untilICode.
        if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
          context.index++; // ignore separators
        } else {
          // Try to gobble each expression individually
          const node = _gobbleExpression(context);
          if (node) {
            nodes.push(node);
            // If we weren't able to find a binary expression and are out of room, then
            // the expression passed in probably has too much
          } else if (context.index < length) {
            if (ch_i === untilICode) {
              break;
            }
            _throwError('Unexpected "' + expr.charAt(context.index) + '"', context.index);
          }
        }
      }
      return nodes;
    }

    // Push `index` up to the next non-space character
    function _gobbleSpaces(context) {
      var expr = context.expr;
      var ch = expr.charCodeAt(context.index);
      // space or tab
      while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {
        ch = expr.charCodeAt(++context.index);
      }
    }

    // The main parsing function. Much of this code is dedicated to ternary expressions
    // eslint-disable-next-line consistent-return
    function _gobbleExpression(context) {
      const expr = context.expr;
      // Check for arrow expression special case first, if it is not continue with binary expression parser.
      let test = _gobbleArrowFunctionExpression(context) || _gobbleBinaryExpression(context),
        consequent,
        alternate;
      _gobbleSpaces(context);
      if (expr.charCodeAt(context.index) === QUMARK_CODE) {
        // Ternary expression: test ? consequent : alternate
        context.index++;
        consequent = _gobbleExpression(context);
        if (!consequent) {
          _throwError('Expected expression', context.index);
        }
        _gobbleSpaces(context);
        if (expr.charCodeAt(context.index) === COLON_CODE) {
          context.index++;
          alternate = _gobbleExpression(context);
          if (!alternate) {
            _throwError('Expected expression', context.index);
          }
          test = {
            type: CONDITIONAL_EXP,
            test: test,
            consequent: consequent,
            alternate: alternate
          };
        } else {
          _throwError('Expected :', context.index);
        }
      }
      // The following form or arrow function such as p =>p or (p1, p2) => ...
      // are parsed as binary expression. We need to convert them into ArrowFunctionExpression form.
      _updateBinariesToArrows(test);
      return test;
    }

    // Search for the operation portion of the string (e.g. `+`, `===`)
    // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
    // and move down from 3 to 2 to 1 character until a matching binary operation is found
    // then, return that binary operation
    function _gobbleBinaryOp(context) {
      var expr = context.expr;
      _gobbleSpaces(context);
      var to_check = expr.substr(context.index, _max_binop_len),
        tc_len = to_check.length;
      while (tc_len > 0) {
        // Don't accept a binary op when it is an identifier.
        // Binary ops that start with a identifier-valid character must be followed
        // by a non identifier-part valid character
        if (
          _binary_ops[to_check] &&
          (!_isIdentifierStart(expr.charCodeAt(context.index)) ||
            (context.index + to_check.length < expr.length &&
              !_isIdentifierPart(expr.charCodeAt(context.index + to_check.length))))
        ) {
          context.index += tc_len;
          return to_check;
        }
        to_check = to_check.substr(0, --tc_len);
      }
      return false;
    }

    // This function is responsible for gobbling an individual expression,
    // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
    function _gobbleBinaryExpression(context) {
      var node, biop, prec, stack, biop_info, left, right, i, cur_biop, cur_prec;

      // First, try to get the leftmost thing
      // Then, check to see if there's a binary operator operating on that leftmost thing
      left = _gobbleToken(context);
      biop = _gobbleBinaryOp(context);

      // If there wasn't a binary operator, just return the leftmost node
      if (!biop) {
        return left;
      }

      // Otherwise, we need to start a stack to properly place the binary operations in their
      // precedence structure
      biop_info = { value: biop, prec: _binaryPrecedence(biop) };

      right = biop === '=>' ? _gobbleArrowFunctionBody(context) : _gobbleToken(context);
      if (!right) {
        _throwError('Expected expression after ' + biop, context.index);
      }
      stack = [left, biop_info, right];
      // The cur_biop and cur_prec variables are used in _binaryPrecedence() calculation
      // to cover the edge case with chain exponentiation that should be executed right-to-left,
      // e.g. (4 ** 3 ** 2) should transform into a node
      // where left side is { type: Literal, value: 4 } and right side is
      // {type: BinaryExpression, operator: "**", left: {type: Literal, value:3}, right: {type: Literal: value:2}}.
      // As the result we don't want to create BinaryExpressions until we find the end of the chain. The technique for
      // right-to-left walk is to assign a slightly larger precedence value
      // to the next '**' in the chain of '**'. See  _binaryPrecedence() for details.
      cur_biop = biop;
      cur_prec = biop_info.prec;

      // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
      // eslint-disable-next-line no-cond-assign
      while ((biop = _gobbleBinaryOp(context))) {
        prec = _binaryPrecedence(biop, cur_biop, cur_prec);

        if (prec === 0) {
          break;
        }
        biop_info = { value: biop, prec: prec };

        cur_biop = biop;
        cur_prec = prec;
        // Reduce: make a binary expression from the three topmost entries.
        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
          right = stack.pop();
          biop = stack.pop().value;
          left = stack.pop();
          node = _createBinaryExpression(biop, left, right, context);
          stack.push(node);
        }

        node = _gobbleToken(context);
        if (!node) {
          _throwError('Expected expression after ' + cur_biop, context.index);
        }
        stack.push(biop_info, node);
      }

      i = stack.length - 1;
      node = stack[i];
      while (i > 1) {
        node = _createBinaryExpression(stack[i - 1].value, stack[i - 2], node, context);
        i -= 2;
      }
      return node;
    }

    // An individual part of a binary expression:
    // e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
    function _gobbleToken(context) {
      var expr = context.expr;
      var ch, to_check, tc_len;

      _gobbleSpaces(context);
      ch = expr.charCodeAt(context.index);

      if (_isDecimalDigit(ch) || ch === PERIOD_CODE) {
        // Char code 46 is a dot `.` which can start off a numeric literal
        return _gobbleNumericLiteral(context);
      } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE || ch === OBRACK_CODE) {
        // Treat string literal or an array literal as variable to support method call such as 'abc'.indexOf('b')
        return _gobbleVariable(context);
      } else if (ch === OBRACE_CODE) {
        return _gobbleObjectLiteral(context);
      } else if (ch === BTICK_CODE) {
        return _gobbleTemplateLiteral(context);
      }
      to_check = expr.substr(context.index, _max_unop_len);
      tc_len = to_check.length;
      while (tc_len > 0) {
        // Don't accept an unary op when it is an identifier.
        // Unary ops that start with a identifier-valid character must be followed
        // by a non identifier-part valid character
        if (
          to_check in _unary_ops &&
          (!_isIdentifierStart(expr.charCodeAt(context.index)) ||
            (context.index + to_check.length < expr.length &&
              !_isIdentifierPart(expr.charCodeAt(context.index + to_check.length))))
        ) {
          context.index += tc_len;
          return {
            type: UNARY_EXP,
            operator: to_check,
            argument: _gobbleToken(context),
            prefix: true
          };
        }
        to_check = to_check.substr(0, --tc_len);
      }

      var start = context.index;
      var funcEnd = context.index + 8;
      if (
        expr.substring(start, funcEnd) === 'function' &&
        !_isIdentifierPart(expr.charCodeAt(funcEnd))
      ) {
        context.index = funcEnd;
        return _gobbleFunction(context);
      }

      if (_isIdentifierStart(ch) || ch === OPAREN_CODE) {
        // open parenthesis
        // `foo`, `bar.baz`
        return _gobbleVariable(context);
      }

      return false;
    }

    // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
    // keep track of everything in the numeric literal and then calling `parseFloat` on that string
    function _gobbleNumericLiteral(context) {
      var expr = context.expr;
      var number = '',
        ch,
        chCode;
      while (_isDecimalDigit(expr.charCodeAt(context.index))) {
        number += expr.charAt(context.index++);
      }

      if (expr.charCodeAt(context.index) === PERIOD_CODE) {
        // can start with a decimal marker
        number += expr.charAt(context.index++);

        while (_isDecimalDigit(expr.charCodeAt(context.index))) {
          number += expr.charAt(context.index++);
        }
      }

      ch = expr.charAt(context.index);
      if (ch === 'e' || ch === 'E') {
        // exponent marker
        number += expr.charAt(context.index++);
        ch = expr.charAt(context.index);
        if (ch === '+' || ch === '-') {
          // exponent sign
          number += expr.charAt(context.index++);
        }
        while (_isDecimalDigit(expr.charCodeAt(context.index))) {
          // exponent itself
          number += expr.charAt(context.index++);
        }
        if (!_isDecimalDigit(expr.charCodeAt(context.index - 1))) {
          _throwError(
            'Expected exponent (' + number + expr.charAt(context.index) + ')',
            context.index
          );
        }
      }

      chCode = expr.charCodeAt(context.index);
      // Check to make sure this isn't a variable name that start with a number (123abc)
      if (_isIdentifierStart(chCode)) {
        _throwError(
          'Variable names cannot start with a number (' + number + expr.charAt(context.index) + ')',
          context.index
        );
      } else if (chCode === PERIOD_CODE) {
        _throwError('Unexpected period', context.index);
      }

      return {
        type: LITERAL,
        value: parseFloat(number),
        raw: number
      };
    }

    // Parses a string literal, staring with single or double quotes with basic support for escape codes
    // e.g. `"hello world"`, `'this is\nJSEP'`
    function _gobbleStringLiteral(context) {
      var expr = context.expr;
      var str = '',
        quote = expr.charAt(context.index++),
        closed = false,
        ch;

      var length = expr.length;
      while (context.index < length) {
        ch = expr.charAt(context.index++);
        if (ch === quote) {
          closed = true;
          break;
        } else if (ch === '\\') {
          // Check for all of the common escape codes
          ch = expr.charAt(context.index++);
          switch (ch) {
            case 'n':
              str += '\n';
              break;
            case 'r':
              str += '\r';
              break;
            case 't':
              str += '\t';
              break;
            case 'b':
              str += '\b';
              break;
            case 'f':
              str += '\f';
              break;
            case 'v':
              str += '\x0B';
              break;
            default:
              str += ch;
          }
        } else {
          str += ch;
        }
      }

      if (!closed) {
        _throwError('Unclosed quote after "' + str + '"', context.index);
      }

      return {
        type: LITERAL,
        value: str,
        raw: quote + str + quote
      };
    }

    // Gobbles only identifiers
    // e.g.: `foo`, `_value`, `$x1`
    // Also, this function checks if that identifier is a literal:
    // (e.g. `true`, `false`, `null`) or `this`
    function _gobbleIdentifier(context, bMemberExpr) {
      var expr = context.expr;
      var ch = expr.charCodeAt(context.index),
        start = context.index,
        identifier;

      if (_isIdentifierStart(ch)) {
        context.index++;
      } else {
        _throwError('Unexpected ' + expr.charAt(context.index), context.index);
      }

      var length = expr.length;
      while (context.index < length) {
        ch = expr.charCodeAt(context.index);
        if (_isIdentifierPart(ch)) {
          context.index++;
        } else {
          break;
        }
      }
      identifier = expr.slice(start, context.index);

      if (identifier === 'new' && !bMemberExpr) {
        // process constructor expression,
        // e.g. new Date('Jan 1, 2016') or new (MyFoo())("outer")
        _gobbleSpaces(context);
        var constructorNode = _gobbleVariable(context, CALL_EXP); // stop at CallExpression type
        if (constructorNode.type !== CALL_EXP) {
          _throwError(
            'Expression of type: ' +
              constructorNode.type +
              ' not supported for constructor expression'
          );
        }
        return {
          type: NEW_EXP,
          callee: constructorNode.callee,
          arguments: constructorNode.arguments
        };
      }

      if (_literals.has(identifier)) {
        return {
          type: LITERAL,
          value: _literals.get(identifier),
          raw: identifier
        };
      }
      if (_unsupported.has(identifier)) {
        _throwError(`The '${identifier}' keyword is not supported in expressions.`);
      }
      return {
        type: IDENTIFIER,
        name: identifier
      };
    }

    // Gobbles a list of arguments within the context of a function call
    // or array literal. This function also assumes that the opening character
    // `(` or `[` has already been gobbled, and gobbles expressions and commas
    // until the terminator character `)` or `]` is encountered.
    // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
    function _gobbleArguments(context, termination, identifiersOnly) {
      var expr = context.expr;
      var length = expr.length;
      var ch_i,
        args = [],
        node,
        closed = false;
      var separator_count = 0;
      while (context.index < length) {
        _gobbleSpaces(context);
        ch_i = expr.charCodeAt(context.index);
        if (ch_i === termination) {
          // done parsing
          closed = true;
          context.index++;
          if (termination === CPAREN_CODE && separator_count && separator_count >= args.length) {
            _throwError('Unexpected token ' + String.fromCharCode(termination), context.index);
          }
          break;
        } else if (ch_i === COMMA_CODE) {
          // between expressions
          context.index++;
          separator_count++;
          if (separator_count !== args.length) {
            // missing argument
            if (termination === CPAREN_CODE) {
              _throwError('Unexpected token ,', context.index);
            } else if (termination === CBRACK_CODE) {
              for (var arg = args.length; arg < separator_count; arg++) {
                args.push(null);
              }
            }
          }
        } else {
          if (identifiersOnly) {
            node = _gobbleIdentifier(context);
          } else {
            node = _gobbleExpression(context);
          }
          if (!node || args.length > separator_count) {
            _throwError('Expected comma', context.index);
          }
          args.push(node);
        }
      }
      if (!closed) {
        _throwError('Expected ' + String.fromCharCode(termination), context.index);
      }
      return args;
    }

    // Gobble a non-literal variable name. This variable name may include properties
    // e.g. `foo`, `bar.baz`, `foo['bar'].baz`
    // It also gobbles function calls:
    // e.g. `Math.acos(obj.angle)`
    function _gobbleVariable(context, stopAtType) {
      var expr = context.expr;
      var ch_i, node;
      ch_i = expr.charCodeAt(context.index);

      if (ch_i === OPAREN_CODE) {
        node = _gobbleGroup(context);
      } else if (ch_i === SQUOTE_CODE || ch_i === DQUOTE_CODE) {
        // Supporting method call on string literal such as 'abc'.indexOf('b')
        // Single or double quotes
        node = _gobbleStringLiteral(context);
      } else if (ch_i === OBRACK_CODE) {
        // Supporting method call on array literal such as [1, 3].includes(3)
        node = _gobbleArray(context);
      } else {
        node = _gobbleIdentifier(context);
      }

      _gobbleSpaces(context);
      ch_i = expr.charCodeAt(context.index);
      while (
        ch_i === PERIOD_CODE ||
        ch_i === OBRACK_CODE ||
        ch_i === OPAREN_CODE ||
        _isOptionalChaining(context)
      ) {
        context.index++;
        if (ch_i === PERIOD_CODE) {
          _gobbleSpaces(context);
          node = {
            type: MEMBER_EXP,
            computed: false,
            object: node,
            property: _gobbleIdentifier(context, true)
          };
        } else if (ch_i === QUMARK_CODE) {
          // optional chaining - current index is on the '.',
          // move it to the next char
          context.index++;
          _gobbleSpaces(context);
          node = {
            type: MEMBER_EXP,
            computed: false,
            optional: true,
            object: node,
            property: _gobbleIdentifier(context, true)
          };
        } else if (ch_i === OBRACK_CODE) {
          node = {
            type: MEMBER_EXP,
            computed: true,
            object: node,
            property: _gobbleExpression(context)
          };
          _gobbleSpaces(context);
          ch_i = expr.charCodeAt(context.index);
          if (ch_i !== CBRACK_CODE) {
            _throwError('Unclosed [', context.index);
          }
          context.index++;
        } else if (ch_i === OPAREN_CODE) {
          // A function call is being made; gobble all the arguments
          node = {
            type: CALL_EXP,
            arguments: _gobbleArguments(context, CPAREN_CODE),
            callee: node
          };
        }
        // stop is used for constructor types, e.g. new Date('Jan 1, 2016').toISOString()
        // treat constructor as a group, then execute the rest
        if (stopAtType === node.type) {
          return node;
        }

        _gobbleSpaces(context);
        ch_i = expr.charCodeAt(context.index);
      }
      return node;
    }

    // Responsible for parsing a group of things within parentheses `()`
    // This function assumes that it needs to gobble the opening parenthesis
    // and then tries to gobble everything within that parenthesis, assuming
    // that the next thing it should see is the close parenthesis. If not,
    // then the expression probably doesn't have a `)`
    // eslint-disable-next-line consistent-return
    function _gobbleGroup(context) {
      context.index++;
      let nodes = _gobbleExpressions(context, CPAREN_CODE);
      if (context.expr.charCodeAt(context.index) === CPAREN_CODE) {
        context.index++;
        if (nodes.length === 1) {
          return nodes[0];
        } else if (!nodes.length) {
          return false;
        }
        return {
          type: SEQUENCE_EXP,
          expressions: nodes
        };
      }
      _throwError('Unclosed (', context.index);
    }

    // Responsible for parsing Array literals `[1, 2, 3]`
    // This function assumes that it needs to gobble the opening bracket
    // and then tries to gobble the expressions as arguments.
    function _gobbleArray(context) {
      context.index++;
      return {
        type: ARRAY_EXP,
        elements: _gobbleArguments(context, CBRACK_CODE)
      };
    }

    // This code parses function body within {...}.
    // Note that the code block is limited to a single statement,
    // might or might not have a return statement and
    // it does not allow an assignment operation.
    // This parser is used for both, function and arrow function, code blocks.
    function _gobbleFunctionBody(context) {
      _gobbleSpaces(context);
      const expr = context.expr;
      let ch_i = expr.charCodeAt(context.index);
      context.index++;
      _gobbleSpaces(context);

      let hasReturn = false;
      const start = context.index;
      if (expr.substring(start, start + 6) === 'return') {
        hasReturn = true;
        context.index += 6;
      }
      _gobbleSpaces(context);
      const funcBody = _gobbleExpression(context);
      _gobbleSpaces(context);
      ch_i = expr.charCodeAt(context.index);
      if (ch_i === SEMCOL_CODE) {
        context.index++;
        _gobbleSpaces(context);
      }

      ch_i = expr.charCodeAt(context.index);
      if (ch_i !== CBRACE_CODE) {
        _throwError('Expected },', context.index);
      }
      context.index++;

      return {
        type: BLOCK_STATEMENT,
        expr: expr.substring(start, context.index - 1),
        body: hasReturn
          ? {
              type: RETURN_STATEMENT,
              argument: funcBody
            }
          : funcBody
      };
    }

    // Creates a node for the FunctionExpression, such as 'function(p1, p2){return p1 + p2}'
    // This code does not support complex code blocks for the function.
    // See _gobbleFunctionBody() for details.
    function _gobbleFunction(context) {
      var expr = context.expr;

      _gobbleSpaces(context);
      var ch_i = expr.charCodeAt(context.index);
      if (ch_i !== OPAREN_CODE) {
        _throwError('Expected (,', context.index);
      }
      context.index++;
      var args = _gobbleArguments(context, CPAREN_CODE, true);
      _gobbleSpaces(context);
      ch_i = expr.charCodeAt(context.index);
      if (ch_i !== OBRACE_CODE) {
        _throwError('Expected {,', context.index);
      }

      return {
        type: FUNCTION_EXP,
        params: args,
        body: _gobbleFunctionBody(context)
      };
    }

    function _gobbleObjectLiteral(context) {
      var expr = context.expr;
      context.index++;
      var props = [];
      var closed;
      var separator_count = 0;
      var length = expr.length;
      while (context.index < length && !closed) {
        _gobbleSpaces(context);
        var ch_i = expr.charCodeAt(context.index);
        if (ch_i === CBRACE_CODE) {
          // done parsing
          closed = true;
          context.index++;
        } else if (ch_i === COMMA_CODE) {
          // between expressions
          context.index++;
          separator_count++;
          if (separator_count !== props.length) {
            // missing argument
            _throwError('Unexpected token ,', context.index);
          }
        } else {
          var key =
            ch_i === SQUOTE_CODE || ch_i === DQUOTE_CODE
              ? _gobbleStringLiteral(context)
              : _gobbleIdentifier(context);

          _gobbleSpaces(context);
          ch_i = expr.charCodeAt(context.index);
          if (key.type === IDENTIFIER && (ch_i === COMMA_CODE || ch_i === CBRACE_CODE)) {
            // process shorthand object notation
            props.push({ type: PROPERTY, key: key, value: key, shorthand: true });
          } else if (ch_i === COLON_CODE) {
            context.index++;
            // Set "writer" property on the context while we are evaluating the expression
            // for property writers. We will only allow assignment operators if the flag is set
            var writer = context.writer;
            var keyValue = getKeyValue(key);
            if (keyValue === '_ko_property_writers') {
              context.writer = 1;
            }
            try {
              props.push({
                type: PROPERTY,
                key: key,
                value: _gobbleExpression(context),
                shorthand: false
              });
            } finally {
              context.writer = writer;
            }
          } else {
            _throwError("Expected ':'. Found " + String.fromCharCode(ch_i), context.index);
          }
        }
      }
      if (!closed) {
        _throwError('Expected ' + String.fromCharCode(CBRACE_CODE), context.index);
      }
      return {
        type: OBJECT_EXP,
        properties: props
      };
    }

    // Parses a template literal, staring with backtick.
    // e.g. `Hello, ${userName}!`
    function _gobbleTemplateLiteral(context) {
      const expr = context.expr;
      let ch_i = expr.charCodeAt(context.index);
      if (ch_i === BTICK_CODE) {
        const node = {
          type: TEMPLATE_LITERAL,
          quasis: [],
          expressions: []
        };
        let cooked = '';
        let raw = '';
        let closed = false;
        const length = expr.length;
        const pushQuasi = () =>
          node.quasis.push({
            type: TEMPLATE_ELEMENT,
            value: {
              raw,
              cooked
            },
            tail: closed
          });
        while (context.index < length) {
          let ch = expr.charAt(++context.index);

          if (ch === '`') {
            context.index += 1;
            closed = true;
            pushQuasi();
            return node;
          } else if (ch === '$' && expr.charAt(context.index + 1) === '{') {
            context.index += 2;
            pushQuasi();
            raw = '';
            cooked = '';
            try {
              node.expressions.push(..._gobbleExpressions(context, CBRACE_CODE));
            } finally {
              ch_i = expr.charCodeAt(context.index);
              if (ch_i !== CBRACE_CODE) {
                _throwError('Unclosed ${ in template literal', expr);
              }
            }
          } else if (ch === '\\') {
            // Check for all of the common escape codes
            raw += ch;
            ch = expr.charAt(++context.index);
            raw += ch;

            switch (ch) {
              case 'n':
                cooked += '\n';
                break;
              case 'r':
                cooked += '\r';
                break;
              case 't':
                cooked += '\t';
                break;
              case 'b':
                cooked += '\b';
                break;
              case 'f':
                cooked += '\f';
                break;
              case 'v':
                cooked += '\x0B';
                break;
              default:
                cooked += ch;
            }
          } else {
            cooked += ch;
            raw += ch;
          }
        }
        if (context.index === length) {
          _throwError('Unclosed backtick ` in template literal', expr);
        }
      }
      return false;
    }

    // This code searches for the special case () => ...
    // which would normally throw an error because of the invalid LHS to the bin op.
    // The other forms of arrow function such as p => p or (p, p2) => ...
    // are parsed using _gobbleBinaryExpression() logic, then updated to the proper form.
    function _gobbleArrowFunctionExpression(context) {
      const expr = context.expr;
      let ch = expr.charCodeAt(context.index);
      let node;

      if (ch === OPAREN_CODE) {
        const backupIndex = context.index;
        context.index++;

        _gobbleSpaces(context);
        ch = expr.charCodeAt(context.index);
        if (ch === CPAREN_CODE) {
          context.index++;

          const biop = _gobbleBinaryOp(context);
          if (biop === '=>') {
            // () => ...
            const body = _gobbleArrowFunctionBody(context);
            if (!body) {
              _throwError('Expected expression after ' + biop);
            }
            node = {
              type: ARROW_EXP,
              params: [],
              body
            };
          }
        }
        if (!node) {
          // not a () => ... case, go back
          context.index = backupIndex;
        }
      }
      return node;
    }

    // Creates a node for the right side of arrow function.
    function _gobbleArrowFunctionBody(context) {
      const expr = context.expr;
      _gobbleSpaces(context);

      let returnNode;
      if (expr.charCodeAt(context.index) === OBRACE_CODE) {
        returnNode = _gobbleFunctionBody(context);
      } else {
        const startDef = context.index;
        _gobbleSpaces(context);
        const funcBody = _gobbleExpression(context);
        _gobbleSpaces(context);
        returnNode = {
          type: BLOCK_STATEMENT,
          expr: expr.substring(startDef, context.index),
          body: {
            type: RETURN_STATEMENT,
            argument: funcBody
          }
        };
      }
      return returnNode;
    }

    // Converts binary expression into arrow function expression
    // if arrow operation is detected.
    function _updateBinariesToArrows(node) {
      if (node) {
        // Traverse full tree, converting any sub-object nodes as needed
        Object.values(node).forEach((val) => {
          if (val && typeof val === 'object') {
            _updateBinariesToArrows(val);
          }
        });

        if (node.operator === '=>') {
          node.type = ARROW_EXP;
          node.params = node.left ? [node.left] : null;
          node.body = node.right;
          if (node.params && node.params[0].type === SEQUENCE_EXP) {
            node.params = node.params[0].expressions;
          }
          delete node.left;
          delete node.right;
          delete node.operator;
        }
      }
    }

    var PERIOD_CODE = 46, // '.'
      COMMA_CODE = 44, // ','
      SQUOTE_CODE = 39, // single quote
      DQUOTE_CODE = 34, // double quotes
      OPAREN_CODE = 40, // (
      CPAREN_CODE = 41, // )
      OBRACK_CODE = 91, // [
      CBRACK_CODE = 93, // ]
      QUMARK_CODE = 63, // ?
      SEMCOL_CODE = 59, // ;
      COLON_CODE = 58, // :
      BTICK_CODE = 96, // `
      OBRACE_CODE = 123, // {
      CBRACE_CODE = 125; // }

    function _getMaxKeyLen(obj) {
      return Object.keys(obj).reduce(function (curr, key) {
        return Math.max(curr, key.length);
      }, 0);
    }

    // Operations
    // ----------
    // Set `t` to `true` to save space (when minified, not gzipped)
    var t = true,
      // Use a quickly-accessible map to store all of the unary operators
      // Values are set to `true` (it really doesn't matter)
      _unary_ops = { '-': t, '!': t, '~': t, '+': t, typeof: t },
      // Also use a map for the binary operations but set their values to their
      // binary precedence for quick reference:
      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence#table
      _binary_ops = {
        '=': 1,
        '||': 2,
        '??': 2,
        '&&': 3,
        '|': 4,
        '^': 5,
        '&': 6,
        '==': 7,
        '!=': 7,
        '===': 7,
        '!==': 7,
        '<': 8,
        '>': 8,
        '<=': 8,
        '>=': 8,
        instanceof: 8,
        '<<': 9,
        '>>': 9,
        '>>>': 9,
        '+': 10,
        '-': 10,
        '*': 11,
        '/': 11,
        '%': 11,
        '**': 12,
        '=>': 0.1
      },
      // Get return the longest key length of any object
      _max_unop_len = _getMaxKeyLen(_unary_ops),
      _max_binop_len = _getMaxKeyLen(_binary_ops);

    // Literals
    // ----------
    // Store the values to return for the various literals we may encounter
    var _literals = new Map();
    _literals.set('true', true);
    _literals.set('false', false);
    _literals.set('null', null);
    _literals.set('undefined', undefined);

    // Identifiers that are not supported by the parser.
    var _unsupported = new Set(['await']);

    // Returns the precedence of a binary operator or `0` if it isn't a binary operator
    function _binaryPrecedence(op_val, prev_op_val, prev_op_prec) {
      const basePrec = _binary_ops[op_val] || 0;
      // The following code is to cover the edge case with chain exponentiation.
      // Since it should be executed right-to-left we increase precedence
      // value for the next ** operation. This technique will delay the
      // creation of BinaryExpression for exponentiation, until the end of the chain is reached.
      if (basePrec !== 12 || prev_op_val === undefined || op_val !== prev_op_val) {
        return basePrec;
      }
      // When both operations are '**', the precedence should be larger than prev_op_prec, but less than 13.
      return (prev_op_prec + 13) * 0.5;
    }

    // Utility function (gets called from multiple places)
    // Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
    function _createBinaryExpression(operator, left, right, context) {
      if (operator === '=' && !context.writer) {
        _throwError("Unexpected operator '='", context.index);
      }
      var type =
        operator === '||' || operator === '&&' || operator === '??' ? LOGICAL_EXP : BINARY_EXP;
      return {
        type: type,
        operator: operator,
        left: left,
        right: right
      };
    }

    // Check for optional  chaining operator - '?.'
    // We should also look ahead to discriminate between
    // 'a?.b' (optional chaining) and 'a?.3:0' (ternary operator)
    function _isOptionalChaining(context) {
      var expr = context.expr;
      if (
        expr.charCodeAt(context.index) === QUMARK_CODE &&
        expr.charCodeAt(context.index + 1) === PERIOD_CODE &&
        !_isDecimalDigit(expr.charCodeAt(context.index + 2))
      ) {
        return true;
      }
      return false;
    }

    // `ch` is a character code in the next three functions
    function _isDecimalDigit(ch) {
      return ch >= 48 && ch <= 57; // 0...9
    }

    function _isIdentifierStart(ch) {
      return (
        ch === 36 ||
        ch === 95 || // `$` and `_`
        (ch >= 65 && ch <= 90) || // A...Z
        (ch >= 97 && ch <= 122) || // a...z
        (ch >= 128 && !_binary_ops[String.fromCharCode(ch)])
      ); // any non-ASCII that is not an operator
    }

    function _isIdentifierPart(ch) {
      return (
        ch === 36 ||
        ch === 95 || // `$` and `_`
        (ch >= 65 && ch <= 90) || // A...Z
        (ch >= 97 && ch <= 122) || // a...z
        (ch >= 48 && ch <= 57) || // 0...9
        (ch >= 128 && !_binary_ops[String.fromCharCode(ch)])
      ); // any non-ASCII that is not an operator
    }

    function _throwError(message, index) {
      var error = new Error(message + ' at character ' + index);
      error.index = index;
      error.description = message;
      throw error;
    }
  };

  // Helper method to retrieve a string value of an object key.
  const getKeyValue = function (keyObj) {
    return keyObj.type === IDENTIFIER ? keyObj.name : keyObj.value;
  };

  // This is the full set of types that any JSEP node can be.
  const COMPOUND = 'Compound';
  const IDENTIFIER = 'Identifier';
  const MEMBER_EXP = 'MemberExpression';
  const LITERAL = 'Literal';
  const CALL_EXP = 'CallExpression';
  const UNARY_EXP = 'UnaryExpression';
  const BINARY_EXP = 'BinaryExpression';
  const LOGICAL_EXP = 'LogicalExpression';
  const CONDITIONAL_EXP = 'ConditionalExpression';
  const ARRAY_EXP = 'ArrayExpression';
  const OBJECT_EXP = 'ObjectExpression';
  const FUNCTION_EXP = 'FunctionExpression';
  const NEW_EXP = 'NewExpression';
  const PROPERTY = 'Property';
  const TEMPLATE_LITERAL = 'TemplateLiteral';
  const TEMPLATE_ELEMENT = 'TemplateElement';
  const SEQUENCE_EXP = 'SequenceExpression';
  const ARROW_EXP = 'ArrowFunctionExpression';
  const RETURN_STATEMENT = 'ReturnStatement';
  const BLOCK_STATEMENT = 'BlockStatement';

  exports.ARRAY_EXP = ARRAY_EXP;
  exports.ARROW_EXP = ARROW_EXP;
  exports.BINARY_EXP = BINARY_EXP;
  exports.BLOCK_STATEMENT = BLOCK_STATEMENT;
  exports.CALL_EXP = CALL_EXP;
  exports.COMPOUND = COMPOUND;
  exports.CONDITIONAL_EXP = CONDITIONAL_EXP;
  exports.ExpParser = ExpParser;
  exports.FUNCTION_EXP = FUNCTION_EXP;
  exports.IDENTIFIER = IDENTIFIER;
  exports.LITERAL = LITERAL;
  exports.LOGICAL_EXP = LOGICAL_EXP;
  exports.MEMBER_EXP = MEMBER_EXP;
  exports.NEW_EXP = NEW_EXP;
  exports.OBJECT_EXP = OBJECT_EXP;
  exports.PROPERTY = PROPERTY;
  exports.RETURN_STATEMENT = RETURN_STATEMENT;
  exports.TEMPLATE_ELEMENT = TEMPLATE_ELEMENT;
  exports.TEMPLATE_LITERAL = TEMPLATE_LITERAL;
  exports.UNARY_EXP = UNARY_EXP;
  exports.getKeyValue = getKeyValue;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcspexpressionevaluator-internal',['exports', 'ojs/ojexpparser'], function (exports, ojexpparser) { 'use strict';

  /**
   * @license
   * Copyright (c) 2019 2025, Oracle and/or its affiliates.
   * Licensed under The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   *
   * @license
   * Based on the Expression Evaluator 2.0.0
   * https://github.com/donmccurdy/expression-eval
   * under MIT License
   * @ignore
   */

  // Used by VTemplateEngine
  const PROXY_SYMBOL = Symbol('proxy');

  /**
   * @ignore
   * @constructor
   */
  // eslint-disable-next-line no-unused-vars
  const CspExpressionEvaluatorInternal = function (options) {
    var _parser = new ojexpparser.ExpParser();
    var _options = Object.assign({}, options);
    if (!(_options.globalScope && _options.globalScope.Object)) {
      _options.globalScope = Object.assign({ Object: Object }, _options.globalScope);
    }

    /**
     * Creates expression evaluator
     * @param {string} expressionText expression associated  with the returned evaluator
     * @return {Object} an object with the 'evaluate' key referencing a function that
     * will return the result of evaluation. The function will take an array of scoping contexts ordered from the
     * most specific to the least specific
     * @ignore
     */
    this.createEvaluator = function (expressionText) {
      var parsed;
      try {
        parsed = _parser.parse(expressionText);
      } catch (e) {
        _throwErrorWithExpression(e, expressionText);
      }
      var extraScope = _options.globalScope;
      return {
        evaluate: function (contexts) {
          var ret;
          var scopes = contexts;
          if (extraScope) {
            scopes = contexts.concat([extraScope]);
          }
          try {
            ret = _evaluateAndUnwrap(parsed, scopes);
          } catch (e) {
            _throwErrorWithExpression(e, expressionText);
          }
          return ret;
        }
      };
    };

    /**
     * @param {object} ast an AST node
     * @param {object} context a context object to apply on expressions
     * @ignore
     */
    this.evaluate = function (ast, context) {
      return _evaluateAndUnwrap(ast, [context]);
    };

    // Note, for logical && and || operators the right hand expression
    // is always a callback. It is done to ensure that the right hand
    // expression is evaluated only if it is needed and only after
    // left hand expression is evaluated.
    var _binops = {
      '||': function (a, b) {
        return a || b();
      },
      '??': function (a, b) {
        return a ?? b();
      },
      '&&': function (a, b) {
        return a && b();
      },
      '|': function (a, b) {
        return a | b;
      },
      '^': function (a, b) {
        return a ^ b;
      },
      '&': function (a, b) {
        return a & b;
      },
      '==': function (a, b) {
        return a == b;
      },
      '!=': function (a, b) {
        return a != b;
      },
      '===': function (a, b) {
        return a === b;
      },
      '!==': function (a, b) {
        return a !== b;
      },
      '<': function (a, b) {
        return a < b;
      },
      '>': function (a, b) {
        return a > b;
      },
      '<=': function (a, b) {
        return a <= b;
      },
      '>=': function (a, b) {
        return a >= b;
      },
      '<<': function (a, b) {
        return a << b;
      },
      '>>': function (a, b) {
        return a >> b;
      },
      '>>>': function (a, b) {
        return a >>> b;
      },
      '+': function (a, b) {
        return a + b;
      },
      '-': function (a, b) {
        return a - b;
      },
      '*': function (a, b) {
        return a * b;
      },
      '/': function (a, b) {
        return a / b;
      },
      '%': function (a, b) {
        return a % b;
      },
      '**': function (a, b) {
        return a ** b;
      },
      instanceof: function (a, b) {
        return a instanceof b;
      }
    };

    var _unops = {
      '-': function (a) {
        return -a;
      },
      '+': function (a) {
        return a;
      },
      '~': function (a) {
        return ~a;
      },
      '!': function (a) {
        return !a;
      },
      '...': function (a) {
        return new _Spread(a);
      },
      typeof: function (a) {
        return typeof a;
      }
    };

    function _Spread(list) {
      this.items = function () {
        return list;
      };
    }

    // Unwrap value if exists and it is a Proxy created by
    // VTemplateEngine around properties.
    function _evaluateAndUnwrap(node, contexts) {
      const value = _evaluate(node, contexts);
      return value?.[PROXY_SYMBOL] ?? value;
    }

    // eslint-disable-next-line consistent-return
    function _evaluate(node, contexts) {
      switch (node.type) {
        case ojexpparser.IDENTIFIER:
          return _getValue(contexts, node.name);

        case ojexpparser.MEMBER_EXP:
          return _evaluateMember(node, contexts)[1];

        case ojexpparser.LITERAL:
          return node.value;

        case ojexpparser.CALL_EXP:
          var caller;
          var fn;
          var assign;
          switch (node.callee.type) {
            case ojexpparser.IDENTIFIER:
              assign = _getValueWithContext(contexts, node.callee.name);
              break;
            case ojexpparser.MEMBER_EXP:
              assign = _evaluateMember(node.callee, contexts);
              break;
            default:
              fn = _evaluateAndUnwrap(node.callee, contexts);
          }
          if (!fn && Array.isArray(assign)) {
            caller = assign[0];
            fn = assign[1];
          }
          if (typeof fn !== 'function') {
            _throwError('Expression is not a function');
          }
          return fn.apply(caller, _evaluateArray(node.arguments, contexts));

        case ojexpparser.UNARY_EXP:
          var testValue;
          try {
            testValue = _evaluateAndUnwrap(node.argument, contexts);
          } catch (e) {
            // Undefined identifier will throw an error, don't report it
            if (node.argument.type !== ojexpparser.IDENTIFIER) {
              throw e;
            }
          }
          return _unops[node.operator](testValue);

        case ojexpparser.BINARY_EXP:
          if (node.operator === '=') {
            return _evaluateAssignment(node.left, contexts, _evaluateAndUnwrap(node.right, contexts));
          }
          return _binops[node.operator](
            _evaluateAndUnwrap(node.left, contexts),
            _evaluateAndUnwrap(node.right, contexts)
          );

        case ojexpparser.LOGICAL_EXP:
          return _binops[node.operator](_evaluateAndUnwrap(node.left, contexts), function () {
            return _evaluateAndUnwrap(node.right, contexts);
          });

        case ojexpparser.CONDITIONAL_EXP:
          return _evaluateAndUnwrap(node.test, contexts)
            ? _evaluateAndUnwrap(node.consequent, contexts)
            : _evaluateAndUnwrap(node.alternate, contexts);

        case ojexpparser.ARRAY_EXP:
          return _evaluateArray(node.elements, contexts);

        case ojexpparser.OBJECT_EXP:
          return _evaluateObjectExpression(node, contexts);

        case ojexpparser.FUNCTION_EXP:
        case ojexpparser.ARROW_EXP:
          return _evaluateFunctionExpression(node, contexts);

        case ojexpparser.NEW_EXP:
          return _evaluateConstructorExpression(node, contexts);

        case ojexpparser.TEMPLATE_LITERAL:
          return _evaluateTemplateLiteral(node, contexts);

        case ojexpparser.TEMPLATE_ELEMENT:
          return node.value.cooked;

        default:
          throw new Error('Unsupported expression type: ' + node.type);
      }
    }

    function _evaluateArray(list, contexts) {
      return list.reduce((acc, v) => {
        const elem = _evaluateAndUnwrap(v, contexts);
        if (elem instanceof _Spread) {
          acc.push(...elem.items());
        } else {
          acc.push(elem);
        }
        return acc;
      }, []);
    }

    function _evaluateMember(node, contexts) {
      var object = _evaluate(node.object, contexts);
      if (!object && node.optional) {
        // handle optional chaining operator: test?.prop
        return [];
      } else if (node.computed) {
        return [object, object[_evaluate(node.property, contexts)]];
      }
      return [object, object[node.property.name]];
    }

    function _evaluateObjectExpression(node, contexts) {
      return node.properties.reduce(function (acc, curr) {
        const key = ojexpparser.getKeyValue(curr.key);
        acc[key] = _evaluateAndUnwrap(curr.value, contexts);
        return acc;
      }, {});
    }

    // eslint-disable-next-line consistent-return
    function _getValue(contexts, name) {
      var target = _getContextForIdentifier(contexts, name);
      if (target) {
        return target[name];
      }
      throw new Error('Variable ' + name + ' is undefined');
    }

    // eslint-disable-next-line consistent-return
    function _getValueWithContext(contexts, name) {
      var target = _getContextForIdentifier(contexts, name);
      if (target) {
        return [target, target[name]];
      }
      throw new Error('Variable ' + name + ' is undefined');
    }

    function _evaluateAssignment(node, contexts, val) {
      switch (node.type) {
        case ojexpparser.IDENTIFIER:
          var name = node.name;
          var target = _getContextForIdentifier(contexts, name);
          if (!target) {
            _throwError('Cannot assign value to undefined variable ' + name);
          }
          target[name] = val;
          break;
        case ojexpparser.MEMBER_EXP:
          var key = node.computed ? _evaluateAndUnwrap(node.property, contexts) : node.property.name;
          _evaluateMember(node, contexts)[0][key] = val;
          break;
        default:
          _throwError('Expression of type: ' + node.type + ' not supported for assignment');
      }
      return val;
    }

    function _evaluateFunctionExpression(node, contexts) {
      return function () {
        var _args = arguments;

        var argScope = node.params.reduce(function (acc, arg, i) {
          acc[arg.name] = _args[i];
          return acc;
        }, {});

        // eslint-disable-next-line dot-notation
        argScope['this'] = this;

        try {
          // Expect to get node.body.type = 'BlockStatement'.
          // Expect to get node.body.body = {type: 'ReturnStatement', argument: <node to evaluate>} || <node to evaluate>
          const hasReturn = node.body.body.type === ojexpparser.RETURN_STATEMENT;
          const codeBlock = hasReturn ? node.body.body.argument : node.body.body;
          const val = _evaluateAndUnwrap(codeBlock, [argScope].concat(contexts));
          return hasReturn ? val : undefined;
        } catch (e) {
          _throwErrorWithExpression(e, node.body.expr);
        }
        return undefined;
      };
    }

    function _evaluateConstructorExpression(node, contexts) {
      var constrObj = _evaluateAndUnwrap(node.callee, contexts);
      if (!(constrObj instanceof Function)) {
        _throwError('Node of type ' + node.callee.type + ' is not evaluated into a constructor');
      }

      // eslint-disable-next-line new-parens
      return new (Function.prototype.bind.apply(
        constrObj,
        [null].concat(_evaluateArray(node.arguments, contexts))
      ))();
    }

    function _evaluateTemplateLiteral(node, contexts) {
      const resolvedExpressions = node.expressions.map((expr) => _evaluateAndUnwrap(expr, contexts));
      const result = node.quasis.reduce((acc, curVal, curIndex) => {
        acc.push(_evaluateAndUnwrap(curVal, contexts));
        if (curIndex < resolvedExpressions.length) {
          acc.push(resolvedExpressions[curIndex]);
        }
        return acc;
      }, []);
      return result.join('');
    }

    function _getContextForIdentifier(contexts, name) {
      for (var i = 0; i < contexts.length; i++) {
        var context = contexts[i];
        if (context instanceof Object && name in context) {
          return context;
        }
      }
      return null;
    }

    function _throwError(message) {
      throw new Error(message);
    }
    function _throwErrorWithExpression(e, expression) {
      throw new Error(e.message + ' in expression "' + expression + '"');
    }
  };

  exports.CspExpressionEvaluatorInternal = CspExpressionEvaluatorInternal;
  exports.PROXY_SYMBOL = PROXY_SYMBOL;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojvcomponent-template',['exports', 'ojs/ojlogger', 'ojs/ojhtmlutils', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry', 'preact', 'preact/jsx-runtime', 'ojs/ojcontext', 'ojs/ojvcomponent', 'ojs/ojdataproviderhandler', 'ojs/ojpreact-managetabstops', 'ojs/ojbindpropagation', 'ojs/ojconfig', 'ojs/ojmetadatautils', 'ojs/ojcspexpressionevaluator-internal', 'ojs/ojmonitoring', 'ojs/ojexpparser'], function (exports, Logger, HtmlUtils, ojcustomelementUtils, ojcustomelementRegistry, preact, jsxRuntime, Context, ojvcomponent, ojdataproviderhandler, ojpreactManagetabstops, ojbindpropagation, ojconfig, ojmetadatautils, ojcspexpressionevaluatorInternal, ojmonitoring, ojexpparser) { 'use strict';

    Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

    class Props {
    }
    class BindDom extends preact.Component {
        constructor(props) {
            super(props);
            this._resolveConfig = (configPromise) => {
                this._registerBusyState();
                configPromise
                    .then((result) => {
                    if (configPromise === this.props.config) {
                        this.setState({ view: this._getFragment(result?.view ?? []), data: result?.data });
                    }
                })
                    .finally(() => {
                    if (configPromise === this.props.config) {
                        this._resolveBusyState();
                    }
                });
            };
            this._getFragment = (nodes) => {
                const fragment = new DocumentFragment();
                nodes.forEach((node) => {
                    fragment.appendChild(node.cloneNode(this));
                });
                return fragment;
            };
            this._registerBusyState = () => {
                if (!this._resolveBusyStateCallback) {
                    // Check for BusyStateContext element provided by the parent,
                    // otherwise use componentElement property.
                    // The property is not populated for oj-defer.
                    const busyElem = this._busyContextEl?.current
                        ? this._busyContextEl?.current
                        : this.props.componentElement;
                    if (busyElem) {
                        this._resolveBusyStateCallback = Context.getContext(busyElem)
                            .getBusyContext()
                            .addBusyState({
                            description: `oj-bind-dom is waiting on config Promise resolution on element ${busyElem.tagName}#${busyElem.id}`
                        });
                    }
                }
            };
            this._resolveBusyState = () => {
                if (this._resolveBusyStateCallback) {
                    this._resolveBusyStateCallback();
                    this._resolveBusyStateCallback = null;
                }
            };
            this.state = { view: null, data: null };
            this._busyContextEl = null;
        }
        componentDidMount() {
            this._resolveConfig(this.props.config);
        }
        componentDidUpdate(prevProps, prevState) {
            if (this.props.config !== prevProps.config) {
                this._resolveConfig(this.props.config);
            }
        }
        render() {
            return (jsxRuntime.jsx(preact.Fragment, { children: jsxRuntime.jsx(ojvcomponent.ReportBusyContext.Consumer, { children: (value) => {
                        this._busyContextEl = value;
                        return this.state.view && this.props.executeFragment
                            ? this.props.executeFragment(null, this.state.view, this.state.data, this.forceUpdate.bind(this), this.props.bindingProvider)
                            : null;
                    } }) }));
        }
    }

    /**
     * Wrapper class that handles both types of data properties - arrays and data providers.
     * The class delegates data provider updates to the HOC - WithDataProviderType.
     */
    class BindForEachWrapper extends preact.Component {
        constructor(props) {
            super(props);
            this._addBusyState = (description) => {
                const busyElem = this._busyContextEl?.current
                    ? this._busyContextEl?.current
                    : this.props.componentElement;
                const busyContext = Context.getContext(busyElem).getBusyContext();
                return busyContext.addBusyState({ description });
            };
            this.BindForEachWithDP = ojdataproviderhandler.withDataProvider(BindForEachDataUnwrapper, 'data');
        }
        render(props) {
            if (Array.isArray(props.data)) {
                return jsxRuntime.jsx(BindForEachWithArray, { data: props.data, itemRenderer: props.itemRenderer });
            }
            else {
                return (jsxRuntime.jsx(ojvcomponent.ReportBusyContext.Consumer, { children: (value) => {
                        this._busyContextEl = value;
                        return (jsxRuntime.jsx(this.BindForEachWithDP, { addBusyState: this._addBusyState, data: props.data, itemRenderer: props.itemRenderer }));
                    } }));
            }
        }
    }
    /**
     * A component that unwraps data object that came from WithDataProviderType into
     * a simplified format required by BindForEachWithArray component.
     */
    class BindForEachDataUnwrapper extends preact.Component {
        render(props) {
            const unwrappedData = props.data.map((item) => item.data);
            return jsxRuntime.jsx(BindForEachWithArray, { data: unwrappedData, itemRenderer: props.itemRenderer });
        }
    }
    /**
     * A component that renderes an array of data using a provided item renderer.
     */
    class BindForEachWithArray extends preact.Component {
        render() {
            const data = this.props.data;
            return (jsxRuntime.jsx(preact.Fragment, { children: data
                    ? data.map((row, index) => {
                        return this.props.itemRenderer({
                            data: row,
                            index: index,
                            observableIndex: () => index
                        });
                    })
                    : [] }));
        }
    }

    const BINDING_PROVIDER = Symbol();
    const COMPONENT_ELEMENT = Symbol();
    const TEMPLATE_ELEMENT = Symbol();
    const TEMPLATE_ALIAS = Symbol();
    const UNWRAP_EXTRAS = Symbol();
    const BINDING_CONTEXT = Symbol();
    const PREVIOUS_DOT_PROPS_VALUES = Symbol();
    const _DEFAULT_UNWRAP = function (target) {
        return target;
    };
    const _PROVIDED_KEY = '$provided';
    const _CONTEXT_PARAM = [
        {
            type: ojexpparser.IDENTIFIER,
            name: '$context'
        }
    ];
    const _LITERALS_CACHE = new Map();
    const _proxyUnwrap = (value) => value?.[ojcspexpressionevaluatorInternal.PROXY_SYMBOL] ?? value;
    const _unwrapBindingContext = (bindingContext, templateAlias) => {
        if (!bindingContext.$current) {
            return bindingContext;
        }
        const unwrappedCurr = _proxyUnwrap(bindingContext.$current);
        const newContext = Object.defineProperties({}, Object.getOwnPropertyDescriptors(bindingContext));
        newContext.$current = unwrappedCurr;
        if (templateAlias) {
            newContext[templateAlias] = unwrappedCurr;
        }
        return newContext;
    };
    class VTemplateEngine {
        constructor() {
            this._templateAstCache = new WeakMap();
            this._cspEvaluator = ojconfig.getExpressionEvaluator() ?? new ojcspexpressionevaluatorInternal.CspExpressionEvaluatorInternal();
            // This variable serves as a temporary storage during expression evaluation.
            // The results should be thrown away as for the next evaluation. See createRecursiveProxy().
            this._expressionPaths = [];
        }
        /**
         * Static method called to cleanup template cache if exists
         * @param templateElement the <template> element
         */
        static cleanupTemplateCache(templateElement) {
            if (templateElement && templateElement['_cachedRows']) {
                templateElement['_cachedRows'].forEach((entry) => entry.dispose());
                templateElement['_cachedRows'] = [];
            }
        }
        /**
         * Executes the DocumentFragment by converting the fragment nodes into AST and evaluating it against applied context.
         * This method is designed for external usage from Dynamic form UI. Main difference from external() method is that
         * the properties object will be directly applied to the template as is.
         * @param {HTMLElement | null} componentElement component element that will be used to retrieve binding provider
         *         or null if binding provider is irrelevant
         * @param {DocumentFragment} fragment the DocumentFragment element
         * @param {object} properties data to be applied to the template
         * @param {Function} mutationCallback a callback function the caller should specify to be notified if any observables
         *        in the properties have changed. When notified, the parent component should rerender in order to call
         *        this function again to regenerate the vnodes.
         * @param {KOBindingProviderLocal=} bindingProvider optional binding provider for the fragment. Used by BindDom component.
         * @returns {Array.<VNode>} an array of virtual nodes that will be added to a parent vcomponent.
         */
        executeFragment(componentElement, fragment, properties, mutationCallback, bindingProviderForFragment) {
            let bindingProvider = bindingProviderForFragment;
            if (!bindingProvider) {
                bindingProvider = componentElement
                    ? ojcustomelementUtils.CustomElementUtils.getElementState(componentElement)?.getBindingProvider()
                    : null;
            }
            // Normalize $provided into a Map since executeFragment() user might give us a plain object.
            // TODO: this code is a workaround for JET-57399. It should be removed when the issue is fixed.
            if (properties?.['$provided'] && !(properties['$provided'] instanceof Map)) {
                properties['$provided'] = new Map(Object.entries(properties['$provided']));
            }
            return this._execute({
                [BINDING_PROVIDER]: bindingProvider,
                [COMPONENT_ELEMENT]: componentElement,
                [TEMPLATE_ELEMENT]: fragment,
                [BINDING_CONTEXT]: properties
            }, fragment, properties, mutationCallback);
        }
        /**
         * Executes the template by converting the template nodes into AST and evaluating it against applied context.
         * @param {Element} componentElement component element
         * @param {Element} templateElement the <template> element
         * @param {object} properties data to be applied to the template
         * @param {Function} mutationCallback a function used by computed VNodes on template updates
         * @return {Array.<VNode>} an array of virtual nodes that will be added to a parent vcomponent.
         * @ignore
         */
        execute(componentElement, templateElement, properties, bindingProvider, mutationCallback) {
            const templateAlias = templateElement.getAttribute('data-oj-as');
            const context = this._getContext(bindingProvider, componentElement, templateElement, properties, null, templateAlias);
            return this._execute({
                [BINDING_PROVIDER]: bindingProvider,
                [COMPONENT_ELEMENT]: componentElement,
                [TEMPLATE_ELEMENT]: templateElement,
                [TEMPLATE_ALIAS]: templateAlias,
                [BINDING_CONTEXT]: context
            }, templateElement, context, mutationCallback);
        }
        /**
         * Internal helper method that creates AST and returns computed or plain VNodes based on binding provider.
         * @param engineContext
         * @param templateElement
         * @param context
         * @param mutationCallback
         */
        _execute(engineContext, templateElement, context, mutationCallback) {
            const ast = this._getAstViaCache(engineContext, templateElement);
            const bindingProvider = engineContext[BINDING_PROVIDER];
            if (bindingProvider) {
                if (!templateElement['_cachedRows']) {
                    Object.defineProperties(templateElement, {
                        _cachedRows: { writable: true, value: [] }
                    });
                }
                // The computedVNodes observable is designed to create virtual nodes
                // on initial call. The computed will be called again on update
                // to perform the cleanup (to be disposed and removed from cache) and to
                // call a mutation callback function. The mutation callback should notify
                // a parent component to trigger rerender.
                const computedVNodes = bindingProvider.__KoComputed(() => {
                    if (bindingProvider.__KoIsInitial()) {
                        return this._cspEvaluator.evaluate(ast, { $context: context, $h: preact.h, BindDom });
                    }
                    VTemplateEngine.cleanupTemplateCache(templateElement);
                    mutationCallback();
                });
                templateElement['_cachedRows'].push(computedVNodes);
                return computedVNodes();
            }
            return this._cspEvaluator.evaluate(ast, { $context: context, $h: preact.h, BindDom });
        }
        /**
         * The method creates a Proxy for the given $current object. This Proxy is used to wrap the properties
         * of the object to gather identifier expressions during the evaluation step.
         * @param currentObj the object to be wrapped with a Proxy.
         * @returns a new Proxy object that wraps the properties of the input object.
         */
        _createProxyForCurrentObj(currentObj) {
            // Method that checks whether a proxy for the given property can be created.
            // The property can't be proxied when both configurable and writable descriptors are false.
            // Allow proxy when a property descriptor does not exist on the object.
            function canProxy(obj, prop) {
                const d = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!d || d.configurable || d.writable);
            }
            // Helper function that wraps properties object into Proxy
            // in order to gather identifier expressions during evaluation step.
            // The expresions will be used to populate __oj_private_identifier_to_prop and
            // __oj_private_identifier_to_value properties.
            function createRecursiveProxy(obj, path = '', onAccess) {
                return new Proxy(obj, {
                    get(target, property) {
                        if (property === ojcspexpressionevaluatorInternal.PROXY_SYMBOL) {
                            return obj;
                        }
                        // Build path and store it on a class
                        const newPath = Boolean(path) ? `${path}.${property}` : `${property}`;
                        const propValue = target[property];
                        onAccess(newPath, propValue);
                        if (propValue && typeof propValue === 'object' && canProxy(target, property)) {
                            return createRecursiveProxy(propValue, newPath, onAccess);
                        }
                        return propValue;
                    }
                });
            }
            const proxy = currentObj
                ? createRecursiveProxy(currentObj, '', (identifier, value) => {
                    const lastItem = this._expressionPaths[this._expressionPaths.length - 1];
                    if (lastItem && identifier.startsWith(`${lastItem.identifier}.`)) {
                        this._expressionPaths.pop();
                    }
                    this._expressionPaths.push({ identifier, value });
                })
                : currentObj;
            return proxy;
        }
        /**
         * Gets binding context for the template element.
         * @param {KOBindingProviderLocal} bindingProvider binding provider for the template
         * @param {Element} componentElement component element
         * @param {Element} node the <template> element
         * @param {object} properties data to be applied to the template
         * @param {string} alias external alias (need in oj-bind-template-slot)
         * @param {string} templateAlias template alias
         * @return {object} context object
         */
        _getContext(bindingProvider, componentElement, node, properties, alias, templateAlias) {
            const proxy = properties && typeof properties === 'object'
                ? this._createProxyForCurrentObj(properties)
                : properties;
            if (bindingProvider) {
                // Always use the binding context for the template  element
                let bindingContext = bindingProvider.__ContextFor(node);
                // In the rare case it's not defined, check the componentElement and log a message
                if (!bindingContext) {
                    Logger.info(`Binding context not found when processing template for element with id: ${componentElement.id}. Using binding context for element instead.`);
                    bindingContext = bindingProvider.__ContextFor(componentElement);
                }
                return bindingProvider.__ExtendBindingContext(bindingContext, proxy, alias, templateAlias, componentElement);
            }
            const context = {
                $current: proxy
            };
            if (templateAlias) {
                context[templateAlias] = proxy;
            }
            return context;
        }
        /**
         * Retrieves an AST for the given template from cache.
         * Creates and stores an AST for the given template when it is used for the first time.
         * @return {object}
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param template
         */
        _getAstViaCache(engineContext, template) {
            let ast = this._templateAstCache.get(template);
            if (!ast) {
                // Check if nodeType is Node.DOCUMENT_FRAGMENT_NODE
                if (template.nodeType === 11) {
                    ast = this._createAst(engineContext, Array.from(template.childNodes));
                }
                else {
                    // Use child nodes of DocumentFragment that we get from HtmlUtils.getTemplateContent()
                    const docFragment = HtmlUtils.getTemplateContent(template)[0];
                    ast = this._createAst(engineContext, Array.from(docFragment.childNodes));
                }
                this._templateAstCache.set(template, ast);
            }
            return ast;
        }
        /**
         * Creates AST node for the top level template nodes.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Array<Node>} nodes array of template nodes
         * @return {object} AST node
         */
        _createAst(engineContext, nodes) {
            const arrayNode = { type: ojexpparser.ARRAY_EXP, elements: [] };
            arrayNode.elements = Array.prototype.reduce.call(nodes, (acc, node) => {
                const special = this._processSpecialNodes(engineContext, node);
                if (special) {
                    acc.push(special);
                }
                else if (node.nodeType === 3) {
                    // text node
                    acc.push({ type: ojexpparser.LITERAL, value: node.nodeValue });
                }
                else if (node.nodeType === 1) {
                    // element
                    acc.push(this._createElementNode(engineContext, node));
                }
                return acc;
            }, []);
            return arrayNode;
        }
        /**
         * Creates AST node for oj-bind-* elements.
         * Returns null otherwise.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         */
        _processSpecialNodes(engineContext, node) {
            if (node.nodeType === 1) {
                switch (node.tagName.toLowerCase()) {
                    case 'oj-bind-text':
                        return this._createExpressionNode(engineContext, node.getAttribute('value'));
                    case 'oj-bind-if':
                        return this._createIfExpressionNode(engineContext, node);
                    case 'oj-bind-for-each':
                        return this._createBindForEachExpressionNode(engineContext, node);
                    case 'oj-bind-dom':
                        return this._createBindDomExpressionNode(engineContext, node);
                    case 'oj-bind-template-slot':
                        return this._createBindTemplateNode(engineContext, node);
                    case 'oj-defer':
                        return this._createDeferNode(engineContext, node);
                    case 'oj-if':
                        return this._createIfNode(engineContext, node);
                    case 'template':
                        // The template case is added to handle custom elements that have template slots
                        // with an exception of oj-bind-for-each element which is handled
                        // by _createBindForEachExpressionNode() method.
                        return this._createTemplateWithRenderCallback(engineContext, node);
                }
            }
            return null;
        }
        /**
         * Creates an AST node for oj-bind-template slot element. The context for the template is determined
         * at evaluation time and it is based on whether the template is default or external.
         * @param engineContext
         * @param node
         */
        _createBindTemplateNode(engineContext, node) {
            // Build name and data property evaluators to be resolved for the template.
            const templateProps = {
                type: ojexpparser.OBJECT_EXP,
                properties: []
            };
            const slotName = node.getAttribute('name') || '';
            templateProps.properties.push(this._getAttribute(engineContext, 'name', slotName));
            const templateData = node.getAttribute('data');
            if (templateData) {
                templateProps.properties.push(this._getAttribute(engineContext, 'data', templateData));
            }
            const alias = node.getAttribute('as');
            return this._createCallNodeWithContext((bindingContext, resolvedProps) => {
                const dataProp = resolvedProps.data;
                const nameProp = resolvedProps.name;
                const slots = engineContext[BINDING_CONTEXT]['__oj_slots'];
                const slotChildren = slots[nameProp];
                let template = slotChildren && slotChildren[slotChildren.length - 1];
                let isDefaultTemplate = false;
                if (!template) {
                    for (let child in node.childNodes) {
                        if (node.childNodes[child].nodeName === 'TEMPLATE') {
                            template = node.childNodes[child];
                            isDefaultTemplate = true;
                            break;
                        }
                    }
                }
                // Handle the case of an external template that was already preprocessed by the template engine
                // so the render() property is on the template and the binding context is prebound to render() method.
                // See JET-51337 for details.
                if (template && template.render) {
                    return template.render(dataProp);
                }
                if (template) {
                    const templateAst = this._getAstViaCache(engineContext, template);
                    const templateAlias = template.getAttribute('data-oj-as');
                    const templateCtx = this._getContext(engineContext[BINDING_PROVIDER], isDefaultTemplate
                        ? engineContext[COMPONENT_ELEMENT]
                        : engineContext[BINDING_CONTEXT]['__oj_composite'], template, dataProp, isDefaultTemplate ? alias : null, templateAlias);
                    return this._cspEvaluator.evaluate(templateAst, {
                        $context: templateCtx,
                        $h: preact.h,
                        BindDom
                    });
                }
            }, [templateProps]);
        }
        /**
         * A method that creates an AST node for a template element where a child content is wrapped into a render callback.
         * It is expected that the parent element would either use the template engine to process the template (legacy components case)
         * or check for render property and user the provided callback directly (vcomponent case).
         * @param {VTemplateEngineContext} engineContext
         * @param {Element} node template node
         */
        _createTemplateWithRenderCallback(engineContext, node) {
            const templateAlias = node.getAttribute('data-oj-as');
            const getAstFromCacheFunc = this._getAstViaCache.bind(this);
            const evaluator = this._cspEvaluator;
            const renderProp = {
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: 'render' },
                value: {
                    type: ojexpparser.LITERAL,
                    value: (itemContext, provided) => {
                        // We copy binding context into a new object and add additional entries
                        // for the current item and a template alias.
                        // Then we add the new binding context to a fresh copy of engine context
                        // in order to preserve the context for elements outside of the nested templates
                        // and provide inner nested templates with the correct data, e.g.
                        // when a cell template is inside of a collection template and
                        // a collection template alias is used inside of the cell template.
                        // Note that COMPONENT_ELEMENT is a parent that owns an initial template slot and
                        // it is needed by oj-bind-for-each code to register busy state.
                        const ctx = Object.assign({}, engineContext[BINDING_CONTEXT], {
                            $current: itemContext
                        });
                        if (templateAlias) {
                            ctx[templateAlias] = itemContext;
                        }
                        // Merge $provided contexts if the 'provided' argument is given.
                        if (ctx['$provided'] && provided) {
                            const merged = new Map([...ctx['$provided'], ...provided]);
                            ctx['$provided'] = merged;
                        }
                        else if (provided) {
                            ctx['$provided'] = provided;
                        }
                        const engineContextForRenderProp = {
                            [BINDING_CONTEXT]: ctx,
                            [BINDING_PROVIDER]: engineContext[BINDING_PROVIDER],
                            [COMPONENT_ELEMENT]: engineContext[COMPONENT_ELEMENT],
                            [UNWRAP_EXTRAS]: engineContext[UNWRAP_EXTRAS]
                        };
                        const templateAst = getAstFromCacheFunc(engineContextForRenderProp, node);
                        return evaluator.evaluate(templateAst, { $context: ctx, $h: preact.h });
                    }
                }
            };
            let props = this._getElementProps(engineContext, node);
            props.push(renderProp);
            if (engineContext[BINDING_PROVIDER]) {
                // When binding provider is present, the data-oj-use-ko attribute is set on the template element.
                // We need the flag to ensure that the correct version of TemplateEngine is loaded
                // for the nested templates.
                props.push({
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'data-oj-use-ko' },
                    value: { type: ojexpparser.LITERAL, value: '' }
                });
            }
            return this._createHFunctionCallNode('template', [{ type: ojexpparser.OBJECT_EXP, properties: props }]);
        }
        /**
         * A method that creates content for oj-defer element.
         * @param {VTemplateEngineContext} engineContext
         * @param {Array<Node>} nodes child nodes for oj-defer
         * @param {object} context object used to resolve oj-defer expressions
         * @returns BindDom component
         */
        _createDeferContent(engineContext, nodes, context) {
            const bindDomConfig = { view: nodes, data: context };
            const bindDomProps = {
                config: Promise.resolve(bindDomConfig),
                bindingProvider: engineContext[BINDING_PROVIDER],
                executeFragment: this.executeFragment.bind(this)
            };
            return preact.h(BindDom, bindDomProps);
        }
        /**
         * Creates oj-defer element with special properties and AST that will be evaluated on demand.
         * @param {VTemplateEngineContext} engineContext
         * @param {Element} node
         */
        _createDeferNode(engineContext, node) {
            // The deferContent is BindDom component used as a child of oj-defer element.
            // Initially BindDom is created with an empty config property. We will pass a new
            // config  to BindDom on _activateSubtree() method call.
            let deferContent = this._createDeferContent(engineContext, [], {});
            // The deferNode is used to populate oj-defer element on mount and to clean it up on unmount.
            let deferNode;
            const deferProps = [
                // The ref callback is used in order to add BindDom component as a child of oj-defer
                // when the element is mounted, then clean up when the element is unmounted,
                // i.e. when refObj is set to null.
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'ref' },
                    value: {
                        type: ojexpparser.LITERAL,
                        value: (refObj) => {
                            if (refObj) {
                                deferNode = refObj;
                                preact.render(deferContent, deferNode);
                            }
                            else {
                                preact.render(null, deferNode);
                            }
                        }
                    }
                },
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: '_activateSubtree' },
                    value: this._createCallNodeWithContext((context) => {
                        return (parentNode) => {
                            deferContent = this._createDeferContent(engineContext, Array.from(node.childNodes), context);
                            preact.render(deferContent, parentNode);
                        };
                    })
                }
            ];
            let props = this._getElementProps(engineContext, node);
            props = props.concat(deferProps);
            return this._createHFunctionCallNode('oj-defer', [{ type: ojexpparser.OBJECT_EXP, properties: props }]);
        }
        /**
         * Creates AST node for oj-bind-if element.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         */
        _createIfExpressionNode(engineContext, node) {
            if (!node.hasAttribute('test')) {
                throw new Error("Missing the required 'test' attribute on <oj-bind-if>");
            }
            return {
                type: ojexpparser.UNARY_EXP,
                operator: '...',
                argument: this._createIfTestNode(engineContext, node)
            };
        }
        /**
         * Creates AST node for oj-if element.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         */
        _createIfNode(engineContext, node) {
            if (!node.hasAttribute('test')) {
                throw new Error("Missing the required 'test' attribute on <oj-if>");
            }
            const props = this._getElementProps(engineContext, node);
            props.push(this._createPropertyNode(engineContext, 'style', 'display:contents;'));
            return this._createHFunctionCallNode('oj-if', [
                { type: ojexpparser.OBJECT_EXP, properties: props },
                this._createIfTestNode(engineContext, node)
            ]);
        }
        /**
         * Creates AST for 'test' attribute on oj-if and oj-bind-if nodes as conditional expression.
         * @param engineContext
         * @param node
         */
        _createIfTestNode(engineContext, node) {
            return {
                type: ojexpparser.CONDITIONAL_EXP,
                test: this._createExpressionNode(engineContext, node.getAttribute('test')),
                consequent: this._createAst(engineContext, Array.from(node.childNodes)),
                alternate: {
                    type: ojexpparser.LITERAL,
                    value: []
                }
            };
        }
        /**
         * Creates AST node for BindForEachWrapper virtual component that will replace oj-bind-for-each element.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         */
        _createBindForEachExpressionNode(engineContext, node) {
            const template = node.getElementsByTagName('template')[0];
            if (!template) {
                throw new Error('Template not found: oj-bind-for-each requires a single template element as its direct child');
            }
            return this._createComponentNode(engineContext, node, BindForEachWrapper, [
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'itemRenderer' },
                    value: this._createNestedTemplateRendererNode(engineContext, template)
                },
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'componentElement' },
                    value: { type: ojexpparser.LITERAL, value: engineContext[COMPONENT_ELEMENT] }
                }
            ]);
        }
        /**
         * Creates AST node for inner oj-bind-for-each template
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} template
         */
        _createNestedTemplateRendererNode(engineContext, template) {
            const templateAlias = template.getAttribute('data-oj-as');
            // The UNWRAP_EXTRAS property contains a function used by an expression evaluator
            // to handle 'observableIndex' property which is a special case - the 'observableIndex' is function,
            // but it should behave as an observable.
            const foreachEngineContext = {
                [BINDING_PROVIDER]: engineContext[BINDING_PROVIDER],
                [BINDING_CONTEXT]: engineContext[BINDING_CONTEXT],
                [COMPONENT_ELEMENT]: engineContext[COMPONENT_ELEMENT],
                [TEMPLATE_ELEMENT]: engineContext[TEMPLATE_ELEMENT],
                [TEMPLATE_ALIAS]: engineContext[TEMPLATE_ALIAS],
                [UNWRAP_EXTRAS]: (exp, value) => {
                    if (typeof value === 'function' &&
                        (exp === '$current.observableIndex' || exp === `${templateAlias}.observableIndex`)) {
                        return value();
                    }
                    return value;
                }
            };
            const ast = this._getAstViaCache(foreachEngineContext, template);
            return this._createCallNodeWithContext(($context) => {
                return (props) => {
                    const proxy = this._createProxyForCurrentObj(props);
                    const extension = { $current: proxy };
                    if (templateAlias != null) {
                        extension[templateAlias] = proxy;
                    }
                    // We are not going through _getContext() becasue we never want to get the bidning context from
                    // the parent element and call .extend() on it
                    const context = Object.assign({}, $context, extension);
                    return this._cspEvaluator.evaluate(ast, { $context: context, $h: preact.h });
                };
            });
        }
        /**
         * Creates AST node for HTML element not covered by special cases - oj-bind-*
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         */
        _createElementNode(engineContext, node) {
            const props = this._getElementProps(engineContext, node);
            const tagName = node.tagName;
            const localName = tagName.toLowerCase();
            const compMetadata = ojcustomelementRegistry.getMetadata(tagName);
            const extendedProps = this._createPossiblyProvidedAndConsumedProperties(localName, engineContext, compMetadata, props);
            const elementNode = this._createHFunctionCallNode(localName, [
                // properties
                this._reorderProps(extendedProps),
                // children
                this._createAst(engineContext, Array.from(node.childNodes))
            ]);
            if (node.hasAttribute('data-oj-manage-tabs')) {
                // JET-54400 - support legacy tabbable mode in template compilation
                // Wrap the node that has data-oj-manage-tabs into ManageTabStops component.
                return this._createComponentNode(engineContext, null, ojpreactManagetabstops.ManageTabStops, [
                    {
                        type: ojexpparser.PROPERTY,
                        key: { type: ojexpparser.LITERAL, value: 'children' },
                        value: elementNode
                    }
                ]);
            }
            return elementNode;
        }
        /**
         * Reorders resolved properties of a given AST node that represents element properties.
         * When the resolved properties object contains private identifiers, those are placed at the start of the object.
         * @param {object} propertyNode AST node which can be an ObjectExpression or a CallExpression that resolves into properties.
         * @returns {object}
         */
        _reorderProps(propertyNode) {
            const extraArgs = propertyNode.type == ojexpparser.OBJECT_EXP ? [propertyNode] : undefined;
            const isCallExpression = propertyNode.type == ojexpparser.CALL_EXP;
            const reorderProps = (originalProps) => {
                if (!originalProps.__oj_private_identifier_to_prop) {
                    return originalProps;
                }
                const { __oj_private_identifier_to_prop, __oj_private_identifier_to_value, ...remainingProps } = originalProps;
                return {
                    __oj_private_identifier_to_prop,
                    __oj_private_identifier_to_value,
                    ...remainingProps
                };
            };
            const callback = (context, resolvedProps) => {
                const originalProps = isCallExpression
                    ? this._cspEvaluator.evaluate(propertyNode, { $context: context, $h: preact.h, BindDom })
                    : resolvedProps;
                return reorderProps(originalProps);
            };
            return this._createCallNodeWithContext(callback, extraArgs);
        }
        /**
         * For properrties that have provide and/or consume metadata, adds code to store provided values
         * on the runtime context ($context) and to retrieve consumed values from the runtime context
         * @param localTagName
         * @param engineContext
         * @param provideConsumeMeta
         * @param props
         */
        _createPossiblyProvidedAndConsumedProperties(localTagName, engineContext, compMetadata, props) {
            const propertyObjectNode = {
                type: ojexpparser.OBJECT_EXP,
                properties: props
            };
            const provideConsumeMeta = ojbindpropagation.getPropagationMetadataViaCache(localTagName, compMetadata);
            if (!provideConsumeMeta) {
                return propertyObjectNode;
            }
            const specifiedProps = new Set();
            props.reduce((acc, def) => acc.add(def.key.value), specifiedProps);
            const consumingProps = [];
            const unwrap = this._getUnwrapObservable(engineContext);
            // eslint-disable-next-line no-restricted-syntax
            for (const [pName, meta] of provideConsumeMeta) {
                const consumeMeta = meta[1];
                if (consumeMeta) {
                    if (pName === ojbindpropagation.CONSUMED_CONTEXT) {
                        // Pass context values via __oj_provided_contexts property to make it available to the
                        // EnvironmentWrapper class.
                        // Note that we cannot use __oj_private_contexts property here as it is done in CustomElementBinding code.
                        // This context will be processed by EnvironmentWrapper class and that needs to differenciate between
                        // provided context and stale context on memoized Preact children. See JET-68575 for use-case.
                        // The EnvironmentWrapper will use the providedValues,  determines what should be set as __oj_private_contexts property.
                        // Then __oj_private_contexts value will be used by ComponentWithContext class to create appropriate Preact context providers.
                        consumingProps.push({
                            type: ojexpparser.PROPERTY,
                            key: { type: ojexpparser.LITERAL, value: '__oj_provided_contexts' },
                            value: this._createCallNodeWithContext(($ctx) => {
                                let providedValues;
                                const provided = unwrap($ctx)?.[_PROVIDED_KEY];
                                consumeMeta.forEach((preactContext) => {
                                    if (provided?.has(preactContext)) {
                                        if (!providedValues) {
                                            providedValues = new Map();
                                        }
                                        providedValues.set(preactContext, unwrap(provided.get(preactContext)));
                                    }
                                });
                                return providedValues;
                            })
                        });
                    }
                    else if (
                    // check for the original property name and the uppercase version in case we are setting an attribute with an uppercase for automatic coercion by the component
                    !(specifiedProps.has(pName) ||
                        specifiedProps.has(ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(pName).toUpperCase()))) {
                        consumingProps.push({
                            type: ojexpparser.PROPERTY,
                            key: { type: ojexpparser.LITERAL, value: pName },
                            value: this._createCallNodeWithContext(($ctx) => {
                                const provided = unwrap($ctx)?.[_PROVIDED_KEY];
                                if (provided) {
                                    return unwrap(provided.get(consumeMeta.name));
                                }
                            })
                        });
                    }
                }
            }
            const propertyObjNodeWithConsumers = consumingProps.length === 0
                ? propertyObjectNode
                : { type: ojexpparser.OBJECT_EXP, properties: propertyObjectNode.properties.concat(consumingProps) };
            const metadataProps = compMetadata.properties;
            return this._createCallNodeWithContext(($ctx, resolvedProps) => {
                let provided = new Map();
                let hasProvided;
                for (const [pName, [provideMeta]] of provideConsumeMeta) {
                    if (provideMeta) {
                        provideMeta.forEach((info) => {
                            let propVal;
                            let isSet = true;
                            if (pName === ojbindpropagation.STATIC_PROPAGATION) {
                                isSet = false;
                            }
                            else if (resolvedProps.hasOwnProperty(pName)) {
                                propVal = resolvedProps[pName];
                            }
                            else {
                                // check for a literal value set as an uppercase attribute
                                const attr = ojcustomelementUtils.AttributeUtils.propertyNameToAttribute(pName);
                                const uppercaseAttr = attr.toUpperCase();
                                if (resolvedProps.hasOwnProperty(uppercaseAttr)) {
                                    propVal = resolvedProps[uppercaseAttr];
                                    const type = metadataProps?.[pName]?.type;
                                    if (type && propVal != null) {
                                        propVal = ojcustomelementUtils.AttributeUtils.parseAttributeValue(localTagName, attr, propVal, type);
                                    }
                                }
                                else {
                                    isSet = false;
                                }
                            }
                            const defaultKey = 'default';
                            if (!isSet) {
                                if (info.hasOwnProperty(defaultKey)) {
                                    propVal = info[defaultKey];
                                    isSet = true;
                                }
                            }
                            else {
                                const transform = info.transform;
                                propVal =
                                    transform && transform.hasOwnProperty(propVal) ? transform[propVal] : propVal;
                            }
                            if (isSet) {
                                hasProvided = true;
                                provided.set(info.name, propVal);
                            }
                        });
                    }
                }
                if (hasProvided) {
                    const oldProvided = $ctx[_PROVIDED_KEY];
                    if (oldProvided !== undefined) {
                        provided = new Map([...oldProvided, ...provided]);
                    }
                    $ctx[_PROVIDED_KEY] = provided;
                }
                return resolvedProps;
            }, [propertyObjNodeWithConsumers]);
        }
        /**
         * Creates AST node for BindDom virtual component. The BindDom component will receive
         * a configuration wrapped into a Promise and a binding provider (if available)
         * to handle ko mutations.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         */
        _createBindDomExpressionNode(engineContext, node) {
            if (!node.hasAttribute('config')) {
                throw new Error("Missing the required 'config' attribute on <oj-bind-dom>");
            }
            const configValue = node.attributes['config'].value;
            const props = [
                this._createPropertyNode(engineContext, 'config', configValue, (config) => Promise.resolve(config)),
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'bindingProvider' },
                    value: { type: ojexpparser.LITERAL, value: engineContext[BINDING_PROVIDER] }
                },
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'componentElement' },
                    value: { type: ojexpparser.LITERAL, value: engineContext[COMPONENT_ELEMENT] }
                },
                {
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'executeFragment' },
                    value: { type: ojexpparser.LITERAL, value: this.executeFragment.bind(this) }
                }
            ];
            return this._createHFunctionCallNode(BindDom, [{ type: ojexpparser.OBJECT_EXP, properties: props }]);
        }
        /**
         * Create AST node for the specified preact component.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {Element} node
         * @param {BindDom} component vcomponent constructor
         * @param {Array} extraProps extra properties to be passed to the virtual component
         */
        _createComponentNode(engineContext, node, component, extraProps) {
            let props = node ? this._getElementProps(engineContext, node) : [];
            props = extraProps ? props.concat(extraProps) : props;
            return this._createHFunctionCallNode(component, [{ type: ojexpparser.OBJECT_EXP, properties: props }]);
        }
        _createPropertyNode(engineContext, key, value, postprocess) {
            return {
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: key },
                value: this._createExpressionNode(engineContext, value, postprocess)
            };
        }
        /**
         * Converts class name values into space separated string.
         * @param val
         */
        _postprocessClassNameValue(val) {
            let newVal;
            if (Array.isArray(val)) {
                newVal = val.join(' ');
            }
            else if (typeof val !== 'string') {
                newVal = Object.keys(val)
                    .reduce((acc, key) => {
                    if (val[key]) {
                        acc.push(key);
                    }
                    return acc;
                }, [])
                    .join(' ');
            }
            else {
                newVal = val;
            }
            return newVal;
        }
        /**
         * The method processes attributes on the given node and converts them into an array of AST nodes
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param node
         */
        _getElementProps(engineContext, node) {
            let styleValue; // the value for the "style" attribute as a whole
            const dotStyleValues = []; // individual styles bound with the :style.xxx syntax
            const dottedExpressions = [];
            const writebacks = new Map();
            const listeners = new Map();
            // See JET-69225. The identifiersMap is used to accumulate identifiers bound to
            // non-primitive property types in JET components. The map
            // has prop->[..identifiers] structure, since each property is evaluated separately.
            const identifiersMap = new Map();
            let shouldCreateIdentifierProps = false;
            const attrNodes = Array.prototype.reduce.call(node.attributes, (acc, attr) => {
                let name = attr.name;
                const value = attr.value;
                if (name.startsWith(':')) {
                    name = name.substring(1);
                    const parts = name.split('.');
                    if (parts.length === 2 && parts[0] === 'style') {
                        dotStyleValues.push({ k: parts[1], v: value });
                    }
                    else if (name === 'style') {
                        styleValue = value;
                    }
                    else if (name === 'class') {
                        acc.push(this._createPropertyNode(engineContext, 'className', value, this._postprocessClassNameValue));
                    }
                    else {
                        if (ojcustomelementUtils.AttributeUtils.isGlobalOrData(name)) {
                            name = ojcustomelementUtils.AttributeUtils.getGlobalPropForAttr(name);
                        }
                        else {
                            // TODO: deal with native attributes with non-standard property names (we need getNativePropForAttr())
                            name = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(name);
                        }
                        acc.push(this._createPropertyNode(engineContext, name, value));
                    }
                }
                else {
                    const expValue = ojcustomelementUtils.AttributeUtils.getExpressionInfo(value);
                    if (ojcustomelementUtils.AttributeUtils.isEventListenerAttr(name)) {
                        // At the moment we will just push a listener into the listeners array
                        // in order to process them later when we done with writeback properties,
                        // because some of the listeners should be wrapped into writeback callback.
                        name = ojcustomelementUtils.AttributeUtils.eventAttrToPreactPropertyName(name);
                        listeners.set(name, value);
                    }
                    else if (ojcustomelementUtils.AttributeUtils.isGlobalOrData(name)) {
                        acc.push(this._createPropertyNode(engineContext, ojcustomelementUtils.AttributeUtils.getGlobalPropForAttr(name), value));
                    }
                    else {
                        const propName = ojcustomelementUtils.AttributeUtils.attributeToPropertyName(name);
                        const propNamePath = propName.split('.');
                        // Check whether we need to store identifiers for this component/property combination.
                        const keepIdentifiersForProp = this._keepIdentifiers(node, propNamePath[0]);
                        shouldCreateIdentifierProps = shouldCreateIdentifierProps || keepIdentifiersForProp;
                        if (expValue.expr) {
                            const propMeta = ojmetadatautils.getPropertyMetadata(propNamePath[0], ojcustomelementRegistry.getPropertiesForElementTag(node.tagName));
                            // Check property metadata for readonly case.
                            if (!propMeta?.readOnly) {
                                if (propNamePath.length > 1) {
                                    // handle dotted properties
                                    // We will accumulate the nested properties and handle them later all together by setting them via 'ref' object callback.
                                    // In this case we are able to handle all property types including objects.
                                    dottedExpressions.push({ subProps: propName, expr: expValue.expr });
                                }
                                else {
                                    // Callback used to populate identifiersMap.
                                    const identifiersCallbackFn = keepIdentifiersForProp
                                        ? (items) => {
                                            identifiersMap.set(propName, items);
                                        }
                                        : null;
                                    acc.push({
                                        type: ojexpparser.PROPERTY,
                                        key: { type: ojexpparser.LITERAL, value: propName },
                                        value: this._createExpressionEvaluator(engineContext, expValue.expr, null, identifiersCallbackFn)
                                    });
                                }
                            }
                            // Handle writeback expressions
                            if (!expValue.downstreamOnly && propMeta?.writeback) {
                                let subProps = propNamePath;
                                const topProp = subProps.shift();
                                let valuesArray = writebacks.get(topProp);
                                if (valuesArray) {
                                    let newValuesArray = [
                                        ...valuesArray,
                                        { expr: expValue.expr, subProps: subProps }
                                    ];
                                    valuesArray = newValuesArray;
                                }
                                else {
                                    valuesArray = [{ expr: expValue.expr, subProps: subProps }];
                                }
                                writebacks.set(topProp, valuesArray);
                            }
                        }
                        else if (name[0] === 'o' && name[1] === 'n') {
                            // An event listener with a literal property must be an inline event handler.
                            // While this is not CSP-compliant, we don't want to regress this case, so we'll
                            // continue setting these as attributes so that Preact doesn't complain when it tries
                            // to process the prop with a non-function value
                            acc.push({
                                type: ojexpparser.PROPERTY,
                                key: { type: ojexpparser.LITERAL, value: name.toUpperCase() },
                                value: { type: ojexpparser.LITERAL, value: value }
                            });
                        }
                        else {
                            // This is the case where the template contains a literal value.
                            // The value is coerced the same way as it is done by custom element setters and set
                            // as a property. Object and array values are cached.
                            // Notice that we are using the same 'ref' property approach
                            // for the complex (dotted) properties as it is done for the expressions in the code
                            // above.
                            const parsedValue = this._getLiteralValueViaCache(engineContext, node, name, propName, value);
                            if (propNamePath.length > 1) {
                                dottedExpressions.push({
                                    subProps: propName,
                                    expr: { type: ojexpparser.LITERAL, value: parsedValue }
                                });
                            }
                            else {
                                acc.push({
                                    type: ojexpparser.PROPERTY,
                                    key: { type: ojexpparser.LITERAL, value: propName },
                                    value: { type: ojexpparser.LITERAL, value: parsedValue }
                                });
                            }
                        }
                    }
                }
                return acc;
            }, []);
            if (styleValue != null) {
                if (dotStyleValues.length > 0) {
                    throw new Error('Binding the entire style attribute as well as ' +
                        'the individual style properties on the same element is not supported');
                }
                attrNodes.push(this._createPropertyNode(engineContext, 'style', styleValue));
            }
            else if (dotStyleValues.length > 0) {
                attrNodes.push({
                    type: ojexpparser.PROPERTY,
                    key: { type: ojexpparser.LITERAL, value: 'style' },
                    value: {
                        type: ojexpparser.OBJECT_EXP,
                        properties: dotStyleValues.map((dotStyleVal) => {
                            return this._createPropertyNode(engineContext, ojcustomelementUtils.AttributeUtils.attributeToPropertyName(dotStyleVal.k), dotStyleVal.v);
                        })
                    }
                });
            }
            if (dottedExpressions.length > 0) {
                attrNodes.push(this._createRefPropertyNodeForNestedProps(engineContext, dottedExpressions));
            }
            writebacks.forEach((valuesArray, name) => {
                const propName = `on${name}Changed`;
                const callbackPropExpr = listeners.get(propName);
                if (callbackPropExpr) {
                    listeners.delete(propName);
                }
                attrNodes.push(this._createWritebackPropertyNode(engineContext, name, propName, valuesArray, ojcustomelementUtils.AttributeUtils.getExpressionInfo(callbackPropExpr)?.expr));
            });
            listeners.forEach((value, name) => {
                const info = ojcustomelementUtils.AttributeUtils.getExpressionInfo(value);
                if (info.expr) {
                    attrNodes.push(this._createEventListenerPropertyNode(engineContext, name, info.expr));
                }
            });
            // Populate private properties dedicated to expression identifiers if those are discovered
            if (shouldCreateIdentifierProps) {
                this._populateIdentifierProps(engineContext, attrNodes, identifiersMap);
            }
            return attrNodes;
        }
        /**
         * Gets the literal value for the property.
         * The value is coerced the same way as it is done by custom element setters (See JET-44940).
         * Complex literal values are stored in the cache and shared across templates with the same id.
         * It is done to cover the use-case when the same template is cloned by the caller on update (see JET-70375),
         * we expect the literals to stay identical for the cloned templates. The goal here is to make Preact
         * to recognize those values as identical on updates and avoid running extra setProperty() call.
         *
         * @param engineContext
         * @param propName
         * @param value
         */
        _getLiteralValueViaCache(engineContext, node, name, propName, value) {
            const propMeta = ojmetadatautils.getPropertyMetadata(propName, ojcustomelementRegistry.getPropertiesForElementTag(node.tagName));
            if (!propMeta) {
                return value;
            }
            const templateId = engineContext[TEMPLATE_ELEMENT]?.id;
            const key = templateId ? JSON.stringify([templateId, propName, value]) : null;
            let propertyValue = key ? _LITERALS_CACHE.get(key) : null;
            if (!propertyValue) {
                propertyValue = ojcustomelementUtils.CustomElementUtils.parseAttrValue(node, name, propName, value, propMeta);
                if (key && (typeof propertyValue == 'object' || Array.isArray(propertyValue))) {
                    _LITERALS_CACHE.set(key, propertyValue);
                }
            }
            return propertyValue;
        }
        /**
         * Creates AST node for the 'ref' property with a callback to the parent element.
         * This is done is order to support nested properties that might be bound to expressions
         * that resolve into objects.
         * @param engineContext engine context object for the template
         * @param dottedExpressions an array of objects with the following struture:
         *   - subProps - a string that represents a subproperty chain for a dotted attribute
         *   - expr - an expression that should be resolved and set to the subprop branch or it might be a object
         *          that contains a LITERAL value and a type that indicates that the value should be treated as literal.
         * @return {PROP_NODE} AST node for the 'ref' property
         */
        _createRefPropertyNodeForNestedProps(engineContext, dottedExpressions) {
            const dottedPropObjectNodes = dottedExpressions.map(({ subProps, expr }) => ({
                type: ojexpparser.OBJECT_EXP,
                properties: [
                    {
                        type: ojexpparser.PROPERTY,
                        key: { type: ojexpparser.LITERAL, value: subProps },
                        value: expr['type'] === ojexpparser.LITERAL
                            ? { type: ojexpparser.LITERAL, value: expr['value'] }
                            : this._createExpressionEvaluator(engineContext, expr)
                    }
                ]
            }));
            const dottedPropsArrayNode = {
                type: ojexpparser.ARRAY_EXP,
                elements: dottedPropObjectNodes
            };
            const cb = VTemplateEngine._nestedPropsRefCallback;
            return {
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: 'ref' },
                // _createCallNodeWithContext will pass both $context and an array of resolved dot properties to its callback.
                // We will be using bind() as the implementation of the callback to pre-bind the first argument (resolved nested properties) to the
                // static ref callback implementation below.
                // So the function being passed to _createCallNodeWithContext() is actually Function.prototype.bind.
                // Being an unbound function, it needs to be pre-bound to cb
                value: this._createCallNodeWithContext(Function.prototype.bind.bind(cb, engineContext[BINDING_PROVIDER]), [dottedPropsArrayNode])
            };
        }
        static _nestedPropsRefCallback(bindingProvider, resolvedSubPropValues, refObj) {
            if (refObj && refObj.setProperties) {
                // Filter out property values that have not changed
                const oldValues = VTemplateEngine._getPreviousNestedPropValues(refObj);
                const modifiedSubPropValues = resolvedSubPropValues.filter((record) => {
                    const propPath = Object.keys(record)[0]; // only one key is expected in the object
                    const value = record[propPath];
                    return oldValues?.[propPath] !== value;
                });
                const newValues = Object.assign({}, ...modifiedSubPropValues);
                VTemplateEngine._setUpdatedNestedPropValues(refObj, newValues);
                refObj.setProperties(newValues);
            }
        }
        static _getPreviousNestedPropValues(refObj) {
            return refObj[PREVIOUS_DOT_PROPS_VALUES];
        }
        static _setUpdatedNestedPropValues(refObj, newValues) {
            let map = refObj[PREVIOUS_DOT_PROPS_VALUES];
            if (!map) {
                map = {};
                refObj[PREVIOUS_DOT_PROPS_VALUES] = map;
            }
            Object.assign(map, newValues);
        }
        /**
         * Creates AST node for on[Value]Changed event listener to support value writeback.
         * Since the element might have multiple writable subproperties, the method sets a listener for the top level property,
         * which will handle writebacks for all subroperties.
         *
         * If the element already had the listener, then that listener will be wrapped into created callback
         * which will updated the value, then call the original listener.
         *
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {string} property name
         * @param {string} eventPropName on[Value]Changed listener prop name
         * @param {Array<{subProps:Array<string>, expr: string}>} valuesArray an array of objects with the following fiends:
         *      - subProps - an array of subproperties for a single dotted attribute chain, e.g. nested-prop.sub-prop.sub-sub-prop = '[[expr]]'
         *      - expr - a writable expression for the given dotted attribute
         * @param {string | undefined} existingCallbackExpr existing on[Value]Changed expression
         * @returns object
         */
        _createWritebackPropertyNode(engineContext, property, eventPropName, valuesArray, existingCallbackExpr) {
            const propExprEvaluators = [];
            let callbackExprEvaluator;
            return {
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: eventPropName },
                value: this._createCallNodeWithContext((bindingContext) => {
                    return (event) => {
                        valuesArray.forEach((propItem, index) => {
                            let newValue = event.detail.value;
                            var subProps = propItem.subProps;
                            var propExpr = propItem.expr;
                            if (subProps.length > 0 && typeof newValue === 'object') {
                                newValue = subProps.reduce((acc, cur) => acc[cur], newValue);
                            }
                            let propExprEvaluator = propExprEvaluators[index];
                            if (!propExprEvaluator) {
                                propExprEvaluator = this._cspEvaluator.createEvaluator(propExpr).evaluate;
                                propExprEvaluators.push(propExprEvaluator);
                            }
                            const value = propExprEvaluator([bindingContext, bindingContext.$data]);
                            let writer;
                            if (engineContext[BINDING_PROVIDER] &&
                                engineContext[BINDING_PROVIDER].__IsObservable(value)) {
                                writer = value;
                            }
                            else {
                                const writerExpr = this._getPropertyWriterExpression(propExpr);
                                if (writerExpr !== null) {
                                    const writerEvaluator = this._cspEvaluator.createEvaluator(writerExpr).evaluate;
                                    writer = this._getWriter(writerEvaluator([bindingContext.$data || {}, bindingContext]));
                                }
                            }
                            ojmonitoring.performMonitoredWriteback(property, writer, event, newValue);
                        });
                        // Then call existing callback if it is available.
                        if (existingCallbackExpr && !callbackExprEvaluator) {
                            callbackExprEvaluator =
                                this._cspEvaluator.createEvaluator(existingCallbackExpr).evaluate;
                        }
                        const existingCallback = callbackExprEvaluator
                            ? callbackExprEvaluator([bindingContext, bindingContext.$data])
                            : null;
                        if (existingCallback) {
                            existingCallback(event, _proxyUnwrap(bindingContext.$current) || bindingContext.$data, bindingContext);
                        }
                    };
                })
            };
        }
        /**
         * Creates AST node for an event listener.
         * An original listener will be wrapped into a function in order to pass additional arguments to the listener.
         * @param {string} propName listener property name
         * @param {string} propExpr listener property expression
         * @returns {PROP_NODE}
         */
        _createEventListenerPropertyNode(engineContext, propName, propExpr) {
            let propExprEvaluator;
            return {
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: propName },
                value: this._createCallNodeWithContext((bindingContext) => {
                    return (event) => {
                        if (!propExprEvaluator) {
                            propExprEvaluator = this._cspEvaluator.createEvaluator(propExpr).evaluate;
                        }
                        const unwrappedContext = _unwrapBindingContext(bindingContext, engineContext[TEMPLATE_ALIAS]);
                        const listener = propExprEvaluator([unwrappedContext, unwrappedContext.$data]);
                        if (listener) {
                            listener(event, unwrappedContext.$current || unwrappedContext.$data, unwrappedContext);
                        }
                    };
                })
            };
        }
        /**
         * Creates AST node that for expression evaluation
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param attrVal
         * @param postprocess
         */
        _createExpressionNode(engineContext, attrVal, postprocess) {
            const info = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrVal);
            return info.expr
                ? this._createExpressionEvaluator(engineContext, info.expr, postprocess)
                : { type: ojexpparser.LITERAL, value: attrVal };
        }
        /**
         * Creates an AST node for expression type.
         * The function will trigger Proxy wrapper around $current property when the property is accessed.
         * The identifiers for the given expression are accumulated on this._expressionPaths member and
         * will be used when identifiersCallbackFn is present.
         * @param {VTemplateEngineContext} engineContext engine context object for the template
         * @param {string} exp expression to be evaluated
         * @param {Function} postprocess
         * @param {Function} identifiersCallbackFn callback used to populate identifiersMap
         * @return callback function that evaluates an expression based on context
         */
        _createExpressionEvaluator(engineContext, exp, postprocess, identifiersCallbackFn) {
            const delegateEvaluator = this._cspEvaluator.createEvaluator(exp).evaluate;
            return this._createCallNodeWithContext(($context) => {
                this._expressionPaths = [];
                const unwrap = this._getUnwrapObservable(engineContext);
                const context = unwrap($context);
                const value = delegateEvaluator([context, context.$data]);
                let unwrapped = unwrap(value);
                if (engineContext[UNWRAP_EXTRAS]) {
                    unwrapped = engineContext[UNWRAP_EXTRAS](exp, unwrapped);
                }
                if (identifiersCallbackFn) {
                    // Clone paths array in the process of fixing each path by appending $current
                    // as root to create a valid expression.
                    identifiersCallbackFn(this._expressionPaths.map((item) => {
                        return { identifier: `$current.${item.identifier}`, value: item.value };
                    }));
                }
                this._expressionPaths = null;
                return postprocess ? postprocess(unwrapped) : unwrapped;
            });
        }
        /**
         * Checks if identifiers should be kept for a given property.
         * @param node
         * @param propName
         * @returns true the node is a JET component and the given property is not a primitive type.
         */
        _keepIdentifiers(node, propName) {
            if (!ojcustomelementRegistry.isElementRegistered(node.tagName))
                return false;
            const propMeta = ojmetadatautils.getPropertyMetadata(propName, ojcustomelementRegistry.getPropertiesForElementTag(node.tagName));
            if (!propMeta)
                return false;
            // Keep identifiers for non-primitive types only - object/array/other/any
            const types = ojcustomelementUtils.ElementUtils.getSupportedTypes(propMeta.type);
            return !!(types.object || types.array || types.other || types.any);
        }
        /**
         * The method is dedicated for creation __oj_private_identifier_to_prop and __oj_private_identifier_to_value
         * for JET components. The values for the properties will be populated at the evaluation time when
         * identifiersMap has fresh entries for the current evaluation cucle.
         * When the identifiersMap is empty, the property value will be set to an empty map to indicate
         * that the component is created by VComponentTemplate and we should handle it the property differently.
         * @param {VTemplateEngineContext} engineContext Engine context object for the template.
         * @param {object[]} attrNodes Array of attribute nodes.
         * @param {Map<string, TemplateIdentifierType>} identifiersMap map of prop -> [...identifiers], the map was populated
         *                                             by evaluation of each property for the component.
         */
        _populateIdentifierProps(engineContext, attrNodes, identifiersMap) {
            // Helper method for inverting a given identifiersMap.
            function invertMap(origMap) {
                const inverted = new Map();
                origMap.forEach((values, key) => {
                    values.forEach(({ identifier }) => {
                        if (!inverted.has(identifier)) {
                            inverted.set(identifier, []);
                        }
                        inverted.get(identifier).push(key);
                    });
                });
                return inverted;
            }
            attrNodes.push({
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: '__oj_private_identifier_to_prop' },
                value: this._createCallNodeWithContext(() => {
                    // Convert map into identifier -> [...props] from
                    // prop -> [...identifiers] format.
                    // Set it as a plain object, that would allow deep compare method to work.
                    return Object.fromEntries(invertMap(identifiersMap));
                })
            });
            attrNodes.push({
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: '__oj_private_identifier_to_value' },
                value: this._createCallNodeWithContext(($context) => {
                    const indentifierToValue = {};
                    const processedIdentifiers = new Set();
                    identifiersMap.forEach((values) => {
                        values.forEach(({ identifier, value }) => {
                            if (!processedIdentifiers.has(identifier)) {
                                const unwrap = this._getUnwrapObservable(engineContext);
                                indentifierToValue[identifier] = unwrap(value);
                                processedIdentifiers.add(identifier);
                            }
                        });
                    });
                    return indentifierToValue;
                })
            });
        }
        _getUnwrapObservable(engineContext) {
            const bp = engineContext[BINDING_PROVIDER];
            return bp ? bp.__UnwrapObservable : _DEFAULT_UNWRAP;
        }
        _createCallNodeWithContext(callback, extaArgs) {
            return {
                type: ojexpparser.CALL_EXP,
                callee: {
                    type: ojexpparser.LITERAL,
                    value: callback
                },
                arguments: extaArgs ? _CONTEXT_PARAM.concat(extaArgs) : _CONTEXT_PARAM
            };
        }
        /**
         * A helper method for an AST node for h() function call that creates a specified
         * element with the provided properties.
         * @param elementName element to create
         * @param extraArgs an array of element properties
         */
        _createHFunctionCallNode(elementName, extraArgs) {
            return {
                type: ojexpparser.CALL_EXP,
                callee: {
                    type: ojexpparser.IDENTIFIER,
                    name: '$h'
                },
                arguments: [
                    {
                        type: ojexpparser.LITERAL,
                        value: elementName
                    },
                    ...extraArgs
                ]
            };
        }
        /**
         * A helper method that creates an AST for the attribute value. The value might be an expression or a litaral.
         * The AST can be used to accumulate props for _createCallNodeWithContext() call that takes extra args, resolved them and
         * passes them into a given callback
         * @param engineContext
         * @param key the property will be created with the given key
         * @param value value that can be an expression or a literal
         */
        _getAttribute(engineContext, key, value) {
            const expr = ojcustomelementUtils.AttributeUtils.getExpressionInfo(value).expr;
            return {
                type: ojexpparser.PROPERTY,
                key: { type: ojexpparser.LITERAL, value: key },
                value: expr
                    ? this._createExpressionEvaluator(engineContext, expr)
                    : { type: ojexpparser.LITERAL, value: value }
            };
        }
        /**
         * Retrieves a writer function from the given evaluator object.
         * @param {object} evaluator
         */
        _getWriter(evaluator) {
            return evaluator['_ko_property_writers'];
        }
        /**
         * Creates an expression that will be used for writing into a non-observable property.
         * @param {string} expression writeback property
         * @return {string} expression that contains a writeback function that will be evaluated against context
         *                and used for updating the value.
         */
        _getPropertyWriterExpression(expression) {
            const _ASSIGNMENT_TARGET_EXP = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;
            const reserveddWords = ['true', 'false', 'null', 'undefined'];
            if (expression == null || reserveddWords.indexOf(expression) >= 0) {
                return null;
            }
            // Remove the white space on both ends to ensure that the _ASSIGNMENT_TARGET_EXP regexp
            // is matched properly
            // eslint-disable-next-line no-param-reassign
            expression = expression.trim();
            // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
            // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
            // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']];).
            const match = expression.match(_ASSIGNMENT_TARGET_EXP);
            if (match === null) {
                return null;
            }
            const target = match[1] ? `Object(${match[1]})${match[2]}` : expression;
            return `{_ko_property_writers: function(v){${target}=v;}}`;
        }
    }

    const templateEngine = new VTemplateEngine();
    const executeFragment = templateEngine.executeFragment.bind(templateEngine);
    const execute = templateEngine.execute.bind(templateEngine);
    const cleanupTemplateCache = VTemplateEngine.cleanupTemplateCache;

    exports.cleanupTemplateCache = cleanupTemplateCache;
    exports.execute = execute;
    exports.executeFragment = executeFragment;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojexpressionutils',['exports', 'ojs/ojconfig', 'ojs/ojcustomelement-utils'], function (exports, Config, ojcustomelementUtils) { 'use strict';

  /**
   * @namespace
   * @name ExpressionUtils
   * @ojtsmodule
   * @since 6.0.0
   * @hideconstructor
   */
  const ExpressionUtils = function () {};

  /**
   * Analyzes a string for a possible JET expression
   * @param {string} expression a string to be analyzed
   * @return {{expr: (null|string), downstreamOnly: boolean}} an object with two keys:
   * use the 'expr' key to get the expression text, and the 'downstreamOnly' to get a boolean
   * indicating whether the expression is downstream-only, i.e. the flag will be true if
   * the expression should not be used for writeback
   * @memberof! ExpressionUtils
   * @static
   */
  ExpressionUtils.getExpressionInfo = function (expression) {
    return ojcustomelementUtils.AttributeUtils.getExpressionInfo(expression);
  };

  /**
   * Creates generic expression evaluator
   * @param {string} expressionText inner expression text not including any decorator characters
   * that identify the string as an expression
   * @return {Function} an evaluator function that will take data context as a parameter
   * @ojsignature {target: "Type", for: "returns",
   *              value: "(context: any)=> any"}
   * @memberof! ExpressionUtils
   * @static
   */
  ExpressionUtils.createGenericExpressionEvaluator = function (expressionText) {
    var factory = Config.getExpressionEvaluator();
    if (factory) {
      var evaluate = factory.createEvaluator(expressionText).evaluate;
      return function (context) {
        return evaluate([context]);
      };
    }

    var evaluator;
    try {
      /* jslint evil:true */
      // eslint-disable-next-line no-new-func
      evaluator = new Function('context', 'with(context){return ' + expressionText + ';}'); // @HTMLUpdateOK binding expression evaluation
    } catch (e) {
      throw new Error(e.message + ' in expression "' + expressionText + '"');
    }
    return evaluator;
  };

  const getExpressionInfo = ExpressionUtils.getExpressionInfo;
  const createGenericExpressionEvaluator = ExpressionUtils.createGenericExpressionEvaluator;

  exports.createGenericExpressionEvaluator = createGenericExpressionEvaluator;
  exports.getExpressionInfo = getExpressionInfo;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtreedataproviderview',['ojs/ojcore-base', 'ojs/ojlistdataproviderview'], function (oj, ListDataProviderView) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    ListDataProviderView = ListDataProviderView && Object.prototype.hasOwnProperty.call(ListDataProviderView, 'default') ? ListDataProviderView['default'] : ListDataProviderView;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 6.2.0
     * @final
     * @export
     * @class TreeDataProviderView
     * @ojtsmodule
     * @implements TreeDataProvider
     * @classdesc Provides optimizations for TreeDataProvider. Supports field mapping. Please see the select demos for examples of DataMapping [Select]{@link oj.ojSelect}
     * @param {DataProvider} dataProvider the DataProvider.
     * @param {TreeDataProviderView.Options=} options Options for the TreeDataProviderView
     * @ojsignature [{target: "Type",
     *               value: "class TreeDataProviderView<K, D, Kin, Din> implements TreeDataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of output key"}, {"name": "D", "description": "Type of output data"},
     *                    {"name": "Kin", "description": "Type of input key"}, {"name": "Din", "description": "Type of input data"}]},
     *               {target: "Type",
     *               value: "TreeDataProvider<K, D>",
     *               for: "dataProvider"},
     *               {target: "Type",
     *               value: "TreeDataProviderView.Options<K, D, Kin, Din>",
     *               for: "options"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     *   "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults", "DataMapping",
     *   "FetchListResult","FetchListParameters", "FetchAttribute"]}
     * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: "TreeDataProvider"}
     */

    /**
     * Optional dataMapping to apply
     *
     *
     * @since 6.2.0
     * @export
     * @expose
     * @memberof TreeDataProviderView
     * @instance
     * @name dataMapping
     * @ojsignature {target: "Type",
     *               value: "?DataMapping<K, D, Kin, Din>"}
     */

    /**
     * @typedef {Object} TreeDataProviderView.Options
     * @property {DataMapping=} dataMapping - mapping to apply to the data.
     * @ojsignature [
     *  {target: "Type", value: "<K, D, Kin, Din>", for: "genericTypeParameters"},
     *  {target: "Type", value: "DataMapping<K, D, Kin, Din>", for: "dataMapping"},
     * ]
     * */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name getChildDataProvider
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * Get an AsyncIterable object for iterating the data.
     * <p>
     * AsyncIterable contains a Symbol.asyncIterator method that returns an AsyncIterator.
     * AsyncIterator contains a next method for fetching the next block of data.
     * </p><p>
     * The "next" method returns a promise that resolves to an object, which contains a "value" property for the data and a "done" property
     * that is set to true when there is no more data to be fetched.  The "done" property should be set to true only if there is no "value"
     * in the result.  Note that "done" only reflects whether the iterator is done at the time "next" is called.  Future calls to "next"
     * may or may not return more rows for a mutable data source.
     * </p>
     * <p>
     * Please see the <a href="DataProvider.html#custom-implementations-section">DataProvider documentation</a> for
     * more information on custom implementations.
     * </p>
     *
     * @param {FetchListParameters=} params fetch parameters
     * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
     * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
     * @export
     * @expose
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name fetchFirst
     * @ojsignature {target: "Type",
     *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
     * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
     * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
     * let result = await asyncIterator.next();
     * let value = result.value;
     * let data = value.data;
     * let keys = value.metadata.map(function(val) {
     *   return val.key;
     * });
     * // true or false for done
     * let done = result.done;
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof TreeDataProviderView
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    /**
     * Class which provides list based optimizations
     */
    class TreeDataProviderView {
        constructor(dataProvider, options) {
            this.dataProvider = dataProvider;
            this.options = options;
            this._listDataProviderView = new ListDataProviderView(dataProvider, options);
        }
        /*
         * Get the data provider for the children of the node identified by parentKey.
         * This should return null for node that cannot have children.
         * This should return a TreeDataProvider for node that can (but doesn't have to) have children.
         */
        getChildDataProvider(parentKey, options) {
            let childDataProvider = this.dataProvider.getChildDataProvider(parentKey);
            if (childDataProvider) {
                return new TreeDataProviderView(childDataProvider, this.options);
            }
            return null;
        }
        containsKeys(params) {
            return this._listDataProviderView.containsKeys(params);
        }
        fetchByKeys(params) {
            return this._listDataProviderView.fetchByKeys(params);
        }
        fetchByOffset(params) {
            return this._listDataProviderView.fetchByOffset(params);
        }
        fetchFirst(params) {
            return this._listDataProviderView.fetchFirst(params);
        }
        getCapability(capabilityName) {
            return this._listDataProviderView.getCapability(capabilityName);
        }
        getTotalSize() {
            return this._listDataProviderView.getTotalSize();
        }
        isEmpty() {
            return this._listDataProviderView.isEmpty();
        }
        addEventListener(eventType, listener) {
            this._listDataProviderView.addEventListener(eventType, listener);
        }
        removeEventListener(eventType, listener) {
            this._listDataProviderView.removeEventListener(eventType, listener);
        }
        dispatchEvent(evt) {
            return this._listDataProviderView.dispatchEvent(evt);
        }
    }
    oj._registerLegacyNamespaceProp('TreeDataProviderView', TreeDataProviderView);

    return TreeDataProviderView;

});


define('ojs/ojcspexpressionevaluator',['ojs/ojcspexpressionevaluator-internal', 'ojs/ojkoshared'], function (ojcspexpressionevaluatorInternal, ojkoshared) { 'use strict';

  /**
   * @license
   * Copyright (c) 2019 2025, Oracle and/or its affiliates.
   * Licensed under The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   *
   * @license
   * Based on the Expression Evaluator 2.0.0
   * https://github.com/donmccurdy/expression-eval
   * under MIT License
   * @ignore
   */

  /**
   * @class oj.CspExpressionEvaluator
   * @since 7.1.0
   * @ojshortdesc Object representing CSP-compliant evaluator.
   * @ojtsmodule
   *
   * @classdesc A class for creating CSP-compliant evaluators of JavaScript expressions
   * <p> The default JET expression evaluator cannot be used when Content Security Policy
   * prohibits unsafe evaluations. In order to replace the default evaluator with the JET CSP-compliant evaluator,
   * create and pass an instance of CspExpressionEvaluator class to the
   * <a href="oj.Config.html#.setExpressionEvaluator">Config.setExpressionEvaluator()</a> method.
   * This method must be called before applying knockout bindings in the application for the first time.
   * </p>
   *
   * <p>Any extra context required for evaluating expressions can be passed to the object constructor using <code>globalScope</code> property.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * Config.setExpressionEvaluator(new CspExpressionEvaluator());
   * </code>
   * </pre>
   *
   * <h2 id="validExpressions">Expressions supported by the JET CspExpressionEvaluator
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validExpressions"></a>
   * </h2>
   * <p>
   * <ul>
   *  <li>Identifiers, e.g. <code>[[value]]</code>.</li>
   *  <li>Members, e.g. <code>[[router.stateId]]</code>.</li>
   *  <li>Literals, e.g. <code>[['abc']]</code>.</li>
   *  <li>Function callbacks, e.g. <code>[[getColor('customer', id)]]</code>.</li>
   *  <li>Unary operators are limited to '-', '+', '~', '!' and '...', e.g. <code>[[-100]]</code>.</li>
   *  <li>Instanceof or typeof operators such as <code>'date instanceof Date'</code></li>
   *  <li>Binary operators, e.g. <code>[[value + '.png']]</code>.</li>
   *  <li>Exponentiation (**) such as <code>'3 ** 4'</code></li>
   *  <li>Logical operators, e.g. <code>[[a && b]]</code> or <code>[[a || b]]</code>.</li>
   *  <li>Nullish coalescing operator (??) such as <code>'value ?? "default value"'</code></li>
   *  <li>Conditional or ternary operators, e.g. <code>[[test ? consequent : alternate]]</code>.</li>
   *  <li>Optional chaining operators, e.g. <code>[[a?.b]]</code>.</li>
   *  <li>Array literals, e.g. <code>[a, b, c]</code>.</li>
   *  <li>Object literals, e.g. <code>[[{'selection_state': selected}]]</code>.</li>
   *  <li>'new' operator such as <code>'new Object()'</code></li>
   *  <li>Regular expressions in the form of explicit RegExp objects such as <code>[[testString.match(new RegExp('abc', 'i'))]]</code></li>
   *  <li>Template literals except tagged templates, e.g. <code>[[`Hello, ${user}!`]]</code></li>
   *  <li>Functions are limited to a single statement, e.g.
   *    <code>function(){return 'abc'}</code> or
   *    <code>function(x, y){return x + y}</code>.
   *  </li>
   *  <li>Arrow functions are limited to a single statement, e.g.
   *    <code>() => 'abc'</code>, <code>() => {return 'abc'}</code>,
   *    <code>(x, y) => {return x + y}</code> or
   *    <code>[1, 2, 3].map(item => item + 1)</code>
   *  </li>
   *</ul>
   * <h2 id="invalidExpressions">Expression limitations:
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#invalidExpressions"></a>
   * </h2>
   * <p> The following code is not supported in expressions:
   * <ul>
   *  <li>Assignment operators of any types such as <code>'='</code> or <code>'+='</code> or <code>'|='</code></li>
   *  <li>Blocks of code such as <code>'if (...){}'</code></li>
   *  <li>Comma operator (,) such as <code>'(expr1, expr2)'</code></li>
   *  <li>in operator such as <code>'prop in testObject'</code></li>
   *  <li>Increment/decrement operators such as <code>'x++'</code> or <code>'x--'</code></li>
   *  <li>Inline regular expressions such as <code>'testString.match(/abc/i)'</code></li>
   *  <li>Spread operator (...) such as <code>'sum(...arrayValue)'</code></li>
   *  <li>Tagged templates such as <code>'myTag`Hello, ${user}!`'</code></li>
   *  <li>await/async keywords such as <code>'await myAsyncTask()'</code></li>
   * <ul>
   * </h2>
   *
   * @param {Object} options
   * @param {any=} options.globalScope optional additional scope required for evaluating expressions.
   * The additional scope will be used to resolve the variables if they are not defined in the $data or $context.
   * <pre class="prettyprint"><code>Config.setExpressionEvaluator(new CspExpressionEvaluator({globalScope:extraScope}));</code></pre>
   * @constructor
   * @final
   * @export
   */
  // eslint-disable-next-line no-unused-vars
  const CspExpressionEvaluator = function (options) {
    var _evaluatorInternal = new ojcspexpressionevaluatorInternal.CspExpressionEvaluatorInternal(options);

    /**
     * Creates expression evaluator
     * @param {string} expressionText expression associated  with the returned evaluator
     * @return {Object} an object with the 'evaluate' key referencing a function that
     * will return the result of evaluation. The function will take an array of scoping contexts ordered from the
     * most specific to the least specific
     * @ignore
     */
    this.createEvaluator = function (expressionText) {
      return _evaluatorInternal.createEvaluator(expressionText);
    };

    /**
     * @param {object} ast an AST node
     * @param {object} context a context object to apply on expressions
     * @ignore
     */
    this.evaluate = function (ast, context) {
      return _evaluatorInternal.evaluate(ast, context);
    };
  };

  return CspExpressionEvaluator;

});


define('ojs/ojtreedataprovideradapter',['ojs/ojcore-base', 'ojs/ojdataprovideradapter-base', 'ojs/ojdataprovider', 'ojs/ojmap'], function (oj, DataSourceAdapter, ojdataprovider, KeyMap) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    DataSourceAdapter = DataSourceAdapter && Object.prototype.hasOwnProperty.call(DataSourceAdapter, 'default') ? DataSourceAdapter['default'] : DataSourceAdapter;
    KeyMap = KeyMap && Object.prototype.hasOwnProperty.call(KeyMap, 'default') ? KeyMap['default'] : KeyMap;

    class TreeDataSourceAdapter extends DataSourceAdapter {
        constructor(treeDataSource) {
            super(treeDataSource);
            this.treeDataSource = treeDataSource;
            this._addTreeDataSourceEventListeners();
            this._parentKey = null;
            this._parentInfoMap = new KeyMap();
        }
        destroy() {
            this._removeTreeDataSourceEventListeners();
        }
        getChildDataProvider(parentKey) {
            if (this._parentInfoMap.has(parentKey)) {
                const childDataProvider = new TreeDataSourceAdapter(this.treeDataSource);
                childDataProvider._parentKey = parentKey;
                childDataProvider._parentInfoMap = this._parentInfoMap;
                return childDataProvider;
            }
            // todo: for the component use case, this is sufficient since parentKey should have been
            // fetched already, otherwise, we would probably need a private contract in TreeDataSource
            // to handle the case when parentKey has not been fetched yet
            return null;
        }
        fetchFirst(params) {
            return new this.AsyncIterable(new this.AsyncIterator(this._getFetchFunc(params), params));
        }
        getTotalSize() {
            return Promise.resolve(this.treeDataSource.getChildCount(this._parentKey));
        }
        isEmpty() {
            const count = this.treeDataSource.getChildCount();
            if (count === -1) {
                return 'unknown';
            }
            return count > 0 ? 'no' : 'yes';
        }
        getCapability(capabilityName) {
            if (capabilityName === TreeDataSourceAdapter._SORT &&
                this.treeDataSource.getCapability(capabilityName) === 'full') {
                return { attributes: 'multiple' };
            }
            else if (capabilityName === 'fetchByKeys') {
                return { implementation: 'iteration' };
            }
            else if (capabilityName === 'fetchByOffset') {
                return { implementation: 'iteration' };
            }
            return null;
        }
        /**
         * Get the function which performs the fetch
         */
        _getFetchFunc(params) {
            const self = this;
            if (params != null && params[TreeDataSourceAdapter._SORTCRITERIA] != null) {
                const attribute = params[TreeDataSourceAdapter._SORTCRITERIA][0][TreeDataSourceAdapter._ATTRIBUTE];
                const direction = params[TreeDataSourceAdapter._SORTCRITERIA][0][TreeDataSourceAdapter._DIRECTION];
                return (function (attribute, direction) {
                    return function (params, fetchFirst) {
                        if (fetchFirst) {
                            const sortParam = {};
                            sortParam[TreeDataSourceAdapter._KEY] = attribute;
                            sortParam[TreeDataSourceAdapter._DIRECTION] = direction;
                            return new Promise(function (resolve, reject) {
                                self.treeDataSource.sort(sortParam, {
                                    success() {
                                        resolve(self._getTreeDataSourceFetch(params)(params));
                                    },
                                    error(err) {
                                        reject(err);
                                    }
                                });
                            });
                        }
                        else {
                            return self._getTreeDataSourceFetch(params)(params);
                        }
                    };
                })(attribute, direction);
            }
            else {
                return this._getTreeDataSourceFetch(params);
            }
        }
        /**
         * Get the function which invokes fetchChildren() on TreeDataSource
         */
        _getTreeDataSourceFetch(params) {
            const self = this;
            return function (params) {
                const sortCriteria = self.treeDataSource.getSortCriteria();
                if (sortCriteria !== null &&
                    sortCriteria[TreeDataSourceAdapter._DIRECTION] != 'none' &&
                    params[TreeDataSourceAdapter._SORTCRITERIA] == null) {
                    params[TreeDataSourceAdapter._SORTCRITERIA] = [];
                    const sortCriterion = new self.SortCriterion(self, sortCriteria[TreeDataSourceAdapter._KEY], sortCriteria[TreeDataSourceAdapter._DIRECTION]);
                    params[TreeDataSourceAdapter._SORTCRITERIA].push(sortCriterion);
                }
                self._isFetching = true;
                return new Promise(function (resolve, reject) {
                    self.treeDataSource.fetchChildren(self._parentKey, { start: 0, end: -1 }, {
                        success(nodeSet) {
                            self._isFetching = false;
                            const resultData = [];
                            const resultMetadata = [];
                            const start = nodeSet.getStart();
                            const count = nodeSet.getCount();
                            let i, data, metadata;
                            for (i = 0; i < count; i++) {
                                data = nodeSet.getData(start + i);
                                resultData.push(data);
                                metadata = nodeSet.getMetadata(start + i);
                                if (!metadata[TreeDataSourceAdapter._LEAF]) {
                                    self._parentInfoMap.set(metadata[TreeDataSourceAdapter._KEY], metadata);
                                }
                                resultMetadata.push(new self.ItemMetadata(self, metadata[TreeDataSourceAdapter._KEY]));
                            }
                            resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, params, resultData, resultMetadata)));
                        },
                        error(error) {
                            self._isFetching = false;
                            reject(error);
                        }
                    });
                });
            };
        }
        /**
         * Add event listeners to TreeDataSource.  Note that currently none of the components
         * handle change event from TreeDataSource.
         */
        _addTreeDataSourceEventListeners() {
            this.removeAllListeners();
            this.addListener('change', this._handleChange);
            this.addListener('refresh', this._handleRefresh);
        }
        /**
         * Remove event listeners to TableDataSource
         */
        _removeTreeDataSourceEventListeners() {
            this.removeListener('change');
            this.removeListener('refresh');
        }
        _handleChange(event) {
            const operation = event[TreeDataSourceAdapter._OPERATION];
            if (operation === 'insert') {
                this._handleInsert(event);
            }
            else if (operation === 'delete') {
                this._handleDelete(event);
            }
            else if (operation === 'update') {
                this._handleUpdate(event);
            }
        }
        _handleInsert(event) {
            const data = event[TreeDataSourceAdapter._DATA];
            const index = event[TreeDataSourceAdapter._INDEX];
            const key = event[TreeDataSourceAdapter._KEY];
            const parentKey = event[TreeDataSourceAdapter._PARENT];
            const itemMetadata = new this.ItemMetadata(this, key);
            const keySet = new Set();
            keySet.add(key);
            const metadata = event[TreeDataSourceAdapter._METADATA];
            if (metadata != null && metadata[TreeDataSourceAdapter._LEAF]) {
                this._parentInfoMap.set(key, metadata);
            }
            const operationEventDetail = new this.DataProviderAddOperationEventDetail(this, keySet, null, null, [parentKey], [itemMetadata], [data], [index]);
            const mutationEventDetail = new this.DataProviderMutationEventDetail(this, operationEventDetail, null, null);
            this.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationEventDetail));
        }
        _handleDelete(event) {
            const data = event[TreeDataSourceAdapter._DATA];
            const index = event[TreeDataSourceAdapter._INDEX];
            const key = event[TreeDataSourceAdapter._KEY];
            const itemMetadata = new this.ItemMetadata(this, key);
            const keySet = new Set();
            keySet.add(key);
            this._parentInfoMap.delete(key);
            const operationEventDetail = new this.DataProviderOperationEventDetail(this, keySet, [itemMetadata], [data], [index]);
            const mutationEventDetail = new this.DataProviderMutationEventDetail(this, null, operationEventDetail, null);
            this.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationEventDetail));
        }
        _handleUpdate(event) {
            let data = event[TreeDataSourceAdapter._DATA];
            let index = event[TreeDataSourceAdapter._INDEX];
            let key = event[TreeDataSourceAdapter._KEY];
            let itemMetadata = new this.ItemMetadata(this, key);
            let keySet = new Set();
            keySet.add(key);
            let operationEventDetail = new this.DataProviderOperationEventDetail(this, keySet, [itemMetadata], [data], [index]);
            let mutationEventDetail = new this.DataProviderMutationEventDetail(this, null, null, operationEventDetail);
            self.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationEventDetail));
        }
        _handleRefresh(event) {
            if (!this._isFetching) {
                this._parentInfoMap.clear();
                this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
            }
        }
    }
    TreeDataSourceAdapter._SORTCRITERIA = 'sortCriteria';
    TreeDataSourceAdapter._INDEX = 'index';
    TreeDataSourceAdapter._PARENT = 'parent';
    TreeDataSourceAdapter._LEAF = 'leaf';
    TreeDataSourceAdapter._OPERATION = 'operation';
    oj._registerLegacyNamespaceProp('TreeDataSourceAdapter', TreeDataSourceAdapter);
    ojdataprovider.FetchByKeysMixin.applyMixin(TreeDataSourceAdapter);
    ojdataprovider.FetchByOffsetMixin.applyMixin(TreeDataSourceAdapter);

    return TreeDataSourceAdapter;

});


define('ojs/ojurlpathadapter',[],function () { 'use strict';

  /**
   * Add a trailing slash to the given path if it doesn't already end with one.
   * @param {string} path
   * @ignore
   */
  function trailingSlash(path) {
    var copy = path;
    if (copy && !copy.match(/\/$/)) {
      copy += '/';
    }
    return copy;
  }

  /**
   * Build a parameter string from a parameter object ({ key1: value1, key2: value2 })
   * @param {Object} params The params object
   * @return {string} The encoded parameter string ("key1=value1;key2=value2")
   * @ignore
   */
  function buildParamsString(params) {
    var paramArray = [];
    Object.keys(params)
      .sort()
      .forEach(function (key) {
        var value = params[key];
        if (value !== undefined && value !== null) {
          paramArray.push(';' + key + '=' + encode(value));
        }
      });
    return paramArray.join('');
  }
  /**
   * Parse the param string and return the object representing it
   * @param {string} segment The individual segment of the URL to parse,
   * i.e., "list;param=123"
   * @return {CoreRouter.CoreRouterState} An object representing the state name and parameters,
   * i.e. { path: 'list', params: { param: 123 } }
   * @ignore
   */
  function parseUrlSegment(segment) {
    var parts = segment.split(';');
    var path = parts.shift();
    var parsed = {
      path: decode(path),
      params: {}
    };
    parts.forEach(function (part) {
      if (part) {
        var pair = part.split('=');
        parsed.params[pair[0]] = decode(pair[1]);
      }
    });
    return parsed;
  }

  /**
   * @param {*} value
   * @ignore
   */
  function encode(value) {
    return encodeURIComponent(value);
  }

  /**
   * @param {*} value
   * @ignore
   */
  function decode(value) {
    return decodeURIComponent(value);
  }

  /**
   * @class UrlPathAdapter
   * @implements CoreRouter.UrlAdapter
   * @since 8.0.0
   * @classdesc Class to synchronize CoreRouter state with the browser URL using
   * path segments.
   * <p>
   * A URL adapter that uses path segments to synchronize router state
   * (/path1;param=123/path2;param=456/path3;param=789). This adapter is the
   * default for {@link CoreRouter},
   * and should be used when the web server serving up UI content has the ability
   * to internally proxy requests from one pseudo path to another.
   * </p>
   * <p>
   * For instance,
   * if the root of your application is <code>http://localhost/</code>, then
   * router states will be added onto this root using path segments, such as
   * <code>http://localhost/path1;param=123/path2;param=456</code>. This path may be bookmarked, and
   * during restoration (or browser reload), the server will be asked to serve
   * up the content from that directory. Since these are presumably virtual
   * directories (they may or may not actually exist on the server), two things
   * must happen for the UI to load correctly:
   * <ul>
   *   <li>The web server must recognize that "/path1/path2" are virtual paths
   *       and serve up the content from the root (/) instead.</li>
   *   <li><code>baseUrl</code> must be set to the correct root;
   *       in this case--"http://localhost/"</li>
   * </ul>
   * </p>
   * <p>
   * Note that this adapter uses [matrix parameters]{@link https://www.w3.org/DesignIssues/MatrixURIs.html}
   * in the URL. This mechanism allows an arbitrary number of parameters to be
   * passed to the state without have to pre-define them in the route configuration.
   * </p>
   * <p>
   * Alternatives to UrlPathAdapter are {@link UrlParamAdapter} and {@link UrlPathParamAdapter}.
   * </p>
   *
   * @param {string=} baseUrl The base URL from which the application is served.
   * This value may be any string value (even blank). If not specified at all
   * (undefined), then the adapter will use document.location.pathname as its
   * base.
   * @constructor
   * @export
   * @ojtsmodule
   * @ojtsimport {module: "ojcorerouter", type: "AMD", importName: "CoreRouter"}
   * @ojsignature {target: "Type",
   *               value: "class UrlPathAdapter<P extends {[key: string]: any} = {[key: string]: any}>",
   *               genericParameters: [{"name": "P", "description": "Parameters object for the router state"}]
   *              }
   */
  function UrlPathAdapter(baseUrl) {
    this._baseUrl = trailingSlash(baseUrl !== undefined ? baseUrl : document.location.pathname);
  }
  /**
   * Build all routes for the given URL. The URL is expected to start with the
   * <code>baseUrl</code> set for this adapter, because it will be subtracted
   * out before routes are built.
   * @param {object=} routePathParams
   * @param {string=} url Optional URL to use. If not specified, document.location.pathname
   * is used.
   * @return {Array.<CoreRouter.Route>} An array of routes starting from the path
   * for the given router.
   * @name getRoutesForUrl
   * @memberof UrlPathAdapter
   * @method
   * @instance
   * @export
   * @ojsignature {target: "Type", value: "Array.<CoreRouter.Route<P>>", for: "returns"}
   */
  UrlPathAdapter.prototype.getRoutesForUrl = function (routePathParams, url) {
    // If url is given, then a decorator (UrlParamAdapter) is calling us with a
    // value that it wants to have parsed. If undefined, then the router is
    // calling us directly.
    var path = url !== undefined ? url : document.location.pathname;
    var baseUrl = this._baseUrl;
    // Remove baseUrl from the URL
    var allSegments = path.substring(baseUrl.length);
    var segments = allSegments.split('/');
    var routes = [];
    // Build a route for each path segment
    segments.forEach(function (segment) {
      var parsed = parseUrlSegment(segment);
      routes.push(parsed);
    });
    // If no routes built, then add one for default route
    if (!routes.length) {
      routes.push(parseUrlSegment(''));
    }
    return routes;
  };
  /**
   * Build the URL path for the given routes.
   * @param {Array.<CoreRouter.Route>} routes The set of routes from which the
   * URL will be built.
   * @return {string} The full URL representative of the given routes
   * @name getUrlForRoutes
   * @memberof UrlPathAdapter
   * @method
   * @instance
   * @export
   * @ojsignature {target: "Type", value: "Array.<CoreRouter.Route<P>>", for: "routes"}
   */
  UrlPathAdapter.prototype.getUrlForRoutes = function (routes) {
    const paths = routes.map(function (route) {
      const params = buildParamsString(route.params || {});
      return route.path + params;
    });
    let baseUrl = this._baseUrl;
    const fullPath = paths.join('/');
    // If paths, ensure trailing slash on baseUrl
    if (fullPath) {
      baseUrl = trailingSlash(baseUrl);
    }
    return baseUrl + fullPath + document.location.search;
  };

  return UrlPathAdapter;

});


define('ojs/ojcorerouter',['ojs/ojlogger', 'ojs/ojobservable', 'ojs/ojurlpathadapter'], function (Logger, ojobservable, UrlPathAdapter) { 'use strict';

  UrlPathAdapter = UrlPathAdapter && Object.prototype.hasOwnProperty.call(UrlPathAdapter, 'default') ? UrlPathAdapter['default'] : UrlPathAdapter;

  /**
   * An interface describing the object used by {@link CoreRouter} to represent
   * the routes and associated information to which it can navigate.
   * @interface CoreRouterState
   * @ojtsnamespace CoreRouter
   * @ojtsimport knockout
   * @ojsignature [{
   *                target: "Type",
   *                value: "interface CoreRouterState<D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters>",
   *                genericParameters: [{"name": "D", "description": "Detail object for the router state"},
   *                                    {"name": "P", "description": "Parameters object for the router state"}]
   *               }
   *              ]
   */
  /**
   * The path of the state. This will always be the string used to navigate
   * to the current state, even if the original path for the route was defined
   * as a RegExp.
   * @name path
   * @memberof CoreRouterState
   * @instance
   * @type {string}
   * @readonly
   */
  /**
   * The detail object for the state, if configured.
   * @name detail
   * @memberof CoreRouterState
   * @type {Object}
   * @instance
   * @readonly
   * @ojsignature { target: 'Type', value: 'D'}
   */
  /**
   * Parameters for the state. Parameters are passed to the state via the
   * {@link CoreRouter#go} method.
   * @name params
   * @memberof CoreRouterState
   * @type {Object}
   * @instance
   * @readonly
   * @ojsignature { target: 'Type', value: 'P'}
   */
  /**
   * Path parameter names for the state, ordered in the order in which they were
   * defined in the route. The names do not include the braces.
   * @name pathParams
   * @memberof CoreRouterState
   * @type {string[]}
   * @instance
   * @readonly
   * @ojsignature { target: 'Type', value: 'string[]'}
   */
  /**
   * A redirect path, if configured. This is taken from the original route configuration,
   * and may be undefined.
   * @name redirect
   * @memberof CoreRouterState
   * @type {string=}
   * @instance
   * @readonly
   */

  // Private instances
  let rootRouter;
  let urlAdapter;
  // noHistorySegments is used by non-tracking routers to store transitions,
  // similar to how history-tracking routers use URL segments
  let noHistorySegments = [];

  /**
   * Test if two routes are equivalent. Routes are equivalent if they have the
   * same paths and parameter values.
   * @param {CoreRouter.Route} route1
   * @param {CoreRouter.Route} route2
   * @return {boolean} true if they're equivalent, false otherwise
   * @ignore
   */
  var isEquivalent = function (route1, route2) {
    var route1String = urlAdapter.getUrlForRoutes([route1]);
    var route2String = urlAdapter.getUrlForRoutes([route2]);
    return route1String === route2String;
  };

  /**
   * Get an array of active routes, starting from the root router down to the
   * last child.
   * @return {Array.<CoreRouter.Route>} An array of all active routes, with the
   * root route as the first element.
   * @ignore
   */
  var getActiveRoutes = function () {
    let router = rootRouter;
    const routes = [];
    while (router) {
      let state = router._activeState;
      if (state) {
        routes.push({
          path: state.path || '',
          params: state.params,
          pathParams: state.pathParams
        });
      } else {
        state = router._getPendingState({ path: '' });
        if (state) {
          routes.push(state);
        }
        break;
      }
      router = router.childRouter;
    }
    return routes;
  };

  const paramRegex = /^{(\w+)}$/;
  /**
   * Get the name of the path parameter
   * @param {*} segment The path segment to parse
   * @ignore
   */
  function getPathParam(segment) {
    const match = segment.match(paramRegex);
    if (match) {
      return match[1];
    }
    throw Error(`no path parameter found for segment ${segment}`);
  }

  /**
   * An observable which publishes state changes that are about to be set as
   * the current state for the router. Subscribers can choose to listen to
   * these publishes to guard against the router navigating out of the current
   * state.
   * <p>
   * The published value given to the subscriber is a {@link CoreRouter.VetoableState},
   * and it can be used to prevent navigation out of the current state.
   * <pre class="prettyprint">
   * <code>
   * router.beforeStateChange.subscribe(function (args) {
   *   var state = args.state;
   *   var accept = args.accept;
   *   // If we don't want to leave, block navigation
   *   if (currentViewmodel.isDirty) {
   *     accept(Promise.reject('model is dirty'));
   *   }
   * });
   * </code>
   * </pre>
   * The value returned can be a boolean or Promise<boolean>.
   * </p>
   * @name beforeStateChange
   * @memberof CoreRouter
   * @type {object}
   * @ojsignature [{target: 'Type', value: 'CoreRouter.Observable<CoreRouter.VetoableState<D, P>>'},
   *               {target: 'Type', value: '<D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters>', for: 'genericTypeParameters'}]
   * @instance
   * @export
   */

  /**
   * An observable which publishes the change to the current router state.
   * Subscribers can listen to these publishes to react to the state change
   * and perform other work, such as loading modules.
   * <p>
   * The published value given to the subscriber is a {@link CoreRouter.ActionableState},
   * and it can be used to report back to the router any issues or asynchronous
   * activity that must be completed before the transition is finalized.
   * <pre class="prettyprint">
   * <code>
   * router.currentState.subscribe(function (args) {
   *   var state = args.state;
   *   var name = state.path;
   *   var complete = args.complete;
   *   // Load the module and return Promise to CoreRouter
   *   complete(
   *     Promise.all([
   *       ModuleUtils.createView({ viewPath: 'views/' + name + '.html' }),
   *       ModuleUtils.createViewModel({ viewModelPath: 'viewModels/' + name })
   *     ])
   *   );
   * });
   * </code>
   * </pre>
   * </p>
   * Subscribers listening to the change to perform asynchronous work, such
   * as loading modules, can return the Promises from those operations through
   * the <code>complete</code> callback. Any errors or Promise rejections returned
   * will cause the transition to fail, and the rejection will be returned to the
   * caller that attempted the transition.
   * The returned value must be a Promise.
   * @name currentState
   * @memberof CoreRouter
   * @type {object}
   * @ojsignature [{target: 'Type', value: 'CoreRouter.Observable<CoreRouter.ActionableState<D, P>>'},
   *               {target: 'Type', value: '<D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters>', for: 'genericTypeParameters'}]
   * @instance
   * @export
   */

  /**
   * The current child router for this router's active state, if one exists.
   * Child routers can be created with {@link CoreRouter#createChildRouter}.
   * @name childRouter
   * @memberof CoreRouter
   * @type {CoreRouter}
   * @instance
   * @export
   */

  /**
   * @class CoreRouter
   * @since 8.0.0
   * @ojshortdesc Provides routing functionality with the state of the application being stored in the browser URL
   * @classdesc The router manages application navigation by tracking
   * state through the browser URL. The router's core responsibility is to publish
   * state changes due to navigation so that listeners can react and perform their
   * own logic, such as loading modules.
   * <p>
   * The root router instance is the top-most router, and it has no parent. This
   * instance may be created only once per application, and attempting to create
   * more than one root instance will result in an error.
   * </p>
   *
   * <p>
   * <h5>Create a CoreRouter with a named route and a redirect rule pointing to that route.</h5>
   * The route with the redirect has a blank path value, making it the default
   * route. However, since it redirects to <code>path1</code>, that is the effective
   * default route.
   * <pre class="prettyprint">
   * <code>
   * var root = new CoreRouter([
   *   { path: 'path1' },
   *   { path: '', redirect: 'path1' }
   * ]);
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>With RegExp as path.</h5>
   * Note that all paths matching the regular expression will be using this configuration entry.
   * <pre class="prettyprint">
   * <code>
   * var root = new CoreRouter([
   *   { path: /path-?/ },
   *   { path: '', redirect: 'path-1' }
   * ])
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>With multiple path matches in descending order.</h5>
   * When using RegExp paths, the order of the routes
   * defined is significant. When searching for a matching state, the router will
   * always search top-down to find the first matching state.
   * </p>
   * <p>
   * In the example below, the value "path-1" will match the first route and will
   * be the one used, even though it would've also matched the second route.
   * <pre class="prettyprint">
   * <code>
   * var root = new CoreRouter([
   *   { path: /path-[0-9]/ },
   *   { path: /path-?/ },
   *   { path: new RegExp('.*') }
   * ])
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>A child router</h5>
   * Child router are created with the {@link CoreRouter#createChildRouter} method.
   * All arguments to that function are the same as what would be passed to the
   * constructor for CoreRouter.
   * <pre class="prettyprint">
   * <code>
   * var child = root.createChildRouter(
   *   [    // routes
   *     { path: 'dashboard' }
   *   ]
   * );
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>A child router which doesn't manipulate history</h5>
   * Some routing use cases want to use the Observables of the router without
   * manipulating the browser history, such as navigating through a wizard whose
   * individual steps shouldn't be bookmarked. Here a child router is created and
   * configured to not manipulate history.
   * <pre class="prettyprint">
   * <code>
   * var child = root.createChildRouter(
   *   [
   *     { path: 'dashboard' }
   *   ],
   *   {
   *     history: 'skip'
   *   }
   * )
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>A path with parameters</h5>
   * Path definitions can contain parameter names as placeholders if using
   * {@link UrlPathParamAdapter}.
   * <pre class="prettyprint">
   * <code>
   * var root = new CoreRouter([
   *   { path: 'orders/{id}/{mode}' }
   * ]);
   * </code>
   * </pre>
   * Each parameter must be predefined for the route, and when navigating, they
   * must all be passed in the "params" object to {@link CoreRouter#go}.
   * If the required parameters aren't all passed, the behavior of the router will
   * be unpredictable.
   * </p>
   * <p>
   * Note that using path parameters does not change the way in which parameters
   * are <i>passed</i> to the route--parameters must still be passed in the "params"
   * object to {@link CoreRouter#go}.
   * </p>
   *
   * @param {Array.<CoreRouter.DetailedRouteConfig|CoreRouter.RedirectedRouteConfig>} routes An array of routes that this
   * router will recognize
   * @param {CoreRouter.CreateOptions=} options The configuration options for this
   * router.
   * @param {CoreRouter=} parentRouter A parent router, if creating a child router,
   * or null/undefined if this is the root router.
   * @export
   * @ojtsmodule
   * @ojsignature [{target: "Type",
   *               value: "class CoreRouter<
   *               D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters,
   *               ParentD extends Record<string, any> = Record<string, any>, ParentP = CoreRouter.Parameters>",
   *               genericParameters: [{"name": "D", "description": "Detail object for the router state"},
   *                                   {"name": "P", "description": "Parameters object for the router state"},
   *                                   {"name": "ParentD", "description": "Detail object for the parent router state"},
   *                                   {"name": "ParentP", "description": "Parameters object for the parent router state"}]},
   *               {target: "Type", value: "Array.<CoreRouter.DetailedRouteConfig<D>|CoreRouter.RedirectedRouteConfig>", for: "routes"},
   *               {target: "Type", value: "CoreRouter.CreateOptions<P>", for: "options"},
   *               {target: "Type", value: "CoreRouter<ParentD, ParentP>", for: "parentRouter"}]
   * @constructor
   * @since 8.0.0
   */
  function CoreRouter(routes, options, parentRouter) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};

    this._name = '/';

    this._urlOffset = 0;

    this.beforeStateChange = new ojobservable.BehaviorSubject({ accept: function () {} });

    this.currentState = new ojobservable.BehaviorSubject({ complete: function () {} });

    this._noHistory = options.history === 'skip';
    // Offset from first no-history tracking router
    this._noHistoryOffset = 0;

    this._parentRouter = parentRouter;
    if (!parentRouter) {
      if (rootRouter) {
        throw Error('Only one root CoreRouter instance may exist at a time');
      }
      rootRouter = this;

      // If a urlAdapter was given use it, otherwise, use UrlPathAdapter
      urlAdapter = options.urlAdapter || new UrlPathAdapter();

      // If this is the root router, listen to window 'popstate'
      this._setupNavigationListener();
    } else {
      // Concatenate parent's name and state to make this child router's name
      this._name = parentRouter._name + parentRouter._activeState.path + '/';

      // Child's _urlOffset parent's offset plus any path params
      this._urlOffset = parentRouter._urlOffset + parentRouter._activeState.pathParams.length + 1;

      if (parentRouter._noHistory) {
        // For nested history-skipping routers, track separate offset to be used
        // to find their transitions from noHistorySegments. Note that if parent
        // router is history-skipping, we, too, are history-skipping.
        this._noHistoryOffset =
          parentRouter._noHistoryOffset + parentRouter._activeState.pathParams.length + 1;
      }
    }

    this.childRouter = undefined;

    this._configure(routes);
  }

  /**
   * Reconfigure the router with new routes. This method will first check that
   * the current state can be exited by pre-publishing the new state to
   * {@link CoreRouter#beforeStateChange}. If no listeners veto the navigation,
   * then the router will reconfigure the routes and navigate to the new route.
   * If any listener rejects the navigation, the rejection will be returned to
   * the caller and the routes will remain as-is.
   * @param {Array.<CoreRouter.DetailedRouteConfig|CoreRouter.RedirectedRouteConfig>} routeConfigs
   * The new route configurations to apply.
   * @param {CoreRouter.Route[]} navigateTo? The new routes to where the router (and its
   * child routers) will navigate after reconfigure.
   * If no routes are given, the current ones will be used. If the routes cannot be
   * navigated to (i.e., they don't exist), the returned Promise will be rejected,
   * the previous route configuration restored, and the router states will remain
   * unchanged.
   * @return {Promise<CoreRouter.CoreRouterState>} A Promise which, when resolved,
   * indicates that the reconfiguration and navigation were successful. A Promise
   * rejection indicates that the reconfigure and navigation failed, and the
   * previous configuration will be restored. Depending on the failure, an error
   * message may be returned describing the reason for the rejection.
   * @name reconfigure
   * @memberof CoreRouter
   * @method
   * @instance
   * @export
   * @ojsignature [
   *   {target: "Type", value: "CoreRouter.Route<P>|CoreRouter.Route<P>[]", for: "navigateTo?"},
   *   {target: "Type", value: "Promise<CoreRouter.CoreRouterState<D, P>>", for: "returns"}
   * ]
   */
  CoreRouter.prototype.reconfigure = function (routeConfigs, navigateTo) {
    const oldRoutes = this._routes;

    let newRoutes = navigateTo || this._getActiveRoutes();
    if (newRoutes && !Array.isArray(newRoutes)) {
      // If single route, coerce to array
      newRoutes = [newRoutes];
    }
    this._configure(routeConfigs);
    return this.go(...newRoutes).catch((ex) => {
      this._configure(oldRoutes);
      throw ex;
    });
  };

  /**
   * Configure any additional states with parameters.
   * @param {CoreRouter.DetailedRouteConfig[] | CoreRouter.RedirectedRouteConfig[]}
   * @private
   */
  CoreRouter.prototype._configure = function (routes = []) {
    this._routes = routes.map(function (config) {
      let path = config.path;
      // Parse path params
      let pathParams = [];
      if (typeof path === 'string') {
        const segments = path.split('/');
        path = segments.shift();
        pathParams = segments.map(getPathParam);
      }
      const configuredRoute = {
        path,
        detail: config.detail || {},
        pathParams,
        redirect: config.redirect
      };
      let match = path;
      // If path is string, match it entirely
      if (typeof path === 'string') {
        match = new RegExp('^' + path + '$');
      } else if (!(path instanceof RegExp)) {
        throw Error('Router path must be a string or RegExp');
      }
      configuredRoute._match = match;
      Object.freeze(configuredRoute);
      return configuredRoute;
    }, this);
  };

  /**
   * Synchronize the router with the current URL. This method tells the router
   * that it should set its internal state to match the values in the URL. Each
   * router at each level sychronizes only the parts of the URL in which it's
   * interested.
   * <p>
   * The top-most root router's "base" is defined by the <code>baseUrl</code>
   * option passed to {@link UrlPathAdapter}, if it's used. If using
   * {@link UrlParamAdapter}, the base is document.location.pathname.
   * </p>
   * <p>
   * sync() is normally called immediately after the router is created so that the
   * default state can be made current. Much like {@link CoreRouter#go}, sync() returns
   * a Promise indicating if the synchronization was successful. A failure could
   * mean that the router doesn't have a default state (see examples in {@link CoreRouter})
   * or the state being synchronized is invalid for the current router.
   * </p>
   *
   * <p>
   * Synchronize the default state of a root router. This assumes that the
   * baseUrl is <code>"/"</code> and the user is
   * visiting the root of the application.
   * <pre class="prettyprint">
   * <code>
   * var root = new CoreRouter([
   *   { path: '', redirect: 'home' },
   *   { path: 'home' }
   * ]);
   * root.sync()
   * .catch(function (error) {
   *   console.error('CoreRouter.sync failed "' + error + '"');
   * })
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * Synchronize a child router. This assumes that the parent's current state is
   * <code>browse</code> and the user is visiting <code>browse/department</code>.
   * <pre class="prettyprint">
   * <code>
   * var child = new CoreRouter(
   *   [
   *     { path: 'department' }
   *   ],
   *   null,
   *   parentRouter
   * );
   * child.sync()
   * .then(function (success) {
   *   if (success) {
   *     console.log('Child router synchronized');
   *   }
   * })
   * .catch(function (error) {
   *   console.error('Child router.sync error "' + error + '"');
   * })
   * </code>
   * </pre>
   * </p>
   *
   * @return {Promise<CoreRouter.CoreRouterState>} A Promise which, when resolved,
   * indicates that the sync was successful. A Promise rejection indicates that
   * the sync failed. An error message may be returned describing the reason for
   * the rejection.
   * @name sync
   * @memberof CoreRouter
   * @method
   * @instance
   * @export
   * @ojsignature {target: "Type", value: "Promise<CoreRouter.CoreRouterState<D, P>>", for: "returns"}
   */
  CoreRouter.prototype.sync = function () {
    // Transition to the new route, or a default one if no current one exists
    return this._execute(this._getRouteSegment() || { path: '', params: {} }).then((state) => {
      // Synchronize the next child router
      var p = state;
      var childRouter = this.childRouter;
      if (childRouter) {
        p = childRouter.sync();
      }
      return p;
    });
  };

  /**
   * Get the route segment for this individual router.
   * @return {CoreRouter.Route}
   * @private
   */
  CoreRouter.prototype._getRouteSegment = function () {
    let route;
    if (this._noHistory) {
      route = noHistorySegments[this._noHistoryOffset];
    } else {
      // Get the URL segment for this router
      let routes = urlAdapter.getRoutesForUrl();
      route = routes[this._urlOffset];
      // Get route path parameters and call getRoutesForUrl with it
      const pathParams = this._getRoutePathParams(route && route.path);
      routes = urlAdapter.getRoutesForUrl({ offset: this._urlOffset, pathParams });
      route = routes[this._urlOffset];
    }
    return route;
  };

  /**
   * Navigate the router to a new path.
   * Each argument to this function should be of
   * type {@link CoreRouter.Route}.
   *
   * <p>
   * <h5>Navigate to a page</h5>
   * Navigate to a page simply by supplying the path matching the route as an array
   * of strings. This method, like {@link CoreRouter#sync} returns a Promise<boolean>
   * to indicate if the transition was successful. You can chain the Promise to
   * do post-processing if you choose.
   * <pre class="prettyprint">
   * <code>
   * router.go({path: 'dashboard'})
   * .then(function () {
   *   this.navigated = true;
   * })
   * // URL "/dashboard"
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>Navigate passing dynamic state parameters</h5>
   * Paths are any string within the array to go(), and parameters are any objects
   * in the array. Parameters are always associated with the <i>previous</i> path
   * segment (in this case, "dashboard"), and must have scalar values.
   * <br/>
   * These parameters
   * are made available via the {@link CoreRouterState#params} object.
   * <pre class="prettyprint">
   * <code>
   * router.go({path: 'dashboard', params: {name: 'Dashboard'}})
   * // URL "/dashboard;name=Dashboard"
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>Navigate to a nested path</h5>
   * Nested paths are simply another string in the array passed to go(). When an
   * entry in the array is a complex object, it's associated with the previous
   * path entry.
   * <br/>
   * In this example, formatted for clarity, "employee" is the path which will
   * receive the parameters object containing "id" value.
   * <pre class="prettyprint">
   * <code>
   * router.go(
   *   {path: 'employee', params: {id: 456}},
   *   {path: 'contacts'}
   * ])
   * // URL "/employee;id=456/contacts"
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>Catching navigation errors</h5>
   * Errors encountered during navigation are returned as Promise rejections, and
   * can be caught with the catch() method.
   * <br/>
   * The types of errors that can occur are:
   * <ul>
   *   <li>No matching state
   *   <li>State change veto'd
   *   <li>Downstream state change listener errors
   * </ul>
   * <pre class="prettyprint">
   * <code>
   * router.go({path: 'home'})
   * .catch(function (error) {
   *   console.error('Routing problem "' + error + '"');
   * });
   * </code>
   * </pre>
   * </p>
   *
   * @param {...CoreRouter.Route} routes The route(s) to navigate. Pass multiple routes
   * as separate arguments.
   * @return {Promise.<CoreRouter.CoreRouterState>} A Promise which will resolve
   * with the state to which the router transitioned, if successful. If the transition
   * fails, the Promise will be rejected.
   * @name go
   * @memberof CoreRouter
   * @method
   * @instance
   * @export
   * @ojsignature [{target: "Type", value: "CoreRouter.Route<P>[]", for: "routes"},
   *               {target: "Type", value: "Promise<CoreRouter.CoreRouterState<D, P>>", for: "returns"}]
   */
  CoreRouter.prototype.go = function (...routes) {
    const path = routes.map((t) => t.path).join('/');
    Logger.info(`Navigating router(${this._name}) to ${path}`);

    let newPath;
    try {
      newPath = this._getPathname(routes);
    } catch (ex) {
      return Promise.reject(ex.message);
    }

    // Get the current routes for all active routers, and compare that to the
    // new routes for this transition.
    const currentPath = this._getPathname(getActiveRoutes());
    const prevNoHistorySegments = noHistorySegments;
    if (this._noHistory) {
      Logger.info(`Navigating non-history tracking router(${this._name}) to ${path}`);
      // Non-history tracking routers use noHistorySegments in place of URL
      // to store their transitions. Replace the segments after our index with
      // the new transitions
      noHistorySegments = noHistorySegments.slice(0, this._noHistoryOffset).concat(routes);
    } else {
      // Cleanup noHistorySegments when navigating any history-tracking routers
      noHistorySegments = [];
      if (currentPath !== newPath) {
        window.history.pushState(null, 'path', newPath);
      }
    }
    return this.sync().catch((ex) => {
      if (this._noHistory) {
        noHistorySegments = prevNoHistorySegments;
      } else {
        window.history.replaceState(null, 'path', currentPath);
      }
      throw ex;
    });
  };

  const paramTypesRegex = new RegExp(
    `^${['bigint', 'boolean', 'number', 'string', 'undefined'].join('$|^')}$`
  );
  /**
   * Create a full URL for the given routes. The parameters are the same as those to {@link CoreRouter#go},
   * and relative to the current router on which it's called.
   * @param {...CoreRouter.Route} routes The route(s) from which to generate the URL
   * @returns {string} The full URL to the given routes, i.e. "https://host[:port]/<routes>..."
   * @since 18.0.0
   * @name getUrlForNavigation
   * @memberof CoreRouter
   * @method
   * @instance
   * @export
   * @ojsignature [{target: "Type", value: "CoreRouter.Route<P>[]", for: "routes"},
   *               {target: "Type", value: "string", for: "returns"}]
   */
  CoreRouter.prototype.getUrlForNavigation = function (...routes) {
    const { protocol, hostname, port } = document.location;
    return `${protocol}//${hostname}${port ? ':' + port : ''}${this._getPathname(routes)}`;
  };

  /**
   * Get the full pathname for navigation from the given routes.
   * @param {CoreRouter.Route[]} routes
   * @returns {string} The pathname to which the router will navigate
   * @private
   */
  CoreRouter.prototype._getPathname = function (routes) {
    routes.forEach(function ({ params }) {
      if (params) {
        // Only primitive values in params object
        Object.keys(params).forEach(function (key) {
          if (!paramTypesRegex.test(typeof params[key])) {
            throw Error(
              `"params" object may only contain primitive values. "${key}" is ${typeof params[key]}`
            );
          }
        });
      }
    });

    // Insert the new transitions after the current router's route offset
    return urlAdapter.getUrlForRoutes(
      this._getParentRoutes()
        .concat(
          // only first transition is for this router
          this._getPendingState(routes[0]),
          // remaining are for child routers
          routes.slice(1)
        )
        .filter(Boolean)
    );
  };

  /**
   * Perform the navigation to a new path, described by the Route object.
   * @param {CoreRouter.CoreRouterState} transition The new state to navigate to
   * @return {Promise<CoreRouter.CoreRouterState>}
   * @private
   */
  CoreRouter.prototype._execute = function (transition) {
    const state = this._getPendingState(transition);
    let execPromise;

    if (!state) {
      execPromise = Promise.reject(
        `Router(${this._name}) has no state matching "${transition.path}"`
      );
    } else {
      execPromise = this._prepublish(state);
      if (!this._isCurrentState(state)) {
        execPromise = execPromise.then(() => this._publish(state));
      }
    }
    return execPromise;
  };

  /**
   * Invoked before a new state change is about to occur, allowing
   * subscribers a chance to block the transition by returning a Promise rejection.
   * @param {CoreRouterState} state The new state to where we want to transition.
   * @return {Promise<CoreRouterState>} A Promise which resolves to the pre-published
   * state, or rejection if a listener rejects the transition.
   * @private
   */
  CoreRouter.prototype._prepublish = function (state) {
    if (!this.beforeStateChange) {
      throw Error(`Router(${this._name}) has already been destroyed`);
    }
    let allPre = [];
    this.beforeStateChange.next({
      state,
      accept: function (res) {
        allPre.push(res);
      }
    });
    let activeSync = Promise.all(allPre).then(() => state);
    if (this.childRouter) {
      activeSync = activeSync.then(() => this.childRouter._prepublish(state));
    }

    activeSync = activeSync.then((s) => {
      if (activeSync !== this._activeSync) {
        // If this isn't the latest sync, then reject the Promise because another
        // sync() is already underway
        return Promise.reject('sync overridden');
      }
      return s;
    });
    this._activeSync = activeSync;

    return activeSync;
  };

  /**
   * Publish the new router state to all subscribers.
   * If all listeners respond with true/Promise<true>, then the currentState
   * is published with the new state.
   * @param {RouterState} state The transition state
   * @private
   */
  CoreRouter.prototype._publish = function (state) {
    var allPub = [];
    this.childRouter = null;
    // Save to "_activeState" and publish to subscribers
    this._activeState = state;
    this.currentState.next({
      state,
      complete: function (res) {
        allPub.push(res);
      }
    });
    return Promise.all(allPub).then(() => state);
  };

  /**
   * @private
   */
  CoreRouter.prototype._setupNavigationListener = function () {
    if (this === rootRouter) {
      this._popstateHandler = () => this.sync();
      window.addEventListener('popstate', this._popstateHandler, false);
    }
  };

  /**
   * Compare the given state with the current state, and test if they are
   * equivalent. States will be equivalent if their path and parameter values
   * are equivalent.
   * @private
   */
  CoreRouter.prototype._isCurrentState = function (state) {
    var cs = this._activeState;
    if (!cs) {
      // If no current state, then the new state is not current
      return false;
    }
    return isEquivalent(cs, state);
  };

  /**
   * Create a CoreRouterState for the given transition which matches one of the pre-
   * configured states. This CoreRouterState object will similar to the matched configured
   * state, except will have its own path and params values.
   * @param {CoreRouter.Route} transition The transition for the CoreRouterState
   * @return {CoreRouter.RouterState} The CoreRouterState associated for the transition
   * @private
   */
  CoreRouter.prototype._getPendingState = function (transition) {
    var pending;
    var path = transition.path;
    var params = transition.params || {};
    let match = this._routes.find((route) => route._match.test(path));
    if (match && match.redirect) {
      path = match.redirect;
      match = this._getPendingState({ path: path, params: params });
    }
    if (match) {
      pending = {
        path,
        params,
        detail: match.detail,
        pathParams: match.pathParams,
        redirect: match.redirect,
        _match: match._match
      };
      Object.freeze(pending);
    }
    return pending;
  };

  /**
   * Get the pathParams array for the given path
   * @private
   * @ignore
   * @param {string} path The path value of the route
   * @return string[] The array of path parameters for the route
   */
  CoreRouter.prototype._getRoutePathParams = function (path = '') {
    const state = this._getPendingState({ path: path });
    return state ? state.pathParams : [];
  };

  /**
   * Gets the active routes for all antecedent routes, from the root down to, but
   * excluding, this router.
   *
   * @private
   * @ignore
   * @returns An array of the active parent routes
   */
  CoreRouter.prototype._getParentRoutes = function () {
    return getActiveRoutes().slice(0, this._urlOffset);
  };
  /**
   * Gets the active routes for this router. Active routes are all of the routes
   * from the current router down to its last active descendant router.
   *
   * @private
   * @ignore
   * @returns An array of the active routes for this router
   */
  CoreRouter.prototype._getActiveRoutes = function () {
    return getActiveRoutes().slice(this._urlOffset);
  };

  /**
   * Create a child router from the current router. The child will be associated
   * with the parent router's state, therefore, the parent must be in a current
   * state (by calling {@link CoreRouter#go} or {@link CoreRouter#sync}). Calling
   * this method from a parent without a current state will result in an error.
   * <p>
   * Only one child router will be active per parent router, and only in the
   * parent router's current state. When the parent router changes states, and
   * the previous state had a child router, it will be disposed of. This means
   * that child routers should always be recreated each time the state is activated.
   * This is typically done in the viewmodel's constructor/initialize functions.
   * </p>
   * <p>
   * Calling this method multiple times to create history-tracking child routers
   * (while remaining on the same state) will result in an error. However, multiple
   * non-history-tracking routers are allowed.
   * </p>
   * <pre class="prettyprint">
   * <code>
   * this.initialize = function (args) {
   *   this.childRouter = args.parentRouter.createChildRouter([
   *     { path: 'child-path' }
   *   ]);
   * }.bind(this);
   * </code>
   * </pre>
   * @param {Array.<CoreRouter.DetailedRouteConfig|CoreRouter.RedirectedRouteConfig>} routes The routes to configure for the child router.
   * @param {CoreRouter.CreateOptions=} options Options to pass to the creation of the router. Currently,
   * the support options are:
   * <ul>
   *   <li> history: "skip"
   * </ul>
   * Note that if the current router doesn't update history (history='skip'), then
   * no descendant routers will update history either, regardless of whether
   * the flag is specified.
   * @return {CoreRouter} The child router instance for the current state
   * @see CoreRouter.createRouter
   * @name createChildRouter
   * @memberof CoreRouter
   * @method
   * @instance
   * @export
   * @ojsignature [{target:"Type", value:"<ChildD extends Record<string, any> = Record<string, any>, ChildP = CoreRouter.Parameters>",
   *               for:"genericTypeParameters",
   *               genericParameters: [{"name": "ChildD", "description": "Detail object for the child router state"},
   *                                   {"name": "ChildP", "description": "Parameters object for the child router state"}]},
   *               {target: "Type", value: "Array.<CoreRouter.DetailedRouteConfig<ChildD>|CoreRouter.RedirectedRouteConfig>", for: "routes"},
   *               {target: "Type", value: "CoreRouter.CreateOptions<ChildP>", for: "options"},
   *               {target: "Type", value: "CoreRouter<ChildD, ChildP>", for: "returns"}]
   */
  CoreRouter.prototype.createChildRouter = function (routes, options = {}) {
    // If parent router is history-skipping, so are its children
    if (this._noHistory) {
      // eslint-disable-next-line no-param-reassign
      options.history = 'skip';
    }

    const cs = this._activeState;
    if (!cs) {
      throw Error(`Router(${this._name}) has no current state. Call sync() on the router first.`);
    }
    // Routers can have only one history-tracking child router per state
    if (this.childRouter && options.history !== 'skip') {
      throw Error(`Router(${this._name}) state(${cs.path}) already has a child router`);
    }
    const childRouter = new CoreRouter(routes, options, this);
    // Set the current state's childRouter
    this.childRouter = childRouter;

    return childRouter;
  };

  /**
   * Destroys the router instance and removes the browser navigation listener
   * (Back/Forward).
   * Note that this function only applies to the root router instance;
   * calling it on child routers will have no effect.
   * @name destroy
   * @memberof CoreRouter
   * @method
   * @instance
   * @export
   */
  CoreRouter.prototype.destroy = function () {
    if (this.childRouter) {
      this.childRouter.destroy();
    }

    // eslint-disable-next-line no-console
    console.debug(`destroying Router(${this._name})`);

    this.beforeStateChange = null;
    this.currentState = null;
    this._parentRouter.childRouter = null;

    if (this === rootRouter) {
      window.removeEventListener('popstate', this._popstateHandler, false);
      rootRouter = null;
    }
  };

  /**
   * A type describing the parameters that can be passed to CoreRouter's go() method
   * @typedef {object} CoreRouter.Parameters
   * @ojsignature [{target: "Type", value: "Record<string, bigint|boolean|number|string|undefined>"}]
   */

  /**
   * An object describing configuration options during the creation of a root
   * CoreRouter instance.
   * @typedef {object} CoreRouter.CreateOptions
   * @property {'skip'=} history Indicate if history tracking should be skipped. By
   * default, the router will add a new history entry each time {@link CoreRouter#go}
   * is called. Setting this option to 'skip' will disable that.
   * @property {CoreRouter.UrlAdapter=} urlAdapter The adapter which handles reading
   * and writing router states from/to the browser URL. If not specified, this will
   * default to {@link UrlPathAdapter}.
   * @ojsignature [{target: "Type", value: "UrlAdapter<P>", for: "urlAdapter"},
   *               {target: "Type", value: "<P = CoreRouter.Parameters>", for: "genericTypeParameters"}]
   */

  /**
   * A route config object configures a path and associated information to which a
   * router can navigate, and is used to build the {@link CoreRouterState}
   * during transitions. This route config type can specify a detail object which
   * can be referenced in the state.
   * @typedef {object} CoreRouter.DetailedRouteConfig
   * @property {string|RegExp} path The path of the route. This may be an exact-
   * match string, or a regular expression.
   * @property {object=} detail An optional detail object which is passed to
   * the route when it is navigated to.
   * @ojsignature [{target: "Type", value: "D", for: "detail"},
   *               {target: "Type", value: "<D extends Record<string, any> = Record<string, any>>", for: "genericTypeParameters"}]
   */

  /**
   * A RouteConfig object configures a path and associated information to which a
   * router can navigate, and is used to build the {@link CoreRouterState}
   * during transitions. This route config type can specify a redirect to another
   * route.
   * @typedef {object} CoreRouter.RedirectedRouteConfig
   * @property {string|RegExp} path The path of the route. This may be an exact-
   * match string, or a regular expression.
   * @property {string=} redirect An optional name of a route to which paths matching
   * this route will redirect. The redirected route's path must be of type string.
   */

  /**
   * A Route defines the path and optional parameters to which a router will navigate.
   * The Route.path must match a route config which was passed
   * to the router via the {@link CoreRouter} constructor or {@link CoreRouter#createChildRouter}.
   * @interface CoreRouter.Route
   * @ojtsnamespace CoreRouter
   * @ojsignature [{
   *                target: "Type",
   *                value: "interface Route<P = CoreRouter.Parameters>",
   *                genericParameters: [{"name": "P", "description": "Parameters object for the router state"}]
   *               }]
   */
  /**
   * The path of the route
   * @name path
   * @type {string}
   * @memberof CoreRouter.Route
   * @instance
   */
  /**
   * The path of the route
   * @name params
   * @type {object=}
   * @memberof CoreRouter.Route
   * @instance
   * @ojsignature { target: 'Type', value: 'P' }
   */

  /**
   * An Observable which can receive subscriptions for new Observers
   * @typedef {object} CoreRouter.Observable
   * @property {function(function(T): void): CoreRouter.Observer} subscribe Subscribe to the observable to get
   * notifications when the value changse. The subscriber callback will receive the
   * value as its single argument. Calling subscribe will return the subscriber
   * object, which can be used to unsubscribe from the observable.
   * @ojsignature [{target:"Type", value:"<T>", for: "genericTypeParameters"}]
   */

  /**
   * An Observer is the result of subscribing to an Observable, and can be used to
   * unsubscribe.
   * @typedef {object} CoreRouter.Observer
   * @property {function(): void} unsubscribe Unsubscribe the observable from further
   * modifications to the value.
   */

  /**
   * A wrapper object which contains a state and a <code>complete</code> callback
   * that can be used by the subscriber to return a Promise for its asynchronous
   * operations.
   * @typedef {object} CoreRouter.ActionableState
   * @property {CoreRouterState} state The CoreRouterState object
   * @property {function(Promise<any>): null} complete The callback function the subscriber
   * can use to return a Promise for its asynchronous activities. Invoking this
   * callback is optional, but allows for the subscriber to delay the completion
   * of the router state transition until its own asynchronous activities are done.
   * @ojsignature [{target: "Type", value: "CoreRouterState<D, P>", for: "state"},
   *               {target: "Type", value: "<D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters>", for: "genericTypeParameters"}]
   */

  /**
   * A wrapper object which contains a state and an <code>accept</code> callback
   * that can be used by the subscriber to return a Promise for its acceptance
   * or rejection of the state transition.
   * @typedef {object} CoreRouter.VetoableState
   * @property {CoreRouterState} state The CoreRouterState object
   * @property {function(Promise<any>): null} accept The callback function the
   * subscriber can use to return a Promise<boolean> indicating whether the state
   * transition ought to be accepted (true) or rejected (false). A Promise rejection
   * will veto the state transition; any Promise resolution (or not invoking the
   * callback at all) will accept the transition.
   * @ojsignature [{target: "Type", value: "CoreRouterState<D, P>", for: "state"},
   *               {target: "Type", value: "<D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters>", for: "genericTypeParameters"}]
   */

  /**
   * A UrlAdapter is used by CoreRouter to read and write router states using the
   * browser URL.
   * @interface UrlAdapter
   * @ojtsnamespace CoreRouter
   * @ojsignature {target: "Type", value: "interface UrlAdapter<P = CoreRouter.Parameters>"}
   */
  /**
   * Build all routes for the given URL. The URL is expected to start with the
   * <code>baseUrl</code> set for this adapter, because it will be subtracted
   * out before routes are built.
   * @name getRoutesForUrl
   * @memberof UrlAdapter
   * @method
   * @instance
   * @export
   * @param {object=} routePathParams An optional object that may be passed from the
   * router for the adapter parse the URL with path parameter information. The
   * object will contain the URL segment offset (segments are individual parts of
   * the path) at where the relevant state begins, and the path parameters for that
   * state as an array of strings.
   * <pre class="prettyprint">
   * <code>
   * {
   *   offset: number,
   *   pathParams: string[]
   * }
   * </code>
   * </pre>
   * If passed, the adapter should build the state with path parameter values for
   * the given offset and return it within the final array. If not passed, the
   * adapter should build the states from the URL, assuming each segment is a new
   * state.
   * @param {string=} url Optional value passed to the adapter for the current URL
   * holding the router state. This is only present when the adapter is wrapped
   * inside of {@link UrlParamAdapter} (see constructor documentation for details).
   * @return {Array.<CoreRouter.Route>} An array of all states represented
   * in the URL.
   * @ojsignature [
   * {target: "Type", value: "{offset: number, pathParams: string[]}", for: "routePathParams"},
   * {target: "Type", value: "Array.<CoreRouter.Route<P>>", for: "returns"}
   * ]
   */

  /**
   * Build the URL path for the given routes.
   * @name getUrlForRoutes
   * @memberof UrlAdapter
   * @method
   * @instance
   * @export
   * @param {Array.<CoreRouter.Route>} states The set of states from which the
   * URL will be built.
   * @return {string} The full URL representative of the given routes
   * @ojsignature [
   * {target: "Type", value: "Array.<CoreRouter.Route<P>>", for: "states"},
   * {target: "Type", value: "string", for: "returns"}
   * ]
   */

  return CoreRouter;

});


define('ojs/ojurlparamadapter',['ojs/ojurlpathadapter'], function (UrlPathAdapter) { 'use strict';

  UrlPathAdapter = UrlPathAdapter && Object.prototype.hasOwnProperty.call(UrlPathAdapter, 'default') ? UrlPathAdapter['default'] : UrlPathAdapter;

  // The old (8.0.0) paramter name
  var _OLD_PARAM_NAME = '_ojCoreRouter';
  // The new (9.0.0) paramter name
  var _NEW_PARAM_NAME = 'ojr';
  var _PARAM_NAME = _OLD_PARAM_NAME;
  /**
   * Parse document.location.search into
   * [[ name, value ], [ name, value ]]
   * @ignore
   */
  function parseSearch() {
    // Get search value and remove leading '?'
    var search = document.location.search ? document.location.search.substring(1) : '';
    var params = [];
    if (search) {
      search.split('&').forEach(function (pair) {
        var parts = pair.split('=');
        params.push(parts);
      });
    }
    return params;
  }

  /**
   * Given an array of
   * [[ name1, value1 ], [ name2, value2 ]]
   * recreate a search string, "name1=value1&name2=value2"
   * @param {Array<object>} params An array of param objects
   * @ignore
   */
  function recreateSearch(params) {
    var search = params.map(function (param) {
      return param[0] + '=' + param[1];
    });
    return search.join('&');
  }

  /**
   * Given search parameters from the URL, find the value of '_ojCoreRouter'
   * @ignore
   */
  function getRouterParamValue() {
    var allParams = parseSearch();
    var found = allParams.find(function (param) {
      return param[0] === _PARAM_NAME;
    });
    return found && decode(found[1]);
  }

  /**
   * Given a string of route states (/path1/path2/path3), encode the value and
   * set into the _ojCoreRouter parameter, and preserve remaining query params.
   * @param {string} routerValue The router states to set
   * @ignore
   */
  function setRouterParamValue(routerValue) {
    var newValue = encode(routerValue);
    var allParams = parseSearch();
    var found = allParams.find(function (param) {
      return param[0] === _PARAM_NAME;
    });
    if (found) {
      found[1] = newValue;
    } else {
      allParams.push([_PARAM_NAME, newValue]);
    }
    return recreateSearch(allParams);
  }

  /**
   * Given a segment-encoded path (/path1/path2/path3), URL encode the value and
   * return it.
   * @param {string} value The unencoded path
   * @ignore
   */
  function encode(value) {
    return encodeURIComponent(value);
  }
  /**
   * Given an encoded path (%2Fpath1%2Fpath2%2Fpath3), decode the valu and
   * return it.
   * @param {string} value The encoded path
   * @ignore
   */
  function decode(value) {
    return decodeURIComponent(value);
  }

  /**
   * @class UrlParamAdapter
   * @implements CoreRouter.UrlAdapter
   * @since 8.0.0
   * @classdesc Class to synchronize CoreRouter state with the browser URL using
   * a query parameter.
   * <p>
   * This URL adapter uses a query parameter to synchronize router state
   * with the URL (using <code>ojr</code> parameter). All other query parameters
   * are unaffected.
   * </p>
   * <p>
   * Since this adapter doesn't require that the server understand URL rewriting
   * (see the documentation in {@link UrlPathAdapter}), it's often used during
   * development time to easily deploy to simple servers. In order to re-use the
   * same route configurations, it's often desirable to use this adapter as a
   * decorator around another, such as with {@link UrlPathParamAdapter}.
   * <pre class="prettyprint">
   * <code>
   * new CoreRouter(
   *   [
   *     { path: 'orders/{id}/{mode}' }
   *   ],
   *   {
   *     urlAdapter: new UrlParamAdapter(
   *       new UrlPathParamAdapter(baseUrl)
   *     )
   *   }
   * )
   * </code>
   * </pre>
   * This configuration allows UrlPathParamAdapter to use the path parameters
   * defined for the route, but allows UrlParamAdapter to persist the router state
   * using query parameters, removing the need for a server capable of URL rewriting
   * during development time. The resulting URL will contain UrlParamAdapter's
   * query parameter <code>ojr</code>, which holds the value of the original URL that the
   * delegate created.
   * </p>
   *
   * <p>
   * When wrapping another adapter inside of UrlParamAdapter, the call to
   * [UrlAdapter.getRoutesForUrl]{@link UrlAdapter#getRoutesForUrl} will be passed a second arg containing
   * the normalized URL for the router state. Normally (when not wrapped),
   * adapters will read directly from the URL to parse router states. However, when
   * wrapped, the contents of the URL aren't known to the delegate, so it must rely
   * on its decorator to pass it the normalized value.
   * </p>
   *
   * <p>
   * Prior to deploying to production, UrlParamAdapter
   * is removed from the configuration, leaving UrlPathParamAdapter to parse the
   * parameters and persist them to the URL.
   * </p>
   * Alternatives to UrlParamAdapter are {@link UrlPathAdapter} and {@link UrlPathParamAdapter}.
   *
   * <h3 id="query-params-section">
   *   Query Parameters
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#query-params-section"></a>
   * </h3>
   * UrlParamAdapter uses only one query parameter - <code>ojr</code>, to maintain
   * the router state. When manipulating query parameters, ensure this is preserved.
   * <pre class="prettyprint">
   * <code>
   * function getOjrParam() {
   *   return document.location.search.split(/[?&]/).find(kv => kv.split(/=/)[0] === 'ojr')
   * }
   *
   * router.go({ path: 'orders' })
   * .then(state => {
   *   window.history.replaceState(
   *     null,
   *     '',
   *     `${document.location.pathame}?${getOjrParam()}&deptId=123&empId=456`
   *   );
   *   return state;
   * });
   * </code>
   * </pre>
   * The application is free to manipulate any other query parameter.
   *
   * @param {CoreRouter.UrlAdapter=} pathAdapter An optional path adapter to which
   * this adapter will delegate for translating routes to paths (getUrlForRoutes)
   * and vice-versa (getRoutesForUrl). If not defined, {@link UrlPathAdapter} is
   * used.
   * </p>
   * @constructor
   * @export
   * @ojtsmodule
   * @ojtsimport {module: "ojcorerouter", type: "AMD", importName: "CoreRouter"}
   * @ojsignature {target: "Type",
   *               value: "class UrlParamAdapter<P extends {[key: string]: any} = {[key: string]: any}>",
   *               genericParameters: [{"name": "P", "description": "Parameters object for the router state"}]
   *              }
   */
  function UrlParamAdapter(pathAdapter) {
    // Use UrlPathAdapter with "" as the baseUrl to handle parsing states stored
    // in the query parameter
    this._pathAdapter = pathAdapter || new UrlPathAdapter('');
    // If _OLD_PARAM_NAME isn't in querystring, then we can use _NEW_PARAM_NAME
    if (getRouterParamValue() === undefined) {
      _PARAM_NAME = _NEW_PARAM_NAME;
    }
  }

  /**
   * Build all routes for the current router query parameter.
   * @param {object=} routePathParams An optional object that may be passed by
   * the route to parse the route path parameters for the active state.
   * See {@link UrlAdapter#getRoutesForUrl} for details.
   * @return {Array.<string[]>} An array of route path parameter names. See
   * {@link UrlAdapter#getRoutesForUrl} for details.
   * @name getRoutesForUrl
   * @memberof UrlParamAdapter
   * @method
   * @instance
   * @export
   * @ojsignature {target: "Type", value: "Array.<CoreRouter.Route<P>>", for: "returns"}
   */
  UrlParamAdapter.prototype.getRoutesForUrl = function (routePathParams) {
    // If no router state query param value exists, pass path adapter blank
    // for the URL so that it generates the default route.
    const urlParam = getRouterParamValue() || '';
    return this._pathAdapter.getRoutesForUrl(routePathParams, urlParam);
  };
  /**
   * Build the URL path for the given routes. See {@link UrlAdapter#getUrlForRoutes}
   * for details.
   * @param {Array.<CoreRouter.Route>} routes The set of routes from which the
   * URL will be built.
   * @return {string} The full URL representing of the given routes
   * @name getUrlForRoutes
   * @memberof UrlParamAdapter
   * @method
   * @instance
   * @export
   * @ojsignature {target: "Type", value: "Array.<CoreRouter.Route<P>>", for: "routes"}
   */
  UrlParamAdapter.prototype.getUrlForRoutes = function (routes) {
    var fullPath = this._pathAdapter.getUrlForRoutes(routes);
    if (fullPath.indexOf('?') > -1) {
      fullPath = fullPath.substring(0, fullPath.indexOf('?'));
    }
    return `${document.location.pathname}?${setRouterParamValue(fullPath)}`;
  };

  return UrlParamAdapter;

});


define('ojs/ojmodulerouter-adapter',['ojs/ojlogger', 'ojs/ojmodule-element-utils', 'ojs/ojmoduleanimations', 'knockout'], function (Logger, ModuleUtils, ModuleAnimations, ko) { 'use strict';

  /**
   * @class oj.ModuleRouterAdapter
   * @since 8.0.0
   * @ojshortdesc Utility class for loading oj-module configuration based on the current state of the router.
   * @classdesc ModuleRouterAdapter utility class.
   * <p>This class is designed to be an adapter between [oj-module]{@link oj.ojModule} element and {@link CoreRouter} object.
   * The properties defined on the class correspond to attributes on oj-module element.
   * The <code>koObservableConfig</code> property created and updated by the class is based on the current state of the CoreRouter.
   * The adapter also supports <code>animation</code> property, which is an implementation of ModuleElementAnimation interface
   * that can be used for <code>oj-module</code> animation.</p>
   *
   * <p>ModuleRouterAdapter reacts to changes of the <code>beforeStateChange</code> and <code>currentState</code> observable properties of CoreRouter.
   * Upon a change to <code>beforeStateChange</code>, ModuleRouterAdapter will invoke the <a href="oj.ModuleViewModel.html#canExit">canExit()</a>
   * callback of the current view model if it's defined; the Promise returned by this callback is passed on to the CoreRouter
   * to allow the pending state change to be canceled. Note that canExit() callback will be invoked on every
   * <code>beforeStateChange</code> mutation regardless whether the module path is changed or view model parameters are changed.</p>
   *
   * <p>Upon a change to the CoreRouter's <code>currentState</code> (i.e. a state change that was not canceled), ModuleRouterAdapter will load
   * the requested view and view model and update its <code>koObservableConfig</code> property.
   * View models may also optimize updates by implementing the <a href="oj.ModuleViewModel.html#parametersChanged">parametersChanged()</a>
   * callback. If this callback is present, CoreRouter state changes that do not result in changes to the module path will be handled
   * by invoking this callback on the already loaded view model with the new state parameter values.</p>
   *
   * <p>When the view model is loaded by ModuleRouterAdapter, an instance of <a href="oj.ModuleRouterAdapter.html#ViewModelParameters">ViewModelParameters</a>
   * will be passed either to the model constructor or to the initialize method on the loaded model instance.
   * See parameter passing contract in <a href="ModuleElementUtils.html#.createConfig">ModuleElementUtils.createConfig()</a>.
   * </p>
   *
   * <pre class="prettyprint">
   * <code>
   * // define animation callback used to transition between views
   * var animationCallback = function (context) {
   *    return context.previousViewModel ? 'pushEnd' : 'fade';
   * };
   *
   * // create a new instance of ModuleRouterAdapter
   * var adapter = new ModuleRouterAdapter(
   *    baseRouter,
   *    {
   *      viewPath: 'views/baserouter/',
   *      viewModelPath: 'viewModels/baserouter/',
   *      animationCallback: animationCallback
   *    }
   * );
   * </code>
   * </pre>
   * @param {CoreRouter} router The instance of the CoreRouter, that manages application navigation for a page or a section of the page.
   * @param {Object=} options Options object used for loading views and view models and configuring oj-module animation.
   * @param {string=} options.viewPath The path to the view, relative to the RequireJS baseURL.
   *                  The text plugin will be used for loading the view. If the option is not provided
   *                  the default path will be used - 'views/'.
   * @param {string=} options.viewModelPath The path to the model, relative to the RequireJS baseURL.
   *                  If the option is not provided the default path wil be used - 'viewModels/'.
   * @param {string=} options.pathKey An optional key for retrieving module name from 'details' object on the router state.
   *                  By default the adapter will use the 'path' field of the router state as the name for the module.
   *                  However when 'path' does not represent the name of the module, the name can be retrieved from 'details' object
   *                  on the router state using specified pathKey.
   * @param {Function=} options.require An optional instance of the require() function to be used
   *                  for loading the view and view model. By default the path is relative to the baseUrl
   *                  specified for the application require calls.
   * @param {Function=} options.animationCallback An optional animation callback used to animate
   *                  transitions between views. <br/>The function will get
   *                  <a href="oj.ModuleRouterAdapter.html#AnimationCallbackParameters">a context object</a> as a parameter.
   *                  A return value should be a string containing
   *                  <a href="ModuleAnimations.html#Animations">an animation type</a> supported by ModuleAnimations
   *                  or an object that implements <a href="oj.ModuleElementAnimation.html">ModuleElementAnimation</a> interface.
   * @ojsignature [
   *    {target: "Type", value: "class ModuleRouterAdapter<D extends Record<string, any> = Record<string, any>, P = CoreRouter.Parameters>",
   *     genericParameters: [{"name": "D", "description": "Detail object for the router state"},
   *                         {"name": "P", "description": "Parameters object for the router state"}]},
   *    {target:"Type", for: "router", value: "CoreRouter<D,P>"},
   *    {target:"Type", for: "options.animationCallback", value: "(animationContext: ModuleRouterAdapter.AnimationCallbackParameters) => ModuleAnimations.Animations|ModuleElementAnimation"},
   *    {target: "Type", for: "options.require", value: "((module: string)=> any)|((modules: string[], ready?: any, errback?: any)=> void)"}
   *  ]
   * @export
   * @ojtsmodule
   * @ojtsimport {module: "ojmoduleanimations", type: "AMD", importName: "ModuleAnimations"}
   * @ojtsimport {module: "ojmodule-element", type: "AMD", imported: ["ModuleElementAnimation","ModuleViewModel"]}
   * @ojtsimport {module: "ojcorerouter", type: "AMD", importName: "CoreRouter"}
   */
  /**
   * @typedef {Object} oj.ModuleRouterAdapter.AnimationCallbackParameters
   * @property {Element} node An oj-module element used for hosting the views
   * @property {any} previousViewModel The instance of previous ViewModel
   * @property {any} viewModel The instance of the current ViewModel
   * @property {any} previousState Previous router state.
   * @property {any} state Current router state.
   */

  /**
   * @typedef {Object} oj.ModuleRouterAdapter.ViewModelParameters
   * @property {CoreRouter} parentRouter The instance of the CoreRouter, that used by the ModuleRouterAdapter instance.
   * @property {any} params The value of CoreRouterState params property.
   * @property {CoreRouter} router The instance of the CoreRouter, that used by the ModuleRouterAdapter instance.
   * @property {CoreRouter.CoreRouterState} routerState The current state of CoreRouter
   * @ojsignature [{target: "Type", value: "CoreRouter<D, P>", for: "parentRouter"},
   *               {target: "Type", value: "P", for: "params"},
   *               {target: "Type", value: "CoreRouter<D, P>", for: "router"},
   *               {target: "Type", value: "CoreRouter.CoreRouterState<D, P>", for: "routerState"},
   *               {target: "Type", value: "<D extends Record<string, any>, P = CoreRouter.Parameters>", for: "genericTypeParameters"}]
   * @ojdeprecated [{target: "property", for: "parentRouter", since: "8.1.0", description: "Use router property instead."},
   *                 {target: "property", for: "params", since: "8.1.0", description: "Use CoreRouter.CoreRouterState.params instead."}]
   */
  // eslint-disable-next-line no-unused-vars
  function ModuleRouterAdapter(router, options) {
    var _router = router;
    var _options = options || {};
    var _prevState = null;
    var _currentState = null;
    var _configPromise = null;
    var _moduleConfig = ko.observable({ view: [], viewModel: null });

    function getModuleAnimation(context) {
      var ctx = {
        node: context.node,
        previousViewModel: context.oldViewModel,
        viewModel: context.newViewModel,
        previousState: _prevState,
        state: _currentState
      };
      return _options.animationCallback(ctx);
    }

    function createAnimation(callback) {
      var AnimateProxy = function () {
        var _delegate;
        var _canAnimate = 'canAnimate';

        function _getDelegateInvoker(name) {
          return function (context) {
            return _delegate[name].call(_delegate, context);
          };
        }

        this[_canAnimate] = function (context) {
          // Get the 'delegate' animation
          var animation = callback(context);

          _delegate = typeof animation === 'string' ? ModuleAnimations[animation] : animation;

          if (!_delegate) {
            return false;
          }

          // Define the rest of the methods on the fly if we have a delegate
          ['prepareAnimation', 'animate'].forEach(
            function (item) {
              this[item] = _getDelegateInvoker(item);
            }.bind(this)
          );

          return _getDelegateInvoker(_canAnimate)(context);
        }.bind(this);
      };

      return new AnimateProxy();
    }

    function getModulePathFromState(state) {
      if (!state) {
        return null;
      }
      return _options.pathKey ? state.detail[_options.pathKey] : state.path;
    }

    // before state change handler
    function onBeforeStateChange(args) {
      // canExit must return a Promise resolution or rejection
      var vm = _moduleConfig().viewModel;
      var canExitPromise = vm && vm.canExit ? vm.canExit() : Promise.resolve();
      args.accept(canExitPromise);
    }

    // on state change handler
    function onStateChange(args) {
      var configPromise;
      var modulePath = getModulePathFromState(args ? args.state : null);
      if (modulePath) {
        var currentModulePath = getModulePathFromState(_currentState);
        // check if model path didn't change and we can just re-apply the parameters
        // using parametersChanged() callback
        if (
          modulePath === currentModulePath &&
          _moduleConfig().viewModel &&
          _moduleConfig().viewModel.parametersChanged
        ) {
          _moduleConfig().viewModel.parametersChanged(args.state.params);
          _currentState = args.state;
          return;
        }

        var viewPath = _options.viewPath || 'views/';
        var viewModelPath = _options.viewModelPath || 'viewModels/';
        configPromise = ModuleUtils.createConfig({
          require: _options.require,
          viewPath: viewPath + modulePath + '.html',
          viewModelPath: viewModelPath + modulePath,
          params: {
            parentRouter: _router,
            params: args.state.params,
            router: _router,
            routerState: args.state
          }
        });
      } else {
        configPromise = Promise.resolve({ view: [], viewModel: null });
      }
      args.complete(configPromise);
      _configPromise = configPromise;
      configPromise.then(
        function (config) {
          if (_configPromise === configPromise) {
            _prevState = _currentState;
            _currentState = args.state;
            // JET-38828 - ensure that a new view is being returned every time the oj-module is re-rendered.
            var clonedViewConfig = { viewModel: config.viewModel };
            Object.defineProperty(clonedViewConfig, 'view', {
              enumerable: true,
              get() {
                return config.view.map((node) => node.cloneNode(true));
              }
            });
            _moduleConfig(clonedViewConfig);
          }
        },
        function (reason) {
          Logger.error('Error creating oj-module config : ', reason);
        }
      );
    }

    // create module animation object if it's requested
    var _moduleAnimation = _options.animationCallback ? createAnimation(getModuleAnimation) : null;

    // Subscribe to router's before and state changes
    _router.beforeStateChange.subscribe(onBeforeStateChange);
    _router.currentState.subscribe(onStateChange);

    var moduleAdapter = {};
    Object.defineProperties(moduleAdapter, {
      /**
       * The observable object created by the ModuleRouterAdapter, which can be used
       * as the <code>config</code> property of the oj-module element.
       * @name koObservableConfig
       * @memberof oj.ModuleRouterAdapter
       * @instance
       * @type {Object}
       * @ojsignature {target: "Type", value: "{ view: Array.<Node>, viewModel: oj.ModuleViewModel}"}
       * @export
       */
      koObservableConfig: {
        get: function () {
          return _moduleConfig;
        }
      },
      /**
       * An implementation of ModuleElementAnimation interface created by the ModuleRouterAdapter,
       * which can be used as the <code>animation</code> property of the oj-module element.
       * This property is created only when animationCallback property is defined for the ModuleRouterAdapter.
       *
       * @name animation
       * @memberof oj.ModuleRouterAdapter
       * @instance
       * @type {oj.ModuleElementAnimation}
       * @export
       */
      animation: {
        get: function () {
          return _moduleAnimation;
        }
      }
    });
    return moduleAdapter;
  }

  return ModuleRouterAdapter;

});


define('ojs/ojknockoutrouteradapter',['knockout', 'ojs/ojlogger'], function (ko, Logger) { 'use strict';

  /**
   * A Knockout adapter, to be used in conjunction with {@link CoreRouter}, to allow
   * components to two-way bind their values to the router's current state.
   * <p>
   * <h5>Creating the adapter in view model</h5>
   * Instantiate the adapter with the router in your view model, and assign it
   * as an instance variable.
   * <pre class="prettyprint">
   * <code>
   * var router = new CoreRouter([
   *   { path: 'home' }
   * ]);
   * this.koAdapter = new KnockoutRouterAdapter(router);
   * </code>
   * </pre>
   *
   * Use the "koAdapter" adapter instance in your view bindings with standard
   * binding syntax. Here, an &lt;oj-navigation-list>'s <code>selection</code>
   * property is two-way bound to the adapter's <code>path</code> observable.
   * When a navigation list item is selected, the binding notifies the adapter
   * of the selection change, and the adapter, in turn, instructs the router to
   * navigate to the path matching the selection.
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-navigation-list selection="{{koAdapter.path}}">
   * &lt;/oj-navigation-list>
   * </code>
   * </pre>
   * </p>
   *
   * <p>
   * <h5>Binding to router state fields</h5>
   * CoreRouterState exposes the {@link CoreRouterState#detail} and
   * {@link CoreRouterState#params} objects (if defined), and these can also be
   * used in view bindings to provide additional information. Here, a label is
   * set in the route's detail object.
   * <pre class="prettyprint">
   * <code>
   * var router = new CoreRouter([
   *   { path: 'home', detail: { label: 'Home Page' } }
   * ]);
   * this.koAdapter = new KnockoutRouterAdapter(router);
   * </code>
   * </pre>
   *
   * The additional "detail" object can be retrieved from the state
   * observable to display.
   * Notes:
   * <ul>
   *   <li>"state" is an observable an must be unwrapped before its
   *       sub-properties can be accessed.</li>
   *   <li>One-way binding should be used because the values under detail aren't
   *       observable (they're whatever was set during router configuration)</li>
   *   <li>Because the state may initially be undefined (before navigation has begun),
   *       we must guard against it with &lt;oj-bind-if>.</li>
   * </ul>
   * <pre class="prettyprint">
   * <code>
   * &lt;h2>
   *   &lt;oj-bind-if test="[[koAdapter.state]]">
   *     &lt;oj-bind-text value="[[koAdapter.state().detail.label]]">&lt;oj-bind-text>
   *   &lt;/oj-bind-if>
   * &lt;/h2>
   * </code>
   * </pre>
   * </p>
   *
   * @param {CoreRouter} router The CoreRouter instance on which this adapter will listen for state changes.
   * @class
   * @export
   * @ojtsmodule
   * @ojtsimport {module: "ojcorerouter", type: "AMD", importName: "CoreRouter"}
   * @ojtsimport knockout
   * @ojsignature [
   *    {target: "Type", value: "class KnockoutRouterAdapter<D extends {[key: string]: any} = {[key: string]: any}, P extends {[key: string]: any} = {[key: string]: any}>",
   *     genericParameters: [{"name": "D", "description": "Detail object for the router state"},
   *                         {"name": "P", "description": "Parameters object for the router state"},
   *     ]},
   *     {target:"Type", for: "router", value: "CoreRouter<D, P>"}
   *  ]
   */
  class KnockoutRouterAdapter {
    /**
     * Constructor
     */
    constructor(router) {
      var state = ko.observable();
      // Knockout observable to expose currentState as read-only observable
      this._observableState = ko.pureComputed({
        read: () => {
          return state();
        },
        write: () => {
          throw Error('"state" observable cannot be written to');
        }
      });

      // Writeable knockout computed to allow two-way binding of router path
      this._observablePath = ko.pureComputed({
        read: () => {
          return state() && state().path;
        },
        write: (path) => {
          router.go({ path: path || '' }).catch(function (msg) {
            Logger.info('KnockoutRouterAdapter router.go() failed with: ' + msg);
            // Force notification of subscribers that their value needs to be
            // reset. Note that this observable's 'equalityComparer' needs to be
            // nullified in order for this to work (below).
            state.valueHasMutated();
          });
        }
      });
      // Nullify equalityComparer so that if _observablePath's call to router.go()
      // is rejected, valueHasMutate() will be told that the value has changed and
      // notify this adapter's subscribers
      this._observablePath.equalityComparer = null;

      // Subscribe to router currentState
      this._stateSubscription = router.currentState.subscribe((args) => {
        state(args.state);
      });
    }

    /**
     * Cleans up this adapter by removing its subscription to the router state
     * changes. This should only be called if the CoreRouter and this adapter are
     * NOT expected to be garbage-collected together.
     * @name destroy
     * @memberof KnockoutRouterAdapter
     * @method
     * @instance
     * @export
     */
    destroy() {
      this._stateSubscription.unsubscribe();
    }

    /**
     * An observable containing the current {@link CoreRouterState} from the
     * router, if defined. Note that this CoreRouterState's <code class="prettyprint">path</code>
     * is the original string value from the class, and can only be used read-only.
     * In order to navigate the router from a component value using two-way binding,
     * use the observable {@link KnockoutRouterAdapter#path} instead.
     * This observable is read-only, and may not be written to.
     * @name state
     * @memberof KnockoutRouterAdapter
     * @instance
     * @readonly
     * @type {ko.Observable<CoreRouter.CoreRouterState>}
     * @ojsignature { target: 'Type', value: 'ko.Observable<CoreRouter.CoreRouterState<D, P>>'}
     */
    get state() {
      return this._observableState;
    }

    /**
     * An observable containing the current value of {@link CoreRouterState#path}.
     * This observable can be used in two-way bindings to read the value of the
     * current state, as well as navigate the router to a new path. When this
     * observable's value changes, the underlying {@link CoreRouter#go} method
     * is called with the new value as the path.
     * @name path
     * @memberof KnockoutRouterAdapter
     * @instance
     * @readonly
     * @type {ko.Observable<string>}
     */
    get path() {
      return this._observablePath;
    }
  }

  return KnockoutRouterAdapter;

});


define('ojs/ojbinddom',['ojs/ojkoshared', 'ojs/ojcustomelement-utils', 'knockout', 'ojs/ojcore-base', 'ojs/ojlogger', 'ojs/ojcontext'], function (BindingProviderImpl, ojcustomelementUtils, ko, oj, Logger, Context) { 'use strict';

  BindingProviderImpl = BindingProviderImpl && Object.prototype.hasOwnProperty.call(BindingProviderImpl, 'default') ? BindingProviderImpl['default'] : BindingProviderImpl;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   *
   * @ojcomponent oj.ojBindDom
   * @ojdisplayname Bind DOM
   * @ojshortdesc An oj-bind-dom element renders HTML content with access to passed in data properties.
   * @ojsignature {target: "Type",
   *               value: "class ojBindDom<D> extends HTMLElement",
   *               genericParameters: [{name: "D", description: "Type of data to be provided to the view"}]}
   * @ojbindingelement
   * @since 6.1.0
   *
   * @ojpropertylayout [ {propertyGroup: "common", items: ["config.view"]},
   *                     {propertyGroup: "data", items: ["config.data"]} ]
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   * @ojoracleicon 'oj-ux-ico-binding-control'
   *
   * @classdesc
   * <h3 id="overview-section">
   *   Dom Binding
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview-section"></a>
   * </h3>
   * <p>Use &lt;oj-bind-dom&gt; to render HTML content and activate optional bindings that will have access to a set of data properties.
   * Note that the &lt;oj-bind-dom&gt; element will be removed from the DOM
   * after bindings are applied. For slotting, applications need to wrap the oj-bind-dom element
   * inside another HTML element (e.g. &lt;span&gt;) with the slot attribute. The oj-bind-dom element does not support
   * the slot attribute.</p>
   *
   * <p><b>Note,</b> the oj-bind-dom element does not validate HTML input provided by an application for integrity or
   * security violations. It is the application's responsibility to sanitize the input to prevent unsafe content
   * from being added to the page.
   * Additionally, using &lt;script&gt; elements as part of the view is strongly discouraged. Execution of
   * inline &lt;script&gt; elements is prohibited by strict Content Security Policies (CSP) and is not guaranteed by
   * oj-bind-dom even in the absence of such CSP restrictions.</p>
   *
   * @example <caption>Initialize the oj-bind-dom:</caption>
   * &lt;oj-bind-dom config='[[configObj]]'>
   * &lt;/oj-bind-dom>
   */

  /**
   * Configuration object that defines HTML content to be inserted into the DOM and data
   * to use when applying bindings to this content.
   * The configuration object can be specified either directly or via a Promise.
   * @name config
   * @memberof oj.ojBindDom
   * @instance
   * @ojshortdesc Configuration object that defines a view and data available to the oj-bind-dom element. The configuration object can be specified directly or via a Promise.
   * @type {object|Promise}
   * @example <caption>Initialize the oj-bind-dom:</caption>
   * &lt;oj-bind-dom config='[[myConfig]]'>
   * &lt;/oj-bind-dom>
   * @ojsignature {target: "Type", value: "oj.ojBindDom.Config<D>|Promise<oj.ojBindDom.Config<D>>", jsdocOverride: true}
   */

  /**
   * @ojtypedef oj.ojBindDom.Config
   * @memberof oj.ojBindDom
   * @ojsignature {for: "genericTypeParameters", target: "Type", value: "<D>"}
   * @export
   */

  /**
   * The Nodes to be inserted. Note that oj-bind-dom does not clone the node array
   * before applying bindings to it. If the application needs to have access to the original node array,
   * it should set the 'view' property to a cloned copy.  Node arrays should not have a longer lifespan
   * than their oj-bind-dom element as would be the case for a node array created in the application model and
   * referenced by an oj-bind-dom element that is detached and reattached by another binding element or script.
   *
   * @name view
   * @type {Array<Node>}
   * @ojtypedefmember
   * @memberof oj.ojBindDom.Config
   * @ojshortdesc An array of nodes to be inserted into the DOM. See the Help documenation for more information.
   */

  /**
   * The data available to the view when expressions are evaluated.  Note that the oj-bind-dom element's binding context
   * will not be made available.
   *
   * @name data
   * @type {Object}
   * @ojtypedefmember
   * @memberof oj.ojBindDom.Config
   * @ojshortdesc The data available to the view when expressions are evaluated. Note that the element's binding context will not be made available.
   * @ojsignature {target: "Type", value: "D"}
   */

  /**
   * @protected
   * @ignore
   */
  (function () {
    function _preprocessBindDom(node) {
      var newNodes;
      var binding = 'ko _ojBindDom_:';

      var expr = _getExpression(node.getAttribute('config'));
      if (expr) {
        binding += expr;
      }

      // oj-bind-dom has a single 'config' attribute
      var openComment = document.createComment(binding);
      var closeComment = document.createComment('/ko');

      newNodes = [openComment];

      var parent = node.parentNode;
      parent.insertBefore(openComment, node); // @HTMLUpdateOK
      // eslint-disable-next-line no-param-reassign
      node[ojcustomelementUtils.OJ_BIND_CONVERTED_NODE] = openComment;

      // Copy children into the comment node
      while (node.childNodes.length > 0) {
        var child = node.childNodes[0];
        parent.insertBefore(child, node); // @HTMLUpdateOK
        newNodes.push(child);
      }

      newNodes.push(closeComment);

      parent.replaceChild(closeComment, node);
      return newNodes;
    }

    BindingProviderImpl.registerPreprocessor('oj-bind-dom', _preprocessBindDom);

    function _getExpression(attrValue) {
      if (attrValue != null) {
        var exp = ojcustomelementUtils.AttributeUtils.getExpressionInfo(attrValue).expr;
        if (exp == null) {
          exp = "'" + attrValue + "'";
        }
        return exp;
      }
      return null;
    }
  })();

  ko.bindingHandlers._ojBindDom_ = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
      var _currentPromise;
      var _resolveBusyStateCallback;
      var _childrenBindingsPromiseResolver;

      function configChanged(configPromise) {
        registerBusyState();
        initChildrenBindingsAppliedPromise();

        configPromise.then(
          function (config) {
            if (configPromise === _currentPromise) {
              try {
                var view = config ? config.view : [];
                var data = config ? config.data : null;
                ko.virtualElements.setDomNodeChildren(element, view || []);
                // Null out the parent references since we don't want the view to be able to access the outside context
                var childBindingContext = bindingContext.createChildContext(
                  data,
                  undefined,
                  function (ctx) {
                    ctx.$parent = null;
                    ctx.$parentContext = null;
                    ctx.$parents = null;
                  }
                );

                ko.applyBindingsToDescendants(childBindingContext, element);
              } catch (e) {
                Logger.error(
                  'An error %o occurred during view insertion and apply bindings for oj-bind-dom.',
                  e
                );
              } finally {
                resolveBusyState();
                resolveChildrenBindingsAppliedPromise();
              }
            }
          },
          function (reason) {
            // errorback
            resolveBusyState();
            resolveChildrenBindingsAppliedPromise();
            Logger.error(
              'An error %o occurred during view insertion and apply bindings for oj-bind-dom.',
              reason
            );
          }
        );
      }

      function findNearestCustomParent(parentTrackingContext) {
        var nearestCustomParent = element.parentNode;
        while (
          nearestCustomParent &&
          !ojcustomelementUtils.ElementUtils.isValidCustomElementName(nearestCustomParent.localName)
        ) {
          nearestCustomParent = nearestCustomParent.parentNode;
        }
        if (!nearestCustomParent) {
          nearestCustomParent = parentTrackingContext
            ? parentTrackingContext._nearestCustomParent
            : null;
        }
        return nearestCustomParent;
      }

      function findImmediateState(nearestCustomParent, parentTrackingContext) {
        var isImmediate = false;
        var nestedElement =
          parentTrackingContext &&
          Object.prototype.hasOwnProperty.call(parentTrackingContext, '_immediate');
        if (element.parentNode === nearestCustomParent) {
          isImmediate = true;
        } else if (nestedElement && !element.parentNode.parentNode) {
          isImmediate = parentTrackingContext._immediate;
        }
        return isImmediate;
      }

      function initChildrenBindingsAppliedPromise() {
        if (!_childrenBindingsPromiseResolver) {
          // when oj-bind-dom is inside of oj-bind-for-each template, the element will be rendered disconnected
          // use bindingContext.$current to determine nearestCustomParent and isImmediate state
          var nearestCustomParent = findNearestCustomParent(bindingContext.$current);
          var isImmediate = findImmediateState(nearestCustomParent, bindingContext.$current);
          _childrenBindingsPromiseResolver = oj._KnockoutBindingProvider
            .getInstance()
            .__RegisterBindingAppliedPromiseForChildren(nearestCustomParent, isImmediate);
        }
      }

      function resolveChildrenBindingsAppliedPromise() {
        if (_childrenBindingsPromiseResolver) {
          _childrenBindingsPromiseResolver();
          _childrenBindingsPromiseResolver = null;
        }
      }

      function registerBusyState() {
        if (!_resolveBusyStateCallback) {
          // element is a comment node so look for the busy context on the parent node instead
          _resolveBusyStateCallback = Context.getContext(element.parentNode)
            .getBusyContext()
            .addBusyState({ description: 'oj-bind-dom is waiting on config Promise resolution' });
        }
      }

      function resolveBusyState() {
        if (_resolveBusyStateCallback) {
          _resolveBusyStateCallback();
          _resolveBusyStateCallback = null;
        }
      }

      ko.computed(
        function () {
          _currentPromise = Promise.resolve(ko.utils.unwrapObservable(valueAccessor()));
          configChanged(_currentPromise);
        },
        null,
        { disposeWhenNodeIsRemoved: element }
      );

      return { controlsDescendantBindings: true };
    }
  };

  // Allow _ojBindDom_ binding on virtual elements (comment nodes) which is done during knockout's preprocessNode method
  ko.virtualElements.allowedBindings._ojBindDom_ = true;

  

});


define('ojs/ojdeferreddataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider'], function (oj, ojdataprovider) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 4.2.0
     * @export
     * @final
     * @class DeferredDataProvider
     * @implements DataProvider
     * @ojtsmodule
     * @classdesc This class implements {@link DataProvider}.
     *            This object represents a data provider that is created with deferred data and can be used by any component that requires a data provider that will be created with data from a Promise.
     * @param {Promise.<DataProvider>} dataProvider A promise that resolves to a DataProvider
     * @param {Function} capabilityFunc A function that implements {@link DataProvider#getCapability}.
     * @ojsignature [{target: "Type",
     *               value: "class DeferredDataProvider<K, D> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "Promise<DataProvider<K, D>>",
     *               for: "dataProvider"},
     *               {target: "Type",
     *               value: "(capabilityName: string)=> any",
     *               for: "capabilityFunc"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     *   "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     *   "FetchListResult","FetchListParameters"]}
     * @ojtsexample
     * // DeferredDataProvider is used in cases where the data for the DataProvider will be
     * // provided asynchronously. In the example below, let getDeferredData() be any function
     * // that returns a Promise that will resolve to the final data.
     * const deferredDataPromise = getDeferredData();
     *
     * // Create a Promise that will resolve to an ArrayDataProvider containing the resolved data
     * const dataProviderPromise = deferredDataPromise.then((resolvedData) => {
     *  return new ArrayDataProvider(resolvedData);
     * });
     *
     * // Then create a DeferredDataProvider object with the promise that will resolve to a DataProvider,
     * // and an implemenation of {@link DataProvider#getCapability}.
     * const dataprovider = new DeferredDataProvider(dataProviderPromise, capabilityFunc);
     * // or you may pass in ArrayDataProvider's static getCapability function as
     * const dataprovider = new DeferredDataProvider(dataProviderPromise, ArrayDataProvider.getCapability);
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * Get an AsyncIterable object for iterating the data.
     * <p>
     * AsyncIterable contains a Symbol.asyncIterator method that returns an AsyncIterator.
     * AsyncIterator contains a next method for fetching the next block of data.
     * </p><p>
     * The "next" method returns a promise that resolves to an object, which contains a "value" property for the data and a "done" property
     * that is set to true when there is no more data to be fetched.  The "done" property should be set to true only if there is no "value"
     * in the result.  Note that "done" only reflects whether the iterator is done at the time "next" is called.  Future calls to "next"
     * may or may not return more rows for a mutable data source.
     * </p>
     * <p>
     * Please see the <a href="DataProvider.html#custom-implementations-section">DataProvider documentation</a> for
     * more information on custom implementations.
     * </p>
     *
     * @param {FetchListParameters=} params fetch parameters
     * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
     * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
     * @export
     * @expose
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name fetchFirst
     * @ojsignature {target: "Type",
     *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
     * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
     * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
     * let result = await asyncIterator.next();
     * let value = result.value;
     * let data = value.data;
     * let keys = value.metadata.map(function(val) {
     *   return val.key;
     * });
     * // true or false for done
     * let done = result.done;
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof DeferredDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    class DeferredDataProvider {
        constructor(_dataProvider, _capabilityFunc) {
            var _a;
            this._dataProvider = _dataProvider;
            this._capabilityFunc = _capabilityFunc;
            this._DATAPROVIDER = 'dataProvider';
            this.AsyncIterable = (_a = class {
                    constructor(_asyncIterator) {
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = () => {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this.AsyncIterator = class {
                constructor(_asyncIteratorPromise, _params) {
                    this._asyncIteratorPromise = _asyncIteratorPromise;
                    this._params = _params;
                }
                ['next']() {
                    const signal = this._params?.signal;
                    const callback = (resolve) => {
                        return resolve(this._asyncIteratorPromise.then((asyncIterator) => {
                            return asyncIterator['next']();
                        }));
                    };
                    return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
                }
            };
        }
        /**
         * Fetch the first block of data
         */
        fetchFirst(params) {
            const asyncIteratorPromise = this._getDataProvider().then((dataProvider) => {
                return dataProvider.fetchFirst(params)[Symbol.asyncIterator]();
            });
            return new this.AsyncIterable(new this.AsyncIterator(asyncIteratorPromise));
        }
        /**
         * Fetch rows by keys
         */
        fetchByKeys(params) {
            const signal = params?.signal;
            const callback = (resolve) => {
                return resolve(this._getDataProvider().then((dataProvider) => {
                    return dataProvider.fetchByKeys(params);
                }));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        /**
         * Check if rows are contained by keys
         */
        containsKeys(params) {
            const signal = params?.signal;
            const callback = (resolve) => {
                return resolve(this._getDataProvider().then((dataProvider) => {
                    return dataProvider.containsKeys(params);
                }));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        /**
         * Fetch rows by offset
         */
        fetchByOffset(params) {
            return this._getDataProvider().then((dataProvider) => {
                return dataProvider.fetchByOffset(params);
            });
        }
        /**
         * Returns the total size of the data
         */
        getTotalSize() {
            return this._getDataProvider().then((dataProvider) => {
                return dataProvider.getTotalSize();
            });
        }
        /**
         * Returns a string that indicates if this data provider is empty.
         * Returns "unknown" if the dataProvider has not resolved yet.
         */
        isEmpty() {
            if (!this[this._DATAPROVIDER])
                return 'unknown';
            else
                return this[this._DATAPROVIDER].isEmpty();
        }
        /**
         * Determines whether this DataProvider supports certain feature.
         */
        getCapability(capabilityName) {
            if (this._capabilityFunc)
                return this._capabilityFunc(capabilityName);
            return null;
        }
        /** EVENT TARGET IMPLEMENTATION **/
        addEventListener(eventType, listener) {
            this._getDataProvider().then((dataProvider) => {
                dataProvider.addEventListener(eventType, listener);
            });
        }
        removeEventListener(eventType, listener) {
            this._getDataProvider().then((dataProvider) => {
                dataProvider.removeEventListener(eventType, listener);
            });
        }
        dispatchEvent(evt) {
            if (!this[this._DATAPROVIDER])
                return false;
            return this[this._DATAPROVIDER].dispatchEvent(evt);
        }
        /**
         * Returns the resolved dataProvider for this instance
         */
        _getDataProvider() {
            return this._dataProvider.then((dataProvider) => {
                if (ojdataprovider.DataProviderFeatureChecker.isDataProvider(dataProvider)) {
                    if (!this[this._DATAPROVIDER]) {
                        this[this._DATAPROVIDER] = dataProvider;
                    }
                    return dataProvider;
                }
                else
                    throw new Error('Invalid data type. DeferredDataProvider takes a Promise<DataProvider>');
            });
        }
    }
    oj._registerLegacyNamespaceProp('DeferredDataProvider', DeferredDataProvider);

    return DeferredDataProvider;

});


define('ojs/ojtracer',['exports', 'ojs/ojcustomelement-utils'], function (exports, ojcustomelementUtils) { 'use strict';

    /**
     * Contains telemetry utility functions
     * @ojmodulecontainer ojtracer
     * @ojtsmodule
     * @since 11.1.0
     */

    /**
     * Return some descriptive text to help identify this element for the Tracer
     *
     * @ojexports
     * @memberof ojtracer
     * @param {HTMLElement} element - element for which to return descriptive text
     * @returns {string} descriptive text
     * @method
     * @name getDescriptiveText
     */

    /**
     * Allow user to set an opentelemetry-compatible TracerProvider object
     * Please see the {@link https://opentelemetry.io opentelemetry documentation}
     *
     * @ojexports
     * @memberof ojtracer
     * @param {unknown} provider
     * @method
     * @name setTracerProvider
     */

    /**
     * Return the user-set opentelemetry-compatible TracerProvider object, or an internal no-op version if nothing has been set
     * Please see the {@link https://opentelemetry.io opentelemetry documentation}
     * @ojexports
     * @memberof ojtracer
     * @returns {unknown} opentelemetry-compatible TracerProvider
     * @method
     * @name getTracerProvider
     */

    class NoOpSpan {
        spanContext() {
            const sc = {
                traceId: '',
                spanId: '',
                traceFlags: 0 // Need numeric instead of code constant to avoid third party
            };
            return sc;
        }
        setAttribute(key, value) {
            return this;
        }
        setAttributes(attributes) {
            return this;
        }
        addEvent(name, attributesOrStartTime, startTime) {
            return this;
        }
        setStatus(status) {
            return this;
        }
        updateName(name) {
            return this;
        }
        end(endTime) { }
        isRecording() {
            return false;
        }
        recordException(exception, time) { }
    }

    class NoOpTracer {
        startSpan(name, options, context) {
            return new NoOpSpan();
        }
        startActiveSpan(name, optOrFunc, contextOrFunc, func) {
            let fn;
            if (arguments.length < 2) {
                return;
            }
            else if (arguments.length === 2) {
                fn = optOrFunc;
            }
            else if (arguments.length === 3) {
                fn = contextOrFunc;
            }
            else {
                fn = func;
            }
            return fn(new NoOpSpan());
        }
    }

    class NoOpTracerProvider {
        getTracer(name, version) {
            return new NoOpTracer();
        }
    }

    // Return some descriptive text to help identify this element for the Tracer
    function getDescriptiveText(element) {
        const state = ojcustomelementUtils.CustomElementUtils.getElementState(element);
        return state?.getDescriptiveText() ?? '';
    }
    let tracerProvider;
    function setTracerProvider(provider) {
        tracerProvider = provider;
    }
    function getTracerProvider() {
        if (!tracerProvider) {
            tracerProvider = new NoOpTracerProvider();
        }
        return tracerProvider;
    }
    function endRecordMode() { }
    function startRecordMode(config) {
        return null;
    }

    exports.endRecordMode = endRecordMode;
    exports.getDescriptiveText = getDescriptiveText;
    exports.getTracerProvider = getTracerProvider;
    exports.setTracerProvider = setTracerProvider;
    exports.startRecordMode = startRecordMode;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojcachediteratorresultsdataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojeventtarget'], function (oj, ojdataprovider, ojeventtarget) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    
    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 9.1.0
     * @export
     * @final
     * @class CachedIteratorResultsDataProvider
     * @implements DataProvider
     * @classdesc This is an internal wrapper class meant to be used by JET collection components to provide highwatermark scrolling optimizations.
     * This wrapper will cache the most results of the most recently invoked fetchFirst by attributes, filterCriterion, and sortCriteria.
     * @param {DataProvider} dataProvider the DataProvider.
     * @param {object=} options Optional specify that we want the total row count to be returned for this query
     * with any filterCriterion applied in backend data source.
     * @ojsignature [{target: "Type",
     *               value: "class CachedIteratorResultsDataProvider<K, D> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "DataProvider<K, D>",
     *               for: "dataProvider"},
     *              {target: "Type",
     *               value: "{includeFilteredRowCount?: 'disabled' | 'enabled'}",
     *               for: "options"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     * "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     * "FetchListResult","FetchListParameters"]}
     * @ojtsmodule
     * @ojhidden
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof CachedIteratorResultsDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    
    class CachedIteratorResultsDataProvider {
        constructor(dataProvider, options) {
            var _a, _b;
            this.dataProvider = dataProvider;
            this.options = options;
            this.CacheAsyncIterable = (_b = class {
                    constructor(_parent, dataProviderAsyncIterator, params, cache) {
                        this._parent = _parent;
                        this.dataProviderAsyncIterator = dataProviderAsyncIterator;
                        this.params = params;
                        this.cache = cache;
                        this[_a] = () => {
                            return new this._parent.CacheAsyncIterator(this._parent, this.dataProviderAsyncIterator, this.params, this.cache, this._clientId);
                        };
                        this._clientId = Symbol();
                        this._parent._mapClientIdToIteratorInfo.set(this._clientId, 0);
                    }
                },
                _a = Symbol.asyncIterator,
                _b);
            this.CacheAsyncIterator = class {
                constructor(_parent, asyncIterator, params, cache, _clientId) {
                    this._parent = _parent;
                    this.asyncIterator = asyncIterator;
                    this.params = params;
                    this.cache = cache;
                    this._clientId = _clientId;
                    // offset in our cache
                    this._iteratorOffset = 0;
                    // We need to provide local row count if this capability has been requested through getEnhancedDataProvider,
                    // and the fetchFirst parameters indicates it wants row count for this iterator,
                    // and the base DataProvider does not have this capability.
                    this._needLocalRowCount =
                        _parent.options?.includeFilteredRowCount === 'enabled' &&
                            params?.includeFilteredRowCount === 'enabled' &&
                            _parent._baseFetchFirstCapability?.totalFilteredRowCount !== 'exact';
                }
                _getIteratorOffset(clientId) {
                    return this._parent._mapClientIdToIteratorInfo.get(clientId);
                }
                // private helper to return results so far when a stale fetch is detected
                _getStaleResult(result) {
                    // if no result is already present, return an empty 'done' stub as this fetch is 'stale'
                    return result != null
                        ? result.value.data?.length > 0
                            ? new this._parent.CacheAsyncIteratorYieldResult(result.value, -1)
                            : new this._parent.CacheAsyncIteratorReturnResult(result.value, -1)
                        : {
                            value: {
                                data: [],
                                metadata: [],
                                fetchParameters: this.params,
                                totalFilteredRowCount: -1
                            },
                            done: true
                        };
                }
                ['next']() {
                    const params = this.params || {};
                    const size = params.size || -1;
                    const signal = params?.signal;
                    const callback = (resolve) => {
                        return resolve(this._getResult(params, size, this._needLocalRowCount ? this._parent.cache.getSize() : undefined));
                    };
                    return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
                }
                _getResult(params, size, totalFilteredRowCount) {
                    // check if we have enough in the cache
                    let result;
                    if (size === -1 ||
                        (this._needLocalRowCount && this._getIteratorOffset(this._clientId) === 0)) {
                        // we want to fetch everything
                        if (this.cache.isDone()) {
                            result = this.cache.getDataList(params, this._getIteratorOffset(this._clientId));
                            // this._iteratorOffset = this._iteratorOffset + result.data.length;
                            this._parent._mapClientIdToIteratorInfo.set(this._clientId, this._getIteratorOffset(this._clientId) + result.data.length);
                            return Promise.resolve(this._getFinalResult(result, totalFilteredRowCount));
                        }
                        else {
                            const fetchUntilDone = () => {
                                return this._checkCachedParamsAndIterate(params, -1).then((result) => {
                                    if (this.asyncIterator !== this._parent._currentAsyncIterator) {
                                        return this._getStaleResult();
                                    }
                                    if (result.done) {
                                        return Promise.resolve(this._getResult(params, size, this._parent.cache.getSize()));
                                    }
                                    else {
                                        return fetchUntilDone();
                                    }
                                });
                            };
                            return fetchUntilDone();
                        }
                    }
                    else {
                        return this._fetchFromCacheAndIterate(params, size, totalFilteredRowCount);
                    }
                }
                _getFinalResult(result, totalFilteredRowCount) {
                    if (this._parent._getSharedIteratorState().cachedFetchParams.sortCriteria &&
                        (!result.fetchParameters || !result.fetchParameters.sortCriteria)) {
                        result.fetchParameters.sortCriteria =
                            this._parent._getSharedIteratorState().cachedFetchParams.sortCriteria;
                    }
                    return result?.data?.length > 0
                        ? new this._parent.CacheAsyncIteratorYieldResult(result, totalFilteredRowCount)
                        : new this._parent.CacheAsyncIteratorReturnResult(result, totalFilteredRowCount);
                }
                _checkCachedParamsAndIterate(params, size) {
                    let asyncIteratorFetchPromise;
                    let firstIteratorCachedFetchParams = this._parent._getSharedIteratorState().cachedFetchParams;
                    let firstIteratorCachedFetchOffset = this._parent._getSharedIteratorState().fetchOffset;
                    let firstIteratorCachedFetchPromise = this._parent._getSharedIteratorState().fetchPromise;
                    if (firstIteratorCachedFetchPromise &&
                        this._getIteratorOffset(this._clientId) === firstIteratorCachedFetchOffset &&
                        CachedIteratorResultsDataProvider._compareCachedFetchParameters(params, firstIteratorCachedFetchParams)) {
                        asyncIteratorFetchPromise = firstIteratorCachedFetchPromise;
                    }
                    else {
                        this._parent._getSharedIteratorState().cachedFetchParams =
                            CachedIteratorResultsDataProvider._createCachedFetchParams(params);
                        this._parent._getSharedIteratorState().fetchPromise = this.asyncIterator
                            .next()
                            .then((result) => {
                            // only update the state variables of this data provider if results are not 'stale'
                            // ie - the currentAsyncIterator instance did not change after the call was issued
                            if (this.asyncIterator !== this._parent._currentAsyncIterator) {
                                return this._getStaleResult(result);
                            }
                            else {
                                // save sortCriteria from baseDP and will be used as part of return result
                                // to reserve implicitSort from baseDP
                                if (result.value.fetchParameters?.sortCriteria) {
                                    this._parent._getSharedIteratorState().cachedFetchParams.sortCriteria =
                                        result.value.fetchParameters?.sortCriteria;
                                }
                                this._parent._getSharedIteratorState().fetchOffset =
                                    this._parent._getSharedIteratorState().fetchOffset + result.value.data.length;
                                this._parent._getSharedIteratorState().fetchPromise = null;
                                this.cache.addListResult(result);
                            }
                            return result;
                        });
                        asyncIteratorFetchPromise = this._parent._getSharedIteratorState().fetchPromise;
                    }
                    return asyncIteratorFetchPromise;
                }
                _fetchFromCacheAndIterate(params, size, totalFilteredRowCount) {
                    let result = this.cache.getDataList(params, this._getIteratorOffset(this._clientId));
                    if (this.cache.getSize() >= this._getIteratorOffset(this._clientId) + size ||
                        this.cache.isDone()) {
                        let iteratorOffset = this._getIteratorOffset(this._clientId) + result.data.length;
                        this._parent._mapClientIdToIteratorInfo.set(this._clientId, iteratorOffset);
                        return Promise.resolve(this._getFinalResult(result, totalFilteredRowCount));
                    }
                    else {
                        let offset = 0;
                        // count - remaining data to be fetched from iterator call
                        let count = size - result.data.length;
                        const fetchUntilOffset = () => {
                            return this._checkCachedParamsAndIterate(params, size).then((finalResult) => {
                                if (this.asyncIterator !== this._parent._currentAsyncIterator) {
                                    return this._getStaleResult();
                                }
                                else {
                                    let data = finalResult.value.data.slice(offset, count);
                                    count -= data.length;
                                    if (count === 0 || this.cache.isDone()) {
                                        result = this.cache.getDataList(params, this._getIteratorOffset(this._clientId));
                                        let iteratorOffset = this._getIteratorOffset(this._clientId) + result.data.length;
                                        this._parent._mapClientIdToIteratorInfo.set(this._clientId, iteratorOffset);
                                        let resultObj = Object.assign({}, finalResult);
                                        resultObj.value.data = result.data;
                                        resultObj.value.metadata = result.metadata;
                                        return Promise.resolve(this._getFinalResult(resultObj.value, totalFilteredRowCount));
                                    }
                                    else {
                                        return fetchUntilOffset();
                                    }
                                }
                            });
                        };
                        return fetchUntilOffset();
                    }
                }
            };
            this.CacheAsyncIteratorYieldResult = class {
                constructor(value, totalFilteredRowCount) {
                    this.value = value;
                    if (totalFilteredRowCount !== undefined) {
                        this[CachedIteratorResultsDataProvider._VALUE] = Object.assign({ totalFilteredRowCount }, value);
                    }
                    else {
                        this[CachedIteratorResultsDataProvider._VALUE] = value;
                    }
                    this[CachedIteratorResultsDataProvider._DONE] = false;
                }
            };
            this.CacheAsyncIteratorReturnResult = class {
                constructor(value, totalFilteredRowCount) {
                    this.value = value;
                    if (totalFilteredRowCount !== undefined) {
                        this[CachedIteratorResultsDataProvider._VALUE] = Object.assign({ totalFilteredRowCount }, value);
                    }
                    else {
                        this[CachedIteratorResultsDataProvider._VALUE] = value;
                    }
                    this[CachedIteratorResultsDataProvider._DONE] = true;
                }
            };
            this.cache = new oj.DataCache();
            this._mapClientIdToIteratorInfo = new Map();
            this._lastFetchParams = null;
            this._firstIteratorState = null;
            // Add createOptimizedKeyMap method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeyMap) {
                this.createOptimizedKeyMap = (initialMap) => {
                    return dataProvider.createOptimizedKeyMap(initialMap);
                };
            }
            // Add createOptimizedKeySet method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeySet) {
                this.createOptimizedKeySet = (initialSet) => {
                    return dataProvider.createOptimizedKeySet(initialSet);
                };
            }
            this.handleMutationOffsetUpdate = function (mutationType, indexes) {
                if (mutationType === 'remove') {
                    let count = 0;
                    indexes.forEach((index) => {
                        this._mapClientIdToIteratorInfo.forEach((offset, symbol) => {
                            if (index < offset) {
                                this._mapClientIdToIteratorInfo.set(symbol, offset - 1);
                                count += 1;
                            }
                        });
                    });
                    if (this._firstIteratorState !== null) {
                        this._firstIteratorState.fetchOffset -= count;
                    }
                }
                if (mutationType === 'add') {
                    let count = 0;
                    indexes.forEach((index) => {
                        this._mapClientIdToIteratorInfo.forEach((offset, symbol) => {
                            if (index < offset) {
                                this._mapClientIdToIteratorInfo.set(symbol, offset + 1);
                                count += 1;
                            }
                        });
                    });
                    if (this._firstIteratorState !== null) {
                        this._firstIteratorState.fetchOffset += count;
                    }
                }
            }.bind(this);
            // Listen to mutate event on wrapped DataProvider
            dataProvider.addEventListener(CachedIteratorResultsDataProvider._MUTATE, (event) => {
                // First allow the cache to process the mutations, which may result in different detail
                this.cache.processMutations(event.detail, this.handleMutationOffsetUpdate);
                // Then fire mutate with new detail
                this.dispatchEvent(event);
            });
            // Listen to refresh event on wrapped DataProvider
            dataProvider.addEventListener(CachedIteratorResultsDataProvider._REFRESH, (event) => {
                // Invalidate the cache on refresh event
                this.cache.reset();
                this._lastFetchParams = null;
                this._firstIteratorState = null;
                this.dispatchEvent(event);
            });
            this._baseFetchFirstCapability = dataProvider.getCapability('fetchFirst');
        }
        containsKeys(params) {
            const finalResults = new Set();
            const neededKeys = new Set();
            // First resolve any keys that can be found in the cache
            const cacheResults = this.cache.getDataByKeys(params);
            params.keys.forEach((key) => {
                const item = cacheResults.results.get(key);
                if (item) {
                    finalResults.add(key);
                }
                else {
                    neededKeys.add(key);
                }
            });
            if (neededKeys.size === 0) {
                // Return the result if all keys have been resolved from cache
                return Promise.resolve({ containsParameters: params, results: finalResults });
            }
            else {
                // If there are unresolved keys, delegate to the wrapped DataProvider
                const newParams = { attributes: params.attributes, keys: neededKeys, scope: params.scope };
                return this.dataProvider.containsKeys(newParams).then((containsKeysResults) => {
                    containsKeysResults.results.forEach((key) => {
                        finalResults.add(key);
                    });
                    return { containsParameters: params, results: finalResults };
                });
            }
        }
        fetchByKeys(params) {
            const finalResults = new Map();
            const neededKeys = new Set();
            const signal = params?.signal;
            const callback = (resolve) => {
                // First resolve any keys that can be found in the cache
                const cacheResults = this.cache.getDataByKeys(params);
                params.keys.forEach((key) => {
                    const item = cacheResults.results.get(key);
                    if (item) {
                        finalResults.set(key, item);
                    }
                    else {
                        neededKeys.add(key);
                    }
                });
                if (neededKeys.size === 0) {
                    // Return the result if all keys have been resolved from cache
                    return resolve({ fetchParameters: params, results: finalResults });
                }
                else {
                    // If there are unresolved keys, delegate to the wrapped DataProvider
                    const newParams = {
                        attributes: params.attributes,
                        keys: neededKeys,
                        scope: params.scope
                    };
                    return resolve(this.dataProvider.fetchByKeys(newParams).then((fetchByKeysResults) => {
                        fetchByKeysResults.results.forEach((item, key) => {
                            finalResults.set(key, item);
                        });
                        return { fetchParameters: params, results: finalResults };
                    }));
                }
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchByOffset(params) {
            // size is optional so use the default size if not specified
            const size = params.size || CachedIteratorResultsDataProvider._DEFAULT_SIZE;
            const signal = params?.signal;
            const callback = (resolve) => {
                // Use the cache if the attributes, filterCriterion, and sortCriteria match and the offset is in range
                // We also need to check if the cached rows can satisfy the requested size.
                if (CachedIteratorResultsDataProvider._compareCachedFetchParameters(params, this._lastFetchParams) &&
                    params.offset + size <= this.cache.getSize()) {
                    let updatedParams = { ...params };
                    updatedParams.size = size;
                    const results = this.cache.getDataByOffset(updatedParams);
                    if (results) {
                        return resolve(results);
                    }
                }
                return resolve(this.dataProvider.fetchByOffset(params));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchFirst(params) {
            if (params?.signal?.aborted) {
                // signal is already aborted, no need to check
                const asyncIterable = this.dataProvider.fetchFirst(params);
                const asyncIterator = asyncIterable[Symbol.asyncIterator]();
                this._currentAsyncIterator = asyncIterator;
                return new this.CacheAsyncIterable(this, asyncIterator, null, null);
            }
            // Invalidate the cache if fetchFirst is called with different fetch parameters from last call
            if (!this._getSharedIteratorState() ||
                !CachedIteratorResultsDataProvider._compareCachedFetchParameters(params, params && this._getSharedIteratorState()
                    ? this._getSharedIteratorState().cachedFetchParams
                    : this._lastFetchParams)) {
                this.cache.reset();
                // Remember the last fetch parameters
                this._lastFetchParams = CachedIteratorResultsDataProvider._createCachedFetchParams(params);
                let _underlyingDPParams = { ...params };
                if (this.options?.includeFilteredRowCount === 'enabled' &&
                    params?.includeFilteredRowCount === 'enabled' &&
                    this._baseFetchFirstCapability?.totalFilteredRowCount !== 'exact') {
                    _underlyingDPParams.size = -1;
                }
                const asyncIterable = this.dataProvider.fetchFirst(_underlyingDPParams);
                const asyncIterator = asyncIterable[Symbol.asyncIterator]();
                this._firstIteratorState = {
                    cachedFetchParams: this._lastFetchParams,
                    fetchOffset: 0,
                    fetchPromise: null,
                    asyncIterator: asyncIterator
                };
            }
            this._currentAsyncIterator = this._getSharedIteratorState().asyncIterator;
            return new this.CacheAsyncIterable(this, this._getSharedIteratorState().asyncIterator, params, this.cache);
        }
        getCapability(capabilityName) {
            const capability = this.dataProvider.getCapability(capabilityName);
            if (capabilityName === 'fetchCapability' || capabilityName === 'fetchFirst') {
                return { attributeFilter: capability?.attributeFilter, caching: 'visitedByCurrentIterator' };
            }
            return capability;
        }
        getTotalSize() {
            // If there is no filterCriterion and the cache is complete, we can just return the cache size
            if (this._lastFetchParams != null && !this._lastFetchParams.filterDef && this.cache.isDone()) {
                return Promise.resolve(this.cache.getSize());
            }
            // Otherwise delegate to the wrapped DataProvider
            return this.dataProvider.getTotalSize();
        }
        isEmpty() {
            // If there is no filterCriterion and the cache is complete, we can just return this info based on the cache
            if (this._lastFetchParams != null && !this._lastFetchParams.filterDef && this.cache.isDone()) {
                return this.cache.getSize() === 0 ? 'yes' : 'no';
            }
            // Otherwise delegate to the wrapped DataProvider
            return this.dataProvider.isEmpty();
        }
        _getSharedIteratorState() {
            return this._firstIteratorState;
        }
        static _compareCachedFetchParameters(params, cachedParams) {
            params = params || {};
            // prev aborted, curr not aborted
            // ie first aborted, sec not aborted, return false to create a new iterator
            // for case like first not aborted, sec aborted and third not aborted won't return false
            // because sec aborted fetch won't update cachedParams if other params are same
            if (cachedParams != null && cachedParams.signal?.aborted && !params.signal?.aborted) {
                return false;
            }
            // prev not aborted, curr aborted and other cases
            return (cachedParams != null &&
                oj.Object.compareValues(cachedParams.attributes, params.attributes || null) &&
                oj.Object.compareValues(cachedParams.filterDef, params.filterCriterion
                    ? CachedIteratorResultsDataProvider._getFilterDef(params.filterCriterion)
                    : null) &&
                oj.Object.compareValues(cachedParams.sortCriteria, params.sortCriteria || null));
        }
        static _createCachedFetchParams(params) {
            params = params || {};
            const cachedFetchParams = {};
            cachedFetchParams.size = params.size;
            cachedFetchParams.attributes = params.attributes ? Object.assign({}, params.attributes) : null;
            cachedFetchParams.filterDef = params.filterCriterion
                ? CachedIteratorResultsDataProvider._getFilterDef(params.filterCriterion)
                : null;
            cachedFetchParams.sortCriteria = params.sortCriteria
                ? Object.assign([], params.sortCriteria)
                : null;
            cachedFetchParams.signal = params.signal;
            return cachedFetchParams;
        }
        static _getFilterDef(filter) {
            if (!filter) {
                return null;
            }
            const filterDef = {};
            Object.keys(filter).forEach((property) => {
                if (property !== 'filter') {
                    filterDef[property] = filter[property];
                }
            });
            return filterDef;
        }
    }
    CachedIteratorResultsDataProvider._REFRESH = 'refresh';
    CachedIteratorResultsDataProvider._MUTATE = 'mutate';
    CachedIteratorResultsDataProvider._VALUE = 'value';
    CachedIteratorResultsDataProvider._DONE = 'done';
    CachedIteratorResultsDataProvider._DEFAULT_SIZE = 25;
    ojeventtarget.EventTargetMixin.applyMixin(CachedIteratorResultsDataProvider);
    oj._registerLegacyNamespaceProp('CachedIteratorResultsDataProvider', CachedIteratorResultsDataProvider);

    

    return CachedIteratorResultsDataProvider;

});


define('ojs/ojdedupdataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojeventtarget', 'ojs/ojcachediteratorresultsdataprovider'], function (oj, ojdataprovider, ojeventtarget, CachedIteratorResultsDataProvider) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    CachedIteratorResultsDataProvider = CachedIteratorResultsDataProvider && Object.prototype.hasOwnProperty.call(CachedIteratorResultsDataProvider, 'default') ? CachedIteratorResultsDataProvider['default'] : CachedIteratorResultsDataProvider;

    
    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 9.1.0
     * @export
     * @final
     * @class DedupDataProvider
     * @implements DataProvider
     * @classdesc This is an internal wrapper class meant to be used by JET collection component to provide de-duping.
     * @param {DataProvider} dataProvider the DataProvider.
     * @ojsignature [{target: "Type",
     *               value: "class DedupDataProvider<K, D> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "DedupDataProvider<K, D> | DataProvider<K, D>",
     *               for: "dataProvider"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     * "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     * "FetchListResult","FetchListParameters"]}
     * @ojtsmodule
     * @ojhidden
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof DedupDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    
    class DedupDataProvider {
        constructor(dataProvider) {
            var _a, _b;
            this.dataProvider = dataProvider;
            this.DedupAsyncIterable = (_b = class {
                    constructor(_parent, params, dataProviderAsyncIterator, cache) {
                        this._parent = _parent;
                        this.params = params;
                        this.dataProviderAsyncIterator = dataProviderAsyncIterator;
                        this.cache = cache;
                        this[_a] = () => {
                            return new this._parent.DedupAsyncIterator(this._parent, this.params, this.dataProviderAsyncIterator, this.cache);
                        };
                    }
                },
                _a = Symbol.asyncIterator,
                _b);
            this.DedupAsyncIterator = class {
                constructor(_parent, params, asyncIterator, cache) {
                    this._parent = _parent;
                    this.params = params;
                    this.asyncIterator = asyncIterator;
                    this.cache = cache;
                    this._cachedOffset = 0;
                }
                ['next']() {
                    const cachedKeys = new Set();
                    if (this.params.size > 0) {
                        // de-dup by checking if the cache already contains the row. If so then
                        // publish a delete mutation for the old one first.
                        // we only want to do this if we are iteratively fetching blocks.
                        // fetching everything with size = -1 is covered by block deduping.
                        const cachedFetchByOffsetResults = this._parent.cache.getDataByOffset({
                            offset: 0,
                            size: this._cachedOffset
                        });
                        cachedFetchByOffsetResults.results.forEach((item) => {
                            cachedKeys.add(item.metadata.key);
                        });
                    }
                    return this.asyncIterator.next().then((result) => {
                        const value = result[DedupDataProvider._VALUE];
                        const keys = value.metadata.map((value) => {
                            return value[DedupDataProvider._KEY];
                        });
                        this._cachedOffset = this._cachedOffset + keys.length;
                        const fetchKeys = new Set();
                        keys.forEach((key) => {
                            fetchKeys.add(key);
                        });
                        const removeKeysArray = [];
                        const removeDataArray = [];
                        const removeMetadataArray = [];
                        fetchKeys.forEach((fetchKey, index) => {
                            if (cachedKeys.has(fetchKey)) {
                                removeKeysArray.push(fetchKey);
                                removeDataArray.push(value.data[index]);
                                removeMetadataArray.push(value.metadata[index]);
                            }
                        });
                        if (removeKeysArray.length > 0) {
                            const removekeySet = new Set();
                            for (const key of removeKeysArray) {
                                removekeySet.add(key);
                            }
                            const operationRemoveEventDetail = new this._parent.DataProviderOperationEventDetail(this._parent, removekeySet, removeMetadataArray, removeDataArray, []);
                            const mutationRemoveEventDetail = new this._parent.DataProviderMutationEventDetail(this._parent, null, operationRemoveEventDetail, null);
                            this._parent.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationRemoveEventDetail));
                        }
                        // if it's our cache then update it
                        if (!(this._parent.dataProvider instanceof CachedIteratorResultsDataProvider)) {
                            this._parent.cache.addListResult(result);
                        }
                        return result;
                    });
                }
            };
            this.DataProviderMutationEventDetail = class {
                constructor(_parent, add, remove, update) {
                    this._parent = _parent;
                    this.add = add;
                    this.remove = remove;
                    this.update = update;
                    this[DedupDataProvider._ADD] = add;
                    this[DedupDataProvider._REMOVE] = remove;
                    this[DedupDataProvider._UPDATE] = update;
                }
            };
            this.DataProviderOperationEventDetail = class {
                constructor(_parent, keys, metadata, data, indexes) {
                    this._parent = _parent;
                    this.keys = keys;
                    this.metadata = metadata;
                    this.data = data;
                    this.indexes = indexes;
                    this[DedupDataProvider._KEYS] = keys;
                    this[DedupDataProvider._METADATA] = metadata;
                    this[DedupDataProvider._DATA] = data;
                    this[DedupDataProvider._INDEXES] = indexes;
                }
            };
            if (dataProvider instanceof CachedIteratorResultsDataProvider) {
                this.cache = dataProvider.cache;
            }
            else {
                this.cache = new oj.DataCache();
            }
            // Add createOptimizedKeyMap method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeyMap) {
                this.createOptimizedKeyMap = (initialMap) => {
                    return dataProvider.createOptimizedKeyMap(initialMap);
                };
            }
            // Add createOptimizedKeySet method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeySet) {
                this.createOptimizedKeySet = (initialSet) => {
                    return dataProvider.createOptimizedKeySet(initialSet);
                };
            }
            // Listen to mutate event on wrapped DataProvider
            dataProvider.addEventListener(DedupDataProvider._MUTATE, (event) => {
                if (event.detail && event.detail.add) {
                    // de-dup add mutations
                    this._processAddMutations(event.detail.add);
                }
                this.dispatchEvent(event);
            });
            // Listen to refresh event on wrapped DataProvider
            dataProvider.addEventListener(DedupDataProvider._REFRESH, (event) => {
                // Invalidate the cache on refresh event
                this.cache.reset();
                this.dispatchEvent(event);
            });
        }
        containsKeys(params) {
            return this.dataProvider.containsKeys(params);
        }
        fetchByKeys(params) {
            return this.dataProvider.fetchByKeys(params);
        }
        fetchByOffset(params) {
            return this.dataProvider.fetchByOffset(params);
        }
        fetchFirst(params) {
            const asyncIterable = this.dataProvider.fetchFirst(params);
            return new this.DedupAsyncIterable(this, params, asyncIterable[Symbol.asyncIterator](), this.cache);
        }
        getCapability(capabilityName) {
            const capability = this.dataProvider.getCapability(capabilityName);
            if (capabilityName === 'dedup') {
                return { type: 'iterator' };
            }
            return capability;
        }
        getTotalSize() {
            return this.dataProvider.getTotalSize();
        }
        isEmpty() {
            return this.dataProvider.isEmpty();
        }
        _processAddMutations(detail) {
            const eventDetailKeys = detail[DedupDataProvider._KEYS];
            if (eventDetailKeys && eventDetailKeys.size > 0) {
                // check if the cache contains the key. If it does then dispatch a remove to remove them
                const removeKeys = new Set();
                const removeDataArray = [];
                const removeMetadataArray = [];
                const value = this.cache.getDataByKeys({ keys: eventDetailKeys });
                value.results.forEach((item, key) => {
                    removeKeys.add(key);
                    removeDataArray.push(item.data);
                    removeMetadataArray.push(item.metadata);
                });
                if (removeKeys.size > 0) {
                    const operationRemoveEventDetail = new this.DataProviderOperationEventDetail(this, removeKeys, removeMetadataArray, removeDataArray, []);
                    const mutationRemoveEventDetail = new this.DataProviderMutationEventDetail(this, null, operationRemoveEventDetail, null);
                    this.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(mutationRemoveEventDetail));
                }
            }
        }
    }
    DedupDataProvider._KEY = 'key';
    DedupDataProvider._KEYS = 'keys';
    DedupDataProvider._DATA = 'data';
    DedupDataProvider._METADATA = 'metadata';
    DedupDataProvider._ITEMS = 'items';
    DedupDataProvider._FROM = 'from';
    DedupDataProvider._OFFSET = 'offset';
    DedupDataProvider._REFRESH = 'refresh';
    DedupDataProvider._MUTATE = 'mutate';
    DedupDataProvider._SIZE = 'size';
    DedupDataProvider._FETCHPARAMETERS = 'fetchParameters';
    DedupDataProvider._VALUE = 'value';
    DedupDataProvider._DONE = 'done';
    DedupDataProvider._RESULTS = 'results';
    DedupDataProvider._ADD = 'add';
    DedupDataProvider._UPDATE = 'update';
    DedupDataProvider._REMOVE = 'remove';
    DedupDataProvider._INDEXES = 'indexes';
    ojeventtarget.EventTargetMixin.applyMixin(DedupDataProvider);
    oj._registerLegacyNamespaceProp('DedupDataProvider', DedupDataProvider);

    

    return DedupDataProvider;

});


define('ojs/ojmutateeventfilteringdataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojcachediteratorresultsdataprovider', 'ojs/ojdedupdataprovider', 'ojs/ojeventtarget'], function (oj, ojdataprovider, CachedIteratorResultsDataProvider, DedupDataProvider, ojeventtarget) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    CachedIteratorResultsDataProvider = CachedIteratorResultsDataProvider && Object.prototype.hasOwnProperty.call(CachedIteratorResultsDataProvider, 'default') ? CachedIteratorResultsDataProvider['default'] : CachedIteratorResultsDataProvider;
    DedupDataProvider = DedupDataProvider && Object.prototype.hasOwnProperty.call(DedupDataProvider, 'default') ? DedupDataProvider['default'] : DedupDataProvider;

    
    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 9.1.0
     * @export
     * @final
     * @class MutateEventFilteringDataProvider
     * @implements DataProvider
     * @classdesc This is an internal wrapper class meant to be used by JET collection components to provide mutation event filtering.
     * @param {DataProvider} dataProvider the DataProvider.
     * @ojsignature [{target: "Type",
     *               value: "class MutateEventFilteringDataProvider<K, D> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "MutateEventFilteringDataProvider<K, D> | DataProvider<K, D>",
     *               for: "dataProvider"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     * "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     * "FetchListResult","FetchListParameters"]}
     * @ojtsmodule
     * @ojhidden
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof MutateEventFilteringDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    
    class MutateEventFilteringDataProvider {
        constructor(dataProvider) {
            var _a, _b;
            this.dataProvider = dataProvider;
            this.MutateEventFilteringAsyncIterable = (_b = class {
                    constructor(_parent, params, dataProviderAsyncIterator, cache) {
                        this._parent = _parent;
                        this.params = params;
                        this.dataProviderAsyncIterator = dataProviderAsyncIterator;
                        this.cache = cache;
                        this[_a] = () => {
                            return new this._parent.MutateEventFilteringAsyncIterator(this._parent, this.params, this.dataProviderAsyncIterator, this.cache);
                        };
                    }
                },
                _a = Symbol.asyncIterator,
                _b);
            this.MutateEventFilteringAsyncIterator = class {
                constructor(_parent, params, asyncIterator, cache) {
                    this._parent = _parent;
                    this.params = params;
                    this.asyncIterator = asyncIterator;
                    this.cache = cache;
                }
                ['next']() {
                    let self = this;
                    const signal = this.params?.signal;
                    const callback = (resolve) => {
                        return resolve(this.asyncIterator.next().then((result) => {
                            if (!(self._parent.dataProvider instanceof CachedIteratorResultsDataProvider) &&
                                !(self._parent.dataProvider instanceof DedupDataProvider)) {
                                self._parent.cache.addListResult(result);
                            }
                            return result;
                        }));
                    };
                    return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
                }
            };
            this.DataProviderMutationEventDetail = class {
                constructor(add, remove, update) {
                    this.add = add;
                    this.remove = remove;
                    this.update = update;
                    this[MutateEventFilteringDataProvider._ADD] = add;
                    this[MutateEventFilteringDataProvider._REMOVE] = remove;
                    this[MutateEventFilteringDataProvider._UPDATE] = update;
                }
            };
            let self = this;
            if (dataProvider instanceof CachedIteratorResultsDataProvider) {
                this.cache = dataProvider.cache;
            }
            else if (dataProvider instanceof DedupDataProvider) {
                this.cache = dataProvider.cache;
            }
            else {
                this.cache = new oj.DataCache();
            }
            // Add createOptimizedKeyMap method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeyMap) {
                this.createOptimizedKeyMap = (initialMap) => {
                    return dataProvider.createOptimizedKeyMap(initialMap);
                };
            }
            // Add createOptimizedKeySet method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeySet) {
                this.createOptimizedKeySet = (initialSet) => {
                    return dataProvider.createOptimizedKeySet(initialSet);
                };
            }
            // Listen to mutate event on wrapped DataProvider
            dataProvider.addEventListener(MutateEventFilteringDataProvider._MUTATE, (event) => {
                if (event.detail) {
                    let removeDetail = self._processMutations(event.detail.remove);
                    let updateDetail = self._processMutations(event.detail.update);
                    if ((removeDetail && removeDetail.keys && removeDetail.keys.size > 0) ||
                        (updateDetail && updateDetail.keys && updateDetail.keys.size > 0) ||
                        (event.detail.add && event.detail.add.keys && event.detail.add.keys.size > 0)) {
                        let mutationEventDetail = new self.DataProviderMutationEventDetail(event.detail.add, removeDetail, updateDetail);
                        let eventClone = Object.assign({}, event);
                        eventClone.detail = mutationEventDetail;
                        self.dispatchEvent(eventClone);
                    }
                }
                else {
                    self.dispatchEvent(event);
                }
            });
            // Listen to refresh event on wrapped DataProvider
            dataProvider.addEventListener(MutateEventFilteringDataProvider._REFRESH, (event) => {
                // Invalidate the cache on refresh event
                self.cache.reset();
                self.dispatchEvent(event);
            });
        }
        containsKeys(params) {
            return this.dataProvider.containsKeys(params);
        }
        fetchByKeys(params) {
            const signal = params?.signal;
            const callback = (resolve) => {
                return resolve(this.dataProvider.fetchByKeys(params));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchByOffset(params) {
            const signal = params?.signal;
            const callback = (resolve) => {
                return resolve(this.dataProvider.fetchByOffset(params));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchFirst(params) {
            const asyncIterable = this.dataProvider.fetchFirst(params);
            return new this.MutateEventFilteringAsyncIterable(this, params, asyncIterable[Symbol.asyncIterator](), this.cache);
        }
        getCapability(capabilityName) {
            let capability = this.dataProvider.getCapability(capabilityName);
            if (capabilityName === 'eventFiltering') {
                return { type: 'iterator' };
            }
            return capability;
        }
        getTotalSize() {
            return this.dataProvider.getTotalSize();
        }
        isEmpty() {
            return this.dataProvider.isEmpty();
        }
        _processMutations(detail) {
            let self = this;
            if (detail) {
                let eventDetailKeys = detail[MutateEventFilteringDataProvider._KEYS];
                if (eventDetailKeys && eventDetailKeys.size > 0) {
                    // check if the cache contains the key
                    let removeKeys = new Set();
                    let value = this.cache.getDataByKeys({ keys: eventDetailKeys });
                    eventDetailKeys.forEach(function (key) {
                        if (!value.results.has(key)) {
                            removeKeys.add(key);
                        }
                    });
                    let detailClone = Object.assign({}, detail);
                    removeKeys.forEach(function (key) {
                        let keyArray = [];
                        detailClone.keys.forEach(function (val) {
                            keyArray.push(val);
                        });
                        let keyIndex = keyArray.indexOf(key);
                        // Delete the key from detail key set as well as keyArray to keep them in sync
                        detailClone.keys.delete(key);
                        keyArray.splice(keyIndex, 1);
                        // All detail properties other than keys can be null, so check them before deleting items
                        if (detailClone.data) {
                            detailClone.data.splice(keyIndex, 1);
                        }
                        if (detailClone.indexes) {
                            detailClone.indexes.splice(keyIndex, 1);
                        }
                        if (detailClone.metadata) {
                            detailClone.metadata.splice(keyIndex, 1);
                        }
                    });
                    return detailClone;
                }
            }
            return detail;
        }
    }
    MutateEventFilteringDataProvider._KEY = 'key';
    MutateEventFilteringDataProvider._KEYS = 'keys';
    MutateEventFilteringDataProvider._DATA = 'data';
    MutateEventFilteringDataProvider._METADATA = 'metadata';
    MutateEventFilteringDataProvider._ITEMS = 'items';
    MutateEventFilteringDataProvider._FROM = 'from';
    MutateEventFilteringDataProvider._OFFSET = 'offset';
    MutateEventFilteringDataProvider._REFRESH = 'refresh';
    MutateEventFilteringDataProvider._MUTATE = 'mutate';
    MutateEventFilteringDataProvider._SIZE = 'size';
    MutateEventFilteringDataProvider._FETCHPARAMETERS = 'fetchParameters';
    MutateEventFilteringDataProvider._VALUE = 'value';
    MutateEventFilteringDataProvider._DONE = 'done';
    MutateEventFilteringDataProvider._RESULTS = 'results';
    MutateEventFilteringDataProvider._ADD = 'add';
    MutateEventFilteringDataProvider._UPDATE = 'update';
    MutateEventFilteringDataProvider._REMOVE = 'remove';
    MutateEventFilteringDataProvider._INDEXES = 'indexes';
    ojeventtarget.EventTargetMixin.applyMixin(MutateEventFilteringDataProvider);
    oj._registerLegacyNamespaceProp('MutateEventFilteringDataProvider', MutateEventFilteringDataProvider);

    

    return MutateEventFilteringDataProvider;

});


define('ojs/ojcachedfetchbyoffsetresultsdataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojeventtarget'], function (oj, ojdataprovider, ojeventtarget) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    
    class CachedFetchByOffsetResultsDataProvider {
        constructor(dataProvider, options) {
            this.dataProvider = dataProvider;
            this.options = options;
            this.cache = new oj.DataCache();
            this._lastFetchParams = null;
            // Add createOptimizedKeyMap method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeyMap) {
                this.createOptimizedKeyMap = (initialMap) => {
                    return dataProvider.createOptimizedKeyMap(initialMap);
                };
            }
            // Add createOptimizedKeySet method to this DataProvider if the wrapped DataProvider supports it
            if (dataProvider.createOptimizedKeySet) {
                this.createOptimizedKeySet = (initialSet) => {
                    return dataProvider.createOptimizedKeySet(initialSet);
                };
            }
            // Listen to mutate event on wrapped DataProvider
            dataProvider.addEventListener(CachedFetchByOffsetResultsDataProvider._MUTATE, (event) => {
                // First allow the cache to process the mutations, which may result in different detail
                this.cache.processMutations(event.detail);
                // Then fire mutate with new detail
                this.dispatchEvent(event);
            });
            // Listen to refresh event on wrapped DataProvider
            dataProvider.addEventListener(CachedFetchByOffsetResultsDataProvider._REFRESH, (event) => {
                // Invalidate the cache on refresh event
                this._clearCachedParameters();
                this.dispatchEvent(event);
            });
        }
        containsKeys(params) {
            const finalResults = new Set();
            const neededKeys = new Set();
            // First resolve any keys that can be found in the cache
            const cacheResults = this.cache.getDataByKeys(params);
            params.keys.forEach((key) => {
                const item = cacheResults.results.get(key);
                if (item) {
                    finalResults.add(key);
                }
                else {
                    neededKeys.add(key);
                }
            });
            if (neededKeys.size === 0) {
                // Return the result if all keys have been resolved from cache
                return Promise.resolve({ containsParameters: params, results: finalResults });
            }
            else {
                // If there are unresolved keys, delegate to the wrapped DataProvider
                const newParams = { attributes: params.attributes, keys: neededKeys, scope: params.scope };
                return this.dataProvider.containsKeys(newParams).then((containsKeysResults) => {
                    containsKeysResults.results.forEach((key) => {
                        finalResults.add(key);
                    });
                    return { containsParameters: params, results: finalResults };
                });
            }
        }
        fetchByKeys(params) {
            const finalResults = new Map();
            const neededKeys = new Set();
            const signal = params?.signal;
            const callback = (resolve) => {
                // First resolve any keys that can be found in the cache
                const cacheResults = this.cache.getDataByKeys(params);
                params.keys.forEach((key) => {
                    const item = cacheResults.results.get(key);
                    if (item) {
                        finalResults.set(key, item);
                    }
                    else {
                        neededKeys.add(key);
                    }
                });
                if (neededKeys.size === 0) {
                    // Return the result if all keys have been resolved from cache
                    return resolve({ fetchParameters: params, results: finalResults });
                }
                else {
                    // If there are unresolved keys, delegate to the wrapped DataProvider
                    const newParams = {
                        attributes: params.attributes,
                        keys: neededKeys,
                        scope: params.scope
                    };
                    return resolve(this.dataProvider.fetchByKeys(newParams).then((fetchByKeysResults) => {
                        fetchByKeysResults.results.forEach((item, key) => {
                            finalResults.set(key, item);
                        });
                        return { fetchParameters: params, results: finalResults };
                    }));
                }
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchByOffset(params) {
            const size = params.size ? params.size : CachedFetchByOffsetResultsDataProvider._DEFAULT_SIZE;
            const updatedParams = { ...params };
            updatedParams.size = size;
            const signal = params?.signal;
            const callback = async (resolve) => {
                // Use the cache if the attributes, filterCriterion, and sortCriteria match and the offset is in range
                // We also need to check if the cached rows can satisfy the requested size.
                if (!CachedFetchByOffsetResultsDataProvider._compareCachedFetchParameters(params, this._lastFetchParams)) {
                    this._clearCachedParameters();
                }
                else if (this._doesCacheSatisfyParameters(updatedParams)) {
                    return resolve(this._fetchByOffsetFromCache(params));
                }
                this._lastFetchParams =
                    CachedFetchByOffsetResultsDataProvider._createCachedFetchParams(params);
                await this._fetchByOffsetFromDataProvider(updatedParams);
                return resolve(this._fetchByOffsetFromCache(params));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        fetchFirst(params) {
            return this.dataProvider.fetchFirst(params);
        }
        getCapability(capabilityName) {
            const capability = this.dataProvider.getCapability(capabilityName);
            if (capabilityName === 'fetchByOffset') {
                return { attributeFilter: capability?.attributeFilter, caching: 'visitedByOffset' };
            }
            return capability;
        }
        getTotalSize() {
            // If all the data is cached then we can just return the cache size
            if (this._isAllDataCached()) {
                return Promise.resolve(this.cache.getSize());
            }
            // Otherwise delegate to the wrapped DataProvider
            return this.dataProvider.getTotalSize();
        }
        isEmpty() {
            // If all the data is cached then we can just return the cache size
            if (this._isAllDataCached()) {
                return this.cache.getSize() === 0 ? 'yes' : 'no';
            }
            // Otherwise delegate to the wrapped DataProvider
            return this.dataProvider.isEmpty();
        }
        static _compareCachedFetchParameters(params, cachedParams) {
            params = params || {};
            // prev aborted, curr not aborted
            // ie first aborted, sec not aborted, return false to create a new iterator
            // for case like first not aborted, sec aborted and third not aborted won't return false
            // because sec aborted fetch won't update cachedParams if other params are same
            if (cachedParams != null && cachedParams.signal?.aborted && !params.signal?.aborted) {
                return false;
            }
            // prev not aborted, curr aborted and other cases
            return (cachedParams != null &&
                oj.Object.compareValues(cachedParams.attributes, params.attributes || null) &&
                oj.Object.compareValues(cachedParams.filterDef, CachedFetchByOffsetResultsDataProvider._getFilterDef(params.filterCriterion)) &&
                oj.Object.compareValues(cachedParams.sortCriteria, params.sortCriteria || null));
        }
        static _createCachedFetchParams(params) {
            params = params || {};
            const cachedFetchParams = {};
            cachedFetchParams.size = params.size;
            cachedFetchParams.attributes = params.attributes ? [...params.attributes] : null;
            cachedFetchParams.filterDef = params.filterCriterion
                ? CachedFetchByOffsetResultsDataProvider._getFilterDef(params.filterCriterion)
                : null;
            cachedFetchParams.sortCriteria = params.sortCriteria ? [...params.sortCriteria] : null;
            cachedFetchParams.signal = params.signal;
            return cachedFetchParams;
        }
        static _getFilterDef(filter) {
            if (!filter) {
                return null;
            }
            const filterDef = {};
            Object.keys(filter).forEach((property) => {
                if (property !== 'filter') {
                    filterDef[property] = filter[property];
                }
            });
            return filterDef;
        }
        _doesCacheSatisfyParameters(params) {
            const isDone = this.cache.isDone();
            let isSparse;
            if (params.size === -1) {
                isSparse = this.cache.getSparseIndex(params.offset) > -1;
                return !isSparse && isDone;
            }
            const cacheSize = this.cache.getSize();
            if (params.offset + params.size >= cacheSize && isDone) {
                isSparse = this.cache.getSparseIndex(params.offset, cacheSize) > -1;
                return !isSparse;
            }
            isSparse = this.cache.getSparseIndex(params.offset, params.offset + params.size) > -1;
            return !isSparse && this.cache.getSize() >= params.offset + params.size;
        }
        _isAllDataCached() {
            return this._lastFetchParams != null && !this._lastFetchParams.filterDef && this.cache.isDone();
        }
        async _fetchByOffsetFromDataProvider(params) {
            let endIndex = params.size - 1;
            const cacheSize = this.cache.getSize();
            if (params.offset < cacheSize) {
                const cachedData = this.cache.getDataByOffset(params).results;
                for (let i = 0; i < cachedData.length; i++) {
                    if (cachedData[i] === undefined) {
                        break;
                    }
                    params.offset++;
                    params.size--;
                }
                while (cachedData[endIndex] != undefined) {
                    params.size--;
                    endIndex--;
                }
            }
            const results = await this.dataProvider.fetchByOffset(params);
            this._totalFilteredRowCount = results.totalFilteredRowCount;
            // save sortCriteria to consider implicit sort
            this._cachedSortCriteria = results.fetchParameters.sortCriteria;
            this.cache.addFetchByOffsetResult(results);
        }
        _fetchByOffsetFromCache(params) {
            let results = this.cache.getDataByOffset(params);
            results.fetchParameters.sortCriteria = this._cachedSortCriteria
                ? this._cachedSortCriteria
                : params.sortCriteria;
            if (params.includeFilteredRowCount === 'enabled') {
                results.totalFilteredRowCount = this._totalFilteredRowCount;
            }
            else {
                delete results.totalFilteredRowCount;
            }
            return results;
        }
        _clearCachedParameters() {
            this.cache.reset();
            this._lastFetchParams = null;
            this._totalFilteredRowCount = null;
            this._cachedSortCriteria = null;
        }
    }
    CachedFetchByOffsetResultsDataProvider._REFRESH = 'refresh';
    CachedFetchByOffsetResultsDataProvider._MUTATE = 'mutate';
    CachedFetchByOffsetResultsDataProvider._DEFAULT_SIZE = 25;
    ojeventtarget.EventTargetMixin.applyMixin(CachedFetchByOffsetResultsDataProvider);
    oj._registerLegacyNamespaceProp('CachedFetchByOffsetResultsDataProvider', CachedFetchByOffsetResultsDataProvider);

    return CachedFetchByOffsetResultsDataProvider;

});


define('ojs/ojdataproviderfactory',['exports', 'ojs/ojeventtarget', 'ojs/ojcachediteratorresultsdataprovider', 'ojs/ojcachedfetchbyoffsetresultsdataprovider', 'ojs/ojdedupdataprovider', 'ojs/ojmutateeventfilteringdataprovider'], function (exports, ojeventtarget, CachedIteratorResultsDataProvider, CachedFetchByOffsetResultsDataProvider, DedupDataProvider, MutateEventFilteringDataProvider) { 'use strict';

    CachedIteratorResultsDataProvider = CachedIteratorResultsDataProvider && Object.prototype.hasOwnProperty.call(CachedIteratorResultsDataProvider, 'default') ? CachedIteratorResultsDataProvider['default'] : CachedIteratorResultsDataProvider;
    CachedFetchByOffsetResultsDataProvider = CachedFetchByOffsetResultsDataProvider && Object.prototype.hasOwnProperty.call(CachedFetchByOffsetResultsDataProvider, 'default') ? CachedFetchByOffsetResultsDataProvider['default'] : CachedFetchByOffsetResultsDataProvider;
    DedupDataProvider = DedupDataProvider && Object.prototype.hasOwnProperty.call(DedupDataProvider, 'default') ? DedupDataProvider['default'] : DedupDataProvider;
    MutateEventFilteringDataProvider = MutateEventFilteringDataProvider && Object.prototype.hasOwnProperty.call(MutateEventFilteringDataProvider, 'default') ? MutateEventFilteringDataProvider['default'] : MutateEventFilteringDataProvider;

    /**
     *
     * @ojmodulecontainer ojdataproviderfactory
     * @ojtsmodule
     * @ojhidden
     * @since 12.0.0
     *
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
     * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: ["TreeDataProvider"]}
     *
     * @classdesc
     * <p>This module contains a utility function <code>getEnhancedDataProvider()</code> that enhances a base DataProvier with additional capabilities.
     * </p>
     * <p>The additional capabilites available are:
     * <ul>
     * <li>Caching - the wrapper DataProvider caches the results returned by the iterators of the base DataProvider.
     * The wrapper DataProvider then optimizes fetch methods such as fetchByKeys, fetchByOffset, and containsKeys to retrieve data from cached items
     * before calling the base DataProvider's methods for any missing data.
     * </li>
     * <li>Mutate event filtering - the wrapper DataProvider excludes details of mutate events from the base DataProvider
     * that are not within the range of items previously returned by its iterators.
     * </li>
     * </ul>
     * <p>
     *
     */

    /**
     *
     * Utility function that enhances a base DataProvier with additional capabilities by wrapping it in other DataProviders.
     *
     * @ojexports
     * @memberof ojdataproviderfactory
     * @method
     * @name getEnhancedDataProvider
     * @param {Object} dataProvider - The base DataProvider to enhance.
     * <p>If this is a TreeDataProvider, the base DataProvider and each DataProvider returned by getChildDataProvider will be enhanced.</p>
     * @param {Object} capabilityConfigurations - Capabilities being requested.  The capabilities of the base DataProvider will be checked
     * to see if it already supports at least the requested capabilities.  Any capability it doesn't support will be provided by wrapping DataProviders.
     * <p>For example, if "visitedByCurrentIterator" caching is requested for the fetchFirst capability, and the base DataProvider already supports "all"
     * or "visitedByCurrentIterator" caching, there is no need to wrap it. But if "forceLocalCaching" is set to "enabled" then wrapped dataprovider is returned irrespective of base dataprovider's caching capability.</p>
     * @return {Object} The outermost wrapping DataProvider.  This may be the base DataProvider itself if it already supports all of the requested capabilities.
     * @ojsignature [{target: "Type", value:"<K, D>", for: "genericTypeParameters"},
     *              {target: "Type", value:"DataProvider<K, D>", for:"dataProvider"},
     *              {target: "Type", value:"CapabilityConfigurations", for:"capabilityConfigurations"},
     *              {target: "Type", value:"DataProvider<K, D>", for:"returns"}]
     */

    /**
     *
     * @ojexports
     * @memberof ojdataproviderfactory
     * @typedef {Object} CapabilityConfigurations
     * @property {Object=} fetchFirst - If "visitedByCurrentIterator" is specified for the "caching" property and base dataprovider does not support caching, then enhance the base DataProvider
     * to cache the results returned by its iterators. Cached results, if available, can be returned when fetchByKeys, fetchByOffset, or
     * containsKeys is called on the enhanced DataProvider. If fetchFirst caching and fetchByOffset caching both are specified then fetchByOffset caching wins over fetchFirst.
     * <p>If "forceLocalCaching" is set to "enabled" then wrapped dataprovider is returned irrespective of base dataprovider's caching capability.<p>
     * <p>If "exact" is specified for the "totalFilteredRowCount" property, enhance the base DataProvider to include totalFilteredRowCount in the iterator
     * results.  Note that this enhancement can be expensive because all rows will be iterated to determine totalFilteredRowCount.</p>
     * @property {Object=} fetchByOffset - If "visitedByOffset" is specified for the "caching" property, enhance the base DataProvider
     * to cache the results returned by fetchByOffset calls.  Cached results, if available, can be returned when fetchByKeys, fetchByOffset, or
     * containsKeys is called on the enhanced DataProvider. If fetchFirst caching and fetchByOffset caching both are specified then fetchByOffset caching wins over fetchFirst.<br>
     * Note: In some scenarios, few cached records are refetched to avoid multiple fetch calls to underlying dataprovider. For example, row0 to row9 and row20 to row25 is cached. Now fetch request with offset 10 and size 20 will cause row20 to row25 to be refetched.
     * @property {Object=} eventFiltering - If "iterator" is specified for the "type" property, enhance the base DataProvider to filter mutate
     * events to hide items that are not within range of items that have been returned by its iterators.
     * @ojsignature [
     *  {target: "Type", value: '{caching?: "visitedByCurrentIterator", forceLocalCaching?: "enabled", totalFilteredRowCount?: "exact"}', for: "fetchFirst", jsdocOverride: true},
     *  {target: "Type", value: '{caching?: "visitedByOffset"}', for: "fetchByOffset", jsdocOverride: true},
     *  {target: "Type", value: '{type?: "iterator"}', for: "eventFiltering", jsdocOverride: true}]
     *
     * @ojtsexample <caption>Using getEnhancedDataProvider() to retrieve a wrapper DataProvider with mutate event filtering capability</caption>
     * const enhancedDataProvider = getEnhancedDataProvider(baseDataProvider,
     *   {
     *     eventFiltering: {type: "iterator"},
     *   }
     * );
     *
     * @ojtsexample <caption>Using getEnhancedDataProvider() to retrieve a wrapper DataProvider with caching capability</caption>
     * const enhancedDataProvider = getEnhancedDataProvider(baseDataProvider,
     *   {
     *     fetchFirst: {caching: "visitedByCurrentIterator"}
     *   }
     * );
     *
     * @ojtsexample <caption>Using getEnhancedDataProvider() to retrieve a wrapper DataProvider with all capabilities</caption>
     * const enhancedDataProvider = getEnhancedDataProvider(baseDataProvider,
     *   {
     *     eventFiltering: {type: "iterator"},
     *     fetchFirst: {caching: "visitedByCurrentIterator"}
     *   }
     * );
     */

    function getEnhancedDataProvider(dataProvider, capabilityConfigurations) {
        const fetchFirstCapability = capabilityConfigurations?.fetchFirst;
        const fetchByOffsetCapability = capabilityConfigurations?.fetchByOffset;
        const dedupCapability = capabilityConfigurations?.dedup;
        const eventFilteringCapability = capabilityConfigurations?.eventFiltering;
        const dataProviderFetchFirstCapability = dataProvider.getCapability('fetchFirst') || dataProvider.getCapability('fetchCapability');
        const dataProviderFetchByOffsetCapability = dataProvider.getCapability('fetchByOffset') || dataProvider.getCapability('fetchCapability');
        const dataProviderDedupCapability = dataProvider.getCapability('dedup');
        const dataProviderEventFilteringCapability = dataProvider.getCapability('eventFiltering');
        let needsFetchFirstCaching = false;
        let needsFetchByOffsetCaching = false;
        let needsFetchFirstRowCount = false;
        let needsDedup = false;
        let needsEventFiltering = false;
        const dataProviderFetchFirstCapabilityCaching = dataProviderFetchFirstCapability?.caching;
        const dataProviderFetchByOffsetCapabilityCaching = dataProviderFetchByOffsetCapability?.caching;
        if (fetchFirstCapability?.caching === 'visitedByCurrentIterator' &&
            (fetchFirstCapability?.forceLocalCaching === 'enabled' ||
                (dataProviderFetchFirstCapabilityCaching !== 'all' &&
                    dataProviderFetchFirstCapabilityCaching !== 'visitedByCurrentIterator'))) {
            needsFetchFirstCaching = true;
        }
        const dataProviderFetchFirstCapabilityRowCount = dataProviderFetchFirstCapability?.totalFilteredRowCount;
        if (fetchFirstCapability?.totalFilteredRowCount === 'exact' &&
            dataProviderFetchFirstCapabilityRowCount !== 'exact') {
            needsFetchFirstRowCount = true;
        }
        if (fetchByOffsetCapability?.caching === 'visitedByOffset' &&
            dataProviderFetchByOffsetCapabilityCaching !== 'all' &&
            dataProviderFetchByOffsetCapabilityCaching !== 'visitedByOffset') {
            needsFetchByOffsetCaching = true;
        }
        const dataProviderDedupCapabilityType = dataProviderDedupCapability?.type;
        if (dedupCapability?.type === 'iterator' &&
            dataProviderDedupCapabilityType !== 'global' &&
            dataProviderDedupCapabilityType !== 'iterator') {
            needsDedup = true;
        }
        const dataProviderEventFilteringCapabilityType = dataProviderEventFilteringCapability?.type;
        if (eventFilteringCapability?.type === 'iterator' &&
            dataProviderEventFilteringCapabilityType !== 'global' &&
            dataProviderEventFilteringCapabilityType !== 'iterator') {
            needsEventFiltering = true;
        }
        let wrappedDataProvider = dataProvider;
        if (needsFetchFirstCaching || needsFetchFirstRowCount) {
            wrappedDataProvider = new CachedIteratorResultsDataProvider(wrappedDataProvider, needsFetchFirstRowCount ? { includeFilteredRowCount: 'enabled' } : undefined);
        }
        if (needsFetchByOffsetCaching) {
            wrappedDataProvider = new CachedFetchByOffsetResultsDataProvider(wrappedDataProvider);
        }
        if (needsDedup) {
            wrappedDataProvider = new DedupDataProvider(wrappedDataProvider);
        }
        if (needsEventFiltering) {
            wrappedDataProvider = new MutateEventFilteringDataProvider(wrappedDataProvider);
        }
        // Additionally wrap with EnhancedTreeDataProvider if dataProvider is a TreeDataProvider
        if (dataProvider['getChildDataProvider']) {
            wrappedDataProvider = new EnhancedTreeDataProvider(dataProvider, wrappedDataProvider, capabilityConfigurations);
        }
        return wrappedDataProvider;
    }
    class EnhancedTreeDataProvider {
        constructor(treeDataProvider, enhancedDataProvider, capabilityConfigurations) {
            this.treeDataProvider = treeDataProvider;
            this.enhancedDataProvider = enhancedDataProvider;
            this.capabilityConfigurations = capabilityConfigurations;
            // Listen to mutate event on wrapped DataProvider
            enhancedDataProvider.addEventListener(EnhancedTreeDataProvider._MUTATE, (event) => {
                this.updateCache(event);
                this.dispatchEvent(event);
            });
            // Listen to refresh event on wrapped DataProvider
            enhancedDataProvider.addEventListener(EnhancedTreeDataProvider._REFRESH, (event) => {
                this.flushCache();
                this.dispatchEvent(event);
            });
            // Add createOptimizedKeyMap method to this TreeDataProvider if the wrapped TreeDataProvider supports it
            if (enhancedDataProvider.createOptimizedKeyMap) {
                this.createOptimizedKeyMap = (initialMap) => {
                    return enhancedDataProvider.createOptimizedKeyMap(initialMap);
                };
            }
            // Add createOptimizedKeySet method to this TreeDataProvider if the wrapped TreeDataProvider supports it
            if (enhancedDataProvider.createOptimizedKeySet) {
                this.createOptimizedKeySet = (initialSet) => {
                    return enhancedDataProvider.createOptimizedKeySet(initialSet);
                };
            }
            this._mapKeyToChild = new Map();
        }
        /*** Extra method for TreeDataProvider ***/
        getChildDataProvider(parentKey) {
            const enhancedDP = this._mapKeyToChild.get(parentKey);
            if (enhancedDP) {
                return enhancedDP;
            }
            else {
                return this.cacheEnhancedDataProvider(parentKey);
            }
        }
        /*** Methods for DataProvider ***/
        containsKeys(parameters) {
            return this.enhancedDataProvider.containsKeys(parameters);
        }
        fetchByKeys(parameters) {
            return this.enhancedDataProvider.fetchByKeys(parameters);
        }
        fetchByOffset(parameters) {
            return this.enhancedDataProvider.fetchByOffset(parameters);
        }
        fetchFirst(parameters) {
            return this.enhancedDataProvider.fetchFirst(parameters);
        }
        getCapability(capabilityName) {
            return this.enhancedDataProvider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this.enhancedDataProvider.getTotalSize();
        }
        isEmpty() {
            return this.enhancedDataProvider.isEmpty();
        }
        cacheEnhancedDataProvider(parentKey) {
            const childDataProvider = this.treeDataProvider.getChildDataProvider(parentKey);
            if (childDataProvider) {
                const enhancedDP = getEnhancedDataProvider(childDataProvider, this.capabilityConfigurations);
                this._mapKeyToChild.set(parentKey, enhancedDP);
                return enhancedDP;
            }
            else {
                return null;
            }
        }
        updateCache(event) {
            // add event ignored
            const remove = event.detail.remove;
            const update = event.detail.update;
            let keys;
            if (remove) {
                keys = remove.keys;
                if (keys) {
                    keys.forEach((key) => {
                        this._mapKeyToChild.delete(key);
                    });
                }
            }
            if (update) {
                keys = update.keys;
                if (keys) {
                    keys.forEach((key) => {
                        this._mapKeyToChild.delete(key);
                    });
                }
            }
        }
        flushCache() {
            this._mapKeyToChild.clear();
        }
    }
    EnhancedTreeDataProvider._REFRESH = 'refresh';
    EnhancedTreeDataProvider._MUTATE = 'mutate';
    ojeventtarget.EventTargetMixin.applyMixin(EnhancedTreeDataProvider);

    exports.getEnhancedDataProvider = getEnhancedDataProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojmutablearraydataprovider',['ojs/ojeventtarget', 'ojs/ojarraydataproviderimpl'], function (ojeventtarget, ojarraydataproviderimpl) { 'use strict';

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 4.1.0
     * @export
     * @final
     * @class MutableArrayDataProvider
     * @implements DataProvider
     * @classdesc This class implements {@link DataProvider}.
     *            Object representing data available from an array.
     *            This dataprovider can be used by [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
     *            [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
     *            See the MutableArrayDataProvider and Table - Base Table demos for examples.<br><br>
     *            The default sorting algorithm used when a sortCriteria is passed into fetchFirst is natural sort.
     *
     * <h3 id="events-section">
     *   Events
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
     * </h3>
     * Consumers can add event listeners to listen for the following event types and respond to data change.
     * <h4 id="event:mutate" class="name">
     *   mutate
     * </h4>
     * This event is fired when items have been added or removed from the data.
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>, which implements the {@link DataProviderMutationEventDetail} interface.
     * </p>
     *
     * <h4 id="event:refresh" class="name">
     *   refresh
     * </h4>
     * This event is fired when the data has been refreshed and components need to re-fetch the data.
     * <p>
     * This event contains no additional event payload.
     * </p>
     *
     * <i>Example of consumer listening for the "mutate" event type:</i>
     * <pre class="prettyprint"><code>let listener = function(event) {
     *   if (event.detail.remove) {
     *     const removeDetail = event.detail.remove;
     *     // Handle removed items
     *   }
     * };
     * dataProvider.addEventListener("mutate", listener);
     * </code></pre>
     *
     * @param {Array=} data data supported by the components.
     *  <p>If the data array is frozen, it will be used by MutableArrayDataProvider directly.
     *  If it is not frozen, MutableArrayDataProvider will make a shallow copy and use the copy.
     *  Mutations to the original array will not be reflected in MutableArrayDataProvider.
     *  The only way to mutate the data in MutableArrayDataProvider is by setting the "data" property to another array.
     *  </p>
     * @param {MutableArrayDataProvider.Options=} options Options for the ArrayDataProvider
     * @ojsignature [{target: "Type",
     *               value: "class MutableArrayDataProvider<K, D> implements DataProvider<K, D>",
     *               genericTypeParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "MutableArrayDataProvider.Options<D>",
     *               for: "options"}]
     *
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     * "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     * "FetchListResult","FetchListParameters"]}
     * @ojtsmodule
     * @ojtsexample
     * // First initialize an array
     * let deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
     *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
     *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
     * // Then create an MutableArrayDataProvider object with the array
     * let dataprovider = new MutableArrayDataProvider(deptArray, {keyAttributes: 'DepartmentId'});
     * @example
     * // First initialize an array
     * let deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
     *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
     *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
     * // Then create an MutableArrayDataProvider object with the array
     * let dataprovider = new MutableArrayDataProvider(deptArray, {keyAttributes: 'DepartmentId'});
     */

    /**
     * @typedef {Object} MutableArrayDataProvider.SortComparators
     * @property {Object} comparators - Sort comparators. Map of attribute to comparator function.
     * @ojsignature [
     *   {target: "Type", value: "<D>", for: "genericTypeParameters"},
     *   {target: "Type", value: "Map<keyof D, (a: any, b: any) => number>", for: "comparators"}]
     */

    /**
     * <p>The underlying data array.
     * </p>
     * <p>Applications can get and set this property directly, such as setting it to a different array.
     * </p>
     * <p>The array returned by the "data" property is frozen.  Applications cannot call array mutation methods
     * such as splice or push on "data" directly.  Applications need to make a copy of the array, mutate the copy,
     * and set it back into the "data" property.
     * </p>
     * <p>When setting this property, MutableArrayDataProvider will shallow compare the new data array with
     * the existing data array to determine if it can fire "mutate" event with add/remove/update details.
     * It will fire the "refresh" event if it cannot make that determination (e.g. if the two arrays are vastly different.)
     * </p>
     * @since 10.0.0
     * @name data
     * @export
     * @expose
     * @memberof MutableArrayDataProvider
     * @instance
     * @property {D[]} data
     * @ojsignature {target: "Type", value: "D[]"}
     */

    /**
     * @typedef {Object} MutableArrayDataProvider.Options
     * @property {MutableArrayDataProvider.SortComparators=} sortComparators - Optional sortComparator for custom sort.
     * <p>
     * Sort follows JavaScript's localeCompare <code>{numeric: true}</code>.
     * Please check {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#numeric_sorting|String.prototype.localeCompare()} for details.
     * </p>
     * <p>
     * For numbers, we convert them into strings then compare them with localeCompare, which may not sort floating point numbers based on their numeric values.
     * If you want to sort floating point numbers based on their numeric values, sortComparator can be used to do a custom sort.
     * </p>
     * <p>
     * For undefined and null values, they are considered as the largest values during sorting. For an empty string, it is considered as the smallest value during sorting.
     * </p>
     * @property {SortCriterion=} implicitSort - Optional array of {@link SortCriterion} used to specify sort information when the data loaded into the dataprovider is already sorted.
     * This is used for cases where we would like display some indication that the data is already sorted.
     * For example, ojTable will display the column sort indicator for the corresponding column in either ascending or descending order upon initial render.
     * This option is not used for cases where we want the MutableArrayDataProvider to apply a sort on initial fetch.
     * For those cases, please wrap in a ListDataProviderView and set the sortCriteria property on it.
     * @property {string=} keyAttributes - Optionally the field name which stores the key in the data. Can be a string denoting a single key attribute or an array
     *                                                  of strings for multiple key attributes. Please note that the ids in MutableArrayDataProvider must always be unique. Please do not introduce duplicate ids, even during temporary mutation operations. @index causes MutableArrayDataProvider to use index as key and @value will cause MutableArrayDataProvider to
     *                                                  use all attributes as key. @index is the default.
     * @property {string=} textFilterAttributes - Optionally specify which attributes the filter should be applied on when a TextFilter filterCriteria is specified. If this option is not specified then the filter will be applied to all attributes.
     * @property {string=} enforceKeyStringify - Optionally specify whether keys need to be converted to strings. Supported values:<br>
     *                                  <ul>
     *                                    <li>'off': the key values are returned as it is.
     *                                    <li>'on': the key values are converted into string.
     *                                  </ul>
     *                                Default is 'off'.
     *                                Key stringify will directly call JSON.stringify on all keys passed out of the DataProvider. Use JSON.parse if you need to convert the key back to a complex type.
     * @ojsignature [
     *  {target: "Type", value: "<D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "MutableArrayDataProvider.SortComparators<D>", for: "sortComparators"},
     *  {target: "Type", value: "Array<SortCriterion<D>>", for: "implicitSort"},
     *  {target: "Type", value: "string | string[]", for: "keyAttributes"},
     *  {target: "Type", value: "string[]", for: "textFilterAttributes"},
     *  {target: "Type", value: "'off' | 'on'", for: "enforceKeyStringify"}
     * ]
     * @ojtsexample <caption>Examples for sortComparator</caption>
     * // Custom comparator for date
     * let comparator = function (a, b) {
     *    if (a === b) {
     *      return 0;
     *    }
     *
     *    let dateA = new Date(a).getTime();
     *    let dateB = new Date(b).getTime();
     *    return dateA > dateB ? 1 : -1;
     * };
     * // Then create an MutableArrayDataProvider object and set Date field to use the this comparator
     * this.dataprovider = new MutableArrayDataProvider(JSON.parse(deptArray), {
     *    keyAttributes: "DepartmentId",
     *    sortComparators: { comparators: new Map().set("Date", comparator) },
     * });
     * @ojtsexample
     * // Custom comparator for number
     * let comparator = function (a, b) {
     *    return a - b;
     *  };
     * // Then create an MutableArrayDataProvider object and set Salary field to use the this comparator
     * this.dataprovider = new MutableArrayDataProvider(JSON.parse(deptArray), {
     *    keyAttributes: "DepartmentId",
     *    sortComparators: { comparators: new Map().set("Salary", comparator) },
     * });
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    // This code is adapted from ko.utils.compareArrays
    const compareArrays = (oldArray, newArray) => {
        const statusNotInOld = 'added';
        const statusNotInNew = 'deleted';
        oldArray = oldArray || [];
        newArray = newArray || [];
        if (oldArray.length < newArray.length) {
            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew);
        }
        else {
            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld);
        }
    };
    const compareSmallArrayToBigArray = (smlArray, bigArray, statusNotInSml, statusNotInBig) => {
        const myMin = Math.min;
        const myMax = Math.max;
        const editDistanceMatrix = [];
        let smlIndex;
        const smlIndexMax = smlArray.length;
        let bigIndex;
        const bigIndexMax = bigArray.length;
        const compareRange = bigIndexMax - smlIndexMax || 1;
        const maxDistance = smlIndexMax + bigIndexMax + 1;
        let thisRow;
        let lastRow;
        let bigIndexMaxForRow;
        let bigIndexMinForRow;
        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
            lastRow = thisRow;
            editDistanceMatrix.push((thisRow = []));
            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
            bigIndexMinForRow = myMax(0, smlIndex - 1);
            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
                if (!bigIndex) {
                    thisRow[bigIndex] = smlIndex + 1;
                }
                else if (!smlIndex) {
                    // Top row - transform empty array into new array via additions
                    thisRow[bigIndex] = bigIndex + 1;
                }
                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1]) {
                    thisRow[bigIndex] = lastRow[bigIndex - 1];
                }
                // copy value (no edit)
                else {
                    const northDistance = lastRow[bigIndex] || maxDistance; // not in big (deletion)
                    const westDistance = thisRow[bigIndex - 1] || maxDistance; // not in small (addition)
                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
                }
            }
        }
        const editScript = [];
        let meMinusOne;
        const notInSml = [];
        const notInBig = [];
        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex - 1]) {
                --bigIndex;
                notInSml.push((editScript[editScript.length] = {
                    // added
                    status: statusNotInSml,
                    value: bigArray[bigIndex],
                    index: bigIndex
                }));
            }
            else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
                --smlIndex;
                notInBig.push((editScript[editScript.length] = {
                    // deleted
                    status: statusNotInBig,
                    value: smlArray[smlIndex],
                    index: smlIndex
                }));
            }
            else {
                --bigIndex;
                --smlIndex;
            }
        }
        return editScript.reverse();
    };

    class MutableArrayDataProvider {
        /**
         * If value is frozen, just use the value.
         * Otherwise, make a shallow copy of the data and freeze the copy.
         *
         * If value is an array, just use the array.
         * Otherwise, make it an array
         */
        set data(value) {
            const oldData = this._data?.slice() ?? [];
            let newData;
            if (Array.isArray(value)) {
                if (Object.isFrozen(value)) {
                    newData = value;
                }
                else {
                    newData = value.slice();
                    Object.freeze(newData);
                }
            }
            else {
                newData = value == undefined ? [] : [].concat(value);
            }
            if ((oldData.length === 0 && newData.length > 0) ||
                (newData.length === 0 && oldData.length > 0)) {
                this._keys = null; // reset keys so the new fetch will regenerate
                this._data = newData;
                this._impl.flushQueue();
                this._impl.resetTotalFilteredRowCount();
            }
            else {
                // Need to ensure keys have been generated from old data so that we can
                // generate the correct mutation payload;
                this._generateKeysIfNeeded(() => this._impl.generateKeys());
                this._data = newData;
                this._changes = compareArrays(oldData, this._data);
                if (this._changes != null && this._changes.length > 0) {
                    this._impl.queueMutationEvent(this._changes);
                    this._impl.flushQueue();
                }
            }
        }
        get data() {
            return this._data;
        }
        get dataChanges() {
            return this._changes;
        }
        constructor(_data = [], options) {
            this._data = _data;
            this.options = options;
            this._impl = new ojarraydataproviderimpl.ArrayDataProviderImpl(options, {
                getData: () => this._data,
                getKeys: () => this._keys,
                generateKeysIfNeeded: (generateKeys) => this._generateKeysIfNeeded(generateKeys),
                mergeSortCriteria: (sortCriteria) => this._mergeSortCriteria(sortCriteria),
                getSortComparator: (sortCriteria) => this._getSortComparator(sortCriteria),
                dispatchEvent: (event) => this.dispatchEvent(event),
                supportAbortController: false,
                getKeyForDelete: (change, generatedKeys) => this._getKeyForDelete(change, generatedKeys),
                spliceKeys: (...args) => this._keys.splice(...args),
                keysSpecified: false
            });
            this.data = _data;
        }
        containsKeys(containsParameters) {
            return this._impl.containsKeys(containsParameters);
        }
        fetchByKeys(fetchParameters) {
            return this._impl.fetchByKeys(fetchParameters);
        }
        fetchByOffset(params) {
            return this._impl.fetchByOffset(params);
        }
        /**
         * Fetch the first block of data
         */
        fetchFirst(params) {
            return this._impl.fetchFirst(params);
        }
        /**
         * Determines whether this DataProvider supports certain feature.
         */
        getCapability(capabilityName) {
            return ojarraydataproviderimpl.getCapability(capabilityName);
        }
        static getCapability(capabilityName) {
            return ojarraydataproviderimpl.getCapability(capabilityName);
        }
        getTotalSize() {
            return this._impl.getTotalSize();
        }
        isEmpty() {
            return this._impl.isEmpty();
        }
        /**
         * Return an empty Set which is optimized to store keys
         */
        createOptimizedKeySet(initialSet) {
            return ojarraydataproviderimpl.createOptimizedKeySet(initialSet);
        }
        /**
         * Returns an empty Map which will efficiently store Keys returned by the DataProvider
         */
        createOptimizedKeyMap(initialMap) {
            return ojarraydataproviderimpl.createOptimizedKeyMap(initialMap);
        }
        _getKeyForDelete(change, generatedKeys) {
            // MutableArrayDataProvider can guarantee that keys have been generated for the item
            // being deleted, whether or not the DataProvider has received a fetch request.  As a result,
            // it's safe to just do a key lookup here
            return this._keys[change.index];
        }
        /**
         * Generate keys array if it wasn't passed in options.keys
         */
        _generateKeysIfNeeded(generateKeys) {
            if (this._keys == null) {
                this._keys = generateKeys();
                return true;
            }
            return false;
        }
        /**
         * Apply sort comparators
         */
        _getSortComparator(sortCriteria) {
            return (x, y) => {
                const sortComparators = this.options != null ? this.options.sortComparators : null;
                let i, direction, attribute, comparator, xval, yval;
                for (i = 0; i < sortCriteria.length; i++) {
                    direction = sortCriteria[i].direction;
                    attribute = sortCriteria[i].attribute;
                    comparator = null;
                    if (sortComparators != null) {
                        comparator = sortComparators.comparators.get(attribute);
                    }
                    xval = ojarraydataproviderimpl.getVal(x.value, attribute);
                    yval = ojarraydataproviderimpl.getVal(y.value, attribute);
                    if (comparator != null) {
                        const descendingResult = direction == 'descending' ? -1 : 1;
                        const comparatorResult = comparator(xval, yval) * descendingResult;
                        if (comparatorResult != 0) {
                            return comparatorResult;
                        }
                    }
                    else {
                        let compareResult = 0;
                        const strX = typeof xval === 'string' ? xval : new String(xval).toString();
                        const strY = typeof yval === 'string' ? yval : new String(yval).toString();
                        if (direction === 'ascending') {
                            if (strX === 'null' || strX === 'undefined') {
                                return 1;
                            }
                            if (strY === 'null' || strY === 'undefined') {
                                return -1;
                            }
                            compareResult = strX.localeCompare(strY, undefined, {
                                numeric: true,
                                sensitivity: 'base'
                            });
                        }
                        else {
                            if (strX === 'null' || strX === 'undefined') {
                                return -1;
                            }
                            if (strY === 'null' || strY === 'undefined') {
                                return 1;
                            }
                            compareResult = strY.localeCompare(strX, undefined, {
                                numeric: true,
                                sensitivity: 'base'
                            });
                        }
                        if (compareResult != 0) {
                            return compareResult;
                        }
                    }
                }
                return 0;
            };
        }
        /**
         * Merge sort criteria
         */
        _mergeSortCriteria(sortCriteria) {
            if (sortCriteria && sortCriteria.length > 0) {
                return sortCriteria;
            }
            else {
                return this.options?.implicitSort;
            }
        }
    }
    ojeventtarget.EventTargetMixin.applyMixin(MutableArrayDataProvider);

    return MutableArrayDataProvider;

});


define('ojs/ojmutablearraytreedataprovider',['exports', 'ojs/ojcore-base', 'ojs/ojarraydataprovider', 'ojs/ojeventtarget', 'ojs/ojlogger'], function (exports, oj, ArrayDataProvider, ojeventtarget, Logger) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    ArrayDataProvider = ArrayDataProvider && Object.prototype.hasOwnProperty.call(ArrayDataProvider, 'default') ? ArrayDataProvider['default'] : ArrayDataProvider;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /**
     * @since 13.0.0
     * @class MutableArrayTreeDataProvider
     * @implements TreeDataProvider
     * @ojexports
     * @classdesc This class implements {@link TreeDataProvider} and is used to represent hierachical data available from an array.<br><br>
     *            Each array element represents a tree node, which can contain a nested child object array for its subtree.
     *            Array elements can be in any shape and form, but is usually an object with a "children" property.  The name of the "children" property
     *            can optionally be specified with the "childrenAttribute" option.<br><br>
     *            For nodes that cannot have children, the "children" property should not be set.
     *            For nodes that can but don't have children, the "children" property should be set to an empty array.<br><br>
     *            The events described below will be dispatched to the MutableArrayTreeDataProvider with the appropriate event payload.<br><br>
     *            Filtering is supported and, by default, applied only on leaf nodes. Empty tree nodes are not collapsed.
     *            The filtering on leaf nodes only works by combining the passed in filter definition with an OR expression
     *            of the "children" property to determine if a node is a tree or leaf.
     *
     * <h3 id="events-section">
     * Events
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
     * </h3>
     * <p>Consumers can add event listeners to listen for the following event types and respond to data change.
     * Event listeners should be added to the root-level MutableArrayTreeDataProvider created by the application. The root-level MutableArrayTreeDataProvider receives events for the entire tree.
     * Child-level MutableArrayTreeDataProvider returned by getChildDataProvider does not receive events.
     * </p>
     * <h4 id="event:mutate" class="name">
     * mutate
     * </h4>
     * This event is fired when items are added into a leaf node or updated in an array.  The event is the array specific.
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>, which implements the {@link DataProviderMutationEventDetail} interface.
     * </p>
     *
     * <h4 id="event:refresh" class="name">
     *   refresh
     * </h4>
     * <p>
     * This event with no payload is fired when the data has been refreshed and components need to re-fetch the data.
     * In this case, the re-fetch is from the root.
     * </p>
     * <p>This event with payload 'keys' is fired when updated nodes include any changes in their children.  The 'keys' is
     * the set of keys of the nodes with changes in their children, and components need to re-fetch the sub-tree of 'keys'.
     * In this case, the re-fetch should be from each key.
     * </p>
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>,
     * which implements the {@link DataProviderRefreshEventDetail} interface.
     * </p>
     *
     * <i>Example of a tree structured data:</i>
     * <pre class="prettyprint"><code>
     * // initiate an array
     * const treeData = [
     *   {title:"News", id:"news"},
     *   {title:"Blogs", id:"blogs", "children": [
     *     {title:"Today", id:"today"},
     *     {title:"Yesterday", id:"yesterday"},
     *     {title:"Archive", id:"archive", "children": [
     *       {title: "Links", id:'links'}
     *      ]}
     *   ]}
     * ];
     * Initial an immutable array treeData.
     * </code></pre>
     *
     * <p>With the data above, the following are actions on an array and events expected.
     * The mutation are created according to <a href="#algorithm-section">Algorithm section</a>, check it for more details.
     * </p>
     *<table class="keyboard-table">
     *  <thead>
     *    <tr>
     *      <th width='15%'>Action</th>
     *      <th width='20%'>Example Code</th>
     *      <th width='15%'>Expected Events</th>
     *   </tr>
     * </thead>
     *  <tbody>
     *  <tr>
     *  <td><kbd>Add a node as a sibling to non-root node</kbd></td>
     *     <td>
     *      <pre class="prettyprint">
     *       <code>
     * Add a sibling 'Links' node next to 'Today'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = addNode(treeData, [1, 1],
     *  {title: "Links", id: "links"});
     * rootTreeDataProvider.data = treeData;
     *       </code>
     *       </pre>
     *      </td>
     *    <td><a href="#algorithm-section-step3">'refresh': {keys: 'blogs'}</a></td>
     *  </tr>
     *  <tr>
     *    <tr>
     *      <td><kbd>Add node 'Links' as a sibling to root node</kbd></td>
     *      <td>
     *       <pre class="prettyprint">
     *        <code>
     * Add a sibling node 'Links' next to 'Blogs'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = addNode(treeData, [1],
     *  {title: "Links", id: "links"});
     * rootTreeDataProvider.data = treeData;
     *        </code>
     *        </pre>
     *      </td>
     *      <td><a href="#algorithm-section-step3">'refresh'</a></td>
     *    </tr>
     *    <tr>
     *    <td><kbd>Add a child to a non-root non-leaf node </kbd></td>
     *    <td>
     *     <pre class="prettyprint">
     *      <code>
     * Add a child node 'Child3' under 'Archive'<br/>
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = addNode(treeData,
     *  [1, 2, 0],
     *  {title: "Child3", id: "child3"});
     * rootTreeDataProvider.data = treeData;
     *      </code>
     *      </pre>
     *    </td>
     *    <td><a href="#algorithm-section-step3">'refresh': {keys: 'archive'}</a></td>
     *  </tr>
     *    <td><kbd>Add a child to a non-root leaf node </kbd></td>
     *    <td>
     *     <pre class="prettyprint">
     *      <code>
     * Add a child node 'Child1' under 'Today'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = addNode(treeData,
     *  [1, 0, 0],
     *  {title: "Child1", id: "child1"});
     * rootTreeDataProvider.data = treeData;
     *      </code>
     *      </pre>
     *    </td>
     *    <td><a href="#algorithm-section-step3">'refresh': {keys: 'blogs'}</a></td>
     *    <tr>
     *      <td><kbd>Add a child to a root leaf node </kbd></td>
     *      <td>
     *       <pre class="prettyprint">
     *        <code>
     * Add another child node 'Child2' under 'News'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = addNode(treeData, [0, 0],
     *  {title: "Child2", id: "child2"});
     * rootTreeDataProvider.data = treeData;
     *        </code>
     *        </pre>
     *      </td>
     *      <td><a href="#algorithm-section-step3">'refresh'</a></td>
     *    </tr>
     *     <td><kbd>Add a child to a root non-leaf node </kbd></td>
     *     <td>
     *      <pre class="prettyprint">
     *       <code>
     * Add a child node 'Child4' under 'Blogs'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = addNode(treeData, [1, 0],
     *  {title: "Child4", id: "child4"});
     * rootTreeDataProvider.data = treeData;
     *       </code>
     *       </pre>
     *     </td>
     *     <td><a href="#algorithm-section-step3">'refresh': {keys: 'blogs'}</a></td>
     * </tr>
     * <tr>
     *   <tr>
     *     <td><kbd>Remove a non-root node</kbd></td>
     *     <td>
     *      <pre class="prettyprint">
     *       <code>
     * Remove node 'Yesterday' under parent node Blogs
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = removeNode(treeData,
     *  [1, 1]);
     * rootTreeDataProvider.data = treeData;
     *       </code>
     *       </pre>
     *         </td>
     *     <td><a href="#algorithm-section-step3">'refresh': {keys: 'blogs'}</a></td>
     *   </tr>
     *     <tr>
     *   <td><kbd>Remove a root node</kbd></td>
     *   <td>
     *    <pre class="prettyprint">
     *     <code>
     * Remove node 'News'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = removeNode(treeData, [0]);
     * rootTreeDataProvider.data = treeData;
     *     </code>
     *     </pre>
     *       </td>
     *   <td><a href="#algorithm-section-step3">'refresh'</a></td>
     * </tr>
     * <tr>
     *   <td><kbd>Remove (change a root non-leaf node to root leaf node)</kbd></td>
     *   <td>
     *    <pre class="prettyprint">
     *     <code>
     * Remove child node under 'Blogs'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = removeNode( treeData, [1, 0]);
     * rootTreeDataProvider.data = treeData;
     *     </code>
     *     </pre>
     *       </td>
     *   <td><a href="#algorithm-section-step3">'refresh'</a></td>
     * </tr>
     * <tr>
     *   <td><kbd>Remove (change a non-root non-leaf node to non-root leaf node)</kbd></td>
     *   <td>
     *    <pre class="prettyprint">
     *     <code>
     * Remove child node under 'Today'
     * // for example you can use util functions from ojimmutabletreedatautils
     * treeData = removeNode( treeData,
     *  [1, 0, 0]);
     * rootTreeDataProvider.data = treeData;
     *     </code>
     *     </pre>
     *       </td>
     *   <td><a href="#algorithm-section-step3">'refresh': {keys: 'blogs'}</a></td>
     * </tr>
     * <tr>
     *   <td><kbd>Update a node</kbd></td>
     *   <td>
     *   <pre class="prettyprint">
     *     <code>
     * Update node 'News' to 'OldNews'
     * // for example you can use util functions from ojimmutabletreedatautils
     * const newNode = {...treeData[0]};
     * treeData = reolaceNode( treeData,
     *  [0], newNode);
     * rootTreeDataProvider.data = treeData;
     *     </code>
     *     </pre>
     *       </td>
     *   <td><a href="#algorithm-section-step2">mutation': {update: {keys: 'news', data:{title: 'OldNews', id: 'news'}}}</a></td>
     * </tr>
     * </tbody>
     *  </table>
     * <br/>
     *
     * <i>Example of consumer listening for the events:</i>
     * <pre class="prettyprint"><code>
     * dataProvider.addEventListener("mutate", handleMutate);
     * dataProvider.addEventListener("refresh", handleRefresh);
     *
     * const handleMutate = function(event) {
     *   if (event.detail.update) {
     *     const updateDetail = event.detail.update;
     *     // Handle updated items
     *   }
     * };
     *
     * const handleRefresh = function(event) {
     *   const detail=event.detail;
     *   if (detail && detail.keys) {
     *     event.detail.keys.forEach ((key) => {
     *       // refresh children for key
     *     });
     *   }
     *   else {
     *     // refresh children for root
     *   }
     * }
     * </code></pre>
     *
     * <h3 id="algorithm-section">
     * Algorithm
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#algorithm-section"></a>
     * </h3>
     * <p>
     * When setting this property, MutableArrayTreeDataProvider will use the following algorithm to compare:
     * We would use limited recursive deep comparison to figure out what mutation events to fire.
     * This is done to avoid having to fire a top-level refresh event for any mutation of the subtree.
     * We can start by optimizing only the case where there the number of children is still the same,
     * and the identity comparison fails for at most one child:<br/>
     * <ol>
     * <li><h4 id="algorithm-section-step1"></h4>
     * If the two nodes are equal, we are done. There are no changes.</li>
     * <li><h4 id="algorithm-section-step2"></h4>
     * If they are not equal, we fire an update mutation. Note that we do not deep-compare the nodes properties.</li>
     * <li><h4 id="algorithm-section-step3"></h4>
     * We compare the nodes old and new child lists. If the sizes are different, we fire a refresh
     * event with 'parentKey' and do not recurse further</li>
     * <li><h4 id="algorithm-section-step4"></h4>
     * If we find more than one child with identity comparison failing, we fire a refresh event with 'parentKey'
     * and do not recurse further</li>
     * <li><h4 id="algorithm-section-step5"></h4>
     * If we find 0 children with identity comparison failing, we do not recurse further</li>
     * <li><h4 id="algorithm-section-step6"></h4>
     * If we find 1 child with identity comparison failing, we recurse into that child and repeat these steps from the beginning</li>
     * </ol>
     * </p>
     *
     * @param {any} data Applications shouldn't call array mutation methods such as splice or push on "data" directly.
     * Applications need to use {@link ojimmutabletreedatautils} or immutable libs like immutablejs to update the array, and set it back into the "data" property.
     * @param {string} keyAttribute The field name which stores the key in the data. Can be a string denoting a single key attribute. Please note that the ids in MutableArrayTreeDataProvider must always be unique.
     *                                                  Please do not introduce duplicate ids, even during temporary mutation operations.@value will cause MutableArrayTreeDataProvider to
     *                                                  use all attributes as key.
     * @param {MutableArrayTreeDataProvider.Options=} options Options for the MutableArrayTreeDataProvider
     * @ojsignature [{target: "Type",
     *               value: "class MutableArrayTreeDataProvider<K, D> implements TreeDataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "MutableArrayTreeDataProvider.Options<D>",
     *               for: "options"},
     *               {target: "Type", value: "string | '@value'", for: "keyAttribute"}
     * ]
     * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: "TreeDataProvider"}
     * @ojtsimport {module: "ojarraydataprovider", type: "AMD", importName: "ArrayDataProvider"}
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion",
     *   "FetchByKeysParameters","ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters", "FetchByOffsetResults",
     *   "FetchListResult","FetchListParameters"]}
     * @ojtsexample
     * import { MutableArrayTreeDataProvider } from "ojs/ojmutablearraytreedataprovider";
     * // First initialize the tree data.  This can be defined locally or read from file.
     * const treeData = [
     *                  {"attr": {"id": "dir1", "title": "Directory 1"},
     *                   "children": [
     *                     {"attr": {"id": "subdir1", "title": "Subdirectory 1"},
     *                      "children": [
     *                        {"attr": {"id": "file1", "title": "File 1"}},
     *                        {"attr": {"id": "file2", "title": "File 2"}},
     *                        {"attr": {"id": "file3", "title": "File 3"}}
     *                      ]},
     *                     {"attr": {"id": "subdir2", "title": "Subdirectory 2"},
     *                      "children": []}
     *                   ]},
     *                  {"attr": {"id": "dir2", "title": "Directory 2"},
     *                   "children": [
     *                     {"attr": {"id": "file4", "title": "File 4"}},
     *                     {"attr": {"id": "file5", "title": "File 5"}},
     *                   ]}
     *                ];
     *
     * // Then create an MutableArrayTreeDataProvider object with the array
     * create an immutable array treeDataImmutable
     * const dp = new MutableArrayTreeDataProvider(treeDataImmutable, 'attr.id');
     */

    /**
     * @memberof MutableArrayTreeDataProvider
     * @typedef {Object} MutableArrayTreeDataProvider.Options
     * @property {ArrayDataProvider.SortComparators=} sortComparators - Optional sortComparator to use for sort.
     * <p>
     * Sort follows JavaScript's localeCompare <code>{numeric: true}</code>.
     * Please check {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#numeric_sorting|String.prototype.localeCompare()} for details.
     * </p>
     * <p>
     * For numbers, we convert them into strings then compare them with localeCompare, which may not sort floating point numbers based on their numeric values.
     * If you want to sort floating point numbers based on their numeric values, sortComparator can be used to do a custom sort.
     * </p>
     * <p>
     * For undefined and null values, they are considered as the largest values during sorting. For an empty string, it is considered as the smallest value during sorting.
     * </p>
     * @property {SortCriterion=} implicitSort - Optional array of {@link SortCriterion} used to specify sort information when the data loaded into the dataprovider is already sorted.
     * This is used for cases where we would like display some indication that the data is already sorted.
     * For example, ojTable will display the column sort indicator for the corresponding column in either ascending or descending order upon initial render.
     * This option is not used for cases where we want the MutableArrayTreeDataProvider to apply a sort on initial fetch.
     * For those cases, please wrap in a ListDataProviderView and set the sortCriteria property on it.
     * @property {string=} textFilterAttributes - Optionally specify which attributes the filter should be applied on when a TextFilter
     * filterCriteria is specified. If this option is not specified then the filter will be applied to all attributes.
     * @property {string=} keyAttributeScope - Optional scope of the key values in the fields specified by keyAttribute.  Supported values:<br>
     *                                           <ul>
     *                                             <li>'global': the key values are unique within the entire tree.
     *                                             <li>'siblings': the key values are unique among the siblings of each node.
     *                                           </ul>
     *                                           Default is 'global'.
     * @property {string=} childrenAttribute - Optional field name which stores the children of nodes in the data. Dot notation can be used to specify nested attribute. If this is not specified, the default is "children".
     * @property {string=} enforceKeyStringify - Optionally specify whether keys should be stringified version of keypath from root. Supported values:<br>
     *                                  <ul>
     *                                    <li>'off': the key values are returned as it is.
     *                                    <li>'on': the key values are stringified version of keypath from root unless useKeyPath is set to 'off'.
     *                                  </ul>
     *                                Default is 'off'.
     *                                Key stringify will directly call JSON.stringify on all keys passed out of the DataProvider. Use JSON.parse if you need to convert the key back to a complex type.
     *                                When used with useKeyPaths the JSON.stringify will happen after the pathing is finished. JSON.parse will then result in an K[]
     * @property {string=} useKeyPaths - Optionally indicate to the TreeDataProvider to generate key paths. Key paths will be represented as an array of type K[] (unless used with enforceKeyStringify - see enforceKeyStringify for more details)
     * with elements ordered according to their depth. Specifically, the first element in the array corresponds to the least depth, and subsequent elements represent increasing depths.
     * @ojsignature [
     *  {target: "Type", value: "<D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "ArrayDataProvider.SortComparators<D>", for: "sortComparators"},
     *  {target: "Type", value: "Array<SortCriterion<D>>", for: "implicitSort"},
     *  {target: "Type", value: "string[]", for: "textFilterAttributes"},
     *  {target: "Type", value: "'siblings' | 'global'", for: "keyAttributeScope"},
     *  {target: "Type", value: "string", for: "childrenAttribute"},
     *  {target: "Type", value: "'off' | 'on'", for: "enforceKeyStringify"},
     *  {target: "Type", value: "'off' | 'on'", for: "useKeyPaths"}
     * ]
     */

    /**
     * <p>The underlying data array.
     * </p>
     * <p>Applications can get this property directly only can set it on the root data provider, such as setting it to a different array.
     * </p>
     * <p>Applications should not call array mutation methods
     * such as splice or push on "data" directly.  Applications need to create a new immutable array by {@link ojimmutabletreedatautils} or
     * immutable libs and set it back into the "data" property.
     * </p>
     * @since 13.0.0
     * @name data
     * @export
     * @expose
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @property {any} data
     * @ojsignature {target: "Type", value: "any"}
     * @ojtsexample <caption>Example of mutating the entire tree</caption>
     * const rootTreeDataProvider = new MutableArrayTreeDataProvider(rootData, 'id');
     * let newRootData;
     * Initialize newRootData to a new immutable array newRootDataImmutable
     * rootTreeDataProvider.data = newRootDataImmutable;
     * @ojtsexample <caption>Example of mutating the data in a branch</caption>
     * create an immutable array immutableData
     * const rootTreeDataProvider = new MutableArrayTreeDataProvider(immutableData, 'id');
     * update immutableData
     * // set it back to rootTreeDataProvider.data
     * rootTreeDataProvider.data = immutableData;
     */

    /**
     * @memberof MutableArrayTreeDataProvider
     * @export
     * @since 13.0.0
     * @expose
     * @instance
     * @method
     * @name getChildDataProvider
     * @ojsignature {target: "Type",
     *               value: "(parentKey: K): MutableArrayTreeDataProvider<K, D> | null"}
     * @return {MutableArrayTreeDataProvider | null} A TreeDataProvider if the row can (but doesn't have to) have children;
     * or null if the row cannot have children.
     * Use the <code class="prettyprint">isEmpty</code> method on the returned TreeDataProvider to determine if it currently has children.
     * @ojtsexample <caption>Example for getChildDataProvider</caption>
     * // Get child data provider for node 10
     * let childDataProvider = dataprovider.getChildDataProvider(10);
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof MutableArrayTreeDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    // end of jsdoc

    class MutableArrayTreeDataProvider {
        set data(value) {
            const oldData = this._data == undefined ? [] : this._data;
            this._data = value;
            if (this._getRootDataProvider() !== this) {
                return;
            }
            if (((oldData == undefined || oldData.length === 0) &&
                this._data != undefined &&
                this._data.length > 0) ||
                ((this._data == undefined || this._data.length === 0) &&
                    oldData != undefined &&
                    oldData.length > 0) ||
                this._data.length !== oldData.length) {
                // need to update baseDataProvider since root data changes
                this._baseDataProvider = new ArrayDataProvider(this._data, this._baseDPOptions);
                this._dataRefreshed(null, null);
            }
            else {
                const changes = this.findDiffNodes(this._data, oldData, [], '', {}, {});
                const updates = changes.add;
                const { refresh } = changes;
                // need to update baseDataProvider since root data may changes, ex: immutable.js
                this._baseDataProvider = new ArrayDataProvider(this._data, this._baseDPOptions);
                if (updates.length > 0 || refresh.length > 0) {
                    const { mutationEvent, refreshEvent } = this._dataMutated(updates, changes.refresh);
                    this._dataRefreshed(mutationEvent, refreshEvent);
                }
            }
        }
        get data() {
            return this._data;
        }
        constructor(data, keyAttribute, options, _rootDataProvider) {
            var _a;
            this.keyAttribute = keyAttribute;
            this.options = options;
            this._rootDataProvider = _rootDataProvider;
            this.TreeAsyncIterator = class {
                constructor(_parent, _baseIterable) {
                    this._parent = _parent;
                    this._baseIterable = _baseIterable;
                }
                ['next']() {
                    return this._baseIterable[Symbol.asyncIterator]()
                        .next()
                        .then((result) => {
                        const metadata = result.value.metadata;
                        for (let i = 0; i < metadata.length; i++) {
                            metadata[i] = this._parent._getTreeMetadata(metadata[i], result.value.data[i]);
                        }
                        return result;
                    });
                }
            };
            this.TreeAsyncIterable = (_a = class {
                    constructor(_parent, _asyncIterator) {
                        this._parent = _parent;
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = () => {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this._mapKeyToNode = new Map();
            this._mapNodeToKey = new Map();
            this._mapKeyToParentNodePath = new Map();
            this._baseDPOptions = { keyAttributes: keyAttribute };
            if (options) {
                if (options.textFilterAttributes) {
                    this._baseDPOptions.textFilterAttributes = options.textFilterAttributes;
                }
                if (options.sortComparators) {
                    this._baseDPOptions.sortComparators = options.sortComparators;
                }
                if (options.implicitSort) {
                    this._baseDPOptions.implicitSort = options.implicitSort;
                }
                if (options.keyAttributeScope) {
                    this._baseDPOptions.keyAttributesScope = options.keyAttributeScope;
                }
                if (options.childrenAttribute) {
                    this._baseDPOptions.childrenAttribute = options.childrenAttribute;
                }
            }
            this._baseDataProvider = new ArrayDataProvider(data, this._baseDPOptions);
            this._childrenAttr =
                this.options && this.options['childrenAttribute']
                    ? this.options['childrenAttribute']
                    : 'children';
            if (_rootDataProvider == null) {
                this._parentNodePath = [];
                this._processTreeArray(data, []);
            }
            this.data = data;
        }
        getChildDataProvider(parentKey, options) {
            const node = this._getNodeForKey(parentKey);
            if (node) {
                const children = this._getChildren(node);
                if (children) {
                    const childDataProvider = new MutableArrayTreeDataProvider(children, this.keyAttribute, this.options, this._getRootDataProvider());
                    Object.defineProperty(childDataProvider, 'data', {
                        writable: false
                    });
                    if (childDataProvider != null) {
                        const enforceKeyStringify = this.options?.enforceKeyStringify;
                        const rootDataProvider = this._getRootDataProvider();
                        const parentKeyString = enforceKeyStringify === 'on' ? parentKey : JSON.stringify(parentKey);
                        childDataProvider._parentNodePath =
                            rootDataProvider._mapKeyToParentNodePath.get(parentKeyString);
                    }
                    return childDataProvider;
                }
            }
            return null;
        }
        fetchFirst(params) {
            params = this._applyLeafNodeFilter(params);
            const baseIterable = this._baseDataProvider.fetchFirst(params);
            return new this.TreeAsyncIterable(this, new this.TreeAsyncIterator(this, baseIterable));
        }
        fetchByOffset(params) {
            params = this._applyLeafNodeFilter(params);
            const basePromise = this._baseDataProvider.fetchByOffset(params);
            return basePromise.then((result) => {
                // Repackage the results with tree node metadata
                const results = result.results;
                const newResults = [];
                for (const result of results) {
                    let metadata = result['metadata'];
                    const data = result['data'];
                    metadata = this._getTreeMetadata(metadata, data);
                    newResults.push({ data, metadata });
                }
                const data = {
                    done: result['done'],
                    fetchParameters: result['fetchParameters'],
                    results: newResults
                };
                if (params.includeFilteredRowCount === 'enabled') {
                    data['totalFilteredRowCount'] = result.totalFilteredRowCount;
                }
                return data;
            });
        }
        fetchByKeys(params) {
            const results = new Map();
            params['keys'].forEach((key) => {
                const node = this._getNodeForKey(key);
                if (node) {
                    results.set(key, { metadata: { key }, data: node });
                }
            });
            return Promise.resolve({ fetchParameters: params, results });
        }
        containsKeys(params) {
            return this.fetchByKeys(params).then((fetchByKeysResult) => {
                const results = new Set();
                params['keys'].forEach((key) => {
                    if (fetchByKeysResult['results'].get(key) != null) {
                        results.add(key);
                    }
                });
                return Promise.resolve({ containsParameters: params, results });
            });
        }
        getCapability(capabilityName) {
            if (capabilityName === 'key') {
                const isStringifiedOn = this.options?.enforceKeyStringify === 'on';
                const isKeyPathingOn = this.options?.useKeyPaths === 'on' || (isStringifiedOn && !this.options?.useKeyPaths);
                if (isKeyPathingOn) {
                    if (isStringifiedOn) {
                        return { structure: 'pathArrayString' };
                    }
                    return { structure: 'pathArray' };
                }
                return { structure: 'none' };
            }
            return this._baseDataProvider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this._baseDataProvider.getTotalSize();
        }
        isEmpty() {
            return this._baseDataProvider.isEmpty();
        }
        /**
         * Return an empty Set which is optimized to store keys
         */
        createOptimizedKeySet(initialSet) {
            return this._baseDataProvider.createOptimizedKeySet(initialSet);
        }
        /**
         * Returns an empty Map which will efficiently store Keys returned by the DataProvider
         */
        createOptimizedKeyMap(initialMap) {
            return this._baseDataProvider.createOptimizedKeyMap(initialMap);
        }
        _processTreeArray(treeData, parentKeyPath) {
            let dataArray;
            let changesIdx, changes;
            if (treeData instanceof Array) {
                dataArray = treeData;
            }
            dataArray.forEach((node, i) => {
                this._processNode(node, parentKeyPath, treeData);
            });
        }
        _getRootDataProvider() {
            if (this._rootDataProvider) {
                return this._rootDataProvider;
            }
            else {
                return this;
            }
        }
        _processNode(node, parentKeyPath, treeData) {
            const keyObj = this._createKeyObj(node, parentKeyPath, treeData);
            this._setMapEntry(keyObj.key, node);
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            const rootDataProvider = this._getRootDataProvider();
            const keyString = enforceKeyStringify === 'on' ? keyObj.key : JSON.stringify(keyObj.key);
            rootDataProvider._mapKeyToParentNodePath.set(keyString, keyObj.keyPath);
            if (node) {
                const children = this._getChildren(node);
                if (children) {
                    this._processTreeArray(children, keyObj.keyPath);
                }
            }
            return keyObj;
        }
        _setMapEntry(key, node) {
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            const rootDataProvider = this._getRootDataProvider();
            const keyCopy = enforceKeyStringify === 'on' ? key : JSON.stringify(key);
            if (rootDataProvider._mapKeyToNode.has(keyCopy)) {
                Logger.warn(`Duplicate key ${keyCopy} found in MutableArrayTreeDataProvider.  Keys must be unique when keyAttributes ${this.keyAttribute} is specified`);
            }
            rootDataProvider._mapKeyToNode.set(keyCopy, node);
            rootDataProvider._mapNodeToKey.set(node, key);
        }
        _createKeyObj(node, parentKeyPath, treeData) {
            let key = this._getId(node);
            const keyPath = parentKeyPath ? parentKeyPath.slice() : [];
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            if (enforceKeyStringify === 'on') {
                keyPath.push(JSON.parse(key));
            }
            else {
                keyPath.push(key);
            }
            if (this.options &&
                (this.options['keyAttributeScope'] === 'siblings' ||
                    (enforceKeyStringify === 'on' && !this.options.useKeyPaths) ||
                    this.options.useKeyPaths === 'on')) {
                // If the id is only unique among siblings, we use the id path of the
                // node as the key.
                key = enforceKeyStringify === 'on' ? JSON.stringify(keyPath) : keyPath;
            }
            return { key, keyPath };
        }
        _getChildren(node) {
            // Pass true to _getVal so that we keep children in the same form
            return this._getVal(node, this._childrenAttr, true);
        }
        /**
         * Get value for attribute
         */
        _getVal(val, attr, keepFunc) {
            if (typeof attr === 'string') {
                const dotIndex = attr.indexOf('.');
                if (dotIndex > 0) {
                    const startAttr = attr.substring(0, dotIndex);
                    const endAttr = attr.substring(dotIndex + 1);
                    const subObj = val[startAttr];
                    if (subObj) {
                        return this._getVal(subObj, endAttr);
                    }
                }
            }
            // If keepFunc is true, don't resolve any function value.
            // e.g. Caller may want to preserve any observableArray for other operations.
            if (keepFunc !== true && typeof val[attr] === 'function') {
                return val[attr]();
            }
            return val[attr];
        }
        /**
         * Get id value for row
         */
        _getId(row) {
            let id;
            const keyAttributes = this.keyAttribute;
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            if (keyAttributes == '@value') {
                id = this._getAllVals(row);
            }
            else {
                id = this._getVal(row, keyAttributes);
            }
            if (enforceKeyStringify === 'on') {
                return JSON.stringify(id);
            }
            return id;
        }
        /**
         * Get all values in a row
         */
        _getAllVals(val) {
            if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
                return val;
            }
            return Object.keys(val).map((key) => {
                return this._getVal(val, key);
            });
        }
        _getNodeMetadata(node) {
            return { key: this._getKeyForNode(node) };
        }
        _getNodeForKey(key) {
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            const keyString = enforceKeyStringify === 'on' ? key : JSON.stringify(key);
            const rootDataProvider = this._getRootDataProvider();
            let nodeDataJS = rootDataProvider._mapKeyToNode.get(keyString);
            return nodeDataJS;
        }
        _getKeyForNode(node) {
            const rootDataProvider = this._getRootDataProvider();
            return rootDataProvider._mapNodeToKey.get(node);
        }
        _applyLeafNodeFilter(params) {
            if (params && params.filterCriterion) {
                const paramsClone = { ...params };
                paramsClone.filterCriterion = this._getLeafNodeFilter(paramsClone.filterCriterion);
                paramsClone.filterCriterion.filter = params.filterCriterion.filter;
                params = paramsClone;
            }
            return params;
        }
        _getLeafNodeFilter(filter) {
            const attributeFilter = filter;
            const childrenNull = { op: '$ne', attribute: this._childrenAttr, value: null };
            const childrenUndefined = { op: '$ne', attribute: this._childrenAttr, value: undefined };
            const excludeParentNodeFilter = { op: '$and', criteria: [childrenNull, childrenUndefined] };
            return { op: '$or', criteria: [attributeFilter, excludeParentNodeFilter] };
        }
        findDiffNodes(newArray, oldArray, parentKeyPath, parentKey, rootNode, oldRootNode) {
            const changes = { add: [], refresh: [] };
            if (!newArray && !oldArray) {
                return changes;
            }
            const newPath = parentKeyPath.slice();
            newPath.pop();
            if ((!newArray && oldArray) || (newArray && !oldArray)) {
                // non-leaf node to leaf node or leaf node to non-leaf node
                // need to refresh on node's parent node
                changes.refresh.push({
                    parentKey: newPath[newPath.length - 1],
                    rootNode,
                    oldRootNode
                });
                return changes;
            }
            if (newArray.length !== oldArray.length) {
                changes.refresh.push({
                    parentKey,
                    rootNode,
                    oldRootNode
                });
                return changes;
            }
            else {
                let diffCount = 0;
                let diffNodeIndex = 0;
                for (let index = 0; index < newArray.length; index++) {
                    const newNode = newArray[index];
                    const oldNode = oldArray[index];
                    if (newNode !== oldNode) {
                        diffCount++;
                        diffNodeIndex = index;
                    }
                }
                if (diffCount === 0) {
                    return changes;
                }
                else if (diffCount > 1) {
                    // need to refresh parent node's data
                    changes.refresh.push({
                        parentKey: newPath[newPath.length - 1],
                        rootNode,
                        oldRootNode
                    });
                    return changes;
                }
                else {
                    // compare old node and new old
                    const newDiffNode = newArray[diffNodeIndex];
                    const oldDiffNode = oldArray[diffNodeIndex];
                    if (parentKey === '') {
                        // set root node
                        rootNode = newDiffNode;
                        oldRootNode = oldDiffNode;
                    }
                    const { refresh, add } = this.compareNode(newDiffNode, oldDiffNode, diffNodeIndex, parentKeyPath, newArray, rootNode, oldRootNode);
                    changes.refresh = [...changes.refresh, ...refresh];
                    changes.add = [...changes.add, ...add];
                    return changes;
                }
            }
        }
        compareNode(newNode, oldNode, diffNodeIndex, parentKeyPath, parentChildList, rootNode, oldRootNode) {
            // for update event, need parentKeyPath, parent's children list
            const changes = { add: [], refresh: [] };
            const newKeys = Object.keys(newNode);
            if (newNode === oldNode) {
                return changes;
            }
            if (newNode === null ||
                oldNode === null ||
                ['number', 'string', 'undefined'].indexOf(typeof newNode) >= 0 ||
                ['number', 'string', 'undefined'].indexOf(typeof oldNode) >= 0) {
                // a string/number/undefined/null node
                // update node, not immutable, no need to go deep
                changes.add.push({
                    index: diffNodeIndex,
                    value: newNode,
                    treeData: parentChildList,
                    parentKeyPath: parentKeyPath,
                    oldValue: oldNode
                });
                return changes;
            }
            for (let index = 0; index < newKeys.length; index++) {
                const key = newKeys[index];
                if (key !== this._childrenAttr && newNode[key] !== oldNode[key]) {
                    changes.add.push({
                        index: diffNodeIndex,
                        value: newNode,
                        treeData: parentChildList,
                        parentKeyPath: parentKeyPath,
                        oldValue: oldNode
                    });
                    break;
                }
            }
            const newPath = parentKeyPath.slice();
            const newParentKey = newNode['id'];
            newPath.push(newParentKey);
            const { refresh, add } = this.findDiffNodes(newNode[this._childrenAttr], oldNode[this._childrenAttr], newPath, newParentKey, rootNode, oldRootNode);
            changes.refresh = [...changes.refresh, ...refresh];
            changes.add = [...changes.add, ...add];
            return changes;
        }
        _dataMutated(changes, refresh) {
            // for each node in changes, need to find the parent key
            let i, dataArray = [], keyArray = [], indexArray = [], metadataArray = [];
            let mutationEvent = null;
            let refreshEvent = null;
            const updatedIndexes = [];
            let operationUpdateEventDetail = null;
            let operationAddEventDetail = null;
            let operationRemoveEventDetail = null;
            const refreshKeySet = new Set();
            const dataJS = this._data;
            for (let index = 0; index < refresh.length; index++) {
                if (refresh[index]) {
                    // empty key for root level list
                    // update node
                    if (!refresh[index].parentKey) {
                        // top-level node changes
                        this._getRootDataProvider()._flushMaps();
                        this._getRootDataProvider()._processTreeArray(dataJS, []);
                        refreshEvent = new oj.DataProviderRefreshEvent();
                        return { mutationEvent, refreshEvent };
                    }
                    refreshKeySet.add(refresh[index].parentKey);
                    this._getRootDataProvider()._flushMaps();
                    this._getRootDataProvider()._processTreeArray(this._data, []);
                }
            }
            dataArray = [];
            keyArray = [];
            indexArray = [];
            metadataArray = [];
            const updateKeyArray = [];
            const updateDataArray = [];
            const updateIndexArray = [];
            const updateMetadataArray = [];
            for (i = 0; i < changes.length; i++) {
                if (changes[i]) {
                    const node = changes[i].value;
                    const oldNode = changes[i].oldValue;
                    this._getRootDataProvider()._flushMaps();
                    this._getRootDataProvider()._processTreeArray(dataJS, []);
                    let currTreeData = changes[i].treeData;
                    let path = changes[i].parentKeyPath;
                    const keyObj = this._createKeyObj(node, path, currTreeData);
                    updateKeyArray.push(keyObj.key);
                    updateDataArray.push(node);
                    updateIndexArray.push(changes[i].index);
                    updateMetadataArray.push({ key: keyObj.key });
                }
            }
            // Prepare the "update" event detail
            if (changes.length > 0) {
                const updateKeySet = new Set();
                updateKeyArray.forEach((key) => {
                    updateKeySet.add(key);
                });
                operationUpdateEventDetail = {
                    data: updateDataArray,
                    indexes: updateIndexArray,
                    keys: updateKeySet,
                    metadata: updateMetadataArray
                };
            }
            if (operationUpdateEventDetail) {
                mutationEvent = new oj.DataProviderMutationEvent({
                    add: operationAddEventDetail,
                    remove: operationRemoveEventDetail,
                    update: operationUpdateEventDetail
                });
            }
            // Prepare refresh subtree
            if (refreshKeySet.size || refresh.length) {
                refreshEvent = new oj.DataProviderRefreshEvent({ keys: refreshKeySet });
            }
            return { mutationEvent, refreshEvent };
        }
        _dataRefreshed(mutationEvent, refreshEvent) {
            if (mutationEvent || refreshEvent) {
                if (mutationEvent) {
                    this._getRootDataProvider().dispatchEvent(mutationEvent);
                }
                if (refreshEvent) {
                    this._getRootDataProvider().dispatchEvent(refreshEvent);
                }
            }
            else {
                this._getRootDataProvider()._flushMaps();
                this._getRootDataProvider()._processTreeArray(this._data, []);
                this._getRootDataProvider().dispatchEvent(new oj.DataProviderRefreshEvent());
            }
        }
        // Get tree array metadata from flat array metadata/data
        _getTreeMetadata(metadata, data) {
            let keyIsPath = false;
            let treeKey = metadata.key;
            if (this.options &&
                (this.options.keyAttributeScope == 'siblings' ||
                    (this.options.enforceKeyStringify === 'on' && !this.options.useKeyPaths) ||
                    this.options.useKeyPaths === 'on')) {
                keyIsPath = true;
            }
            if (keyIsPath) {
                treeKey = this._parentNodePath ? this._parentNodePath.slice() : [];
                treeKey.push(metadata.key);
            }
            if (this.options?.enforceKeyStringify === 'on') {
                treeKey = JSON.stringify(treeKey);
            }
            metadata = this._getNodeMetadata(this._getNodeForKey(treeKey));
            return metadata;
        }
        _releaseTreeArray(treeData) {
            let dataArray;
            if (treeData instanceof Array) {
                dataArray = treeData;
            }
            else {
                dataArray = treeData();
            }
            dataArray.forEach((node, i) => {
                this._releaseNode(node);
            });
        }
        _releaseNode(node) {
            const key = this._getKeyForNode(node);
            this._deleteMapEntry(key, node);
            if (node) {
                const children = this._getChildren(node);
                if (children) {
                    this._releaseTreeArray(children);
                }
            }
        }
        _deleteMapEntry(key, node) {
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            const rootDataProvider = this._getRootDataProvider();
            const keyString = enforceKeyStringify === 'on' ? key : JSON.stringify(key);
            rootDataProvider._mapKeyToNode.delete(keyString);
            rootDataProvider._mapNodeToKey.delete(node);
        }
        _flushMaps() {
            const rootDataProvider = this._getRootDataProvider();
            rootDataProvider._mapKeyToNode.clear();
            rootDataProvider._mapNodeToKey.clear();
        }
    }
    ojeventtarget.EventTargetMixin.applyMixin(MutableArrayTreeDataProvider);
    oj._registerLegacyNamespaceProp('MutableArrayTreeDataProvider', MutableArrayTreeDataProvider);

    exports.MutableArrayTreeDataProvider = MutableArrayTreeDataProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbufferingdataproviderevents',['exports', 'ojs/ojeventtarget'], function (exports, ojeventtarget) { 'use strict';

    class BufferingDataProviderSubmittableChangeEvent extends ojeventtarget.GenericEvent {
        constructor(detail) {
            const eventOptions = {};
            eventOptions['detail'] = detail;
            super('submittableChange', eventOptions);
        }
    }

    exports.BufferingDataProviderSubmittableChangeEvent = BufferingDataProviderSubmittableChangeEvent;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbufferingutils',['exports', 'ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojmap'], function (exports, oj, ojdataprovider, ojMap) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    ojMap = ojMap && Object.prototype.hasOwnProperty.call(ojMap, 'default') ? ojMap['default'] : ojMap;

    class BufferingDataProviderUtils {
        static fetchByKeysFromBuffer(params, editBuffer) {
            const results = new ojMap();
            const unresolvedKeys = new Set();
            params.keys.forEach((key) => {
                const editItem = editBuffer.getItem(key);
                if (editItem) {
                    switch (editItem.operation) {
                        case 'add':
                        case 'update':
                            // Return the buffered item if it is being added or updated
                            results.set(key, editItem.item);
                            break;
                        case 'remove':
                            // Skip the key if it is being removed
                            break;
                    }
                }
                else {
                    // need to fetch from underlying DataProvider if it's not in the buffer
                    unresolvedKeys.add(key);
                }
            });
            return { results, unresolvedKeys };
        }
        static compareItem(d1, d2, sortCriteria) {
            for (const sortCrt of sortCriteria) {
                let comparator = ojdataprovider.SortUtils.getNaturalSortComparator();
                const descendingResult = sortCrt.direction === 'descending' ? -1 : 1;
                const comparatorResult = comparator(this.getVal(d1, sortCrt.attribute), this.getVal(d2, sortCrt.attribute)) *
                    descendingResult;
                if (comparatorResult !== 0) {
                    return comparatorResult;
                }
                // If d1 and d2 is the same on the current sortCriterion, move on to the next sortCriterion
            }
            return 0;
        }
        static getVal(val, attr) {
            if (val === null || typeof val === 'undefined') {
                return val;
            }
            if (typeof attr === 'string') {
                const dotIndex = attr.indexOf('.');
                if (dotIndex > 0) {
                    const startAttr = attr.substring(0, dotIndex);
                    const endAttr = attr.substring(dotIndex + 1);
                    const subObj = val[startAttr];
                    if (subObj) {
                        return this.getVal(subObj, endAttr);
                    }
                }
            }
            if (typeof val[attr] === 'function') {
                return val[attr]();
            }
            return val[attr];
        }
        static insertAddEdits(editItems, filterObj, sortCriteria, itemArray, mergedAddKeySet, lastBlock, editBuffer, parent) {
            editItems.forEach(async (editItem, key) => {
                if (editItem.operation === 'add') {
                    if (!filterObj || filterObj.filter(editItem.item.data)) {
                        // no filter or meets the filter
                        parent.totalFilteredRowCount++;
                    }
                }
                else {
                    // update and remove case
                    // need to check old data if we have filterObj and then calculate new totalFilteredRowCount
                    let oldData = null;
                    if (filterObj) {
                        if (parent.dataBeforeUpdated.has(key)) {
                            oldData = parent.dataBeforeUpdated.get(key);
                        }
                        else {
                            let keySet = new Set();
                            keySet.add(key);
                            let value = await parent.dataProvider.fetchByKeys({ keys: keySet });
                            oldData = value.results.get(key).data;
                            parent.dataBeforeUpdated.set(key, oldData);
                        }
                    }
                    if (editItem.operation === 'remove') {
                        if (!filterObj || filterObj.filter(oldData)) {
                            // don't have filter or
                            // old data meets the filter
                            parent.totalFilteredRowCount--;
                        }
                    }
                    else if (editItem.operation === 'update' && filterObj) {
                        if (filterObj.filter(oldData) && !filterObj.filter(editItem.item.data)) {
                            // old data meets filter, new data doesn't meet filter
                            parent.totalFilteredRowCount--;
                        }
                        else if (!filterObj.filter(oldData) && filterObj.filter(editItem.item.data)) {
                            // old data doesn't meets filter, new data meets filter
                            parent.totalFilteredRowCount++;
                        }
                    }
                }
                // Check if it's an "add" item and not previously merged before merging it
                if ((editItem.operation === 'add' || editItem.operation === 'update') &&
                    !mergedAddKeySet.has(key)) {
                    // First check to see if this item satisfies any filter
                    if (!filterObj || filterObj.filter(editItem.item.data)) {
                        if (sortCriteria && sortCriteria.length) {
                            let inserted = false;
                            for (let i = 0; i < itemArray.length; i++) {
                                if (editItem.operation === 'update' &&
                                    !editBuffer.isUpdateTransformed(key) &&
                                    key === itemArray[i].metadata.key) {
                                    itemArray.splice(i, 1); // remove the old updated item and will be added if within fetch range later
                                }
                                if (this.compareItem(editItem.item.data, itemArray[i].data, sortCriteria) < 0) {
                                    itemArray.splice(i, 0, editItem.item);
                                    mergedAddKeySet.add(key);
                                    inserted = true;
                                    break;
                                }
                            }
                            if (!inserted && lastBlock) {
                                itemArray.push(editItem.item);
                                mergedAddKeySet.add(key);
                            }
                        }
                        else if (editItem.operation === 'add' ||
                            (editItem.operation === 'update' && editBuffer.isUpdateTransformed(key))) {
                            const insertIndex = editItem.addDetail === undefined
                                ? 0
                                : this.findKeyInItems(editItem.addDetail.addBeforeKey, itemArray);
                            if (insertIndex > -1) {
                                itemArray.splice(insertIndex, 0, editItem.item);
                                mergedAddKeySet.add(key);
                            }
                            else if (lastBlock) {
                                itemArray.push(editItem.item);
                                mergedAddKeySet.add(key);
                            }
                        }
                    }
                }
            });
        }
        static mergeAddEdits(filterObj, sortCriteria, newItemArray, mergedAddKeySet, lastBlock, editBuffer, parent) {
            const editBufferUnsubmittedItems = editBuffer.getUnsubmittedItems();
            this.insertAddEdits(editBufferUnsubmittedItems, filterObj, sortCriteria, newItemArray, mergedAddKeySet, lastBlock, editBuffer, parent);
            const editBufferSubmittingItems = editBuffer.getSubmittingItems();
            this.insertAddEdits(editBufferSubmittingItems, filterObj, sortCriteria, newItemArray, mergedAddKeySet, lastBlock, editBuffer, parent);
        }
        // Merge "add" and "update" edit items with baseItemArray and add to newItemArray
        static mergeEdits(baseItemArray, newItemArray, filterCriterion, sortCriteria, mergedAddKeySet, lastBlock, editBuffer, parent) {
            let filterObj;
            // Get a filter if there is a filterCriterion
            if (filterCriterion) {
                if (!filterCriterion.filter) {
                    filterObj = ojdataprovider.FilterFactory.getFilter({
                        filterDef: filterCriterion,
                        filterOptions: parent.options
                    });
                }
                else {
                    filterObj = filterCriterion;
                }
            }
            // include submitted items for iterators that were active when the submit happened
            const includeSubmitted = newItemArray.length !== 0;
            // Merge the removes and updates
            for (const baseItem of baseItemArray) {
                const editItem = editBuffer.getItem(baseItem.metadata.key, includeSubmitted);
                if (!editItem) {
                    newItemArray.push(baseItem);
                }
                else {
                    if (editItem.operation === 'remove') {
                        // Include "remove" items in merged item array in case it's reset. We need to remove them from final result.
                        newItemArray.push(baseItem);
                    }
                    else if (editItem.operation === 'update' &&
                        !editBuffer.isUpdateTransformed(editItem.item.metadata.key)) {
                        if (!filterObj || filterObj.filter(editItem.item.data)) {
                            if (!sortCriteria || sortCriteria.length === 0) {
                                newItemArray.push(editItem.item);
                            }
                        }
                    }
                }
            }
            // If there is sortCriteria, merge the "add" items into the existing items
            this.mergeAddEdits(filterObj, sortCriteria, newItemArray, mergedAddKeySet, lastBlock, editBuffer, parent);
        }
        static async fetchFromOffset(params, dataProvider, editBuffer) {
            const signal = params?.signal;
            const callback = async (resolve) => {
                const offset = params.offset;
                const isFetchToEnd = params.size == null || params.size === -1;
                const size = params.size;
                const mergedItems = [];
                const { submitting, submitted, unsubmitted } = this.getEditBufferCounts(editBuffer);
                const numUnsubmittedAdds = unsubmitted.numAdds;
                const numAdds = numUnsubmittedAdds + submitting.numAdds + submitted.numAdds;
                const numAddsAtIndexZero = unsubmitted.numAddsAtTop + submitting.numAddsAtTop + submitted.numAddsAtTop;
                let done = false;
                let skipAddsAtIndexZero = true;
                let underlyingFetchParams;
                // some concern with the values changing during the fetch
                // for fetch all get all underlying results
                const submittingItems = editBuffer.getSubmittingItems();
                const unSubmittedItems = editBuffer.getUnsubmittedItems();
                const submittedItems = editBuffer.getSubmittedAddItems();
                if (submittingItems.size === 0 && unSubmittedItems.size === 0 && submittedItems.size === 0) {
                    underlyingFetchParams = { ...params };
                    const fetchByOffsetResults = await dataProvider.fetchByOffset(params);
                    return resolve(fetchByOffsetResults);
                }
                // add results from the editBuffer
                if (offset < numAddsAtIndexZero) {
                    mergedItems.push(...this.getAllAddsAtTop(editBuffer).slice(offset, isFetchToEnd ? undefined : offset + size));
                }
                if (!isFetchToEnd && offset + size <= numAddsAtIndexZero) {
                    return resolve({ fetchParameters: params, results: mergedItems, done: done });
                }
                // if all of the requested rows exist in the editBuffer, do not perform a fetch
                const numRemoves = unsubmitted.numRemoves + submitting.numRemoves;
                const numMoveAdds = unsubmitted.numMoveAdds + submitting.numMoveAdds;
                const numSubmittedOrSubmittingAdds = submitting.numAdds + submitted.numAdds;
                let overrideOffset = { offset: offset };
                let overrideSize = { size: size };
                let mergedItemsOffset = 0;
                // if neither of the following conditions are met then there are just true updates and the underlyingParams
                // match the original params
                if (numRemoves > 0 ||
                    numMoveAdds > 0 ||
                    numSubmittedOrSubmittingAdds > 0 ||
                    numAdds - numAddsAtIndexZero > 0) {
                    overrideOffset = {
                        // if there are removes or 'moveAdds' or adds with addBeforeKey then offset is set to zero since the BDP needs to know where
                        // those rows are in the underlying data provider for deciding where to start pulling from the
                        // result set.
                        offset: 0
                    };
                    if (numMoveAdds > 0) {
                        // if there are moveAdds then clear the rows which are added because we can't differentiate newly added row and data from base dp
                        mergedItems.length = 0;
                        mergedItemsOffset = offset;
                        skipAddsAtIndexZero = false;
                    }
                    else {
                        mergedItemsOffset = Math.max(0, offset - numAddsAtIndexZero);
                    }
                    if (!isFetchToEnd) {
                        overrideSize = {
                            // the underlying size needs to be incremented by:
                            // offset - to account for setting it to zero
                            // numRemoves - to account for the rows underlying may returns that we would skip
                            // numMoveAdds - to account for the rows underlying may return that are in the editBuffer adds
                            // numSubmittedOrSubmittingAdds - to account for the rows underlying may return that are in the editBuffer adds
                            // the underlying size needs to be decremented by:
                            // (unsubmittedAdds - offset) - the number of added rows at the top that are in requested range but not yet in the underlying data provider
                            size: offset +
                                size +
                                numRemoves +
                                numMoveAdds +
                                numSubmittedOrSubmittingAdds -
                                Math.max(unsubmitted.numAddsAtTop - offset, 0)
                        };
                    }
                    // when we drop the offset to 0 we don't necessarily want to start adding the rows from index 0 of the results
                    // we will start shift the window by the number of adds, this will increase for any rows deleted before the first
                    // used result
                }
                else if (unsubmitted.numAddsAtTop > 0) {
                    overrideOffset = {
                        // if the only adds are unsubmitted adds we can optimize the offset and size
                        // if there are adds we can need to decrement the offset by the number of adds to shift the fetch region
                        offset: Math.max(offset - unsubmitted.numAddsAtTop, 0)
                    };
                    if (!isFetchToEnd) {
                        overrideSize = {
                            // the underlying size needs to be decremented by:
                            // (unsubmittedAdds - offset) - the number of added rows in the requested range that are not yet in the underlying data provider
                            size: size - Math.max(unsubmitted.numAddsAtTop - offset, 0)
                        };
                    }
                }
                const fetchSize = Math.max(overrideSize.size, size);
                while (!done && (isFetchToEnd || mergedItems.length < fetchSize)) {
                    underlyingFetchParams = { ...params, ...overrideOffset, ...overrideSize };
                    let results = await dataProvider.fetchByOffset(underlyingFetchParams);
                    let resultsArray = results.results;
                    if (resultsArray.length === 0) {
                        done = true;
                        break;
                    }
                    done = results.done;
                    resultsArray.forEach((result) => {
                        if (!editBuffer.isSubmittingOrSubmittedAdd(result.metadata.key)) {
                            mergedItems.push(result);
                        }
                    });
                    overrideOffset.offset += resultsArray.length;
                    // debate if this can be overrideSize -= resultSize
                    overrideSize.size = isFetchToEnd ? size : size - mergedItems.length;
                }
                this.performEdits(mergedItems, editBuffer.getAllTransactions(), skipAddsAtIndexZero, done);
                return resolve({
                    fetchParameters: params,
                    results: mergedItems.slice(mergedItemsOffset, isFetchToEnd ? undefined : mergedItemsOffset + size),
                    done: done
                });
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, true);
        }
        static performEdits(itemsArray, editItems, skipAddsAtIndexZero, done) {
            editItems.forEach((editItem) => {
                if (editItem.operation === 'add') {
                    if (editItem.addDetail) {
                        if (editItem.addDetail.addBeforeKey !== null) {
                            const insertionIndex = this.findKeyInItems(editItem.addDetail.addBeforeKey, itemsArray);
                            if (insertionIndex > -1) {
                                itemsArray.splice(insertionIndex, 0, editItem.item);
                            }
                            else if (done) {
                                itemsArray.push(editItem.item);
                            }
                        }
                        else if (done) {
                            itemsArray.push(editItem.item);
                        }
                    }
                    else if (!skipAddsAtIndexZero) {
                        itemsArray.unshift(editItem.item);
                    }
                }
                else if (editItem.operation === 'remove') {
                    const removeIndex = this.findKeyInItems(editItem.item.metadata.key, itemsArray);
                    if (removeIndex > -1) {
                        itemsArray.splice(removeIndex, 1);
                    }
                }
                else if (editItem.operation === 'update') {
                    const updateIndex = this.findKeyInItems(editItem.item.metadata.key, itemsArray);
                    if (updateIndex > -1) {
                        itemsArray.splice(updateIndex, 1, editItem.item);
                    }
                }
            });
        }
        static calculateSizeChange(editItems, editBuffer) {
            let sizeChange = 0;
            // Add the size of "add" items and subtract the size of "remove" items
            editItems.forEach((value, key) => {
                if (!editBuffer.getEditItemStatus(key)) {
                    if (value.operation === 'add') {
                        ++sizeChange;
                    }
                    else if (value.operation === 'remove') {
                        --sizeChange;
                    }
                }
            });
            return sizeChange;
        }
        static getEditBufferCounts(editBuffer) {
            const submitting = this.getCounts(editBuffer.getSubmittingItems(), editBuffer);
            const unsubmitted = this.getCounts(editBuffer.getUnsubmittedItems(), editBuffer);
            const submitted = this.getCounts(editBuffer.getSubmittedAddItems(), editBuffer);
            return { submitting, unsubmitted, submitted };
        }
        static getCounts(editItems, editBuffer) {
            let numAdds = 0;
            let numRemoves = 0;
            let numMoveAdds = 0;
            let numAddsAtTop = 0;
            editItems.forEach((value, key) => {
                if (value.operation === 'add') {
                    ++numAdds;
                    if (!value.addDetail) {
                        ++numAddsAtTop;
                    }
                }
                else if (value.operation === 'remove') {
                    ++numRemoves;
                }
                else if (value.operation === 'update' && editBuffer.isUpdateTransformed(key)) {
                    ++numMoveAdds;
                }
            });
            return { numAdds, numAddsAtTop, numRemoves, numMoveAdds };
        }
        static getAllAddsAtTop(editBuffer) {
            const addOrder = editBuffer.getAddItemOrder();
            const items = new Array();
            addOrder.forEach((key) => {
                // adds always have data...
                const editItem = editBuffer.getItem(key, true);
                if (editItem && !editItem.addDetail) {
                    items.push(editItem.item);
                }
            });
            return items;
        }
        // Return true if there is a "remove" edit item for key
        static isItemRemoved(key, editBuffer) {
            const editItem = editBuffer.getItem(key);
            return editItem != null && editItem.operation === 'remove';
        }
        static addToMergedArrays(item, fromBaseDP, lastIterator, editBuffer, addBeforeKey = null, insertAtTop = false) {
            let finalAddBeforeKey = addBeforeKey;
            let index = null;
            if (fromBaseDP) {
                // if item of addBeforeKey is removed by removeItem, find the next key of that item recursively
                finalAddBeforeKey = this.getNextKey(addBeforeKey, lastIterator, editBuffer, false);
            }
            else if (lastIterator) {
                if (insertAtTop) {
                    index = 0;
                    for (let i = 0; i < lastIterator.mergedItemArray.length; i++) {
                        const key = lastIterator.mergedItemArray[i].metadata.key;
                        if (!this.isItemRemoved(key, editBuffer)) {
                            finalAddBeforeKey = key;
                            break;
                        }
                    }
                }
                else {
                    if (addBeforeKey !== null) {
                        index = this.findKeyInItems(addBeforeKey, lastIterator.mergedItemArray);
                        if (index === -1) {
                            index = null;
                        }
                    }
                }
                let shouldIncrementNextOffset = index !== null && lastIterator.nextOffset > index;
                if (editBuffer.isUpdateTransformed(item.metadata.key)) {
                    let removeIdx = this.findKeyInItems(item.metadata.key, lastIterator.mergedItemArray);
                    if (removeIdx !== -1) {
                        if (shouldIncrementNextOffset) {
                            shouldIncrementNextOffset = lastIterator.nextOffset <= removeIdx;
                        }
                        lastIterator.mergedItemArray.splice(removeIdx, 1);
                    }
                }
                if (index !== null) {
                    lastIterator.mergedItemArray.splice(index, 0, item);
                    lastIterator.mergedAddKeySet.add(item.metadata.key);
                }
                if (shouldIncrementNextOffset) {
                    lastIterator.nextOffset++;
                }
            }
            else if (insertAtTop) {
                index = 0;
            }
            return {
                addBeforeKey: finalAddBeforeKey,
                index
            };
        }
        static getNextKey(key, lastIterator, editBuffer, bRemoved = false) {
            // bRemoved=true indicates the key will be removed
            let nextKey = key;
            if (lastIterator) {
                const mergedItemArray = lastIterator.mergedItemArray;
                let keyIdx = this.findKeyInItems(key, mergedItemArray);
                while (nextKey !== null && (bRemoved || this.isItemRemoved(nextKey, editBuffer))) {
                    if (bRemoved) {
                        bRemoved = false;
                    }
                    nextKey =
                        keyIdx === -1
                            ? null
                            : keyIdx + 1 === mergedItemArray.length
                                ? null
                                : mergedItemArray[keyIdx + 1].metadata.key;
                    keyIdx++;
                }
            }
            return nextKey;
        }
        static generateKey(value, customKeyGenerator) {
            if (customKeyGenerator) {
                return customKeyGenerator(value);
            }
            else {
                // check if the browser supports UUID
                if (crypto.randomUUID) {
                    return crypto.randomUUID();
                }
                else {
                    // fallback mainly for Safari 15.x
                    // @ts-ignore
                    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
                }
            }
        }
        static removeFromMergedArrays(key, fromBaseDP, lastIterator, editBuffer) {
            if (lastIterator) {
                // Remove item from the merged arrays
                const mergedItemArray = lastIterator.mergedItemArray;
                const mergedAddKeySet = lastIterator.mergedAddKeySet;
                const keyIdx = this.findKeyInItems(key, mergedItemArray);
                if (keyIdx !== -1) {
                    if (fromBaseDP || mergedAddKeySet.has(key)) {
                        // If the item is removed from base DP or newly added through addItem, permanently remove it from the buffer
                        mergedItemArray.splice(keyIdx, 1);
                        mergedAddKeySet.delete(key);
                    }
                    // we need the next offset to be the last non-removed item, before the nextOffset always
                    for (let i = lastIterator.nextOffset - 1; i >= 0; i--) {
                        let itemKey = mergedItemArray[i]?.metadata.key;
                        if (itemKey != null && !this.isItemRemoved(itemKey, editBuffer)) {
                            break;
                        }
                        lastIterator.nextOffset = i;
                    }
                }
            }
        }
        static addEventDetail(detail, detailType, detailItem, detailAddBeforeKey) {
            if (detail[detailType] == null) {
                if (detailType === 'add') {
                    detail[detailType] = { data: [], keys: new Set(), metadata: [], addBeforeKeys: [] };
                }
                else {
                    detail[detailType] = { data: [], keys: new Set(), metadata: [] };
                }
            }
            detail[detailType].keys.add(detailItem.metadata.key);
            detail[detailType].data.push(detailItem.data);
            detail[detailType].metadata.push(detailItem.metadata);
            if (detailType === 'add') {
                detail[detailType].addBeforeKeys.push(detailAddBeforeKey);
            }
        }
        // Return the index of key in a metadata array
        static findKeyInMetadata(key, metadata) {
            if (metadata) {
                for (let i = 0; i < metadata.length; i++) {
                    if (oj.KeyUtils.equals(key, metadata[i].key)) {
                        return i;
                    }
                }
            }
            return -1;
        }
        // Return the index of key in an item array
        static findKeyInItems(key, items) {
            if (items) {
                for (let i = 0; i < items.length; i++) {
                    if (oj.KeyUtils.equals(key, items[i].metadata.key)) {
                        return i;
                    }
                }
            }
            return -1;
        }
        static initDetailProp(detail, newDetail, propName, initValue) {
            if (detail[propName]) {
                newDetail[propName] = initValue;
            }
        }
        static initDetail(detail, newDetail, bEmpty, bAdd = false) {
            if (bEmpty) {
                this.initDetailProp(detail, newDetail, 'data', []);
                this.initDetailProp(detail, newDetail, 'metadata', []);
                if (bAdd) {
                    this.initDetailProp(detail, newDetail, 'addBeforeKeys', []);
                }
                this.initDetailProp(detail, newDetail, 'indexes', []);
                this.initDetailProp(detail, newDetail, 'parentKeys', []);
            }
            else {
                this.initDetailProp(detail, newDetail, 'data', detail.data);
                this.initDetailProp(detail, newDetail, 'metadata', detail.metadata);
                if (bAdd) {
                    this.initDetailProp(detail, newDetail, 'addBeforeKeys', detail.addBeforeKeys);
                }
                this.initDetailProp(detail, newDetail, 'indexes', detail.indexes);
                this.initDetailProp(detail, newDetail, 'parentKeys', detail.parentKeys);
            }
        }
        static initDetails(details, newDetails, bEmpty) {
            if (details.add) {
                newDetails.add = { keys: new Set() };
                this.initDetail(details.add, newDetails.add, bEmpty, true);
            }
            if (details.remove) {
                newDetails.remove = { keys: new Set() };
                this.initDetail(details.remove, newDetails.remove, bEmpty);
            }
            if (details.update) {
                newDetails.update = { keys: new Set() };
                this.initDetail(details.update, newDetails.update, bEmpty);
            }
        }
        static pushDetailProp(detail, newDetail, propName, idx) {
            if (detail[propName]) {
                newDetail[propName].push(detail[propName][idx]);
            }
        }
        static pushDetail(key, detail, newDetail) {
            // Add the item as it
            newDetail.keys.add(key);
            if (detail.metadata) {
                const idx = this.findKeyInMetadata(key, detail.metadata);
                if (idx > -1) {
                    this.pushDetailProp(detail, newDetail, 'data', idx);
                    this.pushDetailProp(detail, newDetail, 'metadata', idx);
                    if (detail.addBeforeKeys && detail.addBeforeKeys.length !== 0) {
                        this.pushDetailProp(detail, newDetail, 'addBeforeKeys', idx);
                    }
                    if (detail.indexes && detail.indexes.length !== 0) {
                        this.pushDetailProp(detail, newDetail, 'indexes', idx);
                    }
                    this.pushDetailProp(detail, newDetail, 'parentKeys', idx);
                }
            }
        }
        static isSkipItem(key, submittingItems, unsubmittedItems) {
            // Skip the mutation if:
            // 1. The key is in the submitting buffer, because the mutation should be coming from
            //    the data source when the item is committed.  We would have already fired the mutate
            //    event when the item was first added to the buffer.
            // 2. The key is in the unsubmitted buffer as removed item. Skip any mutation because
            //    the item does not exist from this dataprovider's perspective.
            let skipItem = submittingItems.get(key) != null;
            if (!skipItem) {
                const editItem = unsubmittedItems.get(key);
                skipItem = editItem && editItem.operation === 'remove';
            }
            return skipItem;
        }
        static isSortFieldUpdated(key, detail, lastIterator, lastSortCriteria) {
            let sortUpd = false;
            if (lastIterator && lastSortCriteria && lastSortCriteria.length) {
                const keyIdx = this.findKeyInItems(key, lastIterator.mergedItemArray);
                if (keyIdx < 0) {
                    // don't need to move since the updated item is not in 'fetched' items
                    return false;
                }
                // find out the fields in sortCriterial if present
                const sortFields = [];
                let i = 0;
                if (lastIterator && lastSortCriteria) {
                    for (const sortCriteria of lastSortCriteria) {
                        sortFields[i++] = sortCriteria.attribute;
                    }
                }
                for (const sortField of sortFields) {
                    const idx = this.findKeyInMetadata(key, detail.metadata);
                    if (lastIterator.mergedItemArray[keyIdx][sortField] !== detail.data[idx]) {
                        sortUpd = true;
                    }
                }
            }
            return sortUpd;
        }
        // Get the operation detail from underlying mutate event and create new detail that reflect the current sortCriterion
        // The "indexes" property is also excluded from the new detail since it's optional and the original indexes could be wrong
        // due to "add" operations in the buffer.
        // addItem() always add new items to the top.
        // For 'add', when there is sortCriterion, addItem() will not move item and commit won't change the item's position.
        // When there is no sortCriterion, addItem() will not move item and commit won't change the item's position.
        // For 'remove', also delete unsubmitted remove and update items that have the same keys as the mutated items because
        // the underlying data items no longer exist.
        // For 'update', when there is sortCriterion, updateItem() will not move item and commit won't change the item's position.
        // When there is no sortCriterion, updateItem() will not move item and commit won't change the item's position.
        static getOperationDetails(details, addBeforeKeys, editBuffer) {
            if (details && (details.add || details.remove || details.update)) {
                let newDetails = {};
                const submittingItems = editBuffer.getSubmittingItems();
                const unsubmittedItems = editBuffer.getUnsubmittedItems();
                if (submittingItems.size === 0 && unsubmittedItems.size === 0) {
                    // If no item is buffered, simply use the underlying operation detail except indexes.
                    newDetails = details; // this.initDetails(details, newDetails, false);
                }
                else {
                    this.initDetails(details, newDetails, true);
                    this.processAdd(newDetails, details, addBeforeKeys);
                    let skipItem;
                    if (details.remove) {
                        details.remove.keys.forEach((key) => {
                            skipItem = this.isSkipItem(key, submittingItems, unsubmittedItems);
                            if (!skipItem) {
                                this.pushDetail(key, details.remove, newDetails.remove);
                            }
                            const editItem = unsubmittedItems.get(key);
                            if (editItem && (editItem.operation === 'remove' || editItem.operation === 'update')) {
                                unsubmittedItems.delete(key);
                            }
                        });
                    }
                    if (details.update) {
                        details.update.keys.forEach((key) => {
                            skipItem = this.isSkipItem(key, submittingItems, unsubmittedItems);
                            if (!skipItem) {
                                this.pushDetail(key, details.update, newDetails.update);
                            }
                        });
                    }
                }
                return newDetails;
            }
            else {
                return details;
            }
        }
        static processAdd(newDetails, details, addBeforeKeys) {
            if (details.add) {
                newDetails.add = { ...details.add };
                if (addBeforeKeys != null) {
                    newDetails.add.addBeforeKeys = addBeforeKeys;
                }
                return;
            }
        }
        static cleanUpSubmittedItem(key, editBuffer) {
            /**
             * called from handleMutateEvent
             * setItemStatus to 'submitted' and firing mutate event could happen in different order.
             * 1. when setItemStatus to 'submitted' happens before mutate event fired,
             * item should not be removed from submittingItems since handleMutateEvent
             * needs such information thus we set the internal 'status' to 'submitted'.
             * when mutate happens, we delete this item from submittingItems.
             * 2. when handleMutateEvent happens before setItemStatus to 'submitted',
             * we set the internal 'status' to 'mutated' so that when setItemStatus to 'submitted' happens,
             * we can delete the item from submittingItems.
             */
            const submittingItems = editBuffer.getSubmittingItems();
            const item = submittingItems.get(key);
            if (item) {
                editBuffer.setItemMutated(item);
            }
        }
        static checkGeneratedKeys(eventDetail, generatedKeyMap, lastIterator) {
            const checkKeyMap = (key, eventAddDetail, index) => {
                if (generatedKeyMap.has(key)) {
                    // need to remove the generated key
                    const transientKey = generatedKeyMap.get(key);
                    // sanity check to see if the new key isn't also in the remove array
                    if (!eventDetail.remove || !eventDetail.remove.keys?.has(key)) {
                        if (!eventDetail.remove) {
                            eventDetail.remove = { keys: new Set() };
                        }
                        // only keys is required for a remove, others like metadata are optional
                        eventDetail.remove.keys.add(transientKey);
                        // set the addBeforeKey so that the insert is to the first row
                        if (eventAddDetail) {
                            const firstKey = lastIterator?.mergedItemArray?.[0]?.metadata?.key;
                            if (firstKey !== null) {
                                if (!eventAddDetail.addBeforeKeys) {
                                    eventAddDetail.addBeforeKeys = [];
                                }
                                eventAddDetail.addBeforeKeys[index] = firstKey;
                            }
                        }
                    }
                }
            };
            if (eventDetail.add?.keys) {
                let i = 0;
                eventDetail.add.keys.forEach((key) => {
                    checkKeyMap(key, eventDetail.add, i);
                    i++;
                });
            }
        }
        static containsKeys(params, editBuffer, dataProvider) {
            // First try to resolve the keys from the buffer
            const bufferResult = BufferingDataProviderUtils.fetchByKeysFromBuffer(params, editBuffer);
            const unresolvedKeys = bufferResult.unresolvedKeys;
            const results = new Set();
            // Extract the set of keys from bufferResult
            bufferResult.results.forEach((value, key) => {
                results.add(key);
            });
            // We are done if all keys are resolved by the buffer
            if (unresolvedKeys.size === 0) {
                return Promise.resolve({ containsParameters: params, results });
            }
            // Otherwise fetch the remaining keys from the underlying DataProvider
            return dataProvider
                .containsKeys({ attributes: params.attributes, keys: unresolvedKeys, scope: params.scope })
                .then((baseResults) => {
                if (results.size > 0) {
                    // If we already have some results from the buffer, add the remaining results from the underlying DataProvider
                    baseResults.results.forEach((value, key) => {
                        results.add(key);
                    });
                    return { containsParameters: params, results };
                }
                return baseResults;
            });
        }
        static fetchByKeys(params, editBuffer, dataProvider) {
            // First try to resolve the keys from the buffer
            const bufferResult = BufferingDataProviderUtils.fetchByKeysFromBuffer(params, editBuffer);
            const unresolvedKeys = bufferResult.unresolvedKeys;
            const results = bufferResult.results;
            const signal = params?.signal;
            const callback = (resolve) => {
                // We are done if all keys are resolved by the buffer
                if (unresolvedKeys.size === 0) {
                    return resolve({ fetchParameters: params, results });
                }
                // Otherwise fetch the remaining keys from the underlying DataProvider
                return resolve(dataProvider
                    .fetchByKeys({
                    attributes: params.attributes,
                    keys: unresolvedKeys,
                    scope: params.scope,
                    signal
                })
                    .then((baseResults) => {
                    if (results.size > 0) {
                        // If we already have some results from the buffer, add the remaining results from the underlying DataProvider
                        baseResults.results.forEach((value, key) => {
                            results.set(key, value);
                        });
                        return { fetchParameters: params, results };
                    }
                    return baseResults;
                }));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
        static removeItem(item, lastIterator, editBuffer) {
            editBuffer.removeItem(item);
            // Remove item from the merged arrays
            BufferingDataProviderUtils.removeFromMergedArrays(item.metadata.key, false, lastIterator, editBuffer);
            // Fire mutate event if successful
            const detail = {
                remove: {
                    data: item.data ? [item.data] : null,
                    keys: new Set().add(item.metadata.key),
                    metadata: [item.metadata]
                }
            };
            return new ojdataprovider.DataProviderMutationEvent(detail);
        }
        static updateItem(item, editBuffer) {
            editBuffer.updateItem(item);
            // Fire mutate event if successful
            const detail = {
                update: {
                    data: [item.data],
                    keys: new Set().add(item.metadata.key),
                    metadata: [item.metadata]
                }
            };
            return new ojdataprovider.DataProviderMutationEvent(detail);
        }
        static addItem(addItem, editBuffer, lastIterator, addDetail) {
            editBuffer.addItem(addItem, addDetail);
            // Add item to the merged arrays
            const computedAddDetail = BufferingDataProviderUtils.addToMergedArrays(addItem, false, lastIterator, editBuffer, addDetail?.addBeforeKey != null ? addDetail.addBeforeKey : null, addDetail === undefined);
            // Fire mutate event if successful
            const detail = {
                add: {
                    data: [addItem.data],
                    keys: new Set().add(addItem.metadata.key),
                    metadata: [addItem.metadata],
                    addBeforeKeys: [computedAddDetail.addBeforeKey],
                    indexes: computedAddDetail.index === null ? null : [computedAddDetail.index]
                }
            };
            return new ojdataprovider.DataProviderMutationEvent(detail);
        }
        static fetchByOffset(params, editBuffer, dataProvider) {
            return BufferingDataProviderUtils.fetchFromOffset(params, dataProvider, editBuffer);
        }
        static getCapability(capabilityName, dataProvider) {
            return dataProvider.getCapability(capabilityName);
        }
        static getTotalSize(dataProvider, editBuffer) {
            // Start with the total size from underlying DataProvider
            return dataProvider.getTotalSize().then((totalSize) => {
                if (totalSize > -1) {
                    // Adjust the size by submitting items
                    totalSize += BufferingDataProviderUtils.calculateSizeChange(editBuffer.getSubmittingItems(), editBuffer);
                    // Adjust the size by unsubmitted items.  We shouldn't need to worry about
                    // "add" or "remove" items existing in both submitting and unsubmitted maps.
                    // Duplicate "add" and "remove" is not allowed.
                    totalSize += BufferingDataProviderUtils.calculateSizeChange(editBuffer.getUnsubmittedItems(), editBuffer);
                }
                return totalSize;
            });
        }
        static isEmpty(editBuffer, dataProvider) {
            const unsubmittedItems = editBuffer.getUnsubmittedItems();
            const submittingItems = editBuffer.getSubmittingItems();
            // If there is any add or update item, the BufferingDataProvider is not empty
            unsubmittedItems.forEach((item, key) => {
                if (item.operation === 'add' || item.operation === 'update') {
                    return 'no';
                }
            });
            submittingItems.forEach((item, key) => {
                if (item.operation === 'add' || item.operation === 'update') {
                    return 'no';
                }
            });
            // At this point, we know that there is either no item or only remove items in the buffer.
            // delegate to the underlying DataProvider
            const isEmpty = dataProvider.isEmpty();
            if (isEmpty === 'no') {
                // If the underlying DataProvider is not empty, the BufferingDataProvider can
                // still be empty if all the rows in the underlying DataProvider are being removed.
                // However, to verify that, we have to get all the keys from the underlying DataProvider,
                // which can be expensive.  Consumer usually calls isEmpty as an inexpensive way to
                // tell if the DataProvider has any data.  If we cannot tell inexpensively, we
                // returns "unknown".
                if (unsubmittedItems.size > 0 || submittingItems.size > 0) {
                    return 'unknown';
                }
            }
            return isEmpty;
        }
        static getSubmittableItems(editBuffer) {
            const unsubmitted = editBuffer.getUnsubmittedItems();
            const submitting = editBuffer.getSubmittingItems();
            // If some items are in submitting state, only return those unsubmitted items that don't
            // have the same keys as the ones that are submitting.
            const submittableItems = [];
            unsubmitted.forEach((editItem, key) => {
                if (!submitting.has(key)) {
                    submittableItems.push(editItem);
                }
            });
            return submittableItems;
        }
        static resetAllUnsubmittedItems(editBuffer) {
            // Clear the buffer and fire submittableChange event
            editBuffer.resetAllUnsubmittedItems();
        }
        static async resetUnsubmittedItem(editItem, editBuffer, dataProvider, lastIterator, keySet) {
            // Refetch the reset items and fire mutate event so that consumer have the original data
            return dataProvider.fetchByKeys({ keys: keySet }).then((resultObj) => {
                const detail = {};
                let resultItem;
                const transactions = editBuffer.getAllTransactions();
                const key = editItem.item.metadata.key;
                if (editItem.operation === 'add') {
                    // If we reset an "add" entry, remove the item from the merged array and fire mutate event with remove detail.
                    BufferingDataProviderUtils.removeFromMergedArrays(key, false, lastIterator, editBuffer);
                    BufferingDataProviderUtils.addEventDetail(detail, 'remove', editItem.item);
                    transactions.push({ ...editItem, ...{ operation: 'remove' } });
                }
                else if (editItem.operation === 'remove') {
                    // If we reset a "remove" entry, fire mutate event with add detail,
                    // unless the underlying data no longer exists, in which case we don't do anything.
                    resultItem = resultObj.results.get(key);
                    if (resultItem) {
                        // We need an addBeforeKey for mutate-add event
                        let addBeforeKey = null;
                        if (lastIterator) {
                            // There is an addBeforeKey only if the data has been iterated.
                            const mergedItemArray = lastIterator.mergedItemArray;
                            const keyIdx = BufferingDataProviderUtils.findKeyInItems(key, mergedItemArray);
                            if (keyIdx !== -1) {
                                for (let i = keyIdx + 1; i < mergedItemArray.length; i++) {
                                    if (!BufferingDataProviderUtils.isItemRemoved(mergedItemArray[i].metadata.key, editBuffer)) {
                                        addBeforeKey = mergedItemArray[i].metadata.key;
                                        break;
                                    }
                                }
                            }
                        }
                        BufferingDataProviderUtils.addEventDetail(detail, 'add', resultItem, addBeforeKey);
                        transactions.push({ operation: 'add', item: resultItem, addDetail: { addBeforeKey } });
                    }
                }
                else {
                    // If we reset an "update" entry, fire mutate event with update detail,
                    // unless the underlying data no longer exists, in which case we fire mutate event with remove detail
                    resultItem = resultObj.results.get(key);
                    if (resultItem) {
                        BufferingDataProviderUtils.addEventDetail(detail, 'update', resultItem);
                    }
                    else {
                        BufferingDataProviderUtils.addEventDetail(detail, 'remove', editItem.item);
                    }
                    transactions.push({ operation: 'update', item: resultItem });
                }
                return new ojdataprovider.DataProviderMutationEvent(detail);
            });
        }
        static setItemStatus(editItem, newStatus, generatedKeyMap, editBuffer, error, newKey) {
            if (editItem) {
                if (newKey != null) {
                    generatedKeyMap.set(newKey, editItem.item.metadata.key);
                }
                editBuffer.setItemStatus(editItem, newStatus, error);
                // If any item is changing status, we may have submittable items.
                // Call dispatchSubmittableChangeEvent, which will figure out if we need to fire submittableChange event.
                return editBuffer;
            }
            return null;
        }
        // Handle refresh event from underlying DataProvider
        static async handleRefreshEvent(event, editBuffer, dataProvider) {
            // If we get a refresh event from the underlying DataProvider, check to see if the
            // unsubmitted remove and update edits still exist in the underlying DataProvider
            const unsubmittedItems = editBuffer.getUnsubmittedItems();
            const keySet = new Set();
            unsubmittedItems.forEach((editItem) => {
                if (editItem.operation === 'remove' || editItem.operation === 'update') {
                    keySet.add(editItem.item.metadata.key);
                }
            });
            if (keySet.size > 0) {
                await dataProvider.fetchByKeys({ keys: keySet }).then((resultObj) => {
                    resultObj.results.forEach((_item, key) => {
                        keySet.delete(key);
                    });
                    // keySet now contains the keys of remove and update edits that no longer exist in the underlying DataProvider,
                    // so we remove them from the buffer.
                    keySet.forEach((key) => {
                        unsubmittedItems.delete(key);
                    });
                });
            }
            else if (event?.detail?.keys) {
                editBuffer.getSubmittingItems().forEach((_value, key) => {
                    const rootKey = key[0];
                    if (event.detail.keys.has(rootKey)) {
                        this.cleanUpSubmittedItem(key, editBuffer);
                    }
                });
            }
            // Fire the refresh event if we don't need to clean up the buffer
            return event;
        }
        // Handle mutate event from underlying DataProvider
        static handleMutateEvent(event, editBuffer, lastIterator, generatedKeyMap, lastSortCriteria) {
            // Fix up the merged arrays
            const detailAdd = event.detail.add;
            let addBeforeKeys;
            if (detailAdd && detailAdd.metadata && detailAdd.data) {
                addBeforeKeys = detailAdd.addBeforeKeys ? [...detailAdd.addBeforeKeys] : null;
                detailAdd.metadata.forEach((metadata, idx) => {
                    let addBeforeKey;
                    // if no addBeforeKeys exist from underlying DP, there is no need to do the adjustment bellow
                    if (detailAdd.addBeforeKeys && detailAdd.addBeforeKeys[idx] !== undefined) {
                        addBeforeKey = this.addToMergedArrays({ metadata: detailAdd.metadata[idx], data: detailAdd.data[idx] }, true, lastIterator, editBuffer, detailAdd.addBeforeKeys[idx]).addBeforeKey;
                        if (detailAdd.addBeforeKeys[idx] != null && addBeforeKey == null) {
                            // the item's addBeforeKey anchor item(s) is removed and the new item is end up at the end.
                            // fetchNext won't get the new items back since the removed items in the buffer
                            // won't reflect to the underlying DP offset
                            if (lastIterator && lastIterator.mergedItemArray) {
                                lastIterator.mergedItemArray.splice(lastIterator.mergedItemArray.length, 0, {
                                    data: detailAdd.data[idx],
                                    metadata: detailAdd.metadata[idx]
                                });
                            }
                        }
                        addBeforeKeys[idx] = addBeforeKey;
                    }
                    else {
                        if (detailAdd.indexes && detailAdd.indexes[idx] != null) {
                            let nextIdx = detailAdd.indexes[idx];
                            while (lastIterator && nextIdx < lastIterator.mergedItemArray.length) {
                                if (!this.isItemRemoved(lastIterator.mergedItemArray[nextIdx].metadata.key, editBuffer)) {
                                    break;
                                }
                                nextIdx++;
                            }
                            if (lastIterator && nextIdx >= lastIterator.mergedItemArray.length) {
                                lastIterator.mergedItemArray.splice(lastIterator.mergedItemArray.length, 0, {
                                    data: detailAdd.data[idx],
                                    metadata: detailAdd.metadata[idx]
                                });
                            }
                        }
                    }
                    this.cleanUpSubmittedItem(metadata.key, editBuffer);
                });
            }
            const detailRemove = event.detail.remove;
            if (detailRemove) {
                detailRemove.keys.forEach((key) => {
                    this.removeFromMergedArrays(key, true, lastIterator, editBuffer);
                    this.cleanUpSubmittedItem(key, editBuffer);
                });
            }
            const sortFldUpdateds = [];
            const detailUpdate = event.detail.update;
            if (detailUpdate) {
                let updateEventAddBeforeKeys = [];
                detailUpdate.data.forEach((currData, idx) => {
                    sortFldUpdateds[idx] = this.isSortFieldUpdated(detailUpdate.metadata[idx].key, detailUpdate, lastIterator, lastSortCriteria);
                    if (sortFldUpdateds[idx]) {
                        this.removeFromMergedArrays(detailUpdate.metadata[idx].key, true, lastIterator, editBuffer);
                        updateEventAddBeforeKeys[idx] = this.addToMergedArrays({ data: currData, metadata: detailUpdate.metadata[idx] }, true, lastIterator, editBuffer, null).addBeforeKey;
                        if (updateEventAddBeforeKeys[idx] == null) {
                            // the updated item is moved to the end.
                            // fetchNext won't get the new items back since the updated items in the buffer
                            // won't reflect to the underlying DP offset
                            if (lastIterator && lastIterator.mergedItemArray) {
                                lastIterator.mergedItemArray.splice(lastIterator.mergedItemArray.length, 0, {
                                    data: currData,
                                    metadata: detailUpdate.metadata[idx]
                                });
                            }
                        }
                    }
                    this.cleanUpSubmittedItem(detailUpdate.metadata[idx].key, editBuffer);
                });
            }
            const newDetails = this.getOperationDetails(event.detail, addBeforeKeys, editBuffer);
            // check if the event contains any mapped generated keys
            this.checkGeneratedKeys(newDetails, generatedKeyMap, lastIterator);
            return new ojdataprovider.DataProviderMutationEvent(newDetails);
        }
        static fetchNext(fetchParams, baseIterator, currentIterator, lastSortCriteria, editBuffer, parent) {
            const signal = fetchParams?.signal;
            const mergedAddKeySet = currentIterator.mergedAddKeySet;
            const mergedItemArray = currentIterator.mergedItemArray;
            const callback = (resolve) => {
                return resolve(baseIterator.next().then(async (result) => {
                    // The result should contain sortCriteria that's more accurate than the one from the fetch params
                    // e.g. it may contains sortCriteria property on the baseDP or implicitSort
                    if (result.value.fetchParameters && result.value.fetchParameters.sortCriteria) {
                        lastSortCriteria = result.value.fetchParameters.sortCriteria;
                    }
                    const baseItemArray = result.value.data.map((val, index) => {
                        return { data: result.value.data[index], metadata: result.value.metadata[index] };
                    });
                    parent.totalFilteredRowCount = result.value.totalFilteredRowCount;
                    await BufferingDataProviderUtils.mergeEdits(baseItemArray, mergedItemArray, fetchParams.filterCriterion, lastSortCriteria, mergedAddKeySet, result.done, editBuffer, parent);
                    // Find out how many items can be returned (i.e. not marked for "remove")
                    let actualReturnSize = mergedItemArray.length - currentIterator.nextOffset;
                    for (let i = currentIterator.nextOffset; i < mergedItemArray.length; i++) {
                        const item = mergedItemArray[i];
                        if (BufferingDataProviderUtils.isItemRemoved(item.metadata.key, editBuffer)) {
                            --actualReturnSize;
                        }
                    }
                    // If the new results don't have the requested number of rows, we may need to fetch more
                    const params = fetchParams || {};
                    if ((params.size && actualReturnSize < params.size) ||
                        (params.size == null && actualReturnSize === 0)) {
                        // We can only fetch more if the underlying DataProvider is not done
                        if (!result.done) {
                            return this.fetchNext(fetchParams, baseIterator, currentIterator, lastSortCriteria, editBuffer, parent);
                        }
                    }
                    // Construct the result
                    const newDataArray = [];
                    const newMetaArray = [];
                    let idx;
                    for (idx = currentIterator.nextOffset; idx < mergedItemArray.length; idx++) {
                        const item = mergedItemArray[idx];
                        if (!BufferingDataProviderUtils.isItemRemoved(item.metadata.key, editBuffer)) {
                            currentIterator.nextOffset = idx + 1;
                            newDataArray.push(item.data);
                            newMetaArray.push(item.metadata);
                            if (params.size && newDataArray.length === params.size) {
                                break;
                            }
                        }
                    }
                    const done = result.done && newDataArray.length === 0;
                    const returnParams = result.value?.fetchParameters?.sortCriteria == null
                        ? params
                        : { ...params, sortCriteria: result.value.fetchParameters.sortCriteria };
                    return {
                        done,
                        value: {
                            fetchParameters: returnParams,
                            data: newDataArray,
                            metadata: newMetaArray,
                            totalFilteredRowCount: fetchParams?.includeFilteredRowCount === 'enabled'
                                ? parent.totalFilteredRowCount
                                : null
                        }
                    };
                }));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, false);
        }
    }

    class EditBuffer {
        constructor() {
            this.unsubmittedItems = new ojMap();
            this.submittingItems = new ojMap();
            // Tracks submitted adds/move adds for the purpose of ignoring them in fetch calls
            this.submittedAddItems = new ojMap();
            // Tracks the order items were added in since adds can be split across the
            // unsubmitted/submitting/submitted maps in any order
            this.addItemOrder = [];
            // Tracks if an update is actually a remove/add
            this.mapOpTransform = new ojMap();
            /**
             * the order of receiving mutate event and set item status to 'submitted' is not consistent.
             * we can not remove an item from submittingItems unless this item has mutated and submitted.
             */
            this.mapEditItemStatus = new ojMap();
            // global array to track all edits in order and used to replay all changes in fetchByOffset
            this.transactions = [];
        }
        addItem(item, addDetail) {
            const key = item.metadata.key;
            const unsubmitted = this.unsubmittedItems.get(key);
            const submitting = this.submittingItems.get(key);
            if ((unsubmitted && (unsubmitted.operation === 'add' || unsubmitted.operation === 'update')) ||
                (submitting && (submitting.operation === 'add' || submitting.operation === 'update'))) {
                // It's an error if we add an item that's being added or updated
                throw new Error('Cannot add item with same key as an item being added or updated');
            }
            const editItem = { operation: 'add', item, ...(addDetail && { addDetail }) };
            this.transactions.push(editItem);
            if (unsubmitted && unsubmitted.operation === 'remove') {
                // If we add an item that's being remove, change the "remove" entry to an "update" entry
                // table doesn't have the key and fetchNext needs to return this item
                // remove the item and add back to keep the insert order
                this.unsubmittedItems.delete(key);
                const newEditItem = { ...editItem, ...{ operation: 'update' } };
                this.unsubmittedItems.set(key, newEditItem);
                this.mapOpTransform.set(key, newEditItem);
                this.addItemOrder.unshift(key);
                return;
            }
            this.unsubmittedItems.set(key, editItem);
            this.addItemOrder.unshift(key);
        }
        removeItem(item) {
            const key = item.metadata.key;
            const unsubmitted = this.unsubmittedItems.get(key);
            const submitting = this.submittingItems.get(key);
            if ((unsubmitted && unsubmitted.operation === 'remove') ||
                (submitting && submitting.operation === 'remove')) {
                // It's an error if we remove an item that's being removed
                throw new Error('Cannot remove item with same key as an item being removed');
            }
            const editItem = { operation: 'remove', item };
            this.transactions.push(editItem);
            if (unsubmitted && unsubmitted.operation === 'add') {
                // If we remove an item that's being added but unsubmitted, just remove it from the buffer as if it never exists
                this.unsubmittedItems.delete(key);
                this._removeFromAddItemOrder(key);
                return;
            }
            else if (unsubmitted && unsubmitted.operation === 'update') {
                // If we remove an item that's being updated but unsubmitted then delete update enrty and add remove
                this.unsubmittedItems.delete(key);
                this.unsubmittedItems.set(key, editItem);
                this.mapOpTransform.delete(key);
                this._removeFromAddItemOrder(key);
                return;
            }
            this._removeFromAddItemOrder(key);
            this.unsubmittedItems.set(key, editItem);
        }
        updateItem(item) {
            const unsubmitted = this.unsubmittedItems.get(item.metadata.key);
            const submitting = this.submittingItems.get(item.metadata.key);
            if ((unsubmitted && unsubmitted.operation === 'remove') ||
                (submitting && submitting.operation === 'remove')) {
                // It's an error if we update an item that's being removed
                throw new Error('Cannot update item with same key as an item being removed');
            }
            const editItem = { operation: 'update', item };
            this.transactions.push(editItem);
            if (unsubmitted && (unsubmitted.operation === 'add' || unsubmitted.operation === 'update')) {
                // If we update an item that's being added or updated but unsubmitted, it's the same operation with different data
                this.unsubmittedItems.set(item.metadata.key, {
                    operation: unsubmitted.operation,
                    item
                });
                return;
            }
            this.unsubmittedItems.set(item.metadata.key, editItem);
        }
        setItemMutated(editItem) {
            const key = editItem.item.metadata.key;
            const item = this.submittingItems.get(key);
            if (item) {
                const status = this.mapEditItemStatus.get(key);
                if (status === 'submitted') {
                    this.submittingItems.delete(key);
                    if (editItem.operation === 'remove') {
                        this.submittedAddItems.delete(key);
                    }
                    else if (this._isAddOrMoveAdd(item)) {
                        this.submittedAddItems.set(key, item);
                    }
                }
                else {
                    this.mapEditItemStatus.set(key, 'mutated');
                    this.submittingItems.set(key, item);
                }
            }
        }
        setItemStatus(editItem, newStatus, error) {
            const key = editItem.item.metadata.key;
            if (newStatus === 'submitting') {
                this.unsubmittedItems.delete(key);
                this.submittingItems.set(key, editItem);
            }
            else if (newStatus === 'submitted') {
                // the order of receiving mutate event and set item status to 'submitted' is not consistent.
                // we can not remove an item from submittingItems unless this item has mutated and submitted.
                if (editItem) {
                    const status = this.mapEditItemStatus.get(key);
                    if (status === 'mutated') {
                        this.submittingItems.delete(key);
                        if (this._isAddOrMoveAdd(editItem)) {
                            this.submittedAddItems.set(key, editItem);
                        }
                    }
                    else {
                        this.mapEditItemStatus.set(key, 'submitted');
                    }
                }
            }
            else if (newStatus === 'unsubmitted') {
                this.submittingItems.delete(key);
                let newEditItem;
                if (error) {
                    newEditItem = {
                        operation: editItem.operation,
                        item: {
                            data: editItem.item.data,
                            metadata: {
                                key: editItem.item.metadata.key,
                                message: error
                            }
                        }
                    };
                }
                else {
                    newEditItem = editItem;
                }
                this.unsubmittedItems.set(key, newEditItem);
            }
        }
        getUnsubmittedItems() {
            return this.unsubmittedItems;
        }
        getSubmittingItems() {
            return this.submittingItems;
        }
        getSubmittedAddItems() {
            return this.submittedAddItems;
        }
        isEmpty(includeSubmitted) {
            return (this.unsubmittedItems.size === 0 &&
                this.submittingItems.size === 0 &&
                (includeSubmitted ? this.submittedAddItems.size === 0 : true));
        }
        // Get an unsubmitted or submitting EditItem by key.
        getItem(key, includeSubmitted) {
            let editItem = this.unsubmittedItems.get(key);
            if (!editItem) {
                editItem = this.submittingItems.get(key);
            }
            if (includeSubmitted && !editItem) {
                editItem = this.submittedAddItems.get(key);
            }
            return editItem;
        }
        isUpdateTransformed(key) {
            return this.mapOpTransform.get(key) ? true : false;
        }
        getEditItemStatus(key) {
            return this.mapEditItemStatus.get(key);
        }
        isSubmittingOrSubmittedAdd(key) {
            return this.submittingItems.get(key)?.operation === 'add' || this.submittedAddItems.has(key);
        }
        resetAllUnsubmittedItems() {
            this._clearAddItemOrder();
            this.unsubmittedItems.clear();
            this.submittingItems.clear();
            this.mapOpTransform.clear();
            this.transactions = [];
        }
        _clearAddItemOrder() {
            // this will remove unsubmittedItems/submitting items from the add
            // order array, submitted items should stay where they are in this case
            this.unsubmittedItems.forEach((editItem, key) => {
                if (this._isAddOrMoveAdd(editItem)) {
                    this._removeFromAddItemOrder(key);
                }
            });
            this.submittingItems.forEach((editItem, key) => {
                if (this._isAddOrMoveAdd(editItem)) {
                    this._removeFromAddItemOrder(key);
                }
            });
        }
        _removeFromAddItemOrder(key) {
            let index = this.addItemOrder.findIndex((k) => {
                return oj.KeyUtils.equals(k, key);
            });
            if (index !== -1) {
                this.addItemOrder.splice(index, 1);
            }
        }
        _isAddOrMoveAdd(editItem) {
            return editItem.operation === 'add' || this._isMoveAdd(editItem);
        }
        _isMoveAdd(editItem) {
            return editItem.operation === 'update' && this.isUpdateTransformed(editItem.item.metadata.key);
        }
        getAddItemOrder() {
            return this.addItemOrder;
        }
        getAllTransactions() {
            return this.transactions;
        }
    }

    class TreeEditBuffer {
        constructor(editBuffer, parentKey, bufferingTreeDataProvider) {
            this.editBuffer = editBuffer;
            this.parentKey = parentKey;
            this.bufferingTreeDataProvider = bufferingTreeDataProvider;
        }
        filterByParentKey(editItemMap) {
            const parentMap = new ojMap();
            editItemMap.forEach((value, key) => {
                const keyParentKey = this.getParentKeyFromKey(key);
                if (oj.KeyUtils.equals(keyParentKey, this.parentKey)) {
                    parentMap.set(key, value);
                }
            });
            return parentMap;
        }
        getParentKeyFromKey(keyPath) {
            return keyPath.slice(0, keyPath.length - 1);
        }
        addItem(item, addDetail) {
            return this.editBuffer.addItem(item, addDetail);
        }
        removeItem(item) {
            return this.editBuffer.removeItem(item);
        }
        updateItem(item) {
            return this.editBuffer.updateItem(item);
        }
        setItemMutated(editItem) {
            return this.editBuffer.setItemMutated(editItem);
        }
        setItemStatus(editItem, newStatus, error) {
            return this.editBuffer.setItemStatus(editItem, newStatus, error);
        }
        getUnsubmittedItems() {
            const unSubbmitedItems = this.editBuffer.getUnsubmittedItems();
            if (this.parentKey !== undefined) {
                return this.filterByParentKey(unSubbmitedItems);
            }
            return unSubbmitedItems;
        }
        getSubmittingItems() {
            const subbmitedItems = this.editBuffer.getSubmittingItems();
            if (this.parentKey !== undefined) {
                return this.filterByParentKey(subbmitedItems);
            }
            return subbmitedItems;
        }
        getSubmittedAddItems() {
            const subbmitedItems = this.editBuffer.getSubmittedAddItems();
            if (this.parentKey !== undefined) {
                return this.filterByParentKey(subbmitedItems);
            }
            return subbmitedItems;
        }
        isEmpty(includeSubmitted) {
            return (this.getUnsubmittedItems().size === 0 &&
                this.getSubmittingItems().size === 0 &&
                (includeSubmitted ? this.getSubmittedAddItems().size === 0 : true));
        }
        getItem(key, includeSubmitted) {
            return this.editBuffer.getItem(key, includeSubmitted);
        }
        isUpdateTransformed(key) {
            return this.editBuffer.isUpdateTransformed(key);
        }
        getEditItemStatus(key) {
            return this.editBuffer.getEditItemStatus(key);
        }
        isSubmittingOrSubmittedAdd(key) {
            return this.editBuffer.isSubmittingOrSubmittedAdd(key);
        }
        resetAllUnsubmittedItems() {
            return this.editBuffer.resetAllUnsubmittedItems();
        }
        getAddItemOrder() {
            return this.editBuffer.getAddItemOrder().filter((key) => {
                const keyPath = this.bufferingTreeDataProvider.convertKeyToKeyPath(key);
                const itemParent = this.bufferingTreeDataProvider.getParentKey(keyPath);
                return oj.KeyUtils.equals(itemParent, this.parentKey);
            });
        }
        getAllTransactions() {
            const transactions = this.editBuffer.getAllTransactions();
            if (this.parentKey !== undefined) {
                return transactions.filter((editItem) => {
                    const keyParentKey = this.getParentKeyFromKey(editItem.item.metadata.key);
                    return oj.KeyUtils.equals(keyParentKey, this.parentKey);
                });
            }
            return transactions;
        }
    }

    exports.BufferingDataProviderUtils = BufferingDataProviderUtils;
    exports.EditBuffer = EditBuffer;
    exports.TreeEditBuffer = TreeEditBuffer;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbufferingdataprovider',['ojs/ojcore-base', 'ojs/ojdataprovider', 'ojs/ojeventtarget', 'ojs/ojmap', 'ojs/ojset', 'ojs/ojbufferingdataproviderevents', 'ojs/ojbufferingutils'], function (oj, ojdataprovider, ojeventtarget, ojMap, ojSet, ojbufferingdataproviderevents, ojbufferingutils) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    ojMap = ojMap && Object.prototype.hasOwnProperty.call(ojMap, 'default') ? ojMap['default'] : ojMap;
    ojSet = ojSet && Object.prototype.hasOwnProperty.call(ojSet, 'default') ? ojSet['default'] : ojSet;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 9.0.0
     * @export
     * @final
     * @class BufferingDataProvider
     * @ojtsmodule
     * @implements DataProvider
     * @classdesc
     * <p>BufferingDataProvider is a wrapping DataProvider that provides edit buffering for an underlying DataProvider, so that
     * the edits can be committed to the data source later on.
     * The underlying DataProvider is responsible for fetching data, and BufferingDataProvider will merge any buffered edits with
     * the underlying data so that they appear as an unified set of data.
     * </p>
     * <p>Because all edits are tracked by keys, the underlying DataProvider must return unique keys in the metadata.  If new rows
     * are added, unique keys must be specified for the new rows.
     * </p>
     * <p>In addition to the methods in the DataProvider interface, BufferingDataProvider implements a set of methods for managing edits:
     * <ul>
     *   <li>addItem</li>
     *   <li>removeItem</li>
     *   <li>updateItem</li>
     *   <li>getSubmittableItems</li>
     *   <li>resetAllUnsubmittedItems</li>
     *   <li>resetUnsubmittedItem</li>
     *   <li>setItemStatus</li>
     * </ul>
     * </p>
     * <p>In a typical usage scenario, an application will:
     * <ol>
     *   <li>Create an instance of the underlying DataProvider that provides the actual data.
     *   <li>Create an instance of BufferingDataProvider, passing the underlying DataProvider instance and any options.
     *   <li>Call "addItem", "removeItem", and "updateItem" on the BufferingDataProvider instance to create edit items, usually in response
     *       to user interactions.  These methods correspond to the basic data operations.  Buffer entries will be created for the edit items
     *       with a status of "unsubmitted".
     *   <li>When ready to submit the edits, call "getSubmittableItems" to get the list of submittable edit items.
     *   <li>Call "setItemStatus" to set the edit items' status to "submitting".
     *   <li>Submit the actual data to the data source and wait for its completion.  How this is done is up to the application and dependent
     *       on the data source.
     *   <li>If the submission is successful, call "setItemStatus" to set the edit items' status to "submitted".
     *       If the submission is unsuccessful, call "setItemStatus" to set the edit items' status
     *       to "unsubmitted" and pass error messages if available.
     *   <li>Show the error messages to the user if needed.
     * </ol>
     * </p>
     *
     * <p>In general, the edit item data should have the same shape as the data in the underlying DataProvider.  If sorting and filtering is used
     * in the underlying DataProvider, the application should ensure that all attributes referenced in the sort criterion and filter criterion are
     * included in the item data. Furthermore, iterators obtained by fetchFirst must all use the same sortCriteria if the application is using
     * those iterators at the same time.
     * </p>
     * <p>New rows are inserted at the beginning of the underlying data with latest item on top.
     * </p>
     * <p>
     * Updated rows are staying in their current position.
     * <p>
     * When uncommitted rows are sorted in current row set, their positions will correspond to server side position once they are committed.
     * Uncommitted rows will be sorted according to updated row set.
     * </p>
     * </p>
     * When new/updated items are committed, and if the underlying DataProvider fires mutate events for the committed items,
     * those items will not be sorted based on SortCriteria. The items will stay in their current positions until a subsequent sort or refresh.
     * </p>
     * <pre class="prettyprint"><code>
     * // ex: added and committed a new row with id 85
     *{
     *  add: {
     *    metadata: [{key: 85}],
     *    addBeforeKeys:[0],
     *    ...
     *  }
     *}
     * </code></pre>
     * <p>
     * Subsequent to a new/updated row but before the commit, the row can be sorted or filtered.
     * The sorted/filtered position of the row stays after the commit until a subsequent re-order/refresh.
     *
     * When uncommitted rows are sorted in current row set, their positions will correspond to server side position once they are committed.
     * Uncommitted rows will be sorted according to updated row set.
     * </p>
     *
     * <p>BufferingDataProvider does not validate the item key and data.  It is up to the application to perform any validation
     * prior to creating edit items in the buffer.
     * </p>
     *
     * <h3 id="events-section">
     *   Events
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
     * </h3>
     * Consumers can add event listeners to listen for the following event types and respond to data change.
     * <h4 id="event:mutate" class="name">
     *   mutate
     * </h4>
     * This event is fired when items have been added or removed from the data.
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>, which implements the {@link DataProviderMutationEventDetail} interface.
     * </p>
     *
     * <h4 id="event:refresh" class="name">
     *   refresh
     * </h4>
     * This event is fired when the data has been refreshed and components need to re-fetch the data.
     * <p>
     * This event contains no additional event payload.
     * </p>
     *
     * <h4 id="event:submittableChange" class="name">
     *   submittableChange
     * </h4>
     * This event is fired when the number of submittable edit items has changed.  An edit item is submittable if it is in "unsubmitted"
     * status and there is no other edit item with the same key in "submitting" status.
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>, which is array of objects that implement the {@link EditItem} interface.
     * </p>
     *
     * <i>Example of consumer listening for the "submittableChange" event type:</i>
     * <pre class="prettyprint"><code>let listener = function(event) {
     *   const editItems = event.detail;
     *   console.log("Number of submittable edit items: " + editItems.length);
     * };
     * dataProvider.addEventListener("submittableChange", listener);
     * </code></pre>
     *
     * @param {DataProvider} dataProvider The underlying DataProvider that provides the original data.
     * @param {BufferingDataProvider.Options=} options Options for the BufferingDataProvider
     * @ojsignature [{target: "Type",
     *               value: "class BufferingDataProvider<K, D> implements DataProvider<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of key"}, {"name": "D", "description": "Type of data"}]},
     *               {target: "Type",
     *               value: "DataProvider<K, D>",
     *               for: "dataProvider"},
     *               {target: "Type",
     *               value: "BufferingDataProvider.Options<K, D>",
     *               for: "options"}]
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "FetchByKeysParameters",
     *   "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     *   "FetchListResult","FetchListParameters", "Item", "ItemWithOptionalData", "ItemMessage"]}
     */

    /**
     * @typedef {Object} BufferingDataProvider.Options
     * @property {Function=} keyGenerator - Optional keyGenerator to use when a null key is passed in for addItem(). By default, BufferingDataProvider will
     * generate a v4 UUID string. Please use this option to supply your own key generator. The key generator function takes value as parameter and returns a key.
     * @ojsignature [{target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *               {target: "Type",
     *               value: "{ keyGenerator?: (value: Partial<D>) => K }"}]
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * Get an AsyncIterable object for iterating the data.
     * <p>
     * AsyncIterable contains a Symbol.asyncIterator method that returns an AsyncIterator.
     * AsyncIterator contains a next method for fetching the next block of data.
     * </p><p>
     * The "next" method returns a promise that resolves to an object, which contains a "value" property for the data and a "done" property
     * that is set to true when there is no more data to be fetched.  The "done" property should be set to true only if there is no "value"
     * in the result.  Note that "done" only reflects whether the iterator is done at the time "next" is called.  Future calls to "next"
     * may or may not return more rows for a mutable data source.
     * </p>
     * <p>
     * Please see the <a href="DataProvider.html#custom-implementations-section">DataProvider documentation</a> for
     * more information on custom implementations.
     * </p>
     *
     * @param {FetchListParameters=} params fetch parameters
     * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
     * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name fetchFirst
     * @ojsignature {target: "Type",
     *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
     * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
     * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
     * let result = await asyncIterator.next();
     * let value = result.value;
     * let data = value.data;
     * let keys = value.metadata.map(function(val) {
     *   return val.key;
     * });
     * // true or false for done
     * let done = result.done;
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    /**
     * Create a buffer entry for adding a row.  The entry initially has a status of 'unsubmitted'.
     * <p>
     * If a "remove" entry with same key already exists then it will be removed and an "update" entry with new data will be added to buffer.
     * </p><p>
     * Application can call setItemStatus to change the status of the entry to 'submitting' or 'submitted'.
     * There can be at most one entry in 'unsubmitted' status and one entry in 'submitting' status with the same key.  This
     * allows application to keep track of additional changes to a row while submitting previous changes.
     * </p>
     * <p>
     * Note: Starting in 12.0.1, addItem supports passing in an item which has null key. If the key is null then
     * a string typed v4 UUID key is generated for the key. It is expected that the application will later call
     * setItemStatus with the newKey parameter to pass in the real key once it becomes available after commit. The
     * newKey will then be stored in an internal map with the generated key and then when the underlying DataProvider
     * subsequently dispatches an add mutation event which contains the new key then the BufferingDataProvider will
     * include a remove mutation which will remove the row with the generated key. If a non-string typed or
     * non-v4 UUID generated key is desired then please use the constructor option: keyGenerator.
     *
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name addItem
     * @param {Item<K, D>} item - an Item object that represents the row.
     * @param {Object=} addDetail - object that represents addBefore Row. If addItem method is called only with item
     * parameter then item will be added at the top. If addBeforeKey is provided and that key exist in base dataprovider then item will be added before that key.
     * If addBeforeKey is null or provided key doesn't exist in base dataprovider then item will be added at the end.
     * @throws {Error} if an "add" or "update" entry already exists for the same key.
     * @ojsignature {target: "Type",
     *               value: "(item: Item<K, D>, addDetail?: {addBeforeKey?: K | null}): void"}
     */

    /**
     * Create a buffer entry for removing a row.  The entry initially has a status of 'unsubmitted'.
     * <p>
     * If an "add" entry already exists, it will be deleted.<br>
     * If an "update" entry already exists, it will be removed and a new "remove" entry will be added.
     * </p><p>
     * Application can call setItemStatus to change the status of the entry to 'submitting' or 'submitted'.
     * There can be at most one entry in 'unsubmitted' status and one entry in 'submitting' status with the same key.  This
     * allows application to keep track of additional changes to a row while submitting previous changes.
     * </p>
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name removeItem
     * @param {ItemWithOptionalData} item - an ItemWithOptionalData object that represents the row.
     * @throws {Error} if a "remove" entry already exists for the same key.
     * @ojsignature {target: "Type",
     *               value: "(item: ItemWithOptionalData<K, D>): void"}
     */

    /**
     * Create a buffer entry for updating a row.  The entry initially has a status of 'unsubmitted'.
     * <p>
     * If an "add" or "update" entry already exists, the data of the entry will be changed.
     * </p><p>
     * Application can call setItemStatus to change the status of the entry to 'submitting' or 'submitted'.
     * There can be at most one entry in 'unsubmitted' status and one entry in 'submitting' status with the same key.  This
     * allows application to keep track of additional changes to a row while submitting previous changes.
     * </p>
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name updateItem
     * @param {Item<K, D>} item - an Item object that represents the row.
     * @throws {Error} if a "remove" entry already exists for the same key.
     * @ojsignature {target: "Type",
     *               value: "(item: Item<K, D>): void"}
     */

    /**
     * Get the list of all submittable edit items.
     * <p>
     * Caller should call setItemStatus to change the status
     * to "submitting" when ready to submit.  Once the edit item for a key is moved to 'submitting', new edit for the same
     * key will be tracked separately.  There can be at most one "submitting" edit item and one "unsubmitted" edit item for the same key.
     * Since we are using key to tracking edit, the key value should be immutable. We could not update the key value in "updateItem".
     * </p>
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name getSubmittableItems
     * @return {Array<BufferingDataProvider.EditItem<K, D>>} an array of all submittable edit items.  Each edit item implements the {@link EditItem} interface.
     * @ojsignature {target: "Type",
     *               value: "(): Array<BufferingDataProvider.EditItem<K, D>>"}
     */

    /**
     * Reset all rows by discarding all 'unsubmitted' edit items, so that the data from the underlying
     * DataProvider will be used.
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name resetAllUnsubmittedItems
     * @return {void}
     */

    /**
     * Reset a row by discarding any 'unsubmitted' edit item for the row, so that the data from the underlying
     * DataProvider will be used.
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name resetUnsubmittedItem
     * @return {void}
     * @param {K} key - The key of the row to reset.
     * @ojsignature {target: "Type",
     *               value: "(key: K): void"}
     */

    /**
     * Set the status of an edit item.
     * <p>
     * Application should set an edit item to 'submitting' before committing its change to the data source.  This will prevent
     * any new edit item with the same key from being changed to 'submitting'.
     * </p><p>
     * When setting an edit item from 'submitting' back to 'unsubmitted' (usually upon submission error),
     * and there is another 'unsubmitted' entry for the same key (this happens when edit is allowed while an edit item is submitting),
     * the error will be set on the new 'unsubmitted' entry and the current 'submitting' entry will be disposed.
     * </p><p>
     * when setting an edit item to 'submitted', the edit item will be removed from the buffer.
     * </p>
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof BufferingDataProvider
     * @instance
     * @method
     * @name setItemStatus
     * @param {BufferingDataProvider.EditItem<K, D>} editItem - The edit item to set status on.  This should implement the {@link EditItem} interface and is
     *   usually one of the items returned by the getSubmittableItems method.
     * @param {'unsubmitted' | 'submitting' | 'submitted'} newStatus - the new status of the edit item.
     *   If an edit item is marked as "submitted", it will be removed at the DataProvider's discretion.
     * @param {ItemMessage?} error - an optional error message.
     * @param {K?} newKey - an optional new key for the item. This is used in cases where addItem was called with a null key which will cause BufferingDataProvider
     * to generate a key. Passing in the real key when it becomes available will enable BufferingDataProvider to map the real and generated keys so that a subsequent
     * add mutation event for the real key will result in BufferingDataProvider also including a remove for the generated key.
     * @ojsignature {target: "Type",
     *               value: "(editItem: BufferingDataProvider.EditItem<K, D>, newStatus: 'unsubmitted' | 'submitting' | 'submitted', error?: ItemMessage, newKey?: K): void"}
     */

    // end of jsdoc

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     * The interface for EditItem
     *
     *
     * @since 9.0.0
     * @export
     * @interface EditItem
     * @ojtsnamespace BufferingDataProvider
     * @ojsignature {target: "Type",
     *               value: "interface EditItem<K, D>",
     *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
     */

    /**
     * The type of buffered edit.
     * <p>
     * Possible values are:<ul>
     * <li>'add': The edit is for adding a new item to the data source.</li>
     * <li>'remove': The edit is for removing an existing item from the data source.</li>
     * <li>'update': The edit is for updating an existing item from the data source.</li>
     * </ul>
     * </p>
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof EditItem
     * @instance
     * @readonly
     * @name operation
     * @type {'add' | 'remove' | 'update'}
     * @ojsignature {target: "Type",
     *               value: "'add' | 'remove' | 'update'"}
     */

    /**
     * The Item object that represents the edited item.
     *
     *
     * @since 9.0.0
     * @export
     * @expose
     * @memberof EditItem
     * @instance
     * @readonly
     * @name item
     * @type {ItemWithOptionalData<K, D>}
     * @ojsignature {target: "Type",
     *               value: "ItemWithOptionalData<K, D>"}
     */

    // end of jsdoc

    /**
     * Class which provides edit buffering
     */
    class BufferingDataProvider {
        constructor(_dataProvider, _options) {
            var _a;
            this._dataProvider = _dataProvider;
            this._options = _options;
            this.AsyncIterable = (_a = class {
                    constructor(_parent, _asyncIterator) {
                        this._parent = _parent;
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = function () {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this.AsyncIterator = class {
                constructor(_parent, _baseIterator, _params) {
                    this._parent = _parent;
                    this._baseIterator = _baseIterator;
                    this._params = _params;
                    this.mergedAddKeySet = new ojSet();
                    this.mergedItemArray = [];
                    this.nextOffset = 0;
                    if (this._params == null) {
                        this._params = {};
                    }
                }
                next() {
                    return ojbufferingutils.BufferingDataProviderUtils.fetchNext(this._params, this._baseIterator, this, this._parent.lastSortCriteria, this._parent.editBuffer, this._parent);
                }
            };
            this.editBuffer = new ojbufferingutils.EditBuffer();
            this.lastSortCriteria = null;
            this.lastIterator = null;
            this.customKeyGenerator = _options?.keyGenerator;
            this.generatedKeyMap = new ojMap();
            this.totalFilteredRowCount = 0;
            this.dataBeforeUpdated = new Map();
            this.dataProvider = _dataProvider;
            this.options = _options;
            this._addEventListeners();
        }
        containsKeys(params) {
            return ojbufferingutils.BufferingDataProviderUtils.containsKeys(params, this.editBuffer, this.dataProvider);
        }
        fetchByKeys(params) {
            return ojbufferingutils.BufferingDataProviderUtils.fetchByKeys(params, this.editBuffer, this.dataProvider);
        }
        removeItem(item) {
            const mutationEvent = ojbufferingutils.BufferingDataProviderUtils.removeItem(item, this.lastIterator, this.editBuffer);
            this.dispatchEvent(mutationEvent);
            this.dispatchSubmittableChangeEvent(this.editBuffer);
        }
        updateItem(item) {
            const mutationEvent = ojbufferingutils.BufferingDataProviderUtils.updateItem(item, this.editBuffer);
            this.dispatchEvent(mutationEvent);
            this.dispatchSubmittableChangeEvent(this.editBuffer);
        }
        addItem(item, addDetail) {
            const addItem = Object.assign({}, item);
            if (item.metadata.key === null) {
                addItem.metadata = Object.assign({}, item.metadata);
                addItem.metadata.key = ojbufferingutils.BufferingDataProviderUtils.generateKey(item.data, this.customKeyGenerator);
            }
            const mutationEvent = ojbufferingutils.BufferingDataProviderUtils.addItem(addItem, this.editBuffer, this.lastIterator, addDetail);
            this.dispatchEvent(mutationEvent);
            this.dispatchSubmittableChangeEvent(this.editBuffer);
        }
        fetchByOffset(params) {
            return ojbufferingutils.BufferingDataProviderUtils.fetchByOffset(params, this.editBuffer, this.dataProvider);
        }
        fetchFirst(params) {
            this.lastSortCriteria = params ? params.sortCriteria : null;
            const baseIterator = this.dataProvider.fetchFirst(params)[Symbol.asyncIterator]();
            this.lastIterator = new this.AsyncIterator(this, baseIterator, params);
            return new this.AsyncIterable(this, this.lastIterator);
        }
        getCapability(capabilityName) {
            return ojbufferingutils.BufferingDataProviderUtils.getCapability(capabilityName, this.dataProvider);
        }
        getTotalSize() {
            return ojbufferingutils.BufferingDataProviderUtils.getTotalSize(this.dataProvider, this.editBuffer);
        }
        isEmpty() {
            return ojbufferingutils.BufferingDataProviderUtils.isEmpty(this.editBuffer, this.dataProvider);
        }
        getSubmittableItems() {
            return ojbufferingutils.BufferingDataProviderUtils.getSubmittableItems(this.editBuffer);
        }
        resetAllUnsubmittedItems() {
            ojbufferingutils.BufferingDataProviderUtils.resetAllUnsubmittedItems(this.editBuffer);
            this.dispatchSubmittableChangeEvent(this.editBuffer);
            this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
        }
        resetUnsubmittedItem(key) {
            const unsubmittedItems = this.editBuffer.getUnsubmittedItems();
            const keySet = new Set();
            // Remove the reset items from buffer and fire submittableChange event
            const editItem = unsubmittedItems.get(key);
            if (!editItem) {
                return;
            }
            keySet.add(key);
            unsubmittedItems.delete(key);
            this.dispatchSubmittableChangeEvent(this.editBuffer);
            ojbufferingutils.BufferingDataProviderUtils.resetUnsubmittedItem(editItem, this.editBuffer, this.dataProvider, this.lastIterator, keySet).then((mutationEvent) => {
                this.dispatchEvent(mutationEvent);
            });
        }
        setItemStatus(editItem, newStatus, error, newKey) {
            const editBuffer = ojbufferingutils.BufferingDataProviderUtils.setItemStatus(editItem, newStatus, this.generatedKeyMap, this.editBuffer, error, newKey);
            if (editBuffer) {
                // If any item is changing status, we may have submittable items.
                // Call dispatchSubmittableChangeEvent, which will figure out if we need to fire submittableChange event.
                this.dispatchSubmittableChangeEvent(editBuffer);
            }
        }
        dispatchSubmittableChangeEvent(editBuffer) {
            // Fire the submittableChange event if the number of submittable item has changed
            const submittable = ojbufferingutils.BufferingDataProviderUtils.getSubmittableItems(editBuffer);
            const event = new ojbufferingdataproviderevents.BufferingDataProviderSubmittableChangeEvent(submittable);
            this.dispatchEvent(event);
        }
        // Dupped code to buffering utils to make sure people who used to get synchronous events still do, even tho we should await fetchByKeys
        _handleRefreshEvent(event) {
            // reset dataBeforeUpdated
            this.dataBeforeUpdated = new Map();
            // If we get a refresh event from the underlying DataProvider, check to see if the
            // unsubmitted remove and update edits still exist in the underlying DataProvider
            const unsubmittedItems = this.editBuffer.getUnsubmittedItems();
            const keySet = new Set();
            unsubmittedItems.forEach((editItem) => {
                if (editItem.operation === 'remove' || editItem.operation === 'update') {
                    keySet.add(editItem.item.metadata.key);
                }
            });
            if (keySet.size > 0) {
                this.dataProvider.fetchByKeys({ keys: keySet }).then((resultObj) => {
                    resultObj.results.forEach((item, key) => {
                        keySet.delete(key);
                    });
                    // keySet now contains the keys of remove and update edits that no longer exist in the underlying DataProvider,
                    // so we remove them from the buffer.
                    keySet.forEach((key) => {
                        unsubmittedItems.delete(key);
                    });
                    // Fire the refresh event after we have cleaned up the buffer
                    this.dispatchEvent(event);
                });
            }
            else {
                // Fire the refresh event if we don't need to clean up the buffer
                this.dispatchEvent(event);
            }
        }
        _addEventListeners() {
            this.dataProvider.addEventListener(BufferingDataProvider._REFRESH, this._handleRefreshEvent.bind(this));
            this.dataProvider.addEventListener(BufferingDataProvider._MUTATE, (event) => {
                this.dataBeforeUpdated = new Map();
                const mutationEvent = ojbufferingutils.BufferingDataProviderUtils.handleMutateEvent(event, this.editBuffer, this.lastIterator, this.generatedKeyMap, this.lastSortCriteria);
                this.dispatchEvent(mutationEvent);
            });
        }
    }
    BufferingDataProvider._REFRESH = 'refresh';
    BufferingDataProvider._MUTATE = 'mutate';
    ojeventtarget.EventTargetMixin.applyMixin(BufferingDataProvider);
    oj._registerLegacyNamespaceProp('BufferingDataProvider', BufferingDataProvider);

    return BufferingDataProvider;

});


define('ojs/ojrestdataprovider',['exports', 'ojs/ojeventtarget', 'ojs/ojdataprovider', 'ojs/ojset', 'ojs/ojmap', 'ojs/ojmetadatautils'], function (exports, ojeventtarget, ojdataprovider, ojSet, ojMap, ojmetadatautils) { 'use strict';

    ojSet = ojSet && Object.prototype.hasOwnProperty.call(ojSet, 'default') ? ojSet['default'] : ojSet;
    ojMap = ojMap && Object.prototype.hasOwnProperty.call(ojMap, 'default') ? ojMap['default'] : ojMap;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     *
     * @since 11.0.0
     * @export
     * @final
     * @class RESTDataProvider
     * @implements DataProvider
     * @classdesc This class implements {@link DataProvider}.
     *            Object representing data available from a JSON-based REST service.
     *            This dataprovider can be used by [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
     *            [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
     * RESTDataProvider is an implementation of DataProvider for fetching data from a JSON-based REST API using the Fetch API . RESTDataProvider fetch calls are based on transforms which are specified as an option to the RESTDataProvider constructor. For each fetch method (fetchFirst, fetchByOffset and fetchByKeys), they define the following functions:
     * <ul>
     * <li>request : function that returns a Promise that resolves to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">Request</a> object to use for the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> call to the the REST API. This is where any required query parameters for paging, filtering, sorting and more can be applied to the URL which can then be used to create a request. Other request options, such as headers , body and method can also be added to the request if needed. If written in Typescript, the function can be defined using async which automatically wraps the return value in a Promise . Otherwise, a Promise has to be explicitly returned e.g return Promise.resolve(new Request(...)) . </li>
     * <li>response : function that extracts the data and other relevant values from the response body and returns a Promise that resolves to those values. The function must at least return an object with a data property that is an array of items of shape D (generic passed into RESTDataProvider class). If written in Typescript, the function can be defined using async which automatically wraps the return value in a Promise . Otherwise, a Promise has to be explicitly returned e.g return Promise.resolve({ data }) .</li>
     * </ul>
     * Please navigate to the corresponding demos for details of how to define transforms to accomplish various fetch tasks. <br><br>
     *
     * <h3 id="events-section">
     *   Events
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
     * </h3>
     * Consumers can add event listeners to listen for the following event types.
     * <h4 id="event:mutate" class="name">
     * mutate
     * </h4>
     * This event is fired when the mutate method is called.
     * <p>
     * Event payload is found under <code class="prettyprint">event.detail</code>, which implements the {@link DataProviderMutationEventDetail} interface.
     * </p>
     *
     * <h4 id="event:refresh" class="name">
     *   refresh
     * </h4>
     * This event is fired when the refresh method is called.
     * <p>
     * This event contains no additional event payload.
     * </p>
     *
     * <i>Example of consumer listening for the "mutate" event type:</i>
     * <pre class="prettyprint"><code>var listener = function(event) {
     *   if (event.detail.remove) {
     *     var removeDetail = event.detail.remove;
     *     // Handle removed items
     *   }
     * };
     * dataProvider.addEventListener("mutate", listener);
     * </code></pre>
     *
     * @param {Object} options options for the RESTDataProvider
     * @ojsignature [{target: "Type",
     *               value: "class RESTDataProvider<K, D> implements DataProvider<K, D>",
     *               genericTypeParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
     *               {target: "Type",
     *               value: "RESTDataProvider.Options<K, D>",
     *               for: "options"}]
     *
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
     * "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults",
     * "FetchListResult","FetchListParameters", "FetchByKeysCapability", "FetchByOffsetCapability", "FilterCapability",
     * "SortCapability", "DataProviderMutationEventDetail", "ItemMetadata"]}
     * @ojtsexample
     * // First create an options object with the minimum fields
     * const options = {
     *  url: 'url/to/rest/endpoint',
     *  transforms: {
     *   // fetchByOffset and fetchByKeys delegate to fetchFirst if their capabilities are not defined
     *   // so at minimum we must specify transforms for fetchFirst
     *   fetchFirst: {
     *     request: async (options) => {
     *       // Use size and offset to set the expected paging parameters and create a request.
     *       // In this example, "size" corresponds to the endpoint' "limit"
     *       // parameter and "offset" corresponds to the endpoint' "offset" parameter for the mock
     *       // server. Note that the function needs to return a Promise, hence the use of async which
     *       // automatically wraps the return value in one
     *       const url = new URL(options.url);
     *       const { size, offset } = options.fetchParameters;
     *       url.searchParams.set("limit", String(size));
     *       url.searchParams.set("offset", String(offset));
     *       return new Request(url.href);
     *     },
     *     response: async ({ body }) => {
     *       // The mock server sends back a response body with shape { hasMore, keys, totalSize, data} so
     *       // we need to extract and return them. "keys" is optional, it is needed when the REST endpoint
     *       // returns the set of keys associated with the data. When not available, RESTDataProvider generates
     *       // the keys from the data based on keyAttributes. Again, note that the function needs to return a
     *       // Promise hence the use of async which automatically wraps the return value in one
     *       const { data, keys, totalSize, hasMore } = body;
     *       return { data, keys, totalSize, hasMore };
     *     }
     *   }
     *  }
     * };
     * // Then create an RESTDataProvider object with the options
     * const dataprovider = new RESTDataProvider(options);
     * @example
     * // First create an options object with the minimum fields
     * var options = {
     *  url: 'url/to/rest/endpoint',
     *  transforms: {
     *   // fetchByOffset and fetchByKeys delegate to fetchFirst if their capabilities are not defined
     *   // so at minimum we must specify transforms for fetchFirst
     *   fetchFirst: {
     *     request: (options) => {
     *       // Use size and offset to set the expected paging parameters and create a request.
     *       // In this example, "size" corresponds to the endpoint' "limit"
     *       // parameter and "offset" corresponds to the endpoint' "offset" parameter for the mock
     *       // server. Note that the function needs to return a Promise
     *       const url = new URL(options.url);
     *       const size = options.fetchParameters.offset;
     *       const offset = options.fetchParameters.offset;
     *       url.searchParams.set("limit", String(size));
     *       url.searchParams.set("offset", String(offset));
     *       return Promise.resolve(new Request(url.href));
     *     },
     *     response: ({ body }) => {
     *       // The mock server sends back a response body with shape { hasMore, keys, totalSize, data} so
     *       // we need to extract and return them. "keys" is optional, it is needed when the REST endpoint
     *       // returns the set of keys associated with the data. When not available, RESTDataProvider generates
     *       // the keys from the data based on keyAttributes. Again, note that the function needs to return a
     *       // Promise
     *       return Promise.resolve({ data: body.data, totalSize: body.totalSize, hasMore: body.hasMore });
     *     }
     *   }
     *  }
     * };
     * // Then create an RESTDataProvider object with the options
     * const dataprovider = new RESTDataProvider(options);
     */

    /**
     * @typedef {Object} RESTDataProvider.Options
     * @property {string=} url - URL of the REST endpoint to fetch data from.
     * @property {string} keyAttributes - The field name which stores the key in the data. Can be a string denoting a single key attribute or an array
     * of strings for multiple key attributes.
     * @property {Object=} transforms - Object which defines functions that transform the request when fetchFirst, fetchByOffset and fetchByKeys are called.
     * @property {Object=} capabilities - Object which defines the capabilities of the RESTDataProvider instance based on the REST service is fetches data from.
     * @property {Array=} implicitSort - Array of {@link SortCriterion} used to specify sort information when the fetched data is already sorted.
     * For example, ojTable will display the column sort indicator for the corresponding column in either ascending or descending order upon initial render.
     * This option is not used for cases where we want the RESTDataProvider to apply a sort on initial fetch.
     * @property {Array=} textFilterAttributes - Specify which attributes the filter should be applied on when a TextFilter filterCriteria is specified.
     * @property {number=} iterationLimit - Specify the maximum number of rows to fetch when iterating through the data. This is particularly useful when fetchByKeys
     * delegates to fetchFirst (because the fetchByKeys capability has not be set with an implementation of "lookup" or "batchLookup"). In the fetchByKeys case,
     * fetchFirst has to iterate through all the data in search of rows corresponding to the provided keys. Without an iteration limit, the iteration can continue
     * for a long time if the provided keys are invalid or the corresponding rows are at the end of the dataset.
     * @property {Function=} error - Callback function that is executed when a fetch error has occurred.
     * @property {Object=} restHelper - Using the default RESTDataProvider fetch implementation with transforms is preferred for code maintainability.
     *                                  However, for rare use cases that require overriding the RESTDataProvider's default fetch call, applications should specify their restHelper as a constructor option.
     *                                  The restHelper is an object containing custom fetch functions for fetchFirst, fetchByOffset, and fetchByKeys.
     *                                  Specifying a fetchFirst rest helper is required when setting any custom fetch implementation.
     *                                  Specifying a fetchByOffset rest helper is required when setting the capability of fetchByOffset to randomAccess.
     *                                  Specifying a fetchByKeys rest helper is required when setting the capability of fetchByKeys to either lookup or batchLookup.
     *                                  The signatures of each rest helper can be found in the API documentation of RESTDataProvider.
     * @property {string=} enforceKeyStringify - Optionally specify whether keys need to be converted to strings. Supported values:<br>
     *                                  <ul>
     *                                    <li>'off': the key values are returned as it is.
     *                                    <li>'on': the key values are converted into string.
     *                                  </ul>
     *                                Default is 'off'.
     *                                Key stringify will directly call JSON.stringify on all keys passed out of the DataProvider. Use JSON.parse if you need to convert the key back to a complex type.
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "string | string[]", for: "keyAttributes"},
     *  {target: "Type", value: "Transforms<K, D>", for: "transforms"},
     *  {target: "Type", value: "Capabilities", for: "capabilities"},
     *  {target: "Type", value: "Array<SortCriterion<D>>", for: "implicitSort"},
     *  {target: "Type", value: "string[]", for: "textFilterAttributes"},
     *  {target: "Type", value: "(response: FetchErrorDetail<K,D > | FetchResponseErrorDetail<K,D>) => void", for: "error", jsdocOverride: true},
     *  {target: "Type", value: " { fetchFirst: (
     *     options: RESTDataProvider.RESTHelperFetchByOffsetRequestOptions<K,D>
     *   ) => Promise<RESTDataProvider.RESTHelperResponse<K, D>>;
     *   fetchByOffset?: (
     *     options: RESTDataProvider.RESTHelperFetchByOffsetRequestOptions<K,D>
     *   ) => Promise<RESTDataProvider.RESTHelperResponse<K, D>>;
     *   fetchByKeys?: (
     *     options: RESTDataProvider.RESTHelperFetchByKeysRequestOptions<K,D>
     *   ) => Promise<RESTDataProvider.RESTHelperResponse<K, D>>; }", for: "restHelper", jsdocOverride: true},
     *  {target: "Type", value: "'off' | 'on'", for: "enforceKeyStringify"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchResponseOptions
     * @property {number} status - response status number
     * @property {Object} headers - response headers object
     * @property {Object} body - response body
     * @ojsignature [
     *  {target: "Type", value: "Headers", for: "headers"},
     *  {target: "Type", value: "any", for: "body"}
     * ]
     */

    /**
     * This type will be returned to the error callback when underlying fetch call has resulted in a type error.
     * @typedef {Object} RESTDataProvider.FetchErrorDetail
     * @property {string} fetchType - Type of fetch that was made
     * @property {Object} options - Options passed in to RESTDataProvider
     * @property {any} error - Error returned from fetch call
     * @property {TypeError} err - TypeError returned from fetch call (deprecated)
     * @property {Object} fetchParameters - FetchParams passed into the fetch call
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "'fetchFirst' | 'fetchByKeys' | 'fetchByOffset'", for: "fetchType"},
     *  {target: "Type", value: "RESTDataProvider.Options<K, D>", for: "options"},
     *  {target: "Type", value: "FetchListParameters<D> | FetchByKeysParameters<K> | FetchByOffsetParameters<D>", for: "fetchParameters"}]
     * @ojdeprecated [{target: "property", for: "err", since: "15.1.0", description: "Use FetchErrorDetail.error instead."}]
     */

    /**
     * This type will be returned to the error callback when underlying fetch call has resulted in an response with response.ok = false.
     * @typedef {Object} RESTDataProvider.FetchResponseErrorDetail
     * @property {string} fetchType - Type of fetch that was made
     * @property {Object} options - Options passed in to RESTDataProvider
     * @property {Object} response - Response returned from server
     * @property {Object} fetchParameters - FetchParams passed into the fetch call
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "'fetchFirst' | 'fetchByKeys' | 'fetchByOffset'", for: "fetchType"},
     *  {target: "Type", value: "RESTDataProvider.FetchResponseOptions", for: "response"},
     *  {target: "Type", value: "RESTDataProvider.Options<K, D>", for: "options"},
     *  {target: "Type", value: "FetchListParameters<D> | FetchByKeysParameters<K> | FetchByOffsetParameters<D>", for: "fetchParameters"}]
     */

    /**
     * @typedef {Object} RESTDataProvider.Transforms
     * @property {Object=} fetchFirst - Object which specifies transforms for fetchFirst calls
     * @property {Object=} fetchByOffset - Object which specifies transforms for fetchByOffset calls
     * @property {Object=} fetchByKeys - Object which specifies transforms for fetchByKeys calls
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "FetchByOffsetTransforms<K, D>", for: "fetchFirst"},
     *  {target: "Type", value: "FetchByOffsetTransforms<K, D>", for: "fetchByOffset"},
     *  {target: "Type", value: "FetchByKeysTransforms<K, D>", for: "fetchByKeys"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchByOffsetTransforms
     * @property {Object=} request - Object which specifies request transforms
     * @property {Object=} response - Object which specifies response transforms
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "FetchByOffsetRequestTransform<K, D>", for: "request"},
     *  {target: "Type", value: "FetchResponseTransform<K, D>", for: "response"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchByKeysTransforms
     * @property {Object=} request - Object which specifies request transforms
     * @property {Object=} response - Object which specifies response transforms
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "FetchByKeysRequestTransform<K>", for: "request"},
     *  {target: "Type", value: "FetchResponseTransform<K, D>", for: "response"}
     * ]
     */

    /**
     * @typedef {Function} RESTDataProvider.FetchByOffsetRequestTransform
     * @ojsignature [
     *   {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *   {target: "Type", value: "(options: FetchByOffsetRequestTransformOptions<K, D>) => Promise<Request>"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchByOffsetRequestTransformOptions
     * @property {string} url - url to use for fetch call
     * @property {Object} fetchParameters - fetch parameters of the called fetch method
     * @property {string} fetchType - fetch method called
     * @property {Object} fetchOptions - fetch options passed into constructor such as textFilterAttributes
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "FetchByOffsetParameters<D>", for: "fetchParameters"},
     *  {target: "Type", value: "'fetchFirst' | 'fetchByOffset'", for: "fetchType"},
     *  {target: "Type", value: "{ textFilterAttributes?: Options<K, D>['textFilterAttributes'] }", for: "fetchOptions"}
     * ]
     */

    /**
     * @typedef {Function} RESTDataProvider.FetchByKeysRequestTransform
     * @ojsignature [
     *   {target: "Type", value: "<K>", for: "genericTypeParameters"},
     *   {target: "Type", value: "(options: FetchByKeysRequestTransformOptions<K>) => Promise<Request>"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchByKeysRequestTransformOptions
     * @property {string} url - url to use for fetch call
     * @property {Object} fetchParameters - fetch parameters of the called fetch method
     * @property {string} fetchType - fetch method called
     * @ojsignature [
     *  {target: "Type", value: "<K>", for: "genericTypeParameters"},
     *  {target: "Type", value: "FetchByKeysParameters<K>", for: "fetchParameters"},
     *  {target: "Type", value: "'fetchByKeys'", for: "fetchType"}
     * ]
     */

    /**
     * @typedef {Function} RESTDataProvider.FetchResponseTransform
     * @ojsignature [
     *   {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *   {target: "Type", value: "(options: FetchResponseTransformOptions) => Promise<FetchResponseTransformResult<K, D>>"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchResponseTransformOptions
     * @property {number} status - response status number
     * @property {Object} headers - response headers object
     * @property {Object} body - response body
     * @ojsignature [
     *  {target: "Type", value: "Headers", for: "headers"},
     *  {target: "Type", value: "any", for: "body"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.FetchResponseTransformResult
     * @property {Array} data - fetched data
     * @property {Array=} keys - keys associated with fetched data. If keys is returned but not metadata,
     * the metadata will be generated from the keys
     * @property {Array=} metadata - metadata associated with fetched data. If metadata is returned
     * but not keys, the keys will be extracted from the metadata
     * @property {number=} totalSize - total number of rows available
     * @property {boolean=} hasMore - whether there are more rows available to be fetched
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "D[]", for: "data"},
     *  {target: "Type", value: "K[]", for: "keys"},
     *  {target: "Type", value: "ItemMetadata<K>[]", for: "metadata"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.RESTHelperResponse
     * @property {Array} data - fetched data
     * @property {Array=} keys - keys associated with fetched data. If keys is returned but not metadata,
     * the metadata will be generated from the keys
     * @property {Array=} metadata - metadata associated with fetched data. If metadata is returned
     * but not keys, the keys will be extracted from the metadata
     * @property {number=} totalSize - total number of rows available
     * @property {boolean=} hasMore - whether there are more rows available to be fetched
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "D[]", for: "data"},
     *  {target: "Type", value: "K[]", for: "keys"},
     *  {target: "Type", value: "ItemMetadata<K>[]", for: "metadata"}
     * ]
     */

    /**
     * @typedef {Object} RESTDataProvider.RESTHelperFetchByOffsetRequestOptions
     * @property {Object} options - Options passed in to RESTDataProvider
     * @property {Object} fetchParameters - FetchParams passed into the fetch call
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "RESTDataProvider.Options<K, D>", for: "options"},
     *  {target: "Type", value: "FetchByOffsetParameters<D>", for: "fetchParameters"}]
     */

    /**
     * @typedef {Object} RESTDataProvider.RESTHelperFetchByKeysRequestOptions
     * @property {Object} options - Options passed in to RESTDataProvider
     * @property {Object} fetchParameters - FetchParams passed into the fetch call
     * @ojsignature [
     *  {target: "Type", value: "<K, D>", for: "genericTypeParameters"},
     *  {target: "Type", value: "RESTDataProvider.Options<K, D>", for: "options"},
     *  {target: "Type", value: "FetchByKeysParameters<K>", for: "fetchParameters"}]
     */

    /**
     * @typedef {Object} RESTDataProvider.Capabilities
     * @property {FetchByKeysCapability=} fetchByKeys - Optional FetchByKeysCapability object. If not set or if the implementation is "iteration", fetchByKeys
     * calls will delegate to fetchFirst which is not efficient. If the implementation is "lookup", individual requests will be made for each key and then
     * combined. If the implementation is "batchLookup", a single request will be made for all keys. Please see {@link RESTDataProvider.Transforms}
     * for how requests should be transformed for fetchByKeys calls.
     * @property {FetchByOffsetCapability=} fetchByOffset - Optional FetchByOffsetCapability object. If not set or if the implementation is "iteration",
     * fetchByOffset calls will delegate to fetchFirst which is not efficient. When implementation is "randomAccess", data can be fetched from any offset
     * and in order and not just from sequentially from the beginning.
     * @property {FilterCapability=} filter - Optional FilterCapability object which specifies the type of filtering supported by the REST service.
     * @property {SortCapability=} sort - Optional SortCapability object which specifies the type of sorting supported by the REST service.
     * @ojsignature [
     *  {target: "Type", value: "FetchByKeysCapability", for: "fetchByKeys"},
     *  {target: "Type", value: "FetchByOffsetCapability", for: "fetchByOffset"},
     *  {target: "Type", value: "FilterCapability", for: "filter"},
     *  {target: "Type", value: "SortCapability", for: "sort"}
     * ]
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name containsKeys
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name createOptimizedKeySet
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name createOptimizedKeyMap
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name fetchFirst
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name fetchByKeys
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name fetchByOffset
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name getCapability
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name getTotalSize
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name isEmpty
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name addEventListener
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name removeEventListener
     */

    /**
     * @inheritdoc
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name dispatchEvent
     */

    /**
     * Triggers a "mutate" event, with the passed in mutation detail, for listening dataprovider consumers.
     * RESTDataProvider does not support CRUD operations and as such, applications are responsible for calling this
     * method when a change happens to notify consumers.
     *
     * @since 11.0.0
     * @param {DataProviderMutationEventDetail } detail - mutation detail
     * @export
     * @expose
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name mutate
     * @ojsignature {target: "Type",
     *               value: "(detail : DataProviderMutationEventDetail<K, D>) : void"}
     * @ojtsexample <caption>Trigger "mutate" event with passed in mutation detail</caption>
     * dataprovider.mutate({
     *   add: {
     *     data: [row],
     *     indexes: [rowIndex],
     *     keys: new Set([rowKey]),
     *     metadata: [{ key: rowKey }]
     *   }
     * });
     */

    /**
     * Triggers a "refresh" event for listening dataprovider consumers.
     *
     * @since 11.0.0
     * @export
     * @expose
     * @memberof RESTDataProvider
     * @instance
     * @method
     * @name refresh
     * @ojsignature {target: "Type",
     *               value: "() : void"}
     * @ojtsexample <caption>Trigger "refresh" event</caption>
     * dataprovider.refresh();
     */

    // end of jsdoc

    class RESTHelper {
        constructor(options) {
            this.options = options;
        }
        async fetch() {
            const request = await this._createRequest();
            const signal = this.options.fetchParameters.signal;
            let result;
            try {
                const response = await fetch(request, { signal: signal });
                result = await this._parseResponse(response);
            }
            catch (err) {
                if (this.options.errorHandler) {
                    const errorContext = {
                        fetchType: this.options.fetchType,
                        fetchParameters: this.options.fetchParameters,
                        options: this.options.options,
                        error: err
                    };
                    // JET-60386
                    Object.defineProperty(errorContext, 'err', {
                        get() {
                            return errorContext.error;
                        },
                        enumerable: true
                    });
                    this.options.errorHandler(errorContext);
                }
                throw err;
            }
            if (result.throwResponse) {
                throw result.throwResponse;
            }
            return result.fetchResponse;
        }
        async _createRequest() {
            const { url, transforms, fetchParameters, fetchType, fetchOptions } = this.options;
            const transform = transforms[fetchType].request;
            if (transform) {
                const transformOptions = ojmetadatautils.deepFreeze({ url, fetchParameters, fetchType, fetchOptions });
                return transform(transformOptions);
            }
            return new Request(url);
        }
        async _parseResponse(response) {
            const parsedResponse = {
                status: response.status,
                headers: response.headers,
                body: await this._getResponseBody(response)
            };
            if (!response.ok) {
                const errorContext = {
                    fetchType: this.options.fetchType,
                    fetchParameters: this.options.fetchParameters,
                    options: this.options.options,
                    response: parsedResponse
                };
                if (this.options.errorHandler) {
                    this.options.errorHandler(errorContext);
                }
                return { throwResponse: parsedResponse };
            }
            return { fetchResponse: await this._applyResponseTransforms(parsedResponse) };
        }
        async _getResponseBody(response) {
            try {
                return await response.json();
            }
            catch {
                return;
            }
        }
        async _applyResponseTransforms({ status, headers, body }) {
            const { transforms = {}, fetchType } = this.options;
            const transform = transforms[fetchType].response;
            let data;
            let keys;
            let metadata;
            let hasMore;
            let totalSize;
            if (transform) {
                const transformOptions = ojmetadatautils.deepFreeze({ status, headers, body });
                const transformResult = await transform(transformOptions);
                data = transformResult.data;
                keys = transformResult.keys;
                metadata = transformResult.metadata;
                hasMore = transformResult.hasMore;
                totalSize = transformResult.totalSize;
            }
            else if (body !== null && typeof body === 'object') {
                data = body.data;
                keys = body.keys;
                metadata = body.metadata;
                hasMore = body.hasMore;
                totalSize = body.totalSize;
            }
            if (!Array.isArray(data)) {
                throw '"data" should be an array. Please use the response transform to extract the data array from the response if needed.';
            }
            return {
                data,
                keys,
                metadata,
                hasMore,
                totalSize
            };
        }
    }

    const _SORT = 'sort';
    const _FILTER = 'filter';
    const _KEY = 'key';
    const _ATINDEX = '@index';
    const _FETCHBYKEYS = 'fetchByKeys';
    const _FETCHBYOFFSET = 'fetchByOffset';
    const _FETCHFIRST = 'fetchFirst';
    const _FETCHCAPABILITY = 'fetchCapability';
    const _BATCHLOOKUP = 'batchLookup';
    const _LOOKUP = 'lookup';
    const _DELAYED = 'delayed';
    const _RANDOMACCESS = 'randomAccess';
    const _DEFAULTFETCHSIZE = 25;
    class RESTDataProvider {
        constructor(options) {
            var _a;
            this.options = options;
            this._totalSize = -1;
            this._sequenceNum = 0;
            this._mapClientIdToProps = new Map();
            this.AsyncIterable = (_a = class {
                    constructor(_asyncIterator) {
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = function () {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            this.AsyncIterator = class {
                constructor(_parent, _nextFunc, _fetchParameters, _offset, _iterationLimit) {
                    this._parent = _parent;
                    this._nextFunc = _nextFunc;
                    this._fetchParameters = _fetchParameters;
                    this._offset = _offset;
                    this._iterationLimit = _iterationLimit;
                    this._rowsFetched = 0;
                    this._clientId = (_fetchParameters && _fetchParameters.clientId) || Symbol();
                    _parent._mapClientIdToProps.set(this._clientId, { hasMore: true, offset: _offset });
                }
                async next() {
                    const propObject = this._parent._mapClientIdToProps.get(this._clientId);
                    const cachedOffset = propObject.offset;
                    const hasMore = propObject.hasMore;
                    const { result, offset, hasNoMore } = await this._nextFunc(_FETCHFIRST, this._fetchParameters, cachedOffset, hasMore);
                    this._parent._mapClientIdToProps.set(this._clientId, {
                        hasMore: !hasNoMore,
                        offset: offset
                    });
                    const data = result.value.data;
                    this._rowsFetched += data.length;
                    if (Number.isInteger(this._iterationLimit) && this._rowsFetched >= this._iterationLimit) {
                        // at or past the iteration limit so force the iterator to be done
                        result.done = true;
                    }
                    return result;
                }
            };
            this.AsyncIteratorYieldResult = class {
                constructor(value) {
                    this.value = value;
                    this.done = false;
                }
            };
            this.AsyncIteratorReturnResult = class {
                constructor(value) {
                    this.value = value;
                    this.done = true;
                }
            };
            const capabilities = this._getCapabilitiesFromOptions();
            if (this.options.restHelper) {
                let shouldThrowError = false;
                if (capabilities.fetchByKeys != null && this.options.restHelper.fetchByKeys == null) {
                    shouldThrowError = true;
                }
                else if (capabilities.fetchByOffset != null &&
                    this.options.restHelper.fetchByOffset == null) {
                    shouldThrowError = true;
                }
                else if (this.options.restHelper.fetchFirst == null) {
                    shouldThrowError = true;
                }
                if (shouldThrowError) {
                    throw new Error('Rest Helper does not match capabilities');
                }
            }
        }
        fetchFirst(parameters) {
            return new this.AsyncIterable(new this.AsyncIterator(this, this._fetchFrom.bind(this), parameters, 0, this.options.iterationLimit));
        }
        async fetchByKeys(parameters) {
            if (!parameters) {
                throw Error('"keys" is a required parameter');
            }
            const capabilities = this._getCapabilitiesFromOptions();
            if (capabilities.fetchByKeys) {
                if (capabilities.fetchByKeys.implementation === _LOOKUP) {
                    return this._fetchByKeysLookup(parameters);
                }
                if (capabilities.fetchByKeys.implementation === _BATCHLOOKUP) {
                    return this._fetchByKeysBatchLookup(parameters);
                }
            }
            return this._fetchByKeysIteration(parameters);
        }
        async fetchByOffset(parameters) {
            if (!parameters) {
                throw Error('"offset" is a required parameter');
            }
            const offset = parameters.offset > 0 ? parameters.offset : 0;
            const capabilities = this._getCapabilitiesFromOptions();
            if (capabilities.fetchByOffset && capabilities.fetchByOffset.implementation === _RANDOMACCESS) {
                return this._fetchByOffsetRandomAccess(parameters, offset);
            }
            return this._fetchByOffsetIteration(parameters, offset);
        }
        async containsKeys(parameters) {
            const results = new ojSet();
            const fetchByKeysResults = await this.fetchByKeys(parameters);
            parameters.keys.forEach((key) => {
                if (fetchByKeysResults.results.get(key) != null) {
                    results.add(key);
                }
            });
            return { containsParameters: parameters, results };
        }
        createOptimizedKeySet(initialSet) {
            return initialSet ? new ojSet(initialSet) : new ojSet();
        }
        createOptimizedKeyMap(initialMap) {
            return initialMap ? new ojMap(initialMap) : new ojMap();
        }
        isEmpty() {
            // this is consistent with ServiceDataProvider. since we never store the returned
            // data, we can only determine if there is any data available after the fetch.
            // i.e we don't have access to previously fetched data and there is no guarantee
            // that it is available on the REST endpoint
            return 'unknown';
        }
        getCapability(capabilityName) {
            const capabilities = this._getCapabilitiesFromOptions();
            switch (capabilityName) {
                case _SORT:
                    return capabilities.sort;
                case _FILTER:
                    return capabilities.filter;
                case _KEY:
                    return capabilities.key;
                case _FETCHFIRST:
                    return this._getFetchCapability(_FETCHFIRST);
                case _FETCHBYKEYS:
                    return this._getFetchCapability(_FETCHBYKEYS);
                case _FETCHBYOFFSET:
                    return this._getFetchCapability(_FETCHBYOFFSET);
                case _FETCHCAPABILITY:
                    return RESTDataProvider._getFetchCapabilityDefaults();
                default:
                    return;
            }
        }
        getTotalSize() {
            return Promise.resolve(this._totalSize);
        }
        refresh() {
            this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
        }
        mutate(detail) {
            const { add, remove } = detail;
            this._adjustIteratorOffset(remove, add);
            this.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(detail));
        }
        async _fetchFrom(fetchType, fetchParameters = {}, offset, hasMore) {
            const { signal } = fetchParameters;
            const callback = async (resolve, reject) => {
                if (hasMore) {
                    const convertedFetchParameters = this._convertFetchListToFetchByOffsetParameters(fetchParameters, offset);
                    const fetchSize = this._getFetchSize(convertedFetchParameters);
                    const fullFetchParameters = {
                        ...convertedFetchParameters,
                        size: fetchSize,
                        filterCriterion: ojdataprovider.FilterFactory.getFilter({
                            filterDef: convertedFetchParameters.filterCriterion,
                            filterOptions: this.options
                        })
                    };
                    ojdataprovider.FilterUtils.validateFilterCapabilities(this.getCapability('filter'), fullFetchParameters.filterCriterion);
                    let fetchResult;
                    if (!this.options.restHelper) {
                        const restHelper = new RESTHelper({
                            fetchType,
                            fetchParameters: fullFetchParameters,
                            url: this.options.url,
                            transforms: this.options.transforms,
                            fetchOptions: {
                                textFilterAttributes: this.options.textFilterAttributes
                            },
                            errorHandler: this.options.error,
                            options: this.options
                        });
                        fetchResult = await restHelper.fetch();
                    }
                    else {
                        const restHelperCallback = this.options.restHelper[fetchType];
                        if (!restHelperCallback) {
                            throw new Error(`Rest Helper does not match capabilities: ${fetchType}`);
                        }
                        fetchResult = await restHelperCallback({
                            options: this.options,
                            fetchParameters: fullFetchParameters
                        });
                    }
                    const { data, totalSize, hasMore } = fetchResult;
                    let metadata = this._getFetchResultMetaData(fetchResult);
                    const mergedSortCriteria = this._mergeSortCriteria(fetchParameters.sortCriteria);
                    if (mergedSortCriteria) {
                        fetchParameters = { ...fetchParameters, sortCriteria: mergedSortCriteria };
                    }
                    const result = { fetchParameters, data, metadata };
                    if (Number.isInteger(totalSize) && this._totalSize !== totalSize) {
                        this._totalSize = totalSize;
                    }
                    if (typeof hasMore === 'boolean' && (hasMore || data.length > 0)) {
                        return resolve({
                            result: new this.AsyncIteratorYieldResult(result),
                            offset: offset + data.length,
                            hasNoMore: !hasMore
                        });
                    }
                    return resolve({
                        result: new this.AsyncIteratorReturnResult(result),
                        offset: offset + data.length,
                        hasNoMore: !hasMore
                    });
                }
                return resolve({
                    result: new this.AsyncIteratorReturnResult({ fetchParameters: fetchParameters, data: [], metadata: [] }),
                    offset: offset,
                    hasNoMore: true
                });
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, true);
        }
        async _fetchByKeysIteration(fetchParameters) {
            const fetchListParameters = this._convertFetchByKeysToFetchListParameters(fetchParameters);
            const asyncIterator = this.fetchFirst(fetchListParameters)[Symbol.asyncIterator]();
            const fetchedData = [];
            const fetchedDataMetadata = [];
            let done = false;
            while (!done) {
                const fetchResult = await asyncIterator.next();
                const { data, metadata } = fetchResult.value;
                metadata.forEach((entry, index) => {
                    if (fetchParameters.keys.has(entry.key)) {
                        fetchedData.push(data[index]);
                        fetchedDataMetadata.push(entry);
                    }
                });
                if (fetchParameters.keys.size === fetchedDataMetadata.length) {
                    done = true;
                }
                else {
                    done = fetchResult.done;
                }
            }
            return this._createFetchByKeysResults(fetchParameters, fetchedData, fetchedDataMetadata);
        }
        async _fetchByKeysLookup(fetchParameters) {
            const { signal } = fetchParameters;
            const callback = async (resolve, reject) => {
                const fetchPromises = [];
                const fetchedData = [];
                let fetchedDataMetadata = [];
                for (let key of fetchParameters.keys) {
                    if (!this.options.restHelper) {
                        const restHelper = new RESTHelper({
                            fetchType: _FETCHBYKEYS,
                            fetchParameters: {
                                ...fetchParameters,
                                keys: new Set([key])
                            },
                            url: this.options.url,
                            transforms: this.options.transforms,
                            errorHandler: this.options.error,
                            options: this.options
                        });
                        fetchPromises.push(restHelper.fetch());
                    }
                    else {
                        const restHelperCallback = this.options.restHelper.fetchByKeys;
                        if (!restHelperCallback) {
                            throw new Error(`Rest Helper does not match capabilities: ${_FETCHBYKEYS}`);
                        }
                        fetchPromises.push(restHelperCallback({
                            options: this.options,
                            fetchParameters: {
                                ...fetchParameters,
                                keys: new Set([key])
                            }
                        }));
                    }
                }
                (await Promise.all(fetchPromises)).forEach((fetchResult) => {
                    fetchResult.data.forEach((item) => {
                        fetchedData.push(item);
                    });
                    const metadata = this._getFetchResultMetaData(fetchResult);
                    metadata.forEach((entry) => {
                        fetchedDataMetadata.push(entry);
                    });
                });
                return resolve(this._createFetchByKeysResults(fetchParameters, fetchedData, fetchedDataMetadata));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, true);
        }
        async _fetchByKeysBatchLookup(fetchParameters) {
            const { signal } = fetchParameters;
            const callback = async (resolve, reject) => {
                let fetchResult;
                if (!this.options.restHelper) {
                    const restHelper = new RESTHelper({
                        fetchType: _FETCHBYKEYS,
                        fetchParameters,
                        url: this.options.url,
                        transforms: this.options.transforms,
                        errorHandler: this.options.error,
                        options: this.options
                    });
                    fetchResult = await restHelper.fetch();
                }
                else {
                    const restHelperCallback = this.options.restHelper.fetchByKeys;
                    if (!restHelperCallback) {
                        throw new Error(`Rest Helper does not match capabilities: ${_FETCHBYKEYS}`);
                    }
                    fetchResult = await restHelperCallback({
                        options: this.options,
                        fetchParameters: fetchParameters
                    });
                }
                const metadata = this._getFetchResultMetaData(fetchResult);
                return resolve(this._createFetchByKeysResults(fetchParameters, fetchResult.data, metadata));
            };
            return ojdataprovider.wrapWithAbortHandling(signal, callback, true);
        }
        async _fetchByOffsetRandomAccess(fetchParameters, offset) {
            const fetchResult = await this._fetchFrom(_FETCHBYOFFSET, this._convertFetchByOffsetToFetchListParameters(fetchParameters), offset, true);
            if (fetchResult.hasNoMore) {
                fetchResult.result.done = true;
            }
            const { value, done } = fetchResult.result;
            const { data, metadata } = value;
            const results = data.map((value, index) => ({ metadata: metadata[index], data: value }));
            const mergedSortCriteria = this._mergeSortCriteria(fetchParameters.sortCriteria);
            if (mergedSortCriteria) {
                fetchParameters = { ...fetchParameters, sortCriteria: mergedSortCriteria };
            }
            return { fetchParameters, results, done };
        }
        async _fetchByOffsetIteration(fetchParameters, offset) {
            const fetchListParameters = this._convertFetchByOffsetToFetchListParameters(fetchParameters);
            const asyncIterator = this.fetchFirst(fetchListParameters)[Symbol.asyncIterator]();
            const fetchResultData = [];
            const fetchResultMetadata = [];
            const size = this._getFetchSize(fetchParameters);
            let done = false;
            let fetchResultDone = true;
            while (!done) {
                const fetchResult = await asyncIterator.next();
                const value = fetchResult.value;
                const { data, metadata } = value;
                fetchResultDone = fetchResult.done;
                data.forEach((entry) => {
                    fetchResultData.push(entry);
                });
                metadata.forEach((entry) => {
                    fetchResultMetadata.push(entry);
                });
                if (typeof fetchResultData[offset + size - 1] !== 'undefined') {
                    // stop iterating when we have fetched the data we need
                    done = true;
                }
                else {
                    done = fetchResultDone;
                }
            }
            const start = offset;
            const end = offset + size;
            const data = fetchResultData.slice(start, end);
            const metadata = fetchResultMetadata.slice(start, end);
            const results = data.map((value, index) => ({ metadata: metadata[index], data: value }));
            const mergedSortCriteria = this._mergeSortCriteria(fetchParameters.sortCriteria);
            if (mergedSortCriteria) {
                fetchParameters = { ...fetchParameters, sortCriteria: mergedSortCriteria };
            }
            return { fetchParameters, results, done: fetchResultDone };
        }
        _generateKeysFromData(data) {
            const keyAttributes = this.options != null ? this.options.keyAttributes : null;
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            return data.map((item) => {
                let id = this._getId(item);
                if (id == null || keyAttributes == _ATINDEX) {
                    id =
                        enforceKeyStringify === 'on' ? JSON.stringify(this._sequenceNum++) : this._sequenceNum++;
                }
                return id;
            });
        }
        _generateMetadataFromKeys(keys) {
            return keys.map((key) => ({ key }));
        }
        _getId(row) {
            let id;
            let keyAttributes = null;
            if (this.options != null) {
                if (this.options.keyAttributes != null) {
                    keyAttributes = this.options.keyAttributes;
                }
            }
            if (keyAttributes != null) {
                if (Array.isArray(keyAttributes)) {
                    let i;
                    id = [];
                    for (i = 0; i < keyAttributes.length; i++) {
                        id[i] = this._getVal(row, keyAttributes[i]);
                    }
                }
                else {
                    id = this._getVal(row, keyAttributes);
                }
                return id;
            }
            else {
                return null;
            }
        }
        _getVal(val, attr) {
            const dotIndex = attr.indexOf('.');
            if (dotIndex > 0) {
                const startAttr = attr.substring(0, dotIndex);
                const endAttr = attr.substring(dotIndex + 1);
                const subObj = val[startAttr];
                if (subObj) {
                    return this._getVal(subObj, endAttr);
                }
            }
            if (typeof val[attr] == 'function') {
                return val[attr]();
            }
            return val[attr];
        }
        _convertFetchByOffsetToFetchListParameters(fetchParameters) {
            return {
                size: fetchParameters.size,
                sortCriteria: fetchParameters.sortCriteria,
                filterCriterion: fetchParameters.filterCriterion,
                attributes: fetchParameters.attributes,
                clientId: fetchParameters.clientId,
                signal: fetchParameters.signal
            };
        }
        _convertFetchListToFetchByOffsetParameters(fetchParameters, offset) {
            return {
                offset,
                size: fetchParameters.size,
                sortCriteria: fetchParameters.sortCriteria,
                filterCriterion: fetchParameters.filterCriterion,
                attributes: fetchParameters.attributes,
                clientId: fetchParameters.clientId,
                signal: fetchParameters.signal
            };
        }
        _convertFetchByKeysToFetchListParameters(fetchParameters) {
            return {
                attributes: fetchParameters.attributes,
                signal: fetchParameters.signal
            };
        }
        _createFetchByKeysResults(fetchParameters, fetchedData, fetchedDataMetadata) {
            const results = new Map();
            fetchedData.forEach((value, index) => {
                if (value) {
                    results.set(fetchedDataMetadata[index].key, {
                        metadata: fetchedDataMetadata[index],
                        data: value
                    });
                }
            });
            return { fetchParameters, results };
        }
        _getFetchCapability(fetchType) {
            const capabilities = this._getCapabilitiesFromOptions();
            const fetchCapabilityDefaults = RESTDataProvider._getFetchCapabilityDefaults();
            if (fetchType === _FETCHFIRST) {
                return { ...fetchCapabilityDefaults, iterationSpeed: _DELAYED };
            }
            return capabilities[fetchType]
                ? { ...fetchCapabilityDefaults, ...(capabilities[fetchType] || {}) }
                : null;
        }
        static _getFetchCapabilityDefaults() {
            return {
                caching: 'none',
                attributeFilter: {
                    expansion: {},
                    ordering: {},
                    defaultShape: {
                        features: new Set(['exclusion'])
                    }
                }
            };
        }
        _getCapabilitiesFromOptions() {
            return this.options.capabilities || {};
        }
        _getFetchSize(fetchParameters) {
            return Number.isInteger(fetchParameters.size) && fetchParameters.size > 0
                ? fetchParameters.size
                : _DEFAULTFETCHSIZE;
        }
        _mergeSortCriteria(sortCriteria) {
            const implicitSort = this.options != null ? this.options.implicitSort : null;
            if (implicitSort != null) {
                if (sortCriteria == null) {
                    return implicitSort;
                }
                // merge
                const mergedSortCriteria = sortCriteria.slice(0);
                let i, j, found;
                for (i = 0; i < implicitSort.length; i++) {
                    found = false;
                    for (j = 0; j < mergedSortCriteria.length; j++) {
                        if (mergedSortCriteria[j].attribute == implicitSort[i].attribute) {
                            found = true;
                        }
                    }
                    if (!found) {
                        mergedSortCriteria.push(implicitSort[i]);
                    }
                }
                return mergedSortCriteria;
            }
            else {
                return sortCriteria;
            }
        }
        _getFetchResultMetaData(fetchResult) {
            const keys = fetchResult.keys || this._generateKeysFromData(fetchResult.data);
            let metadata = fetchResult.metadata || this._generateMetadataFromKeys(keys);
            const enforceKeyStringify = this.options?.enforceKeyStringify;
            metadata = metadata.map((entry) => {
                let metadataObj = { ...entry };
                if (enforceKeyStringify === 'on') {
                    metadataObj.key = JSON.stringify(metadataObj.key);
                }
                return metadataObj;
            });
            return metadata;
        }
        _adjustIteratorOffset(remove, add) {
            const removeIndexes = remove ? remove.indexes : null;
            const addIndexes = add ? add.indexes : null;
            this._mapClientIdToProps.forEach((propObject, clientId) => {
                let offset = propObject.offset;
                let deleteCount = 0;
                if (removeIndexes) {
                    removeIndexes.forEach(function (index) {
                        if (index < offset) {
                            ++deleteCount;
                        }
                    });
                }
                offset -= deleteCount;
                let resetHasMore = false;
                if (addIndexes) {
                    addIndexes.forEach(function (index) {
                        if (index < offset) {
                            ++offset;
                        }
                        else {
                            resetHasMore = true;
                        }
                    });
                }
                if (resetHasMore) {
                    this._mapClientIdToProps.set(clientId, { hasMore: true, offset: offset });
                }
                else {
                    this._mapClientIdToProps.set(clientId, { hasMore: propObject.hasMore, offset: offset });
                }
            });
        }
    }
    ojeventtarget.EventTargetMixin.applyMixin(RESTDataProvider);

    exports.RESTDataProvider = RESTDataProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojresttreedataprovider',['exports', 'ojs/ojeventtarget', 'ojs/ojrestdataprovider', 'ojs/ojdataprovider', 'ojs/ojset', 'ojs/ojmap'], function (exports, ojeventtarget, ojrestdataprovider, ojdataprovider, ojSet, ojMap) { 'use strict';

    ojSet = ojSet && Object.prototype.hasOwnProperty.call(ojSet, 'default') ? ojSet['default'] : ojSet;
    ojMap = ojMap && Object.prototype.hasOwnProperty.call(ojMap, 'default') ? ojMap['default'] : ojMap;

    class RESTTreeDataProvider {
        constructor(options) {
            var _a;
            this.options = options;
            this.TreeAsyncIterator = class {
                constructor(_rootDataProvider, _baseIterable, currentRestTreeDataProvider, _shouldKeyPath, _shouldStringify) {
                    this._rootDataProvider = _rootDataProvider;
                    this._baseIterable = _baseIterable;
                    this.currentRestTreeDataProvider = currentRestTreeDataProvider;
                    this._shouldKeyPath = _shouldKeyPath;
                    this._shouldStringify = _shouldStringify;
                }
                async next() {
                    const result = await this._baseIterable[Symbol.asyncIterator]().next();
                    for (let i = 0; i < result.value.data.length; i++) {
                        let tempKey = result.value.metadata[i].key;
                        if (this._shouldKeyPath) {
                            tempKey = this.currentRestTreeDataProvider.createKeyPath(result.value.metadata[i].key);
                        }
                        if (this._shouldStringify) {
                            tempKey = JSON.stringify(tempKey);
                        }
                        result.value.metadata[i].key = tempKey;
                        this._rootDataProvider._setMapEntry(tempKey, {
                            data: result.value.data[i],
                            metadata: result.value.metadata[i]
                        });
                    }
                    return result;
                }
            };
            this.TreeAsyncIterable = (_a = class {
                    constructor(_asyncIterator) {
                        this._asyncIterator = _asyncIterator;
                        this[Symbol.asyncIterator] = () => {
                            return this._asyncIterator;
                        };
                    }
                },
                Symbol.asyncIterator,
                _a);
            const baseDPOptions = { ...options, enforceKeyStringify: 'off' };
            this._baseDataProvider = new ojrestdataprovider.RESTDataProvider(baseDPOptions);
            // This map is used as an internal cache to look up the Item<K,D> corresponding to a node by
            // its key. It is needed in order to pass an item to options.getChildDataProvider, the goal
            // being to provide applications as much information as possible in order to return a child
            // data provider or null. Item<K,D> values have a "data" field containing the node and a "metadata"
            // field containing the metadata of the node such as whether it is a leaf. The "metadata" can be populated
            // from the REST endpoint via the response fetch response.
            // This map is available on every RESTTreeDataProvider but only populated and updated on the
            // root / top-level RESTTreeDataProvider (see _getRootDataProvider) in order to have a single
            // source of truth. In a future version, we should provide a public interface for
            // accessing the map instead of allowing child data providers to access the root data providers
            // private properties
            this._mapKeyToItem = new ojMap();
        }
        _shouldKeyPath() {
            const options = this._getRootDataProvider().options;
            return options?.useKeyPaths === 'on';
        }
        _shouldStringify() {
            const options = this._getRootDataProvider().options;
            return options?.enforceKeyStringify === 'on';
        }
        _getParentPath() {
            return this.options.rootDataProvider ? this[Symbol.for('parentKey')] : [];
        }
        createKeyPath(key) {
            return [...this._getParentPath(), key];
        }
        fetchFirst(fetchParameters) {
            const baseIterable = this._baseDataProvider.fetchFirst(fetchParameters);
            const rootDataProvider = this._getRootDataProvider();
            return new this.TreeAsyncIterable(new this.TreeAsyncIterator(rootDataProvider, baseIterable, this, this._shouldKeyPath(), this._shouldStringify()));
        }
        isKeyPathDescendant(keyPath) {
            const parentKeyPath = this._getParentPath();
            if (parentKeyPath.length >= keyPath.length) {
                return false;
            }
            for (let i = 0; i < parentKeyPath.length; i++) {
                if (parentKeyPath[i] !== keyPath[i]) {
                    return false;
                }
            }
            return true;
        }
        async fetchByKeys(parameters) {
            const unCachedKeys = new Set();
            const results = new Map();
            const shouldKeyPath = this._shouldKeyPath();
            parameters.keys.forEach((currentKey) => {
                let key = currentKey;
                const item = this._getItemFromKey(key);
                if (item) {
                    if (!shouldKeyPath || (shouldKeyPath && this.isKeyPathDescendant(key))) {
                        results.set(key, item);
                    }
                }
                else {
                    if (this._shouldStringify()) {
                        key = JSON.parse(currentKey);
                    }
                    unCachedKeys.add(key);
                }
            });
            if (unCachedKeys.size) {
                if (shouldKeyPath) {
                    for (const key of unCachedKeys) {
                        const findResults = await this.findKeys(key.slice(), key.slice(), parameters, this);
                        const item = findResults.fetchByKeysResults.results.get(findResults.lastKey);
                        if (item) {
                            let tempKey = key;
                            if (this._shouldStringify()) {
                                tempKey = JSON.stringify(key);
                            }
                            const updatedItem = {
                                data: item.data,
                                metadata: { ...item.metadata, key: tempKey }
                            };
                            this._setMapEntry(tempKey, updatedItem);
                            results.set(tempKey, updatedItem);
                        }
                    }
                }
                else {
                    const fetchByKeysResult = await this._baseDataProvider.fetchByKeys({
                        ...parameters,
                        keys: unCachedKeys
                    });
                    fetchByKeysResult.results.forEach((item) => {
                        let tempKey = item.metadata.key;
                        if (this._shouldStringify()) {
                            tempKey = JSON.stringify(tempKey);
                        }
                        const updatedItem = {
                            data: item.data,
                            metadata: { ...item.metadata, key: tempKey }
                        };
                        this._setMapEntry(tempKey, updatedItem);
                        results.set(tempKey, updatedItem);
                    });
                }
            }
            return {
                fetchParameters: parameters,
                results
            };
        }
        async findKeys(currentKeyPath, originalKeyPath, params, dataProvider) {
            if (currentKeyPath.length === 1) {
                let lastKey = currentKeyPath[0];
                const convertedFetchParameters = { ...params };
                convertedFetchParameters.keys = new Set();
                convertedFetchParameters.keys.add(lastKey);
                return {
                    fetchByKeysResults: await dataProvider._baseDataProvider.fetchByKeys(convertedFetchParameters),
                    lastKey: lastKey
                };
            }
            else {
                let firstKey = [currentKeyPath.shift()];
                const firstItem = this._getItemFromKey(firstKey);
                let childDataProvider;
                if (firstItem) {
                    childDataProvider = dataProvider.getChildDataProvider(firstKey);
                }
                else {
                    firstKey = firstKey[0];
                    const newFetchParameters = { ...params };
                    newFetchParameters.keys = new Set();
                    newFetchParameters.keys.add(firstKey);
                    const fetchByKeysResults = await dataProvider._baseDataProvider.fetchByKeys(newFetchParameters);
                    if (fetchByKeysResults.results.size > 0) {
                        const indexOfKey = originalKeyPath.indexOf(firstKey);
                        const keyPath = originalKeyPath.slice(0, indexOfKey + 1);
                        fetchByKeysResults.results.forEach((value) => {
                            const item = {
                                data: value.data,
                                metadata: { ...value.metadata, key: keyPath }
                            };
                            this._setMapEntry(keyPath, item);
                        });
                        childDataProvider = dataProvider.getChildDataProvider(keyPath);
                    }
                }
                if (childDataProvider) {
                    return this.findKeys(currentKeyPath, originalKeyPath, params, childDataProvider);
                }
                else {
                    return null;
                }
            }
        }
        async fetchByOffset(parameters) {
            const fetchByOffsetResult = await this._baseDataProvider.fetchByOffset(parameters);
            const newOffsetResults = { ...fetchByOffsetResult };
            newOffsetResults.results = [];
            fetchByOffsetResult.results.forEach((item) => {
                let tempKey = item.metadata.key;
                if (this._shouldKeyPath()) {
                    tempKey = this.createKeyPath(item.metadata.key);
                }
                if (this._shouldStringify()) {
                    tempKey = JSON.stringify(tempKey);
                }
                const updatedItem = {
                    data: item.data,
                    metadata: { ...item.metadata, key: tempKey }
                };
                newOffsetResults.results.push(updatedItem);
                this._setMapEntry(tempKey, updatedItem);
            });
            return newOffsetResults;
        }
        async containsKeys(fetchParameters) {
            if (this._shouldKeyPath()) {
                const results = new ojSet();
                const fetchByKeysResults = await this.fetchByKeys(fetchParameters);
                fetchParameters.keys.forEach((key) => {
                    if (fetchByKeysResults.results.get(key) != null) {
                        results.add(key);
                    }
                });
                return { containsParameters: fetchParameters, results };
            }
            if (this._shouldStringify()) {
                const results = new ojSet();
                const newFetchParameters = { ...fetchParameters };
                if (this._shouldStringify()) {
                    newFetchParameters.keys = new Set();
                    fetchParameters.keys.forEach((key) => {
                        newFetchParameters.keys.add(JSON.parse(key));
                    });
                }
                const containsResults = await this._baseDataProvider.containsKeys(newFetchParameters);
                fetchParameters.keys.forEach((key) => {
                    if (containsResults.results.has(JSON.parse(key))) {
                        results.add(key);
                    }
                });
                return { containsParameters: fetchParameters, results };
            }
            return this._baseDataProvider.containsKeys(fetchParameters);
        }
        createOptimizedKeySet(initialSet) {
            return this._baseDataProvider.createOptimizedKeySet(initialSet);
        }
        createOptimizedKeyMap(initialMap) {
            return this._baseDataProvider.createOptimizedKeyMap(initialMap);
        }
        isEmpty() {
            return this._baseDataProvider.isEmpty();
        }
        getCapability(capabilityName) {
            if (capabilityName === 'key') {
                if (this._shouldKeyPath()) {
                    if (this._shouldStringify()) {
                        return { structure: 'pathArrayString' };
                    }
                    return { structure: 'pathArray' };
                }
                return { structure: 'none' };
            }
            return this._baseDataProvider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this._baseDataProvider.getTotalSize();
        }
        refresh() {
            this._flushMaps();
            this.dispatchEvent(new ojdataprovider.DataProviderRefreshEvent());
        }
        mutate(detail) {
            this._addMetadataToMutationEventDetail(detail);
            if (detail.remove) {
                this._updateMapFromMutationDetail('remove', detail.remove);
            }
            if (detail.add) {
                this._updateMapFromMutationDetail('add', detail.add);
            }
            if (detail.update) {
                this._updateMapFromMutationDetail('update', detail.update);
            }
            this._baseDataProvider.mutate(detail);
            this.dispatchEvent(new ojdataprovider.DataProviderMutationEvent(detail));
        }
        getChildDataProvider(key) {
            const item = this._getItemFromKey(key);
            const dataprovider = this.options.getChildDataProvider(item);
            if (!dataprovider) {
                return null;
            }
            const treeDataProvider = ojdataprovider.DataProviderFeatureChecker.isTreeDataProvider(dataprovider)
                ? dataprovider
                : new TreeDataProviderWrapper(dataprovider);
            if (this._shouldKeyPath()) {
                treeDataProvider[Symbol.for('parentKey')] = key;
            }
            return treeDataProvider;
        }
        _getItemFromKey(key) {
            const rootDataProvider = this._getRootDataProvider();
            return rootDataProvider._mapKeyToItem.get(key);
        }
        _setMapEntry(key, item) {
            const rootDataProvider = this._getRootDataProvider();
            const currentValue = rootDataProvider._mapKeyToItem.get(key);
            if (currentValue) {
                rootDataProvider._mapKeyToItem.set(key, {
                    data: { ...currentValue.data, ...item.data },
                    metadata: { ...currentValue.metadata, ...item.metadata }
                });
            }
            else {
                rootDataProvider._mapKeyToItem.set(key, item);
            }
        }
        _deleteMapEntry(key) {
            const rootDataProvider = this._getRootDataProvider();
            rootDataProvider._mapKeyToItem.delete(key);
        }
        _flushMaps() {
            const rootDataProvider = this._getRootDataProvider();
            rootDataProvider._mapKeyToItem.clear();
        }
        _getRootDataProvider() {
            if (this.options.rootDataProvider) {
                return this.options.rootDataProvider;
            }
            return this;
        }
        _addMetadataToMutationEventDetail(detail) {
            Object.keys(detail).forEach((operation) => {
                if (!detail[operation].metadata ||
                    (detail[operation].metadata && !detail[operation].metadata.length)) {
                    detail[operation].metadata = [];
                    detail[operation].keys.forEach((key) => {
                        detail[operation].metadata.push({ key });
                    });
                }
            });
        }
        _updateMapFromMutationDetail(operation, detail) {
            if (operation === 'remove') {
                detail.keys.forEach((key) => {
                    this._deleteMapEntry(key);
                });
            }
            else {
                const data = detail.data;
                const metadata = detail.metadata;
                if (Array.isArray(data) && Array.isArray(metadata)) {
                    for (let i = 0; i < data.length; i++) {
                        this._setMapEntry(metadata[i].key, { data: data[i], metadata: metadata[i] });
                    }
                }
                else if (Array.isArray(metadata)) {
                    for (let i = 0; i < metadata.length; i++) {
                        const item = this._getItemFromKey(metadata[i].key);
                        if (item) {
                            this._setMapEntry(metadata[i].key, { data: item.data, metadata: metadata[i] });
                        }
                    }
                }
            }
        }
    }
    class TreeDataProviderWrapper {
        constructor(dataprovider) {
            this.dataprovider = dataprovider;
        }
        fetchFirst(parameters) {
            return this.dataprovider.fetchFirst(parameters);
        }
        async fetchByKeys(fetchParameters) {
            return this.dataprovider.fetchByKeys(fetchParameters);
        }
        async fetchByOffset(fetchParameters) {
            return this.dataprovider.fetchByOffset(fetchParameters);
        }
        async containsKeys(parameters) {
            return this.dataprovider.containsKeys(parameters);
        }
        createOptimizedKeySet(initialSet) {
            return this.dataprovider.createOptimizedKeySet(initialSet);
        }
        createOptimizedKeyMap(initialMap) {
            return this.dataprovider.createOptimizedKeyMap(initialMap);
        }
        isEmpty() {
            // DataProvider contract specifies that isEmpty returns
            // 'string' so 'yes' | 'no' | 'unknown' is not accepted by Typescript
            const isEmpty = this.dataprovider.isEmpty();
            if (isEmpty === 'yes') {
                return 'yes';
            }
            else if (isEmpty === 'no') {
                return 'no';
            }
            return 'unknown';
        }
        getCapability(capabilityName) {
            return this.dataprovider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this.dataprovider.getTotalSize();
        }
        getChildDataProvider(_key) {
            return null;
        }
        addEventListener(event, listener) {
            this.dataprovider.addEventListener(event, listener);
        }
        removeEventListener(event, listener) {
            this.dataprovider.removeEventListener(event, listener);
        }
        dispatchEvent(event) {
            return this.dataprovider.dispatchEvent(event);
        }
    }
    ojeventtarget.EventTargetMixin.applyMixin(RESTTreeDataProvider);

    exports.RESTTreeDataProvider = RESTTreeDataProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdebouncingdataproviderview',['exports', 'ojs/ojdataprovider'], function (exports, ojdataprovider) { 'use strict';

    /**
     * Helper class for debouncing fetch requests.
     */
    class Debouncer {
        constructor() {
            // The algorithm will calculate the debounce time as follows:
            // debounceTime = (1 + (responseTime - 1.2 * requestTime) / responseTime) * 1.2 * requestTime
            //
            // Rewriting to solve for response time:
            // debounceTime = (2 - 1.2 * requestTime / responseTime) * 1.2 * requestTime
            // debounceTime * responseTime / (1.2 * requestTime) = 2 * responseTime - 1.2 * requestTime
            // responseTime = 1.2 * requestTime / (2 - debounceTime / (1.2 * requestTime))
            //
            // We want our default debounce times to start out higher for fewer characters typed and
            // decrease as the number of characters increases, so we will define our default
            // buckets of response times based on some of these example calculations.
            // (We don't want the default response time to be less than 1.2 * default requestTime (250),
            // because then the logic will use a debounce time of 0 because the response is expected to
            // return before the user types again.)
            // debounce | request | response
            // ---------|---------|---------
            //  500     | 250     | 900
            //  475     | 250     | 720
            //  450     | 250     | 600
            //  425     | 250     | 514
            //  400     | 250     | 450
            //  375     | 250     | 400
            //  350     | 250     | 360
            //  325     | 250     | 327
            //  300     | 250     | 300
            this._responseTimes = [
                { time: 900, count: 0 },
                { time: 720, count: 0 },
                { time: 600, count: 0 },
                { time: 450, count: 0 },
                { time: 360, count: 0 },
                { time: 300, count: 0 }
            ];
            this._requestTime = { time: 250, count: 0 };
            this._lastRequestTime = 0;
        }
        /**
         * Debounce a given function by the specified time.
         * @param callback function to debounce
         * @param filterTextLength text filter length
         * @returns debounced function
         */
        debounce(callback, filterTextLength) {
            const wait = this.GetDebounceTime(filterTextLength);
            return (...args) => {
                window.setTimeout(() => {
                    callback(...args);
                }, wait);
            };
        }
        /**
         * Record the time between a fetch request and response.
         * @param time fetch time in ms
         * @param filterTextLength length of the text filter for the fetch
         */
        recordResponseTime(time, filterTextLength) {
            const index = Math.min(filterTextLength, 5);
            const record = this._responseTimes[index];
            // if this is the first recorded time, overwrite our initial default;
            // otherwise calculate the new average
            if (record.count === 0) {
                record.time = time;
            }
            else {
                record.time = (record.time * record.count + time) / (record.count + 1);
            }
            record.count += 1;
        }
        /**
         * Record the time of a fetch request.
         */
        recordRequestTime() {
            const requestTime = Date.now();
            const lastRequestTime = this._lastRequestTime;
            this._lastRequestTime = requestTime;
            // we need two requests in order to record the time between them, so if this is the
            // very first request, just return
            if (lastRequestTime === 0) {
                return;
            }
            const time = requestTime - lastRequestTime;
            // assume that intervals greater than 1000ms are the start of a new search, so do not
            // factor into the average request time
            if (time > 1000) {
                return;
            }
            const record = this._requestTime;
            // if this is the first recorded time, overwrite our initial default;
            // otherwise calculate the new average
            if (record.count === 0) {
                record.time = time;
            }
            else {
                record.time = (record.time * record.count + time) / (record.count + 1);
            }
            record.count += 1;
        }
        /**
         * Get the average response time for a given text filter length.
         * @param filterTextLength length of the text filter
         * @returns average response time in ms
         */
        _getResponseTime(filterTextLength) {
            const index = Math.min(filterTextLength, 5);
            const record = this._responseTimes[index];
            return record.time;
        }
        /**
         * Get the average request time.
         * @returns average request time in ms
         */
        _getRequestTime() {
            return this._requestTime.time;
        }
        /**
         * Get the time to use for debouncing based on the text filter length, the average
         * time between requests, and the average response time.
         * @param filterTextLength text filter length
         * @returns debounce time in ms
         */
        GetDebounceTime(filterTextLength) {
            const responseTime = this._getResponseTime(filterTextLength);
            const requestTime = this._getRequestTime();
            // the request time is an average of how fast the user types, so assume any given time may
            // be a little longer than the average
            const paddedRequestTime = 1.2 * requestTime;
            // if the response is expected to come back before the user types another character, don't
            // debounce
            if (responseTime < paddedRequestTime) {
                return 0;
            }
            // if the response won't come back before the user types another character, wait between
            // 1 and 2 times the paddedRequestTime, depending on how much slower the response is expected
            // to be
            const factor = (responseTime - paddedRequestTime) / responseTime;
            const debounceTime = (1 + factor) * paddedRequestTime;
            return debounceTime;
        }
    }

    var _a;
    class AsyncIteratorWrapper {
        constructor(dataProvider, debouncer, params) {
            this._isFirstNext = true;
            this.dataProvider = dataProvider;
            this.debouncer = debouncer;
            this.params = params;
        }
        next() {
            if (this._isFirstNext) {
                // record the request time with the debouncer
                this.debouncer.recordRequestTime();
                this._isFirstNext = false;
                const filterText = this.params?.filterCriterion?.text;
                const debounceCallback = (resolve, reject) => {
                    // if the request has been aborted, reject the promise with the abort error and return
                    if (this.params?.signal?.aborted) {
                        reject(this.params?.signal?.reason);
                        return;
                    }
                    const asyncIterable = this.dataProvider.fetchFirst(this.params);
                    this._asyncIterator = asyncIterable[Symbol.asyncIterator]();
                    const fetchStart = Date.now();
                    const iterPromise = this._asyncIterator.next();
                    iterPromise.then((result) => {
                        // record the response time with the debouncer
                        const fetchEnd = Date.now();
                        this.debouncer.recordResponseTime(fetchEnd - fetchStart, filterText ? filterText.length : 0);
                        resolve(result);
                    }, reject);
                };
                // the abort handler will pass its own promise resolve/reject functions into this callback
                const callback = (resolve, reject) => {
                    const promise = new Promise((pResolve, pReject) => {
                        this.debouncer.debounce(debounceCallback, filterText ? filterText.length : 0)(pResolve, pReject);
                    });
                    // when the debounce promise resolves, resolve the abort handling promise
                    return promise.then(resolve, reject);
                };
                return ojdataprovider.wrapWithAbortHandling(this.params?.signal, callback, false);
            }
            return this._asyncIterator.next();
        }
    }
    class AsyncIterableWrapper {
        constructor(dataProvider, debouncer, params) {
            this[_a] = () => {
                return new AsyncIteratorWrapper(this.dataProvider, this.debouncer, this.params);
            };
            this.dataProvider = dataProvider;
            this.debouncer = debouncer;
            this.params = params;
        }
    }
    _a = Symbol.asyncIterator;
    /**
     * A DataProvider wrapper that supports debouncing fetchFirst requests.
     * It is up to the calling code to abort stale requests and only process
     * the results for the most recent fetch.
     * @ignore
     */
    class DebouncingDataProviderView {
        constructor(dataProvider) {
            this._debouncer = new Debouncer();
            this.dataProvider = dataProvider;
        }
        /**
         * Fetch the first block of data
         */
        fetchFirst(params) {
            return new AsyncIterableWrapper(this.dataProvider, this._debouncer, params);
        }
        /**
         * Fetch rows by keys
         */
        fetchByKeys(params) {
            return this.dataProvider.fetchByKeys(params);
        }
        /**
         * Check if rows are contained by keys
         */
        containsKeys(params) {
            return this.dataProvider.containsKeys(params);
        }
        /**
         * Fetch rows by offset
         */
        fetchByOffset(params) {
            return this.dataProvider.fetchByOffset(params);
        }
        /**
         * Returns the total size of the data
         */
        getTotalSize() {
            return this.dataProvider.getTotalSize();
        }
        /**
         * Returns a string that indicates if this data provider is empty.
         * Returns "unknown" if the dataProvider has not resolved yet.
         */
        isEmpty() {
            return this.dataProvider.isEmpty();
        }
        /**
         * Determines whether this DataProvider supports certain feature.
         */
        getCapability(capabilityName) {
            return this.dataProvider.getCapability(capabilityName);
        }
        /** start EVENT TARGET IMPLEMENTATION **/
        addEventListener(eventType, listener) {
            this.dataProvider.addEventListener(eventType, listener);
        }
        removeEventListener(eventType, listener) {
            this.dataProvider.removeEventListener(eventType, listener);
        }
        dispatchEvent(event) {
            return this.dataProvider.dispatchEvent(event);
        }
    }

    exports.Debouncer = Debouncer;
    exports.DebouncingDataProviderView = DebouncingDataProviderView;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojpopuputils',['exports', '@oracle/oraclejet-preact/utils/UNSAFE_popupUtils'], function (exports, PreactPopupUtils) { 'use strict';

    /**
     *
     * @ojmodulecontainer ojpopuputils
     * @ojtsmodule
     * @ojhidden
     * @since 19.0.0
     *
     * @classdesc
     * <p>
     *    This module contains a utility function <code>isLogicalAncestor()</code> that allows to link
     *    reparented popup content to its logical ancestor.
     * </p>
     */

    /**
     *
     * Utility function that checks if two DOM nodes are directly or logically connected
     *
     * @ojexports
     * @memberof ojpopuputils
     * @method
     * @name isLogicalAncestor
     * @param {Node} ancestorNode - the assumed ancestor node
     * @param {Node} node - child node
     * @return {boolean} true if the two DOM nodes are directly or logically connected, false otherwise.
     */

    function isLogicalAncestor(ancestorNode, node) {
        return PreactPopupUtils.isLogicalAncestor(ancestorNode, node);
    }

    exports.isLogicalAncestor = isLogicalAncestor;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojabortreason',['exports'], function (exports) { 'use strict';

    const getAbortReason = (element) => {
        const componentTagName = element ? `<${element.tagName.toLowerCase()}>: ` : '';
        const message = `${componentTagName}Aborting stale fetch for performance  a newer request has been issued`;
        const newDOMException = new DOMException(message, 'AbortError');
        newDOMException.severity = 'info';
        return newDOMException;
    };

    /**
     * The AbortReason interface defines the exception contract that will be provided when JET components abort fetch requests.
     *
     * @since 17.0.0
     * @export
     * @interface AbortReason
     * @extends DOMException
     * @ojsignature {target: "Type", value: "interface AbortReason extends DOMException"}
     * @classdesc The AbortReason interface defines the exception contract that will be provided when JET components abort fetch requests.
     * @ojtsexample <caption>How to abort fetchByKeys</caption>
     * // abort on an AbortController instance will abort all requests that are associated
     * // with the signal from that abortController.
     * const abortController = new AbortController();
     * let keySet = new Set();
     * keySet.add(1001);
     * keySet.add(556);
     * // component passes AbortSignal as part of FetchByKeysParameters to fetchByKeys
     * // on dataProvider
     * try {
     *  let value = await dataprovider.fetchByKeys({keys: keySet, signal: abortController.signal});
     * } catch (err) {
     *  // if the data fetch has been aborted, retrieving data from the fetched result
     *  // will be rejected with DOMException named AbortError
     *  if (err.severity === 'info') {
     *    // if the data fetch has been aborted from a jet component as a performance concern, an <u><a href="AbortReason.html">AbortReason</a></u> will be provided.
     *    console.log(err.message);
     *  }
     * }
     * // later when abort is desired, component can invoke abort() on the cached
     * // abort controller to abort any outstanding data retrieval it requested
     * // on asyncIterator.
     * if (abort_is_desired) {
     *   abortController.abort();
     * }
     */
    /**
     * The level of severity of why the fetch was aborted.
     *
     * @since 17.0.0
     * @export
     * @expose
     * @memberof AbortReason
     * @instance
     * @name severity
     * @type {('error' | 'warn' | 'log' | 'info' | 'none')}
     */

    exports.getAbortReason = getAbortReason;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define("bundles/ojcorebundle", function(){});
