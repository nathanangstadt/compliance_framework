/**
 * @license
 * Copyright (c) 2014, 2025, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdvt-axis',['exports', 'ojs/ojconverter-number'], function (exports, ojconverterNumber) { 'use strict';

  /**
   * Calculated axis information and drawable creation.  This class should
   * not be instantiated directly.
   * @class
   * @constructor
   * @extends {dvt.Obj}
   */
  class BaseAxisInfo {
    /**
     * Calculates and stores the axis information.
     * @param {dvt.Context} context
     * @param {object} options The object containing specifications and data for this component.
     * @param {dvt.Rectangle} availSpace The available space.
     * @protected
     */
    constructor(context, options, availSpace) {
      this._context = context;

      // Figure out the start and end coordinate of the axis
      this.Position = options.position;
      this._radius = options._radius; // for polar charts

      if (this.Position === 'top' || this.Position === 'bottom') {
        this.StartCoord = availSpace.x;
        this.EndCoord = availSpace.x + availSpace.w;
      } else if (this.Position === 'left' || this.Position === 'right') {
        this.StartCoord = availSpace.y;
        this.EndCoord = availSpace.y + availSpace.h;
      } else if (this.Position === 'radial') {
        this.StartCoord = 0;
        this.EndCoord = this._radius;
      } else if (this.Position === 'tangential') {
        if (options.isRTL) {
          this.StartCoord = 2 * Math.PI;
          this.EndCoord = 0;
        } else {
          this.StartCoord = 0;
          this.EndCoord = 2 * Math.PI;
        }
      }

      // Axis min and max value. Subclasses should set.
      this.MinValue = null;
      this.MaxValue = null;
      this.GlobalMin = null;
      this.GlobalMax = null;
      this.DataMin = null;
      this.DataMax = null;

      // The overflows at the two ends of the axis
      this.StartOverflow = 0;
      this.EndOverflow = 0;

      // Sets the buffers (the maximum amount the labels can go over before they overflow)
      if (options.leftBuffer == null) {
        options.leftBuffer = Infinity;
      }

      if (options.rightBuffer == null) {
        options.rightBuffer = Infinity;
      }

      // Store the options object
      this.Options = options;
    }

    /**
     * Returns the dvt.Context associated with this instance.
     * @return {dvt.Context}
     */
    getCtx() {
      return this._context;
    }

    /**
     * Returns the options settings for the axis.
     * @return {object} The options for the axis.
     */
    getOptions() {
      return this.Options;
    }

    /**
     * Returns the value for the specified coordinate along the axis.  Returns null
     * if the coordinate is not within the axis.
     * @param {number} coord The coordinate along the axis.
     * @return {object} The value at that coordinate.
     */
    getValAt(coord) {
      if (coord == null) {
        return null;
      }

      var minCoord = Math.min(this.StartCoord, this.EndCoord);
      var maxCoord = Math.max(this.StartCoord, this.EndCoord);

      // Return null if the coord is outside of the axis
      if (coord < minCoord || coord > maxCoord) {
        return null;
      }
      return this.getUnboundedValAt(coord);
    }

    /**
     * Returns the coordinate for the specified value.  Returns null if the value is
     * not within the axis.
     * @param {object} value The value to locate.
     * @return {number} The coordinate for the value.
     */
    getCoordAt(value) {
      if (value == null) {
        return null;
      }
      if (value < this.MinValue || value > this.MaxValue) {
        return null;
      }
      return this.getUnboundedCoordAt(value);
    }

    /**
     * Returns the value for the specified coordinate along the axis.  If a coordinate
     * is not within the axis, returns the value of the closest coordinate within the axis.
     * @param {number} coord The coordinate along the axis.
     * @return {object} The value at that coordinate.
     */
    getBoundedValAt(coord) {
      if (coord == null) {
        return null;
      }
      var cord = coord;
      var minCoord = Math.min(this.StartCoord, this.EndCoord);
      var maxCoord = Math.max(this.StartCoord, this.EndCoord);

      if (coord < minCoord) {
        cord = minCoord;
      } else if (coord > maxCoord) {
        cord = maxCoord;
      }
      return this.getUnboundedValAt(cord);
    }

    /**
     * Returns the coordinate for the specified value along the axis.  If a value
     * is not within the axis, returns the coordinate of the closest value within the axis.
     * @param {object} value The value to locate.
     * @return {number} The coordinate for the value.
     */
    getBoundedCoordAt(value) {
      if (value == null) {
        return null;
      }

      var val = value;
      if (value < this.MinValue) {
        val = this.MinValue;
      } else if (value >= this.MaxValue) {
        val = this.MaxValue;
      }

      return this.getUnboundedCoordAt(val);
    }

    /**
     * Returns the value for the specified coordinate along the axis.
     * @param {number} coord The coordinate along the axis.
     * @return {object} The value at that coordinate.
     */
    getUnboundedValAt(coord) {
      return null; // subclasses should override
    }

    /**
     * Returns the coordinate for the specified value.
     * @param {object} value The value to locate.
     * @return {number} The coordinate for the value.
     */
    getUnboundedCoordAt(value) {
      return null; // subclasses should override
    }
  }

  /**
   * Minimum buffer for horizontal axis.
   */
  BaseAxisInfo.MIN_AXIS_BUFFER = 10;

  /**
   * Calculated axis information and drawable creation for a data axis.
   * @param {dvt.Context} context
   * @param {object} options The object containing specifications and data for this component.
   * @param {dvt.Rectangle} availSpace The available space.
   * @class
   * @constructor
   * @extends {BaseAxisInfo}
   */
  const DataAxisInfoMixin = (Base) =>
    class extends Base {
      constructor(context, options, availSpace) {
        super(context, options, availSpace);

        /** @private @const */
        this.MAX_NUMBER_OF_GRIDS_AUTO = 10;
        /** @private @const */
        this.MINOR_TICK_COUNT = 2;

        /**
         * Constant used to address javascript floating point errors when calculating the majoriTick count
         * and generating the labels and coords. ()
         * @private
         * @const
         */
        this.MAJOR_TICK_INCREMENT_BUFFER = 0.0000000001;

        /** Minimum bar size for log scale; prevents tiny bar with values close to axis min
         * @private
         * @const
         * */
        this.MIN_BAR_SIZE_IN_LOG = 10;

        // Figure out the coords for the min/max values
        if (this.Position === 'top' || this.Position === 'bottom') {
          // Provide at least the minimum buffer at each side to accommodate labels
          if (options.tickLabel.rendered !== 'off' && options.rendered !== 'off') {
            this.StartOverflow = Math.max(BaseAxisInfo.MIN_AXIS_BUFFER - options.leftBuffer, 0);
            this.EndOverflow = Math.max(BaseAxisInfo.MIN_AXIS_BUFFER - options.rightBuffer, 0);
          }

          // Axis is horizontal, so flip for BIDI if needed
          if (options.isRTL) {
            this.MinCoord = this.EndCoord - this.EndOverflow;
            this.MaxCoord = this.StartCoord + this.StartOverflow;
          } else {
            this.MinCoord = this.StartCoord + this.StartOverflow;
            this.MaxCoord = this.EndCoord - this.EndOverflow;
          }
        } else if (this.Position === 'tangential' || this.Position === 'radial') {
          this.MinCoord = this.StartCoord;
          this.MaxCoord = this.EndCoord;
        } else {
          this.MinCoord = this.EndCoord;
          this.MaxCoord = this.StartCoord;
        }

        this.DataMin = options.dataMin;
        this.DataMax = options.dataMax;

        this.utilsLogOptions = options._utils && options.scale === 'log';
        this.IsLog =
          this.utilsLogOptions || (options.scale === 'log' && this.DataMin > 0 && this.DataMax > 0);

        this.LinearGlobalMin = this.actualToLinear(options.min);
        this.LinearGlobalMax = this.actualToLinear(options.max);
        this.LinearMinValue =
          options.viewportMin == null
            ? this.LinearGlobalMin
            : this.actualToLinear(options.viewportMin);
        this.LinearMaxValue =
          options.viewportMax == null
            ? this.LinearGlobalMax
            : this.actualToLinear(options.viewportMax);
        this._dataMin = this.actualToLinear(this.DataMin);
        this._dataMax = this.actualToLinear(this.DataMax);

        this.MajorIncrement = this.actualToLinear(options.step);
        this.MinorIncrement = this.actualToLinear(options.minorStep);
        this._minMajorIncrement = this.actualToLinear(options.minStep);
        this.MajorTickCount = options._majorTickCount;
        this.MinorTickCount = options._minorTickCount;

        this.LogScaleUnit = options._logScaleUnit;
        this.ZeroBaseline = !this.IsLog && options.baselineScaling === 'zero';
        this._continuousExtent = this.Options ? this.Options._continuousExtent === 'on' : null;

        this.Converter = null;
        if (options.tickLabel != null) {
          this.Converter = options.tickLabel.converter;
        }
        this._calcAxisExtents();

        this.GlobalMin = this.linearToActual(this.LinearGlobalMin);
        this.GlobalMax = this.linearToActual(this.LinearGlobalMax);
        this.MinValue = this.linearToActual(this.LinearMinValue);
        this.MaxValue = this.linearToActual(this.LinearMaxValue);
      }

      /**
       * @override
       */
      getBaselineCoord() {
        return this.IsLog ? this.MinCoord : this.getBoundedCoordAt(0);
      }

      /**
       * @override
       */
      getUnboundedValAt(coord) {
        if (coord == null) {
          return null;
        }
        var ratio = (coord - this.MinCoord) / (this.MaxCoord - this.MinCoord);
        var value = this.LinearMinValue + ratio * (this.LinearMaxValue - this.LinearMinValue);
        return this.linearToActual(value);
      }

      /**
       * @override
       */
      getUnboundedCoordAt(value) {
        return this.GetUnboundedCoordAt(this.actualToLinear(value));
      }

      /**
       * Returns the unbounded coord at the specified linearized value.
       * @param {number} value The linearized value.
       * @return {number}
       * @private
       */
      GetUnboundedCoordAt(value) {
        if (value == null) {
          return null;
        }
        var ratio =
          this.LinearMaxValue === this.LinearMinValue
            ? 0
            : (value - this.LinearMinValue) / (this.LinearMaxValue - this.LinearMinValue);
        // Make sure the the ratio is not way too large so the browser does not fail to render
        ratio = Math.max(Math.min(1000, ratio), -1000);
        return this.MinCoord + ratio * (this.MaxCoord - this.MinCoord);
      }

      /**
       * Determines the number of major and minor tick counts and increments for the axis if values were not given.
       * The default minor tick count is 2.
       * @param {number} scaleUnit The scale unit of the axis.
       * @private
       */
      CalcMajorMinorIncr(scaleUnit) {
        if (!this.MajorIncrement) {
          if (this.MajorTickCount) {
            this.MajorIncrement = (this.LinearMaxValue - this.LinearMinValue) / this.MajorTickCount;
          } else {
            this.MajorIncrement = Math.max(scaleUnit, this._minMajorIncrement);
          }
        }

        if (!this.MajorTickCount) {
          this.MajorTickCount = (this.LinearMaxValue - this.LinearMinValue) / this.MajorIncrement;

          // Check if we have a floating point inaccuracy that causes the tick count to be undercalculated
          // within the allowable buffer. If so, tick count is supposed to be the rounded up integer.
          if (
            Math.ceil(this.MajorTickCount) - this.MajorTickCount <
            this.MAJOR_TICK_INCREMENT_BUFFER
          ) {
            this.MajorTickCount = Math.ceil(this.MajorTickCount);
          }
        }

        if (!this.MinorTickCount) {
          if (this.MinorIncrement) {
            this.MinorTickCount = this.MajorIncrement / this.MinorIncrement;
          } else if (this.IsLog) {
            this.MinorTickCount = this.MajorIncrement;
          } else {
            this.MinorTickCount = this.MINOR_TICK_COUNT;
          }
        }

        if (!this.MinorIncrement) {
          this.MinorIncrement = this.MajorIncrement / this.MinorTickCount;
        }
      }

      /**
       * Determines the axis extents based on given start and end value
       * or calculated from the min and max data values of the chart.
       * @private
       */
      _calcAxisExtents() {
        // Include 0 in the axis if we're scaling from the baseline
        if (this.ZeroBaseline) {
          this._dataMin = Math.min(0, this._dataMin);
          this._dataMax = Math.max(0, this._dataMax);
        }

        var maxValue = this.LinearGlobalMax != null ? this.LinearGlobalMax : this._dataMax;
        var minValue = this.LinearGlobalMin != null ? this.LinearGlobalMin : this._dataMin;
        var scaleUnit = Math.max(this._calcAxisScale(minValue, maxValue), this._minMajorIncrement);

        // If there's only a single value on the axis, we need to adjust the
        // this._dataMin and this._dataMax to produce a nice looking axis with around 6 ticks.
        if (this._dataMin === this._dataMax) {
          if (this._dataMin === 0) {
            this._dataMax += 5 * scaleUnit;
          } else {
            this._dataMin -= 2 * scaleUnit;
            this._dataMax += 2 * scaleUnit;
          }
        }

        // Set the default global min
        if (this.LinearGlobalMin == null) {
          if (this.ZeroBaseline && this._dataMin >= 0) {
            this.LinearGlobalMin = 0;
          } else if (this._continuousExtent) {
            // allow smooth pan/zoom transition
            this.LinearGlobalMin = this._dataMin - (this._dataMax - this._dataMin) * 0.1;
          } else if (!this.ZeroBaseline && this.LinearGlobalMax != null) {
            this.LinearGlobalMin = this.LinearGlobalMax;
            this.LinearGlobalMin -=
              scaleUnit * (Math.floor((this.LinearGlobalMin - this._dataMin) / scaleUnit) + 1);
          } else {
            this.LinearGlobalMin = (Math.ceil(this._dataMin / scaleUnit) - 1) * scaleUnit;
          }

          // If all data points are positive, the axis min shouldn't be less than zero
          if (this._dataMin >= 0 && !this.IsLog) {
            this.LinearGlobalMin = Math.max(this.LinearGlobalMin, 0);
          }
        }

        // Set the default global max
        if (this.LinearGlobalMax == null) {
          if (this.MajorTickCount) {
            this.LinearGlobalMax = this.LinearGlobalMin + this.MajorTickCount * scaleUnit;

            // JET-28098 - wrong y2 max
            if (this.LinearGlobalMax < this._dataMax) {
              scaleUnit = Math.max(
                this._calcAxisScale(minValue, maxValue + scaleUnit),
                this._minMajorIncrement
              );
              this.LinearGlobalMax = this.LinearGlobalMin + this.MajorTickCount * scaleUnit;
            }
          } else if (this.ZeroBaseline && this._dataMax <= 0) {
            this.LinearGlobalMax = 0;
          } else if (this._continuousExtent) {
            // allow smooth pan/zoom transition
            this.LinearGlobalMax = this._dataMax + (this._dataMax - this._dataMin) * 0.1;
          } else if (!this.ZeroBaseline) {
            this.LinearGlobalMax = this.LinearGlobalMin;
            this.LinearGlobalMax +=
              scaleUnit * (Math.floor((this._dataMax - this.LinearGlobalMax) / scaleUnit) + 1);
          } else {
            this.LinearGlobalMax = (Math.floor(this._dataMax / scaleUnit) + 1) * scaleUnit;
          }

          // If all data points are negative, the axis max shouldn't be more that zero
          if (this._dataMax <= 0) {
            this.LinearGlobalMax = Math.min(this.LinearGlobalMax, 0);
          }
        }

        if (this.LinearGlobalMax === this.LinearGlobalMin) {
          // happens if this._dataMin == this._dataMax == 0
          this.LinearGlobalMax = 100;
          this.LinearGlobalMin = 0;
          scaleUnit = (this.LinearGlobalMax - this.LinearGlobalMin) / this.MAX_NUMBER_OF_GRIDS_AUTO;
        }

        if (this.LinearMinValue == null) {
          this.LinearMinValue = this.LinearGlobalMin;
        }
        if (this.LinearMaxValue == null) {
          this.LinearMaxValue = this.LinearGlobalMax;
        }

        // if data min and axis min are too close (less than 10px) in log scale, decrease the axis min by a step
        // when called from ojchart-utils (getLabelsFormatInfo) - always subtract one log scale unit from axis min regardless the diff
        var diff = Math.abs(
          this.GetUnboundedCoordAt(this.LinearGlobalMin) - this.GetUnboundedCoordAt(this._dataMin)
        );
        if ((this.IsLog && diff < this.MIN_BAR_SIZE_IN_LOG) || this.utilsLogOptions) {
          this.LinearGlobalMin -= scaleUnit;
          this.LinearMinValue = this.LinearGlobalMin;
        }

        // Recalc the scale unit if the axis viewport is limited
        if (
          this.LinearMinValue !== this.LinearGlobalMin ||
          this.LinearMaxValue !== this.LinearGlobalMax
        ) {
          scaleUnit = this._calcAxisScale(this.LinearMinValue, this.LinearMaxValue);
        }

        if (this.LinearGlobalMin > this.LinearMinValue) {
          this.LinearGlobalMin = this.LinearMinValue;
        }

        if (this.LinearGlobalMax < this.LinearMaxValue) {
          this.LinearGlobalMax = this.LinearMaxValue;
        }

        // Calculate major and minor gridlines
        this.CalcMajorMinorIncr(scaleUnit);
      }

      /**
       * Determines the scale unit of the axis based on a given start and end axis extent.
       * @param {number} min The start data value for the axis.
       * @param {number} max The end data value for the axis.
       * @return {number} The scale unit of the axis.
       * @private
       */
      _calcAxisScale(min, max) {
        if (this.MajorIncrement) {
          return this.MajorIncrement;
        }
        var spread = max - min;

        if (this.IsLog) {
          var scaleUnit = Math.floor(spread / 8) + 1;

          // Store the scaleUnit for aligning log axes
          if (!this.LogScaleUnit || this.LogScaleUnit < scaleUnit) {
            this.LogScaleUnit = scaleUnit;
          }
          return this.LogScaleUnit;
        }

        if (spread === 0) {
          if (min === 0) {
            return 10;
          }
          return Math.pow(10, Math.floor(Math.log10(min)) - 1);
        }

        var testVal;
        if (this.MajorTickCount) {
          //  - y2 axis should show better labels when tick marks are aligned
          var increment = spread / this.MajorTickCount;
          testVal = Math.pow(10, Math.ceil(Math.log10(increment) - 1));
          var firstDigit = increment / testVal;
          if (firstDigit > 1 && firstDigit <= 1.5) {
            firstDigit = 1.5;
          } else if (firstDigit > 5) {
            firstDigit = 10;
          } else {
            firstDigit = Math.ceil(firstDigit);
          }
          return firstDigit * testVal;
        }

        var t = Math.log10(spread);
        testVal = Math.pow(10, Math.ceil(t) - 2);
        var first2Digits = Math.round(spread / testVal);

        // Aesthetically choose a scaling factor limiting to a max number of steps
        var scaleFactor = 1;
        if (first2Digits >= 10 && first2Digits <= 14) {
          scaleFactor = 2;
        } else if (first2Digits >= 15 && first2Digits <= 19) {
          scaleFactor = 3;
        } else if (first2Digits >= 20 && first2Digits <= 24) {
          scaleFactor = 4;
        } else if (first2Digits >= 25 && first2Digits <= 45) {
          scaleFactor = 5;
        } else if (first2Digits >= 46 && first2Digits <= 80) {
          scaleFactor = 10;
        } else {
          scaleFactor = 20;
        }

        // limiting the scale min value to MIN_VALUE. JET-57772
        return Math.max(Number.MIN_VALUE, scaleFactor * testVal);
      }

      /**
       * @override
       */
      linearToActual(value) {
        if (value == null) {
          return null;
        }
        return this.IsLog ? Math.pow(10, value) : value;
      }

      /**
       * @override
       */
      actualToLinear(value) {
        if (value == null) {
          return null;
        }

        if (this.IsLog) {
          return value > 0 ? Math.log10(value) : null;
        }
        return value;
      }

      getAxisData() {
        return {
          isLog: this.IsLog,
          max: this.LinearGlobalMax,
          min: this.LinearGlobalMin,
          step: this.MajorIncrement,
          numSteps: this.MajorTickCount
        };
      }
    };

  /**
   * Formatter for an axis with a linear scale.
   * Following cases can occur:
   * 1. scaling is set to none:
   *    No scaling is used in this case.
   * 2. scaling is set to auto, null or undefined:
   *    Scaling is computed. The nearest (less or equal) known scale is used. Regarding fraction part, if autoPrecision equals "on" then the count of significant decimal places
   *    is based on tickStep otherwise fraction part is not formatted.
   * 3. otherwise
   *    Defined scaling is used.
   *    Examples (autoPrecision = "on"):
   *    minValue = 0, maxValue=10000, tickStep=1000, scale="thousand" -> formatted axis values: 0K , ..., 10K
   *    minValue = 0, maxValue=100, tickStep=10, scale="thousand" -> formatted axis values: 0.00K, 0.01K, ..., 0.10K
   *
   * @param {number} minValue the minimum value on the axis
   * @param {number} maxValue the maximum value on the axis
   * @param {number} tickStep the tick step between values on the axis
   * @param {string} scale the scale of values on the axis; if null or undefined then auto scaling is used.
   * @param {string} autoPrecision "on" if auto precision should be applied otherwise "off"; if null or undefined then auto precision is applied.
   * @param {object} translations the translations options from the containing component
   * @constructor
   */

  class LinearScaleAxisValueFormatter {
    constructor(minValue, maxValue, tickStep, scale, autoPrecision, translations) {
      // Allowed scales that can be used as formatter scale param values
      /** @const **/
      this.SCALE_NONE = 'none';
      /** @const **/
      this.SCALE_AUTO = 'auto';
      /** @const **/
      this.SCALE_THOUSAND = 'thousand';
      /** @const **/
      this.SCALE_MILLION = 'million';
      /** @const **/
      this.SCALE_BILLION = 'billion';
      /** @const **/
      this.SCALE_TRILLION = 'trillion';
      /** @const **/
      this.SCALE_QUADRILLION = 'quadrillion';
      /** @const **/

      /**
       * The scaling factor difference between successive scale values
       */
      this.SCALING_FACTOR_DIFFERENCE = 3;

      this._translations = translations;
      // array of successive scale values
      this._scales = {};
      // array of scale values ordered by scale factor asc
      this._scalesOrder = [];
      // mapping of scale factors to corresponding scale objects
      this._factorToScaleMapping = {};

      this.InitScales();
      this.InitFormatter(minValue, maxValue, tickStep, scale, autoPrecision);
    }

    /**
     * Initializes scale objects.
     * @protected
     *
     */
    InitScales() {
      /**
       * Creates scale object and refreshes formatter properties using it.
       * @param {string} scaleName one of allowed scale names (e.g. this.SCALE_THOUSAND)
       * @param {number} scaleFactor scale factor of corresponding scale, i.e. 'x' such that 10^x represents corresponding scale (e.g. for scale this.SCALE_THOUSAND x = 3)
       * @param {string} scaleKey translation key which value (translated) represents given scale (e.g. for this.SCALE_THOUSAND an translated english suffix is 'K')
       * @this {LinearScaleAxisValueFormatter}
       */
      const createScale = (scaleName, scaleFactor, scaleKey) => {
        var suffix;
        if (scaleKey) {
          suffix = this._translations ? this._translations[scaleKey] : null;
        }

        var scale = {
          scaleFactor: scaleFactor,
          localizedSuffix: suffix
        };

        // update private properties
        this._scales[scaleName] = scale;
        this._scalesOrder.push(scale);
        this._factorToScaleMapping[scaleFactor] = scale;
      };

      var diff = this.SCALING_FACTOR_DIFFERENCE;

      createScale(this.SCALE_NONE, 0 * diff);
      createScale(this.SCALE_THOUSAND, 1 * diff, 'labelScalingSuffixThousand');
      createScale(this.SCALE_MILLION, 2 * diff, 'labelScalingSuffixMillion');
      createScale(this.SCALE_BILLION, 3 * diff, 'labelScalingSuffixBillion');
      createScale(this.SCALE_TRILLION, 4 * diff, 'labelScalingSuffixTrillion');
      createScale(this.SCALE_QUADRILLION, 5 * diff, 'labelScalingSuffixQuadrillion');

      // sort _scalesOrder array
      this._scalesOrder.sort((scale1, scale2) => {
        if (scale1.scaleFactor < scale2.scaleFactor) {
          return -1;
        } else if (scale1.scaleFactor > scale2.scaleFactor) {
          return 1;
        }
        return 0;
      });
    }

    /**
     * Initializes properties used for values formatting (e.g. scale factor that should be applied etc.).
     *
     * @param {number} minValue the minimum value on the axis
     * @param {number} maxValue the maximum value on the axis
     * @param {number} tickStep the tick step between values on the axis
     * @param {string} scale the scale of values on the axis
     * @param {boolean} autoPrecision true if auto precision should be applied otherwise false
     * @protected
     *
     */
    InitFormatter(minValue, maxValue, tickStep, scale, autoPrecision) {
      var findScale = false;
      var decimalPlaces;
      var scaleFactor;
      var useAutoPrecision = false;

      // if autoPrecision doesn't equal "off" (i.e. is "on", null, undefined) then auto precision should be used.
      if (autoPrecision !== 'off') {
        useAutoPrecision = true;
      }
      // try to use scale given by "scale" param and if no scale factor is found find appropriate scale
      scaleFactor = this._getScaleFactor(scale);
      if (typeof scaleFactor !== 'number') {
        findScale = true;
      }

      // base a default scale factor calculation on the order of
      // magnitude (power of ten) of the maximum absolute value on the axis
      if (findScale) {
        // get the axis endpoint with the largest absolute value,
        // and find its base 10 exponent
        var absMax = Math.max(Math.abs(minValue), Math.abs(maxValue));

        var power = this._getPowerOfTen(absMax);
        scaleFactor = this._findNearestLEScaleFactor(power);
      }

      if (useAutoPrecision === true) {
        if (tickStep === 0 && minValue === maxValue) {
          // TODO:  Remove this hack for chart tooltips, which currently passes 0 as the tick step in all cases.
          // Workaround for now will be to add decimal places to show at least 1 and at most 4 significant digits
          var valuePowerOfTen = this._getPowerOfTen(maxValue);
          var scaleFactorDiff = scaleFactor - valuePowerOfTen;
          if (scaleFactorDiff <= 0) {
            // Value is same or larger than the scale factor, ensure 4 significant digits.
            // Make sure that the number of decimal places is at least zero. 
            decimalPlaces = Math.max(scaleFactorDiff + 3, 0);
          } else {
            // Value is smaller, ensure enough decimals to show 1 significant digit
            decimalPlaces = Math.max(scaleFactorDiff, 4);
          }
        } else {
          // get the number of decimal places in the number by subtracting
          // the order of magnitude of the tick step from the order of magnitude
          // of the scale factor
          // (e.g.: scale to K, tick step of 50 -> 3 - 1 = 2 decimal places)
          var tickStepPowerOfTen = this._getPowerOfTen(tickStep);
          decimalPlaces = Math.max(scaleFactor - tickStepPowerOfTen, 0);
        }
      }

      // init private properties with computed values
      this._useAutoPrecision = useAutoPrecision;
      this._scaleFactor = scaleFactor;
      this._decimalPlaces = decimalPlaces;
    }

    /**
     * Finds a scale factor 'x' such that x <= value (e.g. if value equals 4 then returned scale factor equals 3)
     * @param {number} value value representing an order of magnitude
     * @return {number} a scale factor 'x' such that x <= value
     * @private
     */
    _findNearestLEScaleFactor(value) {
      var scaleFactor = 0;

      if (value <= this._scalesOrder[0].scaleFactor) {
        // if the number is less than 10, don't scale
        scaleFactor = this._scalesOrder[0].scaleFactor;
      } else if (value >= this._scalesOrder[this._scalesOrder.length - 1].scaleFactor) {
        // if the data is greater than or equal to 10 quadrillion, scale to quadrillions
        scaleFactor = this._scalesOrder[this._scalesOrder.length - 1].scaleFactor;
      } else {
        // else find the nearest scaleFactor such that scaleFactor <= value
        var end = this._scalesOrder.length - 1;
        for (var i = end; i >= 0; i--) {
          if (this._scalesOrder[i].scaleFactor <= value) {
            scaleFactor = this._scalesOrder[i].scaleFactor;
            break;
          }
        }
      }
      return scaleFactor;
    }

    /**
     * Returns scale factor of scale given by scale name.
     * @param {string} scaleName
     * @return {number} scale factor of scale given by scale name
     * @private
     */
    _getScaleFactor(scaleName) {
      // If no scaling factor defined, use auto by default.
      var sclName = !scaleName ? this.SCALE_AUTO : scaleName;
      var scaleFactor;
      var scale = this._scales[sclName];
      if (scale) {
        scaleFactor = scale.scaleFactor;
      }
      return scaleFactor;
    }

    /**
     * Formats given value using previously computed scale factor and decimal digits count. In case that parsed value equals NaN an unformatted value is returned.
     * @override
     * @param {object} value to be formatted.
     * @param {Object} converter The converter
     * @return {string} formatted value as string
     */
    format(value, converter) {
      var defaultConverter;
      var parsed = value != null ? parseFloat(value) : value;
      if (typeof parsed === 'number') {
        var scale = Math.pow(10, this._scaleFactor);
        var userConverterStyle =
          converter && converter.getOptions && converter.getOptions() && converter.getOptions().style;
        // Use nu to make sure the digits are latin
        var scaleConverterOptions = {
          style: 'decimal',
          decimalFormat: userConverterStyle === 'unit' ? 'standard' : 'short',
          nu: 'latn',
          useGrouping: false
        };
        defaultConverter = new ojconverterNumber.IntlNumberConverter(scaleConverterOptions);

        // Formatting for scale
        var _SCALE_REGEXP = /(\d+)(.*$)/;
        var formattedScale = defaultConverter.format(scale, scaleConverterOptions);
        var formattedScaleParts = _SCALE_REGEXP.exec(formattedScale);
        var suffix = formattedScaleParts[2]; // Reset the suffix
        var formattedScaledNumber = (Number(formattedScaleParts[1]) / scale) * parsed;

        // Formatting for scaled number
        if (converter && converter.format) {
          formattedScaledNumber = converter.format(formattedScaledNumber); // Convert the number itself
        } else {
          // skip nu if you want the digits in native locale digits
          var numberConverterOptions = {
            style: 'decimal',
            minimumFractionDigits: this._decimalPlaces,
            maximumFractionDigits: this._decimalPlaces
          };
          defaultConverter = new ojconverterNumber.IntlNumberConverter(numberConverterOptions);
          formattedScaledNumber = defaultConverter.format(
            formattedScaledNumber,
            numberConverterOptions
          );
        }
        // Add the scale factor suffix, unless value is zero
        if (typeof suffix === 'string' && value !== 0) {
          formattedScaledNumber += suffix;
        }
        return formattedScaledNumber;
      }
      return value;
    }

    /**
     * Formats fraction part of given value (adds zeroes if needed).
     * @param {number} value to be formatted
     * @return {string} number with fraction part formatted as string
     * @private
     */
    _formatFraction(value) {
      var formatted = value.toString();

      // Don't format scientific notation (e.g. '1e-7')
      if (formatted.indexOf('e') !== -1) {
        return formatted;
      }

      var decimalSep = '.';
      // TODO: probably need some translation here?
      if (this._decimalPlaces > 0) {
        if (formatted.indexOf('.') === -1) {
          formatted += decimalSep;
        }

        var existingPlacesCount = formatted.substring(formatted.indexOf(decimalSep) + 1).length;

        while (existingPlacesCount < this._decimalPlaces) {
          formatted += '0';
          existingPlacesCount += 1;
        }
      }
      return formatted;
    }

    /**
     * Fro given value it returns its order of magnitude.
     * @param {number} value for which order of magnitude should be found
     * @return {number} order of magnitude for given value
     * @private
     */
    _getPowerOfTen(value) {
      // more comprehensive and easier than working with value returned by Math.log(value)/Math.log(10)
      var val = value >= 0 ? value : -value;
      var power = 0;

      // Check for degenerate and zero values
      if (val < 1e-15) {
        return 0;
      } else if (val === Infinity) {
        return Number.MAX_VALUE;
      }

      if (val >= 10) {
        // e.g. for 1000 the power should be 3
        while (val >= 10) {
          power += 1;
          val /= 10;
        }
      } else if (val < 1) {
        while (val < 1) {
          power -= 1;
          val *= 10;
        }
      }
      return power;
    }

    /**
     * @returns {Number} number of fractional digits of the formatter
     */
    getDecimalPlaces() {
      return this._decimalPlaces;
    }
  }

  exports.BaseAxisInfo = BaseAxisInfo;
  exports.DataAxisInfoMixin = DataAxisInfoMixin;
  exports.LinearScaleAxisValueFormatter = LinearScaleAxisValueFormatter;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojlegend-toolkit',['exports', 'ojs/ojdvt-toolkit'], function (exports, dvt) { 'use strict';

  /**
   * Utility functions for Legend.
   * @class
   */
  const DvtLegendUtils = {
    /**
     * Get the category from a legend item.
     * @param {object} item The legend item
     * @param {Legend} legend The legend being rendered.
     * @return {String}
     */
    getItemCategory: (item, legend) => {
      var category = null;
      var hasDataProvider = legend.getOptions()['data'] != null;
      if (item['categories'] && item['categories'].length > 0) category = item['categories'][0];
      else if (!hasDataProvider) category = item['id'] ? item['id'] : item['text'];

      return category;
    },

    /**
     * Helper function to check if category is hidden
     * @param {String} category the category string
     * @param {Legend} legend The legend being rendered.
     * @return {boolean} true if the category is in the hiddenCategories array
     */
    isCategoryHidden: (category, legend) => {
      var hiddenCategories = legend.getOptions()['hiddenCategories'];
      if (!hiddenCategories || hiddenCategories.length <= 0) return false;

      return hiddenCategories.indexOf(category) !== -1;
    },

    /**
     * Helper function to check if a section is collapsed
     * @param {object} section the legend section
     * @param {Legend} legend The legend being rendered.
     * @return {boolean} true if the section is collapsed
     */
    isSectionCollapsed: (section, legend) => {
      var options = legend.getOptions();
      return (
        section['expanded'] == 'off' ||
        section['expanded'] == false ||
        (options.expanded && options.expanded.has(section.id) == false)
      );
    },

    isEmpty: (inputObject) => {
      return inputObject ? Object.keys(inputObject).length === 0 : true;
    }
  };

  /**
   * Logical object for legend data object displayables.
   * @param {Legend} legend The owning legend instance.
   * @param {array} displayables The array of associated DvtDisplayables.
   * @param {object} item The definition of the legend item.
   * @param {string} tooltip The tooltip of the legend item.
   * @param {string} datatip The datatip of the legend item.
   * @param {boolean} drillable Whether the legend item is drillable.
   * @class
   * @constructor
   * @implements {DvtLogicalObject}
   * @implements {DvtCategoricalObject}
   * @implements {DvtTooltipSource}
   */
  class DvtLegendObjPeer {
    constructor(legend, displayables, item, tooltip, datatip, drillable) {
      /**
       * @param {Legend} legend The owning legend instance.
       * @param {array} displayables The array of associated DvtDisplayables.
       * @param {object} item The definition of the legend item.
       * @param {string} tooltip The tooltip of the legend item.
       * @param {string} datatip The datatip of the legend item.
       * @param {boolean} drillable Whether the legend item is drillable.
       */
      this._legend = legend;
      this._displayables = displayables;
      this._item = item;
      this._category = DvtLegendUtils.getItemCategory(this._item, this._legend); // section title is not category
      this._id = this._category ? this._category : item['title'] ? item['title'] : item.id; // checking id last mainly due to backwards compatibility issues
      this._drillable = drillable;
      this._tooltip = tooltip;
      this._datatip = datatip;
      this._isShowingKeyboardFocusEffect = false;
      this._hoverBorderRadius = parseInt(legend.getOptions()['_hoverBorderRadius']);
      // Apply the cursor for drilling if specified
      if (this._drillable) {
        for (var i = 0; i < this._displayables.length; i++) {
          this._displayables[i].setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
        }
      }
    }

    /**
     * Creates a data item to identify the specified displayable and registers it with the legend.
     * @param {array} displayables The displayables to associate.
     * @param {Legend} legend The owning legend instance.
     * @param {object} item The definition of the legend item.
     * @param {string} tooltip The tooltip of the legend item.
     * @param {string} datatip The datatip of the legend item.
     * @param {boolean} drillable Whether the legend item is drillable.
     * @return {DvtLegendObjPeer}
     */
    static associate(displayables, legend, item, tooltip, datatip, drillable) {
      // Item must have displayables and an id to be interactive.
      if (!displayables || !item) return null;

      // Create the logical object.
      var identObj = new DvtLegendObjPeer(legend, displayables, item, tooltip, datatip, drillable);

      // Register with the legend
      legend.__registerObject(identObj);

      // Finally associate using the event manager
      for (var i = 0; i < displayables.length; i++)
        legend.getEventManager().associate(displayables[i], identObj);

      return identObj;
    }

    /**
     * Returns the data object defining this legend item.
     * @return {object} The data object defining this legend item.
     */
    getData() {
      return this._item;
    }

    /**
     * Returns the primary data color for this legend item.
     * @return {string} The color string.
     */
    getColor() {
      return this._item['color'];
    }

    /**
     * Returns the id for this legend item.
     * @return {object} The id for this legend item.
     */
    getId() {
      return this._id;
    }

    //---------------------------------------------------------------------//
    // Rollover and Hide/Show Support: DvtLogicalObject impl               //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    getDisplayables() {
      return this._displayables;
    }

    //---------------------------------------------------------------------//
    // Rollover and Hide/Show Support: DvtCategoricalObject impl           //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    getCategories() {
      if (this._category != null) return [this._category];

      return null;
    }

    /**
     * Returns if the legend item is drillable.
     * @return {boolean}
     */
    isDrillable() {
      return this._drillable;
    }

    /**
     * @override
     */
    getAriaLabel() {
      var states = [];
      var options = this._legend.getOptions();
      var translations = options.translations;
      var hideAndShow = this._legend.getOptions()['hideAndShowBehavior'];
      var bHiddenCategory = DvtLegendUtils.isCategoryHidden(this._category, this._legend);
      var data = this.getData();

      if (this._displayables[0] instanceof dvt.IconButton) {
        states.push(
          translations[
            DvtLegendUtils.isSectionCollapsed(data, this._legend) ? 'stateCollapsed' : 'stateExpanded'
          ]
        );
        return dvt.Displayable.generateAriaLabel(data['title'], states);
      }

      if (hideAndShow != 'off' && hideAndShow != 'none')
        states.push(translations[bHiddenCategory ? 'stateHidden' : 'stateVisible']);
      if (this.isDrillable()) states.push(translations.stateDrillable);

      if (data['shortDesc'] != null) {
        return dvt.Displayable.generateAriaLabel(data['shortDesc'], states);
      } else if (states.length > 0) {
        return dvt.Displayable.generateAriaLabel(data['text'], states);
      }

      return null;
    }

    /**
     * Updates the aria label for a map data object
     */
    updateAriaLabel() {
      if (!dvt.Agent.deferAriaCreation() && this._displayables[0])
        this._displayables[0].setAriaProperty('label', this.getAriaLabel());
    }

    //---------------------------------------------------------------------//
    // Keyboard Support: DvtKeyboardNavigable impl                         //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getNextNavigable(event) {
      if (event.type == dvt.MouseEvent.CLICK) return this;

      var navigables = this._legend.__getKeyboardObjects();
      return dvt.KeyboardHandler.getNextNavigable(this, event, navigables, true, this._legend, true);
    }

    /**
     * @override
     */
    getKeyboardBoundingBox(targetCoordinateSpace) {
      if (this._displayables[0]) return this._displayables[0].getDimensions(targetCoordinateSpace);
      else return new dvt.Rectangle(0, 0, 0, 0);
    }

    /**
     * @override
     */
    getTargetElem() {
      if (this._displayables[0]) return this._displayables[0].getElem();
      return null;
    }

    /**
     * @override
     */
    showKeyboardFocusEffect() {
      this._isShowingKeyboardFocusEffect = true;
      if (this._displayables[0]) {
        if (this._displayables[0] instanceof dvt.IconButton)
          this._displayables[0].showKeyboardFocusEffect();
        else this._displayables[0].addClassName('oj-legend-focus');
      }
    }

    /**
     * @override
     */
    hideKeyboardFocusEffect() {
      this._isShowingKeyboardFocusEffect = false;
      if (this._displayables[0]) {
        if (this._displayables[0] instanceof dvt.IconButton)
          this._displayables[0].hideKeyboardFocusEffect();
        else this._displayables[0].removeClassName('oj-legend-focus');
      }
    }

    /**
     * @override
     */
    isShowingKeyboardFocusEffect() {
      return this._isShowingKeyboardFocusEffect;
    }

    //---------------------------------------------------------------------//
    // Tooltip Support: DvtTooltipSource impl                              //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    getTooltip() {
      return this._tooltip;
    }

    /**
     * @override
     */
    getDatatip() {
      return this._datatip;
    }

    /**
     * @override
     */
    getDatatipColor() {
      return this._item['color'];
    }

    //---------------------------------------------------------------------//
    // DnD Support: DvtDraggable impl                                      //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    isDragAvailable() {
      return true;
    }

    /**
     * @override
     */
    getDragTransferable() {
      return [this.getId()];
    }

    /**
     * @override
     */
    getDragFeedback() {
      return this.getDisplayables();
    }

    /**
     * @override
     */
    showHoverEffect() {
      if (this._displayables[0]) {
        if (this._displayables[0] instanceof dvt.Rect) {
          this._displayables[0].addClassName('oj-legend-hover');
          this._displayables[0].setRx(this._hoverBorderRadius);
        }
      }
    }

    /**
     * @override
     */
    hideHoverEffect() {
      if (this._displayables[0]) {
        if (this._displayables[0] instanceof dvt.Rect) {
          this._displayables[0].removeClassName('oj-legend-hover');
          this._displayables[0].setRx(0);
        }
      }
    }
  }

  /**
   *  Provides automation services for a DVT component.
   *  @class DvtLegendAutomation
   *  @param {Legend} dvtComponent
   *  @implements {dvt.Automation}
   *  @constructor
   */
  class DvtLegendAutomation extends dvt.Automation {
    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>section[sectionIndex0]:item[itemIndex]</li>
     * </ul>
     * @override
     */
    GetSubIdForDomElement(displayable) {
      var logicalObj = this._comp.getEventManager().GetLogicalObject(displayable);
      if (logicalObj && logicalObj instanceof DvtLegendObjPeer) {
        var item = logicalObj.getData();
        var indexList = this._getIndicesFromItem(item, this._comp.getOptions());
        if (indexList) return 'section' + indexList;
      }
      return null;
    }

    /**
     * Returns the index values of the given legend item
     * @param {Object} item the legend item to find the indices of within legendOptions
     * @param {Object} legendOptions the legend options object
     * @return {String} [sectionIndex0] or [sectionIndex0]:item[itemIndex]
     * @private
     */
    _getIndicesFromItem(item, legendOptions) {
      // If there are sections in this options object, recurse through the section object
      if (legendOptions['sections'] && legendOptions['sections'].length > 0) {
        for (var s = 0; s < legendOptions['sections'].length; s++) {
          if (legendOptions['sections'][s] == item) return '[' + s + ']';
          else {
            var itemIndex = this._getIndicesFromItem(item, legendOptions['sections'][s]);
            if (itemIndex) return '[' + s + ']' + itemIndex;
          }
        }
        return null;
      }
      // If we found the items list for a section, search the items of this section
      else if (legendOptions['items'] && legendOptions['items'].length > 0) {
        for (var i = 0; i < legendOptions['items'].length; i++) {
          if (legendOptions['items'][i] == item) return ':item[' + i + ']';
        }
        return null;
      }
      return null;
    }

    /**
     * Returns the index values of the legend item that corresponds to the given series
     * @param {Object} series the chart series object
     * @param {Object} legendOptions the legend options object
     * @return {String} [sectionIndex0] or [sectionIndex0]:item[itemIndex]
     */
    getIndicesFromSeries(series, legendOptions) {
      // If there are sections in this options object, recurse through the section object
      if (legendOptions['sections'] && legendOptions['sections'].length > 0) {
        for (var s = 0; s < legendOptions['sections'].length; s++) {
          var itemIndex = this.getIndicesFromSeries(series, legendOptions['sections'][s]);
          if (itemIndex) return '[' + s + ']' + itemIndex;
        }
        return null;
      }
      // If we found the items list for a section, search the items of this section
      else if (legendOptions['items'] && legendOptions['items'].length > 0) {
        for (var i = 0; i < legendOptions['items'].length; i++) {
          if (legendOptions['items'][i]['text'] == series['name']) return ':item[' + i + ']';
        }
        return null;
      }
      return null;
    }

    /**
     * Returns the legend item for the given subId
     * @param {Object} options the legend options object
     * @param {String} subId the subId of the desired legend item
     * @return {Object} the legend item corresponding to the given subId
     */
    getLegendItem(options, subId) {
      var openParen = subId.indexOf('[');
      var closeParen = subId.indexOf(']');
      if (openParen >= 0 && closeParen >= 0) {
        var index = subId.substring(openParen + 1, closeParen);
        var colonIndex = subId.indexOf(':');
        subId = subId.substring(closeParen + 1);
        var nextOpenParen = subId.indexOf('[');
        var nextCloseParen = subId.indexOf(']');
        // If there is another index layer recurse into the sections object at that index
        if (nextOpenParen >= 0 && nextCloseParen >= 0) {
          return this.getLegendItem(options['sections'][index], subId);
        } else {
          // If we are at the last index return the item/section object at that index
          if (colonIndex == 0) return options['items'][index];
          else return options['sections'][index];
        }
      }
      return undefined;
    }

    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>section[sectionIndex0]:item[itemIndex]</li>
     * <li>tooltip</li>
     * </ul>
     * @override
     */
    getDomElementForSubId(subId) {
      // tooltip
      if (subId == dvt.Automation.TOOLTIP_SUBID) return this.GetTooltipElement(this._comp);

      var legendItem = this.getLegendItem(this._comp.getOptions(), subId);
      var legendPeers = this._comp.__getObjects();

      // Find the legend object peer for the item indexed by the subId and return the dom element of its displayable
      for (var i = 0; i < legendPeers.length; i++) {
        var item = legendPeers[i].getData();
        if (legendItem == item) return legendPeers[i].getDisplayables()[0].getElem();
      }
      return null;
    }

    /**
     * Returns the legend title. Used for verification.
     * @return {String} The legend title
     */
    getTitle() {
      return this._comp.getOptions()['title'];
    }

    /**
     * Returns an object containing data for a legend item. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>text</li>
     * </ul>
     * @param {String} subIdPath The array of indices in the subId for the desired legend item
     * @return {Object|null} An object containing data for the legend item
     */
    getItem(subIdPath) {
      var item;
      var index = subIdPath.shift();
      var options = this._comp.getOptions();

      if (!options.sections || options.sections.length === 0) {
        return null;
      }

      while (index != undefined) {
        if (subIdPath.length > 0) options = options['sections'][index];
        else item = options['items'][index];
        index = subIdPath.shift();
      }
      if (item) return { text: item['text'] ? item['text'] : null };
      return null;
    }

    /**
     * Returns an object containing data for a legend section. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>title</li>
     * <li>item</li>
     * <li>section</li>
     * </ul>
     * @param {String} subIdPath The array of indices in the subId for the desired legend section
     * @return {Object} An object containing data for the legend section
     */
    getSection(subIdPath) {
      var section;
      var index = subIdPath.shift();
      var options = this._comp.getOptions();

      if (!options.sections || options.sections.length === 0) {
        return null;
      }

      while (index != undefined) {
        if (subIdPath.length > 0) options = options['sections'][index];
        else section = options['sections'][index];
        index = subIdPath.shift();
      }
      return {
        title: section && section['title'] ? section['title'] : null,
        items: section && section['items'] ? this._generateItemObjects(section['items']) : null,
        sections:
          section && section['sections'] ? this._generateSectionObjects(section['sections']) : null
      };
    }

    /**
     * Returns an array containing data for an array of legend items
     * @param {Array} items The array of legend items
     * @return {Array} An array containing objects with data for each legend item
     * @private
     */
    _generateItemObjects(items) {
      var itemDataArray = [];

      for (var i = 0; i < items.length; i++) {
        itemDataArray.push({ text: items[i]['text'] });
      }

      return itemDataArray;
    }

    /**
     * Returns an array containing data for an array of legend sections
     * @param {Array} sections The array of legend sections
     * @return {Array} An array containing objects with data for each legend section
     * @private
     */
    _generateSectionObjects(sections) {
      var sectionDataArray = [];

      for (var i = 0; i < sections.length; i++) {
        sectionDataArray.push({
          title: sections[i]['title'] ? sections[i]['title'] : null,
          items: sections[i]['items'] ? this._generateItemObjects(sections[i]['items']) : null,
          sections: sections[i]['sections']
            ? this._generateSectionObjects(sections[i]['sections'])
            : null
        });
      }

      return sectionDataArray;
    }

    /**
     *
     * @param {string} id The id of legend item corresponding to logical object.
     * @returns {object | null} obj The logical object corresponding to legend item id.
     */
    _getLogicalObject(id) {
      var peers = this._comp._peers;
      for (var i = 0; i < peers.length; i++) {
        if (id === peers[i]._id) {
          return peers[i];
        }
      }
      return null;
    }

    /**
     * Dispatches synthetic drill event from legend item. Used by webdriver.
     * @param {string} id The id associated with the legend item.
     */
    dispatchDrillEvent(id) {
      var obj = this._getLogicalObject(id);
      this._comp.getEventManager().processDrillEvent(obj);
    }
  }

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {dvt.BaseComponentDefaults}
   */
  class DvtLegendDefaults extends dvt.BaseComponentDefaults {
    constructor(context) {
      /**
       * Defaults for version 1.
       */
      const SKIN_ALTA = {
        skin: dvt.CSSStyle.SKIN_ALTA,
        orientation: 'vertical',
        position: null,
        backgroundColor: null,
        borderColor: null,
        textStyle: new dvt.CSSStyle(
          dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_11 + 'color: #333333;'
        ),
        titleStyle: new dvt.CSSStyle(
          dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_11 + 'color: #737373;'
        ),
        _sectionTitleStyle: new dvt.CSSStyle(
          dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_11 + 'color: #737373;'
        ),
        titleHalign: '',
        hiddenCategories: [],
        hideAndShowBehavior: 'off',
        hoverBehavior: 'none',
        hoverBehaviorDelay: 200,
        scrolling: 'asNeeded',
        halign: 'start',
        valign: 'top',
        drilling: 'off',
        dnd: {
          drag: {
            series: {}
          },
          drop: {
            legend: {}
          }
        },
        // default color, marker shape, and line width, for internal use
        _color: '#a6acb1',
        _markerShape: 'square',
        _lineWidth: 3,

        //*********** Internal Attributes *************************************************//
        layout: {
          outerGapWidth: 3,
          outerGapHeight: 3, // Used by Treemap for legend creation
          titleGapWidth: 17,
          titleGapHeight: 9,
          symbolGapWidth: 7,
          symbolGapHeight: 4,
          rowGap: 4,
          columnGap: 10,
          sectionGapHeight: 16,
          sectionGapWidth: 24
        },

        isLayout: false // true if rendering for layout purposes
      };
      super({ alta: SKIN_ALTA }, context);
    }

    /**
     * Adjusts the gap size based on the component options.
     * @param {Legend} legend The legend component.
     * @param {Number} defaultSize The default gap size.
     * @return {Number}
     */
    static getGapSize(legend, defaultSize) {
      // adjust based on legend text font size
      var scalingFactor = Math.min(
        dvt.TextUtils.getTextStringHeight(legend.getCtx(), legend.getOptions()['textStyle']) / 14,
        1
      );
      return Math.ceil(defaultSize * scalingFactor);
    }

    /**
     * @override
     */
    getNoCloneObject() {
      return { sections: { items: { _getDataContext: true } } };
    }
  }

  /**
   * Event Manager for Legend.
   * @param {Legend} legend
   * @class
   * @extends {dvt.EventManager}
   * @constructor
   */
  class DvtLegendEventManager extends dvt.EventManager {
    constructor(legend) {
      super(legend.getCtx(), legend.processEvent, legend, legend);
      this._legend = legend;
    }

    /**
     * @override
     */
    OnClick(event) {
      super.OnClick(event);

      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;

      var hideShow = this.processHideShowEvent(obj);
      var action = this.handleClick(obj, event);

      // If a hide/show or action occurs, the event should not bubble.
      if (hideShow || action) event.stopPropagation();
    }

    /**
     * @override
     */
    OnMouseOver(event) {
      super.OnMouseOver(event);

      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;

      // Accessibility Support
      this.UpdateActiveElement(obj);
    }

    /**
     * @override
     */
    HandleTouchClickInternal(evt) {
      var obj = this.GetLogicalObject(evt.target);
      if (!obj) return;

      // : if hideAndShow/action is enabled, it takes precedence over series highlighting
      // action is handled in handleClick
      var touchEvent = evt.touchEvent;
      var hideShow = this.processHideShowEvent(obj);
      var processEvt = this.handleClick(obj, evt);
      if ((hideShow || processEvt) && touchEvent) touchEvent.preventDefault();
    }

    /**
     * Processes a hide and show action on the specified legend item.  Returns true if a hide or
     * show has been performed.
     * @param {DvtLegendObjPeer} obj The legend item that was clicked.
     * @return {boolean} True if an event was fired.
     */
    processHideShowEvent(obj) {
      // Don't continue if not enabled
      var hideAndShow = this._legend.getOptions()['hideAndShowBehavior'];
      if (hideAndShow == 'none' || hideAndShow == 'off') return false;

      var categories = obj.getCategories ? obj.getCategories() : null;
      if (!categories || categories.length <= 0) return false;

      var category = obj.getCategories()[0];
      var hiddenCategories = this._legend.getOptions()['hiddenCategories'] || [];
      hiddenCategories = hiddenCategories.slice();

      // Update the legend markers
      var displayables = obj.getDisplayables();
      for (var i = 0; i < displayables.length; i++) {
        var displayable = displayables[i];
        if (displayable instanceof dvt.SimpleMarker)
          // setHollow is a toggle
          displayable.setHollow(obj.getColor());
        else if (displayable instanceof dvt.Rect) obj.updateAriaLabel();
      }

      // Update the state and create the event
      var id = categories[0];
      var event;
      if (DvtLegendUtils.isCategoryHidden(category, this._legend)) {
        hiddenCategories.splice(hiddenCategories.indexOf(category), 1);
        event = dvt.EventFactory.newCategoryShowEvent(id, hiddenCategories);
      } else {
        hiddenCategories.push(category);
        event = dvt.EventFactory.newCategoryHideEvent(id, hiddenCategories);
      }

      this._legend.getOptions()['hiddenCategories'] = hiddenCategories;
      this.FireEvent(event, this._legend);

      // Return true since an event was fired
      return true;
    }

    /**
     * Fires the drill event from the legend object.
     * @param { Object } obj The logical object coressponding to the displayable from which drill is to be fired.
     * @returns { boolean } Returns true if drill object is fired. Else returns false.
     */
    processDrillEvent(obj) {
      // Drill support
      if (obj && obj instanceof DvtLegendObjPeer && obj.isDrillable()) {
        var id = obj.getId();
        this.FireEvent(dvt.EventFactory.newDrillEvent(id), this._legend);
        return true;
      }
      return false;
    }

    /**
     * Helper for processing click event. Handles action, drilling and section collapse.  Returns true if click is handled.
     * @param {DvtLegendObjPeer} obj The legend item that was clicked.
     * @param {dvt.BaseEvent} event
     * @return {boolean} True if an event was fired.
     */
    handleClick(obj, event) {
      if (this.processDrillEvent(obj)) {
        return true;
      }

      var params = obj instanceof dvt.SimpleObjPeer ? obj.getParams() : null;
      if (params && params['isCollapsible']) {
        this.toggleSectionCollapse(event, params['id']);
        return true;
      }

      return false;
    }

    /**
     * @override
     */
    ProcessRolloverEvent(event, obj, bOver) {
      // Don't continue if not enabled
      var options = this._legend.getOptions();
      if (
        options['drilling'] === 'off' &&
        options['hoverBehavior'] === 'none' &&
        (options['hideAndShowBehavior'] === 'none' || options['hideAndShowBehavior'] === 'off')
      )
        return;

      // Do not fire rollover event for section collapse/expand button
      if (obj.getDisplayables && obj.getDisplayables()[0] instanceof dvt.IconButton) return;

      if (options['hoverBehavior'] !== 'none') {
        // Compute the new highlighted categories and update the options
        var categories = obj.getCategories ? obj.getCategories() : [];
        options['highlightedCategories'] = bOver && categories ? categories.slice() : null;

        // Fire the event to the rollover handler, who will fire to the component callback.
        var rolloverEvent = dvt.EventFactory.newCategoryHighlightEvent(
          options['highlightedCategories'],
          bOver
        );
        var hoverBehaviorDelay = dvt.CSSStyle.getTimeMilliseconds(options['hoverBehaviorDelay']);
        this.RolloverHandler.processEvent(
          rolloverEvent,
          this._legend.__getObjects(),
          hoverBehaviorDelay,
          true
        );
      }

      if (
        options['drilling'] !== 'none' ||
        (options['hideAndShowBehavior'] !== 'none' && options['hideAndShowBehavior'] !== 'off')
      ) {
        // Show hover effect
        bOver
          ? obj.showHoverEffect && obj.showHoverEffect()
          : obj.hideHoverEffect && obj.hideHoverEffect();
      }
    }

    /**
     * Collapses or expands a legend section when collapse button is clicked.
     * @param {dvt.BaseEvent} event
     * @param {dvt.IconButton} button The button that calls the method.
     */
    onCollapseButtonClick(event, button) {
      // Find the section based on the buttonId, which is an array of section indices
      var buttonId = button.getId();
      this.toggleSectionCollapse(event, buttonId);
    }

    /**
     * Collapses or expands a legend section.
     * @param {dvt.BaseEvent} event
     * @param {array} sectionIdArray The array of the id path of the section.
     */
    toggleSectionCollapse(event, sectionIdArray) {
      var options = this._legend.getOptions();
      var expandedKeySet = options.expanded;
      var section = this._legend.getOptions();
      var isExpand = null;
      for (var i = 0; i < sectionIdArray.length; i++)
        section = section['sections'][sectionIdArray[i]];

      // Expand or collapse the section
      if (expandedKeySet) {
        if (expandedKeySet.has(section.id)) {
          options.expanded = expandedKeySet.delete([section.id]);
          isExpand = false;
        } else {
          options.expanded = expandedKeySet.add([section.id]);
          isExpand = true;
        }
      } else {
        section['expanded'] = section['expanded'] == 'off' ? 'on' : 'off';
      }

      // Set the keyboard focus on a mouse click
      if (event.type == dvt.MouseEvent.CLICK) {
        var peer = this.GetLogicalObject(event.target);
        if (peer.getNextNavigable) this.setFocusObj(peer.getNextNavigable(event));
      }

      // Stores the current keyboard focus
      var focus = this._legend.getKeyboardFocus();
      var isShowingFocusEffect = focus ? focus.isShowingKeyboardFocusEffect() : false;

      this._legend.render();

      // Restores the keyboard focus after rerendering
      if (focus) this._legend.setKeyboardFocus(focus, isShowingFocusEffect);

      this.hideTooltip();

      // Fire expand/collapse event
      if (isExpand != null) {
        event = new dvt.EventFactory.newExpandCollapseEvent(
          isExpand ? 'expand' : 'collapse',
          section.id,
          section,
          this._legend.getOptions()['_widgetConstructor'],
          options.expanded
        );
        this.FireEvent(event, this._legend);
      }
    }

    /**
     * @override
     */
    GetTouchResponse() {
      if (this._legend.getOptions()['_isScrollingLegend'])
        return dvt.EventManager.TOUCH_RESPONSE_TOUCH_HOLD;
      else return dvt.EventManager.TOUCH_RESPONSE_TOUCH_START;
    }

    /**
     * @override
     */
    isDndSupported() {
      return true;
    }

    /**
     * @override
     */
    GetDragSourceType(event) {
      var obj = this.DragSource.getDragObject();
      if (obj instanceof DvtLegendObjPeer && obj.getData()['_getDataContext'] != null)
        return 'series';
      return null;
    }

    /**
     * @override
     */
    GetDragDataContexts(bSanitize) {
      var obj = this.DragSource.getDragObject();
      if (obj instanceof DvtLegendObjPeer) {
        var dataContext = obj.getData()['_getDataContext']();
        if (bSanitize) {
          dataContext = dvt.JsonUtils.clone(dataContext, null, {
            component: true,
            componentElement: true
          });
          dvt.ToolkitUtils.cleanDragDataContext(dataContext);
        }
        return [dataContext];
      }
      return [];
    }

    /**
     * @override
     */
    GetDropTargetType(event) {
      var relPos = this._legend.stageToLocal(
        this.getCtx().pageToStageCoords(event.pageX, event.pageY)
      );
      var dropOptions = this._legend.getOptions()['dnd']['drop'];
      var bounds = this._legend.__getBounds();

      if (Object.keys(dropOptions['legend']).length > 0 && bounds.containsPoint(relPos.x, relPos.y))
        return 'legend';
      return null;
    }

    /**
     * @override
     */
    GetDropEventPayload(event) {
      return {};
    }

    /**
     * @override
     */
    ShowDropEffect(event) {
      var dropTargetType = this.GetDropTargetType(event);
      if (dropTargetType == 'legend') {
        var dropColor = this._legend.getOptions()['_dropColor'];
        var background = this._legend.getCache().getFromCache('background');
        if (background) {
          background.setSolidFill(dropColor);
          background.setClassName('oj-active-drop');
        }
      }
    }

    /**
     * @override
     */
    ClearDropEffect() {
      var background = this._legend.getCache().getFromCache('background');
      if (background) {
        var backgroundColor = this._legend.getOptions()['backgroundColor'];
        if (backgroundColor) background.setSolidFill(backgroundColor);
        else background.setInvisibleFill();
        dvt.ToolkitUtils.removeClassName(background.getElem(), 'oj-invalid-drop');
        dvt.ToolkitUtils.removeClassName(background.getElem(), 'oj-active-drop');
      }
    }

    /**
     * @override
     */
    ShowRejectedDropEffect(event) {
      var dropTargetType = this.GetDropTargetType(event);

      if (dropTargetType == 'legend') {
        var background = this._legend.getCache().getFromCache('background');
        if (background) background.setClassName('oj-invalid-drop');
      }
    }
  }

  /**
   *  @param {dvt.EventManager} manager The owning dvt.EventManager
   *  @param {Legend} legend
   *  @class DvtLegendKeyboardHandler
   *  @extends {dvt.KeyboardHandler}
   *  @constructor
   */
  class DvtLegendKeyboardHandler extends dvt.KeyboardHandler {
    constructor(manager, legend) {
      super(manager);
      this._legend = legend;
    }

    /**
     * @override
     */
    processKeyDown(event) {
      var keyCode = event.keyCode;
      var currentNavigable = this._eventManager.getFocus();
      var isButton =
        currentNavigable && currentNavigable.getDisplayables()[0] instanceof dvt.IconButton;
      var nextNavigable = null;

      if (currentNavigable == null && keyCode == dvt.KeyboardEvent.TAB) {
        // navigate to the default
        var navigables = this._legend.__getKeyboardObjects();
        if (navigables.length > 0) {
          dvt.EventManager.consumeEvent(event);
          nextNavigable = this.getDefaultNavigable(navigables);
        }
      } else if (currentNavigable) {
        if (keyCode == dvt.KeyboardEvent.TAB) {
          dvt.EventManager.consumeEvent(event);
          nextNavigable = currentNavigable;
        } else if (keyCode == dvt.KeyboardEvent.ENTER || keyCode == dvt.KeyboardEvent.SPACE) {
          // Process driling and action events if enter
          if (keyCode == dvt.KeyboardEvent.ENTER) {
            this._eventManager.handleClick(currentNavigable, event);
          }

          if (isButton)
            this._eventManager.onCollapseButtonClick(event, currentNavigable.getDisplayables()[0]);
          else this._eventManager.processHideShowEvent(currentNavigable);
          dvt.EventManager.consumeEvent(event);
        } else if (
          isButton &&
          (keyCode == dvt.KeyboardEvent.LEFT_ARROW || keyCode == dvt.KeyboardEvent.RIGHT_ARROW)
        ) {
          this._eventManager.onCollapseButtonClick(event, currentNavigable.getDisplayables()[0]);
          dvt.EventManager.consumeEvent(event);
        } else nextNavigable = super.processKeyDown(event);
      }

      // Scroll the next element into view before returning it
      if (nextNavigable) this._legend.container.scrollIntoView(nextNavigable.getDisplayables()[0]);
      return nextNavigable;
    }
  }

  /**
   * Renderer for Legend.
   * @class
   */
  const DvtLegendRenderer = {
    /** @private */
    _DEFAULT_LINE_WIDTH_WITH_MARKER: 2,
    /** @private */
    _LINE_MARKER_SIZE_FACTOR: 0.6,
    /** @private */
    _DEFAULT_SYMBOL_SIZE: 10,
    /** @private */
    _BUTTON_SIZE: 12,
    /** @private */
    _FOCUS_GAP: 2,

    /**
     * Renders the legend.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {dvt.Rectangle} The dimensions of the legend content.
     */
    render: (legend, availSpace) => {
      var options = legend.getOptions();
      var context = legend.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(context);
      legend.__setBounds(availSpace);

      if (!options['isLayout']) DvtLegendRenderer._renderBackground(legend, availSpace);

      // setting scroll to 'always' in redwood
      var visibleScrolling = context.getThemeBehavior() === 'redwood' ? 'always' : 'asNeeded';
      var container = new dvt.SimpleScrollableContainer(
        context,
        availSpace.w,
        availSpace.h,
        visibleScrolling
      );
      var contentContainer = new dvt.Container(context);
      container.getScrollingPane().addChild(contentContainer);
      legend.addChild(container);
      legend.container = container;

      var gapWidth = DvtLegendDefaults.getGapSize(legend, options['layout']['outerGapWidth']);
      var gapHeight = DvtLegendDefaults.getGapSize(legend, options['layout']['outerGapHeight']);
      availSpace.x += gapWidth;
      availSpace.y += gapHeight;
      availSpace.w -= 2 * gapWidth;
      availSpace.h -= 2 * gapHeight;

      // Return if there's no space
      if (availSpace.w <= 0 || availSpace.h <= 0) return new dvt.Dimension(0, 0);

      var totalDim = DvtLegendRenderer._renderContents(
        legend,
        contentContainer,
        new dvt.Rectangle(availSpace.x, availSpace.y, availSpace.w, availSpace.h)
      );

      if (totalDim.w == 0 || totalDim.h == 0)
        // drop legend
        return new dvt.Dimension(0, 0);

      container.prepareContentPane();

      if (totalDim.h > availSpace.h) {
        totalDim.h = availSpace.h;
        options['_isScrollingLegend'] = true;
      } else options['_isScrollingLegend'] = false;

      // Compute the legend content position
      var translateX = 0,
        translateY = 0;
      var halign = options['hAlign'] != null ? options['hAlign'] : options['halign'];
      if (halign == 'center')
        translateX = availSpace.x - totalDim.x + (availSpace.w - totalDim.w) / 2;
      else if (halign == 'end') {
        if (isRTL) translateX = availSpace.x - totalDim.x;
        else translateX = availSpace.x - totalDim.x + availSpace.w - totalDim.w;
      }
      var valign = options['vAlign'] != null ? options['vAlign'] : options['valign'];
      if (valign == 'middle')
        translateY = availSpace.y - totalDim.y + (availSpace.h - totalDim.h) / 2;
      else if (valign == 'bottom') translateY = availSpace.y - totalDim.y + availSpace.h - totalDim.h;

      var contentDims = new dvt.Rectangle(
        totalDim.x + translateX - gapWidth,
        totalDim.y + translateY - gapHeight,
        totalDim.w + 2 * gapWidth,
        totalDim.h + 2 * gapHeight
      );
      if (options['isLayout']) return contentDims;

      // Align the legend content
      if (translateX || translateY) contentContainer.setTranslate(translateX, translateY);

      // Align the titles now after we know the total width
      var titles = legend.__getTitles();
      for (var i = 0; i < titles.length; i++)
        dvt.LayoutUtils.align(
          totalDim,
          titles[i].halign,
          titles[i].text,
          titles[i].text.getDimensions().w
        );

      return contentDims;
    },

    /**
     * Renders the legend title and sections.
     * @param {Legend} legend
     * @param {dvt.Container} container
     * @param {dvt.Rectangle} availSpace
     * @return {dvt.Rectangle} The total dimensions of the title and the sections.
     * @private
     */
    _renderContents: (legend, container, availSpace) => {
      var options = legend.getOptions();
      availSpace = availSpace.clone();

      var title = DvtLegendRenderer._renderTitle(
        legend,
        container,
        options['title'],
        availSpace,
        null,
        true
      );
      if (title) {
        var titleDim = title.getDimensions();
        var titleGap = DvtLegendDefaults.getGapSize(legend, options['layout']['titleGapHeight']);
        availSpace.y += titleDim.h + titleGap;
        availSpace.h -= Math.floor(titleDim.h + titleGap); // : IE9 attributes slightly too much height for the legend title
      }

      var sectionsDim = DvtLegendRenderer._renderSections(
        legend,
        container,
        options['sections'],
        availSpace,
        []
      );

      return title ? titleDim.getUnion(sectionsDim) : sectionsDim;
    },

    /**
     * Renders the legend background/border colors.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderBackground: (legend, availSpace) => {
      var options = legend.getOptions();
      var backgroundColor = options['backgroundColor'];
      var borderColor = options['borderColor'];
      var legendDrop = options['dnd'] ? options['dnd']['drop']['legend'] : {}; // for drop effect
      var legendDrag = options['dnd'] ? options['dnd']['drag']['series'] : {}; // for draggable effect

      if (
        backgroundColor ||
        borderColor ||
        Object.keys(legendDrop).length > 0 ||
        Object.keys(legendDrag).length > 0
      ) {
        var rect = new dvt.Rect(
          legend.getCtx(),
          availSpace.x,
          availSpace.y,
          availSpace.w,
          availSpace.h
        );

        if (backgroundColor) rect.setSolidFill(backgroundColor);
        else rect.setInvisibleFill(); // otherwise the borderColor will fill the rect

        if (borderColor) {
          rect.setSolidStroke(borderColor);
          rect.setPixelHinting(true);
        }

        legend.addChild(rect);

        legend.getCache().putToCache('background', rect);
      }
    },

    /**
     * Renders the legend title and updates the available space.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Container} container The title container.
     * @param {string} titleStr
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {object} section The section attributes, if this is a section
     * @param {boolean} isAligned Whether the title supports halign (done at the end of render call).
     * @param {number} id The id of the section, if this is a section.
     * @param {dvt.IconButton} button The button associated with the legend title
     * @return {dvt.Rectangle} The dimension of the title.
     * @private
     */
    _renderTitle: (legend, container, titleStr, availSpace, section, isAligned, id, button) => {
      var options = legend.getOptions();
      var context = container.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(context);

      if (!titleStr) return null;

      // Create the title object and add to legend
      var title = new dvt.OutputText(context, titleStr, availSpace.x, availSpace.y);
      var titleStyle = options['titleStyle'];
      const isEmptySectionTitleStyle = DvtLegendUtils.isEmpty(options.sectionTitleStyle);

      if (!isEmptySectionTitleStyle) titleStyle = new dvt.CSSStyle(options.sectionTitleStyle); // titleStyle is deprecated

      if (section) {
        var defaultStyle = options['_sectionTitleStyle'].clone();
        if (!isEmptySectionTitleStyle) defaultStyle = defaultStyle.merge(titleStyle);
        titleStyle = section['titleStyle']
          ? defaultStyle.merge(new dvt.CSSStyle(section['titleStyle']))
          : defaultStyle;
      }

      title.setCSSStyle(titleStyle);

      if (dvt.TextUtils.fitText(title, availSpace.w, Infinity, container)) {
        if (isRTL)
          // align right first to get the dims for preferred size
          title.setX(availSpace.x + availSpace.w - title.getDimensions().w);

        if (!options['isLayout']) {
          // Associate with logical object to support tooltips
          var params = { id, button };
          params['isCollapsible'] =
            section &&
            (section['collapsible'] === 'on' ||
              (typeof section['collapsible'] === 'boolean' && section['collapsible']));
          legend
            .getEventManager()
            .associate(
              title,
              new dvt.SimpleObjPeer(title.getUntruncatedTextString(), null, null, params)
            );

          if (isAligned) {
            // title alignment will be deferred until we know the total width of the legend content
            var titleHalign =
              section && section['titleHalign']
                ? section['titleHalign']
                : options['titleHalign'] || options.sectionTitleHalign;
            legend.__registerTitle({ text: title, halign: titleHalign });
          }
        } else container.removeChild(title);

        return title;
      }

      return null;
    },

    /**
     * Renders a legend section.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Container} container The container of the section.
     * @param {Array} sections The array of section objects.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {Array} id The id of the parent section calling this method.
     * @return {dvt.Rectangle} The total dimension of the sections.
     * @private
     */
    _renderSections: (legend, container, sections, availSpace, id) => {
      if (!sections || sections.length == 0) return new dvt.Rectangle(0, 0, 0, 0);

      var options = legend.getOptions();

      // Apply default symbol dimensions. If only one dimension is defined, the other will copy its value.
      // Note that zero width/height should be treated the same as null or undefined.
      if (!options['symbolWidth'] && !options['symbolHeight']) {
        options['symbolWidth'] = DvtLegendRenderer._DEFAULT_SYMBOL_SIZE;
        options['symbolHeight'] = DvtLegendRenderer._DEFAULT_SYMBOL_SIZE;
      } else {
        if (!options['symbolWidth']) options['symbolWidth'] = options['symbolHeight'];
        else if (!options['symbolHeight']) options['symbolHeight'] = options['symbolWidth'];

        //  - Courtesy fix if values passed in as "x" vs. x
        options['symbolWidth'] = parseInt(options['symbolWidth']);
        options['symbolHeight'] = parseInt(options['symbolHeight']);
      }

      var sectionGapHeight = DvtLegendDefaults.getGapSize(
        legend,
        options['layout']['sectionGapHeight']
      );
      var titleGapHeight = DvtLegendDefaults.getGapSize(legend, options['layout']['titleGapHeight']);
      var gapWidth = DvtLegendDefaults.getGapSize(legend, options['layout']['sectionGapWidth']);
      var rowHeight = DvtLegendRenderer._getRowHeight(legend);
      var isHoriz = options['orientation'] != 'vertical';

      var totalDim = null;
      var horizAvailSpace = availSpace.clone();
      var sectionDim;
      for (var i = 0; i < sections.length; i++) {
        var sectionId = id.concat([i]);
        var gapHeight = DvtLegendUtils.isSectionCollapsed(sections[i], legend)
          ? titleGapHeight
          : sectionGapHeight;

        if (isHoriz) {
          // horizontal legend
          // first try to render horizontally in the current row
          sectionDim = DvtLegendRenderer._renderHorizontalSection(
            legend,
            container,
            sections[i],
            horizAvailSpace,
            rowHeight
          );

          if (sectionDim.w > horizAvailSpace.w) {
            if (horizAvailSpace.w < availSpace.w) {
              // form a new row
              availSpace.y += sectionDim.h + gapHeight;
              availSpace.h -= sectionDim.h + gapHeight;
            }

            if (sectionDim.w <= availSpace.w)
              // render horizontally in a new row
              sectionDim = DvtLegendRenderer._renderHorizontalSection(
                legend,
                container,
                sections[i],
                availSpace,
                rowHeight
              );
            // render vertically in columns
            else
              sectionDim = DvtLegendRenderer._renderVerticalSection(
                legend,
                container,
                sections[i],
                availSpace,
                rowHeight,
                sectionId,
                true
              );

            availSpace.y += sectionDim.h + gapHeight;
            availSpace.h -= sectionDim.h + gapHeight;
            horizAvailSpace = availSpace.clone();
          } else {
            horizAvailSpace.w -= sectionDim.w + gapWidth;
            if (!dvt.Agent.isRightToLeft(legend.getCtx()))
              horizAvailSpace.x += sectionDim.w + gapWidth;
          }
        } else {
          // vertical legend
          sectionDim = DvtLegendRenderer._renderVerticalSection(
            legend,
            container,
            sections[i],
            availSpace,
            rowHeight,
            sectionId,
            false
          );
          availSpace.y += sectionDim.h + gapHeight;
          availSpace.h -= sectionDim.h + gapHeight;
        }

        totalDim = totalDim ? totalDim.getUnion(sectionDim) : sectionDim;
      }

      return totalDim;
    },

    /**
     * Creates the legend button.
     * @param {dvt.Context} context
     * @param {Legend} legend
     * @param {object} item The relevant data object for the button peer.
     * @param {object} resources The object containing the button image resources.
     * @param {string} prefix The prefix of the image resource name.
     * @param {number} x The button x position.
     * @param {number} y The button y position.
     * @param {string} tooltip The button tooltip.
     * @param {string} id The button id.
     * @param {function} callback The button callback function.
     * @param {object} callbackObj The button callback object.
     * @return {dvt.IconButton} The button.
     * @private
     */
    _createButton: (
      context,
      legend,
      item,
      resources,
      prefix,
      x,
      y,
      tooltip,
      id,
      callback,
      callbackObj
    ) => {
      var iconStyle = dvt.ToolkitUtils.getIconStyle(context, resources[prefix]);
      var button = new dvt.IconButton(
        context,
        'borderless',
        { style: iconStyle, size: DvtLegendRenderer._BUTTON_SIZE },
        null,
        id,
        callback,
        callbackObj
      );
      button.setTranslate(x, y);

      var peer = DvtLegendObjPeer.associate([button], legend, item, tooltip, null, false);
      button.setAriaRole('button');
      peer.updateAriaLabel();

      return button;
    },

    /**
     * Renders a vertical legend section.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Container} container The container of the section.
     * @param {object} section The section from the options object.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {Number} rowHeight The height of a row of legend items.
     * @param {Array} id The section id, in the form of section index array. For example, if id=[0,1], then this is
     *  the second nested section of the first section.
     * @param {boolean} minimizeNumRows Whether the number of rows should be minimized.
     * @return {dvt.Rectangle} The total dimension of the section.
     * @private
     */
    _renderVerticalSection: (
      legend,
      container,
      section,
      availSpace,
      rowHeight,
      id,
      minimizeNumRows
    ) => {
      if (!section) return undefined;

      var options = legend.getOptions();
      var symbolGap = DvtLegendDefaults.getGapSize(legend, options['layout']['symbolGapWidth']);
      var rowGap = DvtLegendDefaults.getGapSize(legend, options['layout']['rowGap']);
      var colGap = DvtLegendDefaults.getGapSize(legend, options['layout']['columnGap']);
      var context = legend.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(context);
      var hasSections = section['sections'] != null && section['sections'].length > 0;
      var hasItems = section['items'] != null && section['items'].length > 0;

      var sectionSpace = availSpace.clone();
      if (options['scrolling'] != 'off') sectionSpace.h = Infinity;

      // Render collapse button
      var buttonDim;
      var isCollapsible =
        section['collapsible'] === 'on' ||
        (typeof section['collapsible'] === 'boolean' && section['collapsible']);
      var button;
      if (isCollapsible) {
        var buttonX = isRTL
          ? sectionSpace.x + sectionSpace.w - DvtLegendRenderer._BUTTON_SIZE
          : sectionSpace.x;
        if (!options['isLayout']) {
          var isCollapsed = DvtLegendUtils.isSectionCollapsed(section, legend);
          var buttonType = isCollapsed ? 'closed' : 'open';
          var buttonTooltip = options.translations[isCollapsed ? 'tooltipExpand' : 'tooltipCollapse'];
          var em = legend.getEventManager();

          button = DvtLegendRenderer._createButton(
            context,
            legend,
            section,
            options['_resources'],
            buttonType,
            buttonX,
            sectionSpace.y,
            buttonTooltip,
            id,
            em.onCollapseButtonClick,
            em
          );
          container.addChild(button);
        }
        buttonDim = new dvt.Rectangle(
          buttonX,
          sectionSpace.y,
          DvtLegendRenderer._BUTTON_SIZE,
          DvtLegendRenderer._BUTTON_SIZE
        );

        // Indent the section
        var buttonGap = DvtLegendDefaults.getGapSize(legend, options['layout']['symbolGapWidth']);
        if (!isRTL) sectionSpace.x += DvtLegendRenderer._BUTTON_SIZE + buttonGap;
        sectionSpace.w -= DvtLegendRenderer._BUTTON_SIZE + buttonGap;
      }

      // Render legend section title. Only support titleHalign if the section is not collapsible and not nested.
      var title = DvtLegendRenderer._renderTitle(
        legend,
        container,
        section['title'],
        sectionSpace,
        section,
        !isCollapsible && id.length <= 1,
        id,
        button
      );
      var sectionSpaceX = isRTL ? sectionSpace.x + sectionSpace.w : sectionSpace.x;
      var titleDim = title
        ? title.getDimensions()
        : new dvt.Rectangle(sectionSpaceX, sectionSpace.y, 0, 0);
      var sectionDim = buttonDim ? titleDim.getUnion(buttonDim) : titleDim;

      // See if this is a section group which contains more legend sections
      if ((!hasItems && !hasSections) || DvtLegendUtils.isSectionCollapsed(section, legend))
        return sectionDim;

      // Title+button should always be on its own row
      if (sectionDim.h > 0) {
        var titleGap = DvtLegendDefaults.getGapSize(legend, options['layout']['titleGapHeight']);
        sectionSpace.y += sectionDim.h + titleGap;
        sectionSpace.h -= sectionDim.h + titleGap;
      }

      // Render nested sections
      if (hasSections) {
        var nestedSectionDim = DvtLegendRenderer._renderSections(
          legend,
          container,
          section['sections'],
          sectionSpace,
          id
        );
        sectionDim = sectionDim.getUnion(nestedSectionDim);
      }

      if (!hasItems) return sectionDim;

      // Determine needed cols and rows
      var colInfo = DvtLegendRenderer._calcColumns(
        legend,
        sectionSpace,
        rowHeight,
        section['items'],
        minimizeNumRows
      );
      var numCols = colInfo['numCols'];
      var numRows = colInfo['numRows'];
      var colWidth = colInfo['width'];
      var colInitY = sectionSpace.y; // top y-coord of the columns

      // Don't render if not enough space
      if (numRows == 0 || numCols == 0) return sectionDim;

      var contentHeight = numRows * (rowHeight + rowGap) - rowGap;
      var contentWidth = Math.min(numCols * (colWidth + colGap) - colGap, sectionSpace.w);
      var contentDim = new dvt.Rectangle(
        isRTL ? sectionSpace.x + sectionSpace.w - contentWidth : sectionSpace.x,
        sectionSpace.y,
        contentWidth,
        contentHeight
      );
      sectionDim = sectionDim.getUnion(contentDim);

      // No need to render during layout pass
      if (options['isLayout']) return sectionDim;

      // For text truncation
      var textSpace = colWidth - options['symbolWidth'] - symbolGap;

      // Render the items one by one
      var currRow = 0;
      var currCol = 1;
      var numItems = section['items'].length;

      // iterate through items
      for (var i = 0; i < numItems; i++) {
        var item = section['items'][i];
        DvtLegendRenderer._createLegendItem(
          legend,
          container,
          item,
          sectionSpace,
          textSpace,
          rowHeight,
          i
        );

        // Update coordinates for next row
        sectionSpace.y += rowHeight + rowGap;
        currRow++;
        if (currRow === numRows && currCol !== numCols) {
          sectionSpace.y = colInitY;
          sectionSpace.w -= colWidth + colGap;
          if (!isRTL) sectionSpace.x += colWidth + colGap;
          currRow = 0;
          currCol++;
        }

        // End for loop if number of rows possible(numRows) is reached
        if (currRow === numRows) break;
      }

      return sectionDim;
    },

    /**
     * Renders a horizontal legend section.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Container} container The container of the section.
     * @param {object} section The section from the options object.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {number} rowHeight The height of a row of legend items.
     * @return {dvt.Rectangle} The total dimension of the section.
     * @private
     */
    _renderHorizontalSection: (legend, container, section, availSpace, rowHeight) => {
      if (!section) return undefined;

      var options = legend.getOptions();
      var symbolWidth = options['symbolWidth'];
      var symbolGap = DvtLegendDefaults.getGapSize(legend, options['layout']['symbolGapWidth']);
      var colGap = DvtLegendDefaults.getGapSize(legend, options['layout']['columnGap']);
      var titleGap = DvtLegendDefaults.getGapSize(legend, options['layout']['titleGapWidth']);
      var hasItems = section['items'] != null && section['items'].length > 0;
      var isRTL = dvt.Agent.isRightToLeft(legend.getCtx());
      var sectionSpace = availSpace.clone();

      // Determine legend section title
      var title = DvtLegendRenderer._renderTitle(
        legend,
        container,
        section['title'],
        availSpace,
        section,
        false
      );
      var availSpaceX = isRTL ? availSpace.x + availSpace.w : availSpace.x;
      var titleDim = title
        ? title.getDimensions()
        : new dvt.Rectangle(availSpaceX, availSpace.y, 0, 0);
      if (!hasItems) return titleDim;
      else if (titleDim.w > 0) {
        sectionSpace.w -= titleDim.w + titleGap;
        if (!isRTL) sectionSpace.x += titleDim.w + titleGap;
      }

      // Compute the section width and cache the text widths of the items
      var textWidths = [];
      var totalWidth = availSpace.w - sectionSpace.w;
      var item, textWidth, i;
      var numItems = section['items'].length;
      for (i = 0; i < numItems; i++) {
        item = section['items'][i];
        textWidth = Math.ceil(
          dvt.TextUtils.getTextStringWidth(legend.getCtx(), item['text'], options['textStyle'])
        );
        totalWidth += textWidth + symbolWidth + symbolGap + colGap;
        textWidths.push(textWidth);
      }
      if (numItems > 0) totalWidth -= colGap;

      // Don't render during layout pass, or if the totalWidth exceeds the available space
      var sectionDim = new dvt.Rectangle(
        isRTL ? availSpace.x + availSpace.w - totalWidth : availSpace.x,
        availSpace.y,
        totalWidth,
        Math.max(rowHeight, titleDim.h)
      );
      if (options['isLayout'] || totalWidth > availSpace.w) {
        container.removeChild(title);
        return sectionDim;
      }

      if (title) {
        // no need to vertically align if there is no title
        legend.getCache().putToCache('horizRowAlign', true);
        legend.getCache().putToCache('sectionRect', sectionDim);

        var dims = title.getDimensions();
        var dy = sectionDim.y + sectionDim.h / 2 - dims.h / 2 - dims.y;
        title.setTranslate(0, dy);
      }

      var colWidth;
      for (i = 0; i < numItems; i++) {
        item = section['items'][i];
        DvtLegendRenderer._createLegendItem(
          legend,
          container,
          item,
          sectionSpace,
          textWidths[i],
          rowHeight,
          i
        );

        colWidth = textWidths[i] + symbolWidth + symbolGap;
        sectionSpace.w -= colWidth + colGap;
        if (!isRTL) sectionSpace.x += colWidth + colGap;
      }
      // Reset cached variables after legend items are created
      legend.getCache().putToCache('horizRowAlign', false);
      legend.getCache().putToCache('sectionRect', null);

      return sectionDim;
    },

    /**
     * Returns the space required for a legend section.
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {number} rowHeight The height of a legend row.
     * @param {object} items The legend items to be rendered.
     * @param {boolean} minimizeNumRows Whether the number of rows should be minimized.
     * @return {object} Map containing width, rows and columns in the legend.
     * @private
     */
    _calcColumns: (legend, availSpace, rowHeight, items, minimizeNumRows) => {
      var options = legend.getOptions();

      // Use widest text since using # of chars can be wrong for unicode
      var itemTexts = [];
      for (var i = 0; i < items.length; i++) {
        itemTexts.push(items[i]['text']);
      }
      var textWidth = dvt.TextUtils.getMaxTextStringWidth(
        legend.getCtx(),
        itemTexts,
        options['textStyle']
      );

      // Row variables
      var symbolWidth = options['symbolWidth'];
      var symbolGap = DvtLegendDefaults.getGapSize(legend, options['layout']['symbolGapWidth']);
      var rowGap = DvtLegendDefaults.getGapSize(legend, options['layout']['rowGap']);
      var colGap = DvtLegendDefaults.getGapSize(legend, options['layout']['columnGap']);

      var numRows;
      var colWidth;
      var numCols;
      var fullColWidth = Math.ceil(symbolWidth + symbolGap + textWidth);

      if (minimizeNumRows) {
        // For horizontal layouts form as many columns as possible to minimize the height
        numCols = Math.min(
          Math.max(Math.floor((availSpace.w + colGap) / (fullColWidth + colGap)), 1),
          items.length
        ); // Get possible number of cols
        numRows = Math.min(
          Math.floor((availSpace.h + rowGap) / (rowHeight + rowGap)),
          Math.ceil(items.length / numCols)
        );

        // Adjust number of columns and rows to remove unused columns and even out columns
        numCols = Math.ceil(items.length / numRows);
        numRows = Math.ceil(items.length / numCols);
      } else if (availSpace.h == Infinity) {
        // For scrollable legends, don't wrap legend items into more than one column
        numCols = 1;
        numRows = items.length;
      } else {
        // For vertical layouts use full depth and then increase cols as necessary
        numRows = Math.min(Math.floor((availSpace.h + rowGap) / (rowHeight + rowGap)), items.length);
        numCols = Math.ceil(items.length / numRows);
        numRows = Math.ceil(items.length / numCols); // to get columns of roughly equal heights
      }

      var maxColWidth = (availSpace.w - colGap * (numCols - 1)) / numCols;
      colWidth = Math.min(fullColWidth, maxColWidth);

      if (colWidth < symbolWidth) return { width: 0, numCols: 0, numRows: 0 };

      return { width: colWidth, numCols, numRows };
    },

    /**
     * Returns the height of a single item in the legend.
     * @param {Legend} legend The legend being rendered.
     * @return {number} The height of a legend item.
     * @private
     */
    _getRowHeight: (legend) => {
      var options = legend.getOptions();

      // Figure out the legend item height
      var textHeight = dvt.TextUtils.getTextStringHeight(legend.getCtx(), options['textStyle']);
      var symbolHeight =
        options['symbolHeight'] +
        DvtLegendDefaults.getGapSize(legend, options['layout']['symbolGapHeight']);
      return Math.ceil(Math.max(textHeight, symbolHeight));
    },

    /**
     * Creates a legend item (symbol + text).
     * @param {Legend} legend The legend being rendered.
     * @param {dvt.Container} container The container of the legend item.
     * @param {object} item The item in the options object.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {number} textSpace The maximum text width.
     * @param {object} rowHeight The height of the legend item.
     * @param {number} i The item index.
     * @private
     */
    _createLegendItem: (legend, container, item, availSpace, textSpace, rowHeight, i) => {
      var options = legend.getOptions();
      var context = legend.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(context);
      var symbolWidth = options['symbolWidth'];
      var symbolGap = DvtLegendDefaults.getGapSize(legend, options['layout']['symbolGapWidth']);

      var symbolX = isRTL ? availSpace.x + availSpace.w - symbolWidth : availSpace.x;
      var textX = isRTL
        ? availSpace.x + availSpace.w - symbolWidth - symbolGap
        : availSpace.x + symbolWidth + symbolGap;

      // Create legend marker
      var marker = DvtLegendRenderer._createLegendSymbol(
        legend,
        symbolX,
        availSpace.y,
        rowHeight,
        item,
        i
      );

      // Create legend text
      var label = item['text'];
      var text;
      if (label != null) {
        var style = options['textStyle'];
        text = DvtLegendRenderer._createLegendText(container, textSpace, label, style);
        if (text) {
          text.setX(textX);
          // Maintaining old behaviour for IE since dominant-baseline is buggy. 
          dvt.TextUtils.centerTextVertically(text, availSpace.y + rowHeight / 2);
          if (isRTL) text.alignRight();
        }

        // Vertically center the legend title and legend items of the horizontal section
        var sectionRect = legend.getCache().getFromCache('sectionRect');
        if (
          legend.getCache().getFromCache('horizRowAlign') &&
          sectionRect &&
          options['orientation'] != 'vertical'
        ) {
          var textH = text.getDimensions().h;
          var dy =
            sectionRect.y +
            sectionRect.h / 2 -
            Math.max(options['symbolHeight'], textH) / 2 -
            availSpace.y;
          marker.setTranslate(0, dy);
          text.setTranslate(0, dy);
        }
      }

      // Add legend marker to legend. Legend text has been added by _createLegendText.
      container.addChild(marker);

      // Draw a rectangle on top of the legend item.  This rectangle is used for interactivity and to ensure that
      // rollover is smooth when moving across legend items.
      var itemRect = new dvt.Rect(
        context,
        isRTL
          ? textX - textSpace - DvtLegendRenderer._FOCUS_GAP
          : symbolX - DvtLegendRenderer._FOCUS_GAP,
        availSpace.y - DvtLegendRenderer._FOCUS_GAP,
        symbolWidth + symbolGap + textSpace + 2 * DvtLegendRenderer._FOCUS_GAP,
        rowHeight + 2 * DvtLegendRenderer._FOCUS_GAP
      );
      itemRect.setInvisibleFill();
      var hideAndShow = options['hideAndShowBehavior'];
      if (hideAndShow != 'none' && hideAndShow != 'off') itemRect.setCursor('pointer');

      container.addChild(itemRect);

      // Associate for interactivity.
      var displayables = [itemRect, marker];
      if (text != null) displayables.push(text);

      var peer = DvtLegendObjPeer.associate(
        displayables,
        legend,
        item,
        text != null ? text.getUntruncatedTextString() : null,
        item['shortDesc'],
        DvtLegendRenderer._isItemDrillable(legend, item)
      );

      if (DvtLegendUtils.isCategoryHidden(DvtLegendUtils.getItemCategory(item, legend), legend)) {
        marker.setHollow(peer.getColor());
        // Don't apply style and className
        marker.setStyle().setClassName();
      }

      if (
        (hideAndShow != 'none' && hideAndShow != 'off') ||
        item['shortDesc'] != null ||
        item['drilling'] == 'on'
      ) {
        itemRect.setAriaRole('img');
        peer.updateAriaLabel();
      }
    },

    /**
     * Returns whether the item is drillable.
     * @param {Legend} legend
     * @param {Object} item
     * @return {boolean}
     * @private
     */
    _isItemDrillable: (legend, item) => {
      if (item['drilling'] == 'on') return true;
      if (item['drilling'] == 'off') return false;

      return legend.getOptions()['drilling'] == 'on';
    },

    /**
     * Creates a legend text. Adds the text to the legend if it's not empty.
     * @param {dvt.Container} container The text container.
     * @param {number} textSpace The width allowed for text.
     * @param {String} label The content of the text object.
     * @param {String} style The CSS style string to apply to the text object.
     * @return {dvt.Text}
     * @private
     */
    _createLegendText: (container, textSpace, label, style) => {
      // Draw the legend text.
      var text = new dvt.OutputText(container.getCtx(), label);
      text.setCSSStyle(style);
      text = dvt.TextUtils.fitText(text, textSpace, Infinity, container) ? text : null;
      return text;
    },

    /**
     * Creates a legend symbol.
     * @param {Legend} legend The legend being rendered.
     * @param {number} x The x coordinate of the legend symbol.
     * @param {number} y The y coordinate of the legend symbol.
     * @param {number} rowHeight The height of the legend item.
     * @param {object} item The data for the legend item.
     * @param {number} i The index of the legend item. Used for determining the default color.
     * @return {dvt.Shape}
     * @private
     */
    _createLegendSymbol: (legend, x, y, rowHeight, item, i) => {
      // Apply the default styles
      var legendOptions = legend.getOptions();
      var context = legend.getCtx();
      var symbolType = item['type'] != null ? item['type'] : item['symbolType'];

      if (!item['markerShape']) item['markerShape'] = legendOptions['_markerShape'];

      if (!item['color']) item['color'] = legendOptions['_color'];

      if (!item['lineWidth'])
        item['lineWidth'] =
          symbolType == 'lineWithMarker'
            ? DvtLegendRenderer._DEFAULT_LINE_WIDTH_WITH_MARKER
            : legendOptions['_lineWidth'];

      var symbolWidth = legendOptions['symbolWidth'];
      var symbolHeight = legendOptions['symbolHeight'];

      // Find the center of the markers
      var cy = y + rowHeight / 2;
      var cx = x + symbolWidth / 2;

      var symbol;
      if (symbolType == 'line') {
        symbol = DvtLegendRenderer._createLine(context, x, y, symbolWidth, rowHeight, item);
      } else if (symbolType == 'lineWithMarker') {
        symbol = DvtLegendRenderer._createLine(context, x, y, symbolWidth, rowHeight, item);

        // only if not found in hiddenCategories
        if (!DvtLegendUtils.isCategoryHidden(DvtLegendUtils.getItemCategory(item, legend), legend))
          symbol.addChild(
            DvtLegendRenderer._createMarker(
              legend,
              cx,
              cy,
              symbolWidth * DvtLegendRenderer._LINE_MARKER_SIZE_FACTOR,
              symbolHeight * DvtLegendRenderer._LINE_MARKER_SIZE_FACTOR,
              item
            )
          );
      } else if (symbolType == 'image') {
        symbol = DvtLegendRenderer._createImage(
          legend,
          x,
          y,
          symbolWidth,
          symbolHeight,
          rowHeight,
          item
        );
      } else if (symbolType == '_verticalBoxPlot') {
        symbolHeight = Math.max(Math.round(symbolHeight / 4) * 4, 4); // must be an integer multiple of 4 to ensure perfect rendering
        symbol = new dvt.Container(context);
        symbol.addChild(
          DvtLegendRenderer._createMarker(
            legend,
            cx,
            cy + symbolHeight / 4,
            symbolWidth,
            symbolHeight / 2,
            DvtLegendRenderer._getBoxPlotOptions(item, 'q2')
          )
        );
        symbol.addChild(
          DvtLegendRenderer._createMarker(
            legend,
            cx,
            cy - symbolHeight / 4,
            symbolWidth,
            symbolHeight / 2,
            DvtLegendRenderer._getBoxPlotOptions(item, 'q3')
          )
        );
      } else if (symbolType == '_horizontalBoxPlot') {
        var isRTL = dvt.Agent.isRightToLeft(context);
        symbolWidth = Math.max(Math.round(symbolWidth / 4) * 4, 4); // must be an integer multiple of 4 to ensure perfect rendering
        var xOffset = (symbolWidth / 4) * (isRTL ? 1 : -1);
        symbol = new dvt.Container(context);
        symbol.addChild(
          DvtLegendRenderer._createMarker(
            legend,
            cx + xOffset,
            cy,
            symbolWidth / 2,
            symbolHeight,
            DvtLegendRenderer._getBoxPlotOptions(item, 'q2')
          )
        );
        symbol.addChild(
          DvtLegendRenderer._createMarker(
            legend,
            cx - xOffset,
            cy,
            symbolWidth / 2,
            symbolHeight,
            DvtLegendRenderer._getBoxPlotOptions(item, 'q3')
          )
        );
      } else {
        symbol = DvtLegendRenderer._createMarker(legend, cx, cy, symbolWidth, symbolHeight, item);
      }
      return symbol;
    },

    /**
     * Creates a image symbol
     * @param {Legend} legend The legend being rendered.
     * @param {number} x The x coordinate of the legend symbol.
     * @param {number} y The y coordinate of the legend symbol.
     * @param {number} symbolWidth Image width.
     * @param {number} symbolHeight Image height.
     * @param {number} rowHeight Height of row (impacted by font size).
     * @param {object} item The data for the legend item.
     * @return {dvt.ImageMarker}
     * @private
     */
    _createImage: (legend, x, y, symbolWidth, symbolHeight, rowHeight, item) => {
      var context = legend.getCtx();

      var imageY = y + rowHeight / 2;
      var imageX = x + symbolWidth / 2;

      return new dvt.ImageMarker(
        context,
        imageX,
        imageY,
        symbolWidth,
        symbolHeight,
        null,
        item['source']
      );
    },

    /**
     * Creates a marker symbol.
     * @param {Legend} legend The legend being rendered.
     * @param {number} cx The x coordinate of the legend symbol.
     * @param {number} cy The y coordinate of the legend symbol.
     * @param {number} symbolWidth The column width allocated to the legend symbol.
     * @param {number} symbolHeight The height of the legend item.
     * @param {object} item The data for the legend item.
     * @return {dvt.SimpleMarker}
     * @private
     */
    _createMarker: (legend, cx, cy, symbolWidth, symbolHeight, item) => {
      var context = legend.getCtx();

      // Find the style values
      var shape = item['markerShape'];
      var isLineWithMarker = item['symbolType'] && item['symbolType'] == 'lineWithMarker';
      var color = isLineWithMarker && item['markerColor'] ? item['markerColor'] : item['color'];
      var style =
        item['markerStyle'] || item['markerSvgStyle']
          ? item['markerStyle'] || item['markerSvgStyle']
          : item['style'] || item['svgStyle'];
      var className =
        item['markerClassName'] || item['markerSvgClassName']
          ? item['markerClassName'] || item['markerSvgClassName']
          : item['className'] || item['svgClassName'];
      var pattern = item['pattern'];

      var legendMarker;
      if (pattern && pattern != 'none') {
        // Pattern markers must be translated, since the pattern starts at the origin of the shape
        legendMarker = new dvt.SimpleMarker(
          context,
          shape,
          0,
          0,
          symbolWidth,
          symbolHeight,
          null,
          null,
          true
        );
        legendMarker.setFill(new dvt.PatternFill(pattern, color, '#FFFFFF'));
        legendMarker.setTranslate(cx, cy);
      } else {
        legendMarker = new dvt.SimpleMarker(
          context,
          shape,
          cx,
          cy,
          symbolWidth,
          symbolHeight,
          null,
          null,
          true
        );
        legendMarker.setSolidFill(color);
      }

      if (item['borderColor']) {
        var borderWidth = item['_borderWidth'] ? item['_borderWidth'] : 1;
        legendMarker.setSolidStroke(item['borderColor'], null, borderWidth);
      }

      // Use pixel hinting for crisp squares
      if (shape == 'square' || shape == 'rectangle') legendMarker.setPixelHinting(true);

      legendMarker.setClassName(className).setStyle(style);

      return legendMarker;
    },

    /**
     * Creates a line symbol.
     * @param {dvt.Context} context The context in which to create the legend item.
     * @param {number} x The x coordinate of the legend symbol.
     * @param {number} y The y coordinate of the legend symbol.
     * @param {number} colWidth The column width allocated to the legend symbol.
     * @param {number} rowHeight The height of the legend item.
     * @param {object} item The data for the legend item.
     * @return {dvt.Line}
     * @private
     */
    _createLine: (context, x, y, colWidth, rowHeight, item) => {
      var lineY = y + rowHeight / 2;
      // For type lineWithMarker, marker parameters cx, cy, symbolHeight and symbolWidth are rounded up.
      // To make everything symmetrical, we round line parameters as well.
      colWidth = colWidth % 2 == 1 ? colWidth + 1 : colWidth; // colWidth is even-ed to make up for the rounding of cx in marker for lineWithMarker types.
      var line = new dvt.Line(context, x, Math.round(lineY), x + colWidth, Math.round(lineY));

      // Set the line style. The size and the spacing of the dash/dot has to be shrunk so that it's readable inside the 10px box.
      var style = item['lineStyle'];
      var dashProps;
      if (style == 'dashed') dashProps = { dashArray: '4,2,4' };
      else if (style == 'dotted') dashProps = { dashArray: '2' };

      var stroke = new dvt.Stroke(item['color'], 1, item['lineWidth'], false, dashProps);

      // set custom style and class
      line
        .setClassName(item['className'] || item['svgClassName'])
        .setStyle(item['style'] || item['svgStyle']);

      line.setStroke(stroke);
      line.setPixelHinting(true);

      return line;
    },

    /**
     * Return the item options for the half-shape of box plot symbol.
     * @param {object} item The legend item options
     * @param {string} prefix 'q2' or 'q3'
     * @return {object}
     * @private
     */
    _getBoxPlotOptions: (item, prefix) => {
      return {
        markerShape: 'rectangle',
        color: item['_boxPlot'][prefix + 'Color'],
        pattern: item['_boxPlot']['_' + prefix + 'Pattern'],
        className:
          item['_boxPlot'][prefix + 'ClassName'] || item['_boxPlot'][prefix + 'svgClassName'],
        style: item['_boxPlot'][prefix + 'Style'] || item['_boxPlot'][prefix + 'svgStyle']
      };
    }
  };

  /**
   * Legend component.  This class should never be instantiated directly.  Use the
   * newInstance function instead.
   * @class
   * @constructor
   * @extends {dvt.BaseComponent}
   */
  class Legend extends dvt.BaseComponent {
    /**
     * @override
     * @protected
     */
    constructor(context, callback, callbackObj) {
      super(context, callback, callbackObj);
      this.setId('legend' + 1000 + Math.floor(Math.random() * 1000000000)); //@RandomNumberOK
      // Create the defaults object
      this.Defaults = new DvtLegendDefaults(context);

      // Create the event handler and add event listeners
      this.EventManager = new DvtLegendEventManager(this);
      this.EventManager.addListeners(this);

      /**
       * The array of logical objects that corresponds to legend items.
       * @private
       */
      this._peers = [];
      /**
       * The array of logical objects that corresponds to section collapse buttons or legend items that are navigable.
       * @private
       */
      this._navigablePeers = [];
      /**
       * The object that stores the bounds for this legend
       * @private
       */
      this._bounds = null;
      /**
       * The object that stores the title objects for this legend
       * @private
       */
      this._titles = [];
    }
    /**
     * Returns a copy of the default options for the specified skin.
     * @param {string} skin The skin whose defaults are being returned.
     * @return {object} The object containing defaults for this component.
     */
    static getDefaults(skin) {
      return new DvtLegendDefaults().getDefaults(skin);
    }

    /**
     * @override
     */
    SetOptions(options) {
      super.SetOptions(options);
      if (options) {
        // Combine the user options with the defaults and store
        this.Options = this.Defaults.calcOptions(options);

        this._processData(this.Options['sections']);
      } else if (!this.Options)
        // Create a default options object if none has been specified
        this.Options = this.GetDefaults();
    }

    /**
     * Returns the preferred dimensions for this component given the maximum available space.
     * @param {object} options The object containing specifications and data for this component.
     * @param {Number} maxWidth The maximum width available.
     * @param {Number} maxHeight The maximum height available.
     * @return {dvt.Dimension} The preferred dimensions for the object.
     */
    getPreferredSize(options, maxWidth, maxHeight) {
      // Update the options object.
      this.SetOptions(options);

      // Set the layout flag to indicate this is a layout pass only
      this.getOptions()['isLayout'] = true;

      // Ask the legend to render its contents in the max space and find the space used.
      var availSpace = new dvt.Rectangle(0, 0, maxWidth, maxHeight);
      var dim = DvtLegendRenderer.render(this, availSpace);

      // Clear the rendered contents and reset state
      this.getOptions()['isLayout'] = false;

      // Return the space used
      return new dvt.Dimension(dim.w, dim.h);
    }

    /**
     * @override
     */
    render(options, width, height) {
      this.getCache().clearCache();

      // Update the options object if provided.
      this.SetOptions(options);

      // Update the width and height if provided.
      if (!isNaN(width) && !isNaN(height)) {
        this.Width = width;
        this.Height = height;
      }

      // Set the render flag to indicate we are rendering. Not being read correctly in flash - 
      this.getOptions()['isLayout'] = false;

      // Clear any contents rendered previously
      var childCount = this.getNumChildren();
      for (var childIndex = 0; childIndex < childCount; childIndex++) {
        var child = this.getChildAt(childIndex);
        child.destroy();
      }

      this.removeChildren();
      this._peers = [];
      this._navigablePeers = [];
      this._bounds = null;
      this._titles = [];

      // Set up keyboard handler if the legend is interactive
      this.EventManager.setKeyboardHandler(new DvtLegendKeyboardHandler(this.EventManager, this));

      this.UpdateAriaAttributes();

      // Render the legend
      var availSpace = new dvt.Rectangle(0, 0, this.Width, this.Height);
      this._contentDimensions = DvtLegendRenderer.render(this, availSpace);

      // Process highlightedCategories
      var highlightedCategories = this.getOptions()['highlightedCategories'];
      if (highlightedCategories && highlightedCategories.length > 0)
        this.highlight(highlightedCategories);

      this.RenderComplete();
      return this._contentDimensions;
    }

    /**
     * @override
     */
    highlight(categories) {
      // Update the options. Legend checks for any category instead of all, so we need to convert empty to null.
      this.getOptions()['highlightedCategories'] =
        categories && categories.length > 0 ? categories.slice() : null;

      // Perform the highlighting
      dvt.CategoryRolloverHandler.highlight(categories, this.__getObjects(), true);
    }

    /**
     * Processes the specified event.
     * @param {object} event
     * @param {object} source The component that is the source of the event, if available.
     */
    processEvent(event, source) {
      var type = event['type'];
      if (type == 'categoryHighlight') {
        if (this.getOptions()['hoverBehavior'] == 'dim') {
          var peers = this.__getObjects();

          // If the legend is not the source of the event, perform highlighting.
          if (this != source) this.highlight(event['categories']);

          for (var i = 0; i < peers.length; i++) {
            if (dvt.Obj.compareValues(this.getCtx(), peers[i].getId(), event['categories'])) {
              this.container.scrollIntoView(peers[i].getDisplayables()[0]);
              break;
            }
          }
        }
      }

      // Dispatch the event to the callback if it originated from this component.
      if (this == source) {
        this.dispatchEvent(event);
      }
    }

    /**
     * Registers the object peer with the legend.  The peer must be registered to participate
     * in interactivity.
     * @param {DvtLegendObjPeer} peer
     */
    __registerObject(peer) {
      if (peer.getDisplayables()[0] instanceof dvt.IconButton)
        this._navigablePeers.push(peer); // peer is navigable if associated with button
      else {
        // peer is navigable if associated with legend item using datatip, action, drilling, or hideShow is enabled
        var hideAndShow = this.getOptions()['hideAndShowBehavior'];
        if (
          peer.getDatatip() != null ||
          peer.isDrillable() ||
          (hideAndShow != 'none' && hideAndShow != 'off')
        )
          this._navigablePeers.push(peer);

        this._peers.push(peer);
      }
    }

    /**
     * Returns the peers for all objects within the legend.
     * @return {array}
     */
    __getObjects() {
      return this._peers;
    }

    /**
     * Returns the keyboard navigables within the legend.
     * @return {array}
     */
    __getKeyboardObjects() {
      return this._navigablePeers;
    }

    /**
     * Stores the bounds for this legend
     * @param {Object} bounds
     */
    __setBounds(bounds) {
      this._bounds = bounds.clone();
    }

    /**
     * Returns the bounds for this legend
     * @return {Object} the object containing the bounds for this legend
     */
    __getBounds() {
      return this._bounds;
    }

    /**
     * Adds a title object to be stored by the legend
     * @param {object} title An object containing the text and the alignment
     */
    __registerTitle(title) {
      this._titles.push(title);
    }

    /**
     * Returns the title objects for this legend
     * @return {array} An array containing the title objects for this legend
     */
    __getTitles() {
      return this._titles;
    }

    /**
     * Returns the automation object for this chart
     * @return {dvt.Automation} The automation object
     */
    getAutomation() {
      return new DvtLegendAutomation(this);
    }

    /**
     * Returns the keyboard-focused object of the legend
     * @return {DvtKeyboardNavigable} The focused object.
     */
    getKeyboardFocus() {
      if (this.EventManager != null) return this.EventManager.getFocus();
      return null;
    }

    /**
     * Sets the navigable as the keyboard-focused object of the legend. It matches the id in case the legend
     * has been rerendered.
     * @param {DvtKeyboardNavigable} navigable The focused object.
     * @param {boolean} isShowingFocusEffect Whether the keyboard focus effect should be used.
     */
    setKeyboardFocus(navigable, isShowingFocusEffect) {
      if (this.EventManager == null) return;

      var peers = this.__getKeyboardObjects();
      for (var i = 0; i < peers.length; i++) {
        if (dvt.Obj.compareValues(this.getCtx(), peers[i].getId(), navigable.getId())) {
          this.EventManager.setFocusObj(peers[i]);
          if (isShowingFocusEffect) peers[i].showKeyboardFocusEffect();
          break;
        }
      }

      // Update the accessibility attributes
      var focus = this.getKeyboardFocus();
      if (focus) {
        var displayable = focus.getDisplayables()[0];
        displayable.setAriaProperty('label', focus.getAriaLabel());
        this.getCtx().setActiveElement(displayable);
      }
    }

    /**
     * @override
     */
    getDimensions(targetCoordinateSpace) {
      var bounds = new dvt.Rectangle(0, 0, this.Width, this.Height);
      if (!targetCoordinateSpace || targetCoordinateSpace === this) return bounds;
      else {
        // Calculate the bounds relative to the target space
        return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
      }
    }

    /**
     * Processes the sections data. Transfers categoryVisibility property from legend item to hiddenCategories on the legend.
     * @param {array} sections The array of legend section definitions
     * @private
     */
    _processData(sections) {
      let hasCollapsible = false;
      let hasDrillableItem = false;
      if (!sections || sections.length <= 0) return;

      var hiddenCategories = this.getOptions()['hiddenCategories'];
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        hasCollapsible = hasCollapsible || section.collapsible === 'on';
        // If this section has nested sections, recurse.
        if (section['sections']) this._processData(section['sections']);

        // Iterate through the items and transfer properties.
        var items = section['items'];
        if (!items || items.length <= 0) continue;

        // Transfer the category visibility properties to the hiddenCategories.
        for (var j = 0; j < items.length; j++) {
          var item = items[j];
          hasDrillableItem = hasDrillableItem || item.drilling === 'on';
          var itemCategory = DvtLegendUtils.getItemCategory(item, this);

          if (item['categoryVisibility'] == 'hidden' && hiddenCategories.indexOf(itemCategory) < 0)
            hiddenCategories.push(itemCategory);

          item['categoryVisibility'] = null;
        }
      }
      this.getCache().putToCache('hasCollapsible', hasCollapsible);
      this.getCache().putToCache('hasDrillableItem', hasDrillableItem);
    }

    /**
     * @override
     */
    UpdateAriaAttributes() {
      if (this.IsParentRoot()) {
        var options = this.getOptions();
        var translations = options.translations;
        var hideAndShow = options['hideAndShowBehavior'];
        const hasDrillableItem =
          options['drilling'] === 'on' || this.getCache().getFromCache('hasDrillableItem');
        const hasCollapsible = this.getCache().getFromCache('hasCollapsible');
        if (
          (hideAndShow != 'off' && hideAndShow != 'none') ||
          options['hoverBehavior'] == 'dim' ||
          hasCollapsible ||
          hasDrillableItem
        ) {
          this.getCtx().setAriaRole('application');
          this.getCtx().setAriaLabel(
            dvt.ResourceUtils.format(translations.labelAndValue, [
              translations.labelDataVisualization,
              dvt.AriaUtils.processAriaLabel(this.GetComponentDescription())
            ])
          );
        }
      }
    }

    /**
     * Returns whether or not the legend has navigable peers
     * @return {boolean}
     */
    isNavigable() {
      return this._navigablePeers.length > 0;
    }

    /**
     * Returns the number of items in the section
     * @param {object} section
     * @return {Number} number of items in section
     */
    static getSectionItemsCount(section) {
      var itemsCount = 0;
      if (section.items) {
        itemsCount += section.items.length;
      }
      if (section.sections) {
        var sections = section.sections;
        for (var i = 0; i < sections.length; i++) {
          itemsCount += Legend.getSectionItemsCount(sections[i]);
        }
      }
      return itemsCount;
    }
  }

  exports.Legend = Legend;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdvt-overview',['exports', 'ojs/ojdvt-toolkit'], function (exports, dvt) { 'use strict';

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @extends {dvt.BaseComponentDefaults}
   */
  class DvtOverviewDefaults extends dvt.BaseComponentDefaults {
    constructor() {
      const VERSION_1 = {
        overviewPosition: 'below',
        style: {
          currentTimeIndicatorColor: '#c000d1',
          handleFillColor: '#ffffff',
          handleTextureColor: '#b3c6db',
          leftFilterPanelAlpha: 0.7,
          leftFilterPanelColor: '#ffffff',
          overviewBackgroundColor: '#e6ecf3',
          rightFilterPanelAlpha: 0.7,
          rightFilterPanelColor: '#ffffff',
          timeAxisBarColor: '#e5e5e5',
          timeAxisBarAlpha: 1,
          timeIndicatorColor: '#bcc7d2',
          windowBackgroundAlpha: 1,
          windowBackgroundColor: '#ffffff',
          windowBorderBottomColor: '#4f4f4f',
          windowBorderBottomStyle: 'solid',
          windowBorderLeftColor: '#4f4f4f',
          windowBorderLeftStyle: 'solid',
          windowBorderRightColor: '#4f4f4f',
          windowBorderRightStyle: 'solid',
          windowBorderTopColor: '#4f4f4f',
          windowBorderTopStyle: 'solid'
        }
      };

      super({ alta: VERSION_1 });
    }
  }

  /**
   * Overview event manager.
   * @param {Overview} overview The owning Overview.
   * @extends {dvt.EventManager}
   * @constructor
   */
  class DvtOverviewEventManager extends dvt.EventManager {
    constructor(overview) {
      super(overview.getCtx(), overview.processEvent, overview);
      this._overview = overview;
    }

    /**
     * @override
     */
    addListeners(displayable) {
      dvt.SvgDocumentUtils.addDragListeners(
        this._overview,
        this._onDragStart,
        this._onDragMove,
        this._onDragEnd,
        this
      );
    }

    /**
     * Drag start callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean} Whether drag is initiated.
     * @private
     */
    _onDragStart(event) {
      if (dvt.EventManager.isTouchEvent(event)) return this._onTouchDragStart(event);
      else return this._onMouseDragStart(event);
    }

    /**
     * Drag move callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean}
     * @private
     */
    _onDragMove(event) {
      if (dvt.EventManager.isTouchEvent(event)) return this._onTouchDragMove(event);
      else return this._onMouseDragMove(event);
    }

    /**
     * Drag end callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean}
     * @private
     */
    _onDragEnd(event) {
      if (dvt.EventManager.isTouchEvent(event)) return this._onTouchDragEnd(event);
      else return this._onMouseDragEnd(event);
    }

    /**
     * Return the relative position relative to the stage, based on the cached stage absolute position.
     * @param {number} pageX
     * @param {number} pageY
     * @return {dvt.Point} The relative position.
     * @private
     */
    _getRelativePosition(pageX, pageY) {
      if (!this._stageAbsolutePosition)
        this._stageAbsolutePosition = this._context.getStageAbsolutePosition();

      return new dvt.Point(
        pageX - this._stageAbsolutePosition.x,
        pageY - this._stageAbsolutePosition.y
      );
    }

    /**
     * Mouse drag start callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean} Whether drag is initiated.
     * @private
     */
    _onMouseDragStart(event) {
      if (event.button !== dvt.MouseEvent.RIGHT_CLICK_BUTTON) {
        var relPos = this._getRelativePosition(event.pageX, event.pageY);
        return this._overview.beginDragPan(event, relPos.x, relPos.y);
      }
      return false;
    }

    /**
     * Mouse drag move callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onMouseDragMove(event) {
      var relPos = this._getRelativePosition(event.pageX, event.pageY);
      this._overview.contDragPan(event, relPos.x, relPos.y);
      return true;
    }

    /**
     * Mouse drag end callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onMouseDragEnd(event) {
      this._overview.endDragPan();
      // Clear the stage absolute position cache
      this._stageAbsolutePosition = null;
    }

    /**
     * Touch drag start callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean} Whether drag is initiated.
     * @private
     */
    _onTouchDragStart(event) {
      var touches = event.touches;
      event.stopPropagation();
      if (touches.length === 1) {
        var relPos = this._getRelativePosition(touches[0].pageX, touches[0].pageY);
        event.preventDefault();
        return this._overview.beginDragPan(event, relPos.x, relPos.y);
      }
      return false;
    }

    /**
     * Touch drag move callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onTouchDragMove(event) {
      var touches = event.touches;
      // make sure this is a single touch and not a multi touch
      if (touches.length === 1) {
        var relPos = this._getRelativePosition(touches[0].pageX, touches[0].pageY);
        this._overview.contDragPan(event, relPos.x, relPos.y);
        event.preventDefault();
      }
      event.stopPropagation();
    }

    /**
     * Touch drag end callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onTouchDragEnd(event) {
      this._overview.endDragPan();
      dvt.EventManager.consumeEvent(event);

      // Clear the stage absolute position cache
      this._stageAbsolutePosition = null;
    }
  }

  /**
   * Overview JSON Parser
   * @param {Overview} view The owning Overview component.
   * @class
   * @constructor
   */
  class OverviewParser {
    /**
     * Initializes the component parser.
     * @param {Overview} view The Overview instance.
     */
    constructor(view) {
      this._view = view;
    }

    /**
     * Parses the JSON object and returns the root node of the overview.
     * @param {object} options The object describing the component.
     * @return {object} An object containing the parsed properties.
     */
    parse(options) {
      return this.ParseRootAttributes(options);
    }

    /**
     * Parses the attributes on the root node.
     * @param {object} options The options object defining the root.
     * @return {object} An object containing the parsed properties.
     * @protected
     */
    ParseRootAttributes(options) {
      // The object that will be populated with parsed values and returned
      var ret = {};

      // animation related options
      ret.animationOnClick = options['animationOnClick'];

      if (options['xMin'] != null) ret.xMin = options['xMin'];
      if (options['xMax'] != null) ret.xMax = options['xMax'];

      if (options['x1'] != null) ret.x1 = options['x1'];
      if (options['x2'] != null) ret.x2 = options['x2'];

      if (options['yMin'] != null) ret.yMin = options['yMin'];
      if (options['yMax'] != null) ret.yMax = options['yMax'];

      if (options['y1'] != null) ret.y1 = options['y1'];
      if (options['y2'] != null) ret.y2 = options['y2'];

      if (options['referenceObjects'] != null) ret.referenceObjects = options['referenceObjects'];

      ret.orientation = 'horizontal';
      if (options['orientation'] != null) ret.orientation = options['orientation'];

      ret.featuresOff = options['featuresOff'];
      ret.minimumWindowSize = options['minimumWindowSize'];
      ret.leftMargin = options['leftMargin'];
      ret.rightMargin = options['rightMargin'];

      ret.overviewPosition = 'below';
      ret.selectionMode = 'none';
      ret.isRtl = dvt.Agent.isRightToLeft(this._view.getCtx()).toString();
      if (options['rtl'] != null) ret.isRtl = options['rtl'].toString();

      return ret;
    }

    /**
     * Convenient method to calculate the width based on start time/end time and viewport end time
     * @param {number} startTime The start time of the component.
     * @param {number} endTime The end time of the component.
     * @param {number} viewportStartTime The viewport start time of the component.
     * @param {number} viewportEndTime The viewport end time of the component.
     * @param {number} viewportEndPos The position of the end of the viewport.
     * @return {number} The calculated width.
     */
    calculateWidth(startTime, endTime, viewportStartTime, viewportEndTime, viewportEndPos) {
      var number = viewportEndPos * (endTime - startTime);
      var denominator = viewportEndTime - viewportStartTime;
      if (number === 0 || denominator === 0) {
        return 0;
      }

      return number / denominator;
    }
  }

  /**
   * Style related utility functions for Overview.
   * @class
   */
  const DvtOverviewStyleUtils = {
    /**
     * Attribute for axis label padding.
     * @const
     * @private
     */
    _DEFAULT_AXIS_LABEL_PADDING: 5,

    /**
     * Attribute for default window border width.
     * @const
     * @private
     */
    _DEFAULT_WINDOW_BORDER_WIDTH: 1,

    /**
     * Gets the handle fill color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The handle fill color.
     */
    getHandleFillColor: (options) => {
      if (options['_hfc'] != null) return options['_hfc'];
      else return options['style']['handleFillColor'];
    },

    /**
     * Gets the handle texture color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The handle texture color.
     */
    getHandleTextureColor: (options) => {
      if (options['_htc'] != null) return options['_htc'];
      else return options['style']['handleTextureColor'];
    },

    /**
     * Gets the handle background class.
     * @param {object} options The object containing data and specifications for the component.
     * @param {boolean} isVertical Whether or not this is the vertical handle.
     * @return {string} The handle background class.
     */
    getHandleBackgroundClass: (options, isVertical) => {
      if (!isVertical) {
        if (options['_hbc'] != null) return options['_hbc'];
        else return options['style']['handleBackgroundClass'];
      } else {
        if (options['_vhbc'] != null) return options['_vhbc'];
        else return options['style']['vertHandleBackgroundClass'];
      }
    },

    /**
     * Gets the handle size.
     * @param {object} options The object containing data and specifications for the component.
     * @param {boolean} isVertical Whether or not this is the vertical handle.
     * @return {number} The handle size.
     */
    getHandleSize: (options, isVertical) => {
      if (!isVertical) {
        if (options['_hs'] != null) return options['_hs'];
        else return options['style']['handleSize'];
      } else {
        if (options['_vhs'] != null) return options['_vhs'];
        else return options['style']['vertHandleSize'];
      }
    },

    /**
     * Gets the top border color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The top border color.
     */
    getBorderTopColor: (options) => {
      if (options['_btc'] != null) return options['_btc'];
      else return options['style']['borderTopColor'];
    },

    /**
     * Gets the top border style.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The top border style.
     */
    getBorderTopStyle: (options) => {
      if (options['_bts'] != null) return options['_bts'];
      else return options['style']['borderTopStyle'];
    },

    /**
     * Gets the window background color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The window background color.
     */
    getWindowBackgroundColor: (options) => {
      if (options['_wbc'] != null) return options['_wbc'];
      else return options['style']['windowBackgroundColor'];
    },

    /**
     * Gets the window background opacity.
     * @param {object} options The object containing data and specifications for the component.
     * @return {number} The window background opacity.
     */
    getWindowBackgroundAlpha: (options) => {
      return options['style']['windowBackgroundAlpha'];
    },

    /**
     * Gets the top window border style.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The top window border style.
     */
    getWindowBorderTopStyle: (options) => {
      if (options['_wbts'] != null) return options['_wbts'];
      else return options['style']['windowBorderTopStyle'];
    },

    /**
     * Gets the right window border style.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The right window border style.
     */
    getWindowBorderRightStyle: (options) => {
      if (options['_wbrs'] != null) return options['_wbrs'];
      else return options['style']['windowBorderRightStyle'];
    },

    /**
     * Gets the bottom window border style.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The bottom window border style.
     */
    getWindowBorderBottomStyle: (options) => {
      if (options['_wbbs'] != null) return options['_wbbs'];
      else return options['style']['windowBorderBottomStyle'];
    },

    /**
     * Gets the left window border style.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The left window border style.
     */
    getWindowBorderLeftStyle: (options) => {
      if (options['_wbls'] != null) return options['_wbls'];
      else return options['style']['windowBorderLeftStyle'];
    },

    /**
     * Gets the top window border color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The top window border color.
     */
    getWindowBorderTopColor: (options) => {
      if (options['_wbtc'] != null) return options['_wbtc'];
      else return options['style']['windowBorderTopColor'];
    },

    /**
     * Gets the right window border color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The right window border color.
     */
    getWindowBorderRightColor: (options) => {
      if (options['_wbrc'] != null) return options['_wbrc'];
      else return options['style']['windowBorderRightColor'];
    },

    /**
     * Gets the bottom window border color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The bottom window border color.
     */
    getWindowBorderBottomColor: (options) => {
      if (options['_wbbc'] != null) return options['_wbbc'];
      else return options['style']['windowBorderBottomColor'];
    },

    /**
     * Gets the left window border color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The left window border color.
     */
    getWindowBorderLeftColor: (options) => {
      if (options['_wblc'] != null) return options['_wblc'];
      else return options['style']['windowBorderLeftColor'];
    },

    /**
     * Gets the overview background color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The overview background color.
     */
    getOverviewBackgroundColor: (options) => {
      if (options['_obc'] != null) return options['_obc'];
      else return options['style']['overviewBackgroundColor'];
    },

    /**
     * Gets the current time indicator color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The current time indicator color.
     */
    getCurrentTimeIndicatorColor: (options) => {
      if (options['_ctic'] != null) return options['_ctic'];
      else return options['style']['currentTimeIndicatorColor'];
    },

    /**
     * Gets the time axis bar color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The time axis bar color.
     */
    getTimeAxisBarColor: (options) => {
      if (options['_tabc'] != null) return options['_tabc'];
      else return options['style']['timeAxisBarColor'];
    },

    /**
     * Gets the time axis bar opacity.
     * @param {object} options The object containing data and specifications for the component.
     * @return {number} The time axis bar opacity.
     */
    getTimeAxisBarAlpha: (options) => {
      if (options['_tabo'] != null) return options['_tabo'];
      else return options['style']['timeAxisBarAlpha'];
    },

    /**
     * Gets the time indicator color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The time indicator color.
     */
    getTimeIndicatorColor: (options) => {
      if (options['_tic'] != null) return options['_tic'];
      else return options['style']['timeIndicatorColor'];
    },

    /**
     * Gets the left filter panel color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The left filter panel color.
     */
    getLeftFilterPanelColor: (options) => {
      return options['style']['leftFilterPanelColor'];
    },

    /**
     * Gets the left filter panel opacity.
     * @param {object} options The object containing data and specifications for the component.
     * @return {number} The left filter panel opacity.
     */
    getLeftFilterPanelAlpha: (options) => {
      return options['style']['leftFilterPanelAlpha'];
    },

    /**
     * Gets the right filter panel color.
     * @param {object} options The object containing data and specifications for the component.
     * @return {string} The right filter panel color.
     */
    getRightFilterPanelColor: (options) => {
      return options['style']['rightFilterPanelColor'];
    },

    /**
     * Gets the right filter panel opacity.
     * @param {object} options The object containing data and specifications for the component.
     * @return {number} The right filter panel opacity.
     */
    getRightFilterPanelAlpha: (options) => {
      return options['style']['rightFilterPanelAlpha'];
    }
  };

  const OverviewUtils = {
    supportsTouch: () => {
      return dvt.Agent.isTouchDevice();
    },

    /**
     * startTime - the start time of timeline in millis
     * endTime - the end of the timeline in millis
     * time - the time in question
     * width - the width of the element
     *
     * @return the position relative to the width of the element
     */
    getDatePosition: (startTime, endTime, time, width) => {
      var number = (time - startTime) * width;
      var denominator = endTime - startTime;
      if (number == 0 || denominator == 0) return 0;

      return number / denominator;
    },

    /**
     * @return time in millis
     */
    getPositionDate: (startTime, endTime, pos, width) => {
      var number = pos * (endTime - startTime);
      if (number === 0 || width === 0) return startTime;

      return number / width + startTime;
    }
  };

  /**
   * Renderer for Overview.
   * @class
   */
  const DvtOverviewRenderer = {
    /**
     * Renders an overview.
     * @param {Overview} overview The overview being rendered.
     */
    renderOverview: (overview) => {
      if (overview.isBackgroundRendered()) DvtOverviewRenderer._renderBackground(overview);

      var interactive = overview._callback != null || overview._callbackObj != null;

      if (interactive) DvtOverviewRenderer._renderSlidingWindow(overview);

      DvtOverviewRenderer._renderTimeAxis(overview);
      DvtOverviewRenderer._parseFilledTimeRanges(overview);
      DvtOverviewRenderer._updateReferenceLines(overview);

      // render data
      overview.renderData(overview.Width, overview.Height);

      if (interactive) {
        DvtOverviewRenderer._createBorderAroundSlidingWindow(overview);

        // updates the position and width of sliding window and borders around window
        DvtOverviewRenderer._updateSlidingWindow(overview);
      }
    },

    /**
     * Renders the background of an overview.
     * @param {Overview} overveiw The overview being rendered.
     * @private
     */
    _renderBackground: (overview) => {
      // draw a background shape covering all area to capture all mouse events
      var background = new dvt.Rect(overview.getCtx(), 0, 0, overview.Width, overview.Height, 'bg');
      background.setSolidFill(overview._overviewBackgroundColor);

      // Do not antialias the background
      background.setPixelHinting(true);

      overview.addChild(background);
    },

    /**
     * Renders the sliding window of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _renderSlidingWindow: (overview) => {
      var width = overview.Width;
      var height = overview.Height;

      // draw sliding window first so that it is under the markers
      var slidingWindow = new dvt.Rect(overview.getCtx(), 0, 0, width, height, 'window');
      slidingWindow.setSolidFill(overview._windowBackgroundColor, overview._windowBackgroundAlpha);

      // Do not antialias the Timeline Overview
      slidingWindow.setPixelHinting(true);

      if (!overview.isFeatureOff('zoom')) {
        var handleSize = overview.getHandleSize();
        var handleStart = overview.getHandleStart();
        var grippySize = overview.getGrippySize();
        var cursor;

        if (overview.isVerticalScrollingEnabled()) {
          var slidingWindowWidth = overview.getSlidingWindowWidth();

          var topHandleCmds =
            dvt.PathUtils.moveTo(0, 0) +
            dvt.PathUtils.quadTo(3, 6, 8, 8) +
            dvt.PathUtils.lineTo(28, 8) +
            dvt.PathUtils.quadTo(33, 6, 36, 0);
          dvt.PathUtils.closePath();
          var bottomHandleCmds =
            dvt.PathUtils.moveTo(0, 0) +
            dvt.PathUtils.quadTo(3, -6, 8, -8) +
            dvt.PathUtils.lineTo(28, -8) +
            dvt.PathUtils.quadTo(33, -6, 36, 0);
          dvt.PathUtils.closePath();
          var topHandleBackground = new dvt.Rect(
            overview.getCtx(),
            0,
            0,
            slidingWindowWidth,
            handleSize,
            'thb'
          );
          var bottomHandleBackground = new dvt.Rect(
            overview.getCtx(),
            0,
            0,
            slidingWindowWidth,
            handleSize,
            'bhb'
          );
          cursor = 'row-resize';

          if (overview._vertHandleBackgroundClass) {
            var topGrippy = DvtOverviewRenderer._createGrippyImage(
              overview,
              slidingWindowWidth,
              grippySize,
              true
            );
            var bottomGrippy = DvtOverviewRenderer._createGrippyImage(
              overview,
              slidingWindowWidth,
              grippySize,
              true
            );
          } else {
            topGrippy = DvtOverviewRenderer._createGrippy(overview, true);
            bottomGrippy = DvtOverviewRenderer._createGrippy(overview, true);
          }

          topHandleBackground.setSolidFill(overview._windowBackgroundColor, 0);
          bottomHandleBackground.setSolidFill(overview._windowBackgroundColor, 0);

          // Do not antialias the handle backgrounds
          topHandleBackground.setPixelHinting(true);
          bottomHandleBackground.setPixelHinting(true);

          var topHandle = new dvt.Path(overview.getCtx(), topHandleCmds, 'th');
          var bottomHandle = new dvt.Path(overview.getCtx(), bottomHandleCmds, 'bh');
          topHandle.setSolidFill(overview._handleFillColor);
          topHandle.setSolidStroke(overview._handleFillColor);
          bottomHandle.setSolidFill(overview._handleFillColor);
          bottomHandle.setSolidStroke(overview._handleFillColor);

          // if the handle color is the same as the background color, it should not have antialiasing so it does not appear visible
          if (overview._windowBackgroundColor === overview._handleFillColor) {
            topHandle.setPixelHinting(true);
            bottomHandle.setPixelHinting(true);
          }

          // sets the resize cursor
          topHandleBackground.setCursor(cursor);
          bottomHandleBackground.setCursor(cursor);
          topHandle.setCursor(cursor);
          bottomHandle.setCursor(cursor);
          topGrippy.setCursor(cursor);
          bottomGrippy.setCursor(cursor);

          slidingWindow.addChild(topHandleBackground);
          overview._windowTopHandleBackground = topHandleBackground;
          slidingWindow.addChild(topHandle);
          overview._windowTopHandle = topHandle;
          slidingWindow.addChild(topGrippy);
          overview._windowTopGrippy = topGrippy;
          slidingWindow.addChild(bottomHandleBackground);
          overview._windowBottomHandleBackground = bottomHandleBackground;
          slidingWindow.addChild(bottomHandle);
          overview._windowBottomHandle = bottomHandle;
          slidingWindow.addChild(bottomGrippy);
          overview._windowBottomGrippy = bottomGrippy;
        }
        if (overview.isHorizontalScrollingEnabled()) {
          var slidingWindowHeight = overview.getSlidingWindowHeight();

          var leftHandleCmds =
            dvt.PathUtils.moveTo(0, 0) +
            dvt.PathUtils.quadTo(6, 3, 8, 8) +
            dvt.PathUtils.lineTo(8, 28) +
            dvt.PathUtils.quadTo(6, 33, 0, 36);
          dvt.PathUtils.closePath();
          var rightHandleCmds =
            dvt.PathUtils.moveTo(0, 0) +
            dvt.PathUtils.quadTo(-6, 3, -8, 8) +
            dvt.PathUtils.lineTo(-8, 28) +
            dvt.PathUtils.quadTo(-6, 33, 0, 36);
          dvt.PathUtils.closePath();
          var leftHandleBackground = new dvt.Rect(
            overview.getCtx(),
            0 - handleStart,
            0,
            handleSize,
            slidingWindowHeight,
            'lhb'
          );
          var rightHandleBackground = new dvt.Rect(
            overview.getCtx(),
            handleStart,
            0,
            handleSize,
            slidingWindowHeight,
            'rhb'
          );
          cursor = 'col-resize';

          if (overview._horHandleBackgroundClass) {
            var leftGrippy = DvtOverviewRenderer._createGrippyImage(
              overview,
              grippySize,
              slidingWindowHeight,
              false
            );
            var rightGrippy = DvtOverviewRenderer._createGrippyImage(
              overview,
              grippySize,
              slidingWindowHeight,
              false
            );
          } else {
            leftGrippy = DvtOverviewRenderer._createGrippy(overview, false);
            rightGrippy = DvtOverviewRenderer._createGrippy(overview, false);
          }

          leftHandleBackground.setSolidFill(overview._windowBackgroundColor, 0);
          rightHandleBackground.setSolidFill(overview._windowBackgroundColor, 0);

          // Do not antialias the handle backgrounds
          leftHandleBackground.setPixelHinting(true);
          rightHandleBackground.setPixelHinting(true);

          var leftHandle = new dvt.Path(overview.getCtx(), leftHandleCmds, 'lh');
          var rightHandle = new dvt.Path(overview.getCtx(), rightHandleCmds, 'rh');
          leftHandle.setSolidFill(overview._handleFillColor);
          leftHandle.setSolidStroke(overview._handleFillColor);
          rightHandle.setSolidFill(overview._handleFillColor);
          rightHandle.setSolidStroke(overview._handleFillColor);

          // if the handle color is the same as the background color, it should not have antialiasing so it does not appear visible
          if (overview._windowBackgroundColor === overview._handleFillColor) {
            leftHandle.setPixelHinting(true);
            rightHandle.setPixelHinting(true);
          }

          // sets the resize cursor
          leftHandleBackground.setCursor(cursor);
          rightHandleBackground.setCursor(cursor);
          leftHandle.setCursor(cursor);
          rightHandle.setCursor(cursor);
          leftGrippy.setCursor(cursor);
          rightGrippy.setCursor(cursor);

          slidingWindow.addChild(leftHandleBackground);
          overview._windowLeftHandleBackground = leftHandleBackground;
          slidingWindow.addChild(leftHandle);
          overview._windowLeftHandle = leftHandle;
          slidingWindow.addChild(leftGrippy);
          overview._windowLeftGrippy = leftGrippy;
          slidingWindow.addChild(rightHandleBackground);
          overview._windowRightHandleBackground = rightHandleBackground;
          slidingWindow.addChild(rightHandle);
          overview._windowRightHandle = rightHandle;
          slidingWindow.addChild(rightGrippy);
          overview._windowRightGrippy = rightGrippy;
        }
      }

      // sets cursor AFTER adding child since toolkit adds a group and the cursor would be set on group instead
      slidingWindow.setCursor('move');
      overview.addChild(slidingWindow);
      overview._slidingWindow = slidingWindow;

      DvtOverviewRenderer._renderTimeAxisTopBar(overview);
      DvtOverviewRenderer._renderLeftAndRightFilters(overview, handleStart);
    },

    /**
     * Renders the grippy from an image.
     * @param {Overview} overview The overview being rendered.
     * @param {number} width The window width.
     * @param {number} height The window height.
     * @param {boolean} isVertical Whether or not this is a vertical grippy.
     * @private
     */
    _createGrippyImage: (overview, width, height, isVertical) => {
      var ctx = overview.getCtx();
      var grippy;
      if (!isVertical) {
        var posX = width / 2;
        var iconStyle = dvt.ToolkitUtils.getIconStyle(ctx, overview._horHandleBackgroundClass);
        grippy = dvt.OutputText.createIcon(ctx, {
          style: iconStyle,
          size: overview._horHandleSize,
          pos: { x: posX, y: 0 }
        });
        grippy.setId('hgrpy');
      } else {
        var posY = height / 2;
        var iconStyleY = dvt.ToolkitUtils.getIconStyle(ctx, overview._vertHandleBackgroundClass);
        grippy = dvt.OutputText.createIcon(ctx, {
          style: iconStyleY,
          size: overview._vertHandleSize,
          pos: { x: 0, y: posY }
        });
        grippy.setId('vgrpy');
      }
      grippy.setMouseEnabled(false);
      // wrap in a container so that subsequent translates can be applied
      var container = new dvt.Container(ctx);
      container.addChild(grippy);
      return container;
    },

    /**
     * Renders the dots in the grippy.
     * @param {Overview} overview The overview being rendered.
     * @param {boolean} isVertical Whether or not this is a vertical grippy.
     * @private
     */
    _createGrippy: (overview, isVertical) => {
      var gap = 2; // gap between dots
      var count = 9; // how many dots to draw
      var color = overview._handleTextureColor; // color of the dots

      if (isVertical) {
        var grippy = new dvt.Container(overview.getCtx(), 'g', 'vgrpy');
        var startx = 8;
        var starty = 3; // start y location of dots relative to container
        for (var i = 0; i < count; i++) {
          var dot = new dvt.Line(
            overview.getCtx(),
            startx + i * gap,
            starty,
            startx + i * gap + 1,
            starty,
            'dot1' + i
          );
          dot.setSolidStroke(color);
          grippy.addChild(dot);

          starty = starty + gap;
          dot = new dvt.Line(
            overview.getCtx(),
            startx + 1 + i * gap,
            starty,
            startx + 1 + i * gap + 1,
            starty,
            'dot2' + i
          );
          dot.setSolidStroke(color);
          grippy.addChild(dot);

          starty = starty + gap;
          dot = new dvt.Line(
            overview.getCtx(),
            startx + i * gap,
            starty,
            startx + i * gap + 1,
            starty,
            'dot3' + i
          );
          dot.setSolidStroke(color);
          grippy.addChild(dot);

          starty = 3;
        }

        dot = new dvt.Line(
          overview.getCtx(),
          startx + count * gap,
          starty,
          startx + count * gap + 1,
          starty,
          'dot4'
        );
        dot.setSolidStroke(color);
        grippy.addChild(dot);
        starty = starty + gap * 2;
        dot = new dvt.Line(
          overview.getCtx(),
          startx + count * gap,
          starty,
          startx + count * gap + 1,
          starty,
          'dot5'
        );
        dot.setSolidStroke(color);
        grippy.addChild(dot);
      } else {
        grippy = new dvt.Container(overview.getCtx(), 'g', 'hgrpy');
        startx = 3; // start x location of dots relative to container
        starty = 8;
        for (i = 0; i < count; i++) {
          dot = new dvt.Line(
            overview.getCtx(),
            startx,
            starty + i * gap,
            startx,
            starty + i * gap + 1,
            'dot1' + i
          );
          dot.setSolidStroke(color);
          grippy.addChild(dot);

          startx = startx + gap;
          dot = new dvt.Line(
            overview.getCtx(),
            startx,
            starty + 1 + i * gap,
            startx,
            starty + 1 + i * gap + 1,
            'dot2' + i
          );
          dot.setSolidStroke(color);
          grippy.addChild(dot);

          startx = startx + gap;
          dot = new dvt.Line(
            overview.getCtx(),
            startx,
            starty + i * gap,
            startx,
            starty + i * gap + 1,
            'dot3' + i
          );
          dot.setSolidStroke(color);
          grippy.addChild(dot);

          startx = 3;
        }

        dot = new dvt.Line(
          overview.getCtx(),
          startx,
          starty + count * gap,
          startx,
          starty + count * gap + 1,
          'dot4'
        );
        dot.setSolidStroke(color);
        grippy.addChild(dot);
        startx = startx + gap * 2;
        dot = new dvt.Line(
          overview.getCtx(),
          startx,
          starty + count * gap,
          startx,
          starty + count * gap + 1,
          'dot5'
        );
        dot.setSolidStroke(color);
        grippy.addChild(dot);
      }

      // Do not antialias the grippy
      grippy.setPixelHinting(true);

      return grippy;
    },

    /**
     * Renders the border of the sliding window of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _createBorderAroundSlidingWindow: (overview) => {
      var width = overview.Width;
      var height = overview.Height;

      // add the left and right grip last since we want them over the markers
      var slidingWindow = overview.getSlidingWindow();
      var halfBorderWidth = DvtOverviewStyleUtils._DEFAULT_WINDOW_BORDER_WIDTH / 2;
      if (overview.isVertical()) {
        var top = slidingWindow.getY();
        var topCenter = top + halfBorderWidth;
        var bottom = top + slidingWindow.getHeight();
        var bottomCenter = bottom - halfBorderWidth;
        var left = 0;
        var leftCenter = halfBorderWidth;
        var right = width;
        var rightCenter = right - halfBorderWidth;

        var leftHandle = new dvt.Line(overview.getCtx(), left, topCenter, width, topCenter, 'lh');
        var rightHandle = new dvt.Line(
          overview.getCtx(),
          left,
          bottomCenter,
          width,
          bottomCenter,
          'rh'
        );

        // leftTopBar and rightTopBar are only visible in fusion skins
        var leftTopBar = new dvt.Line(overview.getCtx(), leftCenter, 0, leftCenter, top, 'ltb');
        var rightTopBar = new dvt.Line(
          overview.getCtx(),
          leftCenter,
          bottom,
          leftCenter,
          height,
          'rtb'
        );

        var bottomBar = new dvt.Line(overview.getCtx(), rightCenter, top, rightCenter, bottom, 'bb');
        var topBar = new dvt.Line(overview.getCtx(), leftCenter, top, leftCenter, bottom, 'tb');
      } else {
        top = 0;
        topCenter = top + halfBorderWidth;
        bottom = height;
        bottomCenter = bottom - halfBorderWidth;
        left = slidingWindow.getX();
        leftCenter = left + halfBorderWidth;
        right = left + slidingWindow.getWidth();
        rightCenter = right - halfBorderWidth;

        leftHandle = new dvt.Line(overview.getCtx(), leftCenter, top, leftCenter, bottom, 'lh');
        rightHandle = new dvt.Line(overview.getCtx(), rightCenter, top, rightCenter, bottom, 'rh');

        // leftTopBar and rightTopBar are only visible in fusion skins
        leftTopBar = new dvt.Line(overview.getCtx(), 0, topCenter, left + 1, topCenter, 'ltb');
        rightTopBar = new dvt.Line(overview.getCtx(), right - 1, topCenter, width, topCenter, 'rtb');

        bottomBar = new dvt.Line(overview.getCtx(), left, bottomCenter, right, bottomCenter, 'bb');
        topBar = new dvt.Line(overview.getCtx(), left, topCenter, right, topCenter, 'tb');
      }

      // Do not antialias the sliding window borders
      leftHandle.setPixelHinting(true);
      rightHandle.setPixelHinting(true);
      leftTopBar.setPixelHinting(true);
      rightTopBar.setPixelHinting(true);
      bottomBar.setPixelHinting(true);
      topBar.setPixelHinting(true);

      if (overview._windowBorderLeftStyle !== 'none')
        leftHandle.setSolidStroke(overview._windowBorderLeftColor);
      overview.addChild(leftHandle);
      overview._leftHandle = leftHandle;

      if (overview._windowBorderRightStyle !== 'none')
        rightHandle.setSolidStroke(overview._windowBorderRightColor);
      overview.addChild(rightHandle);
      overview._rightHandle = rightHandle;

      if (overview._borderTopStyle !== 'none' && overview._borderTopColor) {
        leftTopBar.setSolidStroke(overview._borderTopColor);
        rightTopBar.setSolidStroke(overview._borderTopColor);
      }
      overview.addChild(leftTopBar);
      overview.addChild(rightTopBar);

      if (overview._windowBorderBottomStyle !== 'none')
        bottomBar.setSolidStroke(overview._windowBorderBottomColor);
      overview.addChild(bottomBar);

      if (overview._windowBorderTopStyle !== 'none')
        topBar.setSolidStroke(overview._windowBorderTopColor);
      overview.addChild(topBar);
    },

    /**
     * Updates the border positioning of the sliding window of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _updateBorderAroundSlidingWindow: (overview) => {
      var slidingWindow = overview.getSlidingWindow();
      var halfBorderWidth = DvtOverviewStyleUtils._DEFAULT_WINDOW_BORDER_WIDTH / 2;

      var leftHandle = overview.getLeftHandle();
      var rightHandle = overview.getRightHandle();
      var leftTopBar = overview.getLeftTopBar();
      var rightTopBar = overview.getRightTopBar();
      var bottomBar = overview.getBottomBar();
      var topBar = overview.getTopBar();

      if (overview.isVertical()) {
        if (overview.isHorizontalScrollingEnabled()) {
          var slidingWindowWidth = slidingWindow.getWidth();
          var slidingWindowPosX = overview.getSlidingWindowPosX(slidingWindow);
          var leftCenter = slidingWindowPosX + halfBorderWidth;
          var rightCenter = slidingWindowPosX + slidingWindowWidth - halfBorderWidth;

          overview.setLinePosX(leftHandle, leftCenter, rightCenter);
          overview.setLinePosX(rightHandle, leftCenter, rightCenter);
          overview.setLinePosX(topBar, leftCenter, leftCenter);
          overview.setLinePosX(bottomBar, rightCenter, rightCenter);
        }
        if (overview.isVerticalScrollingEnabled()) {
          var slidingWindowHeight = slidingWindow.getHeight();
          var slidingWindowPosY = overview.getSlidingWindowPosY(slidingWindow);
          var topCenter = slidingWindowPosY + halfBorderWidth;
          var bottomCenter = slidingWindowPosY + slidingWindowHeight - halfBorderWidth;

          overview.setLinePosY(leftHandle, topCenter, topCenter);
          overview.setLinePosY(rightHandle, bottomCenter, bottomCenter);
          overview.setLinePosY(topBar, topCenter, bottomCenter);
          overview.setLinePosY(bottomBar, topCenter, bottomCenter);
        }
      } else {
        if (overview.isHorizontalScrollingEnabled()) {
          slidingWindowWidth = slidingWindow.getWidth();
          slidingWindowPosX = overview.getSlidingWindowPosX(slidingWindow);
          leftCenter = slidingWindowPosX + halfBorderWidth;
          rightCenter = slidingWindowPosX + slidingWindowWidth - halfBorderWidth;

          overview.setLinePosX(leftHandle, leftCenter, leftCenter);
          overview.setLinePosX(rightHandle, rightCenter, rightCenter);
          overview.setLinePosX(topBar, leftCenter, rightCenter);
          overview.setLinePosX(bottomBar, leftCenter, rightCenter);
        }

        if (overview.isVerticalScrollingEnabled()) {
          slidingWindowHeight = slidingWindow.getHeight();
          slidingWindowPosY = overview.getSlidingWindowPosY(slidingWindow);
          topCenter = slidingWindowPosY + halfBorderWidth;
          bottomCenter = slidingWindowPosY + slidingWindowHeight - halfBorderWidth;

          overview.setLinePosY(leftHandle, topCenter, bottomCenter);
          overview.setLinePosY(rightHandle, topCenter, bottomCenter);
          overview.setLinePosY(topBar, topCenter, topCenter);
          overview.setLinePosY(bottomBar, bottomCenter, bottomCenter);
        }
      }

      overview.setLinePos(leftTopBar, -1, overview.getSlidingWindowPos(slidingWindow));
      overview.setLinePos(rightTopBar, overview.getLinePos1(rightHandle), -1);
    },

    /**
     * Updates the positioning of the sliding window of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _updateSlidingWindow: (overview) => {
      var window = overview.getSlidingWindow();
      var width = overview.Width;
      var height = overview.Height;

      // find the position relative to the width of timeline overview
      if (overview.isHorizontalScrollingEnabled()) {
        var x1Pos = Math.max(
          overview.getMinimumPositionX(),
          OverviewUtils.getDatePosition(overview._xMin, overview._xMax, overview._x1, width)
        );
        var posX2Max = Math.max(
          overview.getMinimumPositionX(),
          OverviewUtils.getDatePosition(overview._xMin, overview._xMax, overview._x2, width)
        );
        var x2Pos = Math.min(overview.getMaximumPositionX(), posX2Max);

        if (overview.isRTL()) overview.setSlidingWindowPosX(window, width - x2Pos);
        else overview.setSlidingWindowPosX(window, x1Pos);
        DvtOverviewRenderer._setSlidingWindowWidth(overview, window, x2Pos - x1Pos);
      } else DvtOverviewRenderer._setSlidingWindowWidth(overview, window, width);
      if (overview.isVerticalScrollingEnabled()) {
        var y1Pos = Math.max(
          overview.getMinimumPositionY(),
          OverviewUtils.getDatePosition(overview._yMin, overview._yMax, overview._y1, height)
        );
        var posY2Max = Math.max(
          overview.getMinimumPositionY(),
          OverviewUtils.getDatePosition(overview._yMin, overview._yMax, overview._y2, height)
        );
        var y2Pos = Math.min(overview.getMaximumPositionY(), posY2Max);

        overview.setSlidingWindowPosY(window, y1Pos);
        DvtOverviewRenderer._setSlidingWindowHeight(overview, window, y2Pos - y1Pos);
      } else DvtOverviewRenderer._setSlidingWindowHeight(overview, window, height);

      DvtOverviewRenderer._updateBorderAroundSlidingWindow(overview);
    },

    /**
     * Updates the width of the sliding window of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @param {dvt.Rectangle} slidingWindow The sliding window of the overview.
     * @param {number} width The new width of the sliding window.
     * @private
     */
    _setSlidingWindowWidth: (overview, slidingWindow, width) => {
      // make sure the width is within the maximum and minimum sizes specified
      width = Math.min(
        overview.getMaximumWindowWidth(),
        Math.max(overview.getMinimumWindowWidth(), width)
      );
      slidingWindow.setWidth(width);

      // update left and right filter if one is specified
      if (overview.isLeftAndRightFilterRendered()) {
        var rightStart = overview.getSlidingWindowPosX(slidingWindow) + width;
        var rightBackground = overview.getRightBackground();
        rightBackground.setX(rightStart);
        rightBackground.setWidth(Math.max(0, overview.Width - rightStart));

        // updates the background resize handle for touch
        if (OverviewUtils.supportsTouch() && !overview.isFeatureOff('zoom')) {
          var rightBackgroundHandle = overview.getRightBackgroundHandle();
          rightBackgroundHandle.setX(rightStart);
        }
      }

      // if resize feature is off then there's nothing else to do
      if (overview.isFeatureOff('zoom')) return;

      // update the resize handles
      if (overview.isHorizontalScrollingEnabled()) {
        var rightHandleBackground = overview._windowRightHandleBackground;
        var rightHandle = overview._windowRightHandle;
        var rightGrippy = overview._windowRightGrippy;

        rightHandle.setTranslateX(width);
        rightHandleBackground.setTranslateX(width - overview.getHandleSize());
        rightGrippy.setTranslateX(width - overview.getGrippySize());
      }
      if (overview.isVerticalScrollingEnabled()) {
        var handleX = (slidingWindow.getWidth() - 36) / 2;
        if (overview._vertHandleBackgroundClass) var grippyX = width / 2;
        else grippyX = handleX;

        var topHandleBackground = overview._windowTopHandleBackground;
        var topHandle = overview._windowTopHandle;
        var topGrippy = overview._windowTopGrippy;

        topHandle.setTranslateX(handleX);
        topHandleBackground.setWidth(width);
        topGrippy.setTranslateX(grippyX);

        var bottomHandleBackground = overview._windowBottomHandleBackground;
        var bottomHandle = overview._windowBottomHandle;
        var bottomGrippy = overview._windowBottomGrippy;

        bottomHandle.setTranslateX(handleX);
        bottomHandleBackground.setWidth(width);
        bottomGrippy.setTranslateX(grippyX);
      }
    },

    /**
     * Updates the height of the sliding window of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @param {dvt.Rectangle} slidingWindow The sliding window of the overview.
     * @param {number} height The new height of the sliding window.
     * @private
     */
    _setSlidingWindowHeight: (overview, slidingWindow, height) => {
      // make sure the height is within the maximum and minimum sizes specified
      height = Math.min(
        overview.getMaximumWindowHeight(),
        Math.max(overview.getMinimumWindowHeight(), height)
      );
      slidingWindow.setHeight(height);

      // if resize feature is off then there's nothing else to do
      if (overview.isFeatureOff('zoom')) return;

      // update the resize handles
      if (overview.isHorizontalScrollingEnabled()) {
        var handleY = (height - 36) / 2;
        if (overview._horHandleBackgroundClass) var grippyY = height / 2;
        else grippyY = handleY;

        var leftHandleBackground = overview._windowLeftHandleBackground;
        var leftHandle = overview._windowLeftHandle;
        var leftGrippy = overview._windowLeftGrippy;

        leftHandle.setTranslateY(handleY);
        leftHandleBackground.setHeight(height);
        leftGrippy.setTranslateY(grippyY);

        var rightHandleBackground = overview._windowRightHandleBackground;
        var rightHandle = overview._windowRightHandle;
        var rightGrippy = overview._windowRightGrippy;

        rightHandle.setTranslateY(handleY);
        rightHandleBackground.setHeight(height);
        rightGrippy.setTranslateY(grippyY);
      }
      if (overview.isVerticalScrollingEnabled()) {
        var bottomHandleBackground = overview._windowBottomHandleBackground;
        var bottomHandle = overview._windowBottomHandle;
        var bottomGrippy = overview._windowBottomGrippy;

        bottomHandle.setTranslateY(height);
        bottomHandleBackground.setTranslateY(height - overview.getHandleSize());
        bottomGrippy.setTranslateY(height - overview.getGrippySize());
      }
    },

    /**
     * Renders the top bar of the time axis of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _renderTimeAxisTopBar: (overview) => {
      var width = overview.Width;
      var height = overview.Height;

      // border above time axis
      if (overview.isVertical()) {
        if (overview.isRTL())
          var timeAxisTopBar = new dvt.Line(
            overview.getCtx(),
            overview.getTimeAxisWidth(),
            0,
            overview.getTimeAxisWidth(),
            height,
            'tab'
          );
        else
          timeAxisTopBar = new dvt.Line(
            overview.getCtx(),
            width - overview.getTimeAxisWidth(),
            0,
            width - overview.getTimeAxisWidth(),
            height,
            'tab'
          );
      } else {
        if (overview.isOverviewAbove())
          timeAxisTopBar = new dvt.Line(
            overview.getCtx(),
            0,
            overview.getTimeAxisHeight(),
            width,
            overview.getTimeAxisHeight(),
            'tab'
          );
        else
          timeAxisTopBar = new dvt.Line(
            overview.getCtx(),
            0,
            height - overview.getTimeAxisHeight(),
            width,
            height - overview.getTimeAxisHeight(),
            'tab'
          );
      }
      timeAxisTopBar.setSolidStroke(overview._timeAxisBarColor, overview._timeAxisBarOpacity);

      // Do not antialias the time axis top bar
      timeAxisTopBar.setPixelHinting(true);
      overview._timeAxisTopBar = timeAxisTopBar;

      overview.addChild(timeAxisTopBar);
    },

    /**
     * Renders the left and right filters of an overveiw.
     * @param {Overview} overview The overview being rendered.
     * @param {nubmer} handleStart The start position of the window handle.
     * @private
     */
    _renderLeftAndRightFilters: (overview, handleStart) => {
      var width = overview.Width;
      var height = overview.Height;
      overview._leftBackground = undefined;
      overview._rightBackground = undefined;
      overview._leftBackgroundResizeHandle = undefined;
      overview._rightBackgroundResizeHandle = undefined;

      if (overview.isLeftAndRightFilterRendered()) {
        if (overview.isVertical()) {
          var leftBackground = new dvt.Rect(overview.getCtx(), 0, 0, width, 0, 'lbg');
          var rightBackground = new dvt.Rect(overview.getCtx(), 0, 0, width, 0, 'rbg');
        } else {
          leftBackground = new dvt.Rect(overview.getCtx(), 0, 0, 0, height, 'lbg');
          rightBackground = new dvt.Rect(overview.getCtx(), 0, 0, 0, height, 'rbg');
        }

        leftBackground.setSolidFill(overview._leftFilterPanelColor, overview._leftFilterPanelAlpha);
        overview.addChildAt(leftBackground, 0);
        rightBackground.setSolidFill(
          overview._rightFilterPanelColor,
          overview._rightFilterPanelAlpha
        );
        overview.addChildAt(rightBackground, 1);

        overview._leftBackground = leftBackground;
        overview._rightBackground = rightBackground;

        // the left and right background resize handle are needed for touch because the touch area for resize handle goes
        // beyond the handle and into the left and right background area, so we'll need something on top of the background
        if (OverviewUtils.supportsTouch() && handleStart !== undefined && handleStart !== null) {
          if (overview.isVertical()) {
            var leftBackgroundResizeHandle = new dvt.Rect(
              overview.getCtx(),
              0,
              0,
              width,
              handleStart,
              'lbgrh'
            );
            var rightBackgroundResizeHandle = new dvt.Rect(
              overview.getCtx(),
              0,
              0,
              width,
              handleStart,
              'rbgrh'
            );
          } else {
            leftBackgroundResizeHandle = new dvt.Rect(
              overview.getCtx(),
              0,
              0,
              handleStart,
              height,
              'lbgrh'
            );
            rightBackgroundResizeHandle = new dvt.Rect(
              overview.getCtx(),
              0,
              0,
              handleStart,
              height,
              'rbgrh'
            );
          }

          leftBackgroundResizeHandle.setSolidFill(overview._leftFilterPanelColor, 0);
          overview.addChildAt(leftBackgroundResizeHandle, 2);
          rightBackgroundResizeHandle.setSolidFill(overview._rightFilterPanelColor, 0);
          overview.addChildAt(rightBackgroundResizeHandle, 3);

          overview._leftBackgroundResizeHandle = leftBackgroundResizeHandle;
          overview._rightBackgroundResizeHandle = rightBackgroundResizeHandle;
        }
      }
    },

    /**
     * Renders the time axis of the overview.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _renderTimeAxis: (overview) => {
      if (overview._ticks == null) return;

      var width = overview.Width;
      var height = overview.Height;
      var vertical = overview.isVertical();
      var size = overview.getOverviewSize();

      for (var i = 0; i < overview._ticks.length; i++) {
        var child = overview._ticks[i];

        var time = parseInt(child['time'], 10);
        if (vertical) var time_pos = overview.getDateYPosition(time);
        else time_pos = overview.getDateXPosition(time);
        var label = child['label'];

        var maxWidth = 0;
        if (i + 1 < overview._ticks.length) {
          var next_time = parseInt(overview._ticks[i + 1]['time'], 10);
          if (vertical) var next_time_pos = overview.getDateYPosition(next_time);
          else next_time_pos = overview.getDateXPosition(next_time);
          maxWidth = next_time_pos - time_pos;
        } else {
          // last label
          maxWidth = size - time_pos;
        }

        if (overview.isHorizontalRTL()) time_pos = size - time_pos;

        if (vertical) maxWidth = width;

        maxWidth -= DvtOverviewStyleUtils._DEFAULT_AXIS_LABEL_PADDING * 2;
        DvtOverviewRenderer._addTick(overview, time_pos, width, height, 'tick' + i);
        DvtOverviewRenderer._addLabel(
          overview,
          time_pos,
          label,
          height,
          maxWidth,
          'label' + i,
          overview._labelStyle
        );
      }
    },

    /**
     * Creates a tick mark of the time axis.
     * @param {Overview} overview The overview being rendered.
     * @param {number} pos The position of the tick mark.
     * @param {number} width The width of the tick mark.
     * @param {number} height The height of the tick mark.
     * @param {String} id The id of the tick mark.
     * @private
     */
    _addTick: (overview, pos, width, height, id) => {
      if (overview.isVertical()) var line = new dvt.Line(overview.getCtx(), 0, pos, width, pos, id);
      else line = new dvt.Line(overview.getCtx(), pos, 0, pos, height, id);
      var stroke = new dvt.Stroke(overview._timeIndicatorColor, 1, 1, false, { dashArray: '3' });
      line.setStroke(stroke);

      // Do not antialias tick marks
      line.setPixelHinting(true);

      overview.addChild(line);
    },

    /**
     * Creates a label of the time axis.
     * @param {Overview} overview The overview being rendered.
     * @param {number} pos The position of the label.
     * @param {String} text The text of the label.
     * @param {number} height The height of the label.
     * @param {number} maxWidth The maximum width of the label.
     * @param {String} id The id of the label.
     * @param {dvt.CSSStyle} labelStyle The styling of the label.
     * @private
     */
    _addLabel: (overview, pos, text, height, maxWidth, id, labelStyle) => {
      if (overview.isVertical()) {
        var label = new dvt.OutputText(overview.getCtx(), text, 4, pos, id);
        label.setCSSStyle(labelStyle);
        if (overview.isRTL()) {
          var dim = label.getDimensions();
          label.setX(Math.max(4, overview.Width - dim.w - 4));
        }
      } else {
        const labelYOffset = overview._labelYOffset;
        const yOffset = labelYOffset ? 2 : -2;
        if (overview.isOverviewAbove()) var y = 2;
        else y = height - overview.getTimeAxisHeight() + yOffset;

        var padding = DvtOverviewStyleUtils._DEFAULT_AXIS_LABEL_PADDING;
        label = new dvt.OutputText(overview.getCtx(), text, pos + padding, y, id);
        label.setCSSStyle(labelStyle);
        if (overview.isHorizontalRTL()) {
          dim = label.getDimensions();
          label.setX(pos - Math.min(dim.w, maxWidth) - padding);
        }
      }

      dvt.TextUtils.fitText(label, maxWidth, Infinity, overview);

      // save the raw text for tooltip
      label._rawText = label.getUntruncatedTextString();
    },

    /**
     * Parses through formatted time ranges.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _parseFilledTimeRanges: (overview) => {
      if (overview._formattedTimeRanges == null) return;

      // draw filled time ranges so that it is over the sliding window but under the markers
      for (var i = 0; i < overview._formattedTimeRanges.length; i++) {
        var ftr = overview._formattedTimeRanges[i];
        DvtOverviewRenderer._addFilledTimeRange(overview, ftr, overview.Width, overview.Height);
      }
    },

    /**
     * Creates a formatted time range.
     * @param {Overview} overview The overview being rendered.
     * @param {object} elem The formatted time range.
     * @param {number} width The width of the overview.
     * @param {number} height The height of the overview.
     * @private
     */
    _addFilledTimeRange: (overview, elem, width, height) => {
      var rangeStart = parseInt(elem['rs'], 10);
      var rangeEnd = parseInt(elem['re'], 10);

      if (rangeStart != null && rangeEnd != null) {
        var color = elem['c'];
        var size = overview.getOverviewSize();

        if (!overview.isVertical()) {
          var rangeStart_pos = overview.getDateXPosition(rangeStart);
          var rangeEnd_pos = overview.getDateXPosition(rangeEnd);
        } else {
          rangeStart_pos = overview.getDateYPosition(rangeStart);
          rangeEnd_pos = overview.getDateYPosition(rangeEnd);
        }
        var rangeWidth = rangeEnd_pos - rangeStart_pos;
        if (overview.isHorizontalRTL()) {
          rangeStart_pos = size - rangeStart_pos - rangeWidth;
        }
        var displayable;
        if (overview.isVertical())
          displayable = new dvt.Rect(
            overview.getCtx(),
            0,
            rangeStart_pos,
            width - overview.getTimeAxisWidth(),
            rangeWidth,
            'ftr'
          );
        else {
          var overviewAbove = overview.isOverviewAbove() ? overview.getTimeAxisHeight() : 0;
          displayable = new dvt.Rect(
            overview.getCtx(),
            rangeStart_pos,
            overviewAbove,
            rangeWidth,
            height - overview.getTimeAxisHeight(),
            'ftr'
          );
        }

        if (color != null) displayable.setSolidFill(color, 0.4);
        displayable.setCursor('move');

        // Do not antialias filled time range
        displayable.setPixelHinting(true);

        overview.addChild(displayable);
      }
    },

    /**
     * Updates the current time of the overview.
     * @param {Overview} overview The overview being rendered.
     * @private
     */
    _updateReferenceLines: (overview) => {
      var width = overview.Width;
      var height = overview.Height;

      var isValidTime = function (time) {
        return !(time == null || isNaN(time) || time < overview._xMin || time > overview._xMax);
      };
      var renderLine = function (line) {
        line.setSolidStroke(overview._currentTimeIndicatorColor);
        line.setPixelHinting(true);
        overview.addChild(line);
      };
      // return if current time is invalid or outside of the time range
      if (overview.Options.referenceObjects == null || overview.Options.referenceObjects.length == 0)
        return;
      var checkTime;
      if (overview.isVertical()) {
        for (var i = 0; i < overview.Options.referenceObjects.length; i++) {
          checkTime = isValidTime(overview.Options.referenceObjects[i]);
          if (checkTime) {
            var time_pos = overview.getDateYPosition(overview.Options.referenceObjects[i]);
            var line = new dvt.Line(
              overview.getCtx(),
              0,
              time_pos,
              width,
              time_pos,
              'referenceObjects' + i
            );
            renderLine(line);
          }
        }
      } else {
        for (var i = 0; i < overview.Options.referenceObjects.length; i++) {
          checkTime = isValidTime(overview.Options.referenceObjects[i]);
          if (checkTime) {
            time_pos = overview.getDateXPosition(overview.Options.referenceObjects[i]);
            if (overview.isRTL()) time_pos = width - time_pos;
            line = new dvt.Line(
              overview.getCtx(),
              time_pos,
              0,
              time_pos,
              height,
              'referenceObjects' + i
            );
            renderLine(line);
          }
        }
      }
    }
  };

  /**
   * Overview component.
   * @param {dvt.Context} context The rendering context.
   * @param {object} callback The function that should be called to dispatch component events.
   * @param {object} callbackObj The object context for the callback function
   * @class Overview component.
   * @constructor
   * @extends {dvt.Container}
   */
  class Overview extends dvt.Container {
    /**
     * Initializes the view.
     * @param {dvt.Context} context The rendering context.
     * @param {object} callback The function that should be called to dispatch component events.
     * @param {object} callbackObj The object context for the callback function
     * @protected
     */

    constructor(context, callback, callbackObj) {
      super(context);
      this.MIN_WINDOW_SIZE = 28;
      this.DEFAULT_VERTICAL_TIMEAXIS_SIZE = 40;
      this.DEFAULT_HORIZONTAL_TIMEAXIS_SIZE = 24;
      this.HANDLE_PADDING_SIZE = 20;

      // Create the defaults object
      this.initDefaults();

      this._callback = callback;
      this._callbackObj = callbackObj;

      this._lastChildIndex = 6;

      var interactive = this._callback != null || this._callbackObj != null;
      if (interactive) {
        this.EventManager = new DvtOverviewEventManager(this, context, callback, callbackObj);
        this.EventManager.addListeners(this);
        // register listeners
        this.addEvtListener(dvt.TouchEvent.TOUCHSTART, this.HandleTouchStart, false, this);
        this.addEvtListener(dvt.TouchEvent.TOUCHMOVE, this.HandleTouchMove, false, this);
        this.addEvtListener(dvt.TouchEvent.TOUCHEND, this.HandleTouchEnd, false, this);
        this.addEvtListener(dvt.MouseEvent.CLICK, this.HandleShapeClick, false, this);

        this.addEvtListener(dvt.MouseEvent.MOUSEOVER, this.HandleShapeMouseOver, false, this);
        this.addEvtListener(dvt.MouseEvent.MOUSEOUT, this.HandleShapeMouseOut, false, this);
        this.addEvtListener(dvt.MouseEvent.CLICK, this.HandleShapeClick, false, this);
      }
    }

    /**
     * Initializes the component defaults.
     */
    initDefaults() {
      this.Defaults = new DvtOverviewDefaults();
    }

    /**
     * To support Chart zoom and scroll feature
     * Ability to set the overview window start and end pos
     * @param x1 - the viewport x1 value
     * @param x2 - the viewport x2 value
     * @param y1 - the viewport y1 value
     * @param y2 - the viewport y2 value
     */
    setViewportRange(x1, x2, y1, y2) {
      if (x1 != null && x2 != null) {
        var x1Pos = this.getDateXPosition(x1);
        var x2Pos = this.getDateXPosition(x2);

        // make sure it's in bounds
        if (x2Pos > x1Pos) {
          if (x1Pos < this.getMinimumPositionX()) x1Pos = this.getMinimumPositionX();
          if (x2Pos > this.getMaximumPositionX()) x2Pos = this.getMaximumPositionX();

          var width = Math.max(x2Pos - x1Pos, this.getMinimumWindowWidth());
          var slidingWindow = this.getSlidingWindow();
          if (this.isRTL() && this.flipOnRtl()) this.setSlidingWindowPosX(slidingWindow, this.Width - (x1Pos + width));
          else this.setSlidingWindowPosX(slidingWindow, x1Pos);

          DvtOverviewRenderer._setSlidingWindowWidth(this, slidingWindow, width);
        }
      }
      if (y1 != null && y2 != null) {
        var y1Pos = this.getDateYPosition(y1);
        var y2Pos = this.getDateYPosition(y2);

        // make sure it's in bounds
        if (y2Pos > y1Pos) {
          if (y1Pos < this.getMinimumPositionY()) y1Pos = this.getMinimumPositionY();
          if (y2Pos > this.getMaximumPositionY()) y2Pos = this.getMaximumPositionY();

          var height = Math.max(y2Pos - y1Pos, this.getMinimumWindowHeight());
          slidingWindow = this.getSlidingWindow();
          this.setSlidingWindowPosY(slidingWindow, y1Pos);

          DvtOverviewRenderer._setSlidingWindowHeight(this, slidingWindow, height);
        }
      }
      DvtOverviewRenderer._updateBorderAroundSlidingWindow(this);
    }

    /**
     * Returns true if the coordinate system should be flipped on rtl
     */
    flipOnRtl() {
      return true;
    }
    /**
     * Checks whether a particular feature is turned off
     */
    isFeatureOff(feature) {
      if (this._featuresOff == null) return false;

      return this._featuresOff.indexOf(feature) !== -1;
    }

    /**
     * Checks whether sliding window should animate when move
     */
    isAnimationOnClick() {
      return this._animationOnClick !== 'off';
    }

    /**
     * Renders the component with the specified data.  If no data is supplied to a component
     * that has already been rendered, the component will be rerendered to the specified size.
     * @param {obj} obj The json object describing the component.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     */
    render(obj, width, height) {
      // Store the size
      if (width != null && height != null) {
        this.Width = width;
        this.Height = height;
      }

      if (obj == null) {
        var slidingWindow = this.getSlidingWindow();

        // sets the correct time where the sliding window starts
        if (this._xMin && this._xMax) {
          var slidingWindowPos = this.getSlidingWindowPosX(slidingWindow);
          if (slidingWindow != null && slidingWindowPos !== 0) {
            // note this.Width references the old width
            this._x1 = OverviewUtils.getPositionDate(
              this._xMin,
              this._xMax,
              slidingWindowPos,
              this.Width
            );
          }
        }
        if (this._yMin && this._yMax) {
          slidingWindowPos = this.getSlidingWindowPosY(slidingWindow);
          if (slidingWindow != null && slidingWindowPos !== 0) {
            // note this.Height references the old height
            this._y1 = OverviewUtils.getPositionDate(
              this._yMin,
              this._yMax,
              slidingWindowPos,
              this.Height
            );
          }
        }

        // clean out existing elements since they will be regenerate
        this.removeChildren();
      } else {
        this.SetOptions(obj);

        // If new data options are provided, parse it and apply the properties
        var props = this.Parse(this.Options);
        this._applyParsedProperties(props);
      }

      DvtOverviewRenderer.renderOverview(this);
    }

    /**
     * @override
     */
    SetOptions(options) {
      // Combine the user options with the defaults and store
      this.Options = this.Defaults.calcOptions(options);
    }

    getParser() {
      return new OverviewParser(this);
    }

    Parse(obj) {
      var parser = this.getParser(obj);
      return parser.parse(obj);
    }

    /**
     * Applies the parsed properties to this component.
     * @param {object} props An object containing the parsed properties for this component.
     * @private
     */
    _applyParsedProperties(props) {
      this._xMin = props.xMin;
      this._xMax = props.xMax;
      this._x1 = props.x1;
      this._x2 = props.x2;
      this._yMin = props.yMin;
      this._yMax = props.yMax;
      this._y1 = props.y1;
      this._y2 = props.y2;
      this._animationOnClick = props.animationOnClick;

      // chart specific options: left and right margin
      this._leftMargin = Math.max(0, props.leftMargin);
      this._rightMargin = Math.max(0, props.rightMargin);
      if (isNaN(this._leftMargin)) this._leftMargin = 0;
      if (isNaN(this._rightMargin)) this._rightMargin = 0;

      this._orientation = props.orientation;
      this._isRtl = props.isRtl;
      if (props.featuresOff != null) this._featuresOff = props.featuresOff.split(' ');
      if (props.minimumWindowSize != null && props.minimumWindowSize > 0)
        this._minimumWindowSize = props.minimumWindowSize;

      this._timeAxisInfo = props.timeAxisInfo;
      if (props.timeAxisInfo != null) this._ticks = this._timeAxisInfo.ticks;
      this._formattedTimeRanges = props.formattedTimeRanges;

      this._borderTopStyle = DvtOverviewStyleUtils.getBorderTopStyle(this.Options);
      this._borderTopColor = DvtOverviewStyleUtils.getBorderTopColor(this.Options);

      this._windowBackgroundColor = DvtOverviewStyleUtils.getWindowBackgroundColor(this.Options);
      this._windowBackgroundAlpha = DvtOverviewStyleUtils.getWindowBackgroundAlpha(this.Options);
      this._windowBorderTopStyle = DvtOverviewStyleUtils.getWindowBorderTopStyle(this.Options);
      this._windowBorderRightStyle = DvtOverviewStyleUtils.getWindowBorderRightStyle(this.Options);
      this._windowBorderBottomStyle = DvtOverviewStyleUtils.getWindowBorderBottomStyle(this.Options);
      this._windowBorderLeftStyle = DvtOverviewStyleUtils.getWindowBorderLeftStyle(this.Options);
      this._windowBorderTopColor = DvtOverviewStyleUtils.getWindowBorderTopColor(this.Options);
      this._windowBorderRightColor = DvtOverviewStyleUtils.getWindowBorderRightColor(this.Options);
      this._windowBorderBottomColor = DvtOverviewStyleUtils.getWindowBorderBottomColor(this.Options);
      this._windowBorderLeftColor = DvtOverviewStyleUtils.getWindowBorderLeftColor(this.Options);

      this._handleTextureColor = DvtOverviewStyleUtils.getHandleTextureColor(this.Options);
      this._handleFillColor = DvtOverviewStyleUtils.getHandleFillColor(this.Options);
      this._horHandleBackgroundClass = DvtOverviewStyleUtils.getHandleBackgroundClass(
        this.Options,
        false
      );
      this._horHandleSize = DvtOverviewStyleUtils.getHandleSize(this.Options, false);
      this._vertHandleBackgroundClass = DvtOverviewStyleUtils.getHandleBackgroundClass(
        this.Options,
        true
      );
      this._vertHandleSize = DvtOverviewStyleUtils.getHandleSize(this.Options, true);

      this._overviewBackgroundColor = DvtOverviewStyleUtils.getOverviewBackgroundColor(this.Options);
      this._currentTimeIndicatorColor = DvtOverviewStyleUtils.getCurrentTimeIndicatorColor(
        this.Options
      );
      this._timeIndicatorColor = DvtOverviewStyleUtils.getTimeIndicatorColor(this.Options);
      this._timeAxisBarColor = DvtOverviewStyleUtils.getTimeAxisBarColor(this.Options);
      this._timeAxisBarOpacity = DvtOverviewStyleUtils.getTimeAxisBarAlpha(this.Options);

      // chart specific options: left and right filter panels
      this._leftFilterPanelColor = DvtOverviewStyleUtils.getLeftFilterPanelColor(this.Options);
      this._leftFilterPanelAlpha = DvtOverviewStyleUtils.getLeftFilterPanelAlpha(this.Options);
      this._rightFilterPanelColor = DvtOverviewStyleUtils.getRightFilterPanelColor(this.Options);
      this._rightFilterPanelAlpha = DvtOverviewStyleUtils.getRightFilterPanelAlpha(this.Options);

      this._labelStyle = new dvt.CSSStyle('font-weight:bold');
    }

    /** *************************** common helper methods *********************************************/

    /**
     * Returns the horizontal pixel position corresponding to the given date.
     * @param {number} date The given date.
     */
    getDateXPosition(date) {
      return Math.max(
        this.getMinimumPositionX(),
        OverviewUtils.getDatePosition(this._xMin, this._xMax, date, this.getOverviewWidth()) +
          this._leftMargin
      );
    }

    /**
     * Returns the vertical pixel position corresponding to the given date.
     * @param {number} date The given date.
     */
    getDateYPosition(date) {
      return Math.max(
        this.getMinimumPositionY(),
        OverviewUtils.getDatePosition(this._yMin, this._yMax, date, this.getOverviewHeight())
      );
    }

    /**
     * Returns the date corresponding to the given horizontal pixel position.
     * @param {number} pos The given horizontal pixel position.
     */
    getXPositionDate(pos) {
      return OverviewUtils.getPositionDate(
        this._xMin,
        this._xMax,
        Math.max(this.getMinimumPositionX() - this._leftMargin, pos - this._leftMargin),
        this.getOverviewWidth()
      );
    }

    /**
     * Returns the date corresponding to the given vertical pixel position.
     * @param {number} pos The given vertical pixel position.
     */
    getYPositionDate(pos) {
      return OverviewUtils.getPositionDate(
        this._yMin,
        this._yMax,
        Math.max(this.getMinimumPositionY(), pos),
        this.getOverviewHeight()
      );
    }

    /**
     * Whether or not this is rendered in an RTL layout.
     */
    isRTL() {
      return this._isRtl === 'true';
    }

    /**
     * Whether or not this is a horizontal overview that is also rendered in an RTL layout..
     */
    isHorizontalRTL() {
      return this.isRTL() && !this.isVertical();
    }

    /**
     * Whether or not this is a vertical overview.
     */
    isVertical() {
      return this._orientation === 'vertical';
    }

    /**
     * Whether or not this overview is rendered 'above'.
     */
    isOverviewAbove() {
      return this.Options['overviewPosition'] === 'above';
    }

    // Sets the left and right margins, used by chart
    setMargins(leftMargin, rightMargin) {
      if (!isNaN(leftMargin) && leftMargin != null && leftMargin > 0) this._leftMargin = leftMargin;

      if (!isNaN(rightMargin) && rightMargin != null && rightMargin > 0)
        this._rightMargin = rightMargin;
    }

    // returns the width of the overview, taking margins into account
    getOverviewSize() {
      if (this.isVertical()) return this.Height - this._leftMargin - this._rightMargin;
      else return this.Width - this._leftMargin - this._rightMargin;
    }

    // returns the width of the overview, taking margins into account
    getOverviewWidth() {
      return this.Width - this._leftMargin - this._rightMargin;
    }

    // returns the width of the overview, taking margins into account
    getOverviewHeight() {
      return this.Height;
    }

    // return the minmum X position where the sliding window can reach
    getMinimumPositionX() {
      return this._leftMargin;
    }

    // return the minmum Y position where the sliding window can reach
    getMinimumPositionY() {
      return 0;
    }

    // return the maximum X position where the sliding window can reach
    getMaximumPositionX() {
      return this.Width - this._rightMargin;
    }

    // return the maximum Y position where the sliding window can reach
    getMaximumPositionY() {
      return this.Height;
    }

    // returns the minimum width of the sliding window
    getMinimumWindowWidth() {
      if (this._minWinSize != null) return this._minWinSize;
      else if (this._minimumWindowSize != null) {
        this._minWinSize = OverviewUtils.getDatePosition(
          this._xMin,
          this._xMax,
          this._xMin + this._minimumWindowSize,
          this.getOverviewWidth()
        );
        return this._minWinSize;
      }
      return this.MIN_WINDOW_SIZE;
    }

    // returns the minimum height of the sliding window
    getMinimumWindowHeight() {
      if (this._minWinSize != null) return this._minWinSize;
      else if (this._minimumWindowSize != null) {
        this._minWinSize = OverviewUtils.getDatePosition(
          this._yMin,
          this._yMax,
          this._yMin + this._minimumWindowSize,
          this.getOverviewHeight()
        );
        return this._minWinSize;
      } else return this.MIN_WINDOW_SIZE;
    }

    getMaximumWindowWidth() {
      return this.Width;
    }

    getMaximumWindowHeight() {
      return this.Height;
    }

    getGrippySize() {
      return 16;
    }

    // return the start of the resize handle
    getHandleStart() {
      if (OverviewUtils.supportsTouch()) return this.getHandleSize() / 2;
      else return 0;
    }

    // return the size of the resize handle, which is wider on touch devices
    getHandleSize() {
      if (OverviewUtils.supportsTouch()) {
        return 30;
      }
      return 10;
    }

    isHandle(drawable) {
      var id = drawable.getId();
      return (
        id === 'lh' ||
        id === 'rh' ||
        id === 'lhb' ||
        id === 'rhb' ||
        id === 'th' ||
        id === 'bh' ||
        id === 'thb' ||
        id === 'bhb' ||
        id === 'hgrpy' ||
        id === 'vgrpy' ||
        id === 'lbgrh' ||
        id === 'rbgrh' ||
        (drawable.getParent() != null &&
          (drawable.getParent().getId() === 'hgrpy' || drawable.getParent().getId() === 'vgrpy'))
      );
    }

    isLeftOrRightHandle(drawable) {
      var id = drawable.getId();
      return (
        id === 'lh' ||
        id === 'rh' ||
        id === 'lhb' ||
        id === 'rhb' ||
        id === 'hgrpy' ||
        id === 'lbgrh' ||
        id === 'rbgrh' ||
        (drawable.getParent() != null && drawable.getParent().getId() === 'hgrpy')
      );
    }

    isTopOrBottomHandle(drawable) {
      var id = drawable.getId();
      return (
        id === 'th' ||
        id === 'bh' ||
        id === 'thb' ||
        id === 'bhb' ||
        id === 'vgrpy' ||
        (drawable.getParent() != null && drawable.getParent().getId() === 'vgrpy')
      );
    }

    // for vertical
    getTimeAxisWidth() {
      // checks if there is a time axis
      if (this._timeAxisInfo == null) return 0;

      // read from skin?
      if (this._timeAxisWidth == null) {
        var width = parseInt(this._timeAxisInfo.width, 10);
        if (!isNaN(width) && width < this.Width) this._timeAxisWidth = width;
        else this._timeAxisWidth = this.DEFAULT_VERTICAL_TIMEAXIS_SIZE;
      }

      return this._timeAxisWidth;
    }

    getTimeAxisHeight() {
      // checks if there is a time axis
      if (this._timeAxisInfo == null || this._timeAxisInfo.ticks.length === 0) return 0;

      // read from skin?
      if (this._timeAxisHeight == null) {
        var height = parseInt(this._timeAxisInfo.height, 10);
        if (!isNaN(height) && height < this.Height) this._timeAxisHeight = height;
        else this._timeAxisHeight = this.DEFAULT_HORIZONTAL_TIMEAXIS_SIZE;
      }

      return this._timeAxisHeight;
    }

    getPageX(event) {
      if (event.targetTouches != null) {
        if (event.targetTouches.length > 0) return event.targetTouches[0].pageX;
        else return null;
      } else return event.pageX;
    }

    getPageY(event) {
      if (event.targetTouches != null) {
        if (event.targetTouches.length > 0) return event.targetTouches[0].pageY;
        else return null;
      } else return event.pageY;
    }

    /**
     * Returns true if the background should be rendered.
     * By default it is rendered.
     * @protected
     */
    isBackgroundRendered() {
      return true;
    }

    /**
     * Returns true if a panel should be rendered on the left and right side of the overview window.
     * By default they are not rendered.
     * @protected
     */
    isLeftAndRightFilterRendered() {
      return false;
    }

    getSlidingWindow() {
      return this._slidingWindow;
    }

    getSlidingWindowWidth() {
      if (this.isHorizontalScrollingEnabled()) {
        var x1Pos = Math.max(
          this.getMinimumPositionX(),
          OverviewUtils.getDatePosition(this._xMin, this._xMax, this._x1, this.Width)
        );
        var x2Pos = Math.min(
          this.getMaximumPositionX(),
          Math.max(
            this.getMinimumPositionX(),
            OverviewUtils.getDatePosition(this._xMin, this._xMax, this._x2, this.Width)
          )
        );

        return x2Pos - x1Pos;
      }
      return this.Width;
    }

    getSlidingWindowHeight() {
      if (this.isVerticalScrollingEnabled()) {
        var y1Pos = Math.max(
          this.getMinimumPositionY(),
          OverviewUtils.getDatePosition(this._yMin, this._yMax, this._y1, this.Height)
        );
        var y2Pos = Math.min(
          this.getMaximumPositionY(),
          Math.max(
            this.getMinimumPositionY(),
            OverviewUtils.getDatePosition(this._yMin, this._yMax, this._y2, this.Height)
          )
        );

        return y2Pos - y1Pos;
      }
      return this.Height;
    }

    getLeftBackground() {
      if (this.isLeftAndRightFilterRendered()) return this._leftBackground;
      else return null;
    }

    getRightBackground() {
      if (this.isLeftAndRightFilterRendered()) return this._rightBackground;
      else return null;
    }

    getLeftBackgroundHandle() {
      if (this.isLeftAndRightFilterRendered() && !this.isFeatureOff('zoom'))
        return this._leftBackgroundResizeHandle;
      else return null;
    }

    getRightBackgroundHandle() {
      if (this.isLeftAndRightFilterRendered() && !this.isFeatureOff('zoom'))
        return this._rightBackgroundResizeHandle;
      else return null;
    }

    getLeftHandle() {
      return this._leftHandle;
    }

    getRightHandle() {
      return this._rightHandle;
    }

    getLeftTopBar() {
      var offset = this._lastChildIndex - 2;
      return this.getChildAt(this.getNumChildren() - offset);
    }

    getRightTopBar() {
      var offset = this._lastChildIndex - 3;
      return this.getChildAt(this.getNumChildren() - offset);
    }

    getBottomBar() {
      var offset = this._lastChildIndex - 4;
      return this.getChildAt(this.getNumChildren() - offset);
    }

    getTopBar() {
      var offset = this._lastChildIndex - 5;
      return this.getChildAt(this.getNumChildren() - offset);
    }

    setLinePos(line, pos1, pos2) {
      if (this.isVertical()) {
        if (pos1 !== -1) line.setY1(pos1);
        if (pos2 !== -1) line.setY2(pos2);
      } else {
        if (pos1 !== -1) line.setX1(pos1);
        if (pos2 !== -1) line.setX2(pos2);
      }
    }

    setLinePosX(line, x1, x2) {
      if (x1 !== -1) line.setX1(x1);
      if (x2 !== -1) line.setX2(x2);
    }

    setLinePosY(line, y1, y2) {
      if (y1 !== -1) line.setY1(y1);
      if (y2 !== -1) line.setY2(y2);
    }

    getLinePos1(line) {
      if (this.isVertical()) return line.getY1();
      else return line.getX1();
    }

    /**
     * Returns the drawable that is the target of the event.
     * @return {DvtBaseTreeNode} the target of the event
     */
    _findDrawable(event) {
      var target = event.target;
      if (target != null) {
        var id = target.getId();
        if (id == null) return null;

        if (id.substr(id.length - 7) === '_border') {
          // if it's the border shape, returns the actual drawable
          return this.getChildAfter(target);
        } else if (
          id.substr(0, 4) !== 'tick' &&
          id !== 'ltb' &&
          id !== 'rtb' &&
          id !== 'bb' &&
          id !== 'tab'
        )
          return target;
      }

      return null;
    }

    isMovable(drawable) {
      if (
        drawable.getId() === 'window' ||
        drawable.getId() === 'ftr' ||
        drawable.getId() === 'sta' ||
        this.isHandle(drawable)
      )
        return true;

      return false;
    }

    /* **************************** end common helper methods *********************************************/

    /* **************************** marker creation and event handling *********************************************/

    // orientation independent method
    setRectPos(rect, pos) {
      if (this.isVertical()) rect.setY(pos);
      else rect.setX(pos);
    }

    getRectPos(rect) {
      if (this.isVertical()) return rect.getY();
      else return rect.getX();
    }

    getRectSize(rect) {
      if (this.isVertical()) return rect.getHeight();
      else return rect.getWidth();
    }

    setRectSize(rect, size) {
      if (this.isVertical()) rect.setHeight(size);
      else rect.setWidth(size);
    }

    getSlidingWindowPos(slidingWindow) {
      if (this.isVertical()) return slidingWindow.getTranslateY();
      else return slidingWindow.getTranslateX();
    }

    getSlidingWindowPosX(slidingWindow) {
      return slidingWindow.getTranslateX();
    }

    getSlidingWindowPosY(slidingWindow) {
      return slidingWindow.getTranslateY();
    }

    setSlidingWindowPosX(slidingWindow, xPos) {
      xPos = Math.max(this.getMinimumPositionX(), xPos);
      slidingWindow.setTranslateX(xPos);

      if (this.isLeftAndRightFilterRendered()) {
        var leftBackground = this.getLeftBackground();
        leftBackground.setWidth(xPos);
        var rightStart = xPos + this.getSlidingWindowSize(slidingWindow);
        var rightBackground = this.getRightBackground();
        rightBackground.setX(rightStart);
        rightBackground.setWidth(Math.max(0, this.Width - rightStart));

        // updates the background resize handle for touch
        if (OverviewUtils.supportsTouch() && !this.isFeatureOff('zoom')) {
          var handleStart = this.getHandleStart();
          var leftBackgroundHandle = this.getLeftBackgroundHandle();
          leftBackgroundHandle.setX(xPos - handleStart);
          var rightBackgroundHandle = this.getRightBackgroundHandle();
          rightBackgroundHandle.setX(rightStart);
        }
      }
    }

    setSlidingWindowPosY(slidingWindow, yPos) {
      yPos = Math.max(this.getMinimumPositionY(), yPos);
      slidingWindow.setTranslateY(yPos);
    }

    getSlidingWindowSize(slidingWindow) {
      return this.getRectSize(slidingWindow);
    }

    renderData(width, height) {}

    /** ************************ sliding window animation *********************************************/
    animateSlidingWindow(newX, newY) {
      var slidingWindowWidth = 0;
      var slidingWindow = this.getSlidingWindow();

      // first check if sliding window moved or resized at all
      if (
        (newX === undefined || newX === null || newX === this.getSlidingWindowPosX(slidingWindow)) &&
        (newY === undefined || newY === null || newY === this.getSlidingWindowPosY(slidingWindow))
      )
        return;

      var leftHandle = this.getLeftHandle();
      var rightHandle = this.getRightHandle();
      var leftTopBar = this.getLeftTopBar();
      var rightTopBar = this.getRightTopBar();
      var bottomBar = this.getBottomBar();
      var topBar = this.getTopBar();

      var playAnimator = false;
      var animator = this.isAnimationOnClick()
        ? new dvt.Animator(this.getCtx(), 0.5, 0, dvt.Easing.linear)
        : null;

      if (this.isVerticalScrollingEnabled() && newY != null) {
        var posYGetter = slidingWindow.getTranslateY;
        var posYSetter = slidingWindow.setTranslateY;
        var leftHandleY1Getter = leftHandle.getY1;
        var leftHandleY1Setter = leftHandle.setY1;
        var leftHandleY2Getter = leftHandle.getY2;
        var leftHandleY2Setter = leftHandle.setY2;
        var rightHandleY1Getter = rightHandle.getY1;
        var rightHandleY1Setter = rightHandle.setY1;
        var rightHandleY2Getter = rightHandle.getY2;
        var rightHandleY2Setter = rightHandle.setY2;
        var bottomBarY1Getter = bottomBar.getY1;
        var bottomBarY1Setter = bottomBar.setY1;
        var bottomBarY2Getter = bottomBar.getY2;
        var bottomBarY2Setter = bottomBar.setY2;
        var topBarY1Getter = topBar.getY1;
        var topBarY1Setter = topBar.setY1;
        var topBarY2Getter = topBar.getY2;
        var topBarY2Setter = topBar.setY2;

        // make sure it doesn't go over
        var minPosY = this.getMinimumPositionY();
        var maxPosY = this.getMaximumPositionY();
        var slidingWindowHeight = slidingWindow.getHeight();
        newY = Math.max(minPosY, Math.min(maxPosY - slidingWindowHeight, newY));

        this.animateProperty(animator, slidingWindow, posYGetter, posYSetter, newY);

        if (!this.isVertical()) {
          // left and right handles
          this.animateProperty(animator, leftHandle, leftHandleY1Getter, leftHandleY1Setter, newY);
          this.animateProperty(
            animator,
            leftHandle,
            leftHandleY2Getter,
            leftHandleY2Setter,
            newY + slidingWindowHeight
          );
          this.animateProperty(animator, rightHandle, rightHandleY1Getter, rightHandleY1Setter, newY);
          this.animateProperty(
            animator,
            rightHandle,
            rightHandleY2Getter,
            rightHandleY2Setter,
            newY + slidingWindowHeight
          );

          // top and bottom borders
          this.animateProperty(
            animator,
            bottomBar,
            bottomBarY1Getter,
            bottomBarY1Setter,
            newY + slidingWindowHeight
          );
          this.animateProperty(animator, topBar, topBarY1Getter, topBarY1Setter, newY);
          this.animateProperty(
            animator,
            bottomBar,
            bottomBarY2Getter,
            bottomBarY2Setter,
            newY + slidingWindowHeight
          );
          this.animateProperty(animator, topBar, topBarY2Getter, topBarY2Setter, newY);
        } else {
          // left and right handles
          this.animateProperty(animator, leftHandle, leftHandleY1Getter, leftHandleY1Setter, newY);
          this.animateProperty(animator, leftHandle, leftHandleY2Getter, leftHandleY2Setter, newY);
          this.animateProperty(
            animator,
            rightHandle,
            rightHandleY1Getter,
            rightHandleY1Setter,
            newY + slidingWindowHeight
          );
          this.animateProperty(
            animator,
            rightHandle,
            rightHandleY2Getter,
            rightHandleY2Setter,
            newY + slidingWindowHeight
          );

          // top and bottom borders
          this.animateProperty(animator, bottomBar, bottomBarY1Getter, bottomBarY1Setter, newY);
          this.animateProperty(animator, topBar, topBarY1Getter, topBarY1Setter, newY);
          this.animateProperty(
            animator,
            bottomBar,
            bottomBarY2Getter,
            bottomBarY2Setter,
            newY + slidingWindowHeight
          );
          this.animateProperty(
            animator,
            topBar,
            topBarY2Getter,
            topBarY2Setter,
            newY + slidingWindowHeight
          );

          // left and right top bar
          this.animateProperty(animator, leftTopBar, leftTopBar.getY2, leftTopBar.setY2, newY + 1);
          this.animateProperty(
            animator,
            rightTopBar,
            rightTopBar.getY1,
            rightTopBar.setY1,
            newY + slidingWindowHeight - 1
          );
        }

        playAnimator = true;
      }
      if (this.isHorizontalScrollingEnabled() && newX != null) {
        var posXGetter = slidingWindow.getTranslateX;
        var posXSetter = slidingWindow.setTranslateX;
        var leftHandleX1Getter = leftHandle.getX1;
        var leftHandleX1Setter = leftHandle.setX1;
        var leftHandleX2Getter = leftHandle.getX2;
        var leftHandleX2Setter = leftHandle.setX2;
        var rightHandleX1Getter = rightHandle.getX1;
        var rightHandleX1Setter = rightHandle.setX1;
        var rightHandleX2Getter = rightHandle.getX2;
        var rightHandleX2Setter = rightHandle.setX2;
        var bottomBarX1Getter = bottomBar.getX1;
        var bottomBarX1Setter = bottomBar.setX1;
        var bottomBarX2Getter = bottomBar.getX2;
        var bottomBarX2Setter = bottomBar.setX2;
        var topBarX1Getter = topBar.getX1;
        var topBarX1Setter = topBar.setX1;
        var topBarX2Getter = topBar.getX2;
        var topBarX2Setter = topBar.setX2;

        // make sure it doesn't go over
        var minPosX = this.getMinimumPositionX();
        var maxPosX = this.getMaximumPositionX();
        slidingWindowWidth = slidingWindow.getWidth();
        newX = Math.max(minPosX, Math.min(maxPosX - slidingWindowWidth, newX));

        this.animateProperty(animator, slidingWindow, posXGetter, posXSetter, newX);

        // left and right handles
        this.animateProperty(animator, leftHandle, leftHandleX1Getter, leftHandleX1Setter, newX);
        this.animateProperty(animator, leftHandle, leftHandleX2Getter, leftHandleX2Setter, newX);
        this.animateProperty(
          animator,
          rightHandle,
          rightHandleX1Getter,
          rightHandleX1Setter,
          newX + slidingWindowWidth
        );
        this.animateProperty(
          animator,
          rightHandle,
          rightHandleX2Getter,
          rightHandleX2Setter,
          newX + slidingWindowWidth
        );

        // left and right top bar
        if (!this.isVertical()) {
          this.animateProperty(animator, leftTopBar, leftTopBar.getX2, leftTopBar.setX2, newX + 1);
          this.animateProperty(
            animator,
            rightTopBar,
            rightTopBar.getX1,
            rightTopBar.setX1,
            newX + slidingWindowWidth - 1
          );
        }

        // top and bottom borders
        this.animateProperty(animator, bottomBar, bottomBarX1Getter, bottomBarX1Setter, newX);
        this.animateProperty(animator, topBar, topBarX1Getter, topBarX1Setter, newX);
        this.animateProperty(
          animator,
          bottomBar,
          bottomBarX2Getter,
          bottomBarX2Setter,
          newX + slidingWindowWidth
        );
        this.animateProperty(
          animator,
          topBar,
          topBarX2Getter,
          topBarX2Setter,
          newX + slidingWindowWidth
        );

        playAnimator = true;
      }

      if (this.isLeftAndRightFilterRendered()) {
        var leftBackground = this.getLeftBackground();
        var leftBackgroundGetter = leftBackground.getWidth;
        var leftBackgroundSetter = leftBackground.setWidth;
        this.animateProperty(
          animator,
          leftBackground,
          leftBackgroundGetter,
          leftBackgroundSetter,
          newX
        );

        var rightStart = Number(newX) + slidingWindowWidth;
        var rightBackground = this.getRightBackground();
        var rightBackgroundGetter = rightBackground.getWidth;
        var rightBackgroundSetter = rightBackground.setWidth;
        var rightBackgroundPosGetter = rightBackground.getX;
        var rightBackgroundPosSetter = rightBackground.setX;

        this.animateProperty(
          animator,
          rightBackground,
          rightBackgroundGetter,
          rightBackgroundSetter,
          this.Width - rightStart
        );
        this.animateProperty(
          animator,
          rightBackground,
          rightBackgroundPosGetter,
          rightBackgroundPosSetter,
          rightStart
        );

        if (OverviewUtils.supportsTouch() && !this.isFeatureOff('zoom')) {
          var handleStart = this.getHandleStart();
          var leftBackgroundHandle = this.getLeftBackgroundHandle();
          var leftBackgroundHandleGetter = leftBackgroundHandle.getX;
          var leftBackgroundHandleSetter = leftBackgroundHandle.setX;
          var rightBackgroundHandle = this.getRightBackgroundHandle();
          var rightBackgroundHandleGetter = rightBackgroundHandle.getX;
          var rightBackgroundHandleSetter = rightBackgroundHandle.setX;

          this.animateProperty(
            animator,
            leftBackgroundHandle,
            leftBackgroundHandleGetter,
            leftBackgroundHandleSetter,
            newX - handleStart
          );
          this.animateProperty(
            animator,
            rightBackgroundHandle,
            rightBackgroundHandleGetter,
            rightBackgroundHandleSetter,
            rightStart
          );
        }
        playAnimator = true;
      }

      if (animator != null && playAnimator) animator.play();
    }

    animateProperty(animator, obj, getter, setter, value) {
      if (animator != null) {
        animator.addProp(dvt.Animator.TYPE_NUMBER, obj, getter, setter, value);
      } else {
        setter.call(obj, value);
      }
    }
    /* ************************* end sliding window animation *********************************************/

    /* ************************* event handling *********************************************/
    HandleShapeMouseOver(event) {
      var drawable = this._findDrawable(event);
      // Return if no drawable is found
      if (!drawable || drawable.getId() === 'bg' || drawable.getId() === 'referenceObjects')
        return undefined;

      // if it is a label, show a tooltip of the label if it is truncated
      if (
        drawable.getId().substr(0, 5) === 'label' &&
        (drawable instanceof dvt.OutputText || drawable instanceof dvt.BackgroundOutputText)
      ) {
        if (drawable.isTruncated())
          this.getCtx()
            .getTooltipManager()
            .showDatatip(event.pageX, event.pageY, drawable._rawText, '#000000');
        return undefined;
      }

      if (
        drawable.getId() === 'window' ||
        drawable.getId() === 'ftr' ||
        drawable.getId() === 'arr' ||
        this.isHandle(drawable)
      )
        return undefined;

      return drawable;
    }

    HandleShapeMouseOut(event) {
      // don't change cursor yet if we are in a moving state
      if (this._moveDrawable == null) this.setCursor('default');

      var drawable = this._findDrawable(event);
      if (drawable == null) return null;

      return drawable;
    }

    HandleShapeClick(event, pageX, pageY) {
      // so that graph will not get a click event and clear selection
      event.stopPropagation();

      var drawable = this._findDrawable(event);

      // Return if no drawable is found
      if (!drawable || drawable.getId() === 'window' || this.isHandle(drawable)) return null;

      // if clicking anywhere on the overview scroll to the location
      if (
        drawable.getId() === 'bg' ||
        drawable.getId().substr(0, 5) === 'label' ||
        drawable.getId() === 'referenceObjects' ||
        drawable.getId() === 'lbg' ||
        drawable.getId() === 'rbg'
      ) {
        if (pageX === undefined || pageX === null) pageX = event.pageX;
        if (pageY === undefined || pageY === null) pageY = event.pageY;

        var relPos = this.getCtx().pageToStageCoords(pageX, pageY);
        relPos = this.stageToLocal(relPos);

        // scroll sliding window
        var slidingWindow = this.getSlidingWindow();
        if (this.isVerticalScrollingEnabled()) {
          var posY = relPos.y;
          var height = this.Height;
          var newPosY = posY - slidingWindow.getHeight() / 2;
        }
        if (this.isHorizontalScrollingEnabled()) {
          var posX = relPos.x;
          var width = this.Width;
          var newPosX = posX - slidingWindow.getWidth() / 2;
        }

        this.animateSlidingWindow(newPosX, newPosY);

        // scroll timeline
        var newX1, newX2, newY1, newY2;
        if (newPosX != null) {
          var slidingWindowWidth = slidingWindow.getWidth();
          // make sure position is in bound
          newPosX = Math.max(
            this.getMinimumPositionX(),
            Math.min(newPosX, width - slidingWindowWidth)
          );

          if (this.isRTL()) {
            newX1 = this.getXPositionDate(width - (newPosX + slidingWindowWidth));
            newX2 = this.getXPositionDate(width - newPosX);
          } else {
            newX1 = this.getXPositionDate(newPosX);
            newX2 = this.getXPositionDate(newPosX + slidingWindowWidth);
          }
        }
        if (newPosY != null) {
          var slidingWindowHeight = slidingWindow.getHeight();
          // make sure position is in bound
          newPosY = Math.max(
            this.getMinimumPositionY(),
            Math.min(newPosY, height - slidingWindowHeight)
          );

          newY1 = this.getYPositionDate(newPosY);
          newY2 = this.getYPositionDate(newPosY + slidingWindowHeight);
        }
        var evt = dvt.EventFactory.newOverviewEvent('scrollTime', newX1, newX2, newY1, newY2);
        this.dispatchEvent(evt);
        return null;
      }

      return drawable;
    }

    /**
     * Begins a drag pan of the overview window if applicable.
     * @param {dvt.BaseEvent} event The dispatched event to be processed by the object.
     * @param {number} compX The x coordinate of the event with relative to the stage.
     * @param {number} compY The y coordinate of the event with relative to the stage.
     * @return {boolean} true iff a drag pan operation is started, false otherwise.
     */
    beginDragPan(event, compX, compY) {
      var drawable = this._findDrawable(event);
      if (drawable != null && this.isMovable(drawable)) {
        // if the drawable is the formatted time ranges, move the sliding window
        if (drawable.getId() === 'ftr' || drawable.getId() === 'sta')
          drawable = this.getSlidingWindow();

        this._initX = compX;
        this._initY = compY;

        if (this.isHandle(drawable)) {
          var slidingWindow = this.getSlidingWindow();

          if (drawable.getParent().getId() === 'hgrpy' || drawable.getParent().getId() === 'vgrpy')
            drawable = drawable.getParent();

          var drawableId = drawable.getId();

          if (drawableId === 'hgrpy' || drawableId === 'vgrpy') {
            drawable = slidingWindow.getChildBefore(drawable);
            drawableId = drawable.getId();
          }

          if (
            drawableId === 'lh' ||
            drawableId === 'rh' ||
            drawableId === 'th' ||
            drawableId === 'bh'
          ) {
            drawable = slidingWindow.getChildBefore(drawable);
            drawableId = drawable.getId();
          }

          if (drawableId === 'lbgrh') drawable = slidingWindow.getChildAt(0);

          if (drawableId === 'rbgrh')
            drawable = slidingWindow.getChildAt(slidingWindow.getNumChildren() - 3);

          if (this.isLeftOrRightHandle(drawable)) {
            this._isHorizontalResize = true;
            if (this.isRTL()) {
              this._oldEndPosX = this.Width - slidingWindow.getX();
              this._oldStartPosX = this._oldEndPosX - slidingWindow.getWidth();
            } else {
              this._oldStartPosX = slidingWindow.getX();
              this._oldEndPosX = this._oldStartPosX + slidingWindow.getWidth();
            }
            // drawable should be lhb or rhb
            // temporarily increase size of handle to capture wider area and prevent cursor from changing
            // only do this for non touch since we won't run into cursor issue
            if (!OverviewUtils.supportsTouch()) {
              drawable.setX(0 - this.HANDLE_PADDING_SIZE);
              drawable.setWidth((drawable.getWidth() + this.HANDLE_PADDING_SIZE) * 2);
            }
          } else {
            this._isHorizontalResize = false;
            this._oldStartPosY = slidingWindow.getY();
            this._oldEndPosY = this._oldStartPosY + slidingWindow.getHeight();

            // drawable should be lhb or rhb
            // temporarily increase size of handle to capture wider area and prevent cursor from changing
            // only do this for non touch since we won't run into cursor issue
            if (!OverviewUtils.supportsTouch()) {
              drawable.setY(0 - this.HANDLE_PADDING_SIZE);
              drawable.setHeight((drawable.getHeight() + this.HANDLE_PADDING_SIZE) * 2);
            }
          }

          // temporily change the cursor of other areas of overview so that
          // the cursor won't change when it is moved outside of the handle
          this.overrideCursors(drawable.getCursor());
        }
        this._moveDrawable = drawable;

        // ask the overview peer to notify us if the release happened outside of the overview
        // see stopDragAction method
        var evt = dvt.EventFactory.newOverviewEvent('dropCallback');
        this.dispatchEvent(evt);
        return true;
      } else return false;
    }

    // Change the cursor of the sliding window and the left and right backgrounds
    overrideCursors(cursor) {
      var slidingWindow = this.getSlidingWindow();
      if (slidingWindow != null) slidingWindow.setCursor(cursor);

      if (this.isLeftAndRightFilterRendered()) {
        var leftBackground = this.getLeftBackground();
        var rightBackground = this.getRightBackground();
        if (leftBackground != null && rightBackground != null) {
          leftBackground.setCursor(cursor);
          rightBackground.setCursor(cursor);
        }
      }
    }

    // reset the cursor to what it was original state
    resetCursors() {
      var slidingWindow = this.getSlidingWindow();
      if (slidingWindow != null) slidingWindow.setCursor('move');

      if (this.isLeftAndRightFilterRendered()) {
        var leftBackground = this.getLeftBackground();
        var rightBackground = this.getRightBackground();
        if (leftBackground != null && rightBackground != null) {
          leftBackground.setCursor('default');
          rightBackground.setCursor('default');
        }
      }
    }

    /**
     * Ends a drag pan of the overview window if applicable.
     */
    endDragPan() {
      if (this._moveDrawable != null && this._isDragPanning) {
        if (this._moveDrawable.getId() === 'window') this.handleWindowDrag('scrollEnd');
        else if (this.isHandle(this._moveDrawable)) {
          this.finishHandleDrag(0, 0);

          // reset the temporarily resized handle
          if (!OverviewUtils.supportsTouch()) {
            if (this.isTopOrBottomHandle(this._moveDrawable)) {
              this._moveDrawable.setY(0);
              this._moveDrawable.setHeight(this.getHandleSize());
            } else if (this.isLeftOrRightHandle(this._moveDrawable)) {
              this._moveDrawable.setX(0);
              this._moveDrawable.setWidth(this.getHandleSize());
            }
          }

          // reset cursors that were temporily changed
          this.resetCursors();
        }

        this._isDragPanning = false;
        this._moveDrawable = null;
        this._initX = -1;
      }
    }

    /**
     * Continues a drag pan of the overview window if applicable.
     * @param {dvt.BaseEvent} event The dispatched event to be processed by the object.
     * @param {number} compX The x coordinate of the event with relative to the stage.
     * @param {number} compY The y coordinate of the event with relative to the stage.
     */
    contDragPan(event, compX, compY) {
      if (this._moveDrawable != null && this._initX !== -1) {
        this._isDragPanning = true;
        var diffX = compX - this._initX;
        var diffY = compY - this._initY;
        this._initX = compX;
        this._initY = compY;

        if (this._moveDrawable.getId() === 'window') this.handleWindowDrag('scrollPos', diffX, diffY);
        else if (this._moveDrawable.getId() === 'lh' || this._moveDrawable.getId() === 'lhb')
          this.handleLeftOrRightHandleDragPositioning(event, diffX, true);
        else if (this._moveDrawable.getId() === 'rh' || this._moveDrawable.getId() === 'rhb')
          this.handleLeftOrRightHandleDragPositioning(event, diffX, false);
        else if (this._moveDrawable.getId() === 'th' || this._moveDrawable.getId() === 'thb')
          this.handleTopOrBottomHandleDragPositioning(event, diffY, true);
        else if (this._moveDrawable.getId() === 'bh' || this._moveDrawable.getId() === 'bhb')
          this.handleTopOrBottomHandleDragPositioning(event, diffY, false);
      }
    }

    HandleTouchStart(event) {
      var touches = event.touches;
      this._touchStartX = touches[0].pageX;
      this._touchStartY = touches[0].pageY;

      // see if this is a width change gesture
      if (touches.length === 2) {
        // only prevent default if it is a multi-touch gesture otherwise we don't get click callback
        event.preventDefault();

        this._touchStartX2 = touches[1].pageX;
        this._touchStartY2 = touches[1].pageY;

        if (Math.abs(this._touchStartY - this._touchStartY2) < 20) this._counter = 0;
        else {
          this._touchStartX = null;
          this._touchStartY = null;
          this._touchStartX2 = null;
          this._touchStartY2 = null;
        }
      }
    }

    HandleTouchMove(event) {
      event.preventDefault();
      var touches = event.touches;

      // width change gesture
      if (this._touchStartX2 != null && this._touchStartY2 != null) {
        if (this._counter < 50) {
          // we can't do the dynamic update very often as it is very CPU intensive...
          this._counter++;
          return;
        }

        var deltaX = touches[1].pageX - this._touchStartX2;
        this.handleRightHandleDragPositioning(null, deltaX, 0);

        this._touchStartX2 = touches[1].pageX;

        // reset
        this._counter = 0;
      } else {
        var pageDx = Math.abs(this._touchStartX - touches[0].pageX);
        var pageDy = Math.abs(this._touchStartY - touches[0].pageY);
        // null out the var to signal that this is not a click event
        // need to check actual coord since Android delivers touch move event regardless
        if (pageDx > 3 || pageDy > 3) {
          this._touchStartX = null;
          this._touchStartY = null;
        }
      }
    }

    HandleTouchEnd(event) {
      if (this._touchStartX2 != null && this._touchStartY2 != null) {
        // width change gesture
        this.finishHandleDrag(0, 0);
      } else {
        if (this._touchStartX != null && this._touchStartY != null)
          this.HandleShapeClick(event, this._touchStartX, this._touchStartY);
      }

      this._touchStartX = null;
      this._touchStartY = null;
      this._touchStartX2 = null;
      this._touchStartY2 = null;
    }

    // called externally from overview peer to stop all dragging if the drop action happened outside of the overview
    stopDragAction() {
      this.endDragPan();
    }

    /************************** end event handling *********************************************/

    /***************************** window scrolling and resizing *********************************************/
    handleWindowDrag(type, deltaX, deltaY) {
      var slidingWindow = this.getSlidingWindow();

      var triggerEvent = false;
      var posX = this.getSlidingWindowPosX(slidingWindow);
      var posY = this.getSlidingWindowPosY(slidingWindow);
      var width = slidingWindow.getWidth();
      var height = slidingWindow.getHeight();

      if (type === 'scrollPos') {
        if (this.isHorizontalScrollingEnabled() && deltaX !== 0) {
          var minPosX = this.getMinimumPositionX();
          var maxPosX = this.getMaximumPositionX();
          if (posX + deltaX <= minPosX) {
            // hit the left side
            this.setSlidingWindowPosX(slidingWindow, minPosX);
          } else if (posX + width + deltaX >= maxPosX) {
            // hit the bottom
            this.setSlidingWindowPosX(slidingWindow, maxPosX - width);
          } else {
            this.setSlidingWindowPosX(slidingWindow, posX + deltaX);
          }
          var newPosX = this.getSlidingWindowPosX(slidingWindow);
          if (newPosX !== posX) {
            posX = newPosX;
            triggerEvent = true;
          }
        }
        if (this.isVerticalScrollingEnabled() && deltaY !== 0) {
          var minPosY = this.getMinimumPositionY();
          var maxPosY = this.getMaximumPositionY();
          if (posY + deltaY <= minPosY) {
            // hit the left side
            this.setSlidingWindowPosY(slidingWindow, minPosY);
          } else if (posY + height + deltaY >= maxPosY) {
            // hit the bottom
            this.setSlidingWindowPosY(slidingWindow, maxPosY - height);
          } else {
            this.setSlidingWindowPosY(slidingWindow, posY + deltaY);
          }
          var newPosY = this.getSlidingWindowPosY(slidingWindow);
          if (newPosY !== posY) {
            posY = newPosY;
            triggerEvent = true;
          }
        }
        if (triggerEvent) {
          // update sliding window borders if there was a position update
          DvtOverviewRenderer._updateBorderAroundSlidingWindow(this);
        }
      }
      // fire a scroll event if the window drag deltas caused a position update, or if the drag is ending
      if (triggerEvent || type === 'scrollEnd') {
        var newX1;
        var newX2;
        var newY1;
        var newY2;
        if (this.isHorizontalScrollingEnabled()) {
          if (this.isRTL() && this.flipOnRtl()) {
            newX1 = this.getXPositionDate(this.Width - (posX + width));
            newX2 = this.getXPositionDate(this.Width - posX);
          } else {
            newX1 = this.getXPositionDate(posX);
            newX2 = this.getXPositionDate(posX + width);
          }
        }
        if (this.isVerticalScrollingEnabled()) {
          newY1 = this.getYPositionDate(posY);
          newY2 = this.getYPositionDate(posY + height);
        }
        this.fireScrollEvent(type, newX1, newX2, newY1, newY2);
      }
    }

    fireScrollEvent(type, newX1, newX2, newY1, newY2) {
      // scroll timeline
      var nx1, nx2, ny1, ny2;
      if (this.isHorizontalScrollingEnabled()) {
        nx1 = newX1;
        nx2 = newX2;
      }
      if (this.isVerticalScrollingEnabled()) {
        ny1 = newY1;
        ny2 = newY2;
      }
      var evt = dvt.EventFactory.newOverviewEvent(type, nx1, nx2, ny1, ny2);
      this.dispatchEvent(evt);
    }

    handleLeftOrRightHandleDragPositioning(event, delta, isLeft) {
      if (delta === 0) return;

      var slidingWindow = this.getSlidingWindow();
      var windowPos = this.getSlidingWindowPosX(slidingWindow);
      var windowWidth = slidingWindow.getWidth();

      if (isLeft) {
        // make sure width of sliding window is larger than minimum
        if (windowWidth - delta <= this.getMinimumWindowWidth()) return;

        // make sure position of left handle is not less than minimum (delta is negative when moving handle to the left)
        if (windowPos + delta < this.getMinimumPositionX()) {
          delta = this.getMinimumPositionX() - windowPos;
        }

        // window should only resize when the cursor is back to where the handle is
        var relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event));
        relPos = this.stageToLocal(relPos).x;

        if ((delta > 0 && relPos <= windowPos) || (delta < 0 && relPos >= windowPos)) return;

        this.setSlidingWindowPosX(slidingWindow, windowPos + delta);
        DvtOverviewRenderer._setSlidingWindowWidth(this, slidingWindow, windowWidth - delta);
      } else {
        // make sure width of sliding window is larger than minimum
        if (windowWidth + delta <= this.getMinimumWindowWidth()) return;

        // make sure position of right handle is not less than minimum
        if (windowPos + windowWidth + delta >= this.getMaximumPositionX()) {
          delta = this.getMaximumPositionX() - windowPos - windowWidth;
        }

        // window should only resize when the cursor is back to where the handle is
        relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event));
        relPos = this.stageToLocal(relPos).x;

        if (
          (delta > 0 && relPos <= windowPos + windowWidth) ||
          (delta < 0 && relPos >= windowPos + windowWidth)
        )
          return;

        DvtOverviewRenderer._setSlidingWindowWidth(this, slidingWindow, windowWidth + delta);
      }

      // sync with time axis
      DvtOverviewRenderer._updateBorderAroundSlidingWindow(this);

      // tell event handler that time range is changing
      if (this.isRangeChangingSupported()) {
        var newX1, newX2;
        if (this.isRTL()) {
          newX1 = this.getXPositionDate(
            this.Width - (this.getSlidingWindowPosX(slidingWindow) + slidingWindow.getWidth())
          );
          newX2 = this.getXPositionDate(this.Width - this.getSlidingWindowPosX(slidingWindow));
        } else {
          newX1 = this.getXPositionDate(this.getSlidingWindowPosX(slidingWindow));
          newX2 = this.getXPositionDate(
            this.getSlidingWindowPosX(slidingWindow) + slidingWindow.getWidth()
          );
        }
        var evt = dvt.EventFactory.newOverviewEvent('rangeChanging', newX1, newX2);

        this.dispatchEvent(evt);
      }
    }

    handleTopOrBottomHandleDragPositioning(event, delta, isTop) {
      if (delta === 0) return;

      var slidingWindow = this.getSlidingWindow();
      var windowPos = this.getSlidingWindowPosY(slidingWindow);
      var windowHeight = slidingWindow.getHeight();

      if (isTop) {
        // make sure width of sliding window is larger than minimum
        if (windowHeight - delta <= this.getMinimumWindowHeight()) return;

        // make sure position of top handle is not less than minimum (delta is negative when moving handle to the top)
        if (windowPos + delta <= this.getMinimumPositionY()) return;

        // window should only resize when the cursor is back to where the handle is
        var relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event)).y;
        relPos = this.stageToLocal(relPos);

        if ((delta > 0 && relPos <= windowPos) || (delta < 0 && relPos >= windowPos)) return;

        this.setSlidingWindowPosY(slidingWindow, windowPos + delta);
        DvtOverviewRenderer._setSlidingWindowHeight(this, slidingWindow, windowHeight - delta);
      } else {
        // make sure width of sliding window is larger than minimum
        if (windowHeight + delta <= this.getMinimumWindowHeight()) return;

        // make sure position of bottom handle is not less than minimum
        if (windowPos + windowHeight + delta >= this.getMaximumPositionY()) return;

        // window should only resize when the cursor is back to where the handle is
        relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event)).y;
        relPos = this.stageToLocal(relPos);

        if (
          (delta > 0 && relPos <= windowPos + windowHeight) ||
          (delta < 0 && relPos >= windowPos + windowHeight)
        )
          return;

        DvtOverviewRenderer._setSlidingWindowHeight(this, slidingWindow, windowHeight + delta);
      }

      // sync with time axis
      DvtOverviewRenderer._updateBorderAroundSlidingWindow(this);

      // tell event handler that time range is changing
      if (this.isRangeChangingSupported()) {
        var newY1 = this.getYPositionDate(this.getSlidingWindowPosY(slidingWindow));
        var newY2 = this.getYPositionDate(
          this.getSlidingWindowPosY(slidingWindow) + slidingWindow.getHeight()
        );

        var evt = dvt.EventFactory.newOverviewEvent(
          'rangeChanging',
          undefined,
          undefined,
          newY1,
          newY2
        );

        this.dispatchEvent(evt);
      }
    }

    /**
     * Whether or not horizontal scrolling is enabled.
     */
    isHorizontalScrollingEnabled() {
      return this._xMin != null && this._xMax != null;
    }

    /**
     * Whether or not vertical scrolling is enabled.
     */
    isVerticalScrollingEnabled() {
      return this._yMin != null && this._yMax != null;
    }

    // whether to fire a range changing event, which will be fired continuously when the sliding window is resize
    isRangeChangingSupported() {
      return true;
    }

    finishHandleDrag(deltaX, deltaY) {
      var slidingWindow = this.getSlidingWindow();
      var evt;

      if (this._isHorizontalResize) {
        var oldX1 = this.getXPositionDate(this._oldStartPosX);
        var oldX2 = this.getXPositionDate(this._oldEndPosX);
        if (this.isRTL()) {
          var newX1 = this.getXPositionDate(
            this.Width - (this.getSlidingWindowPosX(slidingWindow) + slidingWindow.getWidth())
          );
          var newX2 = this.getXPositionDate(this.Width - this.getSlidingWindowPosX(slidingWindow));
        } else {
          newX1 = this.getXPositionDate(this.getSlidingWindowPosX(slidingWindow));
          newX2 = this.getXPositionDate(
            this.getSlidingWindowPosX(slidingWindow) + slidingWindow.getWidth()
          );
        }
        evt = dvt.EventFactory.newOverviewEvent(
          'rangeChange',
          newX1,
          newX2,
          undefined,
          undefined,
          oldX1,
          oldX2
        );
      } else {
        var oldY1 = this.getYPositionDate(this._oldStartPosY);
        var oldY2 = this.getYPositionDate(this._oldEndPosY);
        var newY1 = this.getYPositionDate(this.getSlidingWindowPosY(slidingWindow));
        var newY2 = this.getYPositionDate(
          this.getSlidingWindowPosY(slidingWindow) + slidingWindow.getHeight()
        );
        evt = dvt.EventFactory.newOverviewEvent(
          'rangeChange',
          undefined,
          undefined,
          newY1,
          newY2,
          undefined,
          undefined,
          oldY1,
          oldY2
        );
      }

      // alert peer of time range change
      this.dispatchEvent(evt);
    }

    /** ************************end window scrolling and resizing*********************************************/

    /**
     * Dispatches the event to the callback function.  This enables callback function on the peer.
     * @param {object} event The event to be dispatched.
     */
    dispatchEvent(event) {
      this._callback.call(this._callbackObj, event, this);
    }

    /**
     * @override
     */
    destroy() {
      // Remove listeners
      if (this.EventManager) {
        this.EventManager.removeListeners(this);
        this.EventManager.destroy();
        this.EventManager = null;
      }

      this.removeEvtListener(dvt.TouchEvent.TOUCHSTART, this.HandleTouchStart, false, this);
      this.removeEvtListener(dvt.TouchEvent.TOUCHMOVE, this.HandleTouchMove, false, this);
      this.removeEvtListener(dvt.TouchEvent.TOUCHEND, this.HandleTouchEnd, false, this);
      this.removeEvtListener(dvt.MouseEvent.CLICK, this.HandleShapeClick, false, this);

      this.removeEvtListener(dvt.MouseEvent.MOUSEOVER, this.HandleShapeMouseOver, false, this);
      this.removeEvtListener(dvt.MouseEvent.MOUSEOUT, this.HandleShapeMouseOut, false, this);
      this.removeEvtListener(dvt.MouseEvent.CLICK, this.HandleShapeClick, false, this);
      this.removeEvtListener(dvt.KeyboardEvent.KEYDOWN, this.HandleKeyDown, false, this);
      this.removeEvtListener(dvt.KeyboardEvent.KEYUP, this.HandleKeyUp, false, this);

      // Call super last during destroy
      super.destroy();
    }
  }

  exports.Overview = Overview;
  exports.OverviewParser = OverviewParser;
  exports.OverviewUtils = OverviewUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojchart-toolkit',['exports', 'ojs/ojdvt-toolkit', 'ojs/ojdvt-axis', 'ojs/ojlegend-toolkit', 'ojs/ojdvt-overview'], function (exports, dvt, ojdvtAxis, ojlegendToolkit, ojdvtOverview) { 'use strict';

  const DvtChartDataItemUtils = {
    /**
     * Returns the default data item id based on series name and group name.
     * @param {string} series The series name.
     * @param {string} group The group name.
     * @return {string} The data item id.
     */
    createDataItemId: (series, group) => {
      return series + '; ' + group;
    },

    /**
     * Returns whether a and b are equal ids. The ids can be a string or and array of strings.
     * @param {object} a
     * @param {object} b
     * @param {dvt.Context} context The chart context
     * @return {boolean}
     */
    isEqualId: (a, b, context) => {
      if (a == null || b == null)
        // don't consider undefined ids as equal
        return false;
      return dvt.Obj.compareValues(context, a, b);
    }
  };

  /**
   * Creates an object representing the ID of a chart data item.
   * @constructor
   * @param {string} id The ID for the data item, if available.
   * @param {string} series The series ID for the chart data item.
   * @param {string|Array} group The group ID for the chart data item.
   * @param {dvt.Context} context The context for the chart.
   */
  class DvtChartDataItem {
    constructor(id, series, group, context) {
      // Expose as named properties to simplify uptake.
      this.id = id;
      this.series = series;
      this.group = group;
      this.context = context;
    }

    /**
     * Determines if two DvtChartDataItem objects are equal.
     *
     * @param {DvtChartDataItem} dataItem The data item that will be used to test for equality.
     * @return {boolean} True if the two DvtChartDataItem objects are equal
     */
    equals(dataItem) {
      // Note that the id is not compared, because the series and group ids are considered the primary identifiers.
      // However, for nested items, we have to compare the id.
      if (dataItem instanceof DvtChartDataItem) {
        if (this.id != null || dataItem.id != null) {
          return DvtChartDataItemUtils.isEqualId(this.id, dataItem.id, this.context);
        }
        return (
          DvtChartDataItemUtils.isEqualId(this.series, dataItem.series, this.context) &&
          DvtChartDataItemUtils.isEqualId(this.group, dataItem.group, this.context)
        );
      }
      return false;
    }

    /**
     * @override
     */
    toString() {
      if (this.id != null && typeof this.id !== 'object') return this.id.toString();
      else return DvtChartDataItemUtils.createDataItemId(this.series, this.group);
    }

    /**
     * @override
     */
    valueOf() {
      return this.toString();
    }
  }

  /**
   * Utility functions for Chart.
   * @class
   */
  const DvtChartTypeUtils = {
    /** @private @const */
    _SUPPORTED_TYPES: [
      'bar',
      'line',
      'area',
      'lineWithArea',
      'combo',
      'pie',
      'bubble',
      'scatter',
      'funnel',
      'pyramid',
      'stock',
      'boxPlot'
    ],

    /**
     * Returns true if the chart's type is valid.
     * @param {Chart} chart
     * @return {boolean}
     */
    isValidType: (chart) => {
      return DvtChartTypeUtils._SUPPORTED_TYPES.indexOf(chart.getType()) >= 0;
    },

    /**
     * Returns true if the chart is a spark.
     * @param {Chart} chart
     * @return {boolean}
     */
    isSpark: (chart) => {
      return chart.getOptions()['__spark'];
    },

    /**
     * Returns true if the chart is an overview background.
     * @param {Chart} chart
     * @return {boolean}
     */
    isOverview: (chart) => {
      return chart.getOptions()['_isOverview'];
    },

    /**
     * Returns true if the chart is a vertical type.
     * @param {Chart} chart
     * @return {boolean}
     */
    isVertical: (chart) => {
      return !DvtChartTypeUtils.isHorizontal(chart) && !DvtChartTypeUtils.isPolar(chart);
    },

    /**
     * Returns true if the chart is a horizontal type.
     * @param {Chart} chart
     * @return {boolean}
     */
    isHorizontal: (chart) => {
      return (
        chart.getOptions()['orientation'] == 'horizontal' &&
        !DvtChartTypeUtils.isPolar(chart) &&
        !DvtChartTypeUtils.isStock(chart) &&
        (DvtChartTypeUtils.isBLAC(chart) || DvtChartTypeUtils.isFunnel(chart))
      );
    },

    /**
     * Returns true if the chart is polar.
     * @param {Chart} chart
     * @return {boolean}
     */
    isPolar: (chart) => {
      return (
        chart.getOptions()['coordinateSystem'] == 'polar' &&
        !DvtChartTypeUtils.isStock(chart) &&
        !DvtChartTypeUtils.isBoxPlot(chart)
      );
    },

    /**
     * Returns true if the chart is a combo type.
     * @param {Chart} chart
     * @return {boolean}
     */
    isCombo: (chart) => {
      return chart.getType() == 'combo';
    },

    /**
     * Returns true if the chart is a bar graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isBar: (chart) => {
      return chart.getType() == 'bar';
    },

    /**
     * Returns true if the chart is a line graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isLine: (chart) => {
      return chart.getType() == 'line';
    },

    /**
     * Returns true if the chart is a line with area graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isLineWithArea: (chart) => {
      return chart.getType() == 'lineWithArea';
    },

    /**
     * Returns true if the chart is an area graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isArea: (chart) => {
      return chart.getType() == 'area';
    },

    /**
     * Returns true if the chart is a stock chart.
     * @param {Chart} chart
     * @return {boolean}
     */
    isStock: (chart) => {
      return chart.getType() == 'stock';
    },

    /**
     * Returns true if the chart is a box plot.
     * @param {Chart} chart
     * @return {boolean}
     */
    isBoxPlot: (chart) => {
      return chart.getType() == 'boxPlot';
    },

    /**
     * Returns true if the chart is a scatter graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isScatter: (chart) => {
      return chart.getType() == 'scatter';
    },

    /**
     * Returns true if the chart is a bubble graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isBubble: (chart) => {
      return chart.getType() == 'bubble';
    },

    /**
     * Returns true if the chart is a pie graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isPie: (chart) => {
      return chart.getType() == 'pie';
    },

    /**
     * Returns true if the chart is a funnel graph.
     * @param {Chart} chart
     * @return {boolean}
     */
    isFunnel: (chart) => {
      return chart.getType() == 'funnel';
    },

    /**
     * Returns true if the chart is a pyramid.
     * @param {Chart} chart
     * @return {boolean}
     */
    isPyramid: (chart) => {
      return chart.getType() == 'pyramid';
    },

    /**
     * Returns true if the chart supports dual-y.
     * @param {Chart} chart
     * @return {boolean}
     */
    isDualY: (chart) => {
      // Verify the chart type
      if (
        !DvtChartTypeUtils.hasAxes(chart) ||
        DvtChartTypeUtils.isScatterBubble(chart) ||
        DvtChartTypeUtils.isPolar(chart)
      )
        return false;

      // Dual-Y
      return true;
    },

    /**
     * Returns true if the chart is type bar, line, area, combo, stock, or boxPlot.
     * @param {Chart} chart
     * @return {boolean}
     */
    isBLAC: (chart) => {
      var type = chart.getType();
      return (
        type == 'bar' ||
        type == 'line' ||
        type == 'area' ||
        type == 'lineWithArea' ||
        type == 'combo' ||
        type == 'stock' ||
        type == 'boxPlot'
      );
    },

    /**
     * Returns true if the chart is type scatter or bubble.
     * @param {Chart} chart
     * @return {boolean}
     */
    isScatterBubble: (chart) => {
      var type = chart.getType();
      return type == 'scatter' || type == 'bubble';
    },

    /**
     * Returns true if the chart is type line, area, or lineWithArea.
     * @param {Chart} chart
     * @return {boolean}
     */
    isLineArea: (chart) => {
      var type = chart.getType();
      return type == 'line' || type == 'area' || type == 'lineWithArea';
    },

    /**
     * Returns whether zoom and scroll is supported for the chart type
     * @param {Chart} chart
     * @return {boolean}
     */
    isScrollSupported: (chart) => {
      return (
        !DvtChartTypeUtils.isPie(chart) &&
        !DvtChartTypeUtils.isFunnel(chart) &&
        !DvtChartTypeUtils.isPolar(chart) &&
        !DvtChartTypeUtils.isPyramid(chart)
      );
    },

    /**
     * Returns whether overview scrollbar is supported for the chart type
     * @param {Chart} chart
     * @return {boolean}
     */
    isOverviewSupported: (chart) => {
      return DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.isVertical(chart);
    },

    /**
     * Returns true if the chart has axes.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasAxes: (chart) => {
      return !(
        chart.getType() == 'pie' ||
        chart.getType() == 'funnel' ||
        chart.getType() == 'pyramid'
      );
    },

    /**
     * Returns whether the legend is rendered
     * (only type of the chart, legend.rendered and series.displayInLegend are considered)
     * @param {Chart} chart instance of the chart
     * @return {boolean} true, if the legend is rendered
     */
    isLegendRendered: (chart) => {
      var options = chart.getOptions();
      var hasLargeSeriesCount = chart.getOptionsCache().getFromCache('hasLargeSeriesCount');
      var legend = options['legend'];

      if (legend['rendered'] === 'off') {
        return false;
      }

      // Legend will not be rendered if rendered: auto is provided and
      // the series data count is large
      // The same check is being done in DvtChartLegendRenderer.render method.
      if (legend['rendered'] === 'auto' && hasLargeSeriesCount) {
        return false;
      }

      var hasSeriesDisplayedInLegend = chart
        .getOptionsCache()
        .getFromCache('hasSeriesDisplayedInLegend');
      var hasCustomLegendSections = legend['sections'] && legend['sections'].length !== 0;

      var isStock = DvtChartTypeUtils.isStock(chart);
      var isFunnel = DvtChartTypeUtils.isFunnel(chart);
      var isPyramid = DvtChartTypeUtils.isPyramid(chart);

      // For rendered: auto; Stock, funnel and pyramid charts do not render the legend unless
      // displayInLegend property is set in at least one series or
      // custom legend sections are provided.
      if (
        (isStock || isFunnel || isPyramid) &&
        !hasSeriesDisplayedInLegend &&
        !hasCustomLegendSections
      ) {
        return false;
      }
      return true;
    },

    /**
     * Returns true if the chart has a time axis.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasTimeAxis: (chart) => {
      return (
        DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.getTimeAxisType(chart) != 'disabled'
      );
    },

    /**
     * Returns true if the chart has a group axis.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasGroupAxis: (chart) => {
      return (
        DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.getTimeAxisType(chart) == 'disabled'
      );
    },

    /**
     * Returns time axis type of the chart.
     * @param {Chart} chart
     * @return {boolean}
     */
    getTimeAxisType: (chart) => {
      var timeAxisType = chart.getOptions()['timeAxisType'];
      if (
        timeAxisType &&
        timeAxisType != 'auto' &&
        DvtChartTypeUtils.isBLAC(chart) &&
        !DvtChartTypeUtils.isPolar(chart)
      )
        return timeAxisType;
      if (DvtChartTypeUtils.isStock(chart)) return 'skipGaps';
      return 'disabled';
    },

    /**
     * Returns if the chart contains mixed frequency data.
     * @param {Chart} chart The chart that will be rendered.
     * @return {boolean} True if chart has mixed data.
     */
    isMixedFrequency: (chart) => {
      return DvtChartTypeUtils.getTimeAxisType(chart) == 'mixedFrequency';
    }
  };

  const DvtChartCoordUtils = {
    /**
     * Converts polar coord to cartesian coord.
     * @param {number} r The radius.
     * @param {number} theta The angle.
     * @param {dvt.Rectangle} availSpace The availSpace, to compute the center.
     * @return {dvt.Point} The cartesian coord.
     */
    polarToCartesian: (r, theta, availSpace) => {
      var x = availSpace.x + availSpace.w / 2 + r * Math.sin(theta);
      var y = availSpace.y + availSpace.h / 2 - r * Math.cos(theta);
      return new dvt.Point(x, y);
    },

    /**
     * Converts the axis coordinate into the plot area coordinate.
     * @param {Chart} chart
     * @param {dvt.Point} coord The axis coordinate.
     * @param {dvt.Rectangle} availSpace
     * @return {dvt.Point} The plot area coordinate.
     */
    convertAxisCoord: (chart, coord, availSpace) => {
      if (DvtChartTypeUtils.isPolar(chart)) {
        var cartesian = DvtChartCoordUtils.polarToCartesian(coord.y, coord.x, availSpace);
        return new dvt.Point(cartesian.x, cartesian.y);
      } else if (DvtChartTypeUtils.isHorizontal(chart)) return new dvt.Point(coord.y, coord.x);
      else return new dvt.Point(coord.x, coord.y);
    }
  };

  const DvtChartFormatUtils$1 = {
    /**
     * Returns the valueFormat of the specified type.
     * @param {Chart} chart
     * @param {string} type The valueFormat type, e.g. series, group, or x.
     * @return {object} The valueFormat.
     */
    getValueFormat: (chart, type) => {
      var valueFormats = chart.getOptions()['valueFormats'];
      if (!valueFormats) return {};

      if (valueFormats[type]) return valueFormats[type];

      // For chart with time axis, if group valueFormat is not defined, fall back to x.
      if (type == 'group' && DvtChartTypeUtils.hasTimeAxis(chart))
        return DvtChartFormatUtils$1.getValueFormat(chart, 'x');

      // For BLAC charts, if y/y2 valueFormat is not defined, fall back to value.
      if (
        (type == 'y' || type == 'y2' || type == 'min' || type == 'max') &&
        DvtChartTypeUtils.isBLAC(chart)
      )
        return DvtChartFormatUtils$1.getValueFormat(chart, 'value');

      return {};
    },

    /**
     * Formats value with the converter from the valueFormat.
     * @param {Chart} chart
     * @param {object} valueFormat
     * @param {number} value The value to format.
     * @param {number} min (optional) Min value of the axis corresponding to the value.  This should be provided only if the
     *                     label should be formatted in the context of the axis extents.
     * @param {number} max (optional) Max value of the axis corresponding to the value.  This should be provided only if the
     *                     label should be formatted in the context of the axis extents.
     * @param {number} majorIncrement (optional) major increment of the axis corresponding to the value.  This should be
     *                                provided only if the label should be formatted in the context of the axis extents.
     * @return {string} The formatted value string.
     */
    formatVal: (chart, valueFormat, value, min, max, majorIncrement) => {
      var scaling = 'auto';
      var autoPrecision = 'on';
      var converter;
      // override from valueFormat
      if (valueFormat['scaling']) scaling = valueFormat['scaling'];
      if (valueFormat['autoPrecision']) autoPrecision = valueFormat['autoPrecision'];
      if (valueFormat['converter']) converter = valueFormat['converter'];

      // Retrieve the extent information
      min = min != null ? min : value;
      max = max != null ? max : value;
      majorIncrement = majorIncrement != null ? majorIncrement : 0;

      // Create the formatter
      var formatter = new ojdvtAxis.LinearScaleAxisValueFormatter(
        min,
        max,
        majorIncrement,
        scaling,
        autoPrecision,
        chart.getOptions().translations
      );
      if (converter && converter['format']) return formatter.format(value, converter);
      else return formatter.format(value);
    },

    /**
     * Formats date with the converter from the valueFormat.
     * @param {object} valueFormat
     * @param {number} date The date to format.
     * @return {string} The formatted date string.
     */
    formatDateVal: (valueFormat, date) => {
      var converter = valueFormat['converter'];
      if (!converter) {
        return null;
      }
      if (converter['format']) {
        let _date = date;
        if (typeof date === 'number' && converter.resolvedOptions) {
          _date = new Date(date).toISOString();
        }
        return converter['format'](_date);
      }
      return null;
    }
  };

  /**
   * Data related utility functions for Chart.
   * @class
   */
  const DvtChartDataUtils = {
    /** @private */
    _SERIES_TYPE_RAMP: ['bar', 'line', 'area'],
    /**
     * Returns true if the specified chart has data.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasData: (chart) => {
      var options = chart.getOptions();

      // Check that there is a data object with at least one series
      if (!options || !options['series'] || options['series'].length < 1) return false;

      // Check that the minimum number of data points is present
      var minDataCount = 1;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var i = 0; i < seriesCount; i++) {
        var seriesItem = DvtChartDataUtils.getSeriesItem(chart, i);
        if (seriesItem && seriesItem['items'] && seriesItem['items'].length >= minDataCount)
          return true;
      }

      return false;
    },

    /**
     * Returns true if the specified chart doesn't have valid data.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasInvalidData: (chart) => {
      return !DvtChartDataUtils.hasData(chart) || DvtChartDataUtils.hasInvalidTimeData(chart);
    },

    /**
     * Returns true if the specified chart has a timeAxis without valid numerical values.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasInvalidTimeData: (chart) => {
      if (
        DvtChartTypeUtils.isFunnel(chart) ||
        DvtChartTypeUtils.isPie(chart) ||
        DvtChartTypeUtils.isPyramid(chart)
      )
        return false;

      var options = chart.getOptions();
      var groupCount = DvtChartDataUtils.getGroupCount(chart);

      // Check that there is a data object with at least one series
      if (!options || !options['series'] || options['series'].length < 1) return true;
      // Check that there is a data object with at least one group
      if (groupCount < 1) return true;

      var seriesIndex, groupIndex;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);

      if (DvtChartTypeUtils.isMixedFrequency(chart)) {
        // Mixed frequency time axis uses x values to specify the dates
        for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
          for (groupIndex = 0; groupIndex < groupCount; groupIndex++) {
            var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
            if (dataItem && (dataItem['x'] == null || isNaN(dataItem['x'])))
              //Invalid values will either be NaN or null depending on the browser
              return true;
          }
        }
      } else if (DvtChartTypeUtils.hasTimeAxis(chart)) {
        // Check that all values are numbers
        for (groupIndex = 0; groupIndex < groupCount; groupIndex++) {
          var groupItem = DvtChartDataUtils.getGroup(chart, groupIndex);
          if (groupItem == null || isNaN(groupItem)) return true;
        }
      }

      return false;
    },

    /**
     * Returns true if the specified chart series has non-null data.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {boolean}
     */
    hasSeriesData: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      var dataItems = seriesItem['items'];
      if (dataItems) {
        for (var i = 0; i < dataItems.length; i++) {
          if (dataItems[i] != null) return true;
        }
      }

      // No data items or no non-null data items
      return false;
    },

    /**
     * Returns the number of series in the specified chart.
     * @param {Chart} chart
     * @return {number}
     */
    getSeriesCount: (chart) => {
      var seriesArray = chart.getOptions()['series'];
      return seriesArray ? seriesArray.length : 0;
    },

    /**
     * Returns the number of rendered y2 series in the specified chart. If type is specified returns the number of y2 series of that type.
     * @param {Chart} chart
     * @param {String} type (optional)
     * @param {Boolean} bIncludeHiddenSeries (optional) Whether or not to include hidden y2 series in the total, defaults to false.
     * @return {number}
     */
    getY2SeriesCount: (chart, type, bIncludeHiddenSeries) => {
      var y2SeriesCount = 0;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        if (type && DvtChartDataUtils.getSeriesType(chart, seriesIndex) != type) continue;
        if (!bIncludeHiddenSeries && !DvtChartDataUtils.isSeriesRendered(chart, seriesIndex))
          continue;
        if (DvtChartDataUtils.isAssignedToY2(chart, seriesIndex)) y2SeriesCount++;
      }
      return y2SeriesCount;
    },

    /**
     * Returns the id for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {string} The id of the series.
     */
    getSeries: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem) {
        if (seriesItem['id']) return seriesItem['id'];
        else if (seriesItem['name'] || seriesItem['name'] === '') return seriesItem['name'];
        return String(seriesIndex);
      }
      return null;
    },

    /**
     * Returns the label for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {string} The label for the series.
     */
    getSeriesLabel: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['name'] || seriesItem['name'] === '')) return seriesItem['name'];
      return null;
    },

    /**
     * Returns the index for the specified series.
     * @param {Chart} chart
     * @param {string} series The id of the series
     * @return {number} The index of the series.
     */
    getSeriesIdx: (chart, series) => {
      var numSeries = DvtChartDataUtils.getSeriesCount(chart);
      for (var seriesIndex = 0; seriesIndex < numSeries; seriesIndex++) {
        var seriesId = DvtChartDataUtils.getSeries(chart, seriesIndex);
        if (seriesId == series) return seriesIndex;
      }

      // No match found
      return -1;
    },

    /**
     * Returns the style index for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {number} The index to use when looking for style information.
     */
    getSeriesStyleIdx: (chart, seriesIndex) => {
      if (chart.getOptionsCache().getFromCache('hasLargeSeriesCount')) return seriesIndex;

      var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      if (series == null) return seriesIndex;

      return chart.getSeriesStyleArray().indexOf(series);
    },

    /**
     * Returns the series item for the specified index.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {object} The series data item.
     */
    getSeriesItem: (chart, seriesIndex) => {
      if (isNaN(seriesIndex) || seriesIndex == null || seriesIndex < 0) return null;

      var options = chart.getOptions();
      if (options['series'] && options['series'].length > seriesIndex)
        return options['series'][seriesIndex];
      return null;
    },

    /**
     * Returns the data item for the specified index.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {object} The data item.
     */
    getDataItem: (chart, seriesIndex, groupIndex) => {
      if (isNaN(groupIndex) || groupIndex == null || groupIndex < 0) return null;

      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['items'] && seriesItem['items'].length > groupIndex)
        return seriesItem['items'][groupIndex];

      return null;
    },

    /**
     * Returns the raw data item for the specified index. Used for drill events
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {object} The data item.
     */
    getRawDataItem: (chart, seriesIndex, groupIndex) => {
      if (isNaN(groupIndex) || groupIndex == null || groupIndex < 0) {
        return null;
      }
      var dataItem = chart.getRawOptions().series[seriesIndex].items[groupIndex];
      if (typeof dataItem === 'number') {
        return dataItem;
      }

      // for missing data in group or series
      if (!dataItem) {
        return null;
      }

      var clonedData = Object.assign({}, dataItem);
      clonedData['itemData'] = dataItem['_itemData'];
      delete clonedData['_itemData'];
      return clonedData;
    },

    /**
     * Returns the id of the data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {string} The data item id.
     */
    getDataItemId: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (!dataItem) return null;

      if (dataItem['id'] != null) return dataItem['id'];

      // default id
      return DvtChartDataItemUtils.createDataItemId(
        DvtChartDataUtils.getSeries(chart, seriesIndex),
        DvtChartDataUtils.getGroup(chart, groupIndex)
      );
    },

    /**
     * Returns the specified nested data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {number}
     */
    getNestedDataItem: (chart, seriesIndex, groupIndex, itemIndex) => {
      if (isNaN(itemIndex) || itemIndex == null || itemIndex < 0) return null;

      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['items'] && dataItem['items'].length > itemIndex)
        return dataItem['items'][itemIndex];

      return null;
    },

    /**
     * Returns the number of nested data items for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {number}
     */
    getNestedDataItemCount: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);

      if (dataItem && dataItem['items']) return dataItem['items'].length;

      return 0;
    },

    /**
     * Returns the id of the nested data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The nested data item id.
     */
    getNestedDataItemId: (chart, seriesIndex, groupIndex, itemIndex) => {
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (!nestedDataItem) return null;

      if (nestedDataItem['id'] != null) return nestedDataItem['id'];

      // default id
      return (
        DvtChartDataUtils.getDataItemId(chart, seriesIndex, groupIndex) + '; ' + String(itemIndex)
      );
    },

    /**
     * Returns the index of the nested data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {string} id The id of the nested data item.
     * @return {number}
     */
    getNestedDataItemIdx: (chart, seriesIndex, groupIndex, id) => {
      var numItems = DvtChartDataUtils.getNestedDataItemCount(chart, seriesIndex, groupIndex);
      for (var itemIndex = 0; itemIndex < numItems; itemIndex++) {
        var itemId = DvtChartDataUtils.getNestedDataItemId(chart, seriesIndex, groupIndex, itemIndex);
        if (DvtChartDataItemUtils.isEqualId(itemId, id, chart.getCtx())) return itemIndex;
      }

      // No match found
      return -1;
    },

    /**
     * Returns the number of groups in the specified chart.
     * @param {Chart} chart
     * @return {number}
     */
    getGroupCount: (chart) => {
      return DvtChartDataUtils._getGroupsArray(chart).length;
    },

    /**
     * Returns the group id for the specified group index.
     * @param {Chart} chart
     * @param {Number} groupIndex The group index.
     * @return {string} The group id, null if the index is invalid.
     */
    getGroup: (chart, groupIndex) => {
      if (
        groupIndex != null &&
        groupIndex >= 0 &&
        groupIndex < DvtChartDataUtils.getGroupCount(chart)
      ) {
        var group = DvtChartDataUtils._getGroupsArray(chart)[groupIndex];
        if (group) {
          if (group['id'] != null) return group['id'];
          else if (group['name'] != null) return group['name'];
          return String(groupIndex);
        }
      }

      return null;
    },

    /**
     * Returns the index of the group with the specified id.
     * @param {Chart} chart
     * @param {string|Array} group The group whose index will be returned.
     * @return {number} The index of the group
     */
    getGroupIdx: (chart, group) => {
      var groups = DvtChartDataUtils.getGroups(chart);
      for (var i = 0; i < groups.length; i++) {
        if (
          group instanceof Array && groups[i] instanceof Array
            ? dvt.ArrayUtils.equals(group, groups[i])
            : group === groups[i]
        )
          return i;
      }
      return -1;
    },

    /**
     * Returns the group label for the specified group index.
     * @param {Chart} chart
     * @param {Number} groupIndex The group index.
     * @return {string} The group label, null if the index is invalid.
     */
    getGroupLabel: (chart, groupIndex) => {
      if (groupIndex >= 0 && groupIndex < DvtChartDataUtils.getGroupCount(chart)) {
        var group = DvtChartDataUtils._getGroupsArray(chart)[groupIndex];
        if (group) {
          if (group['name'] != null) return group['name'];
          else if (group['id'] != null || typeof group !== 'string')
            // Empty or null group name allowed if id is specified
            return '';
          return group;
        }
      }

      return null;
    },

    /**
     * Returns a list of the group ids in the chart's data.
     * @param {Chart} chart
     * @return {Array} An array of the group id's.
     */
    getGroups: (chart) => {
      var cacheKey = 'groups';
      var groups = chart.getOptionsCache().getFromCache(cacheKey);
      if (!groups) {
        var groupCount = DvtChartDataUtils.getGroupCount(chart);
        groups = [];
        for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {
          groups.push(DvtChartDataUtils.getGroup(chart, groupIndex));
        }
        chart.getOptionsCache().putToCache(cacheKey, groups);
      }
      return groups;
    },

    /**
     * Returns a structure containing the ids and names associated with each innermost group item.
     * @param {Chart} chart
     * @return {Array} An array of objects containing the ids and names associated with each innermost group item.
     * @private
     */
    _getGroupsArray: (chart) => {
      var options = chart.getOptions();
      var cacheKey = 'groupsArray';
      var groupsArray = chart.getOptionsCache().getFromCache(cacheKey);

      if (!groupsArray) {
        groupsArray = [];

        if (options['groups'])
          groupsArray = DvtChartDataUtils._getNestedGroups(options['groups'], groupsArray);

        for (var i = 0; i < groupsArray.length; i++) {
          if (groupsArray[i]['id'].length == 1) {
            groupsArray[i]['id'] = groupsArray[i]['id'][0];
            groupsArray[i]['name'] = groupsArray[i]['name'][0];
          }
        }

        chart.getOptionsCache().putToCache(cacheKey, groupsArray);
      }

      return groupsArray;
    },

    /**
     * Returns a structure containing the ids and names associated with each innermost group item.
     * @param {Array} groups An array of chart groups
     * @param {Array} groupsArray The array of objects associated with each group item
     * @return {Array} An array of objects containing the ids and names associated with each innermost group item.
     * @private
     */
    _getNestedGroups: (groups, groupsArray) => {
      if (!groups || groups.length == 0) return [];

      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var elementId = null;
        var elementName = null;
        if (group != null) {
          elementId = group.id != null ? group.id : group.name;
          elementId = elementId != null ? elementId : group;
          elementName = group['name'] ? group['name'] : group;
        }
        if (typeof elementId == 'object') elementId = null;
        if (typeof elementName == 'object') elementName = null;

        if (group && group['groups']) {
          var innerGroupArray = DvtChartDataUtils._getNestedGroups(group['groups'], []);
          if (innerGroupArray.length == 0) innerGroupArray.push({ id: [], name: [] });
          for (var j = 0; j < innerGroupArray.length; j++) {
            innerGroupArray[j]['id'].unshift(elementId);
            innerGroupArray[j]['name'].unshift(elementName);
          }
          groupsArray = groupsArray.concat(innerGroupArray);
        } else groupsArray.push({ id: [elementId], name: [elementName] });
      }
      return groupsArray;
    },

    /**
     * Returns the number of levels of hierarchical groups
     * @param {Chart} chart
     * @return {number} The number of label levels.
     */
    getNumLevels: (chart) => {
      var cacheKey = 'groupsNumLevels';
      var numLevels = chart.getOptionsCache().getFromCache(cacheKey);
      if (numLevels != null) return numLevels;

      // Compute the value
      numLevels = 0;
      var groupsArray = DvtChartDataUtils._getGroupsArray(chart);
      for (var i = 0; i < groupsArray.length; i++) {
        var group = groupsArray[i];
        if (group && group['id']) {
          var length = Array.isArray(group['id']) ? group['id'].length : 1;
          numLevels = Math.max(numLevels, length);
        }
      }

      // Put the computed value into the cache and return
      chart.getOptionsCache().putToCache(cacheKey, numLevels);
      return numLevels;
    },

    /**
     * Returns the value for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {number} The value of the specified data item.
     */
    getVal: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Use the cached value if it has been computed before
      var val;
      var cacheKey = 'value';
      var isNested = typeof itemIndex == 'number' && itemIndex >= 0;
      if (!isNested) {
        val = chart.getOptionsCache().getFromCachedMap2D(cacheKey, seriesIndex, groupIndex);
        if (val !== undefined)
          // anything that's defined, including null
          return val;
      }

      var dataItem = isNested
        ? DvtChartDataUtils.getNestedDataItem(chart, seriesIndex, groupIndex, itemIndex)
        : DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);

      val = null;
      if (dataItem != null) {
        if (typeof dataItem != 'object')
          // Number, just return
          val = dataItem;
        else if (DvtChartTypeUtils.isStock(chart) && dataItem['close'] != null)
          // Use the close value for stock
          val = dataItem['close'];
        else if (dataItem['value'] != null)
          // Object with value property
          val = dataItem['value'];
        else if (dataItem['y'] != null)
          // Object with y property
          val = dataItem['y'];
      }

      //  - timeaxis chart breaks when series value is NaN
      val = val || (val === 0 ? 0 : null);

      // Cache the value
      if (!isNested) chart.getOptionsCache().putToCachedMap2D(cacheKey, seriesIndex, groupIndex, val);

      return val;
    },

    /**
     * Returns the cumulative value for the specified data item, taking into account stacked values.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {boolean} bIncludeHiddenSeries True if hidden series should be included in the value calculation.
     * @return {number} The value of the specified data item.
     */
    getCumulativeVal: (chart, seriesIndex, groupIndex, bIncludeHiddenSeries) => {
      if (!DvtChartDataUtils.isStacked(chart)) {
        return DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);
      }

      // Use the cached value if it has been computed before
      var cacheKey = bIncludeHiddenSeries ? 'cumValueH' : 'cumValue';
      var cumVal = chart.getCache().getFromCachedMap2D(cacheKey, seriesIndex, groupIndex);
      if (cumVal !== undefined)
        // anything that's defined, including null
        return cumVal;

      // Match the series type and add up the values
      var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
      var value = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);
      var category = DvtChartDataUtils.getStackCategory(chart, seriesIndex);

      // Determine if to add to negative stack
      // If a bar chart use item value, otherwise use the whole series
      var isNegative =
        seriesType == 'bar' ? value < 0 : DvtChartDataUtils.isSeriesNegative(chart, seriesIndex);

      cumVal = 0;
      for (var i = seriesIndex; i >= 0; i--) {
        // Looping in reverse order to leverage previoulsy cached cumulative values
        // Skip series that are not rendered
        if (!bIncludeHiddenSeries && !DvtChartDataUtils.isDataItemRendered(chart, i, groupIndex))
          continue;

        // Skip series that don't match the type
        if (seriesType != DvtChartDataUtils.getSeriesType(chart, i)) continue;

        // Skip series who aren't assigned to the same y axis
        if (bAssignedToY2 != DvtChartDataUtils.isAssignedToY2(chart, i)) continue;

        // Add up all the values for items in the group in the same stack.  Null values are treated as 0.
        if (DvtChartDataUtils.getStackCategory(chart, i) == category) {
          var groupValue = DvtChartDataUtils.getVal(chart, i, groupIndex);

          // only add up positive values of items if current bar being processed is positive, and vice versa.
          var isCurrentNegative =
            seriesType == 'bar' ? groupValue < 0 : DvtChartDataUtils.isSeriesNegative(chart, i);

          if ((isNegative && isCurrentNegative) || (!isNegative && !isCurrentNegative)) {
            var prevCumVal = chart.getCache().getFromCachedMap2D(cacheKey, i, groupIndex);
            if (prevCumVal !== undefined) {
              cumVal = value + (prevCumVal || 0);
              break;
            }
            cumVal += groupValue == null || isNaN(groupValue) ? 0 : groupValue;
          }
        }
      }

      // Cache the value
      chart.getCache().putToCachedMap2D(cacheKey, seriesIndex, groupIndex, cumVal);
      return cumVal;
    },

    /**
     * Returns the low value for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {number} The value of the specified data item.
     */
    getLowVal: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem == null)
        // null or undefined, return null
        return null;
      if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'candlestick') {
        if (dataItem['low'] == null && dataItem['close'] != null) {
          if (dataItem['open'] != null) return Math.min(dataItem['close'], dataItem['open']);
          return dataItem['close'];
        }
        return dataItem['low'];
      }
      if (dataItem['low'] != null && dataItem['close'] == null) return dataItem['low'];
      return null;
    },

    /**
     * Returns the high value for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {number} The value of the specified data item.
     */
    getHighVal: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem == null)
        // null or undefined, return null
        return null;
      if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'candlestick') {
        if (dataItem['high'] == null) {
          if (dataItem['open'] != null) return Math.max(dataItem['close'], dataItem['open']);
          return dataItem['close'];
        }
        return dataItem['high'];
      }
      if (dataItem['high'] != null && dataItem['close'] == null) return dataItem['high'];
      return null;
    },

    /**
     * Returns the X value of a data point.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {number} The X value.
     */
    getXVal: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      return DvtChartDataUtils.getXValFromItem(chart, dataItem, groupIndex);
    },

    /**
     * Returns the X value given an item object and the group index. Used by series items and ref obj items.
     * @param {Chart} chart
     * @param {object} item The item object of a series or ref obj.
     * @param {number} groupIndex
     * @return {number} The X value.
     */
    getXValFromItem: (chart, item, groupIndex) => {
      if (item != null && item['x'] != null) return item['x'];
      if (DvtChartTypeUtils.hasGroupAxis(chart)) return groupIndex;
      if (DvtChartTypeUtils.hasTimeAxis(chart) && !DvtChartTypeUtils.isMixedFrequency(chart))
        return DvtChartDataUtils.getGroupLabel(chart, groupIndex);
      return null;
    },

    /**
     * Returns the target value for the specified data item in funnel charts.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {number} The target value of the specified data item.
     */
    getTargetVal: (chart, seriesIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, 0);
      if (dataItem == null || typeof dataItem != 'object') return null;
      return dataItem['targetValue'];
    },

    /**
     * Returns the z value for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} defaultVal The default value if the z is not specified,
     * @return {number} The z value of the specified data item.
     */
    getZVal: (chart, seriesIndex, groupIndex, defaultVal) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem == null || typeof dataItem != 'object') return defaultVal;
      if (dataItem['z'] != null)
        // Object with value property
        return Math.max(0, dataItem['z']); // override any negative z-values as 0
      return defaultVal;
    },

    /**
     * Returns true if the stock value is rising, false otherwise. Returns true for null or equal values.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {boolean}
     */
    isStockValRising: (chart, seriesIndex, groupIndex) => {
      // Note: We return true for equality or null values, because stocks are generally shown as black for 0 or positive.
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      return dataItem ? dataItem['open'] <= dataItem['close'] : true;
    },

    /**
     * Returns the categories of the specified item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number=} groupIndex
     * @param {number} itemIndex
     * @return {string}
     */
    getCategories: (chart, seriesIndex, groupIndex, itemIndex) => {
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['categories']) return nestedDataItem['categories'];

      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['categories']) return dataItem['categories'];

      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['categories']) return seriesItem['categories'];

      var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      if (series != null) return [series];

      return [];
    },

    /**
     * Returns true if the series is assigned to the y2 axis.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {boolean} True if the series is assigned to the y2 axis.
     */
    isAssignedToY2: (chart, seriesIndex) => {
      if (!chart.getOptionsCache().getFromCache('hasY2Assignment')) return false;
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      return seriesItem && seriesItem['assignedToY2'] == 'on' && DvtChartTypeUtils.isDualY(chart);
    },

    /**
     * Returns the array of initially selected objects for a chart.  This information is based on the data object.
     * @param {Chart} chart The chart that will be rendered.
     * @return {array} The array of selected objects.
     */
    getInitialSelection: (chart) => {
      var selection = chart.getOptions()['selection'];
      var hasDataProvider = chart.getOptions()['data'] != null;
      if (!selection) selection = [];

      // Process the data item ids and fill in series and group information
      var peers = chart.getChartObjPeers();
      for (var i = 0; i < selection.length; i++) {
        var id = selection[i]['id'] != null && !hasDataProvider ? selection[i]['id'] : selection[i]; // check first if selection object has an id value
        if (selection[i]['id'] == null && !selection[i]['series'] && !selection[i]['group']) {
          selection[i] = { id: id };
        }

        // If id is defined, but series and group are not
        if (id != null && !(selection[i]['series'] && selection[i]['group'])) {
          for (var j = 0; j < peers.length; j++) {
            var peer = peers[j];
            if (DvtChartDataItemUtils.isEqualId(id, peer.getDataItemId(), chart.getCtx())) {
              selection[i]['series'] = peer.getSeries();
              selection[i]['group'] = peer.getGroup();
              break;
            }
          }
        }
      }

      return selection;
    },

    /**
     * Returns the current selection for the chart.  This selection is in the format of the data['selection'] API.
     * @param {Chart} chart The chart that will be rendered.
     * @return {array} The array of selected objects.
     */
    getCurrentSelection: (chart) => {
      var selection = [];
      var handler = chart.getSelectionHandler();
      if (handler) {
        var selectedIds = handler.getSelectedIds();
        for (var i = 0; i < selectedIds.length; i++) {
          var selectedId = selectedIds[i]; // selectedId is an instance of DvtChartDataItem
          selection.push({ series: selectedId.series, group: selectedId.group, id: selectedId.id });
        }
      }

      return selection;
    },

    /**
     * Returns whether the stock chart has a volume series
     * @param {Chart} chart
     * @return {boolean}
     */
    hasVolumeSeries: (chart) => {
      var hasVolume = chart.getOptionsCache().getFromCache('hasVolume');
      return hasVolume ? hasVolume : false;
    },

    /**
     * Returns whether the data point is currently selected.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {boolean}
     */

    isDataSelected: (chart, seriesIndex, groupIndex, itemIndex) => {
      var isNested = !isNaN(itemIndex) && itemIndex != null && itemIndex >= 0;
      var id = isNested
        ? DvtChartDataUtils.getNestedDataItemId(chart, seriesIndex, groupIndex, itemIndex)
        : DvtChartDataUtils.getDataItemId(chart, seriesIndex, groupIndex);
      var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      var group = DvtChartDataUtils.getGroup(chart, groupIndex);

      // Check based on the selection attribute instead of asking the selectionHandler because
      // this method is called before the initial selection is set.
      var selection = chart.getOptions()['selection'];
      if (!selection) selection = [];

      for (var i = 0; i < selection.length; i++) {
        if (
          DvtChartDataItemUtils.isEqualId(id, selection[i], chart.getCtx()) ||
          DvtChartDataItemUtils.isEqualId(id, selection[i]['id'], chart.getCtx())
        )
          return true;
        if (
          selection[i]['id'] == null &&
          DvtChartDataItemUtils.isEqualId(series, selection[i]['series'], chart.getCtx()) &&
          DvtChartDataItemUtils.isEqualId(group, selection[i]['group'], chart.getCtx())
        )
          return true;
      }

      return false;
    },

    /**
     * Returns the default data label for the specified data point. It ignores the dataLabel function
     * @param {Chart} chart
     * @param {number} seriesIndex The series index.
     * @param {number} groupIndex The group index.
     * @param {number} itemIndex The nested item index.
     * @param {number} type (optional) Data label type: low, high, or value.
     * @param {boolean} isStackLabel true if label for stack cummulative, false otherwise
     * @return {string} The default data label, null if the index is invalid.
     */
    getDefaultDataLabel: (chart, seriesIndex, groupIndex, itemIndex, type, isStackLabel) => {
      var label;
      if (isStackLabel) label = DvtChartDataUtils.getCumulativeVal(chart, seriesIndex, groupIndex);
      else {
        var isNested = !isNaN(itemIndex) && itemIndex != null && itemIndex >= 0;
        var dataItem = isNested
          ? DvtChartDataUtils.getNestedDataItem(chart, seriesIndex, groupIndex, itemIndex)
          : DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
        if (!dataItem) return null;

        label = dataItem['label'];
        // Range series data label support
        if (type == 'low') label = label instanceof Array ? label[0] : label;
        else if (type == 'high') label = label instanceof Array ? label[1] : null;
      }

      if (label != null) {
        // Numbers will be formatted, while all other labels will be treated as strings
        if (typeof label == 'number') {
          // Find the extents of the corresponding axis
          // Note: We assume y axis here because charts with numerical x axis would not pass a single value for the label.
          var min, max, majorIncrement;
          var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
          var axis = bAssignedToY2 && chart.y2Axis ? chart.y2Axis : chart.yAxis;
          if (axis) {
            var axisInfo = axis.getInfo();
            min = axisInfo.getGlobalMin();
            max = axisInfo.getGlobalMax();
            majorIncrement = axisInfo.getMajorIncrement();
          }

          var valueFormat = DvtChartFormatUtils$1.getValueFormat(chart, 'label');
          return DvtChartFormatUtils$1.formatVal(chart, valueFormat, label, min, max, majorIncrement);
        }
        return label;
      }
      return null;
    },

    /**
     * Returns the stack category of the specified series. If the chart is unstacked, returns the series name.
     * @param {Chart} chart
     * @param {Number} seriesIndex The series index.
     * @return {String} The stack category for stacked; the series name for unstacked.
     */
    getStackCategory: (chart, seriesIndex) => {
      var cacheKey = 'stackCategory';
      var stackCategory = chart.getCache().getFromCachedMap(cacheKey, seriesIndex);
      if (typeof stackCategory != 'undefined') {
        return stackCategory;
      }

      if (DvtChartDataUtils.isStacked(chart))
        stackCategory = DvtChartDataUtils.getSeriesItem(chart, seriesIndex)['stackCategory'] || null;
      else stackCategory = DvtChartDataUtils.getSeries(chart, seriesIndex) || null; // each series is its own stack category

      chart.getCache().putToCachedMap(cacheKey, seriesIndex, stackCategory);
      return stackCategory;
    },

    /**
     * Returns the lists of the stack categories for a series type.
     * @param {Chart} chart
     * @param {String} type (optional) The series type.
     * @param {Boolean} bIncludeHiddenSeries (optional) Whether or not to include hidden series categories, defaults to false.
     * @return {Object} An object containing the arrays of stack categories for y and y2 axis respectively.
     */
    getStackCategories: (chart, type, bIncludeHiddenSeries) => {
      var yCategories = [],
        y2Categories = [];
      var yCategoriesHash = {},
        y2CategoriesHash = {}; // this is for performance to track categories processed
      var cacheKey = 'stackCategories';
      var categories = chart.getCache().getFromCachedMap2D(cacheKey, type, bIncludeHiddenSeries);
      if (categories) return categories;

      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var s = 0; s < seriesCount; s++) {
        // Intentionally split up below for readability
        if (!DvtChartDataUtils.isSeriesRendered(chart, s) && !bIncludeHiddenSeries)
          // skip unrendered series
          continue;
        else if (type) {
          // Treat candlestick and boxPlot as bar, as it inherits all the gap properties from bar.
          var seriesType = DvtChartDataUtils.getSeriesType(chart, s);
          if (seriesType == 'candlestick' || seriesType == 'boxPlot') seriesType = 'bar';

          if (type != seriesType) continue;
        }

        var category = DvtChartDataUtils.getStackCategory(chart, s);
        if (DvtChartDataUtils.isAssignedToY2(chart, s)) {
          if (!y2CategoriesHash[category]) {
            y2Categories.push(category);
            y2CategoriesHash[category] = true;
          }
        } else if (!yCategoriesHash[category]) {
          yCategories.push(category);
          yCategoriesHash[category] = true;
        }
      }

      categories = { y: yCategories, y2: y2Categories };
      chart.getCache().putToCachedMap2D(cacheKey, type, bIncludeHiddenSeries, categories);
      return categories;
    },

    /**
     * Computes z-value width of the specified stack category in a group.
     * @param {Chart} chart
     * @param {String} category The stack category. Use the series name for unstacked charts.
     * @param {Number} groupIndex
     * @param {Boolean} isY2 Whether the stack belongs to y2 axis.
     * @return {Number} The z-value width.
     */
    getBarCategoryZ: (chart, category, groupIndex, isY2) => {
      var width = 0;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var s = 0; s < seriesCount; s++) {
        var seriesType = DvtChartDataUtils.getSeriesType(chart, s);
        if (
          (seriesType != 'bar' && seriesType != 'candlestick' && seriesType != 'boxPlot') ||
          DvtChartDataUtils.getStackCategory(chart, s) != category ||
          !DvtChartDataUtils.isSeriesRendered(chart, s)
        )
          continue;

        // Compute the maximum z-value of the bars in the stack.
        var isSeriesY2 = DvtChartDataUtils.isAssignedToY2(chart, s);
        if ((isY2 && isSeriesY2) || (!isY2 && !isSeriesY2))
          width = Math.max(width, DvtChartDataUtils.getZVal(chart, s, groupIndex, 1));
      }

      return width;
    },

    /**
     * Returns the marker position for the specified index.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @param {dvt.Rectangle} availSpace
     * @return {dvt.Point} The marker position.
     */
    getMarkerPos: (chart, seriesIndex, groupIndex, itemIndex, availSpace) => {
      var xAxis = chart.xAxis;
      var yAxis = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex) ? chart.y2Axis : chart.yAxis;
      var isPolar = DvtChartTypeUtils.isPolar(chart);
      var bRange = DvtChartDataUtils.isRangeSeries(chart, seriesIndex);
      var isNested = !isNaN(itemIndex) && itemIndex != null && itemIndex >= 0;

      // Get the x-axis position
      var xValue = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
      var yValue = isNested
        ? DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex, itemIndex)
        : DvtChartDataUtils.getCumulativeVal(chart, seriesIndex, groupIndex);
      var xCoord, yCoord;

      // Get the position of the marker
      if (DvtChartTypeUtils.isBubble(chart)) {
        // The yValue for polar shouldn't go below the minimum because it will appear on the opposite side of the chart
        if (isPolar && yValue < yAxis.getInfo().getViewportMin()) return null;
        // Markers for most graph types must be within the plot area to be rendered.  Bubble markers
        // do not, as they are available clipped to the plot area bounds.
        if (isPolar) xCoord = xAxis.getCoordAt(xValue);
        // if we use unbounded here, the value will wrap around the angle.
        else xCoord = xAxis.getUnboundedCoordAt(xValue);
        yCoord = yAxis.getUnboundedCoordAt(yValue);
      } else if (bRange) {
        var lowCoord = yAxis.getCoordAt(DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex));
        var highCoord = yAxis.getCoordAt(
          DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex)
        );

        xCoord = xAxis.getCoordAt(DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex));
        yCoord = (lowCoord + highCoord) / 2;
      } else {
        xCoord = xAxis.getCoordAt(xValue);
        yCoord = yAxis.getCoordAt(yValue);
      }
      if (xCoord == null || yCoord == null) return null;

      return DvtChartCoordUtils.convertAxisCoord(chart, new dvt.Point(xCoord, yCoord), availSpace);
    },

    /**
     * Returns the marker position for the specified index. Optimized for large data
     * scatter and bubble charts. Differs from the normal getMarkerPosition in that
     * elements just outside the viewport are ignored.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {dvt.Point} The marker position.
     */
    getScatterBubbleMarkerPos: (chart, seriesIndex, groupIndex) => {
      var xAxis = chart.xAxis;
      var yAxis = chart.yAxis;

      // Get the x-axis position
      var xValue = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
      var yValue = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);

      // Get the position of the marker
      var xCoord = xAxis.getCoordAt(xValue);
      var yCoord = yAxis.getCoordAt(yValue);
      if (xCoord == null || yCoord == null) return null;
      return new dvt.Point(xCoord, yCoord);
    },

    /**
     * Returns true if all the values of the series are negative.
     * @param {Chart} chart
     * @param {Number} seriesIndex
     * @return {boolean}
     */
    isSeriesNegative: (chart, seriesIndex) => {
      if (!chart.getOptionsCache().getFromCache('hasNegativeValues')) return false;

      var isSeriesNegative = chart
        .getOptionsCache()
        .getFromCachedMap('isSeriesNegative', seriesIndex);
      if (isSeriesNegative != null) return isSeriesNegative;
      var groupCount = DvtChartDataUtils.getGroupCount(chart);
      isSeriesNegative = true;
      for (var i = 0; i < groupCount; i++) {
        // Use first non zero value to set series type(negative or positive)
        var value = DvtChartDataUtils.getVal(chart, seriesIndex, i);
        if (value > 0) {
          isSeriesNegative = false;
          break;
        }
      }
      chart.getOptionsCache().putToCachedMap('isSeriesNegative', seriesIndex, isSeriesNegative);
      return isSeriesNegative;
    },

    /**
     * Returns an array containing the hierarchical groups  associated with each innermost group item.
     * @param {Chart} chart
     * @return {Array} An array containing the hierarchical groups  associated with each innermost group item in chart.
     */
    getGroupsDataForContext: (chart) => {
      var cacheKey = 'groupsDataArray';
      var groupsDataArray = chart.getOptionsCache().getFromCache(cacheKey);

      if (!groupsDataArray) {
        var rawOptions = chart.getRawOptions();
        groupsDataArray = DvtChartDataUtils._getNestedGroupsData(rawOptions['groups']);
        chart.getOptionsCache().putToCache(cacheKey, groupsDataArray);
      }

      return groupsDataArray;
    },

    getSeriesDataForContext: (chart, seriesIndex) => {
      var rawOptions = chart.getRawOptions();
      var seriesData = rawOptions['series'][seriesIndex];
      var clonedSeriesData = Object.assign({}, seriesData);
      clonedSeriesData.items = []; // Object.assign doesn't clone array properties
      for (var i = 0; i < seriesData.items.length; i++) {
        var item;
        var seriesItem = seriesData.items[i];
        if (typeof seriesItem === 'object') {
          item = Object.assign({}, seriesData.items[i]);
        } else {
          item = seriesItem;
        }
        if (item && typeof item === 'object') {
          delete item['_itemData'];
        }
        clonedSeriesData.items.push(item);
      }
      return clonedSeriesData;
    },

    /**
     * Returns a structure containing the hierarchical groups  associated with each innermost group item.
     * @param {Array} groups An array of chart groups
     * @return {Array} An array of objects containing the hierarchical groups associated with each innermost group items in groups.
     * @private
     */
    _getNestedGroupsData: (groups) => {
      if (!groups) return [];
      var groupsDataArray = [];

      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];

        if (group['groups']) {
          var innerGroupData = DvtChartDataUtils._getNestedGroupsData(group['groups']);
          for (var j = 0; j < innerGroupData.length; j++) {
            innerGroupData[j].unshift(group);
          }
          groupsDataArray = groupsDataArray.concat(innerGroupData);
        } else groupsDataArray.push([group]);
      }
      return groupsDataArray;
    },

    /**
     * Populates a cache map indicating if a data item is the outermost bar. Null items are ignored.
     * @param {Chart} chart
     * @private
     */
    _computeOutermostBarMap: (chart) => {
      if (!chart.getOptionsCache().getFromCache('outermostBar')) {
        var stackMap = {};
        var numSeries = DvtChartDataUtils.getSeriesCount(chart);
        var hasNegativeValues = chart.getOptionsCache().getFromCache('hasNegativeValues');

        // Iterate through the series and create an object maping stack category to a list of series.
        for (var seriesIndex = numSeries - 1; seriesIndex >= 0; seriesIndex--) {
          if (
            !DvtChartDataUtils.isSeriesRendered(chart, seriesIndex) ||
            DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'bar'
          )
            continue;
          var stackCategory = DvtChartDataUtils.getStackCategory(chart, seriesIndex) || '';
          var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
          var stackKey = stackCategory + bAssignedToY2;
          if (stackMap[stackKey]) stackMap[stackKey].push(seriesIndex);
          else stackMap[stackKey] = [seriesIndex];
        }

        // For each stack category, iterate through each group and the series that are part of the stack.
        // If both the positive and negative outermost series are found then we can exit the series loop.
        var numGroups = DvtChartDataUtils.getGroupCount(chart);
        for (var key in stackMap) {
          var seriesList = stackMap[key];
          for (var groupIndex = 0; groupIndex < numGroups; groupIndex++) {
            var hasPositiveOutermost = false;
            var hasNegativeOutermost = false;
            for (var seriesListIndex = 0; seriesListIndex < seriesList.length; seriesListIndex++) {
              if (
                (!hasNegativeValues && hasPositiveOutermost) ||
                (hasPositiveOutermost && hasNegativeOutermost)
              )
                break;

              seriesIndex = seriesList[seriesListIndex];
              if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex)) continue;

              var value = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);
              if (value == null) {
                chart
                  .getOptionsCache()
                  .putToCachedMap2D('outermostBar', seriesIndex, groupIndex, false);
              } else if (!hasPositiveOutermost && value >= 0) {
                hasPositiveOutermost = true;
                chart
                  .getOptionsCache()
                  .putToCachedMap2D('outermostBar', seriesIndex, groupIndex, true);
              } else if (!hasNegativeOutermost && value < 0) {
                hasNegativeOutermost = true;
                chart
                  .getOptionsCache()
                  .putToCachedMap2D('outermostBar', seriesIndex, groupIndex, true);
              }
            }
          }
        }
      }
    },

    /**
     * Whether or not a bar is the outermost bar in its group or category.
     * @param {Chart} chart
     * @param {Number} seriesIndex The series index.
     * @param {Number} groupIndex The group index.
     * @return {boolean}  true if the bar is the outermost bar in its group or category, otherwise false.
     */
    isOutermostBar: (chart, seriesIndex, groupIndex) => {
      DvtChartDataUtils._computeOutermostBarMap(chart);
      return (
        chart.getOptionsCache().getFromCachedMap2D('outermostBar', seriesIndex, groupIndex) || false
      );
    },

    /**
     * Returns whether the data item is filtered.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {boolean}
     */
    isDataItemFiltered: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['_filtered']) return true;
      return false;
    },

    /**
     * Returns true if the chart series should be stacked.
     * @param {Chart} chart
     * @return {boolean}
     */
    isStacked: (chart) => {
      // To be stacked, the attribute must be set and the chart must be a supporting type.
      // If the series count is less than 2, assume unstacked because it's faster to render.
      var options = chart.getOptions();
      if (
        options['stack'] != 'on' ||
        DvtChartTypeUtils.isMixedFrequency(chart) ||
        DvtChartDataUtils.getSeriesCount(chart) < 2
      )
        return false;

      return DvtChartTypeUtils.isBLAC(chart);
    },

    /**
     * Returns true if the chart is split dual-Y.
     * @param {Chart} chart
     * @return {boolean}
     */
    isSplitDualY: (chart) => {
      if (
        DvtChartTypeUtils.isStock(chart) &&
        DvtChartDataUtils.hasVolumeSeries(chart) &&
        !DvtChartTypeUtils.isOverview(chart)
      )
        return true;

      return (
        chart.getOptions()['splitDualY'] == 'on' &&
        DvtChartDataUtils.hasY2Data(chart) &&
        !DvtChartDataUtils.hasY2DataOnly(chart)
      );
    },

    /**
     * Returns true if the chart has y2 data items only.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasY2DataOnly: (chart) => {
      if (!DvtChartTypeUtils.isDualY(chart)) return false;

      // Verify that all the series are y2
      return (
        DvtChartDataUtils.getY2SeriesCount(chart, null, true) ==
        DvtChartDataUtils.getSeriesCount(chart)
      );
    },

    /**
     * Returns true if the chart has y2 data items.
     * @param {Chart} chart
     * @param {string} type Optional series type to look for.
     * @return {boolean}
     */
    hasY2Data: (chart, type) => {
      if (!DvtChartTypeUtils.isDualY(chart)) return false;

      // Verify the chart has at least one y2 series
      return DvtChartDataUtils.getY2SeriesCount(chart, null, true) > 0;
    },

    /**
     * Returns true if the chart has y2 data items.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasY2BarData: (chart) => {
      return DvtChartDataUtils.hasY2Data(chart, 'bar');
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if one of the series type is bar.
     */
    hasBarSeries: (chart) => {
      return DvtChartDataUtils._hasSeriesType(chart, 'bar');
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if one of the series type is line.
     */
    hasLineSeries: (chart) => {
      return DvtChartDataUtils._hasSeriesType(chart, 'line');
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if one of the series type is area.
     */
    hasAreaSeries: (chart) => {
      return DvtChartDataUtils._hasSeriesType(chart, 'area');
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if one of the series type is lineWithArea.
     */
    hasLineWithAreaSeries: (chart) => {
      return DvtChartDataUtils._hasSeriesType(chart, 'lineWithArea');
    },

    /**
     * Returns true if one of the series type is stock.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasCandlestickSeries: (chart) => {
      return DvtChartDataUtils._hasSeriesType(chart, 'candlestick');
    },

    /**
     * Returns true if one of the series type is boxPlot.
     * @param {Chart} chart
     * @return {boolean}
     */
    hasBoxPlotSeries: (chart) => {
      return DvtChartDataUtils._hasSeriesType(chart, 'boxPlot');
    },

    /**
     * @param {Chart} chart
     * @param {string} type The series type.
     * @return {boolean} True if one of the series is the specified series type. Only works for BLAC.
     * @private
     */
    _hasSeriesType: (chart, type) => {
      if (DvtChartTypeUtils.isBLAC(chart)) {
        var seriesCount = DvtChartDataUtils.getSeriesCount(chart);

        for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
          // Ignore the series if it isn't rendered
          if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) continue;
          else if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) == type) return true;
        }
      }
      return false;
    },

    /**
     * Returns all reference objects for the current chart.
     * @param {Chart} chart
     * @return {array} The array of reference object definitions.
     */
    getRefObjs: (chart) => {
      var x = DvtChartDataUtils.getAxisRefObjs(chart, 'x');
      var y = DvtChartDataUtils.getAxisRefObjs(chart, 'y');
      var y2 = DvtChartDataUtils.getAxisRefObjs(chart, 'y2');
      return x.concat(y, y2);
    },

    /**
     * Returns all reference objects for the axis.
     * @param {Chart} chart
     * @param {string} axisType 'x', 'y', 'or 'y2'
     * @return {array} The array of reference object definitions.
     */
    getAxisRefObjs: (chart, axisType) => {
      var options = chart.getOptions();
      if (options && options[axisType + 'Axis'] && options[axisType + 'Axis']['referenceObjects'])
        return options[axisType + 'Axis']['referenceObjects'];
      return [];
    },

    /**
     * Returns the series type for the specified data item.  Returns "auto" for chart types
     * that do not support multiple series types.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {string} The series type.
     */
    getSeriesType: (chart, seriesIndex) => {
      var cacheKey = 'seriesType';
      var seriesType = chart.getOptionsCache().getFromCachedMap(cacheKey, seriesIndex);
      if (seriesType) {
        return seriesType;
      }

      if (!DvtChartTypeUtils.isBLAC(chart)) {
        chart.getOptionsCache().putToCachedMap(cacheKey, seriesIndex, 'auto');
        return 'auto';
      }

      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      seriesType = seriesItem ? seriesItem['type'] : null;

      // Error prevention for candlestick series in non stock type charts
      if (!DvtChartTypeUtils.isStock(chart) && seriesType == 'candlestick') seriesType = 'auto';

      if (!seriesType || seriesType == 'auto') {
        // Series type not specified, get default
        if (DvtChartTypeUtils.isBar(chart)) seriesType = 'bar';
        else if (DvtChartTypeUtils.isLine(chart)) seriesType = 'line';
        else if (DvtChartTypeUtils.isArea(chart)) seriesType = 'area';
        else if (DvtChartTypeUtils.isLineWithArea(chart)) seriesType = 'lineWithArea';
        else if (DvtChartTypeUtils.isStock(chart)) seriesType = 'candlestick';
        else if (DvtChartTypeUtils.isBoxPlot(chart)) seriesType = 'boxPlot';
        else if (DvtChartTypeUtils.isCombo(chart)) {
          var styleIndex = DvtChartDataUtils.getSeriesStyleIdx(chart, seriesIndex);
          var typeIndex = styleIndex % DvtChartDataUtils._SERIES_TYPE_RAMP.length;
          seriesType = DvtChartDataUtils._SERIES_TYPE_RAMP[typeIndex];
        }
      }

      chart.getOptionsCache().putToCachedMap(cacheKey, seriesIndex, seriesType);
      return seriesType;
    },

    /**
     * Returns the array containing the hidden categories for the chart.
     * @param {Chart} chart
     * @return {array}
     */
    getHiddenCategories: (chart) => {
      var options = chart.getOptions();
      if (!options['hiddenCategories']) options['hiddenCategories'] = [];

      return options['hiddenCategories'];
    },

    /**
     * Returns the array containing the highlighted categories for the chart.
     * @param {Chart} chart
     * @return {array}
     */
    getHighlightedCategories: (chart) => {
      var options = chart.getOptions();
      if (!options['highlightedCategories']) options['highlightedCategories'] = [];

      return options['highlightedCategories'];
    },

    /**
     * Returns true if the specified series should be rendered.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {boolean} True if the series should be rendered.
     */
    isSeriesRendered: (chart, seriesIndex) => {
      // Check if any category is hidden
      var hiddenCategories = DvtChartDataUtils.getHiddenCategories(chart);
      if (hiddenCategories.length > 0) {
        if (
          dvt.ArrayUtils.hasAnyItem(
            hiddenCategories,
            DvtChartDataUtils.getCategories(chart, seriesIndex)
          )
        ) {
          return false;
        }
      }

      return true;
    },

    /**
     * Returns true if the specified data item should be rendered.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {boolean} True if the series should be rendered.
     */
    isDataItemRendered: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Use the cached value if it has been computed before
      var ret;
      var cacheKey = 'isDataItemRendered';
      var isNested = !isNaN(itemIndex) && itemIndex != null && itemIndex >= 0;
      if (!isNested) {
        ret = chart.getOptionsCache().getFromCachedMap2D(cacheKey, seriesIndex, groupIndex);
        if (ret !== undefined)
          // anything that's defined, including null
          return ret;
      }

      ret = true;
      if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) ret = false;
      else {
        // Check if any category is hidden
        var hiddenCategories = DvtChartDataUtils.getHiddenCategories(chart);
        if (hiddenCategories.length > 0) {
          if (
            DvtChartTypeUtils.isPie(chart) ||
            DvtChartTypeUtils.isFunnel(chart) ||
            DvtChartTypeUtils.isPyramid(chart)
          )
            groupIndex = 0;

          if (
            dvt.ArrayUtils.hasAnyItem(
              hiddenCategories,
              DvtChartDataUtils.getCategories(chart, seriesIndex, groupIndex)
            )
          ) {
            ret = false;
          }

          // nested item
          if (
            dvt.ArrayUtils.hasAnyItem(
              hiddenCategories,
              DvtChartDataUtils.getCategories(chart, seriesIndex, groupIndex, itemIndex)
            )
          ) {
            ret = false;
          }
        }
      }

      // Cache the value
      if (!isNested) chart.getOptionsCache().putToCachedMap2D(cacheKey, seriesIndex, groupIndex, ret);

      return ret;
    },

    /**
     * Returns whether the series is a range series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {boolean}
     */
    isRangeSeries: (chart, seriesIndex) => {
      var optionsCache = chart.getOptionsCache();
      if (!optionsCache.getFromCache('hasLowHighSeries')) return false;

      // Use the cached value if it has been computed before
      var cacheKey = 'isRange';
      var isRange = optionsCache.getFromCachedMap(cacheKey, seriesIndex);
      if (isRange != null) return isRange;

      isRange = false;
      var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      if (seriesType == 'bar' || seriesType == 'area') {
        for (var g = 0; g < DvtChartDataUtils.getGroupCount(chart); g++) {
          if (
            DvtChartDataUtils.getLowVal(chart, seriesIndex, g) != null ||
            DvtChartDataUtils.getHighVal(chart, seriesIndex, g) != null
          ) {
            isRange = true;
            break;
          }
        }
      }

      // Cache the value
      chart.getOptionsCache().putToCachedMap(cacheKey, seriesIndex, isRange);
      return isRange;
    },

    /**
     * Returns whether the series is drillable.
     * @param {Chart} chart
     * @param {Number} seriesIndex
     * @return {Boolean}
     */
    isSeriesDrillable: (chart, seriesIndex) => {
      var series = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      var drilling = series != null ? series['drilling'] : 'inherit';
      if (drilling == 'on') return true;
      else if (drilling == 'off') return false;

      drilling = chart.getOptions()['drilling'];
      return drilling == 'on' || drilling == 'seriesOnly';
    },

    /**
     * Returns whether the data item is drillable.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {Boolean}
     */
    isDataItemDrillable: (chart, seriesIndex, groupIndex, itemIndex) => {
      var dataItem = DvtChartDataUtils.getNestedDataItem(chart, seriesIndex, groupIndex, itemIndex);
      if (!dataItem) dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);

      var drilling = dataItem != null ? dataItem['drilling'] : 'inherit';
      if (drilling == 'on') return true;
      else if (drilling == 'off') return false;

      drilling = chart.getOptions()['drilling'];
      return drilling == 'on';
    },

    /**
     * Returns weather multiseries drill is enabled in the chart
     * @param {Chart} chart The pie chart
     */
    isMultiSeriesDrillEnabled: (chart) => {
      return chart.getOptions().multiSeriesDrilling === 'on';
    },

    /**
     * Returns the value used to calculate next navigable item.
     * @param {DvtChart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @returns
     */
    getValueForNavigation: (chart, seriesIndex, groupIndex) => {
      if (
        DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex) != null &&
        DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex) != null
      ) {
        // if item.low and item.high is defined, it's a range chart.
        // Use low value as primary value for navigation.
        return DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex);
      }
      return DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);
    },

    /**
     * Returns the cumulative value used to calculate next navigable item.
     * @param {DvtChart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @returns
     */
    getCumulativeValueForNavigation: (chart, seriesIndex, groupIndex) => {
      if (
        DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex) != null &&
        DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex) != null
      ) {
        // range chart isn't stacked. So this is safe.
        return DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex);
      }
      return DvtChartDataUtils.getCumulativeVal(chart, seriesIndex, groupIndex);
    }
  };

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {dvt.BaseComponentDefaults}
   */
  class DvtChartDefaults extends dvt.BaseComponentDefaults {
    constructor(context) {
      /**
       * Defaults for version 1.
       * @const
       */
      const SKIN_ALTA = {
        skin: dvt.CSSStyle.SKIN_ALTA,
        emptyText: null,
        type: 'bar',
        stack: 'off',
        stackLabel: 'off',
        orientation: 'vertical',
        polarGridShape: 'circle',
        selectionMode: 'none',
        hideAndShowBehavior: 'none',
        hoverBehavior: 'none',
        zoomAndScroll: 'off',
        zoomDirection: 'auto',
        initialZooming: 'none',
        dragMode: 'user',
        sorting: 'off',
        otherThreshold: 0,
        animationOnDataChange: 'none',
        animationOnDisplay: 'none',
        __sparkBarSpacing: 'subpixel',
        __spark: false,
        dataCursor: 'auto',
        dataCursorBehavior: 'auto',
        drilling: 'off',
        highlightMatch: 'all',
        series: [],
        groups: [],
        title: {
          style: new dvt.CSSStyle(
            dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD_13 + 'color: #252525;'
          ),
          halign: 'start'
        },
        subtitle: {
          style: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_12 + 'color: #252525;')
        },
        footnote: {
          style: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_11 + 'color: #333333;'),
          halign: 'start'
        },
        titleSeparator: { upperColor: '#74779A', lowerColor: '#FFFFFF', rendered: 'off' },
        touchResponse: 'auto',
        _statusMessageStyle: new dvt.CSSStyle(
          dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_13 + 'color: #252525;'
        ),
        _dropColor: '#D9F4FA',

        xAxis: {
          tickLabel: { rendered: 'on' },
          majorTick: { rendered: 'auto' },
          minorTick: { rendered: 'auto' },
          axisLine: { rendered: 'on' },
          scale: 'linear'
        },
        yAxis: {
          tickLabel: { rendered: 'on' },
          majorTick: { rendered: 'auto' },
          minorTick: { rendered: 'auto' },
          axisLine: { rendered: 'auto' },
          scale: 'linear'
        },
        y2Axis: {
          tickLabel: { rendered: 'on' },
          majorTick: { rendered: 'auto' },
          minorTick: { rendered: 'auto' },
          axisLine: { rendered: 'auto' },
          scale: 'linear',
          alignTickMarks: 'on'
        },
        pieCenter: { labelStyle: new dvt.CSSStyle('') },
        zAxis: {}, // this will be used for dataMin/Max calculations
        plotArea: { backgroundColor: null },

        legend: {
          position: 'auto',
          rendered: 'auto',
          layout: { gapRatio: 1.0 },
          seriesSection: {},
          referenceObjectSection: {},
          sections: []
        },

        overview: {
          rendered: 'off'
        },

        dnd: {
          drag: {
            items: {},
            series: {},
            groups: {}
          },
          drop: {
            plotArea: {},
            xAxis: {},
            yAxis: {},
            y2Axis: {},
            legend: {}
          }
        },

        styleDefaults: {
          colors: dvt.CSSStyle.COLORS_ALTA,
          borderColor: 'auto',
          borderWidth: 'auto',
          patterns: [
            'smallDiagonalRight',
            'smallChecker',
            'smallDiagonalLeft',
            'smallTriangle',
            'smallCrosshatch',
            'smallDiamond',
            'largeDiagonalRight',
            'largeChecker',
            'largeDiagonalLeft',
            'largeTriangle',
            'largeCrosshatch',
            'largeDiamond'
          ],
          shapes: ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'],
          seriesEffect: 'color',
          threeDEffect: 'off',
          selectionEffect: 'highlight',
          animationDuration: 1000,
          animationIndicators: 'all',
          animationUpColor: '',
          animationDownColor: '',
          lineStyle: 'solid',
          lineType: 'auto',
          markerDisplayed: 'auto',
          markerColor: null,
          markerShape: 'auto',
          markerSize: 10,
          marqueeColor: '',
          marqueeBorderColor: '',
          pieFeelerColor: '#BAC5D6',
          pieInnerRadius: 0,
          selectedInnerColor: '#ffffff',
          selectedOuterColor: '#5a5a5a',
          sliceLabelType: 'percent',
          otherColor: '#4b4b4b',
          dataItemGaps: 'auto',
          dataLabelStyle: new dvt.CSSStyle(''),
          _dataLabelStyle: new dvt.CSSStyle(''),
          dataLabelPosition: 'auto',
          resolveLabelOverlap: "off",
          dataLabelOutline: 'auto',
          funnelBackgroundColor: '#EDEDED',
          x1Format: {},
          y1Format: {},
          y2Format: {},
          zFormat: {},
          _defaultSliceLabelColor: '#333333',
          _scrollbarHeight: 3,
          _scrollbarTrackColor: '#F0F0F0',
          _scrollbarHandleColor: '#9E9E9E',
          hoverBehaviorDelay: 200,
          dataCursor: { markerSize: 8, markerDisplayed: 'on', lineStyle: 'solid' },
          groupSeparators: { rendered: 'on', color: 'rgba(138,141,172,0.4)' },
          tooltipLabelStyle: new dvt.CSSStyle(''),
          tooltipValueStyle: new dvt.CSSStyle(''),
          stackLabelStyle: new dvt.CSSStyle(''),
          boxPlot: {
            whiskerSvgStyle: {},
            whiskerEndSvgStyle: { strokeWidth: 2 },
            whiskerEndLength: '9px',
            medianSvgStyle: { strokeWidth: 3 }
          }
        },

        layout: {
          gapWidthRatio: null,
          gapHeightRatio: null, // gap ratio is dynamic based on the component size
          // TODO, the following are internal and should be moved to a _layout object
          outerGapWidth: 10,
          outerGapHeight: 8,
          titleSubtitleGapWidth: 14,
          titleSubtitleGapHeight: 4,
          titleSeparatorGap: 6,
          titlePlotAreaGap: 16,
          footnoteGap: 10,
          verticalAxisGap: 6,
          legendGapWidth: 15,
          legendGapHeight: 10,
          tickLabelGapHeight: 8,
          tickLabelGapWidth: 9
        },

        _locale: 'en-us',
        _resources: {}
      };
      super({ alta: SKIN_ALTA }, context);
    }

    /**
     * Scales down gap widths based on the width of the component.
     * @param {Chart} chart The chart that is being rendered.
     * @param {Number} defaultWidth The default gap width.
     * @return {Number}
     */
    static getGapWidth(chart, defaultWidth) {
      return Math.ceil(defaultWidth * chart.getGapWidthRatio());
    }

    /**
     * Scales down gap heights based on the height of the component.
     * @param {Chart} chart The chart that is being rendered.
     * @param {Number} defaultHeight The default gap height.
     * @return {Number}
     */
    static getGapHeight(chart, defaultHeight) {
      return Math.ceil(defaultHeight * chart.getGapHeightRatio());
    }

    /**
     * @override
     */
    getNoCloneObject() {
      return {
        series: { items: { _itemData: true } },
        data: true,
        valueFormats: {
          close: { converter: true },
          high: { converter: true },
          label: { converter: true },
          low: { converter: true },
          open: { converter: true },
          q1: { converter: true },
          q2: { converter: true },
          q3: { converter: true },
          targetValue: { converter: true },
          value: { converter: true },
          volume: { converter: true },
          x: { converter: true },
          y: { converter: true },
          y2: { converter: true },
          z: { converter: true }
        },
        pieCenter: { converter: true },
        xAxis: {
          tickLabel: { converter: true }
        },
        yAxis: {
          tickLabel: { converter: true }
        },
        y2Axis: {
          tickLabel: { converter: true }
        }
      };
    }
  }

  /**
   * Utility functions for pie chart.
   * @class
   */
  const DvtChartPieUtils = {
    OTHER_ID: '_dvtOther',

    /**
     * Generates the slice ID of a pie series
     * @param {Chart} chart The pie chart
     * @param {Number} seriesIndex The series index
     * @return {DvtChartDataItem} The slice ID
     */
    getSliceId: (chart, seriesIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, 0);
      var id = dataItem ? dataItem['id'] : null;
      var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      var group = DvtChartDataUtils.getGroup(chart, 0);
      return new DvtChartDataItem(id, series, group, chart.getCtx());
    },

    /**
     * Generates the slice ID of a pie "Other" series
     * @param {Chart} chart The pie chart
     * @return {DvtChartDataItem} The slice ID
     */
    getOtherSliceId: (chart) => {
      var group = DvtChartDataUtils.getGroup(chart, 0);
      return new DvtChartDataItem(null, DvtChartPieUtils.OTHER_ID, group, chart.getCtx());
    },

    /**
     * Returns an array of series indices that will be rendered on the pie chart.
     * The array is sorted if sorting is enabled, and does not include the series that will be grouped under "Other" slice.
     * The array includes hidden series and series with non-positive values.
     * @param {Chart} chart The pie chart
     * @return {Array} The array containing series indices
     */
    getRenderedSeriesIndices: (chart) => {
      return DvtChartPieUtils._getSeriesIndicesArrays(chart).rendered;
    },

    /**
     * Returns whether the pie has at least one series (visible or hidden) that is grouped under "Other".
     * @param {Chart} chart The pie chart
     * @return {Boolean}
     */
    hasOtherSeries: (chart) => {
      return DvtChartPieUtils._getSeriesIndicesArrays(chart).other.length > 0;
    },

    /**
     * Computes the total value of the "Other" slice. Only includes visible series with positive values.
     * @param {Chart} chart The pie chart
     * @return {Number} The total value
     */
    getOtherVal: (chart) => {
      var otherSeries = DvtChartPieUtils._getSeriesIndicesArrays(chart).other;
      var otherValue = 0;
      for (var i = 0; i < otherSeries.length; i++) {
        var seriesIndex = otherSeries[i];
        // Only add the values of visible series
        if (DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) {
          var value = DvtChartDataUtils.getVal(chart, seriesIndex, 0);
          if (value > 0) otherValue += value;
        }
      }
      return otherValue;
    },

    /**
     * Generates the slice IDs of the series that are grouped under "Other".
     * @param {Chart} chart The pie chart
     * @return {Array} The array containing slice IDs
     */
    getOtherSliceIds: (chart) => {
      var otherSeries = DvtChartPieUtils._getSeriesIndicesArrays(chart).other;
      var seriesIds = [];
      for (var i = 0; i < otherSeries.length; i++) {
        var seriesIndex = otherSeries[i];
        seriesIds.push(DvtChartPieUtils.getSliceId(chart, seriesIndex));
      }
      return seriesIds;
    },

    /**
     * Returns whether the "Other" slice is selected. It is selected if all the series in it are selected.
     * @param {Chart} chart The pie chart
     * @param {Array} selected An array containing the ID objects of the selected slices.
     * @return {Boolean} Whether the "Other" slice is selected
     */
    isOtherSliceSelected: (chart, selected) => {
      var otherIds = DvtChartPieUtils.getOtherSliceIds(chart);

      for (var j = 0; j < otherIds.length; j++) {
        var sliceId = otherIds[j];
        var sliceSelected = false;

        // Check if this slice is in the selected list
        for (var i = 0; i < selected.length; i++) {
          if (
            (selected[i]['id'] != null && sliceId.id === selected[i]['id']) ||
            (sliceId.series === selected[i]['series'] && sliceId.group === selected[i]['group'])
          ) {
            sliceSelected = true;
            break;
          }
        }

        if (!sliceSelected) return false;
      }

      return true;
    },

    /**
     * Divides the series indices into two arrays. The first array contains the series that are not grouped under "Other",
     * sorted by value if sorting is enabled. The second array contains the series that belongs to "Other". The arrays
     * include hidden series and series with non-positive values.
     * @param {Chart} chart The pie chart
     * @return {Object} An object in the form {rendered: firstArray, other: secondArray}. firstArray and secondArray are
     *     as described above.
     * @private
     */
    _getSeriesIndicesArrays: (chart) => {
      var renderedSeries = [];
      var otherSeries = [];

      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var options = chart.getOptions();
      var otherThreshold = options['otherThreshold'] * DvtChartPieUtils.getTotalVal(chart);

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if its value is 0 or negative
        var value = DvtChartDataUtils.getVal(chart, seriesIndex, 0);

        // Do not use "Other" if the threshold is zero
        if (otherThreshold > 0 && value < otherThreshold) otherSeries.push(seriesIndex);
        else renderedSeries.push(seriesIndex);
      }

      // Sort the slices if enabled
      if (options['sorting'] == 'ascending') {
        renderedSeries.sort((a, b) => {
          return DvtChartDataUtils.getVal(chart, a, 0) - DvtChartDataUtils.getVal(chart, b, 0);
        });
      } else if (options['sorting'] == 'on' || options['sorting'] == 'descending') {
        renderedSeries.sort((a, b) => {
          return DvtChartDataUtils.getVal(chart, b, 0) - DvtChartDataUtils.getVal(chart, a, 0);
        });
      }

      return { rendered: renderedSeries, other: otherSeries };
    },

    /**
     * Computes the total value of a pie chart, including hidden series.
     * @param {Chart} chart The pie chart.
     */
    getTotalVal: (chart) => {
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var totalValue = 0;

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if its value is 0 or negative
        var value = DvtChartDataUtils.getVal(chart, seriesIndex, 0);
        if (value > 0) {
          totalValue += value;
        }
      }

      return totalValue;
    },

    /**
     * Returns the pie slice explode for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {number} The pie slice explode from 0 to 100.
     */
    getSliceExplode: (chart, seriesIndex) => {
      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['pieSliceExplode']) return seriesItem['pieSliceExplode'];
      else return 0;
    },
    /**
     * Returns the slice corresponding to the seriesIndex or null.
     * If seriesIndex is null or seriesIndex is part of "other", the "other" slice is returned
     * @param {Chart} chart
     * @param {Number} seriesIndex
     * @return {DvtChartPieSlice} slice
     */
    getSliceBySeriesIdx: (chart, seriesIndex) => {
      var slices = chart.pieChart.__getSlices();
      for (var i = 0; i < slices.length; i++) {
        if (slices[i].getSeriesIndex() == seriesIndex) return slices[i];
      }
      return null;
    }
  };

  /**
   * Style related utility functions for Chart.
   * @class
   */
  const DvtChartStyleUtils = {
    /** @const */
    MARKER_DATA_LABEL_GAP: 4, // space separating the data label from the marker
    SERIES_PATTERN_BG_COLOR: '#FFFFFF',
    /**
     * Returns the series effect for the specified chart.
     * @param {Chart} chart
     * @return {string} The series effect.
     */
    getSeriesEffect: (chart) => {
      // Style Defaults
      var options = chart.getOptions();
      return options['styleDefaults']['seriesEffect'];
    },

    /**
     * Returns the color for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {string} The color string.
     */
    getColor: (chart, seriesIndex, groupIndex) => {
      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['color']) return dataItem['color'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['color']) return seriesItem['color'];

      // Stock Candlestick: Use rising/falling instead of series color or styleDefaults colors.
      var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      if (seriesType == 'candlestick')
        return DvtChartStyleUtils.getStockItemColor(chart, seriesIndex, groupIndex);

      // Style Defaults
      var options = chart.getOptions();
      var defaultColors = options['styleDefaults']['colors'];
      var styleIndex = DvtChartDataUtils.getSeriesStyleIdx(chart, seriesIndex);
      var colorIndex = styleIndex % defaultColors.length;
      return defaultColors[colorIndex];
    },
    /**
     * Returns the stock item color for the specified data item for stock charts.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {string} The color string.
     */
    getStockItemColor: (chart, seriesIndex, groupIndex) => {
      var options = chart.getOptions();
      if (DvtChartDataUtils.isStockValRising(chart, seriesIndex, groupIndex))
        return options['styleDefaults']['stockRisingColor'];
      else return options['styleDefaults']['stockFallingColor'];
    },
    /**
     * Returns the color for the specified volume item for stock charts.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {string} The color string.
     */
    getStockVolumeColor: (chart, seriesIndex, groupIndex) => {
      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['color']) return dataItem['color'];

      // Volume Color
      var options = chart.getOptions();
      if (options['styleDefaults']['stockVolumeColor'])
        return options['styleDefaults']['stockVolumeColor'];

      // Rising/Falling Color
      return DvtChartStyleUtils.getStockItemColor(chart, seriesIndex, groupIndex);
    },
    /**
     * Returns the splitterPosition to be used as a number from 0 to 1.
     * @param {Chart} chart
     * @return {number}
     */
    getSplitterPos: (chart) => {
      var options = chart.getOptions();

      var splitterPosition = options['splitterPosition'];
      if (splitterPosition != null) return splitterPosition;
      else if (DvtChartTypeUtils.isStock(chart)) return 0.8;
      else return 0.5;
    },
    /**
     * Returns the pattern for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The pattern string.
     */
    getPattern: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['pattern'] && nestedDataItem['pattern'] != 'auto')
        return nestedDataItem['pattern'];

      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['pattern'] && dataItem['pattern'] != 'auto')
        return dataItem['pattern'];

      //get series type instead of chart type, in case its a combo chart
      var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      //prevent line/area markers from using series/styleDefaults pattern
      if ((seriesType == 'line' || seriesType == 'area') && groupIndex != null) return null;

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['pattern'] && seriesItem['pattern'] != 'auto')
        return seriesItem['pattern'];

      // Style Defaults
      if (DvtChartStyleUtils.getSeriesEffect(chart) == 'pattern') {
        // For candlestick series, use pattern based on rising/falling value.
        if (
          DvtChartTypeUtils.isStock &&
          DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'candlestick'
        ) {
          var bRisingValue = DvtChartDataUtils.isStockValRising(chart, seriesIndex, groupIndex);
          var bRtl = dvt.Agent.isRightToLeft(chart.getCtx());
          if (bRisingValue) return bRtl ? 'smallDiagonalLeft' : 'smallDiagonalRight';
          // Falling Value
          else return bRtl ? 'smallDiagonalRight' : 'smallDiagonalLeft';
        } else {
          var options = chart.getOptions();
          var defaultPatterns = options['styleDefaults']['patterns'];
          var styleIndex = DvtChartDataUtils.getSeriesStyleIdx(chart, seriesIndex);
          var patternIndex = styleIndex % defaultPatterns.length;
          return defaultPatterns[patternIndex];
        }
      } else return null;
    },
    /**
     * Returns the border color for markers belonging to the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The border color string.
     */
    getMarkerBorderColor: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Return custom border color from API settings if found.
      var borderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex, groupIndex, itemIndex);
      if (borderColor) return borderColor;

      return DvtChartStyleUtils.getDefaultMarkerBorderColor(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
    },
    /**
     * Returns the default marker color for the marker
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     */
    getDefaultMarkerBorderColor: (chart, seriesIndex, groupIndex, itemIndex) => {
      if (
        chart.getCtx().getThemeBehavior() === 'redwood' &&
        !DvtChartDataUtils.isRangeSeries(chart, seriesIndex)
      ) {
        return DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex, itemIndex);
      }
      // If data item gaps defined, use the background color to simulate gaps.
      if (
        DvtChartStyleUtils.getDataItemGaps(chart) > 0 &&
        DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'lineWithArea'
      ) {
        return DvtChartStyleUtils.getBackgroundColor(chart, true);
      }
      //  - In alta, automatically apply borders to bubbles in bubble charts using the 'color' seriesEffect for better readability
      if (
        DvtChartTypeUtils.isBubble(chart) &&
        DvtChartStyleUtils.getSeriesEffect(chart) != 'gradient'
      ) {
        var markerColor = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex);
        if (markerColor) return dvt.ColorUtils.adjustHSL(markerColor, 0, 0.15, -0.25);
      }
      return null;
    },

    /**
     * Returns the border color for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The border color string.
     */
    getBorderColor: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['borderColor']) return nestedDataItem['borderColor'];

      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['borderColor']) return dataItem['borderColor'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['borderColor']) return seriesItem['borderColor'];

      // Style Defaults
      var options = chart.getOptions();
      var styleDefaults = options['styleDefaults'];
      return styleDefaults['borderColor'] != 'auto' ? styleDefaults['borderColor'] : null;
    },
    /**
     * Returns the border color for the specified data item if specified in the api.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {number} The border width.
     */
    getUserBorderWidth: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['borderWidth'] != null)
        return nestedDataItem['borderWidth'];

      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['borderWidth'] != null) return dataItem['borderWidth'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['borderWidth'] != null) return seriesItem['borderWidth'];

      // Style Defaults
      var styleDefaults = chart.getOptions()['styleDefaults'];
      if (styleDefaults['borderWidth'] != 'auto') return styleDefaults['borderWidth'];

      return null;
    },
    /**
     * Returns the default border width for chart items.
     * @param {Chart} chart
     */
    getDefaultBorderWidth: (chart) => {
      // The borderWidth is reduced for scatter/bubble because it looks hairy otherwise
      return DvtChartTypeUtils.isScatterBubble(chart) || DvtChartTypeUtils.isLineArea(chart)
        ? 1.25
        : 1;
    },
    /**
     * Returns the default border width for chart markers.
     * @param {Chart} chart
     */
    getDefaultMarkerBorderWidth: (chart) => {
      // override border-width in css
      if (chart.getCtx().getThemeBehavior() === 'redwood') {
        return 0;
      }
      return DvtChartStyleUtils.getDefaultBorderWidth(chart);
    },
    /**
     * Returns the border color for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {number} The border width.
     */
    getBorderWidth: (chart, seriesIndex, groupIndex, itemIndex) => {
      var customWidth = DvtChartStyleUtils.getUserBorderWidth(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (customWidth != null) {
        return customWidth;
      }
      return DvtChartStyleUtils.getDefaultBorderWidth(chart);
    },
    /**
     * Returns the marker color for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The marker color string.
     */
    getMarkerColor: (chart, seriesIndex, groupIndex, itemIndex) => {
      if (!DvtChartStyleUtils.isMarkerDisplayed(chart, seriesIndex, groupIndex, itemIndex))
        return DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);

      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['color']) return nestedDataItem['color'];

      // Data Override: Note that the data object defines a single 'color' attribute
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['color']) return dataItem['color'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['markerColor']) return seriesItem['markerColor'];

      // Style Defaults
      var options = chart.getOptions();
      var defaultMarkerColor = options['styleDefaults']['markerColor'];
      if (defaultMarkerColor)
        // Return the default if set
        return defaultMarkerColor;
      else {
        // Otherwise return the series color
        return DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
      }
    },

    /**
     * Returns the marker shape for the specified data item.  Returns the actual shape
     * if the marker shape is set to "auto".
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The marker shape.
     */
    getMarkerShape: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Style Defaults
      var options = chart.getOptions();
      var shape = options['styleDefaults']['markerShape'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['markerShape']) shape = seriesItem['markerShape'];

      // Data Item Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem['markerShape']) shape = dataItem['markerShape'];

      // Nested Item Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['markerShape']) shape = nestedDataItem['markerShape'];

      // Convert automatic shape to actual shape
      if (shape == 'auto') {
        if (
          DvtChartTypeUtils.isBubble(chart) ||
          DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'boxPlot' ||
          DvtChartDataUtils.isRangeSeries(chart, seriesIndex)
        )
          shape = 'circle';
        else {
          var styleIndex = DvtChartDataUtils.getSeriesStyleIdx(chart, seriesIndex);

          // Iterate through the shape ramp to find the right shape
          var shapeRamp = options['styleDefaults']['shapes'];
          var shapeIndex = styleIndex % shapeRamp.length;
          shape = shapeRamp[shapeIndex];
        }
      }

      return shape;
    },

    /**
     * Returns the marker size for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {number} The marker size.
     */
    getMarkerSize: (chart, seriesIndex, groupIndex, itemIndex) => {
      var markerSize;
      if (DvtChartTypeUtils.isBubble(chart)) {
        markerSize = chart
          .getOptionsCache()
          .getFromCachedMap2D('bubbleSizeCache', seriesIndex, groupIndex);
        if (markerSize) return markerSize;
      }

      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['markerSize'] != null)
        // Nested Data Override
        markerSize = Number(nestedDataItem['markerSize']);
      else {
        var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
        if (dataItem && dataItem['markerSize'] != null)
          // Data Override
          markerSize = Number(dataItem['markerSize']);
        else {
          var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
          if (seriesItem && seriesItem['markerSize'] != null)
            // Series Override
            markerSize = Number(seriesItem['markerSize']);
          // Style Defaults
          else markerSize = Number(chart.getOptions()['styleDefaults']['markerSize']);
        }
      }

      // Scale down for chart overview
      if (DvtChartTypeUtils.isOverview(chart)) markerSize = Math.ceil(markerSize * 0.6);
      return markerSize;
    },

    /**
     * Returns the whether markers are displayed for the specified line or area series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {boolean} Whether markers should be displayed.
     */
    isMarkerDisplayed: (chart, seriesIndex, groupIndex, itemIndex) => {
      var displayed;
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem['markerDisplayed'] != null)
        // nested data item override
        displayed = nestedDataItem['markerDisplayed'];
      else {
        var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
        if (dataItem && dataItem['markerDisplayed'] != null)
          // data item override
          displayed = dataItem['markerDisplayed'];
        else {
          var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
          if (seriesItem && seriesItem['markerDisplayed'] != null)
            // series item override
            displayed = seriesItem['markerDisplayed'];
          // style defaults
          else displayed = chart.getOptions()['styleDefaults']['markerDisplayed'];
        }
      }

      if (displayed === 'on') return true;
      else if (displayed === 'off') return false;
      else if (DvtChartTypeUtils.isCombo(chart) && displayed === 'auto') return true;
      else
        return (
          DvtChartTypeUtils.isScatterBubble(chart) ||
          DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'boxPlot' ||
          DvtChartStyleUtils.getLineType(chart, seriesIndex) == 'none'
        );
    },

    /**
     * Returns the marker size for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @param {string} sourceType
     * @return {string} The marker source for the type passed in.
     */
    getImageSource: (chart, seriesIndex, groupIndex, itemIndex, sourceType) => {
      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && nestedDataItem[sourceType]) return nestedDataItem[sourceType];

      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && dataItem[sourceType]) return dataItem[sourceType];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem[sourceType]) return seriesItem[sourceType];

      return undefined;
    },

    /**
     * Returns the line width for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {number} The line width.
     */
    getLineWidth: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      var options = chart.getOptions();
      var lineWidth;

      if (seriesItem && seriesItem['lineWidth'])
        // Series Override
        lineWidth = seriesItem['lineWidth'];
      else if (options['styleDefaults']['lineWidth'])
        // Style Defaults
        lineWidth = options['styleDefaults']['lineWidth'];
      else if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'lineWithArea') lineWidth = 2;
      else lineWidth = 3;

      // Scale down for chart overview
      if (DvtChartTypeUtils.isOverview(chart)) lineWidth = Math.ceil(lineWidth * 0.6);

      return lineWidth;
    },

    /**
     * Returns the line style for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {string} The line style.
     */
    getLineStyle: (chart, seriesIndex) => {
      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['lineStyle']) return seriesItem['lineStyle'];

      // Style Defaults
      var options = chart.getOptions();
      return options['styleDefaults']['lineStyle'];
    },

    /**
     * Returns the line type for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {string} The line type.
     */
    getLineType: (chart, seriesIndex) => {
      var lineType;
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);

      if (seriesItem && seriesItem['lineType'])
        // Series Override
        lineType = seriesItem['lineType'];
      // Style Defaults
      else lineType = chart.getOptions()['styleDefaults']['lineType'];

      if (lineType == 'auto')
        lineType = DvtChartTypeUtils.isScatterBubble(chart) ? 'none' : 'straight';

      // Centered segmented/stepped are not supported for polar and scatter/bubble
      if (DvtChartTypeUtils.isPolar(chart) || DvtChartTypeUtils.isScatterBubble(chart)) {
        if (lineType == 'centeredSegmented') lineType = 'segmented';
        if (lineType == 'centeredStepped') lineType = 'stepped';
      }

      return lineType;
    },

    /**
     * Returns the bar spacing behavior.  Only applies for spark charts.
     * @param {Chart} chart
     * @return {string} The bar spacing behavior
     */
    getBarSpacing: (chart) => {
      var options = chart.getOptions();
      return options['__sparkBarSpacing'];
    },

    /**
     * Returns the maxBarWidth (in pixels) of the bars.
     * @param {Chart} chart
     * @return {number}
     */
    getMaxBarWidth: (chart) => {
      var maxBarWidth = chart.getOptions()['styleDefaults']['maxBarWidth'];
      return maxBarWidth != null && !DvtChartTypeUtils.isPolar(chart) ? maxBarWidth : Infinity;
    },
    /**
     * Returns the bar width for the specified series and group.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {number} The bar width.
     */
    getBarWidth: (chart, seriesIndex, groupIndex) => {
      // If the chart doesn't have Z values, the stack widths are all the same, so override the seriesIndex and groupIndex so
      // the computation doesn't need to be repeated for every group and we can use the cached value instead.
      if (chart.getOptionsCache().getFromCache('hasConstantZValue')) {
        seriesIndex = 0;
        groupIndex = 0;
      }

      var cacheKey = 'barWidth';
      var barWidth = chart.getCache().getFromCachedMap2D(cacheKey, seriesIndex, groupIndex);
      if (barWidth != null) return barWidth;

      var ratio =
        DvtChartDataUtils.getZVal(chart, seriesIndex, groupIndex, 1) /
        chart.getOptions()['_averageGroupZ'];
      barWidth = Math.min(
        ratio * DvtChartStyleUtils.getGroupWidth(chart),
        DvtChartStyleUtils.getMaxBarWidth(chart)
      );

      chart.getCache().putToCachedMap2D(cacheKey, seriesIndex, groupIndex, barWidth);
      return barWidth;
    },
    /**
     * Returns the bar width for the specified stack category.
     * @param {Chart} chart
     * @param {string} category The stack category. Use the series name for unstacked charts.
     * @param {number} groupIndex
     * @param {boolean} isY2 Whether the stack is assigned to Y2.
     * @return {number} The stack width.
     */
    getBarStackWidth: (chart, category, groupIndex, isY2) => {
      // If the chart doesn't have Z values, the stack widths are all the same, so override the groupIndex so
      // the computation doesn't need to be repeated for every group and we can use the cached value instead.
      if (chart.getOptionsCache().getFromCache('hasConstantZValue')) groupIndex = 0;

      var cacheKey = isY2 ? 'y2BarStackWidth' : 'yBarStackWidth';
      var barStackWidth = chart.getCache().getFromCachedMap2D(cacheKey, category, groupIndex);
      if (barStackWidth != null) return barStackWidth;

      var ratio =
        DvtChartDataUtils.getBarCategoryZ(chart, category, groupIndex, isY2) /
        chart.getOptions()['_averageGroupZ'];
      barStackWidth = Math.min(
        ratio * DvtChartStyleUtils.getGroupWidth(chart),
        DvtChartStyleUtils.getMaxBarWidth(chart)
      );
      chart.getCache().putToCachedMap2D(cacheKey, category, groupIndex, barStackWidth);
      return barStackWidth;
    },
    /**
     * Computes the offsets of the bar stack categories relative to the group coordinate and stores it in a map.
     * @param {Chart} chart
     * @param {Number} groupIndex
     * @return {Object} An object containing two maps for y and y2 respectively. Each map contains the categories as the
     *    keys and the offsets as the values.
     */
    getBarCategoryOffsetMap: (chart, groupIndex) => {
      // If the chart doesn't have Z values, the stack widths are all the same, so override the groupIndex so
      // the computation doesn't need to be repeated for every group and we can use the cached value instead.
      if (chart.getOptionsCache().getFromCache('hasConstantZValue')) groupIndex = 0;

      var cacheKey = 'barCategoryOffsetMap';
      var yOffsetMaps = chart.getCache().getFromCachedMap(cacheKey, groupIndex);
      if (yOffsetMaps) return yOffsetMaps;

      var bStacked = DvtChartDataUtils.isStacked(chart);
      var categories = DvtChartDataUtils.getStackCategories(chart, 'bar');
      var isMixedFreq = DvtChartTypeUtils.isMixedFrequency(chart);
      var isSplitDualY = DvtChartDataUtils.isSplitDualY(chart);
      var yOffsetMap = {},
        y2OffsetMap = {};
      var yTotalWidth = 0,
        y2TotalWidth = 0;
      var stackWidth, i;

      // Populate offset maps
      if (bStacked) {
        // Use stack categories to get the width of each stack
        // Iterate through the y-axis stack categories and store the offsets relative the the start coord of the y stack
        for (i = 0; i < categories['y'].length; i++) {
          stackWidth = DvtChartStyleUtils.getBarStackWidth(
            chart,
            categories['y'][i],
            groupIndex,
            false
          );
          if (isMixedFreq) yOffsetMap[categories['y'][i]] = -0.5 * stackWidth;
          else {
            yOffsetMap[categories['y'][i]] = yTotalWidth;
            yTotalWidth += stackWidth;
          }
        }

        if (!isSplitDualY) y2TotalWidth = yTotalWidth;

        // Iterate through the y2-axis stack categories and store the offsets relative the the start coord of the y2 stack
        for (i = 0; i < categories['y2'].length; i++) {
          stackWidth = DvtChartStyleUtils.getBarStackWidth(
            chart,
            categories['y2'][i],
            groupIndex,
            true
          );
          if (isMixedFreq) y2OffsetMap[categories['y2'][i]] = -0.5 * stackWidth;
          else {
            y2OffsetMap[categories['y2'][i]] = y2TotalWidth;
            y2TotalWidth += stackWidth;
          }
        }

        if (!isSplitDualY) yTotalWidth = y2TotalWidth;
      } else {
        // The width of each bar series item is the width of the stack
        var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
        for (var z = 0; z < seriesCount; z++) {
          var seriesType = DvtChartDataUtils.getSeriesType(chart, z);
          if (
            (seriesType != 'bar' && seriesType != 'candlestick' && seriesType != 'boxPlot') ||
            !DvtChartDataUtils.isSeriesRendered(chart, z)
          )
            continue;

          var isY2Series = DvtChartDataUtils.isAssignedToY2(chart, z);
          var category = DvtChartDataUtils.getStackCategory(chart, z);
          stackWidth = DvtChartStyleUtils.getBarWidth(chart, z, groupIndex);

          if (!isY2Series) {
            if (isMixedFreq) yOffsetMap[category] = -0.5 * stackWidth;
            else {
              yOffsetMap[category] = yTotalWidth;
              yTotalWidth += stackWidth;
            }
          } else {
            if (isMixedFreq) y2OffsetMap[category] = -0.5 * stackWidth;
            else {
              y2OffsetMap[category] = y2TotalWidth;
              y2TotalWidth += stackWidth;
            }
          }
        }
      }

      // Now shift each bar by half the total stack width
      for (var yCategory in yOffsetMap)
        yOffsetMap[yCategory] -=
          !isSplitDualY && !bStacked ? (yTotalWidth + y2TotalWidth) / 2 : yTotalWidth / 2;
      for (var y2Category in y2OffsetMap)
        y2OffsetMap[y2Category] -=
          !isSplitDualY && !bStacked
            ? (yTotalWidth + y2TotalWidth) / 2 - yTotalWidth
            : y2TotalWidth / 2;

      yOffsetMaps = { y: yOffsetMap, y2: y2OffsetMap };
      chart.getCache().putToCachedMap(cacheKey, groupIndex, yOffsetMaps);
      return yOffsetMaps;
    },
    /**
     * Returns the ratio of data item gaps to be used as a number from 0 to 1.
     * @param {Chart} chart
     * @return {number}
     */
    getDataItemGaps: (chart) => {
      var cacheKey = 'dataItemGaps';
      var ret = chart.getOptionsCache().getFromCache(cacheKey);
      if (ret != null) {
        return ret;
      }

      var options = chart.getOptions();

      if (options['styleDefaults']['sliceGaps'] != null) {
        // Backwards compatibility with sliceGaps, which is a number between 0 and 1
        ret = options['styleDefaults']['sliceGaps'];
      } else {
        // dataItemGaps: Currently a percentage string to be converted to ratio or "auto"
        var dataItemGaps = options['styleDefaults']['dataItemGaps'];
        if (dataItemGaps == 'auto') {
          // Auto is 50% for 2D charts, 0% for 3D charts
          dataItemGaps = options['styleDefaults']['threeDEffect'] == 'on' ? '0%' : '50%';
        }

        // Process the percentage value
        var percentIndex = dataItemGaps && dataItemGaps.indexOf ? dataItemGaps.indexOf('%') : -1;
        if (percentIndex >= 0) {
          dataItemGaps = dataItemGaps.substring(0, percentIndex);
          ret = dataItemGaps / 100;
        } else {
          // Not a valid string, return 0.
          ret = 0;
        }
      }

      chart.getOptionsCache().putToCache(cacheKey, ret);
      return ret;
    },
    /**
     * Returns true if the specified data item is selectable.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {boolean} True if the data item is selectable.
     */
    isSelectable: (chart, seriesIndex, groupIndex) => {
      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['_selectable'] == 'off') return false;

      // Otherwise the requirements are that selection is enabled and the object corresponds to a data item.
      return (
        chart.isSelectionSupported() &&
        seriesIndex != null &&
        seriesIndex >= 0 &&
        groupIndex != null &&
        groupIndex >= 0
      );
    },
    /**
     * Returns the display animation for the specified chart.
     * @param {Chart} chart
     * @return {string}
     */
    getAnimOnDisplay: (chart) => {
      return chart.getOptions()['animationOnDisplay'];
    },

    /**
     * Returns the data change animation for the specified chart.
     * @param {Chart} chart
     * @return {string}
     */
    getAnimOnDataChange: (chart) => {
      return chart.getOptions()['animationOnDataChange'];
    },

    /**
     * Returns the animation duration in seconds for the specified chart.  This duration is
     * intended to be passed to the animatino handler, and is not in the same units
     * as the API.
     * @param {Chart} chart
     * @return {number} The animation duration in seconds.
     */
    getAnimDur: (chart) => {
      return (
        dvt.CSSStyle.getTimeMilliseconds(chart.getOptions()['styleDefaults']['animationDuration']) /
        1000
      );
    },

    /**
     * Returns the animation indicators property for the specified chart.
     * @param {Chart} chart
     * @return {string}  The animation indicators value.
     */
    getAnimIndicators: (chart) => {
      return chart.getOptions()['styleDefaults']['animationIndicators'];
    },

    /**
     * Returns the animation indicators up color.
     * @param {Chart} chart
     * @return {string}  The animation indicator up color.
     */
    getAnimUpColor: (chart) => {
      return chart.getOptions()['styleDefaults']['animationUpColor'];
    },

    /**
     * Returns the animation indicators down color.
     * @param {Chart} chart
     * @return {string}  The animation indicator down color.
     */
    getAnimDownColor: (chart) => {
      return chart.getOptions()['styleDefaults']['animationDownColor'];
    },
    /**
     * Returns the inner color of the selection feedback.
     * @param {Chart} chart
     * @return {string}
     */
    getSelectedInnerColor: (chart) => {
      return chart.getOptions()['styleDefaults']['selectedInnerColor'];
    },

    /**
     * Returns the outer color of the selection feedback.
     * @param {Chart} chart
     * @return {string}
     */
    getSelectedOuterColor: (chart) => {
      return chart.getOptions()['styleDefaults']['selectedOuterColor'];
    },
    /**
     * Returns whether the selected items are highlighted.
     * @param {Chart} chart
     * @return {boolean}
     */
    isSelectionHighlighted: (chart) => {
      var effect = chart.getOptions()['styleDefaults']['selectionEffect'];
      return effect == 'highlight' || effect == 'highlightAndExplode';
    },
    /**
     * Returns whether the selected items are exploded (only applies to pie).
     * @param {Chart} chart
     * @return {boolean}
     */
    isSelectionExploded: (chart) => {
      var effect = chart.getOptions()['styleDefaults']['selectionEffect'];
      return effect == 'explode' || effect == 'highlightAndExplode';
    },
    /**
     * Returns the data label style for the specified data point.
     * @param {Chart} chart
     * @param {number} seriesIndex The series index.
     * @param {number} groupIndex The group index.
     * @param {number} itemIndex The nested item index.
     * @param {Color} dataColor The color of the marker this is associated with.
     * @param {string} position The position returned by the getDataLabelPosition function, not the API values.
     * @param {string=} type Data label type: low, high, or value.
     * @return {string} The data label, null if the index is invalid.
     */
    getDataLabelStyle: (chart, seriesIndex, groupIndex, itemIndex, dataColor, position, type) => {
      var styleDefaults = chart.getOptions().styleDefaults;
      var labelStyleArray = [styleDefaults._dataLabelStyle, styleDefaults.dataLabelStyle];
      var contrastingColor;
      const seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      const supportsOutline = DvtChartStyleUtils.supportsLabelOutline(chart, seriesIndex);
      if (
        !supportsOutline &&
        ((dataColor &&
          (seriesType == 'bar' || DvtChartTypeUtils.isBubble(chart)) &&
          (position == 'center' ||
            position == 'inBottom' ||
            position == 'inTop' ||
            position == 'inRight' ||
            position == 'inLeft')) ||
          (seriesType == 'area' &&
            !DvtChartDataUtils.isRangeSeries(chart, seriesIndex) &&
            position == 'bottom' &&
            DvtChartTypeUtils.isVertical(chart)))
      ) {
        // issue identified by JET-56558, JET-59519, JET-59520 will be solved by JET-65212
        contrastingColor =
          DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex, itemIndex) != null
            ? '#000000'
            : dvt.ColorUtils.getContrastingTextColor(dataColor);
        labelStyleArray.push(new dvt.CSSStyle('color: ' + contrastingColor + ';'));
      }
      labelStyleArray.push(
        DvtChartStyleUtils._parseLowHighArray(
          chart.getOptions()['styleDefaults']['dataLabelStyle'],
          type
        )
      );

      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem)
        labelStyleArray.push(
          new dvt.CSSStyle(DvtChartStyleUtils._parseLowHighArray(dataItem['labelStyle'], type))
        );

      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem)
        labelStyleArray.push(
          new dvt.CSSStyle(DvtChartStyleUtils._parseLowHighArray(nestedDataItem['labelStyle'], type))
        );

      // In high contrast mode, force use of contrasting color and ignore custom color
      if (contrastingColor && dvt.Agent.isHighContrast())
        labelStyleArray.push(new dvt.CSSStyle('color: ' + contrastingColor + ';'));

      return dvt.CSSStyle.mergeStyles(labelStyleArray);
    },

    /**
     * Returns an object which indicates where the labels has collisions.
     * @param {Chart} chart
     * @param {string} centeredTextCoords Centered data label coordinates
     * @param {object} textDims Data label dimensions
     * @param {object} plotAreaDims Plot area dimensions
     * @param {object} isHoriz Whether or not the chart is horizontal.
     * @return {object} Indicates where the label has collisions: xAxis, yAxis, y2Axis, legend, top of chart
     */
    getDataLabelCollisions: (chart, centeredTextCoords, textDims, plotAreaDims, isHoriz) => {
      var textX =
        centeredTextCoords && centeredTextCoords.x
          ? centeredTextCoords.x - textDims.w / 2 || textDims.x
          : textDims.x;
      var textY =
        centeredTextCoords && centeredTextCoords.y
          ? centeredTextCoords.y - textDims.h / 2 || textDims.y
          : textDims.y;
      var buffer = DvtChartStyleUtils.MARKER_DATA_LABEL_GAP / 2;
      var options = chart.getOptions();
      var legendGap = isHoriz
        ? DvtChartDefaults.getGapHeight(chart, options['layout']['legendGapHeight'])
        : DvtChartDefaults.getGapWidth(chart, options['layout']['legendGapWidth']);
      return {
        xAxis: textY + textDims.h + buffer > plotAreaDims.y + plotAreaDims.h,
        yAxis: textX + buffer < plotAreaDims.x,
        y2Axis: textX + textDims.w + buffer > plotAreaDims.x + plotAreaDims.w,
        legend: textX + textDims.w + buffer > plotAreaDims.x + plotAreaDims.w + legendGap,
        top: textY < chart.getDimensions().y // No need for buffer because textY accounts for typography baseline
      };
    },
    /**
     * Returns an adjusted label position. It flips or adjusts the label position if there are collisions detected for that label.
     * @param {Chart} chart
     * @param {string} position Initial label position
     * @param {object} detectedCollisions Indicates where label has collision: xAxis, yAxis, y2Axis, legend, top of chart
     * @param {boolean} hasY2Axis Whether the chart has a y2 axis
     * @return {string} The adjusted data label position.
     */
    adjustDataLabelPos: (position, detectedCollisions, hasY2Axis) => {
      var adjustedPosition = position;

      // flip alg for collisions
      if ((position == 'left' || position == 'center') && detectedCollisions.yAxis) {
        adjustedPosition = 'right';
      } else if (
        (position == 'right' || position == 'center') &&
        ((hasY2Axis && detectedCollisions.y2Axis) || detectedCollisions.legend)
      ) {
        adjustedPosition = 'left';
      } else if ((position == 'top' || position == 'center') && detectedCollisions.top) {
        adjustedPosition = 'bottom';
      } else if ((position == 'bottom' || position == 'center') && detectedCollisions.xAxis) {
        adjustedPosition = 'top';
      }
      return adjustedPosition;
    },
    /**
     * Parses the data label attribute. If a single value is provided, it will apply to all labels. If an array of
     * two values is provided, the first and second value will apply to the low and high label respectively.
     * @param {object} value The attribute value.
     * @param {type} type Data label type: low, high, or value.
     * @return {object} The value corresponding to the type.
     * @private
     */
    _parseLowHighArray: (value, type) => {
      if (value instanceof Array) return type == 'high' ? value[1] : value[0];
      else return value;
    },

    /**
     * Returns whether the overview is rendered.
     * @param {Chart} chart
     * @return {boolean}
     */
    isOverviewRendered: (chart) => {
      var options = chart.getOptions();
      return DvtChartTypeUtils.isOverviewSupported(chart) && options['overview']['rendered'] != 'off';
    },

    /**
     * Returns the height of the overview scrollbar.
     * @param {Chart} chart
     * @return {number} The height.
     */
    getOverviewHeight: (chart) => {
      var options = chart.getOptions();
      var height = options['overview']['height'];
      if (height == null) height = DvtChartTypeUtils.hasTimeAxis(chart) ? 0.25 : 0.2; // use default ratio

      return DvtChartStyleUtils.getSizeInPixels(height, chart.getHeight());
    },

    /**
     * Computes the size of a subcomponent in pixels by parsing the user input.
     * @param {object} size The size input given by the user. It can be in percent, pixels, or number.
     * @param {number} totalSize The total size of the component in pixels.
     * @return {number} The size of the subcomponent in pixels.
     */
    getSizeInPixels: (size, totalSize) => {
      if (typeof size == 'string') {
        if (size.slice(-1) == '%') return (totalSize * Number(size.slice(0, -1))) / 100;
        else if (size.slice(-2) == 'px') return Number(size.slice(0, -2));
        else size = Number(size);
      }

      if (typeof size == 'number') {
        if (size <= 1)
          // assume to be ratio
          return totalSize * size;
        // assume to be absolute size in pixels
        else return size;
      } else return 0;
    },
    /**
     * Returns the plot area background color.
     * @param {Chart} chart
     * @param {Boolean} useDefault Whether it should fall back to the white default if the background color is not defined.
     * @return {String}
     */
    getBackgroundColor: (chart, useDefault) => {
      var options = chart.getOptions();
      if (options['plotArea']['backgroundColor']) return options['plotArea']['backgroundColor'];
      else return useDefault ? '#FFFFFF' : null;
    },
    /**
     * Returns the delay before mouse over event is triggerd.
     * This is used for highlighting in chart.
     * @param {Chart} chart
     * @return {number} The delay in ms.
     */
    getHoverBehaviorDelay: (chart) => {
      var delay = chart.getOptions()['styleDefaults']['hoverBehaviorDelay'];
      if (delay) {
        delay = dvt.CSSStyle.getTimeMilliseconds(delay);

        if (DvtChartTypeUtils.isScatterBubble(chart) || DvtChartTypeUtils.isLine(chart)) {
          return 0.75 * delay;
        } else {
          return 1.25 * delay;
        }
      } else {
        return 0;
      }
    },
    /**
     * Returns true if the marker stroke should be optimized by moving onto a container.
     * @param {Chart} chart
     * @return {boolean}
     */
    optimizeMarkerStroke: (chart) => {
      return DvtChartTypeUtils.isScatterBubble(chart) || DvtChartTypeUtils.isBoxPlot(chart);
    },
    /**
     * Returns the chart x-axis group width.
     * Use this method instead of calling chart.xAxis.getInfo().getGroupWidth() directly for better performance.
     * @param {Chart} chart
     * @return {number}
     */
    getGroupWidth: (chart) => {
      // Use the cached value if it has been computed before
      var cacheKey = 'groupWidth';
      var width = chart.getCache().getFromCache(cacheKey);
      if (width == null) {
        width = chart.xAxis.getInfo().getGroupWidth();
        chart.getCache().putToCache(cacheKey, width);
      }
      return width;
    },
    /**
     * Returns true if the chart supports stacking and stack label is enabled.
     * @param {Chart} chart
     * @return {boolean}
     */
    isStackLabelRendered: (chart) => {
      // To have stack labels, the attribute must be set and the chart must be a supporting type.
      var options = chart.getOptions();
      //check if stack is enabled first
      if (options['stack'] != 'on' || DvtChartTypeUtils.isMixedFrequency(chart)) {
        return false;
      }

      if (options['stackLabel'] === 'on') return DvtChartTypeUtils.isBLAC(chart);

      return false;
    },
    /**
     * Returns true if the marker fill should be optimized by moving onto a container.
     * @param {Chart} chart
     * @return {boolean}
     */
    optimizeMarkerFill: (chart) => {
      return DvtChartTypeUtils.isLineArea(chart);
    },
    /**
     * Returns the className for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {string} The class string.
     */
    getClassName: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && (dataItem['className'] || dataItem['svgClassName']))
        return dataItem['className'] || dataItem['svgClassName'];

      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['className'] || seriesItem['svgClassName']))
        return seriesItem['className'] || seriesItem['svgClassName'];
      else return null;
    },
    /**
     * Returns the areaClassName for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {string} The class string.
     */
    getAreaClassName: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['areaClassName'] || seriesItem['areaSvgClassName']))
        return seriesItem['areaClassName'] || seriesItem['areaSvgClassName'];
      else if (seriesItem && (seriesItem['className'] || seriesItem['svgClassName']))
        return seriesItem['className'] || seriesItem['svgClassName'];
      return null;
    },
    /**
     * Returns the className for the specified data item marker.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The class string.
     */
    getMarkerClassName: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && (nestedDataItem['className'] || nestedDataItem['svgClassName']))
        return nestedDataItem['className'] || nestedDataItem['svgClassName'];

      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && (dataItem['className'] || dataItem['svgClassName']))
        return dataItem['className'] || dataItem['svgClassName'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['markerClassName'] || seriesItem['markerSvgClassName']))
        return seriesItem['markerClassName'] || seriesItem['markerSvgClassName'];

      if (
        DvtChartTypeUtils.isScatterBubble(chart) &&
        seriesItem &&
        (seriesItem['className'] || seriesItem['svgClassName'])
      )
        return seriesItem['className'] || seriesItem['svgClassName'];
      else return null;
    },
    /**
     * Returns the style for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {object} The object defining the style.
     */
    getStyle: (chart, seriesIndex, groupIndex) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && (dataItem['style'] || dataItem['svgStyle']))
        return dataItem['style'] || dataItem['svgStyle'];

      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['style'] || seriesItem['svgStyle']))
        return seriesItem['style'] || seriesItem['svgStyle'];
      return null;
    },
    /**
     * Returns the areaStyle for the specified series.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {object} The object defining the style.
     */
    getAreaStyle: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['areaStyle'] || seriesItem['areaSvgStyle']))
        return seriesItem['areaStyle'] || seriesItem['areaSvgStyle'];
      else if (seriesItem && (seriesItem['style'] || seriesItem['svgStyle']))
        return seriesItem['style'] || seriesItem['svgStyle'];
      return null;
    },
    /**
     * Returns the style for the specified data item marker.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {object} The object defining the style.
     */
    getMarkerStyle: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Nested Data Override
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (nestedDataItem && (nestedDataItem['style'] || nestedDataItem['svgStyle']))
        return nestedDataItem['style'] || nestedDataItem['svgStyle'];

      // Data Override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (dataItem && (dataItem['style'] || dataItem['svgStyle']))
        return dataItem['style'] || dataItem['svgStyle'];

      // Series Override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && (seriesItem['markerStyle'] || seriesItem['markerSvgStyle']))
        return seriesItem['markerStyle'] || seriesItem['markerSvgStyle'];

      if (
        DvtChartTypeUtils.isScatterBubble(chart) &&
        seriesItem &&
        (seriesItem['style'] || seriesItem['svgStyle'])
      )
        return seriesItem['style'] || seriesItem['svgStyle'];
      else return null;
    },
    /**
     * Returns an object containing the computed box plot options for the specified data item.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {object}
     */
    getBoxPlotStyleOptions: (chart, seriesIndex, groupIndex) => {
      // Data item override
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      var dataItemOptions = dataItem && dataItem['boxPlot'] ? dataItem['boxPlot'] : {};

      // Series override
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      var seriesOptions = seriesItem && seriesItem['boxPlot'] ? seriesItem['boxPlot'] : {};

      // Style defaults
      var styleDefaults = chart.getOptions()['styleDefaults'];
      var styleDefaultsOptions = styleDefaults['boxPlot'];

      // Merge the three options
      var boxPlotOptions = dvt.JsonUtils.merge(
        dataItemOptions,
        dvt.JsonUtils.merge(seriesOptions, styleDefaultsOptions)
      );

      // Default color ramp support. Pass the data color privately for the hover color
      var defaultColor = DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
      boxPlotOptions['_color'] = defaultColor;
      var defaultBoxColor = dvt.ColorUtils.getBrighter(defaultColor, 0.8);
      if (!boxPlotOptions['q2Color']) boxPlotOptions['q2Color'] = defaultBoxColor;
      if (!boxPlotOptions['q3Color']) boxPlotOptions['q3Color'] = defaultBoxColor;

      // Default pattern ramp support (not public API, but needed for seriesEffect=pattern)
      if (DvtChartStyleUtils.getSeriesEffect(chart) == 'pattern') {
        var defaultPattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex);
        boxPlotOptions['_q2Pattern'] = defaultPattern;
        boxPlotOptions['_q3Pattern'] = defaultPattern;
      }

      // Border color and border width. Box plot has a border by default
      var defaultBorderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex, groupIndex);
      boxPlotOptions['borderColor'] = defaultBorderColor ? defaultBorderColor : defaultColor;
      boxPlotOptions['borderWidth'] = DvtChartStyleUtils.getBorderWidth(
        chart,
        seriesIndex,
        groupIndex
      );

      // Default whisker and median line color
      var defaultLineColor = dvt.ColorUtils.getDarker(defaultColor, 0.1);
      DvtChartStyleUtils._setBoxPlotDefaultLineColor(boxPlotOptions, 'whisker', defaultLineColor);
      DvtChartStyleUtils._setBoxPlotDefaultLineColor(boxPlotOptions, 'whiskerEnd', defaultLineColor);
      DvtChartStyleUtils._setBoxPlotDefaultLineColor(boxPlotOptions, 'median', defaultLineColor);

      return boxPlotOptions;
    },
    /**
     * Sets the default line color for box plot shapes.
     * @param {object} boxPlotOptions The box plot style option object.
     * @param {string} prefix The option name prefix.
     * @param {string} defaultLineColor The default line color to set if the color is not user-specified.
     * @private
     */
    _setBoxPlotDefaultLineColor: (boxPlotOptions, prefix, defaultLineColor) => {
      // The deprecated *Style option name has to be merged with *SvgStyle to maintain backwards compatibility.
      // The reason is that the default options in DvtChartDefaults are only defined for *SvgStyle.
      var lineSvgStyle = dvt.JsonUtils.merge(
        boxPlotOptions[prefix + 'Style'],
        boxPlotOptions[prefix + 'SvgStyle']
      );
      boxPlotOptions[prefix + 'SvgStyle'] = lineSvgStyle;
      boxPlotOptions[prefix + 'Style'] = null; // nullify so *Style will not be applied

      // Set the default line color if the stroke is not set in the svgStyle, and if svgClassName is not set.
      if (
        lineSvgStyle &&
        !lineSvgStyle['stroke'] &&
        !boxPlotOptions[prefix + 'ClassName'] &&
        !boxPlotOptions[prefix + 'SvgClassName']
      )
        boxPlotOptions[prefix + 'SvgStyle']['stroke'] = defaultLineColor;
    },
    /**
     * Returns an object containing information about the data item used by tooltip and dataLabel callbacks.
     * @param {Chart} chart
     * @param {number} seriesIndex The series index.
     * @param {number} groupIndex The group index.
     * @param {number} itemIndex The nested item index.
     * @return {object} An object containing information about the data item.
     */
    getDataContext: (chart, seriesIndex, groupIndex, itemIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      var nestedDataItem = DvtChartDataUtils.getNestedDataItem(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      var rawOptions = chart.getRawOptions();
      var isOtherSlice = DvtChartTypeUtils.isPie(chart) && (seriesIndex == null || seriesIndex < 0);
      var chartOptions = chart.getOptions();

      var dataContext;
      if (isOtherSlice) {
        var otherStr = chartOptions.translations.labelOther;
        dataContext = {
          id: otherStr,
          series: otherStr,
          value: DvtChartPieUtils.getOtherVal(chart),
          color: chartOptions['styleDefaults']['otherColor']
        };
      } else if (nestedDataItem) {
        var rawData = rawOptions['series'][seriesIndex]['items'][groupIndex];
        if (rawData._noTemplate) {
          rawData = rawData._itemData;
        } else if (rawData && typeof rawData === 'object') {
          rawData = Object.assign({}, rawData);
          delete rawData['_itemData'];
        }
        dataContext = {
          id: DvtChartDataUtils.getNestedDataItemId(chart, seriesIndex, groupIndex, itemIndex),
          data: [rawData, rawData['items'][itemIndex]],
          value: DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex, itemIndex),
          y: DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex, itemIndex),
          color: DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex, itemIndex),
          itemData: chartOptions['series'][seriesIndex]['items'][groupIndex]['_itemData']
        };
      } else if (dataItem) {
        var rawDataObj = rawOptions['series'][seriesIndex]['items'][groupIndex];
        if (rawDataObj._noTemplate) {
          rawDataObj = rawDataObj._itemData;
        } else if (rawDataObj && typeof rawDataObj === 'object') {
          rawDataObj = Object.assign({}, rawDataObj);
          delete rawDataObj['_itemData'];
        }
        dataContext = {
          id: DvtChartDataUtils.getDataItemId(chart, seriesIndex, groupIndex),
          data: rawDataObj,
          value: DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex),
          targetValue: DvtChartDataUtils.getTargetVal(chart, seriesIndex, groupIndex),
          x: DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex),
          y: DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex),
          z: DvtChartDataUtils.getZVal(chart, seriesIndex, groupIndex),
          low: DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex),
          high: DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex),
          open: dataItem['open'],
          q1: dataItem['q1'],
          q2: dataItem['q2'],
          q3: dataItem['q3'],
          close: dataItem['close'],
          volume: dataItem['volume'],
          color: DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex),
          itemData: chartOptions['series'][seriesIndex]['items'][groupIndex]['_itemData']
        };
      } else if (seriesItem) {
        dataContext = {
          id: DvtChartDataUtils.getSeries(chart, seriesIndex),
          color: DvtChartStyleUtils.getColor(chart, seriesIndex)
        };
      }

      if (dataContext) {
        dataContext['component'] = chartOptions['_widgetConstructor'];

        if (isOtherSlice || nestedDataItem || dataItem) {
          dataContext['group'] = DvtChartDataUtils.getGroup(chart, groupIndex);
          dataContext['groupData'] = DvtChartDataUtils.getGroupsDataForContext(chart)[groupIndex];
        }

        if (!isOtherSlice && (nestedDataItem || dataItem || seriesItem)) {
          dataContext['series'] = DvtChartDataUtils.getSeries(chart, seriesIndex);
          dataContext['seriesData'] = DvtChartDataUtils.getSeriesDataForContext(chart, seriesIndex);
        }

        if (DvtChartTypeUtils.isPie(chart) && chart.pieChart)
          dataContext['totalValue'] = chart.pieChart.getTotalValue();

        var barDimensions = chart
          .getOptionsCache()
          .getFromCachedMap2D('barDims', seriesIndex, groupIndex);
        if (barDimensions) dataContext['dimensions'] = barDimensions;

        dataContext = chart.getCtx().fixRendererContext(dataContext);
      }

      return dataContext || {};
    },
    /**
     * Returns an object containing information about the data item used by tooltip and dataLabel callbacks.
     * @param {Chart} chart
     * @param {number} seriesIndex The series index.
     * @param {number} groupIndex The group index.
     * @param {number} itemIndex The nested item index.
     * @return {object} An object containing information about the data item.
     */
    getShortDescContext: (chart, seriesIndex, groupIndex, itemIndex) => {
      // Only data items have tooltips
      if (seriesIndex < 0 || groupIndex < 0) return null;

      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      var rawOptions = chart.getRawOptions();
      var chartOptions = chart.getOptions();

      var rawData = rawOptions['series'][seriesIndex]['items'][groupIndex];
      if (rawData._noTemplate) {
        rawData = rawData._itemData;
      } else if (rawData && typeof rawData === 'object') {
        rawData = Object.assign({}, rawData);
        delete rawData['_itemData'];
      }
      return {
        id: DvtChartDataUtils.getDataItemId(chart, seriesIndex, groupIndex),
        data: rawData,
        value: DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex),
        targetValue: DvtChartDataUtils.getTargetVal(chart, seriesIndex, groupIndex),
        label: DvtChartDataUtils.getDefaultDataLabel(chart, seriesIndex, groupIndex, itemIndex),
        totalValue:
          DvtChartTypeUtils.isPie(chart) && chart.pieChart ? chart.pieChart.getTotalValue() : null,
        x: DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex),
        y: DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex),
        z: DvtChartDataUtils.getZVal(chart, seriesIndex, groupIndex),
        low: DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex),
        high: DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex),
        q1: dataItem['q1'],
        q2: dataItem['q2'],
        q3: dataItem['q3'],
        volume: dataItem['volume'],
        open: dataItem['open'],
        close: dataItem['close'],
        itemData: chartOptions['series'][seriesIndex]['items'][groupIndex]['_itemData'],
        group: DvtChartDataUtils.getGroup(chart, groupIndex),
        groupData: DvtChartDataUtils.getGroupsDataForContext(chart)[groupIndex],
        series: DvtChartDataUtils.getSeries(chart, seriesIndex),
        seriesData: DvtChartDataUtils.getSeriesDataForContext(chart, seriesIndex)
      };
    },
    /**
     * Returns the data label for the specified data point.
     * @param {Chart} chart
     * @param {number} seriesIndex The series index.
     * @param {number} groupIndex The group index.
     * @param {number} itemIndex The nested item index.
     * @param {number} type (optional) Data label type: low, high, or value.
     * @param {boolean} isStackLabel true if label for stack cummulative, false otherwise
     * @return {string} The data label, null if the index is invalid.
     */
    getDataLabel: (chart, seriesIndex, groupIndex, itemIndex, type, isStackLabel) => {
      var funcLabel;
      var defaultLabel = DvtChartDataUtils.getDefaultDataLabel(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex,
        type,
        isStackLabel
      );

      // Use data Label function if there is one
      var dataLabelFunc = chart.getOptions()['dataLabel'];
      if (dataLabelFunc && !isStackLabel) {
        var dataContext = DvtChartStyleUtils.getDataContext(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex
        );
        dataContext['label'] = defaultLabel;
        funcLabel = dataLabelFunc(dataContext);
        if (typeof funcLabel == 'number') {
          var valueFormat = DvtChartFormatUtils.getValueFormat(chart, 'label');
          funcLabel = DvtChartFormatUtils.formatVal(chart, valueFormat, funcLabel);
        }
      }
      if (chart.Options.stackLabelProvider && isStackLabel) {
        var stackLabelContext = DvtChartStyleUtils.getStackLabelContext(chart, groupIndex);
        funcLabel = chart.Options.stackLabelProvider(stackLabelContext);
      }

      return funcLabel ? funcLabel : defaultLabel;
    },

    /**
     * Returns an object containing information about the stack item used by stack label callbacks.
     * @param {Chart} chart
     * @return {object} An object containing information about the data item.
     */
    getStackLabelContext: (chart, groupIndex) => {
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var chartOptions = chart.getOptions();
      var rawData = [];
      var itemData = [];
      var value = 0;
      var groups = DvtChartDataUtils.getGroup(chart, groupIndex);
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        var item = chartOptions['series'][seriesIndex]['items'][groupIndex];
        rawData.push(item);
        if (item) {
          itemData.push(item['_itemData']);
        }
        value += DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);
      }
      var groupData = DvtChartDataUtils.getGroupsDataForContext(chart)[groupIndex] || [];
      var stackLabelContext;
      //these all have to be arrays that get extended with each call
      stackLabelContext = {
        groups: groups,
        data: rawData,
        groupData: groupData,
        value: value,
        itemData: itemData
      };
      return stackLabelContext;
    },
    /**
     * @param {Chart} chart
     * @return {boolean} true if one of the series is centeredSegmented or centeredStepped line or area.
     */
    hasCenteredSeries: (chart) => {
      if (!DvtChartTypeUtils.isBLAC(chart)) return false;

      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Ignore the series if it isn't rendered
        if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) continue;
        else if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'bar') {
          // line or area
          var lineType = DvtChartStyleUtils.getLineType(chart, seriesIndex);
          if (lineType == 'centeredSegmented' || lineType == 'centeredStepped') return true;
        }
      }
      return false;
    },
    /**
     * @param {Chart} chart
     * @return {boolean} true if one of the series is segmented or stepped line or area.
     */
    hasUncenteredSeries: (chart) => {
      if (!DvtChartTypeUtils.isBLAC(chart)) return false;

      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Ignore the series if it isn't rendered
        if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) continue;
        else if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'bar') {
          // line or area
          var lineType = DvtChartStyleUtils.getLineType(chart, seriesIndex);
          if (lineType == 'segmented' || lineType == 'stepped') return true;
        }
      }
      return false;
    },

    /**
     * Returns whether data label contrast outline is supported for the chart type.
     * @param {Chart} chart
     * @return {boolean}
     */
    supportsLabelOutline: (chart, seriesIndex) => {
      const dataLabelOutline = chart.getOptions().styleDefaults.dataLabelOutline;
      var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      if (
        dataLabelOutline === 'auto' &&
        (seriesType === 'area' ||
          seriesType === 'line' ||
          seriesType === 'lineWithArea' ||
          DvtChartTypeUtils.isScatterBubble(chart))
      ) {
        return true;
      }
      return false;
    }
  };

  /**
   * Data cursor component.
   * @extends {dvt.Container}
   * @class DvtChartDataCursor  Creates a data cursor component.
   * @constructor
   * @param {dvt.Context} context The context object.
   * @param {object} options The data cursor options.
   * @param {boolean} bHoriz True if this is a data cursor for horizontal charts.
   */
  class DvtChartDataCursor extends dvt.Container {
    /**
     * Initializes the data cursor.
     * @param {dvt.Context} context The context object.
     * @param {object} options The data cursor options.
     * @param {boolean} bHoriz True if this is a data cursor for horizontal charts.
     */
    constructor(context, options, bHoriz) {
      super(context);

      this._bHoriz = bHoriz;
      this._options = options;

      // Data cursor is never the target of mouse events
      this.setMouseEnabled(false);

      // Initially invisible until shown
      this.setVisible(false);

      //******************************************* Data Cursor Line ******************************************************/
      var lineWidth = options['lineWidth'];
      var lineColor = options['lineColor'];
      var stroke = new dvt.Stroke(
        lineColor,
        1,
        lineWidth,
        false,
        dvt.Stroke.getDefaultDashProps(options['lineStyle'], lineWidth)
      );

      this._cursorLine = new dvt.Line(this.getCtx(), 0, 0, 0, 0, 'dcLine');
      this._cursorLine.setStroke(stroke);
      this.addChild(this._cursorLine);

      //******************************************* Data Cursor Line Border ******************************************************/
      this._cursorOuterLine = new dvt.Line(this.getCtx(), 0, 0, 0, 0, 'dcLine');
      this._cursorOuterLine.setClassName('oj-chart-data-cursor-outer-line');
      this.addChild(this._cursorOuterLine);
      // default marker
      this.addMarker(dvt.SimpleMarker.CIRCLE, options.markerSize);
    }

    addMarker(markerShape, markerSize) {
      if (this._options.markerDisplayed !== 'off') {
        if (this._marker) {
          this.removeChild(this._marker);
        }
        this._marker = new dvt.Container(this._context);
        this._marker.setMouseEnabled(false);
        this.addChild(this._marker);

        var lineColor = this._options.lineColor;
        var lineWidth = this._options.lineWidth;
        var outerShape = new dvt.SimpleMarker(
          this._context,
          markerShape,
          0,
          0,
          markerSize + 4 * lineWidth,
          markerSize + 4 * lineWidth
        );
        outerShape.setSolidFill(lineColor);
        this._marker.addChild(outerShape);

        var middleShape = new dvt.SimpleMarker(
          this._context,
          markerShape,
          0,
          0,
          markerSize + 2 * lineWidth,
          markerSize + 2 * lineWidth
        );
        middleShape.setSolidFill('white');
        this._marker.addChild(middleShape);

        // Inner circle will be filled to correspond to the data item color
        this._markerInnerShape = new dvt.SimpleMarker(
          this._context,
          markerShape,
          0,
          0,
          markerSize,
          markerSize
        );
        this._marker.addChild(this._markerInnerShape);
      }
    }

    /**
     * Renders this data cursor.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     * @param {number} dataX The x coordinate of the actual data point, where the marker should be placed.
     * @param {number} dataY The y coordinate of the actual data point, where the marker should be placed.
     * @param {number} lineCoord The x coordinate of a vertical data cursor, or the y coordinate of a horizontal data cursor.
     * @param {string} text The text for the datatip.
     * @param {string} dataColor The primary color of the associated data item.
     */
    render(plotAreaBounds, dataX, dataY, lineCoord, text, dataColor) {
      var bHoriz = this.isHorizontal();
      var bRtl = dvt.Agent.isRightToLeft(this.getCtx());
      var tooltipBounds;

      // convert local coords to scaled stage coord for tooltip positioning
      // however datacursor and marker position are in local coords for svg rendering.

      var scaledPlotXY = this._parent.localToStage(new dvt.Point(plotAreaBounds.x, plotAreaBounds.y));
      var scaledPlotX2Y2 = this._parent.localToStage(
        new dvt.Point(plotAreaBounds.x + plotAreaBounds.w, plotAreaBounds.y + plotAreaBounds.h)
      );
      var scaledDataXY = this._parent.localToStage(new dvt.Point(dataX, dataY));
      var scaledCoord = this._parent.localToStage(
        new dvt.Point(bHoriz ? 0 : lineCoord, bHoriz ? lineCoord : 0)
      );

      var scaledLineCoord = bHoriz ? scaledCoord.y : scaledCoord.x;

      if (text != null && text != '') {
        // First render the datatip to retrieve its size.
        var stagePageCoords = this.getCtx().getStageAbsolutePosition();
        var tooltipManager = this.getCtx().getTooltipManager(DvtChartDataCursor.TOOLTIP_ID);
        tooltipManager.showDatatip(
          scaledDataXY.x + stagePageCoords.x,
          scaledDataXY.y + stagePageCoords.y,
          text,
          dataColor,
          false
        );
        tooltipBounds = tooltipManager.getTooltipBounds(); // tooltipBounds is in the page coordinate space

        // Then reposition to the right location
        var markerSizeOuter = this._options['markerSize'] + 4 * this._options['lineWidth'];
        var tooltipX, tooltipY; // tooltipX and tooltipY in the stage coordinate space
        if (bHoriz) {
          tooltipX = bRtl
            ? scaledPlotXY.x - 0.75 * tooltipBounds.w
            : scaledPlotXY.x + Math.abs(scaledPlotXY.x - scaledPlotX2Y2.x) - tooltipBounds.w / 4;
          tooltipY = scaledLineCoord - tooltipBounds.h / 2;

          // Add a buffer between the tooltip and data point. This may be rejected in positionTip due to viewport location.
          if (!bRtl && tooltipX - scaledDataXY.x < markerSizeOuter)
            tooltipX = scaledDataXY.x + markerSizeOuter;
          else if (bRtl && scaledDataXY.x - (tooltipX + tooltipBounds.w) < markerSizeOuter)
            tooltipX = scaledDataXY.x - markerSizeOuter - tooltipBounds.w;
        } else {
          tooltipX = scaledLineCoord - tooltipBounds.w / 2;
          tooltipY = scaledPlotXY.y - 0.75 * tooltipBounds.h;

          // Add a buffer between the tooltip and data point. This may be rejected in positionTip due to viewport location.
          if (dataY - (tooltipY + tooltipBounds.h) < markerSizeOuter)
            tooltipY = dataY - markerSizeOuter - tooltipBounds.h;
        }
        tooltipManager.positionTip(tooltipX + stagePageCoords.x, tooltipY + stagePageCoords.y);
        // Finally retrieve the rendered bounds to calculate the attachment point for the cursor line.
        tooltipBounds = tooltipManager.getTooltipBounds(); // tooltipBounds is in the page coordinate space
        tooltipBounds.x -= stagePageCoords.x;
        tooltipBounds.y -= stagePageCoords.y;

        // adjust the tooltipBounds according to the scale so that data cursor length is correct.
        var x1y1 = this._parent.stageToLocal(new dvt.Point(tooltipBounds.x, tooltipBounds.y));
        var x2y2 = this._parent.stageToLocal(
          new dvt.Point(tooltipBounds.x + tooltipBounds.w, tooltipBounds.y + tooltipBounds.h)
        );
        tooltipBounds.x = x1y1.x;
        tooltipBounds.y = x1y1.y;
        tooltipBounds.w = Math.abs(x2y2.x - x1y1.x);
        tooltipBounds.h = Math.abs(x2y2.y - x1y1.y);
      }

      // Position the cursor line. Use 1px fudge factor to ensure that the line connects to the tooltip.
      var cursorLineWidth = this._cursorLine.getStroke().getWidth();
      var cursorOuterLineCoord = lineCoord + Math.ceil(cursorLineWidth / 2);
      if (bHoriz) {
        this._cursorLine.setTranslateY(lineCoord);
        this._cursorOuterLine.setTranslateY(cursorOuterLineCoord);
        var x1Pos, x2Pos;
        if (bRtl) {
          x1Pos = tooltipBounds ? tooltipBounds.x + tooltipBounds.w - 1 : plotAreaBounds.x;
          x2Pos = plotAreaBounds.x + plotAreaBounds.w;
        } else {
          x1Pos = plotAreaBounds.x;
          const plotAreaEnd = plotAreaBounds.x + plotAreaBounds.w;
          x2Pos = Math.min(tooltipBounds ? tooltipBounds.x + 1 : plotAreaEnd, plotAreaEnd);
        }
        this._cursorLine.setX1(x1Pos);
        this._cursorLine.setX2(x2Pos);
        this._cursorOuterLine.setX1(x1Pos);
        this._cursorOuterLine.setX2(x2Pos);
      } else {
        // Vertical
        this._cursorLine.setTranslateX(lineCoord);
        this._cursorOuterLine.setTranslateX(cursorOuterLineCoord);

        // Position the cursor line
        var y1Pos = tooltipBounds ? tooltipBounds.y + tooltipBounds.h - 1 : plotAreaBounds.y;
        var y2Pos = plotAreaBounds.y + plotAreaBounds.h;
        this._cursorLine.setY1(y1Pos);
        this._cursorLine.setY2(y2Pos);
        this._cursorOuterLine.setY1(y1Pos);
        this._cursorOuterLine.setY2(y2Pos);
      }

      if (this._marker) {
        // Position the marker
        this._marker.setTranslate(dataX, dataY);

        // Set the marker color
        var markerColor = this._options['markerColor'];
        this._markerInnerShape.setSolidFill(markerColor ? markerColor : dataColor);

        // : Workaround firefox issue
        dvt.Agent.workaroundFirefoxRepaint(this._marker);
      }
    }

    /**
     * Returns true if this is a data cursor for a horizontal graph.
     * @return {boolean}
     */
    isHorizontal() {
      return this._bHoriz;
    }

    /**
     * Returns the behavior of the data cursor.
     * @return {string}
     */
    getBehavior() {
      return this._behavior ? this._behavior : 'auto';
    }

    /**
     * Specifies the behavior of the data cursor.
     * @param {string} behavior
     */
    setBehavior(behavior) {
      this._behavior = behavior;
    }
  }

  DvtChartDataCursor.TOOLTIP_ID = '_dvtDataCursor';

  /**
   * Reference object related utility functions for Chart.
   * @class
   */
  const DvtChartRefObjUtils = {
    /**
     * Returns the type of the reference object.
     * @param {object} refObj The reference object definition.
     * @return {string} The type of the reference object.
     */
    getType: (refObj) => {
      if (refObj['type'] == 'area') return 'area';
      // default to "line"
      else return 'line';
    },

    /**
     * Returns the location of the reference object.
     * @param {object} refObj The reference object definition.
     * @return {string} The location of the reference object.
     */
    getLocation: (refObj) => {
      if (refObj['location'] == 'front') return 'front';
      // default to "back"
      else return 'back';
    },

    /**
     * Returns the color of the reference object.
     * @param {Chart} chart
     * @param {object} refObj The reference object definition.
     * @return {string} The color.
     */
    getColor: (chart, refObj) => {
      if (refObj['color']) return refObj['color'];
      else
        return DvtChartRefObjUtils.getType(refObj) === 'line'
          ? chart.getOptions()['_defaultReferenceObjectLineColor']
          : chart.getOptions()['_defaultReferenceObjectAreaColor'];
    },

    /**
     * Returns the line width of the reference line.
     * @param {Chart} chart
     * @param {object} refObj The reference object definition.
     * @return {number} The line width.
     */
    getLineWidth: (chart, refObj) => {
      if (refObj['lineWidth']) return refObj['lineWidth'];
      else return parseFloat(chart.getOptions()['_defaultReferenceObjectLineWidth']);
    },
    /**
     * Returns the line type of the reference line.
     * @param {object} refObj The reference object definition.
     * @return {number} The line type.
     */
    getLineType: (refObj) => {
      if (refObj['lineType']) return refObj['lineType'];
      else return 'straight';
    },
    /**
     * Returns true if the specified reference object should be rendered.
     * @param {Chart} chart
     * @param {object} refObj
     * @return {boolean}
     */
    isObjRendered: (chart, refObj) => {
      var hiddenCategories = DvtChartDataUtils.getHiddenCategories(chart);
      if (hiddenCategories.length > 0) {
        var categories = DvtChartRefObjUtils.getRefObjCategories(refObj);
        if (categories && dvt.ArrayUtils.hasAnyItem(hiddenCategories, categories)) {
          return false;
        }
      }
      return refObj['visibility'] !== 'hidden';
    },

    /**
     * Returns the id of the reference object.
     * @param {object} refObj
     * @return {string}
     */
    getId: (refObj) => {
      return refObj['id'] != null ? refObj['id'] : refObj['text'];
    },
    /**
     * Returns the categories of the reference object.
     * @param {object} refObj
     * @return {string}
     */
    getRefObjCategories: (refObj) => {
      return refObj['categories'] ? refObj['categories'] : [DvtChartRefObjUtils.getId(refObj)];
    },
    /**
     * Returns reference object based on id.
     * @param {object} chart
     * @param {string} id The id of the ref obj.
     * @return {object}
     */
    getRefObj: (chart, id) => {
      var refObjs = DvtChartDataUtils.getRefObjs(chart);
      for (var i = 0; i < refObjs.length; i++) {
        if (DvtChartRefObjUtils.getId(refObjs[i]) == id) {
          return refObjs[i];
        }
      }
      return undefined;
    },

    /**
     * Returns the low value of the refObj item.
     * @param {object} item
     * @return {number}
     */
    getLowVal: (item) => {
      if (item == null) return null;
      return item['low'];
    },
    /**
     * Returns the high value of the refObj item.
     * @param {object} item
     * @return {number}
     */
    getHighVal: (item) => {
      if (item == null) return null;
      return item['high'];
    },
    /**
     * Retuns the x value of the refObj item at the given index
     * @param {Chart} chart
     * @param {object} items
     * @param {number} index
     * @return {number}
     */
    getXVal: (chart, items, index) => {
      return DvtChartDataUtils.getXValFromItem(chart, items[index], index);
    }
  };

  /**
   * Utility functions for Chart.
   * @class
   */
  const DvtChartTooltipUtils = {
    /**
     * Returns the datatip color for the tooltip of a data item with the given series
     * and group indices.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {string} The datatip color.
     */
    getDatatipColor: (chart, seriesIndex, groupIndex, itemIndex) => {
      if (DvtChartTypeUtils.isStock(chart)) return DvtChartStyleUtils.getColor(chart, 0, groupIndex);

      if (itemIndex != null && itemIndex >= 0)
        // nested item
        return DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex, itemIndex);

      return DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
    },

    /**
     * Returns the datatip string for a data item with the given series and group indices.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @return {string|Node|Array<Node>} The datatip string.
     */
    getDatatip: (chart, seriesIndex, groupIndex, itemIndex, isTabular) => {
      if (DvtChartTypeUtils.isSpark(chart) || DvtChartTypeUtils.isOverview(chart)) return null;

      // Only data items have tooltips
      if (seriesIndex < 0 || groupIndex < 0) return null;

      // Custom Tooltip via Function
      var customTooltip = chart.getOptions()['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;

      if (isTabular && tooltipFunc) {
        var tooltipManager = chart
          .getCtx()
          .getTooltipManager(
            DvtChartTooltipUtils.isDataCursorEnabled(chart) ? DvtChartDataCursor.TOOLTIP_ID : null
          );
        var dataContext = DvtChartStyleUtils.getDataContext(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex
        );

        // Get customized labels
        if (DvtChartTypeUtils.isPie(chart)) {
          var slice = DvtChartPieUtils.getSliceBySeriesIdx(chart, seriesIndex);
          dataContext['label'] = slice.getSliceLabelString();
        } else {
          dataContext['label'] = DvtChartStyleUtils.getDataLabel(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex
          );
        }

        return tooltipManager.getCustomTooltip(tooltipFunc, dataContext);
      }

      // Custom Tooltip Support for nested item
      var dataItem = DvtChartDataUtils.getNestedDataItem(chart, seriesIndex, groupIndex, itemIndex);
      // Custom Tooltip via Short Desc
      if (dataItem && dataItem.shortDesc != null) {
        return dataItem.shortDesc;
      }
      // check in data item
      var parentItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      if (parentItem && parentItem.shortDesc != null) {
        return dvt.Displayable.resolveShortDesc(parentItem.shortDesc, () =>
          DvtChartStyleUtils.getShortDescContext(chart, seriesIndex, groupIndex, itemIndex)
        );
      }

      // Default Tooltip Support
      var datatipRows;
      if (DvtChartTypeUtils.isStock(chart))
        datatipRows = DvtChartTooltipUtils._getStockDatatip(chart, 0, groupIndex, isTabular);
      else {
        datatipRows = [];
        DvtChartTooltipUtils._addSeriesDatatip(
          datatipRows,
          chart,
          seriesIndex,
          groupIndex,
          isTabular
        );
        DvtChartTooltipUtils._addGroupDatatip(datatipRows, chart, seriesIndex, groupIndex, isTabular);
        DvtChartTooltipUtils._addValDatatip(
          datatipRows,
          chart,
          seriesIndex,
          groupIndex,
          itemIndex,
          isTabular
        );
      }

      return DvtChartTooltipUtils._processDatatip(datatipRows, chart, isTabular);
    },

    /**
     * Returns the datatip string for an "Other" slice.
     * @param {Chart} chart
     * @param {number} otherValue The value of the "Other" slice
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @return {string|Node|Array<Node>} The datatip string.
     */
    getOtherSliceDatatip: (chart, otherValue, isTabular) => {
      var otherStr = chart.getOptions().translations.labelOther;

      // Custom Tooltip via Function
      var customTooltip = chart.getOptions()['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;
      if (isTabular && tooltipFunc) {
        var slice = DvtChartPieUtils.getSliceBySeriesIdx(chart, null);
        var dataContext = DvtChartStyleUtils.getDataContext(chart, null, 0);
        dataContext['label'] = slice.getSliceLabelString();
        return chart.getCtx().getTooltipManager().getCustomTooltip(tooltipFunc, dataContext);
      }

      // Default Tooltip
      var datatipRows = [];
      DvtChartTooltipUtils._addDatatipRow(
        datatipRows,
        chart,
        'series',
        'labelSeries',
        otherStr,
        isTabular
      );
      DvtChartTooltipUtils._addGroupDatatip(datatipRows, chart, 0, 0, isTabular);
      DvtChartTooltipUtils._addDatatipRow(
        datatipRows,
        chart,
        'value',
        'labelValue',
        otherValue,
        isTabular
      );
      return DvtChartTooltipUtils._processDatatip(datatipRows, chart, isTabular);
    },

    /**
     * Final processing for the datatip.
     * @param {Array<string|Node>} datatipRows The current datatip.
     * @param {Chart} chart The owning chart instance.
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @return {string|Node} The processed datatip.
     * @private
     */
    _processDatatip: (datatipRows, chart, isTabular) => {
      // Don't render tooltip if empty
      if (datatipRows.length === 0) return null;

      // Add outer table tags
      if (isTabular)
        return dvt.HtmlTooltipManager.createElement('table', null, datatipRows, [
          'oj-dvt-datatip-table'
        ]);
      else return datatipRows.join('');
    },

    /**
     * Returns the tooltip for the reference object.
     * @param {Chart} chart
     * @param {object} refObj The reference object definition.
     * @param {object} axisType The type of axis could be 'yAxis', 'y2Axis' or 'xAxis'.
     * @param {object} index The index of the reference object in the axis.
     * @return {string} The tooltip for the reference object.
     */
    getRefObjTooltip: (chart, refObj, axisType, index) => {
      // Custom Tooltip via Function -- only if refObj['id'] is defined for backwards compat
      var customTooltip = chart.getOptions()['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;
      if (tooltipFunc && refObj['id'] != null) {
        var tooltipManager = chart
          .getCtx()
          .getTooltipManager(
            DvtChartTooltipUtils.isDataCursorEnabled(chart) ? DvtChartDataCursor.TOOLTIP_ID : null
          );
        var dataContext = {
          id: DvtChartRefObjUtils.getId(refObj),
          label: refObj['text'],
          data: chart.getRawOptions()[axisType]['referenceObjects'][index],
          value: refObj['value'],
          low: DvtChartRefObjUtils.getLowVal(refObj),
          high: DvtChartRefObjUtils.getHighVal(refObj),
          color: DvtChartRefObjUtils.getColor(chart, refObj)
        };
        return tooltipManager.getCustomTooltip(tooltipFunc, dataContext);
      }

      return refObj['shortDesc'];
    },
    /**
     * Returns the datatip for a data item with the given series and group indices.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @return {Array<string|Node>} The datatip string.
     * @private
     */
    _getStockDatatip: (chart, seriesIndex, groupIndex, isTabular) => {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);

      // Default Tooltip
      var datatipRows = [];
      DvtChartTooltipUtils._addGroupDatatip(datatipRows, chart, seriesIndex, groupIndex, isTabular);
      if (dataItem) {
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'open',
          'labelOpen',
          dataItem['open'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'close',
          'labelClose',
          dataItem['close'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'high',
          'labelHigh',
          dataItem['high'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'low',
          'labelLow',
          dataItem['low'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'volume',
          'labelVolume',
          dataItem['volume'],
          isTabular
        );
      }
      return datatipRows;
    },
    /**
     * Adds the series string to the datatip.
     * @param {Array<string|Node>} datatipRows The current datatip. This array will be mutated.
     * @param {Chart} chart The owning chart instance.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @private
     */
    _addSeriesDatatip: (datatipRows, chart, seriesIndex, groupIndex, isTabular) => {
      var seriesLabel = DvtChartDataUtils.getSeriesLabel(chart, seriesIndex);
      DvtChartTooltipUtils._addDatatipRow(
        datatipRows,
        chart,
        'series',
        'labelSeries',
        seriesLabel,
        isTabular
      );
    },
    /**
     * Adds the group string to the datatip.
     * @param {Array<string|Node>} datatipRows The current datatip. This array will be mutated.
     * @param {Chart} chart The owning chart instance.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @private
     */
    _addGroupDatatip: (datatipRows, chart, seriesIndex, groupIndex, isTabular) => {
      var groupLabel;
      if (DvtChartTypeUtils.hasTimeAxis(chart)) {
        var valueFormat = DvtChartFormatUtils$1.getValueFormat(chart, 'group');
        var value = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
        groupLabel = DvtChartFormatUtils$1.formatDateVal(valueFormat, value);
        if (groupLabel == null) groupLabel = chart.xAxis.getInfo().formatLabel(value);
      } else groupLabel = DvtChartDataUtils.getGroupLabel(chart, groupIndex);

      var numLevels = DvtChartDataUtils.getNumLevels(chart);
      var defaultLabel = 'labelGroup';
      if (numLevels == 1 || !Array.isArray(groupLabel))
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'group',
          defaultLabel,
          groupLabel,
          isTabular
        );
      else {
        // hierarchical groups
        for (var levelIndex = numLevels - 1; levelIndex >= 0; levelIndex--) {
          DvtChartTooltipUtils._addDatatipRow(
            datatipRows,
            chart,
            'group',
            defaultLabel,
            groupLabel[levelIndex],
            isTabular,
            levelIndex
          );
          if (groupLabel[levelIndex]) defaultLabel = null;
        }
      }
    },

    /**
     * Adds the value string to the datatip.
     * @param {Array<string|Node>} datatipRows The current datatip. This array will be mutated.
     * @param {Chart} chart The owning chart instance.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @private
     */
    _addValDatatip: (datatipRows, chart, seriesIndex, groupIndex, itemIndex, isTabular) => {
      var val = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex, itemIndex);
      var xVal = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
      var zVal = DvtChartDataUtils.getZVal(chart, seriesIndex, groupIndex);
      var lowVal = DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex);
      var highVal = DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex);
      var isNested = itemIndex != null && itemIndex >= 0;

      if (DvtChartTypeUtils.isScatterBubble(chart)) {
        // Add the x and y values
        DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'x', 'labelX', xVal, isTabular);
        DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'y', 'labelY', val, isTabular);

        const label = DvtChartStyleUtils.getDataLabel(chart, seriesIndex, groupIndex);
        var displayLabel = chart.getOptions().valueFormats?.label?.tooltipDisplay != 'off';
        if (label && displayLabel && DvtChartTypeUtils.isScatter(chart)) {
          DvtChartTooltipUtils._addDatatipRow(
            datatipRows,
            chart,
            'label',
            'labelDataLabel',
            label,
            isTabular
          );
        }

        // Also add the z value for a bubble chart
        if (DvtChartTypeUtils.isBubble(chart))
          DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'z', 'labelZ', zVal, isTabular);
      } else if (DvtChartTypeUtils.isPie(chart) || DvtChartTypeUtils.isPyramid(chart)) {
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'value',
          'labelValue',
          val,
          isTabular
        );
      } else if (DvtChartTypeUtils.isFunnel(chart)) {
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'value',
          'labelValue',
          val,
          isTabular
        );
        var target = DvtChartDataUtils.getTargetVal(chart, seriesIndex);
        if (target != null)
          DvtChartTooltipUtils._addDatatipRow(
            datatipRows,
            chart,
            'targetValue',
            'labelTargetValue',
            target,
            isTabular
          );
      } else if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'boxPlot' && !isNested) {
        var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'high',
          'labelHigh',
          highVal,
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'q3',
          'labelQ3',
          dataItem['q3'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'q2',
          'labelQ2',
          dataItem['q2'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(
          datatipRows,
          chart,
          'q1',
          'labelQ1',
          dataItem['q1'],
          isTabular
        );
        DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'low', 'labelLow', lowVal, isTabular);

        if (zVal != null)
          DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'z', 'labelZ', zVal, isTabular);
      } else if (DvtChartTypeUtils.isBLAC(chart)) {
        var type = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex) ? 'y2' : 'y';

        // Ad min/max for range bar/area. Add z-value if defined for bar width.
        if ((lowVal != null || highVal != null) && !isNested) {
          DvtChartTooltipUtils._addDatatipRow(
            datatipRows,
            chart,
            'high',
            'labelHigh',
            highVal,
            isTabular
          );
          DvtChartTooltipUtils._addDatatipRow(
            datatipRows,
            chart,
            'low',
            'labelLow',
            lowVal,
            isTabular
          );
          if (zVal != null)
            DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'z', 'labelZ', zVal, isTabular);
        } else if (zVal != null && !isNested) {
          DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, type, 'labelY', val, isTabular);
          DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, 'z', 'labelZ', zVal, isTabular);
        } else
          DvtChartTooltipUtils._addDatatipRow(datatipRows, chart, type, 'labelValue', val, isTabular);
      }
    },

    /**
     * Adds a row of item to the datatip.
     * @param {Array<string|Node>} datatipRows The current datatip. This array will be mutated.
     * @param {Chart} chart The owning chart instance.
     * @param {number} type The item type, e.g. series, group, x, etc.
     * @param {number} defaultLabel The bundle resource string for the default label.
     * @param {number} value The item value.
     * @param {boolean} isTabular Whether the datatip is in a table format.
     * @param {number} index (optional) The index of the tooltipLabel string to be used
     * @private
     */
    _addDatatipRow: (datatipRows, chart, type, defaultLabel, value, isTabular, index) => {
      if (value == null || value === '') return;

      var options = chart.getOptions()['styleDefaults'];
      var valueFormat = DvtChartFormatUtils$1.getValueFormat(chart, type);
      var tooltipDisplay = valueFormat['tooltipDisplay'];
      var translations = chart.getOptions().translations;

      if (!tooltipDisplay || tooltipDisplay == 'auto') {
        if (type == 'group' && (DvtChartTypeUtils.isPie(chart) || DvtChartTypeUtils.isFunnel(chart)))
          tooltipDisplay = 'off';
      }

      if (tooltipDisplay == 'off') return;

      // Create tooltip label
      var tooltipLabel;
      if (typeof valueFormat['tooltipLabel'] === 'string') tooltipLabel = valueFormat['tooltipLabel'];
      else if (Array.isArray(valueFormat['tooltipLabel']))
        tooltipLabel = valueFormat['tooltipLabel'][index ? index : 0];

      if (tooltipLabel == null) {
        if (defaultLabel == null)
          // non-innermost hierarchical group labels
          tooltipLabel = '';
        else {
          // : Use date instead of group for time axis chart tooltips. Only doing this for JET right now until
          // 1.1.1, after which we use the options.translations across fwks.
          if (defaultLabel == 'labelGroup' && DvtChartTypeUtils.hasTimeAxis(chart))
            tooltipLabel = translations.labelDate;
          else tooltipLabel = translations[defaultLabel];
        }
      }

      // Create tooltip value
      if (type != 'label' && type != 'series' && type != 'group')
        value = DvtChartFormatUtils$1.formatVal(chart, valueFormat, value);

      if (isTabular) {
        var tds = [
          dvt.HtmlTooltipManager.createElement('td', options['tooltipLabelStyle'], tooltipLabel, [
            'oj-dvt-datatip-label'
          ]),
          dvt.HtmlTooltipManager.createElement('td', options['tooltipValueStyle'], value, [
            'oj-dvt-datatip-value'
          ])
        ];
        datatipRows.push(dvt.HtmlTooltipManager.createElement('tr', null, tds));
      } else {
        datatipRows.push(
          (datatipRows.length > 0 ? '<br>' : '') +
            dvt.ResourceUtils.format(translations.labelAndValue, [tooltipLabel, value])
        );
      }
    },

    /**
     * Returns whether or not the data cursor is enabled
     * @param {Chart} chart
     * @return {boolean}
     */
    isDataCursorEnabled: (chart) => {
      if (
        DvtChartTypeUtils.isPie(chart) ||
        DvtChartTypeUtils.isFunnel(chart) ||
        DvtChartTypeUtils.isPolar(chart) ||
        DvtChartTypeUtils.isPyramid(chart) ||
        DvtChartDataUtils.hasInvalidData(chart)
      ) {
        return false;
      }

      var options = chart.getOptions();
      if (options['dataCursor'] == 'on') return true;
      if (options['dataCursor'] == 'off') return false;

      // auto
      return dvt.Agent.isTouchDevice() && DvtChartTypeUtils.isLineArea(chart);
    },
    /**
     * Returns the data cursor behavior
     * @param {Chart} chart
     * @return {string}
     */
    getDataCursorBehavior: (chart) => {
      var dataCursorBehavior = chart.getOptions()['dataCursorBehavior'];

      if (dataCursorBehavior !== 'auto') {
        return dataCursorBehavior;
      }
      // auto
      return DvtChartTypeUtils.isLineArea(chart) ? 'smooth' : 'snap';
    }
  };

  /**
   * Logical object for chart data object displayables.
   * @param {Chart} chart The owning chart instance.
   * @param {array} displayables The array of associated DvtDisplayables.
   * @param {number} seriesIndex
   * @param {number} groupIndex
   * @param {number} itemIndex
   * @param {dvt.Point} dataPos The coordinate of the data point relative to the plot area
   * @class
   * @constructor
   * @implements {DvtCategoricalObject}
   * @implements {DvtLogicalObject}
   * @implements {DvtSelectable}
   * @implements {DvtTooltipSource}
   * @implements {DvtDraggable}
   */
  class DvtChartObjPeer {
    constructor(chart, displayables, seriesIndex, groupIndex, itemIndex, dataPos) {
      /**
       * @param {Chart} chart The owning chart instance.
       * @param {array} displayables The array of associated DvtDisplayables.
       * @param {number} seriesIndex
       * @param {number} groupIndex
       * @param {number} itemIndex
       * @param {dvt.Point} dataPos The coordinate of the data point relative to the plot area
       */
      this._chart = chart;
      this._displayables = displayables;
      this._seriesIndex = seriesIndex != null && seriesIndex >= 0 ? seriesIndex : -1;
      this._groupIndex = groupIndex != null && groupIndex >= 0 ? groupIndex : -1;
      this._itemIndex = itemIndex != null && itemIndex >= 0 ? itemIndex : -1;
      this._dataPos = dataPos;
      this._isSelected = false;
      this._isShowingKeyboardFocusEffect = false;

      // . Need to evaluate these up front because the series and group are used for animation
      this._series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      this._group = DvtChartDataUtils.getGroup(chart, groupIndex);

      // Create the array specifying all categories that this data item or series belongs to
      this._categories = DvtChartDataUtils.getCategories(chart, seriesIndex, groupIndex, itemIndex);

      if (this._itemIndex != -1) {
        this._dataItemId = DvtChartDataUtils.getNestedDataItemId(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex
        );
        this._drillable = DvtChartDataUtils.isDataItemDrillable(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex
        );
      } else if (this._groupIndex != -1) {
        var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
        if (dataItem) {
          this._dataItemId = DvtChartDataUtils.getDataItemId(chart, seriesIndex, groupIndex);
          this._drillable = DvtChartDataUtils.isDataItemDrillable(chart, seriesIndex, groupIndex);
        }
      } else {
        var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
        if (seriesItem) {
          this._drillable = DvtChartDataUtils.isSeriesDrillable(chart, seriesIndex);
        }
      }

      // Apply the cursor for drilling if specified
      if (this._drillable) {
        for (var i = 0; i < this._displayables.length; i++) {
          this._displayables[i].setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
        }
      }

      // Apply the aria properties
      for (var index = 0; index < displayables.length; index++) {
        var displayable = displayables[index];
        // lines are not interactive so we shouldn't add wai-aria attributes
        if (!(displayable.chartShapeType === 'lineArea')) displayable.setAriaRole('img');
        this._updateAriaLabel(displayable);
      }
    }

    /**
     * Creates a data item to identify the specified displayable and registers it with the chart.
     * @param {dvt.Displayable} displayable The displayable to associate.
     * @param {Chart} chart The owning chart instance.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex The index of nested data item.
     * @param {dvt.Point} dataPos The coordinate of the data point relative to the plot area.
     */
    static associate(displayable, chart, seriesIndex, groupIndex, itemIndex, dataPos) {
      // Associate is expensive and not needed during zoom & scroll.
      if (!displayable || chart.getOptions()['_duringZoomAndScroll']) return;

      // Create the logical object.
      var identObj = new DvtChartObjPeer(
        chart,
        [displayable],
        seriesIndex,
        groupIndex,
        itemIndex,
        dataPos
      );

      // Register with the chart
      chart.registerObject(identObj);

      // Finally associate using the event manager
      chart.getEventManager().associate(displayable, identObj);
    }

    /**
     * @override
     */
    getId() {
      if (this._seriesIndex >= 0 && this._groupIndex >= 0)
        return new DvtChartDataItem(
          this._dataItemId,
          this.getSeries(),
          this.getGroup(),
          this._chart.getCtx()
        );
      else if (this._seriesIndex >= 0) return this.getSeries();
      else return null;
    }

    /**
     * Return the peer's data item id.  This is an optional id that is provided to simplifying
     * row key support for ADF and AMX.
     * @return {string} the peer's row key.
     */
    getDataItemId() {
      return this._dataItemId;
    }

    /**
     * Return the peer's nested data item index.
     * @return {number}
     */
    getNestedDataItemIndex() {
      return this._itemIndex;
    }

    /**
     * Return the peer's series.
     * @return {string} the peer's series.
     */
    getSeries() {
      return this._series;
    }

    /**
     * Return the peer's series index.
     * @return {Number} the peer's series index.
     */
    getSeriesIndex() {
      return this._seriesIndex;
    }

    /**
     * Return the peer's group.
     * @return {string} the peer's group.
     */
    getGroup() {
      return this._group;
    }

    /**
     * Return the peer's group index.
     * @return {Number} the peer's group index.
     */
    getGroupIndex() {
      return this._groupIndex;
    }

    /**
     * Returns whether the chart object is drillable
     * @return {boolean}
     */
    isDrillable() {
      return this._drillable;
    }

    /**
     * Returns whether the chart object is double clickable.
     * @return {boolean}
     */
    isDoubleClickable() {
      // : IE double clicking workaround in dvt.EventManager.
      return this.isSelectable() && this.isDrillable();
    }

    /**
     * Convenience function to return the peer's chart.
     * @return {Chart} the associated chart object.
     */
    getChart() {
      return this._chart;
    }

    //---------------------------------------------------------------------//
    // Tooltip Support: DvtTooltipSource impl                              //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    getDatatip() {
      return DvtChartTooltipUtils.getDatatip(
        this._chart,
        this._seriesIndex,
        this._groupIndex,
        this._itemIndex,
        true
      );
    }

    /**
     * @override
     */
    getDatatipColor() {
      return DvtChartTooltipUtils.getDatatipColor(
        this._chart,
        this._seriesIndex,
        this._groupIndex,
        this._itemIndex
      );
    }

    //---------------------------------------------------------------------//
    // Selection Support: DvtSelectable impl                               //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    isSelectable() {
      return DvtChartStyleUtils.isSelectable(
        this.getChart(),
        this.getSeriesIndex(),
        this.getGroupIndex()
      );
    }

    /**
     * @override
     */
    isSelected() {
      return this._isSelected;
    }

    /**
     * @override
     */
    setSelected(bSelected) {
      this._isSelected = bSelected;
      for (var i = 0; i < this._displayables.length; i++) {
        if (this._displayables[i].setSelected) {
          this._displayables[i].setSelected(bSelected);
          this._updateAriaLabel(this._displayables[i]);
        }
      }
    }

    /**
     * @override
     */
    showHoverEffect() {
      for (var i = 0; i < this._displayables.length; i++) {
        if (this._displayables[i].showHoverEffect) this._displayables[i].showHoverEffect();
      }
    }

    /**
     * @override
     */
    hideHoverEffect() {
      for (var i = 0; i < this._displayables.length; i++) {
        if (this._displayables[i].hideHoverEffect) this._displayables[i].hideHoverEffect();
      }
    }

    //---------------------------------------------------------------------//
    // Rollover and Hide/Show Support: DvtLogicalObject impl               //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getDisplayables() {
      return this._displayables;
    }

    /**
     * @override
     */
    getAriaLabel() {
      var states = [];
      var translations = this.getChart().getOptions().translations;
      if (this.isSelectable())
        states.push(translations[this.isSelected() ? 'stateSelected' : 'stateUnselected']);
      if (this.isDrillable()) states.push(translations.stateDrillable);

      var shortDesc = DvtChartTooltipUtils.getDatatip(
        this._chart,
        this._seriesIndex,
        this._groupIndex,
        this._itemIndex,
        false
      );
      if (shortDesc == null && this._groupIndex < 0 && states.length > 0)
        shortDesc = DvtChartDataUtils.getSeriesLabel(this._chart, this._seriesIndex);

      return dvt.Displayable.generateAriaLabel(shortDesc, states, () =>
        DvtChartStyleUtils.getShortDescContext(
          this._chart,
          this._seriesIndex,
          this._groupIndex,
          this._itemIndex,
          false
        )
      );
    }

    /**
     * Updates the aria-label as needed. On desktop, we can defer the aria creation, and the aria-label will be updated
     * when the activeElement is set.
     * @param {dvt.Displayable} displayable The displayable object.
     * @private
     */
    _updateAriaLabel(displayable) {
      if (!dvt.Agent.deferAriaCreation()) displayable.setAriaProperty('label', this.getAriaLabel());
    }

    //---------------------------------------------------------------------//
    // Rollover and Hide/Show Support: DvtCategoricalObject impl           //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getCategories(category) {
      return this._categories;
    }

    /**
     * @return {dvt.Point} The coordinate of the data point relative to the plot area
     */
    getDataPosition() {
      return this._dataPos;
    }

    //---------------------------------------------------------------------//
    // Keyboard Support: DvtKeyboardNavigable impl                        //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getNextNavigable(event) {
      var keyCode;
      var next;

      keyCode = event.keyCode;
      if (event.type == dvt.MouseEvent.CLICK) {
        return this;
      } else if (keyCode == dvt.KeyboardEvent.SPACE && event.ctrlKey) {
        // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
        // care of the selection
        return this;
      }

      var chart = this._chart;
      var chartObjs = chart.getChartObjPeers();

      var navigables = [];
      for (var i = 0; i < chartObjs.length; i++) {
        if (chartObjs[i].isNavigable()) navigables.push(chartObjs[i]);
      }

      var isUpDown =
        event.keyCode == dvt.KeyboardEvent.UP_ARROW || event.keyCode == dvt.KeyboardEvent.DOWN_ARROW;
      var isHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var isRTL = dvt.Agent.isRightToLeft(chart.getCtx());
      // Box plot up/down should go up and down the nested items (left/right for horiz)
      if (
        DvtChartTypeUtils.isScatterBubble(chart) ||
        (DvtChartTypeUtils.isBoxPlot(chart) && ((isUpDown && !isHoriz) || (!isUpDown && isHoriz)))
      ) {
        next = dvt.KeyboardHandler.getNextAdjacentNavigable(this, event, navigables);
      }
      // Polar bars should be treated the same way as line/area charts
      else if (
        DvtChartTypeUtils.isLineArea(chart) ||
        DvtChartDataUtils.isStacked(chart) ||
        DvtChartTypeUtils.isPolar(chart) ||
        DvtChartTypeUtils.isStock(chart)
      ) {
        next = this._findNextNavigable(event);
      } else if (DvtChartTypeUtils.isFunnel(chart) && isUpDown) {
        if (isRTL)
          event.keyCode =
            event.keyCode == dvt.KeyboardEvent.UP_ARROW
              ? dvt.KeyboardEvent.RIGHT_ARROW
              : dvt.KeyboardEvent.LEFT_ARROW;
        else event.keyCode = event.keyCode - 1;
        next = dvt.KeyboardHandler.getNextNavigable(this, event, navigables);
      } else if (DvtChartTypeUtils.isPyramid(chart) && !isUpDown) {
        if (isRTL)
          event.keyCode =
            event.keyCode == dvt.KeyboardEvent.RIGHT_ARROW
              ? dvt.KeyboardEvent.DOWN_ARROW
              : dvt.KeyboardEvent.UP_ARROW;
        else
          event.keyCode =
            event.keyCode == dvt.KeyboardEvent.RIGHT_ARROW
              ? dvt.KeyboardEvent.UP_ARROW
              : dvt.KeyboardEvent.DOWN_ARROW;
        next = dvt.KeyboardHandler.getNextNavigable(this, event, navigables);
      } else {
        // : ignoreBounds for the case of range bars or bars with negative values that don't overlap with the adjacent series.
        next = dvt.KeyboardHandler.getNextNavigable(this, event, navigables, true);
      }
      return next;
    }

    /**
     * @override
     */
    getKeyboardBoundingBox(targetCoordinateSpace) {
      if (this._displayables[0]) return this._displayables[0].getDimensions(targetCoordinateSpace);
      else return new dvt.Rectangle(0, 0, 0, 0);
    }

    /**
     * @override
     */
    getTargetElem() {
      if (this._displayables[0]) return this._displayables[0].getElem();
      return null;
    }

    /**
     * @override
     */
    showKeyboardFocusEffect() {
      if (this.isNavigable()) {
        this._isShowingKeyboardFocusEffect = true;
        this.showHoverEffect();
      }
    }

    /**
     * @override
     */
    hideKeyboardFocusEffect() {
      if (this.isNavigable()) {
        this._isShowingKeyboardFocusEffect = false;
        this.hideHoverEffect();
      }
    }

    /**
     * @override
     */
    isShowingKeyboardFocusEffect() {
      return this._isShowingKeyboardFocusEffect;
    }

    /**
     * Returns true if the object is navigable
     * @return {boolean}
     */
    isNavigable() {
      return this.getGroupIndex() != -1 && this.getSeriesIndex() != -1;
    }

    /**
     * Returns the next navigable object in the direction of the arrow for line/area
     * @param {dvt.BaseEvent} event
     * @return {DvtChartObjPeer}
     * @private
     */
    _findNextNavigable(event) {
      var keyCode = event.keyCode;
      var chart = this._chart;
      var context = chart.getCtx();

      var seriesIndex = this.getSeriesIndex();
      var groupIndex = this.getGroupIndex();
      var groupCount = DvtChartDataUtils.getGroupCount(chart);
      var nextSeriesIndex;
      var nextGroupIndex;

      var isHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var isPolar = DvtChartTypeUtils.isPolar(chart);
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isUp = isHoriz
        ? isRTL
          ? keyCode == dvt.KeyboardEvent.LEFT_ARROW
          : keyCode == dvt.KeyboardEvent.RIGHT_ARROW
        : keyCode == dvt.KeyboardEvent.UP_ARROW;
      var isDown = isHoriz
        ? isRTL
          ? keyCode == dvt.KeyboardEvent.RIGHT_ARROW
          : keyCode == dvt.KeyboardEvent.LEFT_ARROW
        : keyCode == dvt.KeyboardEvent.DOWN_ARROW;
      var isLeft = isHoriz
        ? keyCode == dvt.KeyboardEvent.UP_ARROW
        : isRTL
        ? keyCode == dvt.KeyboardEvent.RIGHT_ARROW
        : keyCode == dvt.KeyboardEvent.LEFT_ARROW;
      var isRight = isHoriz
        ? keyCode == dvt.KeyboardEvent.DOWN_ARROW
        : isRTL
        ? keyCode == dvt.KeyboardEvent.LEFT_ARROW
        : keyCode == dvt.KeyboardEvent.RIGHT_ARROW;

      var isStacked = DvtChartDataUtils.isStacked(chart);
      var isBar = DvtChartTypeUtils.isBar(chart);
      var isStock = DvtChartTypeUtils.isStock(chart);
      var nextObj;
      // if stock chart has items as first series, and volume as second series.
      // use up, down to navigate between them. left, right navigates within these series.
      if (isUp) {
        nextGroupIndex = groupIndex;
        nextSeriesIndex = isStock
          ? Math.max(0, seriesIndex - 1)
          : this._findNextUpSeries(chart, seriesIndex, groupIndex);
      } else if (isDown) {
        nextGroupIndex = groupIndex;
        nextSeriesIndex = isStock
          ? Math.min(DvtChartDataUtils.getSeriesCount(chart) - 1, seriesIndex + 1)
          : this._findNextDownSeries(chart, seriesIndex, groupIndex);
      } else if (isRight || isLeft) {
        nextSeriesIndex = seriesIndex;
        nextGroupIndex = groupIndex;
        do {
          nextGroupIndex = isRight ? nextGroupIndex + 1 : nextGroupIndex - 1;
          if (isPolar && nextGroupIndex >= groupCount) nextGroupIndex = 0;
          if (isPolar && nextGroupIndex < 0) nextGroupIndex = groupCount - 1;
          nextObj = chart.getObject(nextSeriesIndex, nextGroupIndex);
          // if stacked and next group does not have item of same series,
          // shift focus to the item at the bottom of the stack
          if (nextObj == null && isStacked && isBar) {
            var nextSeries = this._findFirstSeriesInGroup(chart, nextGroupIndex);
            nextObj = chart.getObject(nextSeries, nextGroupIndex);
          }
        } while (
          nextObj == null &&
          ((isRight && nextGroupIndex < groupCount) || (isLeft && nextGroupIndex > -1))
        );
      }

      nextObj = nextObj || chart.getObject(nextSeriesIndex, nextGroupIndex);
      return nextObj && nextObj.isNavigable() ? nextObj : this;
    }

    /**
     * Returns the index of the next up series
     * @param {Chart} chart
     * @param {number} seriesIndex Current series index.
     * @param {number} groupIndex Current group index.
     * @return {number} Next up series index.
     * @private
     */
    _findNextUpSeries(chart, seriesIndex, groupIndex) {
      var isStacked = DvtChartDataUtils.isStacked(chart);
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var currentValue = DvtChartDataUtils.getCumulativeValueForNavigation(
        chart,
        seriesIndex,
        groupIndex
      );
      var nextValue = null;
      var nextSeriesIndex = null;
      for (var i = 0; i < seriesCount; i++) {
        if (
          !DvtChartDataUtils.isSeriesRendered(chart, i) ||
          DvtChartDataUtils.getValueForNavigation(chart, i, groupIndex) == null ||
          (isStacked && chart.getObject(i, groupIndex) == null)
        )
          continue;
        var itemValue = DvtChartDataUtils.getCumulativeValueForNavigation(chart, i, groupIndex);
        if (itemValue > currentValue || (itemValue == currentValue && i > seriesIndex)) {
          if ((nextValue !== null && itemValue < nextValue) || nextValue == null) {
            nextValue = itemValue;
            nextSeriesIndex = i;
          }
        }
      }
      return nextSeriesIndex;
    }

    /**
     * Returns the index of the next down series.
     * @param {Chart} chart
     * @param {number} seriesIndex Current series index.
     * @param {number} groupIndex Current group index.
     * @return {number} Next down series index.
     * @private
     */
    _findNextDownSeries(chart, seriesIndex, groupIndex) {
      var isStacked = DvtChartDataUtils.isStacked(chart);
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var currentValue = DvtChartDataUtils.getCumulativeValueForNavigation(
        chart,
        seriesIndex,
        groupIndex
      );
      var nextValue = null;
      var nextSeriesIndex = null;

      for (var i = seriesCount - 1; i >= 0; i--) {
        if (
          !DvtChartDataUtils.isSeriesRendered(chart, i) ||
          DvtChartDataUtils.getValueForNavigation(chart, i, groupIndex) == null ||
          (isStacked && chart.getObject(i, groupIndex) == null)
        )
          continue;
        var itemValue = DvtChartDataUtils.getCumulativeValueForNavigation(chart, i, groupIndex);
        if (itemValue < currentValue || (itemValue == currentValue && i < seriesIndex)) {
          if ((nextValue !== null && itemValue > nextValue) || nextValue == null) {
            nextValue = itemValue;
            nextSeriesIndex = i;
          }
        }
      }
      return nextSeriesIndex;
    }

    /**
     * Returns the index of the first series in the given group. This will be the item at the
     * bottom of the stack when chart is stacked.
     * @param {Chart} chart
     * @param {number} groupIndex The group index of the group.
     * @returns
     */
    _findFirstSeriesInGroup(chart, groupIndex) {
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var idx = 0; idx < seriesCount; idx++) {
        if (
          DvtChartDataUtils.isSeriesRendered(chart, idx) &&
          DvtChartDataUtils.getVal(chart, idx, groupIndex) != null &&
          chart.getObject(idx, groupIndex) != null
        )
          return idx;
      }
      return null;
    }

    //---------------------------------------------------------------------//
    // DnD Support: DvtDraggable impl                                      //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    isDragAvailable(clientIds) {
      return true;
    }

    /**
     * @override
     */
    getDragTransferable() {
      return [this.getId()];
    }

    /**
     * @override
     */
    getDragFeedback() {
      // If more than one object is selected, return the displayables of all selected objects
      if (
        this._chart.isSelectionSupported() &&
        this._chart.getSelectionHandler().getSelectedCount() > 1
      ) {
        var selection = this._chart.getSelectionHandler().getSelection();
        var displayables = [];
        for (var i = 0; i < selection.length; i++) {
          displayables = displayables.concat(selection[i].getDisplayables());
        }
        return displayables;
      }

      // Otherwise, return its own displayables
      return this._displayables;
    }
  }

  /**
   * Logical object for reference object displayables.
   * @param {Chart} chart
   * @param {array} displayables The array of associated DvtDisplayables.
   * @param {object} refObj reference object
   * @param {number} index The reference objects position in the reference object array
   * @param {string} axisType The axis the reference object is on
   * @class
   * @constructor
   * @implements {DvtCategoricalObject}
   * @implements {DvtLogicalObject}
   * @implements {DvtTooltipSource}
   */
  class DvtChartRefObjPeer {
    constructor(chart, displayables, refObj, index, axisType) {
      this._chart = chart;
      this._displayables = displayables;
      this._refObj = refObj;
      this._categories = DvtChartRefObjUtils.getRefObjCategories(this._refObj);

      // used for automation
      this._index = index;
      this._axisType = axisType;

      // WAI-ARIA
      for (var i = 0; i < displayables.length; i++) {
        var displayable = displayables[i];
        displayable.setAriaRole('img');
        displayable.setAriaProperty('label', refObj['shortDesc']);
      }
    }

    /**
     * @override
     */
    getCategories() {
      return this._categories;
    }

    /**
     * @override
     */
    getDisplayables() {
      return this._displayables;
    }

    /**
     * Returns the position of the reference object in the referenceObjects array.
     * @return {number} The position of this reference object.
     */
    getIndex() {
      return this._index;
    }

    /**
     * Returns which axis this reference object belongs to.
     * @return {string} xAxis, yAxis, or y2Axis
     */
    getAxisType() {
      return this._axisType;
    }

    /**
     * @override
     */
    getDatatip() {
      return DvtChartTooltipUtils.getRefObjTooltip(
        this._chart,
        this._refObj,
        this._axisType,
        this._index
      );
    }

    /**
     * @override
     */
    getDatatipColor() {
      return DvtChartRefObjUtils.getColor(this._chart, this._refObj);
    }
  }

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {dvt.BaseComponentDefaults}
   */

  class DvtAxisDefaults extends dvt.BaseComponentDefaults {
    constructor(context) {
      /**
       * Defaults for version 1.
       */
      const SKIN_ALTA = {
        position: null,
        baselineScaling: 'zero',
        axisLine: { lineColor: '#9E9E9E', lineWidth: 1, rendered: 'on' },
        majorTick: {
          lineColor: 'rgba(196,206,215,0.4)',
          baselineColor: 'auto',
          lineWidth: 1,
          rendered: 'auto',
          lineStyle: 'solid'
        },
        minorTick: {
          lineColor: 'rgba(196,206,215,0.2)',
          lineWidth: 1,
          rendered: 'off',
          lineStyle: 'solid'
        },
        tickLabel: {
          scaling: 'auto',
          style: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_11 + 'color: #333333;'),
          rotation: 'auto',
          rendered: 'on'
        },
        titleStyle: new dvt.CSSStyle(
          dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_12 + 'color: #737373;'
        ),

        // For group axis, an optional offset expressed as a factor of the group size.
        startGroupOffset: 0,
        endGroupOffset: 0,

        //* ********** Internal Attributes *************************************************//
        layout: {
          titleGap: 6,
          radialLabelGap: 5,
          insideLabelGapWidth: 4,
          insideLabelGapHeight: 2,
          hierarchicalLabelGapHeight: 8,
          hierarchicalLabelGapWidth: 15
        },
        _locale: 'en-us'
      };
      super({ alta: SKIN_ALTA }, context);
    }

    /**
     * @override
     */
    getNoCloneObject() {
      return {
        tickLabel: { converter: true }
      };
    }

    /**
     * Adjusts the gap size based on the component options.
     * @param {dvt.Context} context The axis component context.
     * @param {Object} options The axis options.
     * @param {Number} defaultSize The default gap size.
     * @return {Number}
     */
    static getGapSize(context, options, defaultSize) {
      // adjust based on tick label font size
      var scalingFactor = Math.min(
        dvt.TextUtils.getTextStringHeight(context, options.tickLabel.style) / 14,
        1
      );
      return Math.ceil(defaultSize * scalingFactor);
    }
  }

  /**
   * Calculated axis information and drawable creation.  This class should
   * not be instantiated directly.
   * @param {dvt.Context} context
   * @param {object} options The object containing specifications and data for this component.
   * @param {dvt.Rectangle} availSpace The available space.
   * @class
   * @constructor
   * @extends {dvt.Obj}
   */

  class DvtAxisInfo extends ojdvtAxis.BaseAxisInfo {
    constructor(context, options, availSpace) {
      super(context, options, availSpace);
      this._title = null;
    }
    /**
     * Returns an array containing the tick labels for this axis.
     * @param {dvt.Context} context
     * @param {Number} levelIdx The level index (optional). 0 indicates the first level, 1 the second, etc. If skipped, 0 (the first level) is assumed.
     * @return {Array} The Array of dvt.Text objects.
     */
    getLabels(context, levelIdx) {
      return null; // subclasses should override
    }

    /**
     * Returns the title for this axis.
     * @return {dvt.Text} The dvt.Text object, if it exists.
     */
    getTitle() {
      return this._title;
    }

    /**
     * Sets the title for this axis.
     * @param {dvt.Text} title The axis title.
     */
    setTitle(title) {
      this._title = title;
    }

    /**
     * Returns the coordinates of the major ticks.
     * @return {array} Array of coords.
     */
    getMajorTickCoords() {
      return []; // subclasses should override
    }

    /**
     * Returns the coordinates of the minor ticks.
     * @return {array} Array of coords.
     */
    getMinorTickCoords() {
      return []; // subclasses should override
    }

    /**
     * Returns the coordinates of the baseline (value = 0). Only applies to numerical axis.
     * @return {number} Baseline coord.
     */
    getBaselineCoord() {
      return null; // subclasses should override
    }

    /**
     * Returns the datatip for the label at the given index and level.
     * @param {number} index
     * @param {number} level
     * @return {string} The datatip.
     */
    getDatatip(index, level) {
      return null; // subclasses should override
    }

    /**
     * Returns an object with the label's background labelStyles applied
     * @param {dvt.OutputText} label The label.
     * @param {dvt.Context} context
     * @return {dvt.Rect} The object to be rendered behind the label.
     */
    getLabelBackground(label, context) {
      return null; // subclasses should override
    }

    /**
     * Returns whether the label at the given index is drillable
     * @param {number} index The label index.
     * @return {boolean} Whether the label is drillable.
     */
    isDrillable(index) {
      return null; // subclasses should override
    }

    /**
     * Returns if the labels of the horizontal axis are rotated by 90 degrees.
     * @return {boolean} Whether the labels are rotated.
     */
    isLabelRotated() {
      return false;
    }

    /**
     * Creates a dvt.Text instance for the specified text label.
     * @param {dvt.Context} context
     * @param {string} label The label string.
     * @param {number} coord The coordinate for the text.
     * @param {dvt.CSSStyle=} style Optional style for the text label.
     * @param {boolean=} bMultiline Optional boolean to create dvt.MultilineText
     * @return {dvt.OutputText|dvt.BackgroundOutputText|dvt.MultilineText}
     * @protected
     */
    CreateLabel(context, label, coord, style, bMultiline) {
      var text;

      if (this.Position == 'tangential') {
        var vTol = (16 / 180) * Math.PI; // the mid area (15 degrees) where labels will be middle aligned.
        var hTol = (1 / 180) * Math.PI; // the tolerance (1 degree) where labels will be center aligned.

        var offset = 0.5 * this.getTickLabelHeight();
        var dist = this._radius + offset;
        if (coord < hTol || coord > 2 * Math.PI - hTol) dist += offset; // avoild collision with radial label

        var xcoord = Math.round(dist * Math.sin(coord));
        var ycoord = Math.round(-dist * Math.cos(coord));
        text = style
          ? new dvt.BackgroundOutputText(context, label, xcoord, ycoord, style)
          : new dvt.OutputText(context, label, xcoord, ycoord);

        // Align the label according to the angular position
        if (coord < hTol || Math.abs(coord - Math.PI) < hTol || coord > 2 * Math.PI - hTol)
          text.alignCenter();
        else if (coord < Math.PI) text.alignLeft();
        else text.alignRight();

        if (Math.abs(coord - Math.PI / 2) < vTol || Math.abs(coord - (3 * Math.PI) / 2) < vTol)
          text.alignMiddle();
        else if (coord < Math.PI / 2 || coord > (3 * Math.PI) / 2) text.alignBottom();
        else text.alignTop();
      } else {
        if (bMultiline)
          text = style
            ? new dvt.BackgroundMultilineText(context, label, coord, coord, style)
            : new dvt.MultilineText(context, label, coord, coord);
        else {
          text = style
            ? new dvt.BackgroundOutputText(context, label, coord, coord, style)
            : new dvt.OutputText(context, label, coord, coord);
          text.alignMiddle();
        }
        text.alignCenter();
      }
      if (text instanceof dvt.OutputText || text instanceof dvt.MultilineText)
        // DvtBackgroundTexts already created with its CSSStyle
        text.setCSSStyle(this.Options['tickLabel']['style']);
      return text;
    }

    /**
     * Checks all the labels for the axis and returns whether they overlap.
     * @param {Array} labelDims An array of dvt.Rectangle objects that describe the x, y, height, width of the axis labels.
     * @param {number} skippedLabels The number of labels to skip. If skippedLabels is 1 then every other label will be skipped.
     * @param {Array=} maxWidths An array of max sizes for for each label.
     * @return {boolean} True if any labels overlap or are greater than their corresponding max width.
     * @protected
     */
    IsOverlapping(labelDims, skippedLabels, maxWidths) {
      // If there are no labels, return
      if (!labelDims || labelDims.length <= 0) return false;

      var isVert = this.Position == 'left' || this.Position == 'right' || this.Position == 'radial';
      var isRTL = dvt.Agent.isRightToLeft(this.getCtx());
      var gap = this.GetTickLabelGapSize();

      var pointA1, pointA2, pointB1, pointB2;
      for (var j = 0; j < labelDims.length; j += skippedLabels + 1) {
        if (labelDims[j] == null) continue;

        if (maxWidths != null && labelDims[j].w > maxWidths[j]) return true;

        if (pointA1 == null || pointA2 == null) {
          // Set the first points
          if (isVert) {
            pointA1 = labelDims[j].y;
            pointA2 = labelDims[j].y + labelDims[j].h;
          } else {
            pointA1 = labelDims[j].x;
            pointA2 = labelDims[j].x + labelDims[j].w;
          }
          continue;
        }

        if (isVert) {
          pointB1 = labelDims[j].y;
          pointB2 = labelDims[j].y + labelDims[j].h;

          // Broken apart for clarity, next label may be above or below
          if (pointB1 >= pointA1 && pointB1 - gap < pointA2)
            // next label below
            return true;
          else if (pointB1 < pointA1 && pointB2 + gap > pointA1)
            // next label above
            return true;
        } else {
          pointB1 = labelDims[j].x;
          pointB2 = labelDims[j].x + labelDims[j].w;

          // Broken apart for clarity, next label is on the right for non-BIDI, left for BIDI
          if (!isRTL && pointB1 - gap < pointA2) return true;
          else if (isRTL && pointB2 + gap > pointA1) return true;
        }

        // Otherwise start evaluating from label j
        pointA1 = pointB1;
        pointA2 = pointB2;
      }
      return false;
    }

    /**
     * Compares two label dimensions and returns whether they overlap.
     * @param {Object} labelDims1 An object that describes the x, y, height, width of the first label.
     * @param {Object} labelDims2 An object that describes the x, y, height, width of the second label.
     * @return {boolean} True if the label dimensions overlap.
     * @protected
     */
    IsOverlappingDims(labelDims1, labelDims2) {
      if (!labelDims1 || !labelDims2) return false;

      var pointA1 = labelDims1.y;
      var pointA2 = labelDims1.y + labelDims1.h;
      var pointA3 = labelDims1.x;
      var pointA4 = labelDims1.x + labelDims1.w;

      var pointB1 = labelDims2.y;
      var pointB2 = labelDims2.y + labelDims2.h;
      var pointB3 = labelDims2.x;
      var pointB4 = labelDims2.x + labelDims2.w;

      var widthOverlap =
        (pointA3 <= pointB3 && pointB3 <= pointA4) ||
        (pointA3 <= pointB4 && pointB4 <= pointA4) ||
        (pointB3 <= pointA3 && pointA3 <= pointB4) ||
        (pointB3 <= pointA4 && pointA4 <= pointB4);
      var heightOverlap =
        (pointB1 >= pointA1 && pointB1 < pointA2) || (pointB1 <= pointA1 && pointB2 >= pointA1);

      return widthOverlap && heightOverlap;
    }

    /**
     * Returns the tick label gap size.
     * @return {number}
     * @protected
     */
    GetTickLabelGapSize() {
      // Create gap based on tick label height
      // GroupAxis and TimeAxis have smaller gaps since these axes become less useable as more labels are dropped
      var labelHeight = this.getTickLabelHeight();
      var gapHoriz =
        this instanceof DvtAxisInfo._constructors.group ? labelHeight * 0.24 : labelHeight * 0.79;
      var gapVert =
        this instanceof DvtAxisInfo._constructors.group ? labelHeight * 0.08 : labelHeight * 0.28;

      var isVert = this.Position == 'left' || this.Position == 'right' || this.Position == 'radial';
      return isVert || this.isLabelRotated() ? gapVert : gapHoriz;
    }

    /**
     * Returns the tick label height in px.
     * @return {number}
     */
    getTickLabelHeight() {
      return dvt.TextUtils.getTextStringHeight(this.getCtx(), this.Options['tickLabel']['style']);
    }

    /**
     * Checks the labels for the axis and skips them as necessary.
     * @param {Array} labels An array of dvt.Text labels for the axis.
     * @param {Array} labelDims An array of dvt.Rectangle objects that describe the x, y, height, width of the axis labels.
     * @return {Array} The array of dvt.Text labels for the axis.
     * @protected
     */
    SkipLabels(labels, labelDims) {
      var skippedLabels = 0;
      var bOverlaps = this.IsOverlapping(labelDims, skippedLabels);
      while (bOverlaps) {
        skippedLabels++;
        bOverlaps = this.IsOverlapping(labelDims, skippedLabels);
      }

      if (skippedLabels > 0) {
        var renderedLabels = [];
        for (var j = 0; j < labels.length; j += skippedLabels + 1) {
          renderedLabels.push(labels[j]);
        }
        return renderedLabels;
      } else {
        return labels;
      }
    }

    /**
     * Checks the labels for the tangential axis and skips them as necessary.
     * @param {Array} labels An array of dvt.Text labels for the axis.
     * @param {Array} labelDims An array of dvt.Rectangle objects that describe the x, y, height, width of the axis labels.
     * @return {Array} The array of dvt.Text labels for the tangential axis.
     * @protected
     */
    SkipTangentialLabels(labels, labelDims) {
      var renderedLabels = [];
      var numLabels = labels.length;
      var firstLabelDims = null;

      if (numLabels > 1) {
        var prevLabelDims;
        // Include label if it does not overlap with previously included label
        for (var j = 0; j < numLabels; j++) {
          if (!labelDims[j]) continue;
          if (
            !prevLabelDims ||
            (prevLabelDims && !this.IsOverlappingDims(prevLabelDims, labelDims[j]))
          ) {
            if (!firstLabelDims) firstLabelDims = labelDims[j];
            renderedLabels.push(labels[j]);
            prevLabelDims = labelDims[j];
          }
        }

        // Remove last included label if it overlaps with the first included label
        if (this.IsOverlappingDims(prevLabelDims, firstLabelDims)) renderedLabels.pop();

        return renderedLabels;
      }
      return labels;
    }

    /**
     * Returns an array of dvt.Rectangle objects that describe the x, y, width, height of the axis labels.
     * If level is set, it assumes that the labels are center-middle aligned.
     * @param {Array} labels An array of dvt.Text labels for the axis.
     * @param {dvt.Container} container
     * @param {Number} level (optional) Used for group axis hierarchical labels
     * @return {Array} An array of dvt.Rectangle objects
     * @protected
     */
    GetLabelDims(labels, container, level) {
      var labelDims = [];
      var isRotated = this.isLabelRotated(level);

      // Get the text dimensions
      for (var i = 0; i < labels.length; i++) {
        var text = labels[i];
        if (text == null) {
          labelDims.push(null);
          continue;
        }

        var dims = text.getDimensions(container);
        if (level != null) {
          dims.x = (isRotated ? text.getTranslateX() : text.getX()) - dims.w / 2;
          dims.y = (isRotated ? text.getTranslateY() : text.getY()) - dims.h / 2;
        }

        if (dims.w && dims.h)
          // Empty group axis labels with 0 height and width are possible, they should count as null
          labelDims.push(dims);
        else labelDims.push(null);
      }

      return labelDims;
    }

    /**
     * Returns the number of major tick counts for the axis.
     * @return {number} The number of major tick counts.
     */
    getMajorTickCount() {
      return null; // subclasses that allow major gridlines should implement
    }

    /**
     * Returns the number of minor tick counts for the axis.
     * @return {number} The number of minor tick counts.
     */
    getMinorTickCount() {
      return null; // subclasses that allow minor gridlines should implement
    }

    /**
     * Returns the major increment for the axis.
     * @return {number} The major increment.
     */
    getMajorIncrement() {
      return null; // subclasses that allow major gridlines should implement
    }

    /**
     * Returns the minor increment for the axis.
     * @return {number} The minor increment.
     */
    getMinorIncrement() {
      return null; // subclasses that allow minor gridlines should implement
    }

    /**
     * Returns the global min value of the axis.
     * @return {number} The global min value.
     */
    getGlobalMin() {
      return this.GlobalMin;
    }

    /**
     * Returns the global max value of the axis.
     * @return {number} The global max value.
     */
    getGlobalMax() {
      return this.GlobalMax;
    }

    /**
     * Returns the viewport min value of the axis.
     * @return {number} The viewport min value.
     */
    getViewportMin() {
      return this.MinValue;
    }

    /**
     * Returns the viewport max value of the axis.
     * @return {number} The viewport max value.
     */
    getViewportMax() {
      return this.MaxValue;
    }

    /**
     * Returns the data min value of the axis.
     * @return {number} The data min value.
     */
    getDataMin() {
      return this.DataMin;
    }

    /**
     * Returns the data max value of the axis.
     * @return {number} The data max value.
     */
    getDataMax() {
      return this.DataMax;
    }

    /**
     * Returns the minimum extent of the axis, i.e. the (maxLinearValue - minLinearValue) during maximum zoom.
     * @return {number} The minimum extent.
     */
    getMinExtent() {
      return 0;
    }

    /**
     * Returns the start coord.
     * @return {number}
     */
    getStartCoord() {
      return this.StartCoord;
    }

    /**
     * Returns the end coord.
     * @return {number}
     */
    getEndCoord() {
      return this.EndCoord;
    }

    /**
     * Returns how much the axis labels overflow over the start coord.
     * @return {number}
     */
    getStartOverflow() {
      return this.StartOverflow;
    }

    /**
     * Returns how much the axis labels overflow over the end coord.
     * @return {number}
     */
    getEndOverflow() {
      return this.EndOverflow;
    }

    /**
     * Gets the width of a group (for rendering bar chart)
     * @return {Number} the width of a group
     */
    getGroupWidth() {
      return 0;
    }

    /**
     * Returns a string or an array of groups names/ids of the ancestors of a group label at the given index and level.
     * @param {Number} index The index of the group label within it's level of labels
     * @param {Number=} level The level of the group labels
     * @return {String|Array} The group name/id, or an array of group names/ids.
     * @override
     */
    getGroup(index, level) {
      // only applies to group axis
      return null;
    }

    /**
     * Converts linear value to actual value.
     * For example, for a log scale, the linear value is the log of the actual value.
     * @param {number} value The linear value.
     * @return {number} The actual value.
     */
    linearToActual(value) {
      return value;
    }

    /**
     * Converts actual value to linear value.
     * For example, for a log scale, the linear value is the log of the actual value.
     * @param {number} value The actual value.
     * @return {number} The linear value.
     */
    actualToLinear(value) {
      return value;
    }

    /**
     * Increases the scale unit used until the data for the axis can be fit within a given number of majorTicks
     * Used exclusively to align y and y2 log axes when the yAxis majorTickCount is less than what the y2Axis needs.
     * @param {number} scaleUnit The current scale unit of the axis.
     * @param {number} tickCount The number of major ticks the axis will use.
     * @return {number} The new scale unit that wil allow the axis data to render within the given tickCount number.
     */
    alignLogScaleToTickCount(scaleUnit, tickCount) {
      return scaleUnit;
    }

    /**
     * Returns the scale unit, if one has been previously stored. Will only apply to log axes.
     * @return {number} The scale unit
     */
    getLogScaleUnit() {
      return null;
    }

    /**
     * Used by DvtDataAxisInfo, DvtGroupAxisInfo, DvtTimeAxisInto to pass constructors without created a circular dependency
     *
     * @param {'data'|'group'|'time'} type
     * @param {function} ctor
     */
    static registerConstructor(type, ctor) {
      DvtAxisInfo._constructors[type] = ctor;
    }

    static getConstructor(type) {
      return DvtAxisInfo._constructors[type];
    }

    /**
     * Creates an appropriate instance of DvtAxisInfo with the specified parameters.
     * @param {dvt.Context} context
     * @param {object} options The object containing specifications and data for this component.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {DvtAxisInfo}
     */
    static newInstance(context, options, availSpace) {
      if (options['timeAxisType'] && options['timeAxisType'] != 'disabled')
        return new DvtAxisInfo._constructors.time(context, options, availSpace);
      else if (options['_isGroupAxis'])
        return new DvtAxisInfo._constructors.group(context, options, availSpace);
      return new DvtAxisInfo._constructors.data(context, options, availSpace);
    }
  }

  DvtAxisInfo._constructors = [];

  /**
   * Simple logical object for tooltip support.
   * @param {DvtAxis} axis The axis.
   * @param {dvt.OutputText} label The owning text instance.
   * @param {string|Array} group A string or an array of groups names/ids of the label and the ancestors.
   * @param {object} drillable Whether the label is drillable.
   * @param {string} tooltip The tooltip of the label.
   * @param {string} datatip The datatip of the label.
   * @param {object=} params Optional object containing additional parameters for use by component.
   * @class DvtAxisObjPeer
   * @constructor
   * @implements {dvt.TextObjPeer}
   * @implements {DvtLogicalObject}
   * @implements {DvtDraggable}
   */

  class DvtAxisObjPeer extends dvt.TextObjPeer {
    /**
     * @param {DvtAxis} axis The axis.
     * @param {dvt.OutputText} label The owning text instance.
     * @param {string|Array} group A string or an array of groups names/ids of the label and the ancestors.
     * @param {object} drillable Whether the label is drillable.
     * @param {string} tooltip The tooltip of the label.
     * @param {string} datatip The datatip of the label.
     * @param {object=} params Optional object containing additional parameters for use by component.
     */
    constructor(axis, label, group, drillable, tooltip, datatip, params) {
      super(axis, label, tooltip, datatip, null, params);
      this._axis = axis;
      this._label = label;
      this._group = group;
      this._drillable = drillable;

      // Apply the cursor for drilling if specified
      if (this._drillable) label.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());

      axis.__registerObject(this);
    }

    /**
     * Returns the label for this object.
     * @return {dvt.OutputText}
     */
    getLabel() {
      return this._label;
    }

    /**
     * Returns the id for this object.
     * @return {object} The id for this label.
     */
    getId() {
      return this._group;
    }

    /**
     * Returns whether the label is drillable.
     * @return {boolean}
     */
    isDrillable() {
      return this._drillable;
    }

    /**
     * Returns the group.
     * @return {string|Array}
     */
    getGroup() {
      return this._group;
    }

    //---------------------------------------------------------------------//
    // Keyboard Support: DvtKeyboardNavigable impl                         //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getNextNavigable(event) {
      // TODO: Figure out if this is necessary
      if (event.type == dvt.MouseEvent.CLICK) return this;

      var navigables = this._axis.__getKeyboardObjects();
      return dvt.KeyboardHandler.getNextNavigable(
        this,
        event,
        navigables,
        false,
        this._axis.getCtx().getStage()
      );
    }

    //---------------------------------------------------------------------//
    // WAI-ARIA Support: DvtLogicalObject impl               //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getAriaLabel() {
      var states;
      if (this.isDrillable()) {
        states = [this._axis.getOptions().translations.stateDrillable];
      }
      if (this.getDatatip() != null) {
        return dvt.Displayable.generateAriaLabel(this.getDatatip(), states);
      } else if (states != null) {
        return dvt.Displayable.generateAriaLabel(this.getLabel().getTextString(), states);
      }
    }

    //---------------------------------------------------------------------//
    // DnD Support: DvtDraggable impl                                      //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    isDragAvailable(clientIds) {
      return true;
    }

    /**
     * @override
     */
    getDragTransferable(mouseX, mouseY) {
      return [this.getId()];
    }

    /**
     * @override
     */
    getDragFeedback(mouseX, mouseY) {
      return [this.getDisplayable()];
    }
  }

  /**
   * Event Manager for DvtAxis.
   * @param {DvtAxis} axis
   * @class
   * @extends {dvt.EventManager}
   * @constructor
   */

  class DvtAxisEventManager extends dvt.EventManager {
    constructor(axis) {
      super(axis.getCtx(), axis.processEvent, axis, axis);
      this._axis = axis;
    }

    /**
     * @override
     */
    OnClick(event) {
      super.OnClick(event);

      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;

      var action = this.processDrillEvent(obj);

      // If an action occurs, the event should not bubble.
      if (action) event.stopPropagation();
    }

    /**
     * @override
     */
    HandleTouchClickInternal(evt) {
      var obj = this.GetLogicalObject(evt.target);
      if (!obj) return;

      var touchEvent = evt.touchEvent;
      var action = this.processDrillEvent(obj);
      if (action && touchEvent) touchEvent.preventDefault();
    }

    /**
     * Processes a drill on the specified group label.  Returns true if a drill event is fired.
     * @param {DvtGroupAxisObjPeer} obj The group label that was clicked.
     * @return {boolean} True if an event was fired.
     */
    processDrillEvent(obj) {
      // Drill Support
      if (obj instanceof DvtAxisObjPeer && obj.isDrillable()) {
        this.FireEvent(
          dvt.EventFactory.newChartDrillEvent(obj.getId(), null, obj.getGroup(), 'group'),
          this._axis
        );
        return true;
      }

      return false;
    }

    /**
     * @override
     */
    isDndSupported() {
      return true;
    }

    /**
     * @override
     */
    GetDragSourceType() {
      var obj = this.DragSource.getDragObject();
      if (obj instanceof DvtAxisObjPeer && obj.getGroup() != null) return 'groups';
      return null;
    }

    /**
     * @override
     */
    GetDragDataContexts(bSanitize) {
      var obj = this.DragSource.getDragObject();
      if (obj instanceof DvtAxisObjPeer) {
        var dataContext = {
          id: obj.getId(),
          group: obj.getGroup(),
          label: obj.getLabel().getTextString()
        };
        if (bSanitize) dvt.ToolkitUtils.cleanDragDataContext(dataContext);

        return [dataContext];
      }
      return [];
    }

    /**
     * Returns the parameters for the DvtComponentUIEvent for an object with the specified arguments.
     * @param {string} type The type of object that was the target of the event.
     * @param {object=} id The id of the object, if one exists.
     * @param {number=} index The index of the axis label, in regards to its level, if one is specified.
     * @param {number=} level The level of the axis label, if one is specified.
     * @return {object} the parameters for the DvtComponentUIEvent
     */
    static getUIParams(type, id, index, level) {
      return { type, id, index, level };
    }
  }

  /**
   * Renderer for DvtAxis.
   */
  const DvtAxisRenderer = {
    /**
     * Fraction of width or height used to calculate initial preferred size for title width / height for axes.
     * @private
     */
    _PREFERRED_TITLE_PROPORTION: 0.8,

    /**
     * The max amount of lines we allow in title wrapping.
     * @private
     */
    _MAX_TITLE_LINE_WRAP: 3,
    /**
     * Returns the preferred dimensions for this component given the maximum available space. This will never be called for
     * radial axis.
     * @param {DvtAxis} axis
     * @param {number} availWidth
     * @param {number} availHeight
     * @return {dvt.Dimension} The preferred dimensions for the object.
     */
    getPreferredSize: (axis, availWidth, availHeight, ignoreRenderedOption) => {
      // Calculate the axis extents and increments
      var axisInfo = DvtAxisRenderer._createAxisInfo(
        axis,
        new dvt.Rectangle(0, 0, availWidth, availHeight)
      );
      var context = axis.getCtx();
      var options = axis.getOptions();

      // The axis will always return the full length of the dimension along which values are placed, so there's only one
      // size that we need to keep track of.  For example, this is the height on horizontal axes.
      var bHoriz = options['position'] == 'top' || options['position'] == 'bottom';

      // No size if not rendered or either dimension is 0. Since dimensions can also be 0 for rendered==off, either checks are ignored for the ignoreRenderedOption flag
      if (
        (options['rendered'] == 'off' || availWidth <= 0 || availHeight <= 0) &&
        !ignoreRenderedOption
      )
        return bHoriz ? new dvt.Dimension(availWidth, 0) : new dvt.Dimension(0, availHeight);

      // Allocate space for the title
      var availableTitleWidth =
        (bHoriz ? availWidth : availHeight) * DvtAxisRenderer._PREFERRED_TITLE_PROPORTION;
      var availableTitleHeight =
        (bHoriz ? availHeight : availWidth) * DvtAxisRenderer._PREFERRED_TITLE_PROPORTION;
      var titleHeightInfo = DvtAxisRenderer.getTitleHeight(
        context,
        options,
        availableTitleWidth,
        availableTitleHeight
      );
      var titleHeight = titleHeightInfo.height;

      // cache preferred title line count and available space used
      axis.getOptionsCache().putToCache('prefTitleLineCount', titleHeightInfo.lineCount);
      axis.getOptionsCache().putToCache('prefAvailableTitleWidth', availableTitleWidth);

      var size = titleHeight != 0 ? titleHeight + DvtAxisRenderer._getTitleGap(axis) : 0;

      // Allocate space for the tick labels
      if (options['tickLabel']['rendered'] == 'on' && options['tickLabel']['position'] != 'inside') {
        if (bHoriz) {
          // Horizontal Axis
          var labelHeight = dvt.TextUtils.getTextStringHeight(context, options['tickLabel']['style']);
          if (axisInfo instanceof DvtAxisInfo.getConstructor('data')) size += labelHeight;
          else if (axisInfo instanceof DvtAxisInfo.getConstructor('time'))
            size += axisInfo.getLabels(context, 1) != null ? labelHeight * 2 : labelHeight;
          else if (axisInfo instanceof DvtAxisInfo.getConstructor('group'))
            size = DvtAxisRenderer._getGroupAxisPreferredSize(
              axis,
              axisInfo,
              size,
              availHeight,
              bHoriz
            );
        } else {
          // Vertical Axis
          if (axisInfo instanceof DvtAxisInfo.getConstructor('data'))
            size += dvt.TextUtils.getMaxTextStringWidth(
              context,
              axisInfo.getAllLabels(context, true),
              axisInfo.Options['tickLabel']['style']
            );
          else if (axisInfo instanceof DvtAxisInfo.getConstructor('time')) {
            var innerLabels = axisInfo.getLabels(context);
            var innerLabelWidth = dvt.TextUtils.getMaxTextDimensions(innerLabels).w;
            var outerLabels = axisInfo.getLabels(context, 1);
            var outerLabelWidth =
              outerLabels != null ? dvt.TextUtils.getMaxTextDimensions(outerLabels).w : 0;
            size += Math.max(innerLabelWidth, outerLabelWidth);
          } else if (axisInfo instanceof DvtAxisInfo.getConstructor('group'))
            size = DvtAxisRenderer._getGroupAxisPreferredSize(
              axis,
              axisInfo,
              size,
              availWidth,
              bHoriz
            );
        }
      }

      if (bHoriz) return new dvt.Dimension(availWidth, Math.min(size, availHeight));
      return new dvt.Dimension(Math.min(size, availWidth), availHeight);
    },

    /**
     * Renders the axis and updates the available space.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (axis, availSpace) => {
      // Calculate the axis extents and increments
      var axisInfo = DvtAxisRenderer._createAxisInfo(axis, availSpace);
      var options = axis.getOptions();

      if (options['rendered'] == 'off') return;

      axis.__setBounds(availSpace.clone());

      DvtAxisRenderer._renderBackground(axis, availSpace);

      // Render the title
      DvtAxisRenderer._renderTitle(axis, axisInfo, availSpace);

      // Render the tick labels
      DvtAxisRenderer._renderLabels(axis, axisInfo, availSpace);
    },

    /**
     * Creates and returns the DvtAxisInfo for the specified axis.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {DvtAxisInfo}
     * @private
     */
    _createAxisInfo: (axis, availSpace) => {
      var axisInfo = DvtAxisInfo.newInstance(axis.getCtx(), axis.getOptions(), availSpace);
      axis.__setInfo(axisInfo);
      return axisInfo;
    },

    /**
     * Returns the gap between the title and the tick labels.
     * @param {DvtAxis} axis
     * @return {number}
     * @private
     */
    _getTitleGap: (axis) => {
      var options = axis.getOptions();
      return DvtAxisDefaults.getGapSize(axis.getCtx(), options, options['layout']['titleGap']);
    },

    /**
     * Renders the axis invisble background. Needed for DnD drop effect.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderBackground: (axis, availSpace) => {
      var options = axis.getOptions();
      if (!options['dnd']) return;

      var dropOptions = options['dnd']['drop'];
      var isDropTarget =
        Object.keys(dropOptions['xAxis']).length > 0 ||
        Object.keys(dropOptions['yAxis']).length > 0 ||
        Object.keys(dropOptions['y2Axis']).length > 0;
      var dragOptions = options['dnd']['drag'];
      var isDraggable =
        Object.keys(dragOptions['groups']).length > 0 &&
        axis.getInfo() instanceof DvtAxisInfo.getConstructor('group');

      if (isDropTarget || isDraggable) {
        var position = options['position'];
        var isHoriz = position == 'top' || position == 'bottom';
        var yGap = isHoriz ? 4 : 10;
        var xGap = isHoriz ? 10 : 4;
        var background = new dvt.Rect(
          axis.getCtx(),
          availSpace.x - xGap,
          availSpace.y - yGap,
          availSpace.w + 2 * xGap,
          availSpace.h + 2 * yGap
        );

        if (isDraggable) background.setClassName('oj-draggable');

        background.setInvisibleFill();
        axis.getCache().putToCache('background', background);
        axis.addChild(background);
      }
    },

    /**
     * Renders the axis title and updates the available space.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {DvtAxisInfo} axisInfo The axis model.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderTitle: (axis, axisInfo, availSpace) => {
      // Note: DvtAxisRenderer.getPreferredSize must be updated for any layout changes to this function.
      var options = axis.getOptions();
      if (!options['title']) return;

      // Create the title object and add to axis
      var position = options['position'];

      if (position === 'radial' || position === 'tangential') return; // polar chart doesn't have axis titles

      var bHoriz = options['position'] === 'top' || options['position'] === 'bottom';
      var maxLabelWidth = bHoriz ? availSpace.w : availSpace.h;
      var maxLabelHeight = bHoriz ? availSpace.h : availSpace.w;
      var titleStyle = options['titleStyle'];
      var isMultiLine = DvtAxisRenderer.isWrapEnabled(titleStyle);
      // JET-48758 - Set maxlineCount to originally calculated value in getPrefferedSize if available width for title is less than it was in getPreferredSize.
      // Otherwise, the title might occupy more space due to wrapping which might lead to missing ticklabels.
      var maxLineCount;
      var prefAvailableTitleWidth = axis.getOptionsCache().getFromCache('prefAvailableTitleWidth');
      if (prefAvailableTitleWidth > maxLabelWidth) {
        maxLineCount = axis.getOptionsCache().getFromCache('prefTitleLineCount');
      }
      var title = DvtAxisRenderer._createText(
        axis.getEventManager(),
        axis,
        options['title'],
        titleStyle,
        0,
        0,
        maxLabelWidth,
        maxLabelHeight,
        DvtAxisEventManager.getUIParams('title'),
        isMultiLine,
        maxLineCount
      );

      if (title) {
        // Position the title based on text size and axis position
        var gap = DvtAxisRenderer._getTitleGap(axis);
        var overflow = (axisInfo.getStartOverflow() - axisInfo.getEndOverflow()) / 2;
        var isRTL = dvt.Agent.isRightToLeft(axis.getCtx());
        var titleHeight = title.getDimensions().h;
        title.alignCenter();

        // Position the label and update the space
        if (position === 'top') {
          title.setX(availSpace.x + overflow + availSpace.w / 2);
          title.setY(availSpace.y);
          availSpace.y += titleHeight + gap;
          availSpace.h -= titleHeight + gap;
        } else if (position === 'bottom') {
          title.setX(availSpace.x + overflow + availSpace.w / 2);
          title.setY(availSpace.y + availSpace.h - titleHeight);
          availSpace.h -= titleHeight + gap;
        } else if (position === 'left') {
          title.alignMiddle();
          title.setRotation(isRTL ? Math.PI / 2 : (3 * Math.PI) / 2);
          title.setTranslate(availSpace.x + titleHeight / 2, availSpace.y + availSpace.h / 2);
          availSpace.x += titleHeight + gap;
          availSpace.w -= titleHeight + gap;
        } else if (position === 'right') {
          title.alignMiddle();
          title.setRotation(isRTL ? Math.PI / 2 : (3 * Math.PI) / 2);
          title.setTranslate(
            availSpace.x + availSpace.w - titleHeight / 2,
            availSpace.y + availSpace.h / 2
          );
          availSpace.w -= titleHeight + gap;
        }

        axisInfo.setTitle(title);
      }
    },

    /**
     * Renders the tick labels and updates the available space.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {DvtAxisInfo} axisInfo The axis model.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderLabels: (axis, axisInfo, availSpace) => {
      // Note: DvtAxisRenderer.getPreferredSize must be updated for any layout changes to this function.
      var options = axis.getOptions();
      if (options['tickLabel']['rendered'] == 'on') {
        // Axis labels are positioned based on the position of the axis.  In layout
        // mode, the labels will be positioned as close to the title as possible to
        // calculate the actual space used.
        var position = options['position'];
        if (position === 'top' || position === 'bottom')
          DvtAxisRenderer._renderLabelsHoriz(axis, axisInfo, availSpace);
        else if (position === 'tangential')
          DvtAxisRenderer._renderLabelsTangent(axis, axisInfo, availSpace);
        else DvtAxisRenderer._renderLabelsVert(axis, axisInfo, availSpace);

        // Render the label separators (applicable only to group axis)
        DvtAxisRenderer._renderGroupSeparators(axis, axisInfo, availSpace);
      }
    },

    /**
     * Renders tick labels for a horizontal axis and updates the available space.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {DvtAxisInfo} axisInfo The axis model.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderLabelsHoriz: (axis, axisInfo, availSpace) => {
      // Note: DvtAxisRenderer.getPreferredSize must be updated for any layout changes to this function.
      // Position and add the axis labels.
      var context = axis.getCtx();
      var options = axis.getOptions();
      var position = options['position'];
      var isTickInside = options['tickLabel']['position'] == 'inside';
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isGroupAxis = axisInfo instanceof DvtAxisInfo.getConstructor('group');
      var isHierarchical = isGroupAxis && axisInfo.getNumLevels() > 1;

      var levelIdx = isHierarchical ? 0 : null;
      var labels = axisInfo.getLabels(context, levelIdx);

      gap = isHierarchical
        ? DvtAxisDefaults.getGapSize(
            context,
            options,
            options['layout']['hierarchicalLabelGapHeight']
          )
        : 0;
      while (labels) {
        var height = 0;
        var maxLvlHeight = 0;

        for (var i = 0; i < labels.length; i++) {
          var label = labels[i];

          if (label == null) continue;

          var isMultiline =
            label instanceof dvt.MultilineText || label instanceof dvt.BackgroundMultilineText;

          if (axisInfo.isLabelRotated(levelIdx)) {
            // Truncate to fit. Multiline texts only need fitting here if wrap was disabled.
            var fitText = !isMultiline || (isMultiline && !label.isWrapEnabled());
            if (fitText && !dvt.TextUtils.fitText(label, availSpace.h, availSpace.w, axis)) continue;

            // position and add the axis labels
            if (!isRTL) label.alignRight();
            else label.alignLeft();

            if (isHierarchical) {
              height = label.getDimensions().w;
              label.setTranslateY(availSpace.h - height);
              maxLvlHeight = Math.max(maxLvlHeight, height);
            } else label.setTranslateY(availSpace.y);
          } else {
            // not rotated
            if (!isTickInside && label.getDimensions().h - 1 > availSpace.h)
              // -1 to prevent rounding error ()
              continue;

            if (isHierarchical && position === 'bottom') label.setY(availSpace.h);
            else if (position === 'bottom') label.setY(availSpace.y);
            else label.setY(availSpace.y + availSpace.h);

            if (
              !isHierarchical &&
              ((position === 'bottom' && !isTickInside) || (position === 'top' && isTickInside))
            )
              label.alignTop();
            else if (isHierarchical && position === 'top') label.alignTop();
            else label.alignBottom();

            if (isHierarchical) maxLvlHeight = Math.max(maxLvlHeight, label.getDimensions().h);
            else if (isTickInside) {
              var gap = DvtAxisDefaults.getGapSize(
                context,
                options,
                options['layout']['insideLabelGapWidth']
              );
              isRTL ? label.alignRight() : label.alignLeft();
              label.setX(label.getX() + gap * (isRTL ? -1 : 1));
            }
          }

          // group axis labels store the true index of a label in the hierarchy of levels
          // true index necessary for getting proper attributes from axisInfo
          var index = isGroupAxis ? axisInfo.getLabelIdx(label) : i;

          // support for categorical axis tooltip and datatip
          var datatip = axisInfo.getDatatip(index, levelIdx);
          var tooltip = label.getUntruncatedTextString();
          // drilling support
          var drillable = axisInfo.isDrillable(index, levelIdx);
          var group = axisInfo.getGroup(index, levelIdx);

          // Associate with logical object to support automation and tooltips
          var params = DvtAxisEventManager.getUIParams(
            'tickLabel',
            label.getTextString(),
            index,
            levelIdx
          );

          axis
            .getEventManager()
            .associate(
              label,
              new DvtAxisObjPeer(axis, label, group, drillable, tooltip, datatip, params)
            );

          if (!isHierarchical) maxLvlHeight = Math.max(maxLvlHeight, label.getDimensions().h);
          else axisInfo.setLastRenderedLevel(levelIdx);

          axis.addChild(label);
        }
        if (isHierarchical) {
          for (i = 0; i < labels.length; i++) {
            label = labels[i];
            if (label == null) continue;

            var isRotated = axisInfo.isLabelRotated(levelIdx);
            var isOuterLevel = levelIdx < axisInfo.getNumLevels() - 1;
            if (!isRotated && isOuterLevel) {
              // non-rotated outer multiline texts need height adjustment to center
              label.setY(availSpace.h - maxLvlHeight / 2);
              label.alignMiddle();
            } // all rotated texts need height adjustment
            else label.setTranslateY(availSpace.h - maxLvlHeight);
          }

          availSpace.y += maxLvlHeight + gap;
          availSpace.h -= maxLvlHeight + gap;
          levelIdx++;
          labels = axisInfo.getLabels(axis.getCtx(), levelIdx);
        } else {
          availSpace.y += maxLvlHeight;
          availSpace.h -= maxLvlHeight;
          labels = null;
        }
      }

      // Render the nested labels (level 2) for time axis.
      if (axisInfo instanceof DvtAxisInfo.getConstructor('time')) {
        labels = axisInfo.getLabels(axis.getCtx());
        var lv2Labels = axisInfo.getLabels(axis.getCtx(), 1);
        var offset = 0;

        if (lv2Labels != null) {
          for (i = 0; i < lv2Labels.length; i++) {
            label = lv2Labels[i];
            if (label == null) continue;
            if (label.getDimensions().h - 1 > availSpace.h)
              // -1 to prevent rounding error ()
              continue;

            // Associate with logical object to support automation and tooltips
            axis
              .getEventManager()
              .associate(
                label,
                new dvt.SimpleObjPeer(
                  null,
                  null,
                  null,
                  DvtAxisEventManager.getUIParams('tickLabel', label.getTextString())
                )
              );

            // align with level 1 label
            var overflow1 = 0;
            var overflow2 = 0;
            var maxOverflow = axisInfo.getOptions()['_maxOverflowCoord'];
            var minOverflow = axisInfo.getOptions()['_minOverflowCoord'];
            if (labels[i] != null) {
              offset = labels[i].getDimensions().w / 2;
              overflow1 = axisInfo._level1Overflow[i];
              overflow2 = axisInfo._level2Overflow[i];
            }

            // Code below skips attempt to align level2 label if it overflows and level1 label does not
            // This is because if the level2 label overflows it should not be moved inward, else we risk creating a label overlap
            if (overflow1 == 0 && overflow2 == 0) {
              // Check that shifting by offset will not cause overflow
              var x = label.getX();
              var newCoord;
              if (isRTL) {
                newCoord = x + offset <= maxOverflow ? x + offset : maxOverflow;
                label.setX(newCoord);
              } else {
                newCoord = x - offset >= minOverflow ? x - offset : minOverflow;
                label.setX(newCoord);
              }
            } else if (overflow1 < 0)
              // level1 label is at the left edge, push level2 label out to minOverflow coord
              label.setX(minOverflow);
            else if (overflow1 > 0)
              // level1 label is at the right edge, push level2 label out to maxOverflow coord
              label.setX(maxOverflow);

            label.alignTop();
            label.setY(availSpace.y);
            axis.addChild(label);
          }
        }
      }
    },

    /**
     * Renders tick labels for a vertical axis and updates the available space.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {DvtAxisInfo} axisInfo The axis model.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderLabelsVert: (axis, axisInfo, availSpace) => {
      // Note: DvtAxisRenderer.getPreferredSize must be updated for any layout changes to this function.
      var options = axis.getOptions();
      var position = options['position'];
      var context = axis.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isNumerical = axisInfo instanceof DvtAxisInfo.getConstructor('data');
      var isTickInside = options['tickLabel']['position'] == 'inside';
      var labels;
      var gap;
      var maxLvlWidth;
      var isGroupAxis = axisInfo instanceof DvtAxisInfo.getConstructor('group');
      var isHierarchical = isGroupAxis && axisInfo.getNumLevels() > 1;

      // Hierarchical group axis labels
      var levelIdx = isHierarchical ? 0 : null;
      labels = axisInfo.getLabels(axis.getCtx(), levelIdx);

      var labelX = 0;
      if (!isHierarchical) {
        // Categorical and time labels are aligned left is position=right, aligned right if position=left.
        // Numerical labels are always aligned right.
        if (position === 'radial') {
          gap = DvtAxisDefaults.getGapSize(context, options, options['layout']['radialLabelGap']);
          labelX = availSpace.x + availSpace.w / 2;
          if (isRTL) labelX += gap + dvt.TextUtils.getMaxTextDimensions(labels).w;
          else labelX -= gap;
        } else if (position === 'left') {
          labelX = availSpace.x + availSpace.w;
          if (isNumerical && isTickInside) labelX += dvt.TextUtils.getMaxTextDimensions(labels).w;
        } else {
          // position == 'right'
          labelX = availSpace.x;
          if (isNumerical && !isTickInside) labelX += dvt.TextUtils.getMaxTextDimensions(labels).w;
        }
      } else {
        gap = DvtAxisDefaults.getGapSize(
          context,
          options,
          options['layout']['hierarchicalLabelGapWidth']
        );
        maxLvlWidth = dvt.TextUtils.getMaxTextDimensions(labels).w;
      }

      var formatLabelVert = (label, index) => {
        var isMultiline =
          label instanceof dvt.MultilineText || label instanceof dvt.BackgroundMultilineText;
        var fitText = !isMultiline || (isMultiline && !label.isWrapEnabled()); // Multiline texts only need fitting if wrap was disabled.

        if (isHierarchical && dvt.TextUtils.getMaxTextDimensions(labels).w - 1 > availSpace.w)
          // -1 to prevent rounding error ()
          return;
        else if (
          !isHierarchical &&
          !isTickInside &&
          fitText &&
          !dvt.TextUtils.fitText(label, availSpace.w, availSpace.h, axis)
        )
          return;

        // group axis labels store the true index of a label in the hierarchy of levels
        // true index necessary for getting proper attributes from axisInfo
        index = isGroupAxis ? axisInfo.getLabelIdx(label) : index;

        // support for categorical axis tooltip and datatip
        var datatip = axisInfo.getDatatip(index, levelIdx);
        var tooltip = label.getUntruncatedTextString();
        // drilling support
        var drillable = axisInfo.isDrillable(index, levelIdx);
        var group = axisInfo.getGroup(index, levelIdx);

        // Associate with logical object to support automation and tooltips
        var params = DvtAxisEventManager.getUIParams(
          'tickLabel',
          label.getTextString(),
          index,
          levelIdx
        );

        axis
          .getEventManager()
          .associate(
            label,
            new DvtAxisObjPeer(axis, label, group, drillable, tooltip, datatip, params)
          );

        if (!isHierarchical) {
          label.setX(labelX);
          if (!isNumerical && position == 'right') label.alignLeft();
          else label.alignRight();

          if (isTickInside) {
            label.alignBottom();
            label.setY(
              label.getY() -
                DvtAxisDefaults.getGapSize(
                  context,
                  options,
                  options['layout']['insideLabelGapHeight']
                )
            );
          }

          if (position === 'radial') {
            var labelY = label.getY();
            label.setY(availSpace.y + availSpace.h / 2 - labelY);

            // draw bounding box to improve readability
            var bboxDims = label.getDimensions();
            var padding = bboxDims.h * 0.15;
            var cmd = dvt.PathUtils.roundedRectangle(
              bboxDims.x - padding,
              bboxDims.y,
              bboxDims.w + 2 * padding,
              bboxDims.h,
              2,
              2,
              2,
              2
            );
            var bbox = new dvt.Path(axis.getCtx(), cmd);
            var bgColor = label.getCSSStyle().getStyle(dvt.CSSStyle.BACKGROUND_COLOR);
            var plotAreaPosition =
              labelY + bboxDims.h / 2 > axisInfo.getEndCoord() &&
              axis.getOptions()['polarGridShape'] == 'circle'
                ? 'outside'
                : 'inside';
            if (bgColor) bbox.setSolidFill(bgColor);
            else bbox.setClassName('oj-chart-polar-axis-tick-label-' + plotAreaPosition);
            axis.addChild(bbox);
          }
        } else {
          label.alignRight();
          label.setX(isRTL ? availSpace.w : availSpace.x + maxLvlWidth);
          axisInfo.setLastRenderedLevel(levelIdx);
        }
        axis.addChild(label);
      };

      while (labels) {
        for (var i = 0; i < labels.length; i++) {
          var label = labels[i];
          if (label != null) formatLabelVert(label, i);
        }
        if (isHierarchical) {
          availSpace.x += maxLvlWidth + gap;
          availSpace.w -= maxLvlWidth + gap;
          levelIdx++;
          labels = axisInfo.getLabels(axis.getCtx(), levelIdx);
          maxLvlWidth = labels ? dvt.TextUtils.getMaxTextDimensions(labels).w : null;
        } else break;
      }

      if (axisInfo instanceof DvtAxisInfo.getConstructor('time')) {
        // Render the nested labels (level 2).
        var lv2Labels = axisInfo.getLabels(axis.getCtx(), 1);
        if (lv2Labels != null) {
          for (i = 0; i < lv2Labels.length; i++) {
            label = lv2Labels[i];
            if (label != null) formatLabelVert(label, i);
          }
        }
      }
    },

    /**
     * Renders tick labels for a tangential axis and updates the available space.
     * @param {DvtAxis} axis The axis being rendered.
     * @param {DvtAxisInfo} axisInfo The axis model.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderLabelsTangent: (axis, axisInfo, availSpace) => {
      var labels = axisInfo.getLabels(axis.getCtx());
      for (var i = 0; i < labels.length; i++) {
        var label = labels[i];
        if (label == null) continue;
        var maxWidth = availSpace.w / 2 - Math.abs(label.getX());
        var maxHeight = availSpace.h / 2 - Math.abs(label.getY());
        if (dvt.TextUtils.fitText(label, maxWidth, maxHeight, axis)) {
          // truncation

          // group axis labels store the true index of a label in the hierarchy of levels
          // true index necessary for getting proper attributes from axisInfo
          var index =
            axisInfo instanceof DvtAxisInfo.getConstructor('group') ? axisInfo.getLabelIdx(label) : i;

          // support for categorical axis tooltip and datatip
          var datatip = axisInfo.getDatatip(index);
          var tooltip = label.getUntruncatedTextString();
          // drilling support
          var drillable = axisInfo.isDrillable(index);
          var group = axisInfo.getGroup(index);

          // Associate with logical object to support automation and tooltips
          var params = DvtAxisEventManager.getUIParams(
            'tickLabel',
            label.getTextString(),
            index,
            null
          );
          axis
            .getEventManager()
            .associate(
              label,
              new DvtAxisObjPeer(axis, label, group, drillable, tooltip, datatip, params)
            );

          label.setTranslateX(availSpace.x + availSpace.w / 2);
          label.setTranslateY(availSpace.y + availSpace.h / 2);
          axis.addChild(label);
        }
      }
    },

    /**
     * Creates and adds a dvt.Text object to a container. Will truncate and add tooltip as necessary.
     * @param {dvt.EventManager} eventManager
     * @param {dvt.Container} container The container to add the text object to.
     * @param {String} textString The text string of the text object.
     * @param {dvt.CSSStyle} cssStyle The css style to apply to the text object.
     * @param {number} x The x coordinate of the text object.
     * @param {number} y The y coordinate of the text object.
     * @param {number} width The width of available text space.
     * @param {number} height The height of the available text space.
     * @param {object} params Additional parameters that will be passed to the logical object.
     * @param {boolean=} bMultiLine True if text can use multiple lines
     * @param {number} maxLineCount Maximum number of lines allowed in the case of multi line texts.
     * @return {dvt.OutputText|dvt.MultilineText} The created text object. Can be null if no text object could be created in the given space.
     * @private
     */
    _createText: (
      eventManager,
      container,
      textString,
      cssStyle,
      x,
      y,
      width,
      height,
      params,
      bMultiLine,
      maxLineCount
    ) => {
      var text;
      if (bMultiLine) {
        text = new dvt.MultilineText(container.getCtx(), textString, x, y);
        text.setMaxLines(maxLineCount != null ? maxLineCount : DvtAxisRenderer._MAX_TITLE_LINE_WRAP);
        text.setCSSStyle(cssStyle);
        text.wrapText(width, height, 1);
      } else {
        text = new dvt.OutputText(container.getCtx(), textString, x, y);
        text.setCSSStyle(cssStyle);
      }

      if (dvt.TextUtils.fitText(text, width, height, container)) {
        // Associate with logical object to support automation and truncation
        eventManager.associate(
          text,
          new dvt.SimpleObjPeer(text.getUntruncatedTextString(), null, null, params)
        );
        return text;
      }

      return null;
    },

    /**
     * Renders the separators between group labels
     * @param {DvtAxis} axis The axis being rendered.
     * @param {DvtAxisInfo} axisInfo The axis model.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderGroupSeparators: (axis, axisInfo, availSpace) => {
      if (
        axisInfo instanceof DvtAxisInfo.getConstructor('group') &&
        axisInfo.areSeparatorsRendered()
      ) {
        var numLevels = axisInfo.getNumLevels();
        var separatorStartLevel = axisInfo.getSeparatorStartLevel();

        // only draw separators when there is more than one level of labels, and at least one level to apply separators to
        if (numLevels <= 1 || separatorStartLevel <= 0) return;

        var options = axis.getOptions();
        var position = options['position'];
        var isHoriz = position == 'top' || position == 'bottom';
        var context = axis.getCtx();
        var isRTL = dvt.Agent.isRightToLeft(context);

        var color = axisInfo.getSeparatorColor();
        var lineStroke = new dvt.Stroke(color, 1, 1);
        var prevLevelSize = 0;
        var gap = isHoriz
          ? DvtAxisDefaults.getGapSize(
              context,
              options,
              options['layout']['hierarchicalLabelGapHeight']
            )
          : DvtAxisDefaults.getGapSize(
              context,
              options,
              options['layout']['hierarchicalLabelGapWidth']
            );
        var startOffset = options['startGroupOffset'];
        var endOffset = options['endGroupOffset'];

        var x1, y1, x2, y2, x3, x4;
        /*
         * orientation = 'vertical'                     if rotated:
         * (x1, y1)                        (x2, y1)     (x1, y1)                 (x2, y1)
         *    |                               |            |     rotated label      |
         *    ------------- label -------------            --------------------------
         * (x1, y2)    (x3, y2)(x4, y2)    (x2, y2)     (x1, y2)                 (x2, y2)
         *
         *
         * orientation = 'horizontal'
         * (x1, y1) _______ (x2, y1)
         *         |
         *         |
         *         | label
         *         |
         *         |
         * (x1, y2) _______ (x2, y2)
         */

        // process from the innermost level that was rendered
        for (var level = separatorStartLevel; level >= 0; level--) {
          var labels = axisInfo.getLabels(axis.getCtx(), level);
          var maxDims = dvt.TextUtils.getMaxTextDimensions(labels);
          var isRotated = axisInfo.isLabelRotated(level);
          var levelSize = isRotated || !isHoriz ? maxDims.w : maxDims.h;

          if (levelSize == 0) {
            // no labels to draw separators between
            prevLevelSize = levelSize;
            continue;
          }

          // variables to keep track of whether certain edge cases apply
          var prevLabelRendered = false; // previous label exists, does not have blank name, and is within the viewport
          var prevLabelEmpty = null; // previous label exists, but has a blank name (uneven heirarchy)

          // Start drawing separators from second innermost level rendered.
          if (level < separatorStartLevel) {
            for (var i = 0; i < labels.length; i++) {
              var label = labels[i];
              if (label == null) continue;

              var index = axisInfo.getLabelIdx(label);
              var isEmptyLabel = axisInfo.getLabelAt(index, level).length == 0; // label exists, but has a blank name (uneven heirarchy)

              if (isEmptyLabel) continue;

              // empty label at first or last position in the outermost level
              var eraseCornerEdge =
                isEmptyLabel && level == 0 && (index == 0 || index == labels.length - 1);

              var isFirstLabel = label && labels[index - 1] == null;
              var isLastLabel = label && labels[index + 1] == null;

              var start = axisInfo.getStartIdx(index, level);
              var end = axisInfo.getEndIdx(index, level);

              if (isHoriz) {
                // HORIZONTAL AXIS SEPARATORS

                // draw vertical lines, when necessary, around label
                if (label) {
                  var yCoord;
                  if (
                    label instanceof dvt.MultilineText ||
                    label instanceof dvt.BackgroundMultilineText
                  )
                    yCoord = label.getYAlignCoord();
                  else yCoord = label.getY();

                  x1 = axisInfo.getCoordAt(start - startOffset);
                  y1 = !isRotated
                    ? yCoord - levelSize / 2 - prevLevelSize * 0.5 - gap
                    : yCoord + prevLevelSize * 0.5;
                  x2 = axisInfo.getCoordAt(end + endOffset);
                  y2 = !isRotated ? yCoord : yCoord + levelSize + prevLevelSize + 2 * gap;

                  if ((!isEmptyLabel || !eraseCornerEdge) && prevLabelRendered == false && x1 != null)
                    DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x1, y2, x1, y1);

                  if (x2 != null && !eraseCornerEdge)
                    DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x2, y2, x2, y1);
                }

                // draw horizontal lines, when necessary, around non-empty labels
                if (!isEmptyLabel) {
                  if (label)
                    var labelWidth = isRotated ? label.getDimensions().h : label.getDimensions().w;

                  x1 =
                    isFirstLabel && prevLabelEmpty == false
                      ? axisInfo.getStartCoord()
                      : axisInfo.getBoundedCoordAt(start - startOffset);
                  if (isFirstLabel) isFirstLabel = false;
                  var nextLabel = axisInfo.getLabelAt(index + 1, level);
                  x2 =
                    isLastLabel && nextLabel && nextLabel.length > 0
                      ? axisInfo.getEndCoord()
                      : axisInfo.getBoundedCoordAt(end + endOffset);

                  x3 = label
                    ? isRTL
                      ? label.getX() + labelWidth * 0.5
                      : label.getX() - labelWidth * 0.5
                    : axisInfo.getBoundedCoordAt(end + endOffset);
                  x4 = label
                    ? isRTL
                      ? label.getX() - labelWidth * 0.5
                      : label.getX() + labelWidth * 0.5
                    : axisInfo.getBoundedCoordAt(start - startOffset);

                  if (label) {
                    if (isRotated)
                      // draw horizontal line beneath rotated label
                      DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x1, y2, x2, y2);
                    else {
                      // draw horizontal lines on either size of rendered label
                      var spacing = isRTL
                        ? -label.getDimensions().h * 0.5
                        : label.getDimensions().h * 0.5; // small space between end of horizontal lines and label
                      var drawRightLine = isRTL ? x1 > x3 - spacing : x1 < x3 - spacing;
                      var drawLeftLine = isRTL ? x4 + spacing > x2 : x4 + spacing < x2;

                      if (drawRightLine)
                        DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x1, y2, x3 - spacing, y2);

                      if (drawLeftLine)
                        DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x4 + spacing, y2, x2, y2);
                    }
                  }
                }
              } else {
                // VERTICAL AXIS SEPARATORS

                // draw horizontal lines, when necessary, around label
                if (label) {
                  x1 = !isRTL ? label.getX() + gap * 0.5 : label.getX() - levelSize - gap * 0.5;
                  y1 = axisInfo.getCoordAt(start - startOffset);
                  x2 = !isRTL ? label.getX() - levelSize - gap * 0.5 : label.getX() + gap * 0.5;
                  y2 = axisInfo.getCoordAt(end + endOffset);

                  if (
                    ((!isEmptyLabel && prevLabelRendered == false) ||
                      (index == 0 && isEmptyLabel && level != 0)) &&
                    y1 != null
                  )
                    DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x1, y1, x2, y1);

                  if (y2 != null && !eraseCornerEdge)
                    DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x2, y2, x1, y2);
                }

                // draw vertical lines, when necessary, around non-empty labels
                if (!isEmptyLabel) {
                  y1 =
                    isFirstLabel && prevLabelEmpty == false
                      ? 0
                      : axisInfo.getBoundedCoordAt(start - startOffset);
                  if (isFirstLabel) isFirstLabel = false;
                  nextLabel = axisInfo.getLabelAt(index + 1, level);
                  y2 =
                    isLastLabel && nextLabel && nextLabel.length > 0
                      ? axisInfo.getEndCoord()
                      : axisInfo.getBoundedCoordAt(end + endOffset);

                  if (label)
                    // draw vertical line around label
                    DvtAxisRenderer._addSeparatorLine(axis, lineStroke, x2, y1, x2, y2);
                }
              }
              // information about previous label
              prevLabelRendered = !isEmptyLabel && label != null;
              prevLabelEmpty = label != null || (label == null && isEmptyLabel); // TODO TAMIKA: IS THIS NECESSARY
            }
          }
          prevLevelSize = levelSize; // save height or width of previous level
        }
      }
      return;
    },

    /**
     * Renders separator line
     * @param {DvtAxis} axis The axis on which the separators are rendered.
     * @param {dvt.Stroke} lineStroke The stroke for the line.
     * @param {Number} x1 The first xCoordinate of the line.
     * @param {Number} y1 The first yCoordinate of the line.
     * @param {Number} x2 The second xCoordinate of the line.
     * @param {Number} y2 The second yCoordinate of the line.
     * @private
     */
    _addSeparatorLine: (axis, lineStroke, x1, y1, x2, y2) => {
      var line = new dvt.Line(axis.getCtx(), x1, y1, x2, y2);
      line.setStroke(lineStroke);
      line.setPixelHinting(true);
      axis.addChild(line);

      return;
    },

    /**
     * Gets the preferred size for a group axis, which may include hierarchical labels
     * @param {DvtAxis} axis The axis
     * @param {DvtGroupAxisInfo} axisInfo The group axis info
     * @param {Number} size The current preferred size of the axis
     * @param {Number} availSize The maximum availHeight or availWidth of the axis
     * @param {Boolean} bHoriz Whether or not the axis is vertical of horizontal
     * @return {Number}
     * @private
     */
    _getGroupAxisPreferredSize: (axis, axisInfo, size, availSize, bHoriz) => {
      var context = axis.getCtx();
      var options = axis.getOptions();
      var numLevels = axisInfo.getNumLevels();
      var gapName = bHoriz ? 'hierarchicalLabelGapHeight' : 'hierarchicalLabelGapWidth';
      var gap =
        numLevels > 1 ? DvtAxisDefaults.getGapSize(context, options, options['layout'][gapName]) : 0;
      for (var level = 0; level < numLevels; level++) {
        // allocate space outermost to innermost
        var labelSize; // corresponds to label height if bHoriz, label width if not

        if (axisInfo.isAutoRotate()) {
          // performance optimization
          var labelStrings = [];
          var labelStyles = [];
          // increase performance by only measuring a subset of labels to begin with, as majority will be skipped.
          var increment = axisInfo.getSkipIncrement();

          for (var i = 0; i < axisInfo.getGroupCount(); i += increment) {
            labelStrings.push(axisInfo.getLabelAt(i, 0));
            var style = axisInfo.getLabelStyleAt(i, 0);
            if (!style) style = axisInfo.Options['tickLabel']['style'];
            labelStyles.push(style);
          }
          labelSize = dvt.TextUtils.getMaxTextStringWidth(context, labelStrings, labelStyles);
        } else {
          var labels = axisInfo.getLabels(context, level);
          if (bHoriz) {
            var maxDims = dvt.TextUtils.getMaxTextDimensions(labels);
            labelSize = axisInfo.isLabelRotated(level) ? maxDims.w : maxDims.h;
          } else labelSize = dvt.TextUtils.getMaxTextDimensions(labels).w;
        }

        if (size + labelSize <= availSize) size += labelSize + gap;
        else {
          if (level == 0)
            // Outermost level labels were too big, assign all of availSize
            size = availSize;
          break;
        }
      }
      if (level != 0) size -= gap; // last hierarchical level rendered doesn't need gap

      return size;
    },

    /**
     * Get the height and line count of the axis title.
     * @param {dvt.Context} context The axis context
     * @param {Object} options The options for the axis
     * @param {Number} availWidth The maximum available width for the title
     * @param {Number} availHeight The maximum available height for the title
     * @return {Object} Contains the height and line count of the axis title
     */
    getTitleHeight: (context, options, availWidth, availHeight) => {
      var titleHeight = 0;
      var text;

      if (options['title']) {
        if (DvtAxisRenderer.isWrapEnabled(options['titleStyle'])) {
          text = new dvt.MultilineText(context, options['title'], 0, 0);
          text.setMaxLines(DvtAxisRenderer._MAX_TITLE_LINE_WRAP);
          text.setCSSStyle(options['titleStyle']);
          text.wrapText(availWidth, availHeight, 1);
          titleHeight =
            dvt.TextUtils.getTextStringHeight(context, options['titleStyle']) * text.getLineCount();
        } else titleHeight = dvt.TextUtils.getTextStringHeight(context, options['titleStyle']);
      }

      return {
        height: titleHeight,
        lineCount: text ? text.getLineCount() : 0
      };
    },

    /**
     * Returns true if the white space property is not nowrap.
     * @param {dvt.CSSStyle} cssStyle The css style to be evaluated
     * @return {boolean}
     */
    isWrapEnabled: (cssStyle) => {
      var whiteSpaceValue = cssStyle.getStyle(dvt.CSSStyle.WHITE_SPACE);
      // checking noWrap for backwards compatibility
      if (whiteSpaceValue == 'nowrap' || whiteSpaceValue == 'noWrap') return false;
      return true;
    }
  };

  /**
   * Calculated axis information and drawable creation for a group axis.
   * @param {dvt.Context} context
   * @param {object} options The object containing specifications and data for this component.
   * @param {dvt.Rectangle} availSpace The available space.
   * @class
   * @constructor
   * @extends {DvtAxisInfo}
   */
  class DvtGroupAxisInfo extends DvtAxisInfo {
    constructor(context, options, availSpace) {
      super(context, options, availSpace);

      /**
       * The max amount of lines we allow in label wrapping.
       * Needed to prevent rotated labels from greedily wrapping along the length of the xAxis
       * @private
       */
      this._MAX_LINE_WRAP = 3;

      /**
       * The threshold for how small the group width can become before skipping label measurement checks
       * and defaulting to rotation in order to improve performance.
       * @private
       */
      this._ROTATE_THRESHOLD = 12;

      // Flip horizontal axes for BIDI
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isHoriz = this.Position == 'top' || this.Position == 'bottom';
      if (isHoriz && isRTL) {
        var temp = this.StartCoord;
        this.StartCoord = this.EndCoord;
        this.EndCoord = temp;
      }

      this._levelsArray = [];
      this._groupCount = this._generateLevelsArray(options['groups'], 0, this._levelsArray, 0); // populates this._levelsArray and returns groupCount
      this._numLevels = this._levelsArray.length;
      this._areSeparatorsRendered = options['groupSeparators']['rendered'] != 'off';
      this._separatorColor = options['groupSeparators']['color'];
      this._lastRenderedLevel = null;
      this._drilling = options['drilling'];

      // Calculate the increment and add offsets if specified
      var endOffset = options['endGroupOffset'] > 0 ? Number(options['endGroupOffset']) : 0;
      var startOffset = options['startGroupOffset'] > 0 ? Number(options['startGroupOffset']) : 0;

      // Set the axis min/max
      this.DataMin = 0;
      this.DataMax = this._groupCount - 1;

      this.GlobalMin = options['min'] == null ? this.DataMin - startOffset : options['min'];
      this.GlobalMax = options['max'] == null ? this.DataMax + endOffset : options['max'];

      // Set min/max by start/endGroup
      var startIndex = this.getGroupIndex(options['viewportStartGroup']);
      var endIndex = this.getGroupIndex(options['viewportEndGroup']);
      if (startIndex != -1) this.MinValue = startIndex - startOffset;
      if (endIndex != -1) this.MaxValue = endIndex + endOffset;

      // Set min/max by viewport min/max
      if (options['viewportMin'] != null) this.MinValue = options['viewportMin'];
      if (options['viewportMax'] != null) this.MaxValue = options['viewportMax'];

      // If min/max is still undefined, fall back to global min/max
      if (this.MinValue == null) this.MinValue = this.GlobalMin;
      if (this.MaxValue == null) this.MaxValue = this.GlobalMax;

      if (this.GlobalMin > this.MinValue) this.GlobalMin = this.MinValue;
      if (this.GlobalMax < this.MaxValue) this.GlobalMax = this.MaxValue;

      this._groupWidthRatios = options['_groupWidthRatios'];
      this._processGroupWidthRatios();

      this._startBuffer = isRTL ? options['rightBuffer'] : options['leftBuffer'];
      this._endBuffer = isRTL ? options['leftBuffer'] : options['rightBuffer'];

      this._isLabelRotated = [];
      for (var i = 0; i < this._numLevels; i++) this._isLabelRotated.push(false);

      this._renderGridAtLabels = options['_renderGridAtLabels'];

      this._labels = null;

      // Initial height/width that will be available for the labels. Used for text wrapping.
      this._maxSpace = isHoriz ? availSpace.h : availSpace.w;
      if (options['rendered'] != 'off') {
        var titleHeight = DvtAxisRenderer.getTitleHeight(
          context,
          options,
          isHoriz ? availSpace.w : availSpace.h,
          isHoriz ? availSpace.h : availSpace.w
        ).height;
        this._maxSpace -=
          titleHeight != 0
            ? titleHeight +
              DvtAxisDefaults.getGapSize(context, options, options['layout']['titleGap'])
            : 0;
      }

      this._maxLineWrap = this._MAX_LINE_WRAP;
    }

    /**
     * Processes group width ratios to support bar chart with varying widths.
     * @private
     */
    _processGroupWidthRatios() {
      // Edge case: less than two groups
      if (!this._groupWidthRatios || this._groupWidthRatios.length < 2) {
        this._groupWidthRatios = null;
        return;
      }

      // Compute the sums of the group widths that are contained within the viewport
      var sum = 0;
      var groupMin, groupMax;
      for (var g = 0; g < this._groupCount; g++) {
        groupMin = g == 0 ? this.MinValue : Math.max(g - 0.5, this.MinValue);
        groupMax = g == this._groupCount - 1 ? this.MaxValue : Math.min(g + 0.5, this.MaxValue);
        if (groupMax > groupMin) sum += (groupMax - groupMin) * this._groupWidthRatios[g];
      }

      // Divide the total viewport length (in pixels) proportionally based on the group width ratios.
      var totalWidth = this.EndCoord - this.StartCoord;
      this._groupWidths = this._groupWidthRatios.map((ratio) => {
        return (ratio * totalWidth) / sum;
      });

      // Construct borderValues array which stores the the value location of the group boundaries.
      this._borderValues = [];
      for (var g = 0; g < this._groupWidthRatios.length - 1; g++) {
        this._borderValues.push(g + 0.5);
      }

      // Construct borderCoords array which stores the coord location of the group boundaries.
      this._borderCoords = [];
      var anchor = Math.min(Math.max(Math.round(this.MinValue), 0), this._borderValues.length - 1);
      this._borderCoords[anchor] =
        this.StartCoord + (this._borderValues[anchor] - this.MinValue) * this._groupWidths[anchor];
      for (
        var g = anchor + 1;
        g < this._borderValues.length;
        g++ // compute borderCoords after the anchor
      )
        this._borderCoords[g] = this._borderCoords[g - 1] + this._groupWidths[g];
      for (
        var g = anchor - 1;
        g >= 0;
        g-- // compute borderCoords before the anchor
      )
        this._borderCoords[g] = this._borderCoords[g + 1] - this._groupWidths[g + 1];
    }

    /**
     * Rotates the labels of the horizontal axis by 90 degrees and skips the labels if necessary.
     * @param {Array} labels An array of dvt.Text labels for the axis.
     * @param {dvt.Container} container
     * @param {number} overflow How much overflow the rotated labels will have.
     * @param {number} level The level the labels array corresponds to
     * @return {Array} The array of dvt.Text labels for the axis.
     * @private
     */
    _rotateLabels(labels, container, overflow, level) {
      var text;
      var x;
      var context = this.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isHierarchical = this._numLevels > 1;

      if (level == null) level = this._numLevels - 1;

      this._isLabelRotated[level] = true;

      // TODO: For hierarchical labels, overflow change due to rotation is ignored.
      // Ideally we need to set the overflow at the end after all levels have been rotated.
      if (!isHierarchical) this._setOverflow(overflow, overflow, labels);

      for (var i = 0; i < labels.length; i++) {
        text = labels[i];
        if (text == null) continue;
        x = text.getX();

        // Wrap multiline text in new height/width dimensions
        var isMultiline =
          text instanceof dvt.MultilineText || text instanceof dvt.BackgroundMultilineText;
        if (isMultiline) {
          var groupSpan =
            this.getGroupWidth() * (this.getEndIdx(i, level) - this.getStartIdx(i, level) + 1);
          // Estimate if there is room for at least one wrap, and either attempt to wrap or disable wrap on the text
          // Note: This estimate may end up disabling wrap for text that may have just fit, but sufficiently excludes text that
          // will have definitely not fit.
          if (text.getLineHeight() * 2 < groupSpan && this._maxSpace > 0)
            text.wrapText(this._maxSpace, text.getLineHeight() * this._MAX_LINE_WRAP, 1);
          else text.setWrapEnabled(false);
        }

        text.setX(0);
        text.setY(0);
        if (isRTL) text.setRotation(Math.PI / 2);
        else text.setRotation((3 * Math.PI) / 2);
        text.setTranslateX(x);
      }

      var labelDims = this.GetLabelDims(labels, container, level); // the guess returns the exact heights

      // Wrapped labels
      if (DvtAxisRenderer.isWrapEnabled(this.Options['tickLabel']['style']) && this._maxSpace > 0) {
        var updateLabelDims = this._sanitizeWrappedText(
          context,
          labelDims,
          labels,
          true,
          isHierarchical
        );
        // Recalculate label dims for skipping
        if (updateLabelDims) labelDims = this.GetLabelDims(labels, container, level);
      }

      return this.SkipLabels(labels, labelDims);
    }

    /**
     * Checks if any label should be re-wrapped due to overlap and re-wraps text if needed to minimize overlap.
     * Updates remaining space available for wrapping hierarchical labels.
     * @param {dvt.Context} context
     * @param {Array} labelDims An array of dvt.Text dimensions for the axis.
     * @param {Array} labels An array of dvt.Text labels for the axis.
     * @param {Boolean} isRotated Whether or not labels are horizontal and rotated, or vertical.
     * @param {Boolean} isHierarchical Whether or not axis has hierarchical labels
     * @return {Boolean} Whether or not labels were re-wrapped
     * @private
     */
    _sanitizeWrappedText(context, labelDims, labels, isRotated, isHierarchical) {
      // Check any label should be wrapped
      var updateLabelDims = this._calculateMaxWrap(labelDims, labels, isRotated);

      var totalSpace = 0;
      // Re-wraps text if needed to minimize overlap, updates remaining space available for wrapping hierarchical labels.
      for (var i = 0; i < labels.length; i++) {
        var text = labels[i];
        if (!text) continue;

        var isMultiline =
          text instanceof dvt.MultilineText || text instanceof dvt.BackgroundMultilineText;

        // Re-wrap to minimize overlap
        if (updateLabelDims && isMultiline && text.isWrapEnabled())
          text.wrapText(this._maxSpace, text.getLineHeight() * this._maxLineWrap, 1);

        // Keep track of maximum height of this rotated level.
        if (isHierarchical) totalSpace = Math.max(totalSpace, text.getDimensions().w);

        // Make sure texts, which may or may not have been re-wrapped are aligned center
        text.alignMiddle();
      }

      // Update remaining space available for wrapping hierarchical labels.
      if (isHierarchical) {
        var gap = isRotated
          ? this.Options['layout']['hierarchicalLabelGapHeight']
          : this.Options['layout']['hierarchicalLabelGapWidth'];
        this._maxSpace -= totalSpace + DvtAxisDefaults.getGapSize(context, this.Options, gap);
      }

      return updateLabelDims;
    }

    /**
     * Updates the maximum lines labels will be allowed to have to minimize overlap
     * @param {Array} labelDims An arry of the current label dimensions
     * @param {Array} labels An array of dvt.Text labels for the axis.
     * @param {Boolean} isRotated Whether or not the axis is horizontal
     * @return {Boolean} Whether or not labels will need to be re-wrapped
     * @private
     */
    _calculateMaxWrap(labelDims, labels, isRotated) {
      var updateLabelDims = false;

      // Estimate and update label dims of text if they were to be wrapped with current maxLineWrap
      // Decrease maxLineWrap until 1 if it is estimated text will still overlap
      while (this.IsOverlapping(labelDims, 0) && this._maxLineWrap > 1) {
        updateLabelDims = true;
        for (var i = 0; i < labels.length; i++) {
          var text = labels[i];
          if (text instanceof dvt.MultilineText || text instanceof dvt.BackgroundMultilineText) {
            if (text.getLineCount() == this._maxLineWrap) {
              var lineHeight = text.getLineHeight();
              if (isRotated) labelDims[i].w -= lineHeight;
              else {
                labelDims[i].y += lineHeight * 0.5;
                labelDims[i].h -= lineHeight;
              }
            }
          }
        }
        this._maxLineWrap--;
      }

      return updateLabelDims;
    }

    /**
     * @override
     */
    isLabelRotated(level) {
      if (level == null) level = this._numLevels - 1;
      return this._isLabelRotated[level];
    }

    /**
     * Sets the start/end overflow of the axis.
     * @param {number} startOverflow How much the first label overflows beyond the start coord.
     * @param {number} endOverflow How much the last label overflows beyonod the end coord.
     * @param {array} labels An array of dvt.Text labels for a specific level. The x coordinated of the labels will be recalculated.
     * @private
     */
    _setOverflow(startOverflow, endOverflow, labels) {
      // TODO: hierarchical labels -- when more than one level is rotated, _setOverflow is incorrect
      //       due to text.setX(coord) (should be setting the translateX instead).

      startOverflow = Math.max(startOverflow - this._startBuffer, 0);
      endOverflow = Math.max(endOverflow - this._endBuffer, 0);

      // Revert the start/endCoord to the original positions before applying the new overflow values
      var isRTL = dvt.Agent.isRightToLeft(this.getCtx());
      this.StartCoord += (startOverflow - this.StartOverflow) * (isRTL ? -1 : 1);
      this.EndCoord -= (endOverflow - this.EndOverflow) * (isRTL ? -1 : 1);

      // Reprocess since startCoord and endCoord have changed
      this._processGroupWidthRatios();

      // Recalculate coords for all levels.
      for (var j = 0; j < this._numLevels; j++) {
        labels = this._labels[j];
        // Adjust the label coords
        for (var i = 0; i < labels.length; i++) {
          var text = labels[i];
          if (text) {
            var coord = this._getLabelCoord(j, this.getLabelIdx(text));
            if (this._numLevels > 1) {
              text.setTranslateX(coord);
            } else {
              text.setX(coord);
            }
          }
        }
      }

      this.StartOverflow = startOverflow;
      this.EndOverflow = endOverflow;
    }

    /**
     * @override
     */
    getLabels(context, level) {
      if (level == null)
        // Default to returning inner most labels
        level = this._numLevels - 1;

      if (!this._labels) this._generateLabels(context);

      return this._labels[level];
    }

    /**
     * Gets the coordinate of a group label based on it's position in the hierarchy
     * @param {number} level
     * @param {number} index
     * @private
     * @return {number} The label coord
     */
    _getLabelCoord(level, index) {
      var startValue = this.getStartIdx(index, level);
      var endValue = this.getEndIdx(index, level);
      if (startValue == null || endValue == null) return null;

      if (startValue < this.MinValue && endValue > this.MinValue) startValue = this.MinValue;
      if (endValue > this.MaxValue && startValue < this.MaxValue) endValue = this.MaxValue;
      var center = endValue ? startValue + (endValue - startValue) / 2 : startValue;
      return this.getCoordAt(center);
    }

    /**
     * Generates the labels
     * @param {dvt.Context} context
     * @private
     */
    _generateLabels(context) {
      var labels = [];
      this._labels = [];
      var container = context.getStage();
      var isHoriz = this.Position == 'top' || this.Position == 'bottom';
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isHierarchical = this._numLevels > 1;
      var groupWidth = this.getGroupWidth();
      var availSize = this._maxSpace;
      var gapName = isHoriz ? 'hierarchicalLabelGapHeight' : 'hierarchicalLabelGapWidth';
      var gap = isHierarchical
        ? DvtAxisDefaults.getGapSize(context, this.Options, this.Options['layout'][gapName])
        : 0;
      var rotationEnabled = this.Options['tickLabel']['rotation'] == 'auto' && isHoriz;
      var groupSpansMap = {};

      // autoRotate used to enhance performance
      var autoRotate = this.isAutoRotate();

      // Attempt text wrapping if:
      // 1. white-space != 'nowrap'
      // 2. vertical or horizontal axis
      // 3. groupWidth > textHeight -> wrapping is only necessary when more than one text line can tentatively fit in the groupWidth
      var tickLabelStyle = this.Options['tickLabel']['style'];
      var wrapping =
        DvtAxisRenderer.isWrapEnabled(this.Options['tickLabel']['style']) &&
        this.Position != 'tangential' &&
        groupWidth > dvt.TextUtils.getTextStringHeight(context, tickLabelStyle);

      // Iterate and create the labels
      var label, firstLabel, lastLabel;
      var cssStyle;
      var text;

      for (var level = 0; level < this._numLevels; level++) {
        var levels = this._levelsArray[level];
        // if autoRotate, increase performance by only generating a subset of labels to begin with, as majority will be skipped.
        var increment = autoRotate ? this.getSkipIncrement() : 1;
        groupSpansMap[level] = [];

        for (var i = 0; i < levels.length; i += increment) {
          if (levels[i]) {
            label = this.getLabelAt(i, level);
            // No text object created when group name is null or ''
            if (label === '' || (!label && label != 0)) {
              labels.push(null);
              continue;
            }

            var coord = this._getLabelCoord(level, i);
            if (coord != null) {
              // get categorical axis label style, if it exists
              cssStyle = this.getLabelStyleAt(i, level);
              var bMultiline =
                !autoRotate && wrapping && typeof label != 'number' && label.indexOf(' ') >= 0;
              text = this.CreateLabel(context, label, coord, cssStyle, bMultiline);

              // JET-53254: Make non multiline labels accessibile to assisstive technology
              if (this.isDrillable(i, level) && !bMultiline) {
                text.setAriaProperty('hidden', null);
              }

              var groupSpan =
                groupWidth * (this.getEndIdx(i, level) - this.getStartIdx(i, level) + 1);
              groupSpansMap[level].push(groupSpan);
              var bWrappedLabel =
                bMultiline &&
                this._isTextWrapNeeded(
                  context,
                  label,
                  cssStyle,
                  rotationEnabled,
                  isHoriz ? groupSpan : availSize
                );
              // wrap text in the width available for each group
              if (bWrappedLabel && availSize > 0) {
                if (isHoriz) text.wrapText(groupSpan, availSize, 1, true);
                else text.wrapText(availSize, text.getLineHeight() * this._maxLineWrap, 1, false);
              } else if (bMultiline && (!isHoriz || availSize < 0))
                // Multiline texts on vertical axis will not attempt further wrapping
                text.setWrapEnabled(false);

              text._index = i; // group axis labels should reference label._index for its index
              labels.push(text);

              // Store first and last label
              if (!firstLabel && level == 0) firstLabel = text;
              if (level == 0) lastLabel = text;
            } else labels.push(null);
          } else labels.push(null);
        }

        // Adjust availSize for generating wrapped hierarchical levels
        if (wrapping && isHierarchical) {
          var totalSpace = 0;
          for (var j = 0; j < labels.length; j++) {
            if (!labels[j]) continue;

            var dims = labels[j].getDimensions();
            totalSpace = Math.max(totalSpace, isHoriz ? dims.h : dims.w);
          }
          availSize -= totalSpace + gap;
        }

        this._labels.push(labels);
        labels = [];
      }

      labels = this._labels[this._numLevels - 1];
      var labelDims = [];

      if (!firstLabel) return;

      if (this.Position == 'tangential') {
        labelDims = this.GetLabelDims(labels, container); // actual dims
        this._labels[0] = this.SkipTangentialLabels(labels, labelDims);
        return;
      }

      var firstLabelDim = firstLabel.getDimensions();
      var resetOverflow = false;

      if (isHoriz) {
        var startOverflow, endOverflow;
        if (this.Options['_startOverflow'] != null && this.Options['_endOverflow'] != null) {
          // Use the preset value if available (during z&s animation)
          startOverflow = this.Options['_startOverflow'];
          endOverflow = this.Options['_endOverflow'];
        } else {
          // wrapping combined with rotation eliminate the potential for overflow
          // Set the overflow depending on how much the first and the last label go over the bounds
          var lastLabelDim = lastLabel.getDimensions();
          startOverflow = isRTL
            ? firstLabelDim.w + firstLabelDim.x - this.StartCoord
            : this.StartCoord - firstLabelDim.x;
          endOverflow = isRTL
            ? this.EndCoord - lastLabelDim.x
            : lastLabelDim.w + lastLabelDim.x - this.EndCoord;
        }

        resetOverflow = startOverflow > this._startBuffer || endOverflow > this._endBuffer;
      }

      for (level = 0; level < this._numLevels; level++) {
        labels = this._labels[level];

        if (autoRotate)
          this._labels[level] = this._rotateLabels(labels, container, firstLabelDim.h / 2, level);
        else {
          labelDims = this.GetLabelDims(labels, container, level); // maximum estimate

          var labelsOverlapping = this.IsOverlapping(labelDims, 0, groupSpansMap[level]);
          if (!labelsOverlapping) this._labels[level] = labels; // all labels can fit

          // Rotate and skip the labels if necessary
          if (isHoriz) {
            // horizontal axis
            if (rotationEnabled) {
              if (labelsOverlapping) {
                this._labels[level] = this._rotateLabels(
                  labels,
                  container,
                  firstLabelDim.h / 2,
                  level
                );
              } else {
                resetOverflow ? this._setOverflow(startOverflow, endOverflow, labels) : null;
                this._labels[level] = labels; // all labels can fit
                if (isHierarchical) {
                  // Adjust maxHeight for wrapping rotated hierarchical levels
                  var totalHeight = 0;
                  for (j = 0; j < labelDims.length; j++) {
                    if (labelDims[j]) {
                      totalHeight = Math.max(totalHeight, labelDims[j].h);
                    }
                  }
                  this._maxSpace -= totalHeight + gap;
                }
              }
            } else {
              // no rotation
              resetOverflow ? this._setOverflow(startOverflow, endOverflow, labels) : null;
              labelDims = this.GetLabelDims(labels, container); // get actual dims for skipping
              this._labels[level] = this.SkipLabels(labels, labelDims);
            }
          } else {
            // vertical axis
            // Wrapped labels
            if (wrapping) {
              var updateLabelDims = this._sanitizeWrappedText(
                context,
                labelDims,
                labels,
                false,
                isHierarchical
              );

              // Recalculate label dims for skipping
              if (updateLabelDims) labelDims = this.GetLabelDims(labels, container, level);
            }

            this._labels[level] = this.SkipLabels(labels, labelDims);
          }
        }
      }
    }

    /**
     * @override
     */
    getMajorTickCoords() {
      var coords = [],
        coord;

      // when drawing lines between labels, polar charts need gridline drawn after last label, cartesian charts do not.
      var maxIndex = this.Position == 'tangential' ? this.getGroupCount() : this.getGroupCount() - 1;

      for (var i = 0; i < this._levelsArray[0].length; i++) {
        if (this._levelsArray[0][i]) {
          var start = this.getStartIdx(i, 0);
          var end = this.getEndIdx(i, 0);
          /* If placing gridlines at labels, use the coordinates at the labels
           * Else if placing gridlines in between labels, use the value halfway between two consecutive coordinates */
          if (this._renderGridAtLabels) coord = this.getCoordAt(start + (end - start) * 0.5);
          // start == end for non-hierarchical labels
          else coord = end + 0.5 < maxIndex ? this.getCoordAt(end + 0.5) : null;

          if (coord != null) coords.push(coord);
        }
      }
      return coords;
    }

    /**
     * @override
     */
    getMinorTickCoords() {
      var coords = [],
        coord;
      if (!this._levelsArray[1])
        // minor ticks only rendered if two levels exist
        return coords;

      for (var i = 0; i < this._levelsArray[1].length; i++) {
        if (this._levelsArray[1][i]) {
          var start = this.getStartIdx(i, 1);
          var end = this.getEndIdx(i, 1);
          /* If placing gridlines at labels, use the coordinates at the labels
           * Else if placing gridlines in between labels, use the value halfway between two consecutive coordinates */
          if (this._renderGridAtLabels) coord = this.getCoordAt(start + (end - start) * 0.5);
          else coord = end + 0.5 < this.getGroupCount() - 1 ? this.getCoordAt(end + 0.5) : null;

          if (coord != null) coords.push(coord);
        }
      }
      return coords;
    }

    /**
     * @override
     */
    getUnboundedValAt(coord) {
      if (coord == null) return null;

      if (this._groupWidthRatios) {
        // Find the anchor, i.e. the group boundary closest to the coord.
        var anchor = this._borderCoords.length;
        for (var g = 0; g < this._borderCoords.length; g++) {
          if (coord <= this._borderCoords[g]) {
            anchor = g;
            break;
          }
        }
        // Compute the value based on the group width at the anchor.
        if (anchor == 0)
          return this._borderValues[0] - (this._borderCoords[0] - coord) / this._groupWidths[0];
        else
          return (
            this._borderValues[anchor - 1] +
            (coord - this._borderCoords[anchor - 1]) / this._groupWidths[anchor]
          );
      } else {
        // Even group widths
        var incr = (this.EndCoord - this.StartCoord) / (this.MaxValue - this.MinValue);
        return this.MinValue + (coord - this.StartCoord) / incr;
      }
    }

    /**
     * @override
     */
    getUnboundedCoordAt(value) {
      if (value == null) return null;

      if (this._groupWidthRatios) {
        // Find the anchor, i.e. the group boundary closest to the value.
        var anchor = this._borderValues.length;
        for (var g = 0; g < this._borderValues.length; g++) {
          if (value <= this._borderValues[g]) {
            anchor = g;
            break;
          }
        }
        // Compute the coord based on the group width at the anchor.
        if (anchor == 0)
          return this._borderCoords[0] - this._groupWidths[0] * (this._borderValues[0] - value);
        else
          return (
            this._borderCoords[anchor - 1] +
            this._groupWidths[anchor] * (value - this._borderValues[anchor - 1])
          );
      } else {
        // Even group widths
        var incr = (this.EndCoord - this.StartCoord) / (this.MaxValue - this.MinValue);
        return this.StartCoord + (value - this.MinValue) * incr;
      }
    }

    /**
     * Returns the group label for the specified group.
     * @param {number} index The index of the group label within it's level.
     * @param {number} level (optional) The level of the group label.
     * @return {string} The group label.
     */
    getLabelAt(index, level) {
      if (level == null) level = this._numLevels - 1;

      index = Math.round(index);
      if (index < 0) return null;

      var label =
        this._levelsArray[level] && this._levelsArray[level][index]
          ? this._levelsArray[level][index]['item']
          : null;

      if (label) {
        if (label['name']) label = label['name'];
        else if (label['id'] != null)
          // Empty or null group name allowed if id is specified
          label = '';
      }
      return label;
    }

    /**
     * Returns the group name or id for the specified group.
     * @param {number} index The index of the group within it's level.
     * @param {number} level (optional) The level of the group label.
     * @return {string} The group name or id.
     */
    getGroupAt(index, level) {
      if (level == null) level = this._numLevels - 1;

      index = Math.round(index);
      if (index < 0) return null;

      var label =
        this._levelsArray[level] && this._levelsArray[level][index]
          ? this._levelsArray[level][index]['item']
          : null;

      if (label) {
        if (label['id']) return label['id'];
        else if (label['name'] || label['name'] === '') return label['name'];
      }

      return label;
    }

    /**
     * Returns the style for the group label at the specified index and level.
     * @param {number} index The group index.
     * @param {number} level (optional) The level of the group label.
     * @return {dvt.CSSStyle}
     */
    getLabelStyleAt(index, level) {
      var labelStyle = this._getGroupAttribute(index, level, 'labelStyle');

      if (labelStyle) {
        var cssStyle = new dvt.CSSStyle(labelStyle);
        if (!cssStyle.getStyle('font-size'))
          // dvt.BackgroundOutputText needs font-size for adjusting select browser mis-alignment cases
          cssStyle.setStyle('font-size', this.Options['tickLabel']['style'].getStyle('font-size'));
        return cssStyle;
      }
      return null;
    }

    /**
     * @override
     */
    getDatatip(index, level) {
      // categorical label datatip is the given shortDesc if it exists
      return this._getGroupAttribute(index, level, 'shortDesc');
    }

    /**
     * @override
     */
    isDrillable(index, level) {
      var drilling = this._getGroupAttribute(index, level, 'drilling');

      if (drilling == 'on') return true;
      else if (drilling == 'off') return false;
      else return this._drilling == 'on' || this._drilling == 'groupsOnly';
    }

    /**
     * Returns a string or an array of groups names/ids of the ancestors of a group label at the given index and level.
     * @param {Number} index The index of the group label within it's level of labels
     * @param {Number=} level The level of the group labels
     * @return {String|Array} The group name/id, or an array of group names/ids.
     * @override
     */
    getGroup(index, level) {
      if (index < 0 || index > this.getGroupCount() - 1) return null;

      if (this._numLevels == 1)
        // skip the expensive computation below
        return this.getGroupAt(index);

      var groupLabels = [];
      if (level == null) level = this._numLevels - 1;
      var startIndex = this.getStartIdx(index, level);
      for (var levelIndex = 0; levelIndex <= level; levelIndex++) {
        var levelArray = this._levelsArray[levelIndex];
        for (var i = 0; i < levelArray.length; i++) {
          if (
            this.getStartIdx(i, levelIndex) <= startIndex &&
            this.getEndIdx(i, levelIndex) >= startIndex
          ) {
            groupLabels.push(this.getGroupAt(i, levelIndex));
            continue;
          }
        }
      }
      if (groupLabels.length > 0)
        return groupLabels.length === 1 && this._numLevels === 1 ? groupLabels[0] : groupLabels;
      return null;
    }

    /**
     * @override
     */
    getLabelBackground(label, context, level) {
      if (level == null) level = this._numLevels - 1;
      var style = label.getCSSStyle();
      if (style) {
        var bgColor = style.getStyle(dvt.CSSStyle.BACKGROUND_COLOR);
        var borderColor = style.getStyle(dvt.CSSStyle.BORDER_COLOR);
        var borderWidth = style.getStyle(dvt.CSSStyle.BORDER_WIDTH);
        var borderRadius = style.getStyle(dvt.CSSStyle.BORDER_RADIUS);

        // Create element for label background if group labelStyle has the background-related attributes that we support
        if (bgColor != null || borderColor != null || borderWidth != null || borderRadius != null) {
          var bboxDims = label.getDimensions();
          var padding = bboxDims.h * 0.15;

          // Chrome & IE handle 'vAlign = bottom' in a way that label and the background are misaligned, this corrects the dvt.Rect
          if (
            (dvt.Agent.engine === 'blink' ||
              dvt.Agent.browser === 'ie' ||
              dvt.Agent.browser === 'edge') &&
            label.getVertAlignment() === dvt.OutputText.V_ALIGN_BOTTOM
          )
            bboxDims.y += bboxDims.h / 2;

          var bbox = new dvt.Rect(
            context,
            bboxDims.x - padding,
            bboxDims.y,
            bboxDims.w + 2 * padding,
            bboxDims.h
          );

          var bgStyle = new dvt.CSSStyle();
          if (bgColor != null) bgStyle.setStyle(dvt.CSSStyle.BACKGROUND_COLOR, bgColor);
          else bbox.setInvisibleFill();
          bgStyle.setStyle(dvt.CSSStyle.BORDER_COLOR, borderColor);
          bgStyle.setStyle(dvt.CSSStyle.BORDER_WIDTH, borderWidth);
          bgStyle.setStyle(dvt.CSSStyle.BORDER_RADIUS, borderRadius);
          bbox.setCSSStyle(bgStyle);

          if (this._isLabelRotated[level]) bbox.setMatrix(label.getMatrix());
          bbox.setMouseEnabled(false);
          return bbox;
        }
        return null;
      } else return null;
    }

    /**
     * Returns the index for the specified group.
     * @param {string} group The group.
     * @return {number} The group index. -1 if the group doesn't exist.
     */
    getGroupIndex(group) {
      if (group == null) return -1;

      var index = -1;
      for (var i = 0; i < this._groupCount; i++) {
        var curGroup = this.getGroup(i);
        var matches =
          group instanceof Array && curGroup instanceof Array
            ? dvt.ArrayUtils.equals(group, curGroup)
            : group == curGroup;
        if (matches) {
          index = i;
          break;
        }
      }
      return index;
    }

    /**
     * @override
     */
    getMinExtent() {
      return 1;
    }

    /**
     * @override
     */
    getGroupWidth() {
      // returns the average group width
      return Math.abs(this.EndCoord - this.StartCoord) / Math.abs(this.MaxValue - this.MinValue);
    }

    /**
     * Returns the number of groups in the specified chart.
     * @return {number}
     */
    getGroupCount() {
      return this._groupCount;
    }

    /**
     * Returns the number of label levels
     * @return {number}
     */
    getNumLevels() {
      return this._numLevels;
    }

    /**
     * Conducts a DFS on a hierarchical group object to update the levelsArray
     * @param {object} groupsArray An array of chart groups
     * @param {number} level The level in the hierarchy
     * @param {object} levelsArray A structure of hierarchical group labels by level
     * @param {number} groupIndex The index of the current group
     * @return {groupIndex} A running count of the number of leaf groups
     * @private
     */
    _generateLevelsArray(groupsArray, level, levelsArray, groupIndex) {
      for (var i = 0; i < groupsArray.length; i++) {
        // Add new array if at first group in a new level
        if (!levelsArray[level]) levelsArray[level] = [];

        // Store object for group
        levelsArray[level].push({
          item: groupsArray[i],
          start: groupIndex,
          end: groupIndex,
          position: i
        });

        if (groupsArray[i] && groupsArray[i]['groups']) {
          var lastIndex = levelsArray[level].length - 1;
          // Find the index of the last innermost group nested within this group item
          var currentLeafIndex = this._generateLevelsArray(
            groupsArray[i]['groups'],
            level + 1,
            levelsArray,
            levelsArray[level][lastIndex]['start']
          );
          if (groupIndex != currentLeafIndex) {
            levelsArray[level][lastIndex]['end'] = currentLeafIndex - 1; // start and end index used for centering group labels
            groupIndex = currentLeafIndex;
          } else groupIndex++;
        } else groupIndex++;
      }
      return groupIndex;
    }

    /**
     * Returns the value for the given attribute for the group item specified by index and level
     * @param {number} index
     * @param {number} level
     * @param {string} attribute The desired atribute
     * @return {string} The value of the desires attribute
     * @private
     */
    _getGroupAttribute(index, level, attribute) {
      if (level == null) level = this._numLevels - 1;
      var groupItem =
        this._levelsArray[level] && this._levelsArray[level][index]
          ? this._levelsArray[level][index]['item']
          : null;
      return groupItem ? groupItem[attribute] : null;
    }

    /**
     * Returns whether or not to render group separators
     * @return {boolean}
     */
    areSeparatorsRendered() {
      return this._areSeparatorsRendered;
    }

    /**
     * Returns the color of the group separators
     * @return {boolean}
     */
    getSeparatorColor() {
      return this._separatorColor;
    }

    /**
     * Returns the start index for the group item specified by index and level
     * @param {number} index
     * @param {number} level
     * @return {number} The start index
     */
    getStartIdx(index, level) {
      if (level == null) level = this._numLevels - 1;
      var startIndex =
        this._levelsArray[level] && this._levelsArray[level][index]
          ? this._levelsArray[level][index]['start']
          : null;
      return startIndex;
    }

    /**
     * Returns the end index for the group item specified by index and level
     * @param {number} index
     * @param {number} level
     * @return {number} The end index
     */
    getEndIdx(index, level) {
      if (level == null) level = this._numLevels - 1;
      var endIndex =
        this._levelsArray[level] && this._levelsArray[level][index]
          ? this._levelsArray[level][index]['end']
          : null;
      return endIndex;
    }

    /**
     * Returns the position for the group item specified by index and level, in reference to it's parent
     * @param {number} index
     * @param {number} level
     * @return {number} The position of the group item in it's parent's array of children
     */
    getPosition(index, level) {
      if (level == null) level = this._numLevels - 1;
      var endIndex =
        this._levelsArray[level] && this._levelsArray[level][index]
          ? this._levelsArray[level][index]['position']
          : null;
      return endIndex;
    }

    /**
     * Returns the group index range and groupData array for the groupPath
     * @param {Array} groupPath
     */
    getItemsRange(groupPath) {
      if (!(groupPath instanceof Array)) {
        groupPath = [groupPath];
      }
      var startIndex = 0;
      var endIndex = this._groupCount;
      var groupData = [];

      for (var i = 0; i < groupPath.length; i++) {
        var searchLevel = this._levelsArray[i];
        var groupId = groupPath[i];
        for (var j = 0; j < searchLevel.length; j++) {
          var itemId = searchLevel[j].item.id ? searchLevel[j].item.id : searchLevel[j].item.name;
          if (itemId === groupId) {
            var start = searchLevel[j].start;
            var end = searchLevel[j].end;

            if (startIndex <= start && endIndex >= end) {
              startIndex = start;
              endIndex = end;
              groupData.push(searchLevel[j].item);
            }
          }
        }
      }
      return { startIndex: startIndex, endIndex: endIndex, groupData: groupData };
    }

    /**
     * Returns whether or not the axis is shifted
     * @return {boolean}
     */
    isRenderGridAtLabels() {
      return this._renderGridAtLabels;
    }

    /**
     * Store the index of the innermost level that was able to be rendered
     * @param {number} level The innermost level rendered
     */
    setLastRenderedLevel(level) {
      this._lastRenderedLevel = level;
    }

    /**
     * Returns the index of the innermost level that was able to be rendered
     * @return {number} The innermost level rendered
     */
    getLastRenderedLevel() {
      return this._lastRenderedLevel;
    }

    /**
     * Returns the index of the level there we will begin to draw hierarchical group separators
     * @return {number} The group separators start level
     */
    getSeparatorStartLevel() {
      var startLevel = this._lastRenderedLevel;

      // The start level of the separators may itself have skipped labels, but all levels after must not skip labels
      // We reset the startLevel when we find a level that skips labels
      for (var i = this._lastRenderedLevel - 1; i >= 0; i--) {
        if (this._labels[i].length != this._levelsArray[i].length) startLevel = i;
      }

      return startLevel;
    }

    /**
     * Returns the true index of the given group label
     * @param {dvt.OutputText} label The group label
     * @return {Number} The index of the group label in regards to it's position in it's level of labels
     */
    getLabelIdx(label) {
      return label._index >= 0 ? label._index : null;
    }

    /**
     * Returns the maximum lines allowed for wrapped labels.
     * @return {number}
     */
    getMaxLineWrap() {
      return this._maxLineWrap;
    }

    /**
     * Returns whether or not we should attempt to wrap a horizontal multiline text object
     * @param {dvt.Context} context
     * @param {String} label The label string of the text object
     * @param {dvt.CSSStyle} style The cssstyle of the text object
     * @param {Boolean} rotationEnabled Whether or not the text object is on an axis that enables label rotation
     * @param {Number} maxWidth The maximum width that will be given to the text object to wrap horizontally
     * @return {boolean}
     * @private
     */
    _isTextWrapNeeded(context, label, style, rotationEnabled, maxWidth) {
      var textWidth = dvt.TextUtils.getTextStringWidth(context, label, style);

      // Only attempt to wrap text horizontally if:
      // 1. The textWidth is longer that the maxWidth.
      // 2. The maximum possible width of each potential wrapped line is less than the maxWidth,
      //    or rotation is not enabled.
      // Note: This estimate may still attempt to wrap text that may not fully fit and eventually be rotated
      if (textWidth >= maxWidth && (textWidth / this._maxLineWrap < maxWidth || !rotationEnabled))
        return true;

      return false;
    }

    /**
     * Returns whether or not labels will be rotated automatically.
     * @return {boolean}
     */
    isAutoRotate() {
      var isHoriz = this.Position == 'top' || this.Position == 'bottom';
      var isHierarchical = this._numLevels > 1;
      var groupWidth = this.getGroupWidth();
      var rotationEnabled = this.Options['tickLabel']['rotation'] == 'auto' && isHoriz;
      return !isHierarchical && rotationEnabled && groupWidth < this._ROTATE_THRESHOLD;
    }

    /**
     * Returns the number by which labels can be safely skipped to improve performance.
     * @return {number}
     */
    getSkipIncrement() {
      // increase performance by only measuring a subset of labels to begin with, as majority will be skipped.
      var increment = 1;
      increment = this._ROTATE_THRESHOLD / (2 * this.getGroupWidth());
      if (this.Options['_duringZoomAndScroll']) {
        increment *= 4; // during animation, the labels can be more sparse to increase performance
      }
      return Math.max(1, Math.floor(increment));
    }
  }

  DvtAxisInfo.registerConstructor('group', DvtGroupAxisInfo);

  /**
   *  Provides automation services for a DVT component.
   *  @class DvtAxisAutomation
   *  @param {DvtAxis} dvtComponent
   *  @implements {dvt.Automation}
   *  @constructor
   */

  class DvtAxisAutomation extends dvt.Automation {
    constructor(dvtComponent) {
      super(dvtComponent);
      this._options = this._comp.getOptions();
      this._axisInfo = this._comp.getInfo();
    }

    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>item[groupIndex0]...[groupIndexN]</li>
     * <li>title</li>
     * </ul>
     * @override
     */
    GetSubIdForDomElement(displayable) {
      var logicalObj = this._comp.getEventManager().GetLogicalObject(displayable);
      if (logicalObj && logicalObj instanceof dvt.SimpleObjPeer) {
        if (logicalObj.getParams().type === 'title')
          // return chart axis title subId
          return 'title';
        else if (this._options.groups) {
          // return group axis label subId
          var level = logicalObj.getParams().level || 0;
          var labelIndex = this._axisInfo.getStartIdx(logicalObj.getParams().index, level);
          var indexList = '';
          // Loop from outermost level to desired level
          for (var levelIdx = 0; levelIdx <= level; levelIdx++) {
            var labels = this._axisInfo.getLabels(this._comp.getCtx(), levelIdx);
            // Find label at each level that belongs in hierarchy for the specified label, and append position to subId index list
            for (var i = 0; i < labels.length; i++) {
              var index = this._axisInfo.getLabelIdx(labels[i]); // true group axis label index
              if (
                this._axisInfo.getStartIdx(index, levelIdx) <= labelIndex &&
                this._axisInfo.getEndIdx(index, levelIdx) >= labelIndex
              ) {
                indexList += '[' + this._axisInfo.getPosition(index, levelIdx) + ']';
              }
            }
          }
          // Return subId
          if (indexList.length > 0) return 'item' + indexList;
        }
      }
      return null;
    }

    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>item[groupIndex0]...[groupIndexN]</li>
     * <li>title</li>
     * </ul>
     * @override
     */
    getDomElementForSubId(subId) {
      if (subId === 'title') {
        // process chart axis title subId
        var title = this._axisInfo.getTitle();
        if (title) return title.getElem();
      } else if (this._axisInfo instanceof DvtGroupAxisInfo) {
        // process group axis label subId
        var numIndices = subId.split('[').length - 1;
        var labelLevel = numIndices - 1;
        var labelIndex = 0;
        var startIndex = 0;
        // Loop from outermost level to specified level
        for (var levelIdx = 0; levelIdx <= labelLevel; levelIdx++) {
          var openParen = subId.indexOf('[');
          var closeParen = subId.indexOf(']');
          var groupIndex = Number(subId.substring(openParen + 1, closeParen));
          subId = subId.substring(closeParen + 1);
          var labels = this._axisInfo.getLabels(this._comp.getCtx(), levelIdx);
          var index; // true group axis label index
          for (var j = 0; j < labels.length; j++) {
            index = this._axisInfo.getLabelIdx(labels[j]);
            if (this._axisInfo.getStartIdx(index, levelIdx) === startIndex) {
              labelIndex = index;
              break;
            }
          }
          for (var i = labelIndex; i < labels.length; i++) {
            index = this._axisInfo.getLabelIdx(labels[i]);
            if (this._axisInfo.getPosition(index, levelIdx) === groupIndex) {
              if (subId.length === 0) return labels[i].getElem();
              else startIndex = this._axisInfo.getStartIdx(index, levelIdx);
              break;
            }
          }
        }
      }
      return null;
    }

    /**
     * Returns the logical object belonging to the axis label corresponding to the groupId.
     * @param {Array<string>} groupId An array of group ids associated with the axisLabel
     * @return {object} obj Logical object used corresponding to axis label belonging to groupId
     */
    findPeerFromGroupId(groupId) {
      let objs = this._comp._navigablePeers;
      for (let i = 0; i < objs.length; i++) {
        let obj = objs[i];

        if (
          (typeof obj._group === 'string' && groupId.length === 1 && groupId[0] === obj._group) ||
          (Array.isArray(obj._group) && dvt.ArrayUtils.equals(obj._group, groupId))
        ) {
          return obj;
        }
      }
      return null;
    }

    /**
     * Dispatches synthetic drill event from axis label. Used by webdriver.
     * @param {Array<string> } groupId An array of group ids associated with the axisLabel
     */

    dispatchDrillEvent(groupId) {
      let obj = this.findPeerFromGroupId(groupId);
      this._comp.getEventManager().processDrillEvent(obj);
    }
  }

  /**
   *  @param {dvt.EventManager} manager The owning dvt.EventManager
   *  @param {DvtAxis} axis
   *  @class DvtAxisKeyboardHandler
   *  @extends {dvt.KeyboardHandler}
   *  @constructor
   */
  class DvtAxisKeyboardHandler extends dvt.KeyboardHandler {
    constructor(manager, axis) {
      super(manager);
      this._axis = axis;
    }

    /**
     * @override
     */
    processKeyDown(event) {
      var keyCode = event.keyCode;
      var currentNavigable = this._eventManager.getFocus();
      var nextNavigable = null;

      if (keyCode === dvt.KeyboardEvent.TAB) {
        if (currentNavigable) {
          dvt.EventManager.consumeEvent(event);
          nextNavigable = currentNavigable;
        }

        // navigate to the default
        var navigables = this._axis.__getKeyboardObjects();
        if (navigables.length > 0) {
          dvt.EventManager.consumeEvent(event);
          nextNavigable = this.getDefaultNavigable(navigables);
        }
      } else if (keyCode === dvt.KeyboardEvent.ENTER) {
        if (currentNavigable) {
          this._eventManager.processDrillEvent(currentNavigable);
          dvt.EventManager.consumeEvent(event);
        }
      } else nextNavigable = super.processKeyDown(event);

      return nextNavigable;
    }
  }

  /**
   * @class
   * @constructor
   * @extends {dvt.BaseComponent}
   */
  class DvtAxis extends dvt.BaseComponent {
    constructor(context, callback, callbackObj) {
      super(context, callback, callbackObj);

      // Create the defaults object
      this.Defaults = new DvtAxisDefaults(context);

      // Create the event handler and add event listeners
      this.EventManager = new DvtAxisEventManager(this);
      this.EventManager.addListeners(this);

      // Set up keyboard handler if the axis is interactive
      this.EventManager.setKeyboardHandler(new DvtAxisKeyboardHandler(this.EventManager, this));

      this._bounds = null;
    }

    /**
     * @override
     * @protected
     */
    SetOptions(options) {
      if (options) {
        var isRendered = options['rendered'] !== 'off';

        // Combine the user options with the defaults and store. If the axis isn't rendered, no need to apply defaults.
        if (isRendered) {
          this.Options = this.Defaults.calcOptions(options);
        } else {
          // Convert user option object styles to CSSStyle
          options.tickLabel.style = new dvt.CSSStyle(options.tickLabel.style);
          options.titleStyle = new dvt.CSSStyle(options.titleStyle);
          this.Options = options;
        }
      } else if (!this.Options)
        // Create a default options object if none has been specified
        this.Options = this.GetDefaults();

      // cache isRtl value
      this.Options.isRTL = dvt.Agent.isRightToLeft(this.getCtx());
    }

    /**
     * Returns the preferred dimensions for this component given the maximum available space.
     * @param {object} options The object containing specifications and data for this component.
     * @param {Number} maxWidth The maximum width available.
     * @param {Number} maxHeight The maximum height available.
     * @param {boolean} ignoreRenderedOption rendered= "off" will be ignored if this is true
     * @return {dvt.Dimension} The preferred dimensions for the object.
     */
    getPreferredSize(options, maxWidth, maxHeight, ignoreRenderedOption) {
      // Update the options object.
      this.SetOptions(options);

      // Ask the axis to render its context in the max space and find the space used
      return DvtAxisRenderer.getPreferredSize(this, maxWidth, maxHeight, ignoreRenderedOption);
    }

    /**
     * Renders the component at the specified size.
     * @param {object} options The object containing specifications and data for this component.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     * @param {number=} x x position of the component.
     * @param {number=} y y position of the component.
     */
    render(options, width, height, x, y) {
      this.getCache().clearCache();

      // Update the options object.
      this.SetOptions(options);
      this._navigablePeers = [];

      this.Width = width;
      this.Height = height;

      // Clear any contents rendered previously
      this.removeChildren();

      // Set default values to undefined properties.
      if (!x) {
        x = 0;
      }

      if (!y) {
        y = 0;
      }

      // Render the axis
      var availSpace = new dvt.Rectangle(x, y, width, height);
      DvtAxisRenderer.render(this, availSpace);
    }

    /**
     * Registers the object peer with the axis.  The peer must be registered to participate
     * in interactivity.
     * @param {DvtAxisObjPeer} peer
     */
    __registerObject(peer) {
      // peer is navigable if associated with axis item using datatip or drilling is enabled
      if (peer.getDatatip() != null || peer.isDrillable()) this._navigablePeers.push(peer);
    }

    /**
     * Returns the keyboard navigables within the axis.
     * @return {array}
     */
    __getKeyboardObjects() {
      return this._navigablePeers;
    }

    /**
     * Returns whether or not the axis has navigable peers
     * @return {boolean}
     */
    isNavigable() {
      return this._navigablePeers.length > 0;
    }

    /**
     * Returns the keyboard-focused object of the axis
     * @return {DvtKeyboardNavigable} The focused object.
     */
    getKeyboardFocus() {
      if (this.EventManager != null) return this.EventManager.getFocus();
      return null;
    }

    /**
     * Sets the navigable as the keyboard-focused object of the axis. It matches the id in case it has been rerendered.
     * @param {DvtKeyboardNavigable} navigable The focused object.
     * @param {boolean} isShowingFocusEffect Whether the keyboard focus effect should be used.
     */
    setKeyboardFocus(navigable, isShowingFocusEffect) {
      if (this.EventManager == null) return;

      var peers = this.__getKeyboardObjects();
      var id = navigable.getId();
      var matchFound = false;
      for (var i = 0; i < peers.length; i++) {
        var otherId = peers[i].getId();
        if (
          (id instanceof Array && otherId instanceof Array && dvt.ArrayUtils.equals(id, otherId)) ||
          id === otherId
        ) {
          this.EventManager.setFocusObj(peers[i]);
          matchFound = true;
          if (isShowingFocusEffect) peers[i].showKeyboardFocusEffect();
          break;
        }
      }
      if (!matchFound)
        this.EventManager.setFocusObj(
          this.EventManager.getKeyboardHandler().getDefaultNavigable(peers)
        );

      // Update the accessibility attributes
      var focus = this.getKeyboardFocus();
      if (focus) {
        var displayable = focus.getDisplayable();
        displayable.setAriaProperty('label', focus.getAriaLabel());
        this.getCtx().setActiveElement(displayable);
      }
    }

    /**
     * Processes the specified event.
     * @param {object} event
     * @param {object} source The component that is the source of the event, if available.
     */
    processEvent(event, source) {
      // Dispatch the event to the callback if it originated from within this component.
      if (this === source) {
        this.dispatchEvent(event);
      }
    }

    /**
     * Returns the axisInfo for the axis
     * @return {DvtAxisInfo} the axisInfo
     */
    getInfo() {
      return this.Info;
    }

    /**
     * Sets the object containing calculated axis information and support
     * for creating drawables.
     * @param {DvtAxisInfo} axisInfo
     */
    __setInfo(axisInfo) {
      this.Info = axisInfo;
    }

    /**
     * Returns the axis width
     * @return {number}
     */
    getWidth() {
      return this.Width;
    }

    /**
     * Returns the axis height
     * @return {number}
     */
    getHeight() {
      return this.Height;
    }

    /**
     * Stores the bounds for this axis
     * @param {dvt.Rectangle} bounds
     */
    __setBounds(bounds) {
      this._bounds = bounds;
    }

    /**
     * Returns the bounds for this axis
     * @return {dvt.Rectangle} the object containing the bounds for this axis
     */
    __getBounds() {
      return this._bounds;
    }

    /**
     * Returns the automation object for this axis
     * @return {dvt.Automation} The automation object
     */
    getAutomation() {
      return new DvtAxisAutomation(this);
    }

    /**
     * Returns a copy of the default options for the specified skin.
     * @param {string} skin The skin whose defaults are being returned.
     * @return {object} The object containing defaults for this component.
     */
    static getDefaults(skin) {
      return new DvtAxisDefaults().getDefaults(skin);
    }
  }

  const DvtChartBehaviorUtils = {
    /**
     * Returns the hide and show behavior for the specified chart.
     * @param {Chart} chart
     * @return {string}
     */
    getHideAndShowBehavior: (chart) => {
      return chart.getOptions()['hideAndShowBehavior'];
    },

    /**
     * Returns the hover behavior for the specified chart.
     * @param {Chart} chart
     * @return {string}
     */
    getHoverBehavior: (chart) => {
      return chart.getOptions()['hoverBehavior'];
    },

    /**
     * Returns whether scroll is enabled.
     * @param {Chart} chart
     * @return {boolean}
     */
    isScrollable: (chart) => {
      if (!DvtChartTypeUtils.isScrollSupported(chart)) return false;
      return chart.getOptions()['zoomAndScroll'] != 'off';
    },

    /**
     * Returns whether zoom is enabled.
     * @param {Chart} chart
     * @return {boolean}
     */
    isZoomable: (chart) => {
      if (!DvtChartTypeUtils.isScrollSupported(chart)) return false;
      var zs = chart.getOptions()['zoomAndScroll'];
      return zs == 'live' || zs == 'delayed';
    },

    /**
     * Returns the zoom direction of the chart.
     * @param {Chart} chart
     * @return {string}
     */
    getZoomDir: (chart) => {
      if (DvtChartTypeUtils.isScatterBubble(chart)) return chart.getOptions()['zoomDirection'];
      else return 'auto';
    },

    /**
     * Returns whether zoom/scroll is live.
     * @param {Chart} chart
     * @return {boolean}
     */
    isLiveScroll: (chart) => {
      if (!DvtChartTypeUtils.isScrollSupported(chart)) return false;
      var zs = chart.getOptions()['zoomAndScroll'];
      return zs == 'live' || zs == 'liveScrollOnly';
    },

    /**
     * Returns whether zoom/scroll is delayed.
     * @param {Chart} chart
     * @return {boolean}
     */
    isDelayedScroll: (chart) => {
      if (!DvtChartTypeUtils.isScrollSupported(chart)) return false;
      var zs = chart.getOptions()['zoomAndScroll'];
      return zs == 'delayed' || zs == 'delayedScrollOnly';
    },

    /**
     * Returns whether items in plotarea are draggable.
     * @param {Chart} chart
     * @return {boolean}
     */
    isPlotAreaDraggable: (chart) => {
      var options = chart.getOptions();
      var chartDrag = options['dnd'] ? options['dnd']['drag']['items'] : {}; // for draggable effect
      return Object.keys(chartDrag).length > 0;
    },

    /**
     * Returns whether plot area is a drop target.
     * @param {Chart} chart
     * @return {boolean}
     */
    isPlotAreaDropTarget: (chart) => {
      var options = chart.getOptions();
      var chartDrop = options['dnd'] ? options['dnd']['drop']['plotArea'] : {}; // for drop effect
      return Object.keys(chartDrop).length > 0;
    },

    /**
     * Returns whether horizontal scrollbar is supported for the chart type
     * @param {Chart} chart
     * @return {boolean}
     */
    isHorizScrollbarSupported: (chart) => {
      var direction = DvtChartBehaviorUtils.getZoomDir(chart);
      if (DvtChartTypeUtils.isPolar(chart)) return false;
      return (
        (DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.isVertical(chart)) ||
        (DvtChartTypeUtils.isScatterBubble(chart) && direction != 'y')
      );
    },

    /**
     * Returns whether vertical scrollbar is supported for the chart type
     * @param {Chart} chart
     * @return {boolean}
     */
    isVertScrollbarSupported: (chart) => {
      var direction = DvtChartBehaviorUtils.getZoomDir(chart);
      if (DvtChartTypeUtils.isPolar(chart)) return false;
      return (
        (DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.isHorizontal(chart)) ||
        (DvtChartTypeUtils.isScatterBubble(chart) && direction != 'x')
      );
    }
  };

  /**
   * Text related utility functions.
   * @class
   */
  const DvtChartTextUtils = {
    /**
     * Creates and adds a dvt.Text object to a container. Will truncate and add tooltip as necessary.
     * @param {dvt.EventManager} eventManager
     * @param {dvt.Container} container The container to add the text object to.
     * @param {String} textString The text string of the text object.
     * @param {dvt.CSSStyle} cssStyle The css style to apply to the text object.
     * @param {number} x The x coordinate of the text object.
     * @param {number} y The y coordinate of the text object.
     * @param {number} width The width of available text space.
     * @param {number} height The height of the available text space.
     * @return {dvt.Text} The created text object. Can be null if no text object could be created in the given space.
     */
    createText: (eventManager, container, textString, cssStyle, x, y, width, height) => {
      var text = new dvt.OutputText(container.getCtx(), textString, x, y);
      text.setCSSStyle(cssStyle);

      if (dvt.TextUtils.fitText(text, width, height, container)) {
        // Associate with logical object to support truncation
        eventManager.associate(text, new dvt.SimpleObjPeer(text.getUntruncatedTextString()));
        return text;
      }
      return null;
    },
    /**
     * Returns whether the chart has title, subtitle, or footnote.
     * @param {Chart} chart
     * @return {boolean} True if the chart has title, subtitle, or footnote.
     */
    areTitlesRendered: (chart) => {
      var options = chart.getOptions();
      return options['title']['text'] || options['subtitle']['text'] || options['footnote']['text'];
    },

    /**
     * Renders the empty text for the component.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    renderEmptyText: (chart, container, availSpace) => {
      // Get the empty text string
      var options = chart.getOptions();
      if (DvtChartDataUtils.hasInvalidTimeData(chart) && DvtChartDataUtils.hasData(chart))
        var emptyTextStr = options.translations.labelInvalidData;
      else {
        emptyTextStr = options['emptyText'];
        if (!emptyTextStr) {
          emptyTextStr = options.translations.labelNoData;
        }
      }

      chart.renderEmptyText(
        container,
        emptyTextStr,
        new dvt.Rectangle(availSpace.x, availSpace.y, availSpace.w, availSpace.h),
        chart.getEventManager(),
        options['_statusMessageStyle']
      );
    }
  };

  /**
   * Axis related utility functions for Chart.
   * @class
   */
  const DvtChartAxisUtils = {
    /**
     * Returns the position of the x axis relative to the chart.
     * @param {Chart} chart
     * @return {string} The axis position
     */
    getXAxisPos: (chart) => {
      if (DvtChartTypeUtils.isPolar(chart)) return 'tangential';
      if (DvtChartTypeUtils.isHorizontal(chart))
        return dvt.Agent.isRightToLeft(chart.getCtx()) ? 'right' : 'left';
      return 'bottom';
    },

    /**
     * Returns the baselineScaling of the specified axis.
     * @param {DvtChartImpl} chart
     * @param {string} type The axis type: x, y, or y2
     * @return {string} The axis position
     */
    getBaselineScaling: (chart, type) => {
      var axis = type + 'Axis';
      var baselineScaling = chart.getOptions()[axis]['baselineScaling'];
      if (baselineScaling && (baselineScaling == 'zero' || baselineScaling == 'min'))
        return baselineScaling;
      else if (DvtChartTypeUtils.isStock(chart)) return 'min';
      return 'zero';
    },

    /**
     * Returns the position of the y axis relative to the chart.
     * @param {Chart} chart
     * @return {string} The axis position
     */
    getYAxisPos: (chart) => {
      var position = chart.getOptions()['yAxis']['position'];

      if (DvtChartTypeUtils.isPolar(chart)) return 'radial';
      else if (DvtChartTypeUtils.isHorizontal(chart)) {
        if (position && (position == 'top' || position == 'bottom')) return position;
        return 'bottom';
      }

      if (DvtChartTypeUtils.isStock(chart)) position = position ? position : 'end';
      if (!dvt.Agent.isRightToLeft(chart.getCtx()))
        return position && position == 'end' ? 'right' : 'left';
      return position && position == 'end' ? 'left' : 'right';
    },

    /**
     * Returns the position of the y2 axis relative to the chart.
     * @param {Chart} chart
     * @return {string} The axis position
     */
    getY2AxisPos: (chart) => {
      var position = chart.getOptions()['y2Axis']['position'];

      if (DvtChartTypeUtils.isHorizontal(chart)) {
        if (position && (position == 'top' || position == 'bottom')) return position;
        return 'top';
      }

      if (!dvt.Agent.isRightToLeft(chart.getCtx()))
        return position && position == 'start' ? 'left' : 'right';
      return position && position == 'start' ? 'right' : 'left';
    },

    /**
     * Returns the offset before and after the groups for the specified chart.
     * @param {Chart} chart
     * @return {number} The offset factor.
     */
    getAxisOffset: (chart) => {
      // Use the cached value if it has been computed before
      var cacheKey = 'axisOffset';
      var axisOffset = chart.getCache().getFromCache(cacheKey);
      if (axisOffset != null) return axisOffset;

      var groupSeparators = chart.getOptions()['styleDefaults']['groupSeparators'];
      if (
        DvtChartTypeUtils.hasGroupAxis(chart) &&
        DvtChartDataUtils.getNumLevels(chart) > 1 &&
        groupSeparators['rendered'] == 'on'
      ) {
        // Use 0.5 offset for hierarchical group axis charts with groupSeparators, to ensure even spacing of the separators at start and end.
        axisOffset = 0.5;
      } else if (
        DvtChartDataUtils.hasBarSeries(chart) ||
        DvtChartStyleUtils.hasCenteredSeries(chart) ||
        DvtChartDataUtils.hasCandlestickSeries(chart) ||
        DvtChartDataUtils.hasBoxPlotSeries(chart) ||
        (DvtChartTypeUtils.isBLAC(chart) && DvtChartDataUtils.getGroupCount(chart) == 1)
      ) {
        // Use the offset for any chart with bars or centered lines/areas, or for single point line/area chart
        axisOffset = 0.5;
      } else if (
        !DvtChartTypeUtils.isSpark(chart) &&
        !DvtChartBehaviorUtils.isScrollable(chart) &&
        !DvtChartTypeUtils.isOverview(chart)
      ) {
        // Also add offset for line/area charts
        var maxOffset = DvtChartTypeUtils.isHorizontal(chart) ? 0.2 : 0.5;
        axisOffset = maxOffset - maxOffset / Math.sqrt(DvtChartDataUtils.getGroupCount(chart));
      } else {
        // Otherwise no offset
        axisOffset = 0;
      }

      chart.getCache().putToCache(cacheKey, axisOffset);
      return axisOffset;
    },

    /**
     * Returns whether the grid lines should be shifted by 1/2, so that the grid lines are drawn between labels, instead of
     * at labels. True if all the series are either bars or centeredSegmented/centeredStepped lines/areas.
     * @param {Chart} chart
     * @return {boolean}
     */
    isGridShifted: (chart) => {
      if (!DvtChartTypeUtils.isBLAC(chart)) return false;

      // Hierarchical charts will render grid lines between labels by default
      if (DvtChartDataUtils.getNumLevels(chart) > 1) return true;

      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (var i = 0; i < seriesCount; i++) {
        // Ignore the series if it isn't rendered
        if (!DvtChartDataUtils.isSeriesRendered(chart, i)) continue;
        var seriesType = DvtChartDataUtils.getSeriesType(chart, i);
        var lineType = DvtChartStyleUtils.getLineType(chart, i);
        if (seriesType != 'bar' && lineType != 'centeredSegmented' && lineType != 'centeredStepped')
          return false;
      }

      return true;
    },

    /**
     * Returns whether the polar chart gridlines are polygonal.
     * @param {DvtChartImp} chart
     * @return {boolean}
     */
    isGridPolygonal: (chart) => {
      if (!DvtChartTypeUtils.isBLAC(chart) || DvtChartDataUtils.hasBarSeries(chart)) return false;
      return chart.getOptions()['polarGridShape'] == 'polygon';
    },

    /**
     * Returns whether an axis is rendered (only tick labels and axis title are considered parts of the axis).
     * @param {Chart} chart
     * @param {string} type The axis type: x, y, or y2.
     * @return {boolean} True if the axis is rendered.
     */
    isAxisRendered: (chart, type) => {
      // Check if the current chart type supports having axes
      if (!DvtChartTypeUtils.hasAxes(chart)) {
        return false;
      }

      var options = chart.getOptions();
      var ovContent = options.overview.content && options.overview.content[type + 'Axis'];
      var ignoreRenderedOption = ovContent && ovContent.rendered == 'on';
      // For y/y2, evaluate if there's any series assigned to them
      if (type == 'y' && DvtChartDataUtils.hasY2DataOnly(chart) && !ignoreRenderedOption)
        return false;
      if (type == 'y2' && !DvtChartDataUtils.hasY2Data(chart) && !ignoreRenderedOption) return false;

      // Check the chart options
      var axisOptions = options[type + 'Axis'];
      if (axisOptions['rendered'] == 'off' && !ignoreRenderedOption) return false;
      if (
        axisOptions['tickLabel']['rendered'] == 'off' &&
        !axisOptions['title'] &&
        !ignoreRenderedOption
      )
        return false;

      return true;
    },

    /**
     * Returns true if the axis line for the specified axis is to be rendered.
     * @param {Chart} chart
     * @param {string} type The axis type: x, y, or y2.
     * @return {boolean}
     */
    isAxisLineRendered: (chart, type) => {
      var axisOptions = chart.getOptions()[type + 'Axis'];
      if (axisOptions['rendered'] == 'off' || axisOptions['axisLine']['rendered'] == 'off')
        return false;
      else if (
        axisOptions['axisLine']['rendered'] == 'auto' &&
        type != 'x' &&
        DvtChartTypeUtils.isBLAC(chart) &&
        !DvtChartTypeUtils.isPolar(chart)
      )
        return false; // yAxis lines not rendered for blac cartesian with axisLine.rendered="auto"
      return true;
    },

    /**
     * Returns true if the major tick for the specified axis is to be rendered.
     * @param {Chart} chart
     * @param {string} type The axis type: x, y, or y2.
     * @return {boolean}
     */
    isMajorTickRendered: (chart, type) => {
      var axisOptions = chart.getOptions()[type + 'Axis'];
      if (axisOptions['rendered'] == 'off' || axisOptions['majorTick']['rendered'] == 'off')
        return false;
      else if (
        axisOptions['majorTick']['rendered'] == 'auto' &&
        type == 'x' &&
        DvtChartTypeUtils.isBLAC(chart) &&
        !DvtChartTypeUtils.isPolar(chart)
      )
        return false; // xAxis ticks not rendered for blac cartesian with axisLine.rendered="auto"
      return true;
    },

    /**
     * Returns true if the minor tick for the specified axis is to be rendered.
     * @param {Chart} chart
     * @param {string} type The axis type: x, y, or y2.
     * @return {boolean}
     */
    isMinorTickRendered: (chart, type) => {
      var axisOptions = chart.getOptions()[type + 'Axis'];
      if (axisOptions['rendered'] == 'off' || axisOptions['minorTick']['rendered'] == 'off')
        return false;
      else if (axisOptions['minorTick']['rendered'] == 'on') return true;
      return DvtChartAxisUtils.isLog(chart, type);
    },

    /**
     * Returns true if the axis scale is logarithmic.
     * @param {Chart} chart
     * @param {string} type The axis type: x, y, or y2.
     * @return {boolean}
     */
    isLog: (chart, type) => {
      var axisOptions = chart.getOptions()[type + 'Axis'];
      return axisOptions['scale'] == 'log';
    },

    /**
     * Returns the height of the axis tick label
     * @param {Chart} chart
     * @param {string} type The axis type: x, y, or y2
     * @return {number} Height in px
     */
    getTickLabelHeight: (chart, type) => {
      var options = chart.getOptions();
      var axisOptions = options[type + 'Axis'];

      // Manually construct the tick label style
      var tickLabelStyle = axisOptions['tickLabel']['style'];
      if (!(tickLabelStyle instanceof dvt.CSSStyle))
        tickLabelStyle = new dvt.CSSStyle(tickLabelStyle);
      tickLabelStyle.mergeUnder(DvtAxis.getDefaults(options['skin'])['tickLabel']['style']); // merge with the default

      return dvt.TextUtils.getTextStringHeight(chart.getCtx(), tickLabelStyle);
    },

    /**
     * Returns the tick label gap size for the axis.
     * @param {Chart} chart
     * @param {string} type The type of the axis: x, y, or y2.
     * @return {number} Gap size.
     */
    getTickLabelGapSize: (chart, type) => {
      if (DvtChartAxisUtils.isTickLabelInside(chart, type)) return 0;

      var options = chart.getOptions();
      var isHoriz = DvtChartTypeUtils.isHorizontal(chart);

      var scalingFactor = DvtChartAxisUtils.getGapScalingFactor(chart, type);
      var gapWidth = Math.ceil(options['layout']['tickLabelGapWidth'] * scalingFactor);
      var gapHeight = Math.ceil(options['layout']['tickLabelGapHeight'] * scalingFactor);

      if (type == 'x') return isHoriz ? gapWidth : gapHeight;
      return isHoriz ? gapHeight : gapWidth;
    },

    /**
     * Returns the scaling factor for a gap based on the axis tick label font size.
     * @param {Chart} chart
     * @param {string} type The type of the axis: x, y, or y2.
     * @return {number} Scaling factor.
     */
    getGapScalingFactor: (chart, type) => {
      if (DvtChartAxisUtils.isAxisRendered(chart, type))
        return DvtChartAxisUtils.getTickLabelHeight(chart, type) / 14; // 14px is the default label height, assuming 11px font size
      return 0;
    },

    /**
     * Returns the position of the axis tick label is inside the plot area.
     * @param {Chart} chart
     * @param {string} type The type of the axis: x, y, or y2.
     * @return {boolean}
     */
    isTickLabelInside: (chart, type) => {
      if (
        DvtChartTypeUtils.isPolar(chart) ||
        DvtChartTypeUtils.isScatterBubble(chart) ||
        (DvtChartTypeUtils.isBLAC(chart) && type == 'x')
      )
        return false;

      return chart.getOptions()[type + 'Axis']['tickLabel']['position'] == 'inside';
    },

    /**
     * Returns the viewport min/max of the x-axis. If viewportMin/Max is not defined, it assumes viewportStart/EndGroup to
     * be the viewport min/max.
     * @param {Chart} chart
     * @param {boolean} useGlobal Whether the method returns the global min/max if the viewport min/max is defined.
     * @return {object} An object containing min and max.
     */
    getXAxisViewportMinMax: (chart, useGlobal) => {
      var cacheKey = useGlobal ? 'xAxisViewportMinMaxUG' : 'xAxisViewportMinMax';
      var minMax = chart.getCache().getFromCache(cacheKey);
      if (minMax) return minMax;

      var options = chart.getOptions()['xAxis'];
      var isGroupAxis = DvtChartTypeUtils.hasGroupAxis(chart);
      var groupOffset = DvtChartAxisUtils.getAxisOffset(chart);

      if (useGlobal) var globalMinMax = DvtChartAxisUtils.getXAxisGlobalMinMax(chart);

      var min = null;
      if (options['viewportMin'] != null) min = options['viewportMin'];
      else if (options['viewportStartGroup'] != null)
        min = isGroupAxis
          ? DvtChartDataUtils.getGroupIdx(chart, options['viewportStartGroup']) - groupOffset
          : options['viewportStartGroup'];
      else if (useGlobal) {
        min = globalMinMax['min'];
      }

      var max = null;
      if (options['viewportMax'] != null) max = options['viewportMax'];
      else if (options['viewportEndGroup'] != null)
        max = isGroupAxis
          ? DvtChartDataUtils.getGroupIdx(chart, options['viewportEndGroup']) + groupOffset
          : options['viewportEndGroup'];
      else if (useGlobal) {
        max = globalMinMax['max'];
      }

      // Cache the value
      minMax = { min: min, max: max };
      chart.getCache().putToCache(cacheKey, minMax);

      return minMax;
    },

    /**
     * Returns the global min/max of the x-axis.
     * @param {Chart} chart
     * @return {object} An object containing min and max.
     */
    getXAxisGlobalMinMax: (chart) => {
      var options = chart.getOptions()['xAxis'];
      var isGroupAxis = DvtChartTypeUtils.hasGroupAxis(chart);
      var groupOffset = DvtChartAxisUtils.getAxisOffset(chart);

      if (!isGroupAxis) var minMax = DvtChartAxisUtils.getMinMaxVal(chart, 'x');

      var min = null;
      if (options['min'] != null) min = options['min'];
      else if (isGroupAxis) min = 0 - groupOffset;
      else min = minMax['min'];

      var max = null;
      if (options['max'] != null) max = options['max'];
      else if (isGroupAxis) max = DvtChartDataUtils.getGroupCount(chart) - 1 + groupOffset;
      else max = minMax['max'];

      return { min: min, max: max };
    },

    /**
     * Applies the chart initial zooming by updating the viewportMin/Max in the options object.
     * @param {Chart} chart
     * @param {dvt.Rectangle} availSpace The available axis space, to determine the amount of initial zooming.
     */
    applyInitialZooming: (chart, availSpace) => {
      var options = chart.getOptions();
      var axisOptions = options['xAxis'];
      var initialZooming = options['initialZooming'];
      if (
        !DvtChartTypeUtils.isBLAC(chart) ||
        options['zoomAndScroll'] == 'off' ||
        initialZooming == 'none'
      )
        return;

      // If the chart has been initially zoomed before, but is rerendered with the same options (possibly resized), the
      // initial zooming level has the be recomputed.
      if (options['_initialZoomed']) {
        if (initialZooming == 'last') axisOptions['viewportMin'] = null;
        // initialZooming = first
        else axisOptions['viewportMax'] = null;
      }

      var viewportMinMax = DvtChartAxisUtils.getXAxisViewportMinMax(chart, false);
      var viewportMin = viewportMinMax['min'];
      var viewportMax = viewportMinMax['max'];
      if (
        (initialZooming == 'last' && viewportMin != null) ||
        (initialZooming == 'first' && viewportMax != null)
      )
        return;

      var axisWidth = DvtChartTypeUtils.isHorizontal(chart) ? availSpace.h : availSpace.w; // estimated
      var maxNumGroups =
        Math.floor(axisWidth / (2 * DvtChartAxisUtils.getTickLabelHeight(chart, 'x'))) +
        DvtChartAxisUtils.getAxisOffset(chart);
      var numGroups = DvtChartDataUtils.getGroupCount(chart) - 1; // -1 because we count the number of group gaps
      if (numGroups <= maxNumGroups) return;

      var globalMin, globalMax;
      if (DvtChartTypeUtils.hasGroupAxis(chart)) {
        globalMin = 0;
        globalMax = numGroups; // numGroups is already subtracted by 1!
      } else {
        var globalMinMax = DvtChartAxisUtils.getMinMaxVal(chart, 'x');
        globalMin = globalMinMax['min'];
        globalMax = globalMinMax['max'];
      }
      var maxViewportSize = (maxNumGroups / numGroups) * (globalMax - globalMin);

      if (options['initialZooming'] == 'last') {
        if (viewportMax == null) viewportMax = globalMax;
        axisOptions['viewportMin'] = Math.max(viewportMax - maxViewportSize, globalMin);
      } else {
        // initialZooming = first
        if (viewportMin == null) viewportMin = globalMin;
        axisOptions['viewportMax'] = Math.min(viewportMin + maxViewportSize, globalMax);
      }

      // Add flag to indicate that the viewportMin/Max is the result of initial zooming.
      options['_initialZoomed'] = true;
    },

    /**
     * Returns true if the y axis needs to be adjust to account for data labels.
     * @param {Chart} chart
     * @return {boolean}
     */
    isYAdjustmentNeeded: (chart) => {
      var dataLabelPosition = chart.getOptions()['styleDefaults']['dataLabelPosition'];
      var hasDataOutsideBarEdge = chart.getOptionsCache().getFromCache('hasDataOutsideBarEdge');
      var hasOutsideBarEdge = dataLabelPosition == 'outsideBarEdge' || hasDataOutsideBarEdge;
      var isStackLabelRendered = DvtChartStyleUtils.isStackLabelRendered(chart);
      if (DvtChartDataUtils.hasBarSeries(chart) && (hasOutsideBarEdge || isStackLabelRendered)) {
        return true;
      }
      return false;
    },

    /**
     * Whether the axis contains the specified point.
     * @param {DvtAxis} axis
     * @param {dvt.Point} relPos Point coords relative to the stage.
     * @return {boolean}
     */
    axisContainsPoint: (axis, relPos) => {
      if (!axis) return false;

      // Increase the hit area
      var position = axis.getOptions()['position'];
      var isHoriz = position == 'top' || position == 'bottom';
      var yGap = isHoriz ? 4 : 10;
      var xGap = isHoriz ? 10 : 4;

      var bounds = axis.__getBounds().clone();
      bounds.x -= xGap;
      bounds.y -= yGap;
      bounds.w += 2 * xGap;
      bounds.h += 2 * yGap;

      var axisPos = axis.stageToLocal(relPos);
      return bounds.containsPoint(axisPos.x, axisPos.y);
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if the chart is a standalone plot area.
     */
    isStandalonePlotArea: (chart) => {
      if (DvtChartTextUtils.areTitlesRendered(chart)) return false;
      if (DvtChartTypeUtils.isLegendRendered(chart)) return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'x')) return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'y')) return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'y2')) return false;
      return true;
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if the chart is a standalone x-axis.
     */
    isStandaloneXAxis: (chart) => {
      var options = chart.getOptions();
      if (DvtChartTextUtils.areTitlesRendered(chart)) return false;
      if (options['legend']['rendered'] != 'off') return false;
      if (options['plotArea']['rendered'] != 'off') return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'y')) return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'y2')) return false;
      return true;
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if the chart is a standalone y-axis.
     */
    isStandaloneYAxis: (chart) => {
      var options = chart.getOptions();
      if (DvtChartTextUtils.areTitlesRendered(chart)) return false;
      if (options['legend']['rendered'] != 'off') return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'x')) return false;
      if (options['plotArea']['rendered'] != 'off') return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'y2')) return false;
      return true;
    },

    /**
     * @param {Chart} chart
     * @return {boolean} true if the chart is a standalone y2-axis.
     */
    isStandaloneY2Axis: (chart) => {
      var options = chart.getOptions();
      if (DvtChartTextUtils.areTitlesRendered(chart)) return false;
      if (options['legend']['rendered'] != 'off') return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'x')) return false;
      if (DvtChartAxisUtils.isAxisRendered(chart, 'y')) return false;
      if (options['plotArea']['rendered'] != 'off') return false;
      return true;
    },

    /**
     * Returns the min and max groupIndex that are entirely within the chart viewport for the specified seriesIndex.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {object} An object containing min and max properties.
     */
    getViewportMinMaxGroupIdx: (chart, seriesIndex) => {
      var minMaxValue = DvtChartAxisUtils.getXAxisViewportMinMax(chart, true);
      var hasGroupAxis = DvtChartTypeUtils.hasGroupAxis(chart);
      var groupCount = DvtChartDataUtils.getGroupCount(chart);

      var minValue = minMaxValue['min'];
      var minIndex = 0;
      if (minValue != null) {
        if (hasGroupAxis) minIndex = Math.ceil(minValue);
        else {
          // TODO: faster with binary search
          for (var g = 0; g < groupCount; g++) {
            var xValue = DvtChartDataUtils.getXVal(chart, seriesIndex, g);
            if (xValue >= minValue) {
              minIndex = g;
              break;
            }
          }
        }
      }

      var maxValue = minMaxValue['max'];
      var maxIndex = groupCount - 1;
      if (hasGroupAxis) maxIndex = Math.floor(maxValue);
      else {
        // TODO: faster with binary search
        for (var groupIdx = groupCount - 1; groupIdx >= minIndex; groupIdx--) {
          var xVal = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIdx);
          if (xVal <= maxValue) {
            maxIndex = groupIdx;
            break;
          }
        }
      }

      return { min: minIndex, max: maxIndex };
    },

    /**
     * Returns the number of groups within the viewport.
     * @param {Chart} chart
     * @return {number}
     */
    getViewportGroupCount: (chart) => {
      var viewportMinMax = DvtChartAxisUtils.getXAxisViewportMinMax(chart, true);
      var globalMinMax = DvtChartAxisUtils.getXAxisGlobalMinMax(chart);
      var ratio =
        (viewportMinMax['max'] - viewportMinMax['min']) / (globalMinMax['max'] - globalMinMax['min']);
      return isNaN(ratio) ? 1 : ratio * DvtChartDataUtils.getGroupCount(chart);
    },

    /**
     * Compute the Y corresponding to the X along the line from (x1,y1) to (x2,y2).
     * @param {boolean} isLog
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x
     * @return {number} The y value.
     * @private
     */
    _computeYAlongLine: (isLog, x1, y1, x2, y2, x) => {
      if (isLog) {
        y1 = dvt.Math.log10(y1);
        y2 = dvt.Math.log10(y2);
      }
      var y = y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);
      return isLog ? Math.pow(10, y) : y;
    },

    /**
     * Returns the min and max values from the data.
     * @param {Chart} chart
     * @param {string} type The type of value to find: "x", "y", "y2", "z".
     * @param {boolean=} isDataOnly Use data points only in min/max computation. Excludes bubble radii and viewport edge values. Defaults to false.
     * @return {object} An object containing the minValue and the maxValue.
     */
    getMinMaxVal: (chart, type, isDataOnly) => {
      // Use the cached value if it has been computed before
      var cacheKey = type + (isDataOnly ? 'MinMaxDO' : 'MinMax');
      var minMax = chart.getCache().getFromCache(cacheKey);
      if (minMax) return minMax;

      // Use user specified values if set to improve performance
      var axisOptions = chart.getOptions()[type + 'Axis'];
      if (axisOptions['dataMax'] != null && axisOptions['dataMin'] != null && isDataOnly) {
        // Cache the value
        minMax = { min: axisOptions['dataMin'], max: axisOptions['dataMax'] };
        chart.getCache().putToCache(cacheKey, minMax);
        return minMax;
      }

      var hasTimeAxis = DvtChartTypeUtils.hasTimeAxis(chart);
      if (axisOptions['max'] != null && axisOptions['min'] != null && !isDataOnly && !hasTimeAxis) {
        // Cache the value
        minMax = { min: axisOptions['min'], max: axisOptions['max'] };
        chart.getCache().putToCache(cacheKey, minMax);
        return minMax;
      }

      // TODO support for null or NaN values

      var isLog = type != 'z' && DvtChartAxisUtils.isLog(chart, type);

      // Y2 values pull from the y data value
      var isY2Value = type == 'y2';
      if (isY2Value) type = 'y';

      // Y values may be listed directly as numbers
      var isYValue = type == 'y';

      // limitToViewport is computing the min/max based on only the values that are within the viewport.
      // Only implemented for BLAC chart "y" and "y2" axis.
      var limitToViewport = !isDataOnly && isYValue && DvtChartTypeUtils.isBLAC(chart);

      // Include hidden series if hideAndShowBehavior occurs without rescale or for time axis
      var bIncludeHiddenSeries =
        DvtChartBehaviorUtils.getHideAndShowBehavior(chart) == 'withoutRescale' ||
        (type == 'x' && DvtChartTypeUtils.hasTimeAxis(chart));

      var maxValue = -Infinity;
      var minValue = Infinity;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
        var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
        var isRange =
          isYValue &&
          (DvtChartDataUtils.isRangeSeries(chart, seriesIndex) ||
            seriesType == 'candlestick' ||
            seriesType == 'boxPlot');

        // Skip the series if it is hidden
        if (!bIncludeHiddenSeries && !DvtChartDataUtils.isSeriesRendered(chart, seriesIndex))
          continue;

        // Skip the series if it's not assigned to the right y axis
        var isY2Series = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
        if (isYValue && isY2Value != isY2Series) continue;

        // Loop through the data
        var seriesData = seriesItem['items'];
        if (!seriesData) continue;

        var minGroupIndex = 0;
        var maxGroupIndex = seriesData.length - 1;
        if (limitToViewport) {
          var minMaxGroupIndex = DvtChartAxisUtils.getViewportMinMaxGroupIdx(chart, seriesIndex);
          minGroupIndex = minMaxGroupIndex['min'];
          maxGroupIndex = minMaxGroupIndex['max'];
        }

        for (var groupIndex = minGroupIndex; groupIndex <= maxGroupIndex; groupIndex++) {
          // Skip the data item if it is hidden
          if (
            !bIncludeHiddenSeries &&
            !DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex)
          )
            continue;

          var data = seriesData[groupIndex];

          var value = null;
          if (isYValue) {
            if (!isRange)
              value = DvtChartDataUtils.getCumulativeVal(
                chart,
                seriesIndex,
                groupIndex,
                bIncludeHiddenSeries
              );
          } else if (type == 'x' && hasTimeAxis && !DvtChartTypeUtils.isMixedFrequency(chart)) {
            // Take time value from the groups array and transfer it to the data item
            value = DvtChartDataUtils.getGroupLabel(chart, groupIndex);
            if (data != null) data['x'] = value;
          } else if (data != null) value = data[type];

          if (type == 'z' && value <= 0)
            // exclude 0 for bubble radius min/max
            continue;

          if (!isRange && value != null && typeof value == 'number' && !(isLog && value <= 0)) {
            var radius = 0;
            if (DvtChartTypeUtils.isBubble(chart) && !isDataOnly && type != 'z') {
              var markerSize = DvtChartStyleUtils.getMarkerSize(chart, seriesIndex, groupIndex);
              radius = DvtChartAxisUtils.getBubbleAxisRadius(chart, type, markerSize);
            }

            maxValue = Math.max(maxValue, isLog ? value * Math.pow(10, radius) : value + radius);
            minValue = Math.min(minValue, isLog ? value / Math.pow(10, radius) : value - radius);
          }

          if (isRange) {
            var high = DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex);
            var low = DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex);

            if (!(isLog && (high <= 0 || low <= 0))) {
              maxValue = Math.max(maxValue, high, low);
              minValue = Math.min(minValue, high, low);
            }
          }

          // Include the Y values at the X-axis min/max edges of the viewport to make the Y-axis rescale smoothly
          // TODO: Implement for range series
          if (limitToViewport && !isRange) {
            // Computation only applies to first and last group in the viewport. Get the adjacent group just outside
            // the viewport to get the viewport edge value.
            var adjacentIndex = null;
            var edgeX = null;
            if (minGroupIndex > 0 && groupIndex == minGroupIndex) {
              adjacentIndex = groupIndex - 1;
              edgeX = DvtChartAxisUtils.getXAxisViewportMinMax(chart, true)['min'];
            } else if (maxGroupIndex < seriesData.length - 1 && groupIndex == maxGroupIndex) {
              adjacentIndex = groupIndex + 1;
              edgeX = DvtChartAxisUtils.getXAxisViewportMinMax(chart, true)['max'];
            }

            if (adjacentIndex != null) {
              var x = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
              var adjacentX = DvtChartDataUtils.getXVal(chart, seriesIndex, adjacentIndex);
              var adjacentValue = DvtChartDataUtils.getCumulativeVal(
                chart,
                seriesIndex,
                adjacentIndex
              );
              var edgeValue = DvtChartAxisUtils._computeYAlongLine(
                isLog,
                x,
                value || 0,
                adjacentX,
                adjacentValue || 0,
                edgeX
              );
              maxValue = Math.max(maxValue, edgeValue);
              minValue = Math.min(minValue, edgeValue);
            }
          }

          // Only include nested item when type is not x.
          if (type != 'x') {
            var nestedDataCount = DvtChartDataUtils.getNestedDataItemCount(
              chart,
              seriesIndex,
              groupIndex
            );
            if (nestedDataCount > 0) {
              for (var itemIndex = 0; itemIndex < nestedDataCount; itemIndex++) {
                var item = DvtChartDataUtils.getNestedDataItem(
                  chart,
                  seriesIndex,
                  groupIndex,
                  itemIndex
                );
                var isItemNumeric = typeof item === 'number';
                maxValue = isItemNumeric ? Math.max(maxValue, item) : Math.max(maxValue, item.value);
                minValue = isItemNumeric ? Math.min(minValue, item) : Math.min(minValue, item.value);
              }
            }
          }
        }
      }

      //Loop through reference objects and include their min/max values in the calculation
      var refObjects = null;
      if (type == 'x') refObjects = DvtChartDataUtils.getAxisRefObjs(chart, 'x');
      else if (isY2Value)
        // check isY2Value first, because isYValue will also be true
        refObjects = DvtChartDataUtils.getAxisRefObjs(chart, 'y2');
      else if (isYValue) refObjects = DvtChartDataUtils.getAxisRefObjs(chart, 'y');

      if (refObjects != null) {
        for (var i = 0; i < refObjects.length; i++) {
          var refObj = refObjects[i];
          var items = refObj['items']; //reference objects with varied min/max or values have the 'items' object populated
          var hidden =
            DvtChartBehaviorUtils.getHideAndShowBehavior(chart) == 'withRescale' &&
            !DvtChartRefObjUtils.isObjRendered(chart, refObj);
          // If refObj has varied values , loop through and evaluate all values in 'items'
          // Else just evaluate min/max/value on refObj
          if (hidden) continue;

          if (items && !hidden) {
            var minItemIndex = 0;
            var maxItemIndex = items.length - 1;
            if (limitToViewport) {
              var minMaxItemIndex = DvtChartAxisUtils.getViewportMinMaxIdx(chart, items);
              minItemIndex = minMaxItemIndex['min'];
              maxItemIndex = minMaxItemIndex['max'];
            }

            for (var j = minItemIndex; j <= maxItemIndex; j++) {
              if (items[j] == null) continue;

              var refObjLow = DvtChartRefObjUtils.getLowVal(items[j]);
              var refObjHigh = DvtChartRefObjUtils.getHighVal(items[j]);
              var val = isNaN(items[j]) ? items[j]['value'] : items[j];

              if (refObjLow != null && isFinite(refObjLow)) {
                minValue = Math.min(minValue, refObjLow);
                maxValue = Math.max(maxValue, refObjLow);
              }
              if (refObjHigh != null && isFinite(refObjHigh)) {
                minValue = Math.min(minValue, refObjHigh);
                maxValue = Math.max(maxValue, refObjHigh);
              }
              if (val != null && isFinite(val)) {
                minValue = Math.min(minValue, val);
                maxValue = Math.max(maxValue, val);
              }
            }
          } else {
            var refLow = DvtChartRefObjUtils.getLowVal(refObj);
            var refHigh = DvtChartRefObjUtils.getHighVal(refObj);
            var refVal = refObj['value'];
            if (refLow != null && isFinite(refLow)) {
              minValue = Math.min(minValue, refLow);
              maxValue = Math.max(maxValue, refLow);
            }
            if (refHigh != null && isFinite(refHigh)) {
              minValue = Math.min(minValue, refHigh);
              maxValue = Math.max(maxValue, refHigh);
            }
            if (refVal != null && isFinite(refVal)) {
              minValue = Math.min(minValue, refVal);
              maxValue = Math.max(maxValue, refVal);
            }
          }
        }
      }

      // Cache the value
      minMax = { min: minValue, max: maxValue };
      chart.getCache().putToCache(cacheKey, minMax);

      return minMax;
    },

    /**
     * Estimates how much axis range (in values, not pixels) the bubble radius would span.
     * @param {Chart} chart
     * @param {string} axisType 'x' or 'y'
     * @param {number} markerSize The size of the bubble marker
     * @return {number}
     */
    getBubbleAxisRadius: (chart, axisType, markerSize) => {
      if (!markerSize) return 0;
      var cacheKey = axisType == 'x' ? '_xAxisBubbleRatio' : '_yAxisBubbleRatio';
      var axisBubbleRatio = chart.getCache().getFromCache(cacheKey);
      return (markerSize / 2) * axisBubbleRatio;
    },

    /**
     *
     * Returns the min and max ref obj item index that are entirely within the chart viewport.
     * @param {Chart} chart
     * @param {object} items The array of reference object items
     * @return {object} An object containing min and max properties.
     */
    getViewportMinMaxIdx: (chart, items) => {
      var minMaxValue = DvtChartAxisUtils.getXAxisViewportMinMax(chart, true);
      var hasGroupAxis = DvtChartTypeUtils.hasGroupAxis(chart);

      var minValue = minMaxValue['min'];
      var minIndex = 0;
      if (minValue != null) {
        if (hasGroupAxis) minIndex = Math.ceil(minValue);
        else {
          // TODO: faster with binary search
          for (var i = 0; i < items.length; i++) {
            var xValue = DvtChartRefObjUtils.getXVal(chart, items, i);
            if (xValue >= minValue) {
              minIndex = i;
              break;
            }
          }
        }
      }

      var maxValue = minMaxValue['max'];
      var maxIndex = items.length - 1;
      if (hasGroupAxis) maxIndex = Math.floor(maxValue);
      else {
        // TODO: faster with binary search
        for (var z = items.length - 1; z >= minIndex; z--) {
          var xVal = DvtChartDataUtils.getXVal(chart, items, z);
          if (xVal <= maxValue) {
            maxIndex = z;
            break;
          }
        }
      }

      return { min: minIndex, max: maxIndex };
    }
  };

  const DvtChartGroupUtils = {
    /**
     * Computes the ratios of the axis group widths (for bars with varying widths).
     * @param {Chart} chart
     * @return {Array} The array of the axis group width ratios.
     */
    getGroupWidthRatios: (chart) => {
      if (
        !DvtChartDataUtils.hasBarSeries(chart) &&
        !DvtChartDataUtils.hasCandlestickSeries(chart) &&
        !DvtChartDataUtils.hasBoxPlotSeries(chart)
      )
        return null;

      var options = chart.getOptions();
      var barGapRatio = DvtChartGroupUtils.getBarGapRatio(chart);

      if (barGapRatio >= 1) {
        options['_averageGroupZ'] = Infinity; // so that all bars have zero width
        return null;
      }

      options['_averageGroupZ'] = 0; // reset the value

      // Compute the total z-values of the bars occupying each group
      var numGroups = DvtChartDataUtils.getGroupCount(chart);
      var isSplitDualY = DvtChartDataUtils.isSplitDualY(chart);
      var categories = DvtChartDataUtils.getStackCategories(chart, 'bar');
      var numYCategories = categories['y'].length;
      var numY2Categories = categories['y2'].length;
      var groupWidths, yWidth, y2Width, i;

      var barWidthSum, gapWidthSum;
      var hasConstantZValue = chart.getOptionsCache().getFromCache('hasConstantZValue');

      if (hasConstantZValue) {
        var constantZValue = chart.getOptionsCache().getFromCache('constantZValue');
        var barWidth =
          constantZValue *
          (isSplitDualY
            ? Math.max(numYCategories, numY2Categories)
            : numYCategories + numY2Categories);
        barWidthSum = barWidth * numGroups;

        // The gap size is the same for all groups, regardless of the bar width.
        gapWidthSum = (barWidthSum * barGapRatio) / (1 - barGapRatio);

        // no need for group widths if z is constant
        groupWidths = null;
      } else {
        var barWidths = [];

        for (var g = 0; g < numGroups; g++) {
          yWidth = 0;
          for (i = 0; i < numYCategories; i++) {
            yWidth += DvtChartDataUtils.getBarCategoryZ(chart, categories['y'][i], g, false);
          }
          y2Width = 0;
          for (i = 0; i < numY2Categories; i++) {
            y2Width += DvtChartDataUtils.getBarCategoryZ(chart, categories['y2'][i], g, true);
          }
          barWidths.push(isSplitDualY ? Math.max(yWidth, y2Width) : yWidth + y2Width);
        }

        barWidthSum = barWidths.reduce((prev, cur) => {
          return prev + cur;
        });

        // The gap size is the same for all groups, regardless of the bar width.
        gapWidthSum = (barWidthSum * barGapRatio) / (1 - barGapRatio);
        groupWidths = barWidths.map((_barWidth) => {
          // divide the gaps evenly
          return _barWidth + gapWidthSum / numGroups;
        });
      }

      // Store the average z-value. This is useful because when we call groupAxisInfo.getGroupWidth(), it returns the average
      // group width. Thus, we can convert z-value to pixels using (zValue / averageGroupZ * groupAxisInfo.getGroupWidth()).
      options['_averageGroupZ'] = (barWidthSum + gapWidthSum) / numGroups;

      return groupWidths;
    },

    /**
     * Returns the bar gap ratio.
     * @param {Chart} chart
     * @return {Number} The bar gap ratio, between 0 and 1
     */
    getBarGapRatio: (chart) => {
      var cacheKey = 'barGapRatio';
      var barGapRatio = chart.getCache().getFromCache(cacheKey);
      if (barGapRatio) return barGapRatio;

      barGapRatio = chart.getOptions()['styleDefaults']['barGapRatio'];
      if (typeof barGapRatio == 'string' && barGapRatio.slice(-1) == '%')
        // parse percent input
        barGapRatio = Number(barGapRatio.slice(0, -1)) / 100;

      if (barGapRatio != null && !isNaN(barGapRatio)) return Number(barGapRatio);

      var categories = DvtChartDataUtils.getStackCategories(chart, 'bar');
      var numYStacks = categories['y'].length;
      var numY2Stacks = categories['y2'].length;
      var numStacks = DvtChartDataUtils.isSplitDualY(chart)
        ? Math.max(numYStacks, numY2Stacks)
        : numYStacks + numY2Stacks;

      // Fall back to the default
      if (DvtChartTypeUtils.isPolar(chart)) barGapRatio = numStacks == 1 ? 0 : 0.25;
      else
        barGapRatio =
          numStacks == 1 ? 0.37 + 0.26 / DvtChartAxisUtils.getViewportGroupCount(chart) : 0.25;

      chart.getCache().putToCache(cacheKey, barGapRatio);
      return barGapRatio;
    },

    /**
     * Returns the bar information needed to draw it for the specified index.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {dvt.Rectangle} availSpace
     * @return {Object} The coordinates associated with this bar for rendering purposes.
     */
    getBarInfo: (chart, seriesIndex, groupIndex, availSpace) => {
      var bHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var bStacked = DvtChartDataUtils.isStacked(chart);
      var isRTL = dvt.Agent.isRightToLeft(chart.getCtx());
      var xAxis = chart.xAxis;
      var bRange = DvtChartDataUtils.isRangeSeries(chart, seriesIndex);
      var offsetMap = DvtChartStyleUtils.getBarCategoryOffsetMap(chart, groupIndex);

      // Get the x-axis position
      var xValue = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
      var xCoord = xAxis.getUnboundedCoordAt(xValue);

      // Find the corresponding y axis
      var bY2Series = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
      var yAxis = bY2Series ? chart.y2Axis : chart.yAxis;
      var axisCoord = yAxis.getBaselineCoord();

      // Get the y-axis position
      var yCoord, baseCoord;
      if (bRange) {
        var lowValue = DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex);
        var highValue = DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex);
        if (lowValue == null || isNaN(lowValue) || highValue == null || isNaN(highValue))
          // Don't render bars whose value is null
          return null;

        yCoord = yAxis.getBoundedCoordAt(lowValue);
        baseCoord = yAxis.getBoundedCoordAt(highValue);

        // Don't render bars whose start and end points are both out of bounds
        if (yCoord == baseCoord && yAxis.getCoordAt(lowValue) == null) return null;
      } else {
        var yValue = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex);
        var totalYValue = DvtChartDataUtils.getCumulativeVal(chart, seriesIndex, groupIndex);
        if (yValue == null || isNaN(yValue))
          // Don't render bars whose value is null
          return null;

        yCoord = yAxis.getBoundedCoordAt(totalYValue);
        baseCoord = bStacked ? yAxis.getBoundedCoordAt(totalYValue - yValue) : axisCoord;

        // Don't render bars whose start and end points are both out of bounds
        if (yCoord == baseCoord && yAxis.getCoordAt(totalYValue) == null) return null;
      }

      // Calculate the width for the bar.
      var category = DvtChartDataUtils.getStackCategory(chart, seriesIndex);
      var barWidth = DvtChartStyleUtils.getBarWidth(chart, seriesIndex, groupIndex);
      var stackWidth = bStacked
        ? DvtChartStyleUtils.getBarStackWidth(chart, category, groupIndex, bY2Series)
        : barWidth;

      // : Mac FF pixel snaps greedily, so there must be 2 or more pixels of gaps.
      if (DvtChartStyleUtils.getBarSpacing(chart) == 'pixel' && dvt.Agent.browser === 'firefox') {
        var groupWidth = barWidth / (1 - DvtChartGroupUtils.getBarGapRatio(chart));
        if (barWidth > 1 && groupWidth - barWidth < 2) {
          barWidth--;
          stackWidth = barWidth;
        }
      }

      // Calculate the actual coords for the bar
      var itemOffset = offsetMap[bY2Series ? 'y2' : 'y'][category] + 0.5 * (stackWidth - barWidth);
      var x1 = isRTL && !bHoriz ? xCoord - itemOffset - barWidth : xCoord + itemOffset;
      var x2 = x1 + barWidth;

      // Store the center of the data point relative to the plot area (for marquee selection)
      var dataPosX = (x1 + x2) / 2;
      var dataPosY = bRange ? (yCoord + baseCoord) / 2 : yCoord;
      var dataPos = DvtChartCoordUtils.convertAxisCoord(
        chart,
        new dvt.Point(dataPosX, dataPosY),
        availSpace
      );
      return {
        x1: x1,
        x2: x2,
        axisCoord: axisCoord,
        baseCoord: baseCoord,
        yCoord: yCoord,
        dataPos: dataPos,
        barWidth: barWidth
      };
    },

    /**
     * Returns the data label position for the specified data point.
     * @param {Chart} chart
     * @param {number} seriesIndex The series index.
     * @param {number} groupIndex The group index.
     * @param {number} itemIndex The nested item index.
     * @param {string=} type Data label type: low, high, or value.
     * @param {boolean} isStackLabel true if label for stack cummulative, false otherwise
     * @return {string} The data label position. Uses an internal list different from the API values.
     * Possible values are: center, inLeft, inRight, inTop, inBottom, left, right, top, bottom, none
     */
    getDataLabelPos: (chart, seriesIndex, groupIndex, itemIndex, type, isStackLabel) => {
      var nestedData = DvtChartDataUtils.getNestedDataItem(chart, seriesIndex, groupIndex, itemIndex);
      var data = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
      var position;

      if (isStackLabel) position = 'outsideBarEdge';
      else {
        position =
          nestedData && nestedData['labelPosition']
            ? nestedData['labelPosition']
            : data['labelPosition'];

        if (!position) position = chart.getOptions()['styleDefaults']['dataLabelPosition'];
        position = DvtChartStyleUtils._parseLowHighArray(position, type);

        if (position == 'none') return 'none';
      }

      var bRTL = dvt.Agent.isRightToLeft(chart.getCtx());
      var bHorizontal = DvtChartTypeUtils.isHorizontal(chart);
      var bPolar = DvtChartTypeUtils.isPolar(chart);

      if (DvtChartTypeUtils.isFunnel(chart) || DvtChartTypeUtils.isPyramid(chart)) {
        return 'center';
      }
      // Bar series
      else if (DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'bar') {
        // Only center is supported for polar bar
        if (position == 'center' || bPolar) return 'center';

        // Only insideBarEdge, outsideBarEdge, and center are supported for cartesian bar.
        // outsideBarEdge is not supported for stacked because it'll be covered by the bar above.
        var isStacked = DvtChartDataUtils.isStacked(chart);
        if (position != 'insideBarEdge') {
          if (isStacked && !isStackLabel) return 'center';
          else if (position != 'outsideBarEdge') position = 'insideBarEdge';
        }
        if (position == 'insideBarEdge' && !isStacked) {
          var styleDefaultsDataLabel = chart.getOptions()['styleDefaults']['dataLabelStyle'];
          var style = data['labelStyle']
            ? dvt.CSSStyle.mergeStyles([styleDefaultsDataLabel, new dvt.CSSStyle(data['labelStyle'])])
            : styleDefaultsDataLabel;
          var textDim;

          if (bHorizontal) {
            var text = DvtChartStyleUtils.getDataLabel(
              chart,
              seriesIndex,
              groupIndex,
              itemIndex,
              type
            );
            textDim = dvt.TextUtils.getTextStringWidth(chart.getCtx(), text, style);
          } else textDim = dvt.TextUtils.getTextStringHeight(chart.getCtx(), style);

          var barInfo = DvtChartGroupUtils.getBarInfo(chart, seriesIndex, groupIndex);
          var barHeight = barInfo ? Math.abs(barInfo.baseCoord - barInfo.yCoord) : 0;

          if (barHeight <= textDim) position = 'outsideBarEdge';
        }

        // Determine if the label is positioned in the low or high position
        var bNegative;
        if (type == 'low') bNegative = data['low'] <= data['high'];
        else if (type == 'high') bNegative = data['high'] < data['low'];
        else bNegative = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex, itemIndex) < 0;

        if (position == 'outsideBarEdge') {
          if (bHorizontal) return (!bNegative && !bRTL) || (bNegative && bRTL) ? 'right' : 'left';
          else return bNegative ? 'bottom' : 'top';
        } else {
          // insideBarEdge
          if (bHorizontal) return (!bNegative && !bRTL) || (bNegative && bRTL) ? 'inRight' : 'inLeft';
          else return bNegative ? 'inBottom' : 'inTop';
        }
      }

      // Scatter, Bubble, Line, or Area series
      else {
        if (position == 'center') return 'center';
        if (position == 'belowMarker') return 'bottom';
        if (position == 'aboveMarker') return 'top';

        if (position != 'afterMarker' && position != 'beforeMarker') {
          if (DvtChartTypeUtils.isBubble(chart)) return 'center';
          else if (type == 'low' && !bPolar) {
            if (!bHorizontal) return 'bottom';
            else position = 'beforeMarker';
          } else if (type == 'high' && !bPolar) {
            if (!bHorizontal) return 'top';
            else position = 'afterMarker';
          } else position = 'afterMarker';
        }

        if ((!bRTL && position == 'afterMarker') || (bRTL && position == 'beforeMarker'))
          return 'right';
        else return 'left';
      }
    }
  };

  /**
   * Series effect utility functions for Chart.
   * @class
   */
  const DvtChartSeriesEffectUtils = {
    /**
     * Returns the fill for a bar with the given series and group.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} barWidth The width of the bar
     * @return {dvt.Fill}
     */
    getBarFill: (chart, seriesIndex, groupIndex, barWidth) => {
      var color = DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
      var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex);
      return DvtChartSeriesEffectUtils.getRectangleFill(chart, color, pattern, barWidth);
    },

    /**
     * Returns the fill for a rectangular shape
     * @param {Chart} chart
     * @param {string} color
     * @param {string} pattern
     * @param {number} width The width of the rectangle
     * @return {dvt.Fill}
     */
    getRectangleFill: (chart, color, pattern, width) => {
      var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);

      if (pattern) return new dvt.PatternFill(pattern, color);
      else if (seriesEffect == 'gradient' && width > 3) {
        // to improve performance, don't use gradient if rect is too thin
        var colors;
        var stops;
        var angle = DvtChartTypeUtils.isHorizontal(chart) ? 270 : 0;
        colors = [
          dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04),
          dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05)
        ];
        stops = [0, 1.0];

        return new dvt.LinearGradientFill(angle, colors, null, stops);
      } // seriesEffect="color"
      else return new dvt.SolidFill(color);
    },

    /**
     * Returns the fill for an area with the given series and group.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @return {dvt.Fill}
     */
    getAreaFill: (chart, seriesIndex) => {
      var isLineWithArea = DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'lineWithArea';

      // Get the color
      var color;
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      if (seriesItem && seriesItem['areaColor']) color = seriesItem['areaColor'];
      else {
        color = DvtChartStyleUtils.getColor(chart, seriesIndex);
        if (isLineWithArea) color = dvt.ColorUtils.setAlpha(color, 0.2);
      }

      // All series effects are based off of the color
      var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex);
      var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);

      if (pattern) return new dvt.PatternFill(pattern, color);
      else if (seriesEffect == 'gradient') {
        var colors, stops;
        var angle = DvtChartTypeUtils.isHorizontal(chart) ? 180 : 270;
        if (isLineWithArea) {
          var alpha = dvt.ColorUtils.getAlpha(color);
          colors = [
            dvt.ColorUtils.setAlpha(color, Math.min(alpha + 0.2, 1)),
            dvt.ColorUtils.setAlpha(color, Math.max(alpha - 0.15, 0))
          ];
          stops = [0, 1.0];
        } else {
          colors = [
            dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04),
            dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05)
          ];
          stops = [0, 1.0];
        }
        return new dvt.LinearGradientFill(angle, colors, null, stops);
      } // seriesEffect="color"
      else return new dvt.SolidFill(color);
    },

    /**
     * Returns the fill for a marker with the given series and group.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @return {dvt.Fill}
     */
    getMarkerFill: (chart, seriesIndex, groupIndex, itemIndex) => {
      // All series effects are based off of the color
      var color = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex, itemIndex);
      var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex, itemIndex);

      if (pattern) return new dvt.PatternFill(pattern, color);

      // Only bubble markers use series effect(gradient)
      if (DvtChartTypeUtils.isBubble(chart)) {
        var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);

        if (seriesEffect == 'gradient') {
          var colors = [
            dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04),
            dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05)
          ];
          var stops = [0, 1.0];
          return new dvt.LinearGradientFill(270, colors, null, stops);
        }
      }

      // seriesEffect="color" or line/scatter marker
      return new dvt.SolidFill(color);
    },

    /**
     * Returns the fill for a funnel or pyramid slice with the given series and group.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @param {string} color  The color that is associated with the funnel or pyramid slice, to apply the effect onto it.
     * @param {dvt.Rectangle} dimensions  The dimensions of this funnel or pyramid slice, to pass as limits for the gradient effect.
     * @param {boolean} bBackground
     * @return {dvt.Fill}
     */
    getFunnelPyramidSliceFill: (chart, seriesIndex, color, dimensions, bBackground) => {
      var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, 0);
      var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);

      if (pattern && !bBackground) {
        // Need to rotate the pattern if vertical to counteract the chart rotation.
        var matrix;
        if (chart.getOptions()['orientation'] == 'vertical' || DvtChartTypeUtils.isPyramid(chart)) {
          if (dvt.Agent.isRightToLeft(chart.getCtx())) matrix = new dvt.Matrix(0, -1, 1, 0);
          else matrix = new dvt.Matrix(0, 1, -1, 0);
        }
        return new dvt.PatternFill(pattern, color, null, matrix);
      } else if (seriesEffect == 'gradient') {
        var angle = DvtChartTypeUtils.isPyramid(chart) ? 180 : 90;
        var colors, stops;
        if (chart.getOptions()['styleDefaults']['threeDEffect'] == 'on') {
          colors = [
            dvt.ColorUtils.adjustHSL(color, 0, 0, -0.1),
            dvt.ColorUtils.adjustHSL(color, 0, 0, 0.12),
            color
          ];
          stops = [0, 0.65, 1.0];
        } else {
          colors = [
            dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04),
            dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05)
          ];
          stops = [0, 1.0];
        }
        return new dvt.LinearGradientFill(angle, colors, null, stops, [
          dimensions.x,
          dimensions.y,
          dimensions.w,
          dimensions.h
        ]);
      } // seriesEffect="color"
      else return new dvt.SolidFill(color);
    }
  };

  /**
   *  Creates a funnel shape.
   *  @extends {dvt.Path}
   *  @class DvtChartFunnelSlice  Creates a funnel slice object.
   *  @constructor
   *  @param {Chart} chart  The chart being rendered.
   *  @param {number} seriesIndex  The index of this slice.
   *  @param {number} numDrawnSeries  The number of series already drawn. Should be total number of series - seriesIndex - 1 if none are skipped.
   *  @param {number} funnelWidth The available width for the whole funnel.
   *  @param {number} funnelHeight The available height for the whole funnel.
   *  @param {number} startPercent The cumulative value of all the slices that come before. The start/leftmost value of the slice.
   *  @param {number} valuePercent The percent value for the slice. Dictates the width.
   *  @param {number} fillPercent The actual/target value, how much of the slice is filled.
   *  @param {number} gap The gap distance between slices.
   */
  class DvtChartFunnelSlice extends dvt.Path {
    /**
     *  Object initializer.
     *  @param {Chart} chart  The chart being rendered.
     *  @param {number} seriesIndex  The index of this slice.
     *  @param {number} numDrawnSeries  The number of series already drawn. Should be total number of series - seriesIndex - 1 if none are skipped.
     *  @param {number} funnelWidth The available width for the whole funnel.
     *  @param {number} funnelHeight The available height for the whole funnel.
     *  @param {number} startPercent The cumulative value of all the slices that come before. The start/leftmost value of the slice.
     *  @param {number} valuePercent The percent value for the slice. Dictates the width.
     *  @param {number} fillPercent The actual/target value, how much of the slice is filled.
     *  @param {number} gap The gap distance between slices.
     *  @protected
     */
    constructor(
      chart,
      seriesIndex,
      numDrawnSeries,
      funnelWidth,
      funnelHeight,
      startPercent,
      valuePercent,
      fillPercent,
      gap
    ) {
      super(chart.getCtx());

      /** The ratio of rx/ry in the 3D funnel opening
       * @private */
      this._FUNNEL_3D_WIDTH_RATIO = 0.08;
      /** Angle for creating the funnel sides
       * @private */
      this._FUNNEL_ANGLE_2D = 36;
      /** Ratio between the smallest and largest slices
       * @private */
      this._FUNNEL_RATIO = 1 / 3;
      /** Color for funnel slice border. Could be overridden in styleDefaults.
       * @private */
      this._BORDER_COLOR = '#FFFFFF';
      /** Minimum number of characters to use when truncating.
       * @private */
      this._MIN_CHARS_DATA_LABEL = 3;
      /** Length of the first line.
       * @private */
      this._LINE_FRACTION = 2 / 3;
      /** Fraction into which the funnel area is divided by the first line.
       * @private */
      this._AREA_FRACTION = 0.41;
      /** Fraction into which the funnel height is divided by the first line.
       * @private */
      this._HEIGHT_FRACTION = 0.28;
      /** Length of the second line.
       * @private */
      this._LINE_FRACTION_2 = 0.4;
      /** Fraction into which the funnel area is divided by the second line.
       * @private */
      this._AREA_FRACTION_2 = 0.8;
      /** Fraction into which the funnel height is divided by the second line.
       * @private */
      this._HEIGHT_FRACTION_2 = 0.7;

      this._chart = chart;
      var styleDefaults = chart.getOptions()['styleDefaults'];
      this._seriesIndex = seriesIndex;
      this._numDrawnSeries = numDrawnSeries;
      this._funnelWidth = funnelWidth;
      this._funnelHeight = funnelHeight;
      this._startPercent = startPercent;
      this._valuePercent = valuePercent;
      this._fillPercent = fillPercent;
      this._3dRatio = styleDefaults['threeDEffect'] == 'on' ? 1 : 0;
      this._gap = gap;
      var cmds = this._getPath();
      this._dataColor = DvtChartStyleUtils.getColor(this._chart, this._seriesIndex, 0);
      // Read the color from backgroundColor for backwards compatibility
      this._backgroundColor = styleDefaults['backgroundColor']
        ? styleDefaults['backgroundColor']
        : styleDefaults['funnelBackgroundColor'];
      this.setCmds(cmds['slice']);

      if (cmds['bar']) {
        this._bar = new dvt.Path(this.getCtx(), cmds['bar']);
        this.addChild(this._bar);
        this._bar.setMouseEnabled(false); // want the mouse interaction to only be with the slice.
      }

      this._setColorProps(cmds['sliceBounds']);
      this._label = this._getSliceLabel(cmds['sliceBounds'], cmds['barBounds']);

      if (this._label != null) {
        this._label.setMouseEnabled(false);
        this.addChild(this._label);
      }
    }

    /**
     * Creates the path commands that represent this slice
     * @return {object} The commands for drawing this slice. An object containing the sliceCommands, barCommands, sliceBounds and barBounds
     * @private
     */
    _getPath() {
      var isBiDi = dvt.Agent.isRightToLeft(this.getCtx());
      var gapCount = DvtChartDataUtils.getSeriesCount(this._chart);
      var offset = (this._numDrawnSeries + 1) * this._gap;
      var angle = dvt.Math.degreesToRads(this._FUNNEL_ANGLE_2D - 2 * this._3dRatio);

      var totalWidth = this._funnelWidth - gapCount * this._gap;
      var rx = totalWidth / Math.sin(dvt.Math.degreesToRads(this._FUNNEL_ANGLE_2D));
      var ry = this._funnelHeight / Math.sin(angle);
      var ratio =
        ((this._3dRatio * this._funnelWidth) / this._funnelHeight) * this._FUNNEL_3D_WIDTH_RATIO;
      if (ratio < 0.00001) ratio = 0;

      // Dividing the funnel into three trapezoids to come up with a better approximation for the dimensions. We draw two lines,
      // at .28 and .7 of the height, and they split the area to the ratio .41: .39: .2.
      var b1 = this._funnelHeight;
      var b2 = this._funnelHeight * this._FUNNEL_RATIO;
      var p1, p2; // The percent at which we are calculating the width
      var b11, b12, b21, b22; // The first and second base of the trapezoid into which the percent we are looking at falls.
      var f1, f2; // The fraction of the area included in the trapezoid we are considering.
      var t1, t2; // Total width of the trapezoid we are considering.
      var h1, h2; // Horizontal distance from the slice to the center of the ellipse for drawing the funnel arcs.

      // calculating first edge
      if (this._startPercent < this._AREA_FRACTION) {
        p1 = this._startPercent;
        b11 = b1;
        b21 = this._funnelHeight * this._LINE_FRACTION;
        f1 = this._AREA_FRACTION;
        t1 = totalWidth * this._HEIGHT_FRACTION;
        h1 = totalWidth * (1 - this._HEIGHT_FRACTION);
      } else if (this._startPercent < this._AREA_FRACTION_2) {
        p1 = this._startPercent - this._AREA_FRACTION;
        b11 = this._funnelHeight * this._LINE_FRACTION;
        b21 = this._funnelHeight * this._LINE_FRACTION_2;
        f1 = this._AREA_FRACTION_2 - this._AREA_FRACTION;
        t1 = totalWidth * (this._HEIGHT_FRACTION_2 - this._HEIGHT_FRACTION);
        h1 = totalWidth * (1 - this._HEIGHT_FRACTION_2);
      } else {
        p1 = this._startPercent - this._AREA_FRACTION_2;
        b11 = this._funnelHeight * this._LINE_FRACTION_2;
        b21 = b2;
        f1 = 1 - this._AREA_FRACTION_2;
        t1 = totalWidth * (1 - this._HEIGHT_FRACTION_2);
        h1 = 0;
      }

      // Calculating second edge
      if (this._startPercent + this._valuePercent < this._AREA_FRACTION) {
        b12 = b1;
        b22 = this._funnelHeight * this._LINE_FRACTION;
        p2 = this._startPercent + this._valuePercent;
        f2 = this._AREA_FRACTION;
        t2 = totalWidth * this._HEIGHT_FRACTION;
        h2 = totalWidth * (1 - this._HEIGHT_FRACTION);
      } else if (this._startPercent + this._valuePercent < this._AREA_FRACTION_2) {
        b12 = this._funnelHeight * this._LINE_FRACTION;
        b22 = this._funnelHeight * this._LINE_FRACTION_2;
        p2 = this._startPercent + this._valuePercent - this._AREA_FRACTION;
        f2 = this._AREA_FRACTION_2 - this._AREA_FRACTION;
        t2 = totalWidth * (this._HEIGHT_FRACTION_2 - this._HEIGHT_FRACTION);
        h2 = totalWidth * (1 - this._HEIGHT_FRACTION_2);
      } else {
        b12 = this._funnelHeight * this._LINE_FRACTION_2;
        b22 = b2;
        p2 = this._startPercent + this._valuePercent - this._AREA_FRACTION_2;
        f2 = 1 - this._AREA_FRACTION_2;
        t2 = totalWidth * (1 - this._HEIGHT_FRACTION_2);
        h2 = 0;
      }

      var w1 = Math.sqrt(((f1 - p1) / f1) * b11 * b11 + (p1 / f1) * b21 * b21);
      var w2 = Math.sqrt(((f2 - p2) / f2) * b12 * b12 + (p2 / f2) * b22 * b22);

      var startAngle = 0.98 * Math.asin((((w1 - b21) * t1) / (b11 - b21) + h1) / rx);
      var endAngle = 0.98 * Math.asin((((w2 - b22) * t2) / (b12 - b22) + h2) / rx);

      var c1 = ((1 + this._FUNNEL_RATIO) / 2) * this._funnelHeight + ry;
      var c2 = ((1 - this._FUNNEL_RATIO) / 2) * this._funnelHeight - ry;
      var ar, arcDir1, arcDir2;

      if (isBiDi) {
        ar = [
          rx * Math.sin(startAngle) + offset,
          c1 - ry * Math.cos(startAngle),
          rx * Math.sin(endAngle) + offset,
          c1 - ry * Math.cos(endAngle),
          rx * Math.sin(endAngle) + offset,
          c2 + ry * Math.cos(endAngle),
          rx * Math.sin(startAngle) + offset,
          c2 + ry * Math.cos(startAngle)
        ];
        arcDir1 = 0;
        arcDir2 = 1;
      } else {
        ar = [
          this._funnelWidth - offset - rx * Math.sin(startAngle),
          c1 - ry * Math.cos(startAngle),
          this._funnelWidth - offset - rx * Math.sin(endAngle),
          c1 - ry * Math.cos(endAngle),
          this._funnelWidth - offset - rx * Math.sin(endAngle),
          c2 + ry * Math.cos(endAngle),
          this._funnelWidth - offset - rx * Math.sin(startAngle),
          c2 + ry * Math.cos(startAngle)
        ];
        arcDir1 = 1;
        arcDir2 = 0;
      }

      var pathCommands = dvt.PathUtils.moveTo(ar[0], ar[1]);
      var barCommands = null;
      pathCommands += dvt.PathUtils.arcTo(
        (ratio * (ar[1] - ar[7])) / 2,
        (ar[1] - ar[7]) / 2,
        Math.PI,
        arcDir2,
        ar[6],
        ar[7]
      );
      pathCommands += dvt.PathUtils.arcTo(
        (ratio * (ar[1] - ar[7])) / 2,
        (ar[1] - ar[7]) / 2,
        Math.PI,
        arcDir2,
        ar[0],
        ar[1]
      );
      pathCommands += dvt.PathUtils.arcTo(rx, ry, angle, arcDir1, ar[2], ar[3]);
      pathCommands += dvt.PathUtils.arcTo(
        (ratio * (ar[3] - ar[5])) / 2,
        (ar[3] - ar[5]) / 2,
        Math.PI,
        arcDir2,
        ar[4],
        ar[5]
      );
      pathCommands += dvt.PathUtils.arcTo(rx, ry, angle, arcDir1, ar[6], ar[7]);
      var sliceBounds = new dvt.Rectangle(
        Math.min(ar[0], ar[2]),
        ar[5],
        Math.abs(ar[0] - ar[2]),
        Math.abs(ar[3] - ar[5])
      );

      if (this._fillPercent != null) {
        // creating the bar commands for 3D slices if applicable
        var percent = Math.max(Math.min(this._fillPercent, 1), 0);
        var alpha = isBiDi ? -percent * Math.PI : percent * Math.PI;
        barCommands = dvt.PathUtils.moveTo(ar[0], ar[1]);
        barCommands += dvt.PathUtils.arcTo(rx, ry, angle, arcDir1, ar[2], ar[3]);
        barCommands += dvt.PathUtils.arcTo(
          (ratio * (ar[3] - ar[5])) / 2,
          (ar[3] - ar[5]) / 2,
          alpha,
          arcDir2,
          ar[2] + ((ratio * (ar[3] - ar[5])) / 2) * Math.sin(alpha),
          (ar[5] + ar[3]) / 2 + ((ar[3] - ar[5]) / 2) * Math.cos(alpha)
        );
        // Edge cases require different bar shapes so they don't spill out of the slice.
        if (this._fillPercent > 0.95)
          barCommands += dvt.PathUtils.arcTo(
            rx,
            ry,
            angle,
            arcDir1,
            ar[6],
            ar[1] + percent * (ar[7] - ar[1])
          );
        else if (this._fillPercent < 0.05)
          barCommands += dvt.PathUtils.arcTo(
            rx,
            ry,
            angle,
            arcDir2,
            ar[6],
            ar[1] + percent * (ar[7] - ar[1])
          );
        else
          barCommands += dvt.PathUtils.lineTo(
            ar[6] + ((ratio * (ar[1] - ar[7])) / 2) * Math.sin(alpha),
            (ar[7] + ar[1]) / 2 + ((ar[1] - ar[7]) / 2) * Math.cos(alpha)
          );
        barCommands += dvt.PathUtils.arcTo(
          (ratio * (ar[1] - ar[7])) / 2,
          (ar[1] - ar[7]) / 2,
          alpha,
          arcDir1,
          ar[0],
          ar[1]
        );
        barCommands += dvt.PathUtils.closePath();
        var barBounds = new dvt.Rectangle(
          Math.min(ar[0], ar[2]),
          ar[5] + Math.abs(ar[3] - ar[5]) * (1 - percent),
          Math.abs(ar[0] - ar[2]),
          Math.abs(ar[3] - ar[5]) * percent
        );
      }
      return {
        slice: pathCommands,
        bar: barCommands,
        sliceBounds: sliceBounds,
        barBounds: barCommands ? barBounds : sliceBounds
      };
    }

    /**
     * Creates a single slice label dvt.Text object associated with this slice.
     * @param {dvt.Rectangle} sliceBounds The space occupied by the slice this is associated with.
     * @param {dvt.Rectangle} barBounds The space occupied by the colored bar this is associated with. Could affect the color.
     * @return {dvt.OutputText} slice label for this slice
     * @private
     */
    _getSliceLabel(sliceBounds, barBounds) {
      // Get and create the label string
      var labelString = DvtChartStyleUtils.getDataLabel(this._chart, this._seriesIndex, 0);
      if (!labelString)
        // if no data label set on the data item, set it from the series
        labelString = DvtChartDataUtils.getSeriesLabel(this._chart, this._seriesIndex);

      // Return if no label or label position none
      if (
        !labelString ||
        DvtChartGroupUtils.getDataLabelPos(this._chart, this._seriesIndex, 0) == 'none'
      )
        return;

      var label = new dvt.MultilineText(this.getCtx(), labelString, 0, 0);

      // Have to move the style setting first because was using wrong font size to come up with truncated text
      var isPatternBg = DvtChartStyleUtils.getPattern(this._chart, this._seriesIndex, 0) != null;
      var styleDefaults = this._chart.getOptions().styleDefaults;
      var labelStyleArray = [
        styleDefaults._dataLabelStyle,
        styleDefaults.dataLabelStyle,
        new dvt.CSSStyle(
          DvtChartDataUtils.getDataItem(this._chart, this._seriesIndex, 0)['labelStyle']
        )
      ];
      var style = dvt.CSSStyle.mergeStyles(labelStyleArray);
      label.setCSSStyle(style);

      // Truncating text and dropping if doesn't fit.
      if (
        !dvt.TextUtils.fitText(
          label,
          sliceBounds.h - this._3dRatio * (0.8 - this._valuePercent) * 50,
          sliceBounds.w,
          this,
          this._MIN_CHARS_DATA_LABEL
        )
      )
        return;

      var textDim = label.getDimensions();
      var pos = this._getLabelPos(sliceBounds);
      // Checking if the text starts within the bounding box of the colored bar.
      if (isPatternBg) {
        var padding = textDim.h * 0.15;
        var displacement = dvt.Agent.isRightToLeft(this.getCtx()) ? 0.5 : -0.5;
        var cmd = dvt.PathUtils.roundedRectangle(
          textDim.x - padding,
          textDim.y,
          textDim.w + 2 * padding,
          textDim.h,
          2,
          2,
          2,
          2
        );
        var bbox = new dvt.Path(this.getCtx(), cmd);
        bbox.setSolidFill(DvtChartStyleUtils.SERIES_PATTERN_BG_COLOR, 0.9);
        pos = pos.translate(displacement * textDim.h, -displacement * textDim.w);
        bbox.setMatrix(pos);
        this.addChild(bbox);
      }
      var labelColor = isPatternBg
        ? dvt.ColorUtils.getContrastingTextColor(DvtChartStyleUtils.SERIES_PATTERN_BG_COLOR)
        : barBounds.containsPoint(sliceBounds.x, sliceBounds.y + (sliceBounds.h - textDim.w) / 2)
        ? dvt.ColorUtils.getContrastingTextColor(this._dataColor)
        : dvt.ColorUtils.getContrastingTextColor(this._backgroundColor);
      var labelColorStyle = new dvt.CSSStyle({ color: labelColor });
      // Don't want to override the color if it was set above, unless in high contrast mode.
      labelStyleArray.splice(1, 0, labelColorStyle);
      if (dvt.Agent.isHighContrast()) {
        labelStyleArray.push(labelColorStyle);
      }
      style = dvt.CSSStyle.mergeStyles(labelStyleArray);
      label.setCSSStyle(style);

      label.setMatrix(this._getLabelPos(sliceBounds));
      label.alignCenter();
      label.alignMiddle();
      return label;
    }

    /**
     * Calculates the position of the text within this slice. Comes up with the translation/rotation matrix.
     * @param {dvt.Rectangle} sliceBounds The space occupied by the slice.
     * @return {dvt.Matrix} The matrix representing the transformation for placing the text.
     * @private
     */
    _getLabelPos(sliceBounds) {
      var displacement =
        this._3dRatio *
        ((((sliceBounds.h * this._funnelWidth) / this._funnelHeight) * this._FUNNEL_3D_WIDTH_RATIO) /
          2); // to make up for the 3D funnel opening
      // Rotate the text
      var rotationMatrix = new dvt.Matrix();
      if (dvt.Agent.isRightToLeft(this.getCtx())) {
        rotationMatrix = rotationMatrix.rotate(Math.PI / 2);
        rotationMatrix = rotationMatrix.translate(
          sliceBounds.x + sliceBounds.w / 2 - displacement,
          sliceBounds.y + sliceBounds.h / 2
        );
      } else {
        rotationMatrix = rotationMatrix.rotate((3 * Math.PI) / 2);
        rotationMatrix = rotationMatrix.translate(
          sliceBounds.x + sliceBounds.w / 2 + displacement,
          sliceBounds.y + sliceBounds.h / 2
        );
      }
      return rotationMatrix;
    }

    /**
     * Passing on the colors for the funnel slice object. Sets the slice fill and border color, as well as the selection and hover colors by reading them from the chart.
     * @param {dvt.Rectangle} sliceBounds The space occupied by the slice. This is used for calculating the gradient effect bounds.
     * @private
     */
    _setColorProps(sliceBounds) {
      var sliceFill = DvtChartSeriesEffectUtils.getFunnelPyramidSliceFill(
        this._chart,
        this._seriesIndex,
        this._dataColor,
        sliceBounds
      );
      var sliceBorder = DvtChartStyleUtils.getBorderColor(this._chart, this._seriesIndex, 0);

      var userBorderWidth = DvtChartStyleUtils.getUserBorderWidth(this._chart, this._seriesIndex, 0);
      var defaultBorderWidth = DvtChartStyleUtils.getDefaultBorderWidth(
        this._chart,
        this._seriesIndex,
        0
      );
      var borderIsFrom3D = false;
      var isRedwood = this.getCtx().getThemeBehavior() === 'redwood';
      if (sliceBorder == null && this._3dRatio > 0) {
        borderIsFrom3D = true;
        sliceBorder = this._BORDER_COLOR;
      }
      var borderWidth = userBorderWidth !== null ? userBorderWidth : defaultBorderWidth;
      if (
        sliceBorder &&
        !(isRedwood && this._chart.isSelectionSupported() && !this._bar && borderIsFrom3D)
      ) {
        this.setSolidStroke(sliceBorder, null, borderWidth);
      }
      var hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(this._dataColor);
      var backgroundFill = DvtChartSeriesEffectUtils.getFunnelPyramidSliceFill(
        this._chart,
        this._seriesIndex,
        this._backgroundColor,
        sliceBounds,
        true
      );
      if (this._bar) {
        this.setFill(backgroundFill);
        this._bar.setFill(sliceFill);
        this._bar.setStyle(DvtChartStyleUtils.getStyle(this._chart, this._seriesIndex, 0));
        this._bar.setClassName(DvtChartStyleUtils.getClassName(this._chart, this._seriesIndex, 0));
      } else {
        this.setFill(sliceFill);
        this.setStyle(DvtChartStyleUtils.getStyle(this._chart, this._seriesIndex, 0));
        this.setClassName(DvtChartStyleUtils.getClassName(this._chart, this._seriesIndex, 0));
      }
      // Save the original border stroke
      this.OriginalStroke = this.getStroke();
      var shapeForSelection = this._bar != null ? this._bar : this;

      if (this._chart.isSelectionSupported()) {
        this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
        if (isRedwood) {
          if (this._bar != null) {
            shapeForSelection.setSolidStroke(this._dataColor, null, 0);
            shapeForSelection.setFeedbackClassName('oj-dvt-selectable');
          } else {
            var strokeColor = sliceBorder != null && !borderIsFrom3D ? sliceBorder : this._dataColor;
            var strokeWidth = userBorderWidth !== null ? userBorderWidth : 0;
            shapeForSelection.setSolidStroke(strokeColor, null, strokeWidth);
            shapeForSelection.setFeedbackClassName('oj-dvt-selectable');
            if (sliceBorder) {
              if (borderIsFrom3D) {
                shapeForSelection.addClassName('oj-dvt-default-border-color');
              }
              if (userBorderWidth == null) {
                shapeForSelection.addClassName('oj-dvt-default-border-width');
              }
            }
          }
        } else {
          var innerColor = DvtChartStyleUtils.getSelectedInnerColor(this._chart);
          var outerColor = DvtChartStyleUtils.getSelectedOuterColor(this._chart)
            ? DvtChartStyleUtils.getSelectedOuterColor(this._chart)
            : this._dataColor;
          // Set the selection strokes
          shapeForSelection.setHoverStroke(new dvt.Stroke(hoverColor, 1, 2));
          shapeForSelection.setSelectedStroke(
            new dvt.Stroke(innerColor, 1, 1.5),
            new dvt.Stroke(outerColor, 1, 4.5)
          );
          shapeForSelection.setSelectedHoverStroke(
            new dvt.Stroke(innerColor, 1, 1.5),
            new dvt.Stroke(hoverColor, 1, 4.5)
          );
        }
      }
    }

    /**
     * Gets the percent values associated with the slice for animation
     * @return {array} the start, value, fill percents, and alpha for this slice.
     */
    getAnimParams() {
      return [
        this._startPercent,
        this._valuePercent,
        this._fillPercent,
        this.getAlpha(),
        this._3dRatio
      ];
    }

    /**
     * Sets the percent values associated with the slice for animation
     * @param {array} ar The new start, value, and fill percents for this slice
     */
    setAnimParams(ar) {
      this._startPercent = ar[0];
      this._valuePercent = ar[1];
      this._fillPercent = this._fillPercent != null ? ar[2] : null;
      this.setAlpha(ar[3]);
      this._3dRatio = ar[4];
      var cmds = this._getPath();

      this.setCmds(cmds['slice']);
      if (cmds['bar'] && this._bar) this._bar.setCmds(cmds['bar']);
      if (this._label) this._label.setMatrix(this._getLabelPos(cmds['sliceBounds']));
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this._bar != null) {
        if (this.IsSelected == selected) return;
        this.IsSelected = selected;
        this._bar.setSelected(selected);
      } else super.setSelected(selected);

      var dims = this.getDimensions();
      var shapeForSelection = this._bar != null ? this._bar : this;
      var displacement = 3;
      // To make the selection effect more apparent - make the bars slightly smaller
      var w = dims.w;
      if (selected) {
        shapeForSelection.setScaleX((w - displacement) / w);
        shapeForSelection.setTranslateX(Math.ceil(displacement / 2) + (displacement / w) * dims.x);
      } else {
        shapeForSelection.setScaleX(1);
        shapeForSelection.setTranslateX(0);
      }
    }

    /**
     * @override
     */
    showHoverEffect() {
      if (this._bar != null) {
        this._bar.showHoverEffect();
      } else super.showHoverEffect();
    }

    /**
     * @override
     */
    hideHoverEffect() {
      if (this._bar != null) {
        this._bar.hideHoverEffect();
      } else super.hideHoverEffect();
    }

    /**
     * @override
     */
    copyShape() {
      return new DvtChartFunnelSlice(
        this._chart,
        this._seriesIndex,
        this._numDrawnSeries,
        this._funnelWidth,
        this._funnelHeight,
        this._startPercent,
        this._valuePercent,
        this._fillPercent,
        this._gap
      );
    }
  }

  /**
   * Utility functions for Chart eventing and interactivity.
   * @class
   */
  const DvtChartEventUtils = {
    /**
     * Updates the visibility of the specified category.  Returns true if the visibility is successfully
     * updated.  This function will return false if the visibility change is rejected, such as when
     * hiding the last visible series with hideAndShowBehavior withRescale.
     * @param {Chart} chart
     * @param {string} category
     * @param {string} visibility The new visibility of the category.
     * @return {boolean} True if the visibility was successfully updated.
     */
    setVisibility: (chart, category, visibility) => {
      //  - HIDE & SHOW FOR REFERENCE OBJECTS
      var refObj = DvtChartRefObjUtils.getRefObj(chart, category);
      if (refObj != null) {
        refObj['visibility'] = visibility;
      }
      // Update the categories list
      var hiddenCategories = DvtChartDataUtils.getHiddenCategories(chart);
      var index = hiddenCategories.indexOf(category);
      if (visibility == 'hidden' && index < 0) hiddenCategories.push(category);
      else if (visibility == 'visible' && index >= 0) hiddenCategories.splice(index, 1);

      // Update the legend
      var options = chart.getOptions();
      if (options && options['legend'] && options['legend']['sections']) {
        // Iterate through any sections defined
        for (var i = 0; i < options['legend']['sections'].length; i++) {
          var dataSection = options['legend']['sections'][i];
          if (dataSection && dataSection['items']) {
            // Find the matching item and apply visibility
            for (var j = 0; j < dataSection['items'].length; j++) {
              if (dataSection['items'][j]['id'] == category)
                dataSection['items'][j]['categoryVisibility'] = visibility;
            }
          }
        }

        return true;
      }

      return false;
    },

    /**
     * Processes an array of DvtChartDataItems representing the current selection, making them ready to be
     * dispatched to the callback. This is primarily used for expanding the "Other" data item into its contained
     * ids.
     * @param {Chart} chart
     * @param {array} selection The array of unprocessed ids.
     * @return {array} The array of processed ids, ready to be dispatched.
     */
    processIds: (chart, selection) => {
      var ret = [];
      for (var i = 0; i < selection.length; i++) {
        var item = selection[i];
        if (item.series == DvtChartPieUtils.OTHER_ID) {
          // Get the slice ids of the slices that are grouped into "other" slice
          var otherItems = DvtChartPieUtils.getOtherSliceIds(chart);
          ret = ret.concat(otherItems);
        } else ret.push(item);
      }
      return ret;
    },

    /**
     * Enlarge marquee rectangular bounds by one pixel in all directions to cover the points at the edges.
     * @param {object} event The marquee event.
     */
    adjustBounds: (event) => {
      if (event.x != null) event.x -= 1;
      if (event.w != null) event.w += 2;
      if (event.y != null) event.y -= 1;
      if (event.h != null) event.h += 2;
    },

    /**
     * Gets the chart data items that are inside a marquee.
     * @param {Chart} chart The chart.
     * @param {object} event The marquee event, which contains the rectangular bounds (relative to stage).
     * @return {array} Array of peer objects that are inside the rectangle.
     */
    getBoundedObjs: (chart, event) => {
      // Include the filtered data items so that they are included if they are inside the marquee rectangle
      var peers = chart.getChartObjPeers().concat(DvtChartEventUtils.getFilteredChartObjPeers(chart));
      var boundedPeers = [];

      for (var i = 0; i < peers.length; i++) {
        var peer = peers[i];
        var dataPos = peer.getDataPosition();

        if (dataPos) {
          // since marquee coords are converted from (possibly scaled) stage to local (unscaled svg) coords,
          // we want to get the unscaled stage coord here.
          dataPos = chart
            .getPlotArea()
            .ConvertCoordSpaceRect(
              { x: dataPos.x, y: dataPos.y, h: 0, w: 0 },
              chart.getCtx().getStage()
            );
          var withinX = event.x == null || (dataPos.x >= event.x && dataPos.x <= event.x + event.w);
          var withinY = event.y == null || (dataPos.y >= event.y && dataPos.y <= event.y + event.h);
          if (withinX && withinY) boundedPeers.push(peer);
        }
      }

      return boundedPeers;
    },

    /**
     * Returns the peers of the chart data items that are filtered.
     * @param {Chart} chart
     * @return {Array}
     */
    getFilteredChartObjPeers: (chart) => {
      if (!chart.getCache().getFromCache('dataFiltered')) return [];

      var cacheKey = 'filteredChartObjPeers';
      var filteredPeers = chart.getCache().getFromCache(cacheKey);

      if (!filteredPeers) {
        filteredPeers = [];
        for (var s = 0; s < DvtChartDataUtils.getSeriesCount(chart); s++) {
          for (var g = 0; g < DvtChartDataUtils.getGroupCount(chart); g++) {
            if (!DvtChartDataUtils.isDataItemFiltered(chart, s, g)) continue;

            var dataPos;
            if (DvtChartDataUtils.getSeriesType(chart, s) == 'bar')
              dataPos = DvtChartGroupUtils.getBarInfo(chart, s, g).dataPos;
            else dataPos = DvtChartDataUtils.getMarkerPos(chart, s, g);

            filteredPeers.push(new DvtChartObjPeer(chart, [], s, g, null, dataPos));
          }
        }
        chart.getCache().putToCache(cacheKey, filteredPeers);
      }

      return filteredPeers;
    },

    /**
     * Gets the chart axis bounds corresponding to the bounding rectangle.
     * @param {Chart} chart The chart.
     * @param {object} event The marquee event, which contains the rectangular bounds (relative to stage).
     * @param {boolean} limitExtent Whether the result should be limited to the axis min/max extent.
     * @return {object} An object containing xMin, xMax, yMin, yMax, startGroup, endGroup corresponding to the bounds.
     */
    getAxisBounds: (chart, event, limitExtent) => {
      // Get the bounds in the axis coordinates
      var plotArea = chart.getPlotArea();
      var minPt = plotArea.stageToLocal(new dvt.Point(event.x, event.y));
      var maxPt = plotArea.stageToLocal(new dvt.Point(event.x + event.w, event.y + event.h));
      // Reset null values because they would be treated as zeros by stageToLocal()
      if (event.x == null) {
        minPt.x = null;
        maxPt.x = null;
      }
      if (event.y == null) {
        minPt.y = null;
        maxPt.y = null;
      }
      var coords = DvtChartEventUtils._convertToAxisCoord(chart, minPt.x, maxPt.x, minPt.y, maxPt.y);

      // Compute the axis bounds. Skip if the event values are null due to dragging on the axis.
      var xMinMax = {},
        yMinMax = {},
        y2MinMax = {},
        startEndGroup = {};
      if (chart.xAxis) {
        xMinMax = DvtChartEventUtils._getAxisMinMax(
          chart.xAxis,
          coords.xMin,
          coords.xMax,
          limitExtent
        );
        startEndGroup = DvtChartEventUtils.getAxisStartEndGroup(
          chart.xAxis,
          xMinMax.min,
          xMinMax.max
        );
      }
      if (chart.yAxis)
        yMinMax = DvtChartEventUtils._getAxisMinMax(
          chart.yAxis,
          coords.yMin,
          coords.yMax,
          limitExtent
        );
      if (chart.y2Axis)
        y2MinMax = DvtChartEventUtils._getAxisMinMax(
          chart.y2Axis,
          coords.yMin,
          coords.yMax,
          limitExtent
        );

      return {
        xMin: xMinMax.min,
        xMax: xMinMax.max,
        unchanged: xMinMax.unchanged,
        yMin: yMinMax.min,
        yMax: yMinMax.max,
        y2Min: y2MinMax.min,
        y2Max: y2MinMax.max,
        startGroup: startEndGroup.startGroup,
        endGroup: startEndGroup.endGroup
      };
    },

    /**
     * Gets the axis min/max values corresponding to the bounding coords.
     * @param {DvtChartAxis} axis
     * @param {number} minCoord The coord of the minimum value of the axis.
     * @param {number} maxCoord The coord of the maximum value of the axis.
     * @param {boolean} limitExtent Whether the result should be limited to the axis min/max extent.
     * @return {object} An object containing the axis min/max value.
     * @private
     */
    _getAxisMinMax: (axis, minCoord, maxCoord, limitExtent) => {
      if (minCoord == null || maxCoord == null) return { min: null, max: null };

      var min = axis.getUnboundedLinearValAt(minCoord);
      var max = axis.getUnboundedLinearValAt(maxCoord);

      if (limitExtent) {
        // Limit to min extent
        var minExtent = axis.getInfo().getMinExtent();
        if (max - min < minExtent) {
          var center = (max + min) / 2;
          max = center + minExtent / 2;
          min = center - minExtent / 2;
        }
        return DvtChartEventUtils._limitToGlobal(axis, min, max);
      }
      return DvtChartEventUtils.getActualMinMax(axis, min, max);
    },

    /**
     * Gets the chart axis bounds corresponding to the deltas in coords. The results are bounded by axis global min/max and
     * minimum axis extent.
     * @param {Chart} chart The chart.
     * @param {number} xMinDelta The delta coord of the left end of the horizontal axis.
     * @param {number} xMaxDelta The delta coord of the right end of the horizontal axis.
     * @param {number} yMinDelta The delta coord of the top end of the vertical axis.
     * @param {number} yMaxDelta The delta coord of the bottom end of the vertical axis.
     * @return {object} An object containing xMin, xMax, yMin, yMax, startGroup, endGroup corresponding to the bounds.
     */
    getAxisBoundsByDelta: (chart, xMinDelta, xMaxDelta, yMinDelta, yMaxDelta) => {
      // Convert the deltas to the axis coordinates
      var deltas = DvtChartEventUtils._convertToAxisCoord(
        chart,
        xMinDelta,
        xMaxDelta,
        yMinDelta,
        yMaxDelta
      );
      var zoomDirection = DvtChartBehaviorUtils.getZoomDir(chart);

      // Compute the axis bounds.
      var xMinMax = {},
        yMinMax = {},
        y2MinMax = {},
        startEndGroup = {};
      if (chart.xAxis && zoomDirection != 'y') {
        xMinMax = DvtChartEventUtils._getAxisMinMaxByDelta(chart.xAxis, deltas.xMin, deltas.xMax);
        startEndGroup = DvtChartEventUtils.getAxisStartEndGroup(
          chart.xAxis,
          xMinMax.min,
          xMinMax.max
        );
      }
      if (chart.yAxis && zoomDirection != 'x')
        yMinMax = DvtChartEventUtils._getAxisMinMaxByDelta(chart.yAxis, deltas.yMin, deltas.yMax);
      if (chart.y2Axis)
        y2MinMax = DvtChartEventUtils._getAxisMinMaxByDelta(chart.y2Axis, deltas.yMin, deltas.yMax);

      return {
        xMin: xMinMax.min,
        xMax: xMinMax.max,
        unchanged: xMinMax.unchanged,
        yMin: yMinMax.min,
        yMax: yMinMax.max,
        y2Min: y2MinMax.min,
        y2Max: y2MinMax.max,
        startGroup: startEndGroup.startGroup,
        endGroup: startEndGroup.endGroup
      };
    },

    /**
     * Gets the axis min/max values corresponding to the delta coords. The results are bounded by axis global min/max and
     * minimum axis extent.
     * @param {DvtChartAxis} axis
     * @param {number} minDelta The delta coord of the minimum value of the axis.
     * @param {number} maxDelta The delta coord of the maximum value of the axis.
     * @return {object} An object containing the axis min/max value.
     * @private
     */
    _getAxisMinMaxByDelta: (axis, minDelta, maxDelta) => {
      var min = axis.getLinearViewportMin();
      var max = axis.getLinearViewportMax();

      // Don't do the computation if the min/max won't change. This is to prevent rounding errors.
      if (maxDelta == minDelta && axis.isFullViewport())
        return DvtChartEventUtils.getActualMinMax(axis, min, max);

      var minDeltaVal = axis.getUnboundedLinearValAt(minDelta) - axis.getUnboundedLinearValAt(0);
      var maxDeltaVal = axis.getUnboundedLinearValAt(maxDelta) - axis.getUnboundedLinearValAt(0);

      // Make sure that the min/max is not less than the minimum axis extent
      var weight = 1;
      var newExtent = max + maxDeltaVal - (min + minDeltaVal);
      var minExtent = axis.getInfo().getMinExtent();
      if (minDelta != maxDelta && newExtent < minExtent)
        weight = (max - min - minExtent) / (minDeltaVal - maxDeltaVal);

      min += minDeltaVal * weight;
      max += maxDeltaVal * weight;

      return DvtChartEventUtils._limitToGlobal(axis, min, max);
    },

    /**
     * Convert from real coord to axis coord.
     * @param {Chart} chart
     * @param {number} xMin The minimum x in real coord.
     * @param {number} xMax The maximum x in real coord.
     * @param {number} yMin The minimum y in real coord.
     * @param {number} yMax The maximum y in real coord.
     * @return {object} An object containing the axis xMin/Max and yMin/Max.
     * @private
     */
    _convertToAxisCoord: (chart, xMin, xMax, yMin, yMax) => {
      var axisCoord = {};
      var isRTL = dvt.Agent.isRightToLeft(chart.getCtx());
      if (DvtChartTypeUtils.isHorizontal(chart)) {
        axisCoord.xMin = yMin;
        axisCoord.xMax = yMax;
        axisCoord.yMin = isRTL ? xMax : xMin;
        axisCoord.yMax = isRTL ? xMin : xMax;
      } else {
        axisCoord.xMin = isRTL ? xMax : xMin;
        axisCoord.xMax = isRTL ? xMin : xMax;
        axisCoord.yMin = yMax;
        axisCoord.yMax = yMin;
      }
      return axisCoord;
    },

    /**
     * Limits the min/max values to the global extents of the axis.
     * @param {DvtChartAxis} axis
     * @param {number} min Linearized min value of the axis.
     * @param {number} max Linearzied max value of the axis.
     * @return {object} An object containing the actual axis min/max value after limiting.
     * @private
     */
    _limitToGlobal: (axis, min, max) => {
      var globalMin = axis.getLinearGlobalMin();
      var globalMax = axis.getLinearGlobalMax();

      // Limit to global min/max
      if (max - min >= globalMax - globalMin) {
        min = globalMin;
        max = globalMax;
      } else if (min < globalMin) {
        max += globalMin - min;
        min = globalMin;
      } else if (max > globalMax) {
        min -= max - globalMax;
        max = globalMax;
      }

      return DvtChartEventUtils.getActualMinMax(axis, min, max);
    },

    /**
     * Returns an object containing the actual min/max based on the linearized min/max.
     * @param {DvtChartAxis} axis
     * @param {number} min Linearized min value of the axis.
     * @param {number} max Linearzied max value of the axis.
     * @return {object} An object containing the actual axis min/max value.
     */
    getActualMinMax: (axis, min, max) => {
      var actualMinMax = { min: axis.linearToActual(min), max: axis.linearToActual(max) };

      // For group axis, skip if the bounds don't change so we don't render the sparse axis labels unnecessarily ()
      if (axis.isGroupAxis()) {
        var currentMin = axis.getLinearViewportMin();
        var currentMax = axis.getLinearViewportMax();

        // Instead of strict equality, we need to add some tolerance to handle rounding errors
        var tolerance = 0.0001;
        if (Math.abs(min - currentMin) < tolerance && Math.abs(max - currentMax) < tolerance)
          actualMinMax.unchanged = true;
      }

      return actualMinMax;
    },

    /**
     * Returns the start/endGroup of the axis.
     * @param {DvtChartAxis} axis
     * @param {number} min The minimum value of the axis.
     * @param {number} max The maximum value of the axis.
     * @return {object} An object containing the axis start/endGroup.
     */
    getAxisStartEndGroup: (axis, min, max) => {
      if (axis.isGroupAxis() && min != null && max != null) {
        var startIdx = Math.ceil(min);
        var endIdx = Math.floor(max);
        if (endIdx >= startIdx) {
          var startGroup = axis.getInfo().getGroup(startIdx);
          var endGroup = axis.getInfo().getGroup(endIdx);
          return { startGroup: startGroup, endGroup: endGroup };
        }
      }
      return { startGroup: null, endGroup: null };
    },

    /**
     * Sets initial selection for the graph.
     * @param {Chart} chart The chart being rendered.
     * @param {array} selection The array of initially selected objects.
     */
    setInitialSelection: (chart, selection) => {
      var handler = chart.getSelectionHandler();
      if (!handler) return;

      if (!selection || selection.length == 0) {
        handler.clearSelection();
        return;
      }

      // Construct a keySet of selection ids
      var selectionIds = [];
      for (var i = 0; i < selection.length; i++) {
        if (selection[i]['id'] != null) selectionIds.push(selection[i]['id']);
        else if (selection[i]['series'] != null && selection[i]['group'] != null)
          selectionIds.push(
            DvtChartDataItemUtils.createDataItemId(selection[i]['series'], selection[i]['group'])
          );
      }
      var ctx = chart.getCtx();
      var selectionSet = new ctx.KeySetImpl(selectionIds);

      // Now go through the peers and add the peers that can be found inside the selectionSet to the selectedIds array.
      var peers = chart.getChartObjPeers();
      var selectedIds = [];
      for (var j = 0; j < peers.length; j++) {
        var peer = peers[j];
        if (!peer.isSelectable()) continue;

        // We have to check both id and series+group combination because the user can specify selection using either
        var peerDataId = peer.getDataItemId();
        var peerDataItemId = DvtChartDataItemUtils.createDataItemId(
          peer.getSeries(),
          peer.getGroup()
        );
        if (selectionSet.has(peerDataId) || selectionSet.has(peerDataItemId)) {
          selectedIds.push(peer.getId());
        }
      }

      handler.processInitialSelections(selectedIds, peers);
    },

    /**
     * Returns the keyboard navigable objects for the chart.
     * @param {Chart} chart
     * @return {array}
     */
    getKeyboardNavigables: (chart) => {
      var navigables = [];
      // only process pie chart with valid/non empty data
      if (DvtChartTypeUtils.isPie(chart) && chart.pieChart) {
        var slices = chart.pieChart.__getSlices();
        for (var i = 0; i < slices.length; i++) {
          // exclude hidden slices that may be included during delete animation
          if (DvtChartDataUtils.isSeriesRendered(chart, slices[i].getSeriesIndex())) {
            navigables.push(slices[i]);
          }
        }
      } else {
        var peers = chart.getChartObjPeers();
        for (var z = 0; z < peers.length; z++) {
          if (peers[z].isNavigable()) {
            navigables.push(peers[z]);
          }
        }
      }
      return navigables;
    },

    /**
     * Add data, itemData, seriesData, and groupData to the event payload.
     * @param {Chart} chart
     * @param {object} eventPayload The event payload to decorate. Currently contains series, group, and id.
     */
    addEventData: (chart, eventPayload) => {
      var seriesIndex = DvtChartDataUtils.getSeriesIdx(chart, eventPayload['series']);
      var groupIndex = DvtChartDataUtils.getGroupIdx(chart, eventPayload['group']);
      var itemIndex = DvtChartDataUtils.getNestedDataItemIdx(
        chart,
        seriesIndex,
        groupIndex,
        eventPayload['id']
      );
      var dataContext = DvtChartStyleUtils.getDataContext(chart, seriesIndex, groupIndex, itemIndex);

      if (dataContext) {
        eventPayload['data'] = dataContext['data'];
        eventPayload['itemData'] = dataContext['itemData']; // data provider row data
        eventPayload['seriesData'] = dataContext['seriesData'];
        if (dataContext['groupData']) eventPayload['groupData'] = dataContext['groupData'];
        // getDataContext() doesn't support group objects
        else if (groupIndex != null)
          eventPayload['groupData'] = DvtChartDataUtils.getGroupsDataForContext(chart)[groupIndex];
      }
    },

    /**
     * Adds group drill details in the eventPayload
     * @param {Chart} chart
     * @param {object} eventPayload The event payload to decorate. Currently contains series, group, and id.
     */
    addGroupDrillEventData: (chart, eventPayload) => {
      var newEvent = {};
      Object.assign(newEvent, eventPayload);

      var axis = chart.xAxis.getInfo();
      var range = axis.getItemsRange(eventPayload.group);
      delete newEvent.series;

      var startIndex = range.startIndex;
      var endIndex = range.endIndex;
      var itemsList = [];
      for (var i = startIndex; i < endIndex + 1; i++) {
        var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
        for (var j = 0; j < seriesCount; j++) {
          itemsList.push(DvtChartDataUtils.getRawDataItem(chart, j, i));
        }
      }

      newEvent.items = itemsList;
      newEvent.groupData = range.groupData;

      return newEvent;
    },

    /**
     * Adds multiseries drill details in the eventPayload
     * @param {Chart} chart
     * @param {object} eventPayload The event payload to decorate. Currently contains series, group, and id.
     */
    addMultiSeriesDrillEventData: (chart, eventPayload) => {
      var newEvent = {};
      Object.assign(newEvent, eventPayload);

      var seriesItems = DvtChartPieUtils._getSeriesIndicesArrays(chart).other;
      delete newEvent.group;

      var seriesData = [];
      var items = [];
      var series = [];
      for (var i = 0; i < seriesItems.length; i++) {
        var seriesContext = DvtChartDataUtils.getSeriesDataForContext(chart, seriesItems[i]);
        var item = DvtChartDataUtils.getRawDataItem(chart, seriesItems[i], 0);

        seriesData.push(seriesContext);
        items.push(item);
        series.push(DvtChartDataUtils.getSeries(chart, seriesItems[i]));
      }
      newEvent.seriesData = seriesData;
      newEvent.items = items;
      newEvent.series = series;

      return newEvent;
    },

    /**
     * Adds series drill details in the eventPayload
     * @param {Chart} chart
     * @param {object} eventPayload The event payload to decorate. Currently contains series, group, and id.
     */
    addSeriesDrillEventData: (chart, eventPayload) => {
      var newEvent = {};
      Object.assign(newEvent, eventPayload);

      var seriesIndex = DvtChartDataUtils.getSeriesIdx(chart, eventPayload.id);
      var numGroups = DvtChartDataUtils.getGroupCount(chart);
      newEvent.series = eventPayload.id;
      delete newEvent.group;

      newEvent.seriesData = DvtChartDataUtils.getSeriesDataForContext(chart, seriesIndex);

      var items = [];
      for (var i = 0; i < numGroups; i++) {
        var item = DvtChartDataUtils.getRawDataItem(chart, seriesIndex, i);
        items.push(item);
      }
      newEvent.items = items;
      return newEvent;
    },

    /**
     * Adds item drill details in the eventPayload
     * @param {Chart} chart
     * @param {object} eventPayload The event payload to decorate. Currently contains series, group, and id.
     */
    addItemDrillEventData: (chart, eventPayload) => {
      var newEvent = {};
      Object.assign(newEvent, eventPayload);

      var seriesIndex = DvtChartDataUtils.getSeriesIdx(chart, eventPayload.series);
      var groupIndex = DvtChartDataUtils.getGroupIdx(chart, eventPayload.group);
      var itemIndex = DvtChartDataUtils.getNestedDataItemIdx(
        chart,
        seriesIndex,
        groupIndex,
        eventPayload.id
      );

      newEvent.seriesData = DvtChartDataUtils.getSeriesDataForContext(chart, seriesIndex);
      newEvent.groupData = DvtChartDataUtils.getGroupsDataForContext(chart)[groupIndex];
      newEvent.data = DvtChartDataUtils.getRawDataItem(chart, seriesIndex, groupIndex, itemIndex);
      newEvent.itemData = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex, itemIndex)[
        '_itemData'
      ];

      return newEvent;
    },

    /**
     * Create a background rect that allows DND theming
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {boolean} bHorizontal Is chart horizontal
     */
    addPlotAreaDnDBackground: (chart, container, availSpace, bHorizontal) => {
      var isPlotAreaDraggable = DvtChartBehaviorUtils.isPlotAreaDraggable(chart);
      var isPlotAreaDropTarget = DvtChartBehaviorUtils.isPlotAreaDropTarget(chart);

      if (isPlotAreaDropTarget || isPlotAreaDraggable) {
        var background = new dvt.Rect(
          chart.getCtx(),
          0,
          0,
          bHorizontal ? availSpace.w : availSpace.h,
          bHorizontal ? availSpace.h : availSpace.w
        );
        background.setInvisibleFill();
        container.addChild(background);
        chart.getCache().putToCache('plotAreaBackground', background);

        if (isPlotAreaDraggable) background.setClassName('oj-draggable');
      }
    }
  };

  /**
   * Renderer for funnel chart.
   * @class
   */
  const DvtChartFunnelRenderer = {
    /** @private @const */
    _DEFAULT_3D_GAP_RATIO: 1 / 36,
    /** @private @const */
    _DEFAULT_2D_GAP_RATIO: 1 / 70,
    /** @private @const */
    _MAX_WIDTH_FOR_GAPS: 0.25,
    /** @private @const */
    _GROUP_IDX: 0,
    /** @private @const */
    _SLICE_VALUE_THRESHOLD: 0.0001,

    /**
     * Renders the funnel into the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (chart, container, availSpace) => {
      // Creating a container for the funnel so that it can be rotated if vertical, also for animation.
      var funnelContainer = new dvt.Container(chart.getCtx());
      funnelContainer.setTranslate(availSpace.x, availSpace.y);
      container.addChild(funnelContainer);
      chart.setPlotArea(funnelContainer);
      var isHorizontal = DvtChartTypeUtils.isHorizontal(chart);

      var bbox;

      if (isHorizontal) bbox = new dvt.Rectangle(0, 0, availSpace.w, availSpace.h);
      else {
        //rotate the container and the bounding rect
        var rotationMatrix = new dvt.Matrix();
        var dirFactor = dvt.Agent.isRightToLeft(chart.getCtx()) ? -1 : 1;
        rotationMatrix = rotationMatrix.translate(-availSpace.h / 2, -availSpace.w / 2);
        rotationMatrix = rotationMatrix.rotate((dirFactor * Math.PI) / 2);
        rotationMatrix = rotationMatrix.translate(
          availSpace.x + availSpace.w / 2,
          availSpace.y + availSpace.h / 2
        );
        bbox = new dvt.Rectangle(0, 0, availSpace.h, availSpace.w);
        funnelContainer.setMatrix(rotationMatrix);
      }

      DvtChartEventUtils.addPlotAreaDnDBackground(chart, funnelContainer, availSpace, isHorizontal);

      if (!DvtChartFunnelRenderer._renderFunnelSlices(chart, funnelContainer, bbox))
        DvtChartTextUtils.renderEmptyText(chart, container, availSpace);

      // Initial Selection
      var selected = DvtChartDataUtils.getInitialSelection(chart);
      DvtChartEventUtils.setInitialSelection(chart, selected);

      // Initial Highlighting
      chart.highlight(DvtChartDataUtils.getHighlightedCategories(chart));
    },

    /**
     * Renders all funnel slices for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace
     * @return {boolean} true if funnel slices have been rendered, false otherwise
     * @private
     */
    _renderFunnelSlices: (chart, container, availSpace) => {
      var options = chart.getOptions();
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);

      // Compute the gap size
      var gapRatio = DvtChartStyleUtils.getDataItemGaps(chart);
      var defaultGapSize =
        (options['styleDefaults']['threeDEffect'] == 'on'
          ? DvtChartFunnelRenderer._DEFAULT_3D_GAP_RATIO
          : DvtChartFunnelRenderer._DEFAULT_2D_GAP_RATIO) * availSpace.w;
      var maxGapSize = Math.min(
        (DvtChartFunnelRenderer._MAX_WIDTH_FOR_GAPS * availSpace.w) / (seriesCount - 1),
        defaultGapSize
      );
      var gapSize = gapRatio * maxGapSize;

      var totalValue = 0; // the total value represented by the funnel
      var numDrawnSeries = 0; // to keep track of how many series are drawn, so we don't add too many gaps if there are zero values
      var cumulativeValue = 0; // keeping track of the total up to this series

      // Iterate through the data to calculate the total value
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if it shouldn't be rendered
        if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIndex)) continue;

        // Do not render if the value is not positive
        var value = DvtChartDataUtils.getTargetVal(chart, seriesIndex);
        if (value == null)
          value = DvtChartDataUtils.getVal(chart, seriesIndex, DvtChartFunnelRenderer._GROUP_IDX);
        if (value <= 0) continue;
        totalValue += value;
      }

      if (totalValue == 0) return false;

      // Iterate through the data
      for (var seriesIdx = seriesCount - 1; seriesIdx >= 0; seriesIdx--) {
        // Skip the series if it shouldn't be rendered
        if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIdx)) continue;

        // Do not render if the value is not positive
        var val = DvtChartDataUtils.getVal(chart, seriesIdx, DvtChartFunnelRenderer._GROUP_IDX);
        var targetValue = DvtChartDataUtils.getTargetVal(chart, seriesIdx);
        if ((val <= 0 && targetValue == null) || (targetValue != null && targetValue <= 0)) continue;

        //  - rendering issues for funnel/pie/sunburst charts
        var sliceValue = targetValue != null ? targetValue : val;
        if (sliceValue < DvtChartFunnelRenderer._SLICE_VALUE_THRESHOLD * totalValue) continue;

        var slice;

        if (targetValue != null) {
          cumulativeValue += targetValue / totalValue;
          slice = new DvtChartFunnelSlice(
            chart,
            seriesIdx,
            numDrawnSeries,
            availSpace.w,
            availSpace.h,
            1 - cumulativeValue,
            targetValue / totalValue,
            val / targetValue,
            gapSize
          );
        } else {
          cumulativeValue += val / totalValue;
          slice = new DvtChartFunnelSlice(
            chart,
            seriesIdx,
            numDrawnSeries,
            availSpace.w,
            availSpace.h,
            1 - cumulativeValue,
            val / totalValue,
            null,
            gapSize
          );
        }

        numDrawnSeries++; // keeping track of how many series have been drawn to create the gap.
        container.addChild(slice);
        DvtChartObjPeer.associate(slice, chart, seriesIdx, DvtChartFunnelRenderer._GROUP_IDX);
      }
      return true;
    }
  };

  /**
   *  Creates a pyramid shape.
   *  @extends {dvt.Path}
   *  @class DvtChartPyramidSlice  Creates a pyramid slice object.
   *  @constructor
   *  @param {Chart} chart  The chart being rendered.
   *  @param {number} seriesIndex  The index of this slice.
   *  @param {number} numDrawnSeries  The number of series already drawn. Should be total number of series - seriesIndex - 1 if none are skipped.
   *  @param {number} pyramidWidth The available width for the whole pyramid.
   *  @param {number} pyramidHeight The available height for the whole pyramid.
   *  @param {number} startPercent The cumulative value of all the slices that come before. The start/leftmost value of the slice.
   *  @param {number} valuePercent The percent value for the slice. Dictates the width.
   *  @param {number} gap The gap distance between slices.
   */
  class DvtChartPyramidSlice extends dvt.Path {
    /**
     *  Object initializer.
     *  @param {Chart} chart  The chart being rendered.
     *  @param {number} seriesIndex  The index of this slice.
     *  @param {number} numDrawnSeries  The number of series already drawn. Should be total number of series - seriesIndex - 1 if none are skipped.
     *  @param {number} pyramidWidth The available width for the whole pyramid.
     *  @param {number} pyramidHeight The available height for the whole pyramid.
     *  @param {number} startPercent The cumulative value of all the slices that come before. The start/leftmost value of the slice.
     *  @param {number} valuePercent The percent value for the slice. Dictates the width.
     *  @param {number} gap The gap distance between slices.
     *  @protected
     */
    constructor(
      chart,
      seriesIndex,
      numDrawnSeries,
      pyramidWidth,
      pyramidHeight,
      startPercent,
      valuePercent,
      gap
    ) {
      super(chart.getCtx());

      /** Minimum number of characters to use when truncating.
       * @private
       * */
      this._MIN_CHARS_DATA_LABEL = 3;

      /** Horizontal padding for the slice label to prevent the text from bleeding
       * @private
       * */
      this._SLICE_LABEL_HORIZONTAL_PADDING = 4;

      /** Factor by which the total width is used for rendering the 3D side
       * @private */
      this._3D_WIDTH_FACTOR = 0.2;

      this._chart = chart;
      var styleDefaults = chart.getOptions()['styleDefaults'];
      this._seriesIndex = seriesIndex;
      this._numDrawnSeries = numDrawnSeries;
      this._pyramidWidth = pyramidWidth;
      this._pyramidHeight = pyramidHeight;
      this._startPercent = startPercent;
      this._valuePercent = valuePercent;
      this._3dRatio = styleDefaults['threeDEffect'] == 'on' ? 1 : 0;
      this._gap = gap;
      var cmds = this._getPath();
      this._dataColor = DvtChartStyleUtils.getColor(this._chart, this._seriesIndex, 0);

      if (this._3dRatio > 0) {
        this.setCmds(cmds['threeDPathTop']);
        this._threeDPathSide = new dvt.Path(this.getCtx(), cmds['threeDPathSide']);
        this._mainFace = new dvt.Path(this.getCtx(), cmds['slice']);
        this.addChild(this._threeDPathSide);
        this.addChild(this._mainFace);
      } else this.setCmds(cmds['slice']);

      this._setColorProps(cmds['sliceBounds']);
      this._label = this._getSliceLabel(cmds['sliceBounds']);

      if (this._label != null) {
        this._label.setMouseEnabled(false);
        this.addChild(this._label);
      }
    }

    /**
     * Creates the path commands that represent this slice
     * @return {object} The commands for drawing this slice. An object containing the sliceCommands and sliceBounds
     * @private
     */
    _getPath() {
      var isBiDi = dvt.Agent.isRightToLeft(this.getCtx());
      var seriesCount = DvtChartDataUtils.getSeriesCount(this._chart);
      var offset = (seriesCount - this._numDrawnSeries - 1) * this._gap;
      var center3DOffset = this._3dRatio * this._3D_WIDTH_FACTOR * 0.98 * this._pyramidWidth;
      var chartOptions = this._chart.getOptions();

      var heightToBottomEdge = Math.sqrt(
        Math.pow(this._pyramidHeight - (seriesCount - 1) * this._gap, 2) * (1 - this._startPercent)
      ); // height to bottom edge
      var heightToTopEdge =
        this._startPercent + this._valuePercent >= 1
          ? 0
          : Math.sqrt(
              Math.pow(this._pyramidHeight - (seriesCount - 1) * this._gap, 2) *
                (1 - this._startPercent - this._valuePercent)
            ); //height to top edge

      var topEdgeWidth =
        (1 - this._3dRatio * this._3D_WIDTH_FACTOR) *
        0.98 *
        this._pyramidWidth *
        (heightToTopEdge / this._pyramidHeight);
      var gapAdjustedHeightToBottom =
        this._numDrawnSeries == 0 ? heightToBottomEdge : heightToBottomEdge - this._gap;
      var bottomEdgeWidth =
        (1 - this._3dRatio * this._3D_WIDTH_FACTOR) *
        0.98 *
        this._pyramidWidth *
        (gapAdjustedHeightToBottom / this._pyramidHeight);

      var topLeftCoords, topRightCoords, bottomLeftCoords, bottomRightCoords; // naming is based on left to right case

      if (isBiDi) {
        topRightCoords = [
          this._pyramidWidth - 0.5 * this._pyramidWidth + center3DOffset / 2 - topEdgeWidth / 2,
          offset + heightToTopEdge
        ];
        bottomRightCoords = [
          this._pyramidWidth - 0.5 * this._pyramidWidth + center3DOffset / 2 - bottomEdgeWidth / 2,
          offset + heightToBottomEdge
        ];
        bottomLeftCoords = [
          this._pyramidWidth - 0.5 * this._pyramidWidth + center3DOffset / 2 + bottomEdgeWidth / 2,
          offset + heightToBottomEdge
        ];
        topLeftCoords = [
          this._pyramidWidth - 0.5 * this._pyramidWidth + center3DOffset / 2 + topEdgeWidth / 2,
          offset + heightToTopEdge
        ];
      } else {
        topLeftCoords = [
          0.5 * this._pyramidWidth - center3DOffset / 2 - topEdgeWidth / 2,
          offset + heightToTopEdge
        ];
        bottomLeftCoords = [
          0.5 * this._pyramidWidth - center3DOffset / 2 - bottomEdgeWidth / 2,
          offset + heightToBottomEdge
        ];
        bottomRightCoords = [
          0.5 * this._pyramidWidth - center3DOffset / 2 + bottomEdgeWidth / 2,
          offset + heightToBottomEdge
        ];
        topRightCoords = [
          0.5 * this._pyramidWidth - center3DOffset / 2 + topEdgeWidth / 2,
          offset + heightToTopEdge
        ];
      }

      var threeDPathTop, threeDPathSide;
      if (chartOptions['styleDefaults']['threeDEffect'] == 'on') {
        // 3D angle is 45 degrees
        // Our pyramids are not correctly drawn to perspective.  We need to fudge the position of the invisble vertex to avoid it
        // becoming visible for wide pyramids.  Proposed hack is to allow the angle of the invisible edge to be no larger than
        // 90% of the bottom angles of the front face
        var baseAngle = Math.atan((2 * heightToBottomEdge) / bottomEdgeWidth);
        var invisibleAngle = Math.min(baseAngle * 0.9, Math.PI / 4);
        var bottomEdge3DOffset =
          (this._3dRatio * this._3D_WIDTH_FACTOR * bottomEdgeWidth * Math.sqrt(2)) / 2;
        var topEdge3DOffset =
          (this._3dRatio * this._3D_WIDTH_FACTOR * topEdgeWidth * Math.sqrt(2)) / 2;
        var topEdge3DHiddenXOffset = topEdge3DOffset / Math.tan(invisibleAngle);

        // 3D Top
        threeDPathTop = dvt.PathUtils.moveTo(topRightCoords[0], topRightCoords[1]);
        threeDPathTop += dvt.PathUtils.lineTo(
          topRightCoords[0] + (isBiDi ? -1 : 1) * Math.max(topEdge3DOffset, 1),
          topRightCoords[1] - Math.max(topEdge3DOffset, 0.5)
        );
        threeDPathTop += dvt.PathUtils.lineTo(
          topLeftCoords[0] + (isBiDi ? -1 : 1) * Math.max(topEdge3DHiddenXOffset, 1),
          topLeftCoords[1] - Math.max(topEdge3DOffset, 0.5)
        );
        threeDPathTop += dvt.PathUtils.lineTo(topLeftCoords[0], topLeftCoords[1]);
        threeDPathTop += dvt.PathUtils.closePath();

        // 3D Side
        threeDPathSide = dvt.PathUtils.moveTo(topRightCoords[0], topRightCoords[1]);
        threeDPathSide += dvt.PathUtils.lineTo(
          topRightCoords[0] + (isBiDi ? -1 : 1) * Math.max(topEdge3DOffset, 1),
          topRightCoords[1] - Math.max(topEdge3DOffset, 0.5)
        );
        threeDPathSide += dvt.PathUtils.lineTo(
          bottomRightCoords[0] + (isBiDi ? -1 : 1) * bottomEdge3DOffset,
          bottomRightCoords[1] - bottomEdge3DOffset
        );
        threeDPathSide += dvt.PathUtils.lineTo(bottomRightCoords[0], bottomRightCoords[1]);
        threeDPathSide += dvt.PathUtils.closePath();
      }

      //2D Main face path commands
      var pathCommands = dvt.PathUtils.moveTo(topRightCoords[0], topRightCoords[1]);
      pathCommands += dvt.PathUtils.lineTo(bottomRightCoords[0], bottomRightCoords[1]);
      pathCommands += dvt.PathUtils.lineTo(bottomLeftCoords[0], bottomLeftCoords[1]);
      pathCommands += dvt.PathUtils.lineTo(topLeftCoords[0], topLeftCoords[1]);
      pathCommands += dvt.PathUtils.closePath();

      var topBottomEdgeRatio = topEdgeWidth / bottomEdgeWidth;
      // alternative calculations for top slice
      var sliceHeight =
        0.5 * Math.abs(topLeftCoords[1] - bottomLeftCoords[1]) * (1 + topBottomEdgeRatio);
      var sliceWidth =
        0.5 * Math.abs(bottomRightCoords[0] - bottomLeftCoords[0]) * (1 + topBottomEdgeRatio) -
        this._SLICE_LABEL_HORIZONTAL_PADDING;
      var sliceY = bottomLeftCoords[1] - sliceHeight;
      var sliceX = bottomLeftCoords[0] + (isBiDi ? -1 : 1) * ((bottomEdgeWidth - sliceWidth) / 2);
      var sliceBounds = new dvt.Rectangle(sliceX, sliceY, sliceWidth, sliceHeight);

      return { slice: pathCommands, sliceBounds, threeDPathTop, threeDPathSide };
    }

    /**
     * Creates a single slice label dvt.Text object associated with this slice.
     * @param {dvt.Rectangle} sliceBounds The space occupied by the slice this is associated with.
     * @return {dvt.OutputText} slice label for this slice
     * @private
     */
    _getSliceLabel(sliceBounds) {
      // Get and create the label string
      var labelString = DvtChartStyleUtils.getDataLabel(this._chart, this._seriesIndex, 0);
      if (!labelString)
        // if no data label set on the data item, set it from the series
        labelString = DvtChartDataUtils.getSeriesLabel(this._chart, this._seriesIndex);

      // Return if no label or label position none
      if (
        !labelString ||
        DvtChartGroupUtils.getDataLabelPos(this._chart, this._seriesIndex, 0) == 'none'
      )
        return;

      var label = new dvt.MultilineText(this.getCtx(), labelString, 0, 0);

      // Have to move the style setting first because was using wrong font size to come up with truncated text
      var isPatternBg = DvtChartStyleUtils.getPattern(this._chart, this._seriesIndex, 0) != null;
      var styleDefaults = this._chart.getOptions().styleDefaults;
      var labelStyleArray = [
        styleDefaults._dataLabelStyle,
        styleDefaults.dataLabelStyle,
        new dvt.CSSStyle(
          DvtChartDataUtils.getDataItem(this._chart, this._seriesIndex, 0)['labelStyle']
        )
      ];
      var style = dvt.CSSStyle.mergeStyles(labelStyleArray);
      label.setCSSStyle(style);

      // Truncating text and dropping if doesn't fit.
      if (
        !dvt.TextUtils.fitText(label, sliceBounds.w, sliceBounds.h, this, this._MIN_CHARS_DATA_LABEL)
      )
        return;

      var textDim = label.getDimensions();
      var pos = this._getLabelPos(sliceBounds);
      // Checking if the text starts within the bounding box.
      if (isPatternBg) {
        var padding = textDim.h * 0.15;
        var cmd = dvt.PathUtils.roundedRectangle(
          textDim.x - padding,
          textDim.y,
          textDim.w + 2 * padding,
          textDim.h,
          2,
          2,
          2,
          2
        );
        var bbox = new dvt.Path(this.getCtx(), cmd);
        bbox.setSolidFill(DvtChartStyleUtils.SERIES_PATTERN_BG_COLOR, 0.9);
        pos = pos.translate(-0.5 * textDim.w, -0.5 * textDim.h);
        bbox.setMatrix(pos);
        this.addChild(bbox);
      }
      var labelColor = isPatternBg
        ? dvt.ColorUtils.getContrastingTextColor(DvtChartStyleUtils.SERIES_PATTERN_BG_COLOR)
        : sliceBounds.containsPoint(sliceBounds.x + (sliceBounds.w - textDim.w) / 2, sliceBounds.y)
        ? dvt.ColorUtils.getContrastingTextColor(this._dataColor)
        : dvt.ColorUtils.getContrastingTextColor(null);
      // Don't want to override the color if it was set above, unless in high contrast mode.
      var labelColorStyle = new dvt.CSSStyle({ color: labelColor });
      labelStyleArray.splice(1, 0, labelColorStyle);
      if (dvt.Agent.isHighContrast()) {
        labelStyleArray.push(labelColorStyle);
      }
      style = dvt.CSSStyle.mergeStyles(labelStyleArray);
      label.setCSSStyle(style);
      label.setMatrix(this._getLabelPos(sliceBounds));
      label.alignCenter();
      label.alignMiddle();
      return label;
    }

    /**
     * Calculates the position of the text within this slice. Comes up with the translation matrix.
     * @param {dvt.Rectangle} sliceBounds The space occupied by the slice.
     * @return {dvt.Matrix} The matrix representing the transformation for placing the text.
     * @private
     */
    _getLabelPos(sliceBounds) {
      // Rotate the text
      var matrix = new dvt.Matrix();
      if (dvt.Agent.isRightToLeft(this.getCtx())) {
        matrix = matrix.translate(
          sliceBounds.x - sliceBounds.w / 2,
          sliceBounds.y + sliceBounds.h / 2
        );
      } else {
        matrix = matrix.translate(
          sliceBounds.x + sliceBounds.w / 2,
          sliceBounds.y + sliceBounds.h / 2
        );
      }
      return matrix;
    }

    /**
     * Passing on the colors for the pyramid slice object. Sets the slice fill and border color, as well as the selection and hover colors by reading them from the chart.
     * @param {dvt.Rectangle} sliceBounds The space occupied by the slice. This is used for calculating the gradient effect bounds.
     * @private
     */
    _setColorProps(sliceBounds) {
      var sliceFill = DvtChartSeriesEffectUtils.getFunnelPyramidSliceFill(
        this._chart,
        this._seriesIndex,
        this._dataColor,
        sliceBounds
      );
      var sliceBorder = DvtChartStyleUtils.getBorderColor(this._chart, this._seriesIndex, 0);
      var userBorderWidth = DvtChartStyleUtils.getUserBorderWidth(this._chart, this._seriesIndex, 0);
      var defaultBorderWidth = DvtChartStyleUtils.getDefaultBorderWidth(
        this._chart,
        this._seriesIndex,
        0
      );
      var borderWidth = userBorderWidth !== null ? userBorderWidth : defaultBorderWidth;

      var borderIsFrom3D = false;
      var isRedwood = this.getCtx().getThemeBehavior() === 'redwood';
      if (sliceBorder == null && this._3dRatio > 0) {
        borderIsFrom3D = true;
        sliceBorder = '#FFFFFF';
      }

      if (sliceBorder && !(isRedwood && this._chart.isSelectionSupported() && borderIsFrom3D)) {
        this.setSolidStroke(sliceBorder, null, borderWidth);
        if (this._3dRatio > 0) {
          this._threeDPathSide.setSolidStroke(sliceBorder, null, borderWidth);
          this._mainFace.setSolidStroke(sliceBorder, null, borderWidth);
        }
      }

      var hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(this._dataColor);

      if (this._3dRatio > 0) {
        var isSeriesEffectColor = !sliceFill.getPattern && !sliceFill.getAlphas;
        this._mainFace.setFill(sliceFill);
        this._mainFace.setStyle(DvtChartStyleUtils.getStyle(this._chart, this._seriesIndex, 0));
        this._mainFace.setClassName(
          DvtChartStyleUtils.getClassName(this._chart, this._seriesIndex, 0)
        );
        this._threeDPathSide.setFill(
          isSeriesEffectColor
            ? new dvt.SolidFill(dvt.ColorUtils.getDarker(sliceFill.getColor(), 0.3))
            : sliceFill
        );
        this._threeDPathSide.setStyle(DvtChartStyleUtils.getStyle(this._chart, this._seriesIndex, 0));
        this._threeDPathSide.setClassName(
          DvtChartStyleUtils.getClassName(this._chart, this._seriesIndex, 0)
        );
        this.setFill(
          isSeriesEffectColor
            ? new dvt.SolidFill(dvt.ColorUtils.getDarker(sliceFill.getColor(), 0.3))
            : sliceFill
        );
        this.setStyle(DvtChartStyleUtils.getStyle(this._chart, this._seriesIndex, 0));
        this.setClassName(DvtChartStyleUtils.getClassName(this._chart, this._seriesIndex, 0));
      } else {
        this.setFill(sliceFill);
        this.setStyle(DvtChartStyleUtils.getStyle(this._chart, this._seriesIndex, 0));
        this.setClassName(DvtChartStyleUtils.getClassName(this._chart, this._seriesIndex, 0));
      }

      // Save the original border stroke
      this.OriginalStroke = this.getStroke();

      if (this._chart.isSelectionSupported()) {
        this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());

        if (this._3dRatio > 0) {
          this._mainFace.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
          this._threeDPathSide.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
          if (isRedwood) {
            this._mainFace.setFeedbackClassName('oj-dvt-selectable');
            this._threeDPathSide.setFeedbackClassName('oj-dvt-selectable');
            var strokeColor = sliceBorder != null && !borderIsFrom3D ? sliceBorder : this._dataColor;
            var strokeWidth = userBorderWidth !== null ? userBorderWidth : 0;
            this._mainFace.setSolidStroke(strokeColor, null, strokeWidth);
            this._threeDPathSide.setSolidStroke(strokeColor, null, strokeWidth);
            if (sliceBorder) {
              if (borderIsFrom3D) {
                this._mainFace.addClassName('oj-dvt-default-border-color');
                this._threeDPathSide.addClassName('oj-dvt-default-border-color');
              }
              if (userBorderWidth == null) {
                this._mainFace.addClassName('oj-dvt-default-border-width');
                this._threeDPathSide.addClassName('oj-dvt-default-border-width');
              }
            }
          } else {
            var innerColor = DvtChartStyleUtils.getSelectedInnerColor(this._chart);
            var outerColor = DvtChartStyleUtils.getSelectedOuterColor(this._chart)
              ? DvtChartStyleUtils.getSelectedOuterColor(this._chart)
              : this._dataColor;
            this._mainFace.setHoverStroke(new dvt.Stroke(hoverColor, 1, 2));
            this._threeDPathSide.setHoverStroke(new dvt.Stroke(hoverColor, 1, 2));
            this._mainFace.setSelectedStroke(
              new dvt.Stroke(innerColor, 1, 1.5),
              new dvt.Stroke(outerColor, 1, 4.5)
            );
            this._mainFace.setSelectedHoverStroke(
              new dvt.Stroke(innerColor, 1, 1.5),
              new dvt.Stroke(hoverColor, 1, 4.5)
            );
          }
        } else {
          this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
          if (isRedwood) {
            this.setFeedbackClassName('oj-dvt-selectable');
            var strokeColor = sliceBorder != null && !borderIsFrom3D ? sliceBorder : this._dataColor;
            var strokeWidth = userBorderWidth !== null ? userBorderWidth : 0;
            this.setSolidStroke(strokeColor, null, strokeWidth);
            if (sliceBorder) {
              if (borderIsFrom3D) {
                this.addClassName('oj-dvt-default-border-color');
              }
              if (userBorderWidth == null) {
                this.addClassName('oj-dvt-default-border-width');
              }
            }
          } else {
            var innerColor = DvtChartStyleUtils.getSelectedInnerColor(this._chart);
            var outerColor = DvtChartStyleUtils.getSelectedOuterColor(this._chart)
              ? DvtChartStyleUtils.getSelectedOuterColor(this._chart)
              : this._dataColor;
            this.setHoverStroke(new dvt.Stroke(hoverColor, 1, 2));
            this.setSelectedStroke(
              new dvt.Stroke(innerColor, 1, 1.5),
              new dvt.Stroke(outerColor, 1, 4.5)
            );
            this.setSelectedHoverStroke(
              new dvt.Stroke(innerColor, 1, 1.5),
              new dvt.Stroke(hoverColor, 1, 4.5)
            );
          }
        }
      }
    }

    /**
     * Gets the percent values associated with the slice for animation
     * @return {array} the start, value and alpha for this slice.
     */
    getAnimParams() {
      return [this._startPercent, this._valuePercent, this.getAlpha(), this._3dRatio];
    }

    /**
     * Sets the percent values associated with the slice for animation
     * @param {array} ar The new start and value for this slice
     */
    setAnimParams(ar) {
      this._startPercent = ar[0];
      this._valuePercent = ar[1];
      this.setAlpha(ar[2]);
      this._3dRatio = ar[3];
      var cmds = this._getPath();

      if (this._threeDPathSide && this._mainFace) {
        this.setCmds(cmds['threeDPathTop']);
        this._threeDPathSide.setCmds(cmds['threeDPathSide']);
        this._mainFace.setCmds(cmds['slice']);
      } else this.setCmds(cmds['slice']);

      if (this._label) this._label.setMatrix(this._getLabelPos(cmds['sliceBounds']));
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this._3dRatio > 0) {
        this._mainFace.setSelected(selected);
        if (this.getCtx().getThemeBehavior() === 'redwood') {
          this._threeDPathSide.setSelected(selected);
        }
        if (selected) {
          var dims = this.getDimensions();
          var displacementX = 3;
          var displacementY = 5;
          // To make the selection effect more apparent - make the bars slightly smaller
          var w = dims.w;
          var h = dims.h;
          var scaleX = (w - displacementX) / w;
          var scaleY = (h - displacementY) / h;
          this._mainFace.setScaleX(scaleX);
          this._mainFace.setScaleY(scaleY);
          this._mainFace.setTranslateX(Math.ceil(displacementX / 2) + (displacementX / w) * dims.x);
          this._mainFace.setTranslateY(Math.ceil(displacementY / 2) + (displacementY / h) * dims.y);
        } else {
          this._mainFace.setScaleX(1);
          this._mainFace.setScaleY(1);
          this._mainFace.setTranslateX(0);
          this._mainFace.setTranslateY(0);
        }
      } else super.setSelected(selected);
    }

    /**
     * @override
     */
    showHoverEffect() {
      if (this.getCtx().getThemeBehavior() !== 'redwood' || this._3dRatio === 0) {
        super.showHoverEffect();
      }
      if (this._3dRatio > 0) {
        this._threeDPathSide.showHoverEffect();
        this._mainFace.showHoverEffect();
      }
    }

    /**
     * @override
     */
    hideHoverEffect() {
      if (this.getCtx().getThemeBehavior() !== 'redwood' || this._3dRatio === 0) {
        super.hideHoverEffect();
      }
      if (this._3dRatio > 0) {
        this._threeDPathSide.hideHoverEffect();
        this._mainFace.hideHoverEffect();
      }
    }

    /**
     * @override
     */
    copyShape() {
      return new DvtChartPyramidSlice(
        this._chart,
        this._seriesIndex,
        this._numDrawnSeries,
        this._pyramidWidth,
        this._pyramidHeight,
        this._startPercent,
        this._valuePercent,
        this._gap
      );
    }

    /**
     * Gets the fill for the main face shape.
     * @return {dvt.SoldFill}
     */
    getPrimaryFill() {
      return this._mainFace ? this._mainFace.getFill() : this.getFill();
    }
  }

  /**
   * Renderer for pyramid chart.
   * @class
   */
  const DvtChartPyramidRenderer = {
    /** @private @const */
    _DEFAULT_GAP_RATIO: 1 / 70,
    /** @private @const */
    _MAX_HEIGHT_FOR_GAPS: 0.25,
    /** @private @const */
    _GROUP_IDX: 0,

    /**
     * Renders the pyramid into the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (chart, container, availSpace) => {
      // Creating a container for the pyramid so that it can be rotated if vertical, also for animation.
      var pyramidContainer = new dvt.Container(chart.getCtx());
      pyramidContainer.setTranslate(availSpace.x, availSpace.y);
      container.addChild(pyramidContainer);
      chart.setPlotArea(pyramidContainer);

      var bbox = new dvt.Rectangle(0, 0, availSpace.w, availSpace.h);

      DvtChartEventUtils.addPlotAreaDnDBackground(chart, pyramidContainer, availSpace, true);

      if (!DvtChartPyramidRenderer._renderPyramidSlices(chart, pyramidContainer, bbox))
        DvtChartTextUtils.renderEmptyText(chart, container, availSpace);

      // Initial Selection
      var selected = DvtChartDataUtils.getInitialSelection(chart);
      DvtChartEventUtils.setInitialSelection(chart, selected);

      // Initial Highlighting
      chart.highlight(DvtChartDataUtils.getHighlightedCategories(chart));
    },

    /**
     * Renders all pyramid slices for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace
     * @return {boolean} true if pyramid slices have been rendered, false otherwise
     * @private
     */
    _renderPyramidSlices: (chart, container, availSpace) => {
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);

      // Compute the gap size
      var gapRatio = DvtChartStyleUtils.getDataItemGaps(chart);
      var defaultGapSize = DvtChartPyramidRenderer._DEFAULT_GAP_RATIO * availSpace.h;
      var maxGapSize = Math.min(
        (DvtChartPyramidRenderer._MAX_HEIGHT_FOR_GAPS * availSpace.h) / (seriesCount - 1),
        defaultGapSize
      );
      var gapSize = gapRatio * maxGapSize;

      var totalValue = 0; // the total value represented by the pyramid
      var numDrawnSeries = 0; // to keep track of how many series are drawn, so we don't add too many gaps if there are zero values
      var cumulativeValue = 0; // keeping track of the total up to this series

      // Iterate through the data to calculate the total value
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if it shouldn't be rendered
        if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIndex)) continue;

        // Do not render if the value is not positive
        var value = DvtChartDataUtils.getVal(chart, seriesIndex, DvtChartPyramidRenderer._GROUP_IDX);
        if (value <= 0) continue;
        totalValue += value;
      }

      if (totalValue == 0) return false;

      // Iterate through the data
      for (var seriesIdx = 0; seriesIdx < seriesCount; seriesIdx++) {
        // Skip the series if it shouldn't be rendered
        if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIdx)) continue;

        // Do not render if the value is not positive
        var val = DvtChartDataUtils.getVal(chart, seriesIdx, DvtChartPyramidRenderer._GROUP_IDX);
        if (val <= 0) continue;

        var slice = new DvtChartPyramidSlice(
          chart,
          seriesIdx,
          numDrawnSeries,
          availSpace.w,
          availSpace.h,
          cumulativeValue,
          val / totalValue,
          gapSize
        );
        cumulativeValue += val / totalValue;

        numDrawnSeries++; // keeping track of how many series have been drawn to create the gap.
        container.addChild(slice);
        DvtChartObjPeer.associate(slice, chart, seriesIdx, DvtChartPyramidRenderer._GROUP_IDX);
      }
      return true;
    }
  };

  /**
   *  Creates a selectable shape using SVG path commands.
   *  @extends {dvt.Path}
   *  @class DvtChartSelectableWedge  Creates an arbitrary shape using SVG path commands.
   *  @constructor
   *  @param {dvt.Context} context
   *  @param {number} cx  The center x position.
   *  @param {number} cy  The center y position.
   *  @param {number} rx  The horizontal radius of the ellipse.
   *  @param {number} ry  The vertical radius of the ellipse.
   *  @param {number} sa  The starting angle in degrees (following the normal anti-clockwise is positive convention).
   *  @param {number} ae  The angle extent in degrees (following the normal anti-clockwise is positive convention).
   *  @param {number} gap The data item gap.
   *  @param {number} ir The inner radius.
   *  @param {String} id  Optional ID for the shape (see {@link  dvt.Displayable#setId}).
   */
  class DvtChartSelectableWedge extends dvt.Path {
    /**
     *  Object initializer.
     *  @param {dvt.Context} context
     *  @param {Object} cmds  Optional string of SVG path commands (see comment for
     *                        {@link dvt.Path#setCmds}), or an array containing
     *                        consecutive command and coordinate entries (see comment
     *                        for {@link dvt.Path#setCommands}).
     * @param {String} id  Optional ID for the shape (see {@link  dvt.Displayable#setId}).
     *  @protected
     */
    /**
     *  Sets the path commands based on the wedge parameters
     *  @param {number} cx  The center x position.
     *  @param {number} cy  The center y position.
     *  @param {number} rx  The horizontal radius.
     *  @param {number} ry  The vertical radius.
     *  @param {number} sa  The starting angle in degrees (following the normal anti-clockwise is positive convention).
     *  @param {number} ae  The angle extent in degrees (following the normal anti-clockwise is positive convention).
     *  @param {number} gap The gap between wedges.
     *  @param {number} ir The inner radius of the wedge.
     */
    setWedgeParams(cx, cy, rx, ry, sa, ae, gap, ir) {
      this._cx = cx;
      this._cy = cy;
      this._rx = rx;
      this._ry = ry;
      this._sa = sa;
      this._ae = ae;
      this._gap = gap;
      this._ir = ir;
      var cmds = this._makeWedgePath(0);
      this.setCmds(cmds);
    }

    /**
     * Returns the path string for a wedge based on the set params.
     *  @param {number} inset  The number of pixels to inset the path.
     *  @return {String} the path commands for creating the wedge
     * @private
     */
    _makeWedgePath(inset) {
      var rx = Math.max(this._rx - inset, 0);
      var ry = Math.max(this._ry - inset, 0);
      var gap = this._ae == 360 || rx < inset ? 0 : this._gap + 2 * inset;
      var ir = this._ir ? this._ir + inset : 0;

      var angleExtentRads =
        this._ae == 360 ? dvt.Math.degreesToRads(359.99) : dvt.Math.degreesToRads(this._ae);

      var startAngleRads = dvt.Math.degreesToRads(this._sa);
      var dataItemGaps = gap / 2;

      var gapAngle = dataItemGaps < rx ? Math.asin(dataItemGaps / rx) : 0;
      var centerLineAngle = -angleExtentRads / 2 - startAngleRads;

      // distanceToStartPoint should be correlated with the dataItemGaps in that dimension- needed for 3D pies because rx != ry.
      var distanceToStartPointX = Math.min(
        dataItemGaps * 5,
        angleExtentRads > 0 ? Math.abs(dataItemGaps / Math.sin(angleExtentRads / 2)) : 0
      );
      var distanceToStartPointY = rx == 0 ? distanceToStartPointX : (distanceToStartPointX * ry) / rx;

      var startPointX = this._cx + Math.cos(centerLineAngle) * distanceToStartPointX;
      var startPointY = this._cy + Math.sin(centerLineAngle) * distanceToStartPointY;

      var arcPointX = this._cx + Math.cos(-gapAngle - startAngleRads) * rx;
      var arcPointY = this._cy + Math.sin(-gapAngle - startAngleRads) * ry;

      var arcPoint2X = this._cx + Math.cos(-startAngleRads - angleExtentRads + gapAngle) * rx;
      var arcPoint2Y = this._cy + Math.sin(-startAngleRads - angleExtentRads + gapAngle) * ry;

      var outerAngle = dvt.Math.calculateAngleBetweenTwoVectors(
        arcPoint2X - this._cx,
        arcPoint2Y - this._cy,
        arcPointX - this._cx,
        arcPointY - this._cy
      );
      outerAngle = Math.min(outerAngle, angleExtentRads);
      var pathCommands;
      if (ir > 0) {
        var innerGapAngle = dataItemGaps < ir ? Math.asin(dataItemGaps / ir) : 0;
        var innerPointX = this._cx + Math.cos(-innerGapAngle - startAngleRads) * ir;
        var innerPointY = this._cy + Math.sin(-innerGapAngle - startAngleRads) * ir;

        var innerPoint2X =
          this._cx + Math.cos(-startAngleRads - angleExtentRads + innerGapAngle) * ir;
        var innerPoint2Y =
          this._cy + Math.sin(-startAngleRads - angleExtentRads + innerGapAngle) * ir;

        var innerAngle = dvt.Math.calculateAngleBetweenTwoVectors(
          innerPoint2X - this._cx,
          innerPoint2Y - this._cy,
          innerPointX - this._cx,
          innerPointY - this._cy
        );
        innerAngle = Math.min(innerAngle, outerAngle, angleExtentRads);

        if (this._ae == 360) {
          pathCommands = dvt.PathUtils.moveTo(arcPoint2X, arcPoint2Y);
          pathCommands += dvt.PathUtils.arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);
          pathCommands += dvt.PathUtils.lineTo(arcPoint2X, arcPoint2Y);
          pathCommands += dvt.PathUtils.moveTo(innerPointX, innerPointY);
          pathCommands += dvt.PathUtils.arcTo(ir, ir, angleExtentRads, 0, innerPoint2X, innerPoint2Y);
        } else {
          pathCommands = dvt.PathUtils.moveTo(innerPoint2X, innerPoint2Y);
          pathCommands += dvt.PathUtils.lineTo(arcPoint2X, arcPoint2Y);
          pathCommands += dvt.PathUtils.arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);
          pathCommands += dvt.PathUtils.lineTo(innerPointX, innerPointY);
          pathCommands += dvt.PathUtils.arcTo(ir, ir, innerAngle, 0, innerPoint2X, innerPoint2Y);
        }
      } else {
        if (this._ae == 360) {
          pathCommands = dvt.PathUtils.moveTo(arcPoint2X, arcPoint2Y);
          pathCommands += dvt.PathUtils.arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);
        } else {
          pathCommands = dvt.PathUtils.moveTo(startPointX, startPointY);
          pathCommands += dvt.PathUtils.lineTo(arcPoint2X, arcPoint2Y);
          pathCommands += dvt.PathUtils.arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);
        }
      }

      pathCommands += dvt.PathUtils.closePath();
      return pathCommands;
    }

    /**
     * Helper function that creates and adds the shapes used for displaying hover and selection effects. Should only be
     * called on hover or select operations, since it assumes that the fill, stroke, and shape size are already determined.
     * @private
     */
    _initializeSelectionEffects() {
      // Calculate the geometry of the shapes used for the selection effects
      var isRedwood = this.getCtx().getThemeBehavior() === 'redwood';
      var outerBorderWidth =
        this.isSelected() || isRedwood
          ? DvtChartSelectableWedge._OUTER_BORDER_WIDTH
          : DvtChartSelectableWedge._OUTER_BORDER_WIDTH_HOVER;
      var outerChildCmds = this._makeWedgePath(outerBorderWidth);
      var innerChildCmds = this._makeWedgePath(
        outerBorderWidth + DvtChartSelectableWedge._INNER_BORDER_WIDTH
      );

      // Just update the geometries if already initialized
      if (this.OuterChild) {
        this.OuterChild.setCmds(outerChildCmds);
        this.InnerChild.setCmds(innerChildCmds);
        return;
      }

      this.OuterChild = new dvt.Path(this.getCtx(), outerChildCmds);
      this.OuterChild.setInvisibleFill();
      this.OuterChild.setMouseEnabled(true);
      this.addChild(this.OuterChild);

      this.InnerChild = new dvt.Path(this.getCtx(), innerChildCmds);
      this.InnerChild.setInvisibleFill();
      this.InnerChild.setMouseEnabled(true);
      this.addChild(this.InnerChild);
    }

    /**
     * Helper function to apply border colors for hover and selection.
     * @param {string=} outerBorderColor
     * @param {string=} innerBorderColor
     * @private
     */
    _showNestedBorders(outerBorderColor, innerBorderColor) {
      // Ensure that selection and hover shapes are created
      this._initializeSelectionEffects();
      // Modify the shapes based on which borders should be shown
      if (innerBorderColor) {
        this.setSolidFill(outerBorderColor);
        this.setStroke(null);
        this.setClassName().setStyle();

        this.OuterChild.setSolidFill(innerBorderColor);
        this.OuterChild.setClassName().setStyle();

        this.InnerChild.setFill(this._fill);
        this.InnerChild.setClassName(this._shapeClassName).setStyle(this._shapeStyle);
      } else if (outerBorderColor) {
        this.setSolidFill(outerBorderColor);
        this.setStroke(null);
        this.setClassName().setStyle();

        this.OuterChild.setFill(this._fill);
        this.OuterChild.setClassName(this._shapeClassName).setStyle(this._shapeStyle);

        this.InnerChild.setInvisibleFill();
        this.InnerChild.setClassName().setStyle();
      } else {
        this.setFill(this._fill);
        this.setStroke(this._shapeStroke);
        this.setClassName(this._shapeClassName).setStyle(this._shapeStyle);

        this.OuterChild.setInvisibleFill();
        this.OuterChild.setClassName().setStyle();

        this.InnerChild.setInvisibleFill();
        this.InnerChild.setClassName().setStyle();
      }
    }

    /**
     * Specifies the colors needed to generate the selection effect.
     * @param {dvt.Fill} fill
     * @param {dvt.Stroke} stroke
     * @param {string} dataColor The color of the data.
     * @param {string} innerColor The color of the inner selection border.
     * @param {string} outerColor The color of the outer selection border.
     * @param {string} className The className of the shape.
     * @param {object} style The style of the shape.
     */
    setStyleProperties(fill, stroke, dataColor, innerColor, outerColor, className, style) {
      this._fill = fill;
      // Save original stroke style to get reapplied in _showNestedBorders. Cannot use this._stroke, as it gets overwritten during select and hover
      this._shapeStroke = stroke;
      var isRedwood = this.getCtx().getThemeBehavior() === 'redwood';
      this._hoverColor = isRedwood
        ? dataColor
        : dvt.SelectionEffectUtils.getHoverBorderColor(dataColor);
      this._innerColor = innerColor;
      this._outerColor = outerColor;
      this._shapeClassName = className;
      this._shapeStyle = style;
      this.setStyle(style).setClassName(className);

      // Apply the fill and stroke
      this.setFill(fill);
      if (stroke) this.setStroke(stroke);
    }

    /**
     * @override
     */
    showHoverEffect() {
      this.IsShowingHoverEffect = true;
      var isRedwood = this.getCtx().getThemeBehavior() === 'redwood';
      var outerColor = isRedwood && this.isSelected() ? this._outerColor : this._hoverColor;
      this._showNestedBorders(outerColor, this._innerColor);
    }

    /**
     * @override
     */
    hideHoverEffect() {
      this.IsShowingHoverEffect = false;
      if (this.isSelected()) this._showNestedBorders(this._outerColor, this._innerColor);
      else this._showNestedBorders();
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this.IsSelected == selected) return;

      this.IsSelected = selected;
      var isRedwood = this.getCtx().getThemeBehavior() === 'redwood';
      if (this.isHoverEffectShown()) {
        var outerColor = isRedwood && this.isSelected() ? this._outerColor : this._hoverColor;
        this._showNestedBorders(outerColor, this._innerColor);
      } else if (this.isSelected()) this._showNestedBorders(this._outerColor, this._innerColor);
      else this._showNestedBorders();
    }

    /**
     * @override
     */
    UpdateSelectionEffect() {
      // noop: Selection effects fully managed by this class
    }
  }

  /** @private @const */
  DvtChartSelectableWedge._OUTER_BORDER_WIDTH = 2;

  /** @private @const */
  DvtChartSelectableWedge._OUTER_BORDER_WIDTH_HOVER = 1.25;

  /** @private @const */
  DvtChartSelectableWedge._INNER_BORDER_WIDTH = 1;

  /*---------------------------------------------------------------------*/
  /* Class DvtChartPieLabelInfo       Slice label information               */
  /*---------------------------------------------------------------------*/

  /** A property bag used to pass around information used for label placement
   *
   * @constructor
   */
  class DvtChartPieLabelInfo {
    constructor() {
      this._sliceLabel = null; // instance of dvt.OutputText or dvt.MultilineText
      this._slice = null; // DvtSlice we will associate _sliceLabel with, if we can fit the label
      this._angle = -1;

      // this._position is the normalized midpoint angle, where 0 degrees is at 12 o'clock
      //    and angular measures are degrees away from 12 o'clock (so 90 degrees
      //    can be either at 3 o'clock or 9 o'clock on the unit circle)
      this._position = -1;
      this._width = -1;
      this._height = -1;
      this._x = -1;
      this._y = -1;

      this._initialNumLines = -1;

      this._hasFeeler = false;

      this._maxY = -1;
      this._minY = -1;
    }

    /**
     * @return {number} Angle of the text in this slice label
     */
    getAngle() {
      return this._angle;
    }

    /**
     * @param {number} angle Sets the angle of the text in this slice label
     */
    setAngle(angle) {
      this._angle = angle;
    }

    /**
     * @return {number} The height of this slice label
     */
    getHeight() {
      return this._height;
    }

    /**
     * @param {number} height The height of this slice label
     */
    setHeight(height) {
      this._height = height;
    }

    /**
     * @return {number}
     */
    getInitialNumLines() {
      return this._initialNumLines;
    }

    /**
     * @param {number} numLines
     */
    setInitialNumLines(numLines) {
      this._initialNumLines = numLines;
    }

    /**
     * @return {number} The maximum Y position of this slice label
     */
    getMaxY() {
      return this._maxY;
    }

    /**
     * @param {number} maxY The maximum Y position of this slice label
     */
    setMaxY(maxY) {
      this._maxY = maxY;
    }

    /**
     * @return {number} The minimum Y position of this slice label
     */
    getMinY() {
      return this._minY;
    }

    /**
     * @param {number} minY The minimum Y position of this slice label
     */
    setMinY(minY) {
      this._minY = minY;
    }

    /**
     * bound the value of y within minY and maxY
     * assumes that maxY > minY
     * @param {number} y value
     * @return {number} bounded y value
     */
    boundY(y) {
      if (this._minY <= this._maxY) {
        y = Math.max(y, this._minY);
        y = Math.min(y, this._maxY);
      }
      return y;
    }

    /**
     * @return {boolean}
     */
    hasFeeler() {
      return this._hasFeeler;
    }

    /**
     * @param {boolean} hasFeeler
     */
    setHasFeeler(hasFeeler) {
      this._hasFeeler = hasFeeler;
    }

    /**
     * Returns the normalized midpoint angle, where 0 degrees is at 12 o'clock
     * and angular measures are degrees away from 12 o'clock (so 90 degrees
     * can be either at 3 o'clock or 9 o'clock on the unit circle)
     *
     * @return {number}
     */
    getPosition() {
      return this._position;
    }

    /**
     * Sets the normalized midpoint angle, where 0 degrees is at 12 o'clock
     * and angular measures are degrees away from 12 o'clock (so 90 degrees
     * can be either at 3 o'clock or 9 o'clock on the unit circle)
     *
     * @param {number} position
     */
    setPosition(position) {
      this._position = position;
    }

    /**
     * The slice that we want to associate the label with
     *
     * @return {DvtChartPieSlice}
     */
    getSlice() {
      return this._slice;
    }

    /**
     * @param {DvtChartPieSlice} slice
     */
    setSlice(slice) {
      this._slice = slice;
    }

    /**
     * The displayable associated with this SliceLabelInfo
     *
     * @return {dvt.OutputText|dvt.MultilineText}
     */
    getSliceLabel() {
      return this._sliceLabel;
    }

    /**
     * Sets the displayable this label info will layout
     *
     * @param {dvt.OutputText|dvt.MultilineText} label
     */
    setSliceLabel(label) {
      this._sliceLabel = label;
    }

    /**
     * @return {number} The width of this label
     */
    getWidth() {
      return this._width;
    }

    /**
     * @param {number} width
     */
    setWidth(width) {
      this._width = width;
    }

    /**
     * @return {number} The x-coordinate of the reference point for this label
     */
    getX() {
      return this._x;
    }

    /**
     * @param {number} x
     */
    setX(x) {
      this._x = x;
    }

    /**
     * @return {number} The y-coordinate of hte reference point for this label
     */
    getY() {
      return this._y;
    }

    /**
     * @param {number} y
     */
    setY(y) {
      this._y = y;
    }
  }

  /**
   * @class DvtChartPieRenderUtils
   */
  const DvtChartPieRenderUtils = {
    // surface types
    SURFACE_CRUST: 0,
    SURFACE_LEFT: 1,
    SURFACE_RIGHT: 2,

    /**
     * Returns a <code>Point</code> object representing a point at a given
     * angle at a distance specified by the rx and ry radius from the center cx, cy.
     *
     * Function reflects input angle over the y-axis.  It then scales the
     * cosine and sine of this angle by rx and ry, and then translates
     * the cosine and sine values by cx and cy.  The reflected, scaled, and
     * translated angle's cosine and sine values are then returned
     *
     * @param {number} angle A <code>Number</code> representing the desired angle in degrees.
     * @param {number} cx    A <code>Number</code> indicating the center horizontal position.
     * @param {number} cy    A <code>Number</code> indicating the center vertical position.
     * @param {number} rx    A <code>Number</code> indicating the horizontal radius.
     * @param {number} ry    A <code>Number</code> indicating the vertical radius.
     *
     * @return {object} A point object with the calculated x and y fields.
     */

    // original code taken from com.oracle.dvt.shape.draw.utils.RenderUtils
    // function originally called rotatePoint -- but that was a serious misnomer
    reflectAngleOverYAxis: (angle, cx, cy, rx, ry) => {
      var radian = dvt.Math.degreesToRads(360 - angle);
      var cosine = Math.cos(radian);
      var sine = Math.sin(radian);

      return { x: cx + cosine * rx, y: cy + sine * ry };
    },

    /**
     * Returns an array of colors (with no alphas) for use in creating a gradient, based on a base color and where the gradient
     * will be applied
     *
     * @param {String} baseColor
     * @param {String} style Either '2D', '3D', 'CRUST',
     *                          'SIDE', or 'BORDER'
     * @return {Array}
     */
    getGradientColors: (baseColor, style) => {
      if (style == '2D' || style == '3D')
        return [
          dvt.ColorUtils.adjustHSL(baseColor, 0, -0.04, -0.05),
          dvt.ColorUtils.adjustHSL(baseColor, 0, -0.09, 0.04)
        ];
      else if (style == 'CRUST')
        return [
          dvt.ColorUtils.adjustHSL(baseColor, 0, -0.04, -0.05),
          dvt.ColorUtils.adjustHSL(baseColor, 0, 0, -0.14)
        ];
      else if (style == 'SIDE')
        return [
          dvt.ColorUtils.adjustHSL(baseColor, 0, -0.1, 0.06),
          dvt.ColorUtils.adjustHSL(baseColor, 0, -0.04, -0.05)
        ];
      return undefined;
    },

    /**
     * Returns an array of alphas for use in creating a gradient, based on an initial alpha value and where the gradient
     * will be applied
     *
     * @param {number} baseAlpha
     * @param {String} style Either '2D', '3D', 'CRUST',
     *                          'SIDE', or 'BORDER'
     *
     * @return {Array}
     */
    getGradientAlphas: (baseAlpha, style) => {
      var alpha = baseAlpha == null || isNaN(baseAlpha) || baseAlpha == 0 ? 1.0 : baseAlpha;
      if (style == '2D') return [alpha, alpha, alpha];
      else if (style == 'BORDER')
        return [alpha / (0xff / 0xa0), alpha / (0xff / 0x30), alpha / (0xff / 0x60)];
      else if (style == '3D') return [alpha, alpha, alpha, alpha, alpha];
      else if (style == 'CRUST') return [alpha, alpha, alpha, alpha];
      else if (style == 'SIDE') return [alpha, alpha];

      return undefined;
    },

    /*
     * Static methods for generating the physical shapes that make up the different pieces of a DvtChartPieSlice
     */

    /**
     * @this {DvtChartPieSlice}
     * Returns an array of dvt.Shape objects representing the top of a pie slice
     *
     * @param {DvtChartPieSlice} slice The slice to generate the top for
     * @param {dvt.Fill} fill The fill for the top
     * @return {Array} An array of dvt.Shape objects representing the top of this pie slice
     */
    createTopSurface: (slice, fill) => {
      var pieChart = slice.getPieChart();
      var context = pieChart.getCtx();
      var pieCenter = slice.getCenter();

      var innerRadius = slice.getInnerRadius();
      var sliceGaps =
        pieChart.is3D() ||
        slice.getSliceGaps() >
          Math.sin(dvt.Math.degreesToRads(slice.getAngleExtent())) * slice._radiusX + 1
          ? null
          : slice.getSliceGaps();
      var wedge = new DvtChartSelectableWedge(context);
      wedge.setWedgeParams(
        pieCenter.x,
        pieCenter.y,
        slice._radiusX,
        slice._radiusY,
        slice.getAngleStart(),
        slice.getAngleExtent(),
        sliceGaps,
        innerRadius
      );

      var innerColor = DvtChartStyleUtils.getSelectedInnerColor(pieChart.chart);
      var outerColor = DvtChartStyleUtils.getSelectedOuterColor(pieChart.chart);
      var stroke = new dvt.Stroke(slice.getStrokeColor(), 1, slice.getBorderWidth());

      var seriesIndex = slice.getSeriesIndex();
      var className = DvtChartStyleUtils.getClassName(pieChart.chart, seriesIndex, 0);
      var style = DvtChartStyleUtils.getStyle(pieChart.chart, seriesIndex, 0);
      wedge.setStyleProperties(
        fill,
        stroke,
        slice.getFillColor(),
        innerColor,
        outerColor,
        className,
        style
      );

      var shapes = [wedge];

      // Associate the shapes with the slice for use during event handling
      DvtChartPieRenderUtils.associate(slice, shapes);

      return shapes;
    },

    /**
     * Associates the specified displayables with the specified slice.
     * @param {DvtChartPieSlice} slice The owning slice.
     * @param {array} displayables The displayables to associate.
     */
    associate: (slice, displayables) => {
      if (!displayables) return;

      for (var i = 0; i < displayables.length; i++)
        slice.getPieChart().chart.getEventManager().associate(displayables[i], slice);
    },
    /**
     * Generates any lateral (non-top) pie surface
     *
     * @param {DvtChartPieSlice} slice
     * @param {number} pathType One of DvtChartPieRenderUtils.SURFACE_CRUST,
     *                          DvtChartPieRenderUtils.SURFACE_LEFT, or DvtChartPieRenderUtils.SURFACE_RIGHT
     * @param {dvt.Fill} fill The fill for the lateral surface
     *
     * @return {Array} An array of dvt.Shape objects representing this lateral surface
     */
    // replaces PieSlice._draw
    createLateralSurface: (slice, pathType, fill) => {
      // handle the case where we are animating a slice insert
      // initially, this slice will have 0 extent. in this case
      // don't generate any surface
      if (slice.getAngleExtent() == 0) {
        return [];
      }

      var talpha = dvt.ColorUtils.getAlpha(slice.getFillColor());
      var shapes = [];

      if (talpha > 0) {
        if (
          pathType == DvtChartPieRenderUtils.SURFACE_LEFT ||
          pathType == DvtChartPieRenderUtils.SURFACE_RIGHT
        ) {
          shapes.push(DvtChartPieRenderUtils._generateLateralShape(slice, pathType, null, fill));
        } else if (pathType == DvtChartPieRenderUtils.SURFACE_CRUST) {
          var pathCommands = DvtChartPieRenderUtils._createCrustPathCommands(slice);

          var len = pathCommands.length;
          for (var i = 0; i < len; i++) {
            shapes.push(
              DvtChartPieRenderUtils._generateLateralShape(slice, pathType, pathCommands[i], fill)
            );
          }
        }
      }

      // Associate the shapes with the slice for use during event handling
      DvtChartPieRenderUtils.associate(slice, shapes);

      return shapes;
    },

    /**
     * Create the gradient fill used for lateral surfaces.
     * @param {DvtChartPieSlice} slice
     * @param {String} objType One of 'CRUST' or 'SIDE'
     * @return {dvt.LinearGradientFill}
     */
    generateLateralGradientFill: (slice, objType) => {
      var angle = 270;
      var arColors = DvtChartPieRenderUtils.getGradientColors(
        dvt.ColorUtils.getRGB(slice.getFillColor()),
        objType
      );
      var arAlphas = DvtChartPieRenderUtils.getGradientAlphas(
        dvt.ColorUtils.getAlpha(slice.getFillColor()),
        objType
      );
      var arRatios = [0, 1.0];
      var arBounds = null;
      return new dvt.LinearGradientFill(angle, arColors, arAlphas, arRatios, arBounds);
    },

    /**
     * Private method that generates an array of dvt.Shape objects for different lateral pie surfaces
     *
     * @param {DvtChartPieSlice} slice
     * @param {number} pathType One of DvtChartPieRenderUtils.SURFACE_CRUST,
     *                          DvtChartPieRenderUtils.SURFACE_LEFT, or DvtChartPieRenderUtils.SURFACE_RIGHT
     * @param {String} pathCommand  A string of SVG commands in SVG "d" attribute format. Used when pathType is
     *                              DvtChartPieRenderUtils.SURFACE_CRUST. Can be set to null otherwise
     * @param {dvt.Fill} fill The fill to apply to the shapes
     *
     * @return {dvt.Shape} A right or left pie surface, or a piece of a crust, as described in pathCommands
     *
     * @private
     */
    _generateLateralShape: (slice, pathType, pathCommand, fill) => {
      var pie = slice.getPieChart();
      var context = pie.getCtx();
      // left side points and right side points
      if (
        pathType == DvtChartPieRenderUtils.SURFACE_LEFT ||
        pathType == DvtChartPieRenderUtils.SURFACE_RIGHT
      ) {
        var angle = slice.getAngleStart();
        var arc = slice.getAngleExtent();
        var xCenter = slice.getCenter().x;
        var yCenter = slice.getCenter().y;
        var xRadius = slice._radiusX;
        var yRadius = slice._radiusY;
        var depth = slice.getDepth();

        var pt =
          pathType == DvtChartPieRenderUtils.SURFACE_LEFT
            ? DvtChartPieRenderUtils.reflectAngleOverYAxis(
                angle + arc,
                xCenter,
                yCenter,
                xRadius,
                yRadius
              )
            : DvtChartPieRenderUtils.reflectAngleOverYAxis(angle, xCenter, yCenter, xRadius, yRadius);
        var pointArray = DvtChartPieRenderUtils._generateInnerPoints(
          xCenter,
          yCenter,
          pt.x,
          pt.y,
          depth
        );

        var points = [];
        for (var i = 0; i < pointArray.length; i++) {
          points.push(pointArray[i].x, pointArray[i].y);
        }

        var polygon = new dvt.Polygon(context, points);

        polygon.setFill(fill);
        if (slice.getStrokeColor()) polygon.setSolidStroke(slice.getStrokeColor());

        return polygon;
      } // draw piece of pie crust
      else {
        if (pathCommand) {
          var path = new dvt.Path(context, null);

          path.setCmds(pathCommand);
          path.setTranslate(slice.__getExplodeOffsetX(), slice.__getExplodeOffsetY());

          path.setFill(fill);
          if (slice.getStrokeColor()) {
            path.setSolidStroke(slice.getStrokeColor());
          }

          return path;
        }
      }

      return null;
    },

    /**
     * Returns an array of path commands describing how to draw a pie crust
     *
     * @param {DvtChartPieSlice} slice
     *
     * @return {Array} An array of strings of SVG commands in SVG "d" attribute format.
     *                 e.g., [ [command1 x1, y1, ..., commandi xn, yn, ...], [commandj xs, ys, ...] ]
     *
     * @private
     */
    _createCrustPathCommands: (slice) => {
      var angle = slice.getAngleStart();
      var arc = slice.getAngleExtent();
      var angleEnd = angle + arc;
      var xCenter = slice.getCenter().x;
      var yCenter = slice.getCenter().y;
      var xRadius = slice._radiusX;
      var yRadius = slice._radiusY;
      var depth = slice.getDepth();

      // If slice crosses 0 degrees (right horizontal x-axis), we need to break crust into 2 pieces joined at the crossing
      // point so that the right side of the slice appears to be a solid 3D wall. If slice crosses 180 degrees (left
      // horizontal x-axis), we need to break crust into 2 pieces joined at the crossing point so that the left side of the
      // slice appears to be a solid 3D wall.
      var arOuterPath = [];
      if (angle < 180.0 && angleEnd > 360.0) {
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            angle,
            180.0 - angle
          )
        ); // left
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            360.0,
            angleEnd - 360.0
          )
        ); // right
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            180.0,
            180.0
          )
        ); // center
      } else if (angleEnd > 360.0) {
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            angle,
            360.0 - angle
          )
        );
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            360.0,
            angleEnd - 360.0
          )
        );
      } else if (angle < 180.0 && angleEnd > 180.0) {
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            angle,
            180.0 - angle
          )
        );
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(
            xCenter,
            yCenter,
            xRadius,
            yRadius,
            depth,
            180.0,
            angleEnd - 180.0
          )
        );
      } else
        arOuterPath.push(
          DvtChartPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, angle, arc)
        );

      return arOuterPath;
    },

    /**
     * Returns the path string for a segment of the outer crust of a pie slice.
     * @param {number} cx The x coordinate of the center of the pie.
     * @param {number} cy The y coordinate of the center of the pie.
     * @param {number} rx The radius of the pie.
     * @param {number} ry The radius of the pie.
     * @param {number} depth The depth of the pie.
     * @param {number} startAngle The start angle in degrees.
     * @param {number} angleExtent The angular extent in degrees.  Always less than 180 degrees (half the pie).
     * @return {String} An SVG string that represents part of the crust.
     * @private
     */
    _makeOuterPath: (cx, cy, rx, ry, depth, startAngle, angleExtent) => {
      var angleExtentRads = dvt.Math.degreesToRads(angleExtent);
      var endAngleRads = -(dvt.Math.degreesToRads(startAngle) + angleExtentRads);

      // Calculate the start and end points on the top curve
      var startPointTop = DvtChartPieRenderUtils.reflectAngleOverYAxis(startAngle, cx, cy, rx, ry);
      var endPointTopX = cx + Math.cos(endAngleRads) * rx;
      var endPointTopY = cy + Math.sin(endAngleRads) * ry;

      // Top Curve
      var pathCommands = dvt.PathUtils.moveTo(startPointTop.x, startPointTop.y);
      pathCommands += dvt.PathUtils.arcTo(rx, ry, angleExtentRads, 0, endPointTopX, endPointTopY);

      // Line to Bottom Curve
      pathCommands += dvt.PathUtils.lineTo(endPointTopX, endPointTopY + depth);

      // Bottom Curve
      pathCommands += dvt.PathUtils.arcTo(
        rx,
        ry,
        angleExtentRads,
        1,
        startPointTop.x,
        startPointTop.y + depth
      );

      // Line to Top Curve
      pathCommands += dvt.PathUtils.lineTo(startPointTop.x, startPointTop.y);

      return pathCommands;
    },
    /**
     * Private function to generate the points for the left or right pie surface
     *
     * @param {number} cx The x-coordinate of the center of the pie slice
     * @param {number} cy The y-coordinate of the center of the pie slice
     * @param {number} xpos The x-coordinate of the top, outside (left or right) edge of the pie slice
     * @param {number} ypos The y-coordinate of the top, outside (left or right) edge of the pie slice
     * @param {number} tilt Pie tilt
     *
     * @return {Array} An array of points that are the coordinates for the left or right surface of a pie slice
     *
     * @private
     */
    _generateInnerPoints: (cx, cy, xpos, ypos, tilt) => {
      var pointArray = [];
      pointArray.push({ x: cx, y: cy });
      pointArray.push({ x: xpos, y: ypos });
      pointArray.push({ x: xpos, y: ypos + tilt });
      pointArray.push({ x: cx, y: cy + tilt });
      return pointArray;
    }
  };

  /*---------------------------------------------------------------------*/
  /*   DvtChartPieLabelUtils                                                  */
  /*---------------------------------------------------------------------*/

  /**
   * @class DvtChartPieLabelUtils
   */
  const DvtChartPieLabelUtils = {
    /** @private */
    _MAX_LINES_PER_LABEL: 3,
    /** @private */
    _COLLISION_MARGIN: 1,
    /** @private */
    _LEFT_SIDE_LABELS: 1,
    /** @private */
    _RIGHT_SIDE_LABELS: 2,
    /** @private */
    _OUTSIDE_LABEL_DISTANCE: 1.04, // distance from the slice, as a ratio of the radius

    //constants for column layout
    /** @private */
    _FEELER_RAD_MINSIZE: 0.1, // ratio to the pie diameter
    /** @private */
    _FEELER_HORIZ_MINSIZE: 0.1, // ratio to the pie diameter
    /** @private */
    _LABEL_TO_FEELER_OFFSET: 0.5, // ratio to the label height
    /** @private */
    _LABEL_TO_FEELER_DISTANCE: 3, // in pixels
    /** @private */
    _NO_COLLISION: 0,
    /** @private */
    _HALF_COLLISION: 1,
    /** @private */
    _ALL_COLLISION: 2,

    /**
     * Public entry point called by DvtChartPie to layout the pie chart's labels and feelers.
     * @param {DvtChartPie} pie the pie chart
     */
    layoutLabelsAndFeelers: (pie) => {
      var labelPosition = pie.getLabelPos();
      DvtChartPieLabelUtils._layoutInsideLabels(pie, labelPosition == 'auto');
      DvtChartPieLabelUtils._layoutOutsideLabelsAndFeelers(pie);
    },

    /**
     * Lays out labels that appear within the pie slices.
     * @param {DvtChartPie} pie the pie chart
     * @param {boolean} isHybrid Whether the labeling is inside/outside hybrid
     * @private
     */
    _layoutInsideLabels: (pie, isHybrid) => {
      var slices = pie.__getSlices();

      for (var i = 0; i < slices.length; i++) {
        var slice = slices[i];
        // Only doing layout for inside labels, so skip any labels that have a position of none or outside
        var labelPosition = pie.getSeriesLabelPos(slice.getSeriesIndex());
        if (
          labelPosition == 'none' ||
          labelPosition == 'outsideSlice' ||
          DvtChartPieLabelUtils._skipSliceLabel(pie, slice)
        )
          continue;

        var midAngle = slice.getAngleStart() + slice.getAngleExtent() / 2;
        var ir = slice.getInnerRadius();
        var center = slice.getCenter();
        var posX = 0;
        var posY = 0;
        var sliceLabel = DvtChartPieLabelUtils._createLabel(slice, true);

        if (slices.length == 1) {
          // Center the label
          posX = center.x;
          posY = center.y;
        } else {
          var offset = Math.max(0.45, 0.65 - (0.45 * ir) / Math.max(slice.getRadiusY(), 0.001));
          var midPt = DvtChartPieRenderUtils.reflectAngleOverYAxis(
            midAngle,
            center.x,
            center.y,
            ir + (slice.getRadiusX() - ir) * offset,
            ir + (slice.getRadiusY() - ir) * offset
          );

          posX = midPt.x;
          posY = midPt.y;
        }

        sliceLabel.setX(posX);
        sliceLabel.setY(posY);
        sliceLabel.alignMiddle();
        sliceLabel.alignCenter();

        // Find the estimated dimensions of the label
        var sliceLabelDims = sliceLabel.getDimensions();

        // Find the largest rectangle that will fit.  The height is accurate, so we only need to check the width.
        var x1 = posX;
        var x2 = posX;
        var y1 = posY - sliceLabelDims.h / 2;
        var y2 = posY + sliceLabelDims.h / 2;

        // Calculate the left-most x1 that will fit
        while (slice.contains(x1, y1) && slice.contains(x1, y2)) {
          x1--;
        }

        // Calculate the right-most x2 that will fit
        while (slice.contains(x2, y1) && slice.contains(x2, y2)) {
          x2++;
        }

        // Add a 3-pixel buffer on each side (accounts for the potential extra pixel in the while loop on failed check)
        x1 = Math.ceil(x1 + 3);
        x2 = Math.floor(x2 - 3);

        // Adjust the anchor point to the midpoint of available space if truncation would occur centered at current anchor
        var usableSpace = 2 * Math.min(posX - x1, x2 - posX);
        if (usableSpace < sliceLabelDims.w) {
          sliceLabel.setX((x1 + x2) / 2);
          usableSpace = x2 - x1;
        }

        // Don't want to use the automatic hybrid layout if slice label position is specifically set as center
        if (isHybrid && labelPosition != 'center') {
          var textWidth = sliceLabel.getDimensions().w;
          if (textWidth < usableSpace) slice.setSliceLabel(sliceLabel);
          else slice.setSliceLabel(null); // use outside label
        } else {
          // Truncate the text.  It will be added to the chart later, so remove if it is added.
          var stage = pie.getCtx().getStage();
          var minChars = !DvtChartPieLabelUtils._isTextLabel(pie, slice)
            ? sliceLabel.getTextString().length
            : null;
          if (dvt.TextUtils.fitText(sliceLabel, usableSpace, sliceLabelDims.h, stage, minChars)) {
            stage.removeChild(sliceLabel);
            slice.setSliceLabel(sliceLabel);
          }
        }

        // If hybrid labeling, the slice can animate from having a outsideLabel + feeler to being inside. In this case, we
        // need to clear the outside feeler so that it doesn't stay around.
        if (slice.getSliceLabel() != null) slice.setNoOutsideFeeler();
      }
    },

    /**
     * Lays out labels (and feelers if necessary) that appear outside the pie slices
     * @param {DvtChartPie} pie The pie chart
     * @private
     */
    _layoutOutsideLabelsAndFeelers: (pie) => {
      var leftLabels = [];
      var rightLabels = [];

      // -----------------------------------------------------------
      // Build arrays of Left side and Right side Labels
      //
      // When computing the positioning of the labels, we consider
      // angles to be measured from the 12 o'clock position,
      // i.e., 12 o'clock is 0 degrees.
      // Angular measurements then range from 0 to 180.
      // A value of 90 degrees can then be either at the
      // 3 o'clock position or at the 9 o'clock position
      // -----------------------------------------------------------
      var alabels = DvtChartPieLabelUtils._generateInitialLayout(pie);

      leftLabels = alabels[0];
      rightLabels = alabels[1];

      // -----------------------------------------------------------
      // Evaluate initial label layout from generateInitialLayout
      // -----------------------------------------------------------
      var leftColl = DvtChartPieLabelUtils._refineInitialLayout(
        pie,
        leftLabels,
        DvtChartPieLabelUtils._LEFT_SIDE_LABELS
      );
      var rightColl = DvtChartPieLabelUtils._refineInitialLayout(
        pie,
        rightLabels,
        DvtChartPieLabelUtils._RIGHT_SIDE_LABELS
      );

      if (
        leftColl == DvtChartPieLabelUtils._HALF_COLLISION &&
        rightColl != DvtChartPieLabelUtils._NO_COLLISION
      )
        DvtChartPieLabelUtils._columnLabels(pie, leftLabels, true, true, true);
      if (
        leftColl != DvtChartPieLabelUtils._NO_COLLISION &&
        rightColl == DvtChartPieLabelUtils._HALF_COLLISION
      )
        DvtChartPieLabelUtils._columnLabels(pie, rightLabels, false, true, true);

      DvtChartPieLabelUtils._setLabelsAndFeelers(
        pie,
        leftLabels,
        DvtChartPieLabelUtils._LEFT_SIDE_LABELS
      );
      DvtChartPieLabelUtils._setLabelsAndFeelers(
        pie,
        rightLabels,
        DvtChartPieLabelUtils._RIGHT_SIDE_LABELS
      );
    },

    /**
     * Create a label for the given pie slice. Label positioning is done elsewhere
     * @param {DvtChartPieSlice} slice
     * @param {boolean} isInside True if the label is inside the slice.
     * @return {dvt.OutputText|dvt.MultilineText}
     * @private
     */
    _createLabel: (slice, isInside) => {
      var isHighContrast = dvt.Agent.isHighContrast();
      var pieChart = slice.getPieChart();

      var context = pieChart.getCtx();
      var isOtherSlice = slice.getId().series === DvtChartPieUtils.OTHER_ID;
      var hasPattern =
        DvtChartStyleUtils.getPattern(pieChart.chart, slice.getSeriesIndex(), 0) != null ||
        (isOtherSlice && DvtChartStyleUtils.getSeriesEffect(pieChart) == 'pattern');
      var needsPatternBg = isInside && hasPattern;
      var sliceLabel;
      if (needsPatternBg) {
        sliceLabel = new dvt.BackgroundOutputText(context);
      } else {
        sliceLabel = isInside ? new dvt.OutputText(context) : new dvt.MultilineText(context);
      }

      // Apply the label color- read all applicable styles and merge them.
      var contrastColor = needsPatternBg
        ? dvt.ColorUtils.getContrastingTextColor(DvtChartStyleUtils.SERIES_PATTERN_BG_COLOR)
        : isInside
        ? dvt.ColorUtils.getContrastingTextColor(slice.getFillColor())
        : dvt.ColorUtils.getContrastingTextColor(dvt.ColorUtils.getColorFromName('black'));
      var contrastColorStyle = new dvt.CSSStyle({ color: contrastColor });
      var styleDefaults = pieChart.getOptions().styleDefaults;
      var labelStyleArray = [styleDefaults._dataLabelStyle];
      if (isInside) {
        labelStyleArray.push(contrastColorStyle);
      }
      labelStyleArray.push(styleDefaults.dataLabelStyle);
      var dataItem = DvtChartDataUtils.getDataItem(pieChart.chart, slice.getSeriesIndex(), 0);
      if (dataItem) {
        labelStyleArray.push(new dvt.CSSStyle(dataItem.labelStyle));
      }

      if (isHighContrast) {
        labelStyleArray.push(contrastColorStyle);
      }
      if (needsPatternBg) {
        var backgroundColorStyle = new dvt.CSSStyle({
          'background-color': 'rgba(255, 255, 255, 0.9)',
          'border-radius': '2px'
        });
        labelStyleArray.push(backgroundColorStyle);
      }
      var style = dvt.CSSStyle.mergeStyles(labelStyleArray);
      sliceLabel.setCSSStyle(style);

      var labelStr = DvtChartPieLabelUtils.generateSliceLabelString(
        slice,
        styleDefaults['sliceLabelType']
      );
      sliceLabel.setTextString(labelStr);
      slice.setSliceLabelString(labelStr);

      return sliceLabel;
    },
    /**
     * Create the center content for pie chart.
     * @param {DvtChartPie} pieChart the pie chart
     */
    createPieCenter: (pieChart) => {
      var options = pieChart.getOptions();
      var context = pieChart.getCtx();
      var pieCenter = DvtChartPieLabelUtils.getPieCenterOptions(pieChart, options);
      var centerLabel = pieCenter['label'];
      var centerRenderer = pieCenter['renderer'];
      var dataLabelPosition = pieChart.getLabelPos();
      var customTooltip = options['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;
      var centerCoord = pieChart.getCenter();
      var innerRadius = pieChart.getInnerRadius();

      if (!centerLabel && !centerRenderer) return;

      var radiusX = pieChart.getRadiusX();
      var defaultInnerRadius = dataLabelPosition == 'outsideSlice' ? 0.9 * radiusX : 0.5 * radiusX;
      innerRadius = innerRadius > 0 ? innerRadius : defaultInnerRadius;
      var innerSquareDimension = innerRadius * Math.sqrt(2);
      if (centerLabel) {
        var centerText = new dvt.MultilineText(context);
        var centerStyle = pieCenter['labelStyle'];
        centerText.setCSSStyle(centerStyle);

        // Scaling and Converter option handler
        if (typeof centerLabel === 'number') {
          centerLabel = DvtChartFormatUtils$1.formatVal(
            pieChart,
            pieCenter,
            centerLabel,
            centerLabel,
            centerLabel,
            0
          );
        }

        centerText.setTextString(centerLabel);
        if (dvt.TextUtils.fitText(centerText, innerSquareDimension, innerSquareDimension, pieChart)) {
          var textDim = centerText.getDimensions();
          centerText.setY(centerCoord.y - textDim.h / 2);
          centerText.setX(centerCoord.x);
          centerText.alignCenter();

          // Associate with logical object to support automation and truncation
          if (!tooltipFunc)
            pieChart.chart.getEventManager().associate(
              centerText,
              new dvt.SimpleObjPeer(centerText.getTextString(), null, null, {
                type: 'pieCenterLabel'
              })
            );
          pieChart.addChild(centerText);
          pieChart.setCenterLabel(centerText);
        }
      }

      // If there is a tooltip callback function, overlay a circular object over the center area.
      if (tooltipFunc) {
        var centerOverlay = new dvt.Circle(context, centerCoord.x, centerCoord.y, innerRadius);
        centerOverlay.setInvisibleFill();
        pieChart.addChild(centerOverlay);
        var tooltipManager = pieChart.getCtx().getTooltipManager();
        pieChart.chart.getEventManager().associate(
          centerOverlay,
          new dvt.CustomDatatipPeer(tooltipManager, tooltipFunc, '#4b4b4b', {
            component: options['_widgetConstructor'],
            label: centerLabel
          })
        );
      }

      if (centerRenderer) {
        var dataContext = {
          outerBounds: {
            x: centerCoord.x - innerRadius,
            y: centerCoord.y - innerRadius,
            width: 2 * innerRadius,
            height: 2 * innerRadius
          },
          innerBounds: {
            x: centerCoord.x - innerSquareDimension / 2,
            y: centerCoord.y - innerSquareDimension / 2,
            width: innerSquareDimension,
            height: innerSquareDimension
          },
          label: centerLabel,
          totalValue: pieChart.getTotalValue(),
          component: options['_widgetConstructor']
        };
        dataContext = context.fixRendererContext(dataContext);
        var parentDiv = context.getContainer();

        // Remove existing overlay if there is one
        var existingOverlay = pieChart.chart.pieCenterDiv;
        if (existingOverlay) parentDiv.removeChild(existingOverlay);

        var customContent = centerRenderer(dataContext);
        if (!customContent) return;
        var newOverlay = context.createOverlayDiv();
        if (Array.isArray(customContent)) {
          customContent.forEach((node) => {
            newOverlay.appendChild(node); // @HTMLUpdateOK
          });
        } else if (typeof customContent === 'string') {
          newOverlay.textContent = customContent;
          newOverlay.style.position = 'absolute';
          newOverlay.style.left = `${centerCoord.x}px`;
          newOverlay.style.top = `${centerCoord.y}px`;
          newOverlay.style.transform = 'translate(-50%, -50%)';
          newOverlay.style.width = `${2 * innerRadius}px`;
          newOverlay.style.height = `${2 * innerRadius}px`;
          newOverlay.style.display = 'flex';
          newOverlay.style.textAlign = 'center';
          newOverlay.style.alignItems = 'center';
        } else {
          newOverlay.appendChild(customContent); // @HTMLUpdateOK
        }
        pieChart.chart.pieCenterDiv = newOverlay;
        parentDiv.appendChild(newOverlay); // @HTMLUpdateOK

        // Invoke the overlay attached callback if one is available.
        var callback = context.getOverlayAttachedCallback();
        if (callback) callback(newOverlay);
      }
    },
    /**
     * Returns the untruncated label text for a given pie slice
     * @param {DvtChartPieSlice} slice
     * @param {string} labelType The label type.
     * @return {string} The full, untruncated label string, or null if the slice's pie chart is configured to not display labels
     */
    generateSliceLabelString: (slice, labelType) => {
      var functionLabel;
      var defaultLabel = DvtChartPieLabelUtils.getDefaultSliceLabelString(slice, labelType);

      // Use data Label function if there is one
      var dataLabelFunc = slice.getPieChart().getOptions()['dataLabel'];

      if (dataLabelFunc) {
        var dataContext = DvtChartStyleUtils.getDataContext(slice._chart, slice.getSeriesIndex(), 0);
        dataContext['label'] = defaultLabel;
        functionLabel = dataLabelFunc(dataContext);
        if (typeof functionLabel == 'number') {
          var valueFormat = DvtChartFormatUtils$1.getValueFormat(slice.getPieChart().chart, 'label');
          functionLabel = DvtChartFormatUtils$1.formatVal(
            slice.getPieChart(),
            valueFormat,
            functionLabel
          );
        }
      }

      return functionLabel ? functionLabel : defaultLabel;
    },
    /**
     * Returns the default label text for a given pie slice and ignores the dataLabel function
     * @param {DvtChartPieSlice} slice
     * @param {string} labelType The label type.
     * @return {string} The full, default label string, or null if the slice's pie chart is configured to not display labels
     */
    getDefaultSliceLabelString: (slice, labelType) => {
      var pieChart = slice.getPieChart();

      // If customLabel exists it will be the slice label. If a converter is set, apply converter to customLabel
      var customLabel = slice.getCustomLabel();
      var valueFormat = DvtChartFormatUtils$1.getValueFormat(pieChart.chart, 'label');
      if (customLabel != null) {
        if (typeof customLabel == 'number')
          return DvtChartFormatUtils$1.formatVal(pieChart, valueFormat, customLabel);
        return customLabel;
      }

      if (labelType == 'percent') return DvtChartPieLabelUtils.generateSlicePercentageString(slice);
      else if (labelType == 'number')
        return DvtChartFormatUtils$1.formatVal(pieChart, valueFormat, slice.getVal());
      else if (labelType == 'text') return slice.getSeriesLabel();
      else if (labelType == 'textAndPercent')
        return (
          slice.getSeriesLabel() + ', ' + DvtChartPieLabelUtils.generateSlicePercentageString(slice)
        );
      return null;
    },
    /**
     * Returns the default percentage string for a given pie slice
     * @param {DvtChartPieSlice} slice
     * @return {string} The default percentage string for the slice
     */
    generateSlicePercentageString: (slice) => {
      var pieChart = slice.getPieChart();

      var totalValue = pieChart.getTotalValue();
      var percentage = totalValue == 0 ? 0 : slice.getVal() / totalValue;
      var onesDigits = percentage < 1 ? 1 : 0;
      var tenthsDigits = percentage < 0.1 ? 2 : onesDigits;
      var decDigits = percentage < 0.01 ? 3 : tenthsDigits;
      // For pies smaller than a certain size, drop to fewer significant digits so that the labels can display.
      if (pieChart.getRadiusX() * 2 < 150) decDigits = Math.max(decDigits - 1, 0);

      var formats = pieChart.getOptions().valueFormats;
      var customConverter;
      if (formats && formats.label && formats.label.converter) {
        customConverter = formats.label.converter;
      }
      var percentConverter = pieChart.getCtx().getNumberConverter({
        style: 'percent',
        maximumFractionDigits: decDigits,
        minimumFractionDigits: decDigits
      });
      var spercent = '';

      if (customConverter && customConverter['format']) {
        spercent = customConverter['format'](percentage);
      } else if (percentConverter && percentConverter['format']) {
        // Apply the percent converter if present
        spercent = percentConverter['format'](percentage);
      } else {
        percentage *= 100;
        // If the percentage is 100%, make sure to display it without any fractions ("100%" not "100.0%")
        spercent =
          DvtChartFormatUtils$1.formatVal(
            pieChart,
            {},
            percentage,
            null,
            null,
            percentage == 100 ? 1 : Math.pow(10, -1 * decDigits)
          ) + '%';
      }

      return spercent;
    },
    /**
     * Called after initial naive layout is generated to resolve label collisions
     *
     * @param {DvtChartPie} pie
     * @param {Array} labelInfoArray An array of DvtChartPieLabelInfo objects
     * @param {number} side Either DvtChartPieLabelUtils._LEFT_SIDE_LABELS or DvtChartPieLabelUtils._RIGHT_SIDE_LABELS
     * @return {number} DvtChartPieLabelUtils._ALL_COLLISION, DvtChartPieLabelUtils._HALF_COLLISION, or DvtChartPieLabelUtils._NO_COLLISION
     * @private
     */
    _refineInitialLayout: (pie, labelInfoArray, side) => {
      if (labelInfoArray && labelInfoArray.length > 0) {
        var lastY = pie.__getFrame().y; //think again!!
        var collisionTop = false;
        var collisionCentral = false;
        var collisionBottom = false;
        var labelBottom = 0;

        var labelInfo;

        var bottomQuarter = false;
        var prevBottomQuarter;
        var collide = false;
        var isLeftSideLabels = side == DvtChartPieLabelUtils._LEFT_SIDE_LABELS;

        for (var i = 0; i < labelInfoArray.length; i++) {
          labelInfo = labelInfoArray[i];

          prevBottomQuarter = bottomQuarter;
          if (labelInfo.getPosition() > 90) bottomQuarter = true;

          labelBottom = labelInfo.getY() + labelInfo.getHeight();

          collide = lastY - labelInfo.getY() > DvtChartPieLabelUtils._COLLISION_MARGIN;

          if (collide) {
            if (!bottomQuarter) {
              collisionTop = true;
            } else if (!prevBottomQuarter) {
              collisionCentral = true;
            } else {
              collisionBottom = true;
            }
          }

          if (labelBottom > lastY) {
            lastY = labelBottom;
          }
        }

        if ((collisionTop && collisionBottom) || collisionCentral) {
          DvtChartPieLabelUtils._columnLabels(pie, labelInfoArray, isLeftSideLabels, true, true);
          return DvtChartPieLabelUtils._ALL_COLLISION;
        } else if (collisionTop) {
          DvtChartPieLabelUtils._columnLabels(pie, labelInfoArray, isLeftSideLabels, true, false); //top only
          return DvtChartPieLabelUtils._HALF_COLLISION;
        } else if (collisionBottom) {
          DvtChartPieLabelUtils._columnLabels(pie, labelInfoArray, isLeftSideLabels, false, true); //bottom only
          return DvtChartPieLabelUtils._HALF_COLLISION;
        }
        return DvtChartPieLabelUtils._NO_COLLISION;
      }
      return undefined;
    },

    // ported over from PieChart.as, renderLabelsAndFeelers
    /**
     *
     * Sets the location of the label objects as specified in the DvtChartPieLabelInfo objects in alabels.
     * When this method returns, the DvtChartPie labels corresponding to the DvtChartPieLabelInfo objects in alabels
     * will have their layout positions set, and will be ready to render
     *
     * @param {DvtChartPie} pie
     * @param {Array} alabels An array of DvtChartPieLabelInfo objects.
     * @param {number} side Either DvtChartPieLabelUtils._LEFT_SIDE_LABELS or DvtChartPieLabelUtils._RIGHT_SIDE_LABELS
     * @private
     */
    _setLabelsAndFeelers: (pie, alabels, side) => {
      if (alabels == null || alabels.length <= 0) return;

      var i;
      var slice; // instance of DvtChartPieSlice
      var sliceLabel; // instance of dvt.OutputText or dvt.MultilineText
      var labelInfo; // instance of DvtChartPieLabelInfo
      var isLeftSide = side == DvtChartPieLabelUtils._LEFT_SIDE_LABELS;
      var frame = pie.__getFrame();

      var excessWidth = Infinity;
      var excessLength;

      // Determine how much the horizontal feelers can be shortened
      for (i = 0; i < alabels.length; i++) {
        labelInfo = alabels[i];
        slice = labelInfo.getSlice();

        if (labelInfo.hasFeeler()) {
          excessLength = DvtChartPieLabelUtils._calculateFeeler(labelInfo, slice, isLeftSide);

          // For numeric labels, the minLabelWidth is equal to the labelWidth because anything shorter will be skipped.
          // For text labels, the minLabelWidth is one character + ellipses ("S...") because if it is shorter than that then
          // fitText() will completely remove the label. We estimate that width as twice the font height.
          var fontHeight = dvt.TextUtils.getTextStringHeight(
            pie.getCtx(),
            labelInfo.getSliceLabel().getCSSStyle()
          );
          var labelWidth = labelInfo.getWidth();
          var minLabelWidth = DvtChartPieLabelUtils._isTextLabel(pie, slice)
            ? Math.min(2 * fontHeight, labelWidth)
            : labelWidth;
          var maxLabelWidth = DvtChartPieLabelUtils.getMaxLabelWidth(
            pie,
            labelInfo.getX(),
            isLeftSide
          );

          // Remove feelers for labels that will not be rendered and ignore for excess width calculation
          if (maxLabelWidth + excessLength < minLabelWidth || labelInfo.getWidth() == 0) {
            labelInfo.setSliceLabel(null);
            slice.setNoOutsideFeeler();
            continue;
          }
          excessWidth = Math.min(excessWidth, excessLength);
        } else slice.setNoOutsideFeeler();
      }

      for (i = 0; i < alabels.length; i++) {
        labelInfo = alabels[i];
        slice = labelInfo.getSlice();
        sliceLabel = labelInfo.getSliceLabel();
        if (!sliceLabel) continue;

        if (labelInfo.hasFeeler()) {
          // shorten the horizontal feelers
          if (isLeftSide) {
            labelInfo.setX(labelInfo.getX() + excessWidth);
          } else {
            labelInfo.setX(labelInfo.getX() - excessWidth);
          }
          // setup the feeler line (let it clip if needed)
          DvtChartPieLabelUtils._calculateFeeler(labelInfo, slice, isLeftSide);
        }

        sliceLabel.setY(labelInfo.getY());
        sliceLabel.setX(labelInfo.getX());

        // perform 'logical' clipping ourselves
        if (
          labelInfo.getY() < frame.y ||
          labelInfo.getY() + labelInfo.getHeight() > frame.y + frame.h
        ) {
          slice.setSliceLabel(null);
          slice.setNoOutsideFeeler(); //  - don't show feelers if the label is 'clipped' (invisible)
        } else {
          DvtChartPieLabelUtils._truncateSliceLabel(pie, slice, labelInfo, isLeftSide);
          // If slice label has zero dimensions, don't add it to the slice, and disable feelers
          if (labelInfo.getWidth() == 0 || labelInfo.getHeight() == 0) {
            slice.setSliceLabel(null);
            slice.setNoOutsideFeeler();
          } else slice.setSliceLabel(sliceLabel);
        }
      }
    },

    // replaces PieChart.drawFeeler
    /**
     *
     * Sets the feeler line that extends from the pie to the targetPt on the given slice. This method computes where
     * on the pie the feeler line should start, and then the start point and targetPt are set on the input slice.
     *
     * @param {DvtChartPieLabelInfo} labelInfo A DvtChartPieLabelInfo object
     * @param {DvtChartPieSlice} slice A DvtChartPieSlice object
     * @param {boolean} isLeft Boolean indicating if these labels are on the left side of the pie
     * @return {number} The excess length of the horizontal feeler, i.e. the length of the horizontal feeler minus the minimum length
     * @private
     */
    _calculateFeeler: (labelInfo, slice, isLeft) => {
      var targetX = labelInfo.getX();
      var targetY =
        labelInfo.getY() + labelInfo.getHeight() * DvtChartPieLabelUtils._LABEL_TO_FEELER_OFFSET;
      var minHorizLength = DvtChartPieLabelUtils._FEELER_HORIZ_MINSIZE * slice.getRadiusX();

      var midX;
      if (isLeft) {
        targetX += DvtChartPieLabelUtils._LABEL_TO_FEELER_DISTANCE;
        midX = targetX + minHorizLength;
      } else {
        targetX -= DvtChartPieLabelUtils._LABEL_TO_FEELER_DISTANCE;
        midX = targetX - minHorizLength;
      }

      var midPt = {
        x: midX,
        y: targetY
      };
      var endPt = {
        x: targetX,
        y: targetY
      };
      var ma = labelInfo.getAngle();
      var tilt = DvtChartPieLabelUtils._adjustForDepth(ma, slice.getDepth());

      var startPt = DvtChartPieRenderUtils.reflectAngleOverYAxis(
        ma,
        slice.getCenter().x,
        slice.getCenter().y + tilt,
        slice.getRadiusX(),
        slice.getRadiusY()
      );

      // make set the first section of the feeler radial if possible
      var pa = dvt.Math.degreesToRads(labelInfo.getPosition());
      var radFeelerAngle = Math.abs(Math.atan2(midPt.x - startPt.x, startPt.y - midPt.y));
      var horizOffset = (startPt.y - midPt.y) * Math.tan(pa); // * pieChart.getRadiusX() / pieChart.getRadiusY();
      if (
        (pa > Math.PI / 2 && radFeelerAngle > Math.PI / 2 && radFeelerAngle < pa) ||
        (pa < Math.PI / 2 && radFeelerAngle < Math.PI / 2 && radFeelerAngle > pa)
      ) {
        if (isLeft) {
          midPt.x = startPt.x - horizOffset;
        } else {
          midPt.x = startPt.x + horizOffset;
        }
      }

      //store outside feeler points on slice
      //and let slice draw the feeler so that we can
      //easily redraw it when selecting
      slice.setOutsideFeelerPoints(startPt, midPt, endPt);
      return Math.abs(endPt.x - midPt.x) - minHorizLength;
    },

    /**

    * Generates the offset of a label feeler to account for the depth of a 3d pie.
    *
    * @param {number} ma The angle on the unit circle from which the leaderline should originate from
    * @param {number} pieDepth The pie chart's depth
    *
    * @return {number} The offset for the feeler line
    * @private
    */
    _adjustForDepth: (ma, pieDepth) => {
      var depth = 0;
      var leftMidHi = 189;
      var rightMidHi = 351;

      if (ma > leftMidHi && ma < rightMidHi) {
        depth = pieDepth;
      }

      return depth;
    },

    /**
     *  Finds the label corresponding to the most horizontal slice
     *
     *  @param {Array} alabels An array of DvtChartPieLabelInfo objects
     *  @return {number} the index of the most horizontal slice
     *  @private
     */
    _getMiddleLabel: (alabels) => {
      var bestAngle = 91;
      var bestIndex = -1;
      for (var i = 0; i < alabels.length; i++) {
        var pa = alabels[i].getPosition();
        if (Math.abs(pa - 90) < bestAngle) {
          bestAngle = Math.abs(pa - 90);
          bestIndex = i;
        }
      }
      return bestIndex;
    },

    /**
     * Sets the label at its optimal position, assuming all other labels do not exist.
     * @param {DvtChartPie} pie
     * @param {DvtChartPieLabelInfo} labelInfo
     * @param {number} vertX The x-position where the labels are aligned.
     * @param {boolean} isLeft Whether the label is on the left side of the pie.
     * @private
     */
    _setOptimalLabelPos: (pie, labelInfo, vertX, isLeft) => {
      //set optimal X
      labelInfo.setX(vertX);

      //set optimal Y
      //  var a = pie.getRadiusX() * (1 + DvtChartPieLabelUtils._FEELER_RAD_MINSIZE);
      var b = pie.getRadiusY() * (1 + DvtChartPieLabelUtils._FEELER_RAD_MINSIZE);
      var angleInRad = dvt.Math.degreesToRads(labelInfo.getPosition());
      var heightFromCenter = b * Math.cos(angleInRad);
      var tilt = DvtChartPieLabelUtils._adjustForDepth(labelInfo.getAngle(), pie.getDepth());
      var optimalY =
        pie.getCenter().y -
        heightFromCenter -
        labelInfo.getHeight() * DvtChartPieLabelUtils._LABEL_TO_FEELER_OFFSET +
        tilt;
      labelInfo.setY(labelInfo.boundY(optimalY));
    },
    /**
     * Calculates the feeler angle for this label based on the projected x and y positions of the label outside of the slice
     * @param {DvtChartPieLabelInfo} labelInfo
     * @param {number} x The x position
     * @param {number} y The y position
     * @return {number} The angle for the feeler line
     * @private
     */
    _getRadFeelerAngle: (labelInfo, x, y) => {
      var slice = labelInfo.getSlice();
      var center = slice.getCenter();
      var ma = labelInfo.getAngle();
      var tilt = DvtChartPieLabelUtils._adjustForDepth(ma, slice.getDepth());
      var startPt = DvtChartPieRenderUtils.reflectAngleOverYAxis(
        ma,
        center.x,
        center.y + tilt,
        slice.getRadiusX(),
        slice.getRadiusY()
      );
      return Math.atan2(Math.abs(x - startPt.x), startPt.y - y);
    },
    /**
     *  Adjusts the label locations by positioning the labels vertically in a column
     *  @param {DvtChartPie} pie
     *  @param {Array} alabels An array of DvtChartPieLabelInfo objects
     *  @param {boolean} isLeft Boolean indicating if these labels are on the left side of the pie
     *  @param {boolean} isTop Boolean indicating if these labels are on the top of the pie
     *  @param {boolean} isBottom Boolean indicating if these labels are at the bottom of the pie
     *  @private
     */
    _columnLabels: (pie, alabels, isLeft, isTop, isBottom) => {
      var frame = pie.__getFrame();
      var minY = frame.y;
      var maxY = frame.y + frame.h;
      var i;
      var labelInfo;
      var pa = 0;
      var radFeelerAngle;

      //determine the position where the column will be aligned
      var vertX = pie.getCenter().x;
      var feelerX;
      var minFeelerDist =
        pie.getRadiusX() *
        (1 + DvtChartPieLabelUtils._FEELER_RAD_MINSIZE + DvtChartPieLabelUtils._FEELER_HORIZ_MINSIZE);

      if (isLeft) {
        vertX -= minFeelerDist;
        feelerX = vertX + pie.getRadiusX() * DvtChartPieLabelUtils._FEELER_HORIZ_MINSIZE;
      } else {
        vertX += minFeelerDist;
        feelerX = vertX - pie.getRadiusX() * DvtChartPieLabelUtils._FEELER_HORIZ_MINSIZE;
      }

      //set the minimum heights that ensures as many labels as possible are displayed
      for (i = 0; i < alabels.length; i++) {
        labelInfo = alabels[i];
        pa = dvt.Math.degreesToRads(labelInfo.getPosition());
        radFeelerAngle = DvtChartPieLabelUtils._getRadFeelerAngle(labelInfo, feelerX, minY);

        // Remove labels that are more than a certain angle away from the slice.
        if (
          radFeelerAngle - pa > 0.45 * Math.PI ||
          DvtChartPieLabelUtils._skipSliceLabel(pie, labelInfo.getSlice())
        ) {
          alabels.splice(i, 1);
          i--;
        } else {
          alabels[i].setMinY(minY);
          minY += alabels[i].getHeight();
        }
      }

      //set the maximum heights that ensures as many labels as possible are displayed
      for (i = alabels.length - 1; i >= 0; i--) {
        labelInfo = alabels[i];
        pa = dvt.Math.degreesToRads(labelInfo.getPosition());
        radFeelerAngle = DvtChartPieLabelUtils._getRadFeelerAngle(labelInfo, feelerX, maxY);

        // Remove labels that are more than a certain angle away from the slice.
        if (
          pa - radFeelerAngle > 0.45 * Math.PI ||
          DvtChartPieLabelUtils._skipSliceLabel(pie, labelInfo.getSlice())
        ) {
          alabels.splice(i, 1);
        } else {
          maxY -= alabels[i].getHeight();
          alabels[i].setMaxY(maxY);
        }
      }

      if (alabels.length == 0) return;

      var startIndex = DvtChartPieLabelUtils._getMiddleLabel(alabels);
      var startLabel = alabels[startIndex];

      //if the column is only partial but there are too many labels, then set the whole side as column
      if (isTop && !isBottom) {
        if (startLabel.getMinY() + startLabel.getHeight() > pie.getCenter().y) {
          isBottom = true;
        }
      }
      if (isBottom && !isTop) {
        if (startLabel.getMaxY() < pie.getCenter().y) {
          isTop = true;
        }
      }

      var labelPostion = startLabel.getPosition();
      if ((isBottom && isTop) || (labelPostion > 90 && isBottom) || (labelPostion <= 90 && isTop)) {
        DvtChartPieLabelUtils._setOptimalLabelPos(pie, startLabel, vertX, isLeft);
        startLabel.setHasFeeler(true);
      }

      var highestY = startLabel.getY();
      var lowestY = startLabel.getY() + startLabel.getHeight();

      var optimalY;
      var labelHeight;

      if (isTop) {
        //labels above the start label
        for (i = startIndex - 1; i >= 0; i--) {
          labelInfo = alabels[i];
          labelHeight = labelInfo.getHeight();
          DvtChartPieLabelUtils._setOptimalLabelPos(pie, labelInfo, vertX, isLeft);
          labelInfo.setHasFeeler(true);

          //avoid collision with the label below
          optimalY = labelInfo.getY();
          if (optimalY + labelHeight < highestY) {
            highestY = optimalY;
          } else {
            highestY -= labelHeight;
          }
          labelInfo.setY(highestY);
        }
      }

      if (isBottom) {
        //labels below the start label
        for (i = startIndex + 1; i < alabels.length; i++) {
          labelInfo = alabels[i];
          labelHeight = labelInfo.getHeight();
          DvtChartPieLabelUtils._setOptimalLabelPos(pie, labelInfo, vertX, isLeft);
          labelInfo.setHasFeeler(true);

          //avoid collision with the label above
          optimalY = labelInfo.getY();
          if (optimalY > lowestY) {
            lowestY = optimalY + labelHeight;
          } else {
            lowestY += labelHeight;
          }
          labelInfo.setY(lowestY - labelHeight);
        }
      }
    },
    /**
     *
     * Truncates the label for the last time after the final X position is calculated
     *
     * @param {DvtChartPie} pie
     * @param {DvtChartPieSlice} slice
     * @param {DvtChartPieLabelInfo} labelInfo
     * @param {boolean} isLeft Boolean indicating whether or not this slice is on the left side of the pie
     *
     * @return {boolean} True if the height is modified after truncation, false otherwise
     * @private
     */
    _truncateSliceLabel: (pie, slice, labelInfo, isLeft) => {
      var sliceLabel = labelInfo.getSliceLabel();
      var style = sliceLabel.getCSSStyle();
      var maxLabelWidth = 0;
      var tmDimPt;

      // before setting the label displayable, make sure it is added to the DOM
      // necessary because the displayable will try to wrap, and to do that,
      // it needs to get the elements dimensions, which it can only do if it's
      // added to the DOM
      var numChildren = pie.getNumChildren();
      var removeTextArea = false;
      if (!pie.contains(sliceLabel)) {
        pie.addChild(sliceLabel);
        removeTextArea = true;
      }

      sliceLabel.setCSSStyle(style);
      var labelStr = slice.getSliceLabelString();
      sliceLabel.setTextString(labelStr);

      if (removeTextArea) {
        pie.removeChildAt(numChildren);
      }

      maxLabelWidth = DvtChartPieLabelUtils.getMaxLabelWidth(pie, labelInfo.getX(), isLeft);

      // truncates with larger space
      tmDimPt = DvtChartPieLabelUtils._getTextDim(
        pie,
        slice,
        sliceLabel,
        maxLabelWidth,
        labelInfo.getInitialNumLines()
      );

      // Update labelinfo
      labelInfo.setWidth(tmDimPt.x);

      if (labelInfo.getHeight() != tmDimPt.y) {
        labelInfo.setHeight(tmDimPt.y); // new height
        return true;
      }

      return false;
    },

    /**
     * Create initial layout, placing each label in its ideal location. Locations will be subsequently updated
     * to account for collisions
     * @param {DvtChartPie} pie
     * @return {Array}  An array with two elements. The first element is an array of DvtChartPieLabelInfo objects for the
     *                  labels on the left side of the pie.  The second element is an array of DvtChartPieLabelInfo objects
     *                  for the labels on the right side of the pie.
     * @private
     */
    _generateInitialLayout: (pie) => {
      var arArrays = [];
      var leftLabels = [];
      var rightLabels = [];

      var slices = pie.__getSlices();
      var frame = pie.__getFrame();

      for (var i = 0; i < slices.length; i++) {
        var slice = slices[i];
        // Only doing layout for outside labels, so skip any labels that have a position of none or inside, or was already positioned inside in auto layout
        var labelPosition = pie.getSeriesLabelPos(slice.getSeriesIndex());
        if (
          slice.getSliceLabel() != null ||
          labelPosition == 'none' ||
          labelPosition == 'center' ||
          DvtChartPieLabelUtils._skipSliceLabel(pie, slice)
        )
          continue;

        var s_label = DvtChartPieLabelUtils._createLabel(slice, false);

        var ma = slice.getAngleStart() + slice.getAngleExtent() / 2;
        if (ma > 360) ma -= 360;
        if (ma < 0) ma += 360;

        var labelPt = DvtChartPieRenderUtils.reflectAngleOverYAxis(
          ma,
          pie.getCenter().x,
          pie.getCenter().y,
          pie.getRadiusX() * DvtChartPieLabelUtils._OUTSIDE_LABEL_DISTANCE,
          pie.getRadiusY() * DvtChartPieLabelUtils._OUTSIDE_LABEL_DISTANCE
        );

        var isLeftSide = ma >= 90 && ma < 270;
        var maxLabelWidth = DvtChartPieLabelUtils.getMaxLabelWidth(pie, labelPt.x, isLeftSide);

        var tmDimPt = DvtChartPieLabelUtils._getTextDim(
          pie,
          slice,
          s_label,
          maxLabelWidth,
          DvtChartPieLabelUtils._MAX_LINES_PER_LABEL
        ); // set up for word wrap
        var midArea = 15;

        if (ma < 180 - midArea && ma > midArea) {
          //upper half
          labelPt.y -= tmDimPt.y * 1;
        } else if (ma < midArea || ma > 360 - midArea) {
          //right side, near horizontal
          labelPt.y -= tmDimPt.y * 0.5;
          labelPt.x += tmDimPt.y * 0.2;
        } else if (ma > 180 - midArea && ma < 180 + midArea) {
          //left side, near horizontal
          labelPt.y -= tmDimPt.y * 0.5;
          labelPt.x -= tmDimPt.y * 0.2;
        }

        var tilt = DvtChartPieLabelUtils._adjustForDepth(ma, pie.getDepth());
        labelPt.y += tilt;

        if (slices.length == 1)
          // only 1 label
          labelPt.x -= tmDimPt.x / 2; //position the label at the center

        if (labelPt.y < frame.y || labelPt.y + tmDimPt.y > frame.y + frame.h)
          // label will not fit with appropriate spacing
          continue;

        var pa;
        if (ma >= 90.0 && ma < 270.0) {
          // left side
          // right align
          s_label.alignRight();
          //        s_label.alignTop();  // alignTop impl buggy - too much interline space in FF
          // normalize from 0 to 180
          pa = ma - 90.0;
          DvtChartPieLabelUtils._createLabelInfo(
            slice,
            s_label,
            ma,
            pa,
            tmDimPt,
            labelPt,
            leftLabels
          );
        } else {
          // right side
          // normalize from 0 to 180
          pa = ma <= 90.0 ? Math.abs(90 - ma) : 180 - (ma - 270);
          DvtChartPieLabelUtils._createLabelInfo(
            slice,
            s_label,
            ma,
            pa,
            tmDimPt,
            labelPt,
            rightLabels
          );
        }
      }

      arArrays[0] = leftLabels;
      arArrays[1] = rightLabels;

      return arArrays;
    },
    /**
     * Create the DvtChartPieLabelInfo property bag object for a given slice and inserts it into labelInfoArray,
     * it its properly sorted position (where top-most labels are at the start of the array)
     *
     * @param {DvtChartPieSlice} slice
     * @param {dvt.OutputText|dvt.MultilineText} sliceLabel  The physical label we will associate with thie DvtChartPieLabelInfo. This
     label will be the one eventually associated with the input slice, if this
    label gets rendered
    * @param {number} ma The angle for the feeler line, with 0 degrees being the standard
    *                    0 degrees in the trigonometric sense (3 o'clock position)
    * @param {number} pa The normalized midpoint angle, where 0 degrees is at 12 o'clock
    *                    and angular measures are degrees away from 12 o'clock (so 90 degrees
    *                    can be either at 3 o'clock or 9 o'clock on the unit circle. Used to order slice
    *                    labels from top to bottom
    * @param {object} tmDimPt Object representing the width and height of the slice label
    * @param {object} labelPt The outside endpoint of the feeler line
    * @param {Array} labelInfoArray Where we store the newly created DvtChartPieLabelInfo
    * @private
    */
    _createLabelInfo: (slice, sliceLabel, ma, pa, tmDimPt, labelPt, labelInfoArray) => {
      // method carefully refactored from the end of PieChart.prepareLabels
      var insertPos = -1;
      var labelInfo;
      var s_label = sliceLabel;

      // insertion "sort"
      for (var j = 0; j < labelInfoArray.length; j++) {
        labelInfo = labelInfoArray[j];
        if (labelInfo.getPosition() > pa) {
          insertPos = j;
          break;
        }
      }

      if (insertPos == -1) insertPos = labelInfoArray.length;

      labelInfo = new DvtChartPieLabelInfo();

      labelInfo.setPosition(pa);
      labelInfo.setAngle(ma);
      labelInfo.setSliceLabel(s_label);
      labelInfo.setSlice(slice);
      labelInfo.setWidth(tmDimPt.x);
      labelInfo.setHeight(tmDimPt.y);
      labelInfo.setX(labelPt.x);
      labelInfo.setY(labelPt.y);
      labelInfo.setInitialNumLines(s_label.getLineCount());

      labelInfoArray.splice(insertPos, 0, labelInfo);
    },
    /**
     *
     * Wraps and truncates the text in the pieLabel, and returns a pt describing the new dimensions
     * @param {DvtChartPie} pieChart
     * @param {DvtChartPieSlice} slice
     * @param {dvt.MultilineText} sliceLabel the text instance to wrap and truncate
     * @param {Number} maxWidth the maxWidth of a line
     * @param {Number} maxLines the maximum number of lines to wrap, after which the rest of the text is truncated
     * @return {object} a point describing the new dimensions
     * @private
     */
    _getTextDim: (pieChart, slice, sliceLabel, maxWidth, maxLines) => {
      // Truncate and wrap the text to fit in the available space
      sliceLabel.setMaxLines(maxLines);
      var minChars = !DvtChartPieLabelUtils._isTextLabel(pieChart, slice)
        ? sliceLabel.getTextString().length
        : null;
      if (dvt.TextUtils.fitText(sliceLabel, maxWidth, Infinity, pieChart, minChars)) {
        // Add the label to the DOM to get dimensions
        pieChart.addChild(sliceLabel);
        var dimensions = sliceLabel.getDimensions();
        pieChart.removeChild(sliceLabel);
        return { x: dimensions.w, y: dimensions.h };
      }
      // It doesn't fit. return dimensions of 0x0
      return { x: 0, y: 0 };
    },
    /**
     * Checks whether the label for the given slice is text or numeric. Always returns true if a dataLabel function is specified, because the dataLabel could be returning labels that are all strings or all numbers or or a mixture of both.
     * @param {DvtChartPie} pie
     * @param {DvtChartPieSlice} slice
     * @return {boolean} whether the label associated with the slice is text. Returns true if a   dataLabel function is specified.
     * @private
     */
    _isTextLabel: (pie, slice) => {
      var customLabel = slice.getCustomLabel();
      var hasDataLabelFunc = pie.getOptions()['dataLabel'] != null;
      return (
        pie.getOptions()['styleDefaults']['sliceLabelType'].indexOf('text') != -1 ||
        (customLabel != null && typeof customLabel != 'number') ||
        hasDataLabelFunc
      );
    },
    /**
     *  Returns the maximum label length
     *  @param {DvtChartPie} pie
     *  @param {number} labelX the x point of the label
     *  @param {boolean} isLeftSide Indicates if the label is on left side of the pie chart
     *  @return {number} the maximum label length
     */
    getMaxLabelWidth: (pie, labelX, isLeftSide) => {
      var frame = pie.__getFrame();
      return isLeftSide ? labelX - frame.x : frame.x + frame.w - labelX;
    },
    /**
     *  Returns the pie center option
     * @param {DvtChartPie} pieChart the pie chart
     *  @param {object} options The options object
     *  @return {object} pieCenter object
     */
    getPieCenterOptions: (pieChart, options) => {
      var pieCenter = dvt.JsonUtils.clone(
        options['pieCenter'],
        null,
        pieChart.chart.Defaults.getNoCloneObject().pieCenter
      );
      var deprecatedPieCenter = options['pieCenterLabel'];
      if (deprecatedPieCenter) {
        var style = deprecatedPieCenter['style'];
        var text = deprecatedPieCenter['text'];
        if (text) pieCenter['label'] = text;
        if (style) pieCenter['labelStyle'] = new dvt.CSSStyle(style);
      }
      return pieCenter;
    },
    /**
     *  Returns true if slice label should be skipped. Currently we do this when the slice label is small on a pie with a large number of slices.
     *  @param {DvtChartPie} pie
     *  @param {DvtPieSlice} slice
     *  @return {boolean} true if slice label should be skipped, false otherwise
     *  @private
     */
    _skipSliceLabel: (pie, slice) => {
      return slice.getAngleExtent() < 3 && DvtChartDataUtils.getSeriesCount(pie.chart) > 120;
    }
  };

  /*---------------------------------------------------------------------*/
  /*   DvtChartPieSlice                                                       */
  /*---------------------------------------------------------------------*/

  /*
   * Call chain:
   *
   * DvtChartPie creates each logical DvtChartPieSlice object.  The physical surface objects are
   * then created in DvtChartPie.render, by calling DvtChartPieSlice.preRender()
   *
   * In DvtChartPieSlice.preRender() we
   *
   * 1. setup the gradient used for this DvtChartPieSlice
   * 2. create the physical objects representing each surface
   *
   * The labels are then created and laid out by DvtSliceLabelLayout.layoutLabelsAndFeelers.
   *
   * After the label layout is complete, DvtChartPie then calls
   *
   * 1. render() to render the pie slice itself
   * 2. renderLabelAndFeeler() to render the pie label and feeler (if necessary)
   *
   */

  /**
   * Creates an instance of DvtChartPieSlice
   *
   * @param {DvtChartPie} pieChart The pie chart that owns the pie slice.
   * @param {number=} seriesIndex The series index of this slice. If not provided, the slice is an "Other" slice.
   * @class DvtChartPieSlice
   * @constructor
   * @implements {DvtLogicalObject}
   * @implements {DvtCategoricalObject}
   * @implements {DvtTooltipSource}
   * @implements {DvtDraggable}
   */
  class DvtChartPieSlice {
    /**
     * Object initializer
     * @param {DvtChartPie} pieChart The pie chart that owns the pie slice.
     * @param {number=} seriesIndex The series index of this slice. If not provided, the slice is an "Other" slice.
     * @protected
     */
    constructor(pieChart, seriesIndex) {
      this._pieChart = pieChart;
      this._chart = pieChart.chart;

      this._angleStart = 0;
      this._angleExtent = 0;

      this._topSurface = null; // an array of DvtShapes representing the top of the slice
      this._leftSurface = null; // an array of DvtShapes representing the left side of the slice
      // ("left" as seen from the tip of the slice)
      this._rightSurface = null; // an array of DvtShapes representing the right side of the slice
      // ("right" as seen from the tip of the slice)
      this._crustSurface = null; // an array of DvtShapes representing the crust of the slice

      this._explodeOffsetX = 0;
      this._explodeOffsetY = 0;

      this._sliceLabel = null;
      this._sliceLabelString = null;

      this._hasFeeler = false;
      this._feelerRad = null; // the section of the feeler closest to the pie
      this._feelerHoriz = null; // the section of the feeler closest to the label
      this._outsideFeelerStart = null; // a point class with x and y fields. This represents the point on the pie
      // from which the feeler originates in the unexploded state
      this._outsideFeelerMid = null; // a point class with x and y fields. This represents the point on the pie
      // from which the feeler bends
      this._outsideFeelerEnd = null; // a point class with x and y fields. This represents the point not on the pie
      // at which the feeler ends
      this._selected = false;
      this._selecting = false;

      this._centerX = this._pieChart.getCenter().x;
      this._centerY = this._pieChart.getCenter().y;

      this._radiusX = this._pieChart.getRadiusX();
      this._radiusY = this._pieChart.getRadiusY();

      this._depth = this._pieChart.getDepth();

      // Set rendering constants
      var options = this._chart.getOptions();

      if (seriesIndex != null) {
        // not "Other" slice
        var dataItem = DvtChartDataUtils.getDataItem(this._chart, seriesIndex, 0);
        this._value = DvtChartDataUtils.getVal(this._chart, seriesIndex, 0);
        this._explode = DvtChartPieUtils.getSliceExplode(this._chart, seriesIndex);
        this._fillColor = DvtChartStyleUtils.getColor(this._chart, seriesIndex, 0);
        this._fillPattern = DvtChartStyleUtils.getPattern(this._chart, seriesIndex, 0);
        this._strokeColor = DvtChartStyleUtils.getBorderColor(this._chart, seriesIndex);
        this._borderWidth = DvtChartStyleUtils.getBorderWidth(this._chart, seriesIndex);
        this._customLabel = dataItem ? dataItem['label'] : null;
        this._seriesLabel = DvtChartDataUtils.getSeries(this._chart, seriesIndex);
        this._drillable = DvtChartDataUtils.isDataItemDrillable(this._chart, seriesIndex, 0);
        this._id = DvtChartPieUtils.getSliceId(this._chart, seriesIndex);
        this._seriesIndex = seriesIndex;
        this._categories = DvtChartDataUtils.getCategories(this._chart, seriesIndex, 0);
      } else {
        // "Other" slice
        this._value = DvtChartPieUtils.getOtherVal(this._chart);
        this._explode = 0;
        this._fillColor = options['styleDefaults']['otherColor'];
        this._fillPattern = null;
        this._strokeColor = options['styleDefaults']['borderColor'];
        this._borderWidth = options['styleDefaults']['borderWidth'];
        this._customLabel = null;
        this._seriesLabel = options.translations.labelOther;
        this._drillable = DvtChartDataUtils.isMultiSeriesDrillEnabled(this._chart);
        this._id = DvtChartPieUtils.getOtherSliceId(this._chart);
        this._otherId = true;
      }
    }

    /**
     * Returns the owning DvtChartPie object.
     * @return {DvtChartPie}
     */
    getPieChart() {
      return this._pieChart;
    }

    /**
     * Render the pie slice only; rendering of label and feeler
     * occurs in DvtChartPieSlice.renderLabelAndFeelers
     * @param {boolean=} duringDisplayAnim Whether the render is during the display animation.
     */
    render(duringDisplayAnim) {
      var sortedSurfaces = DvtChartPieSlice._sortPieSurfaces(
        this._topSurface,
        this._leftSurface,
        this._rightSurface,
        this._crustSurface,
        this._angleStart,
        this._angleExtent
      );
      var len = sortedSurfaces.length;
      for (var i = 0; i < len; i++) {
        var shapeArray = sortedSurfaces[i];
        // shapeArray is an array of DvtShapes representing the given surface.
        // Iterate through this array and add each shape to the pieChart
        var shapeCount = shapeArray.length;
        for (var j = 0; j < shapeCount; j++) {
          var shapesContainer = this._pieChart.__getShapesContainer();
          shapesContainer.addChild(shapeArray[j]);
          if (shapeArray[j].render)
            // render is only defined on certain shape subclasses
            shapeArray[j].render();
        }
      }

      // Render label and feeler
      // assume that all layout and text truncation has already been done
      // so in theory, we just need to call addChild with the feeler and label
      if (this._sliceLabel) {
        this._pieChart.addChild(this._sliceLabel);

        // Associate the shapes with the slice for use during event handling
        DvtChartPieRenderUtils.associate(this, [this._sliceLabel]);

        if (duringDisplayAnim) {
          // Reuse the existing feeler instead of creating a new one for fade in animation
          this._pieChart.addChild(this._feelerRad);
          this._pieChart.addChild(this._feelerHoriz);
        } else this._renderOutsideFeeler();
      }

      // Perform initial explosion
      this._explodeSlice();

      // Apply the correct cursor if drilling or selection is enabled
      if (this._drillable || this._pieChart.chart.isSelectionSupported()) {
        var sliceDisplayables = this.getDisplayables();
        for (var i = 0; i < sliceDisplayables.length; i++) {
          sliceDisplayables[i].setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
        }
      }

      // WAI-ARIA
      var displayable = this.getTopDisplayable();

      if (displayable) {
        displayable.setAriaRole('img');
        this._updateAriaLabel();
      }
    }

    /**
     * Create a feeler from pt1 to pt2.
     * @param {dvt.Point} pt1
     * @param {dvt.Point} pt2
     * @return {dvt.Line} feeler
     * @private
     */
    _feelerFromPts(pt1, pt2) {
      var feeler = new dvt.Line(this._pieChart.getCtx(), pt1.x, pt1.y, pt2.x, pt2.y);
      var color = this._pieChart.getOptions()['styleDefaults']['pieFeelerColor'];
      var stroke = new dvt.Stroke(color);
      feeler.setStroke(stroke);
      this._pieChart.addChild(feeler);
      return feeler;
    }

    /**
     * Render a feeler outside the slice.
     * @private
     */
    _renderOutsideFeeler() {
      if (!this._hasFeeler) return;

      var feelerRad = this._feelerFromPts(this._outsideFeelerStart, this._outsideFeelerMid);
      var feelerHoriz = this._feelerFromPts(this._outsideFeelerMid, this._outsideFeelerEnd);

      // Store a reference to it so that we can remove
      this._feelerRad = feelerRad;
      this._feelerHoriz = feelerHoriz;
    }

    /**
     * Creates the gradients and physical shapes for the pie surfaces. Z-Ordering of the shapes
     * and layout and creation of the pie label is done elsewhere.
     */
    preRender() {
      var fillType = this._bFillerSlice ? 'color' : DvtChartStyleUtils.getSeriesEffect(this._chart);
      var color = this.getFillColor();
      var pattern = this.getFillPattern();

      // Create the fills
      var topFill;
      if (fillType == 'pattern' || pattern != null) {
        topFill = new dvt.PatternFill(pattern, color);
        fillType = 'pattern';
      } else if (fillType == 'gradient') {
        var grAngle = 270;
        var style = !this._pieChart.is3D() ? '2D' : '3D';

        var arColors = DvtChartPieRenderUtils.getGradientColors(dvt.ColorUtils.getRGB(color), style);
        var arAlphas = DvtChartPieRenderUtils.getGradientAlphas(
          dvt.ColorUtils.getAlpha(color),
          style
        );
        var arRatios = [0, 1.0];
        var arBounds = [
          Math.floor(this._centerX - this._radiusX),
          Math.floor(this._centerY - this._radiusY),
          Math.ceil(2 * this._radiusX),
          Math.ceil(2 * this._radiusY)
        ];

        topFill = new dvt.LinearGradientFill(grAngle, arColors, arAlphas, arRatios, arBounds);
      } else topFill = new dvt.SolidFill(color);

      // Create the Top Surface
      this._topSurface = DvtChartPieRenderUtils.createTopSurface(this, topFill);

      // 3D Effect Support
      if (this._depth > 0 || this._radiusX != this._radiusY) {
        var useGradientFill = fillType == 'gradient';
        var lateralFill = new dvt.SolidFill(dvt.ColorUtils.getDarker(color, 0.4));
        var sideFill = useGradientFill
          ? DvtChartPieRenderUtils.generateLateralGradientFill(this, 'SIDE')
          : lateralFill;
        var crustFill = useGradientFill
          ? DvtChartPieRenderUtils.generateLateralGradientFill(this, 'CRUST')
          : lateralFill;

        // Create the side surfaces for the slice, which will be sorted later
        this._leftSurface = DvtChartPieRenderUtils.createLateralSurface(
          this,
          DvtChartPieRenderUtils.SURFACE_LEFT,
          sideFill
        );
        this._rightSurface = DvtChartPieRenderUtils.createLateralSurface(
          this,
          DvtChartPieRenderUtils.SURFACE_RIGHT,
          sideFill
        );
        this._crustSurface = DvtChartPieRenderUtils.createLateralSurface(
          this,
          DvtChartPieRenderUtils.SURFACE_CRUST,
          crustFill
        );
      }

      // Clear slice label and feelers from previous render
      this.setSliceLabel(null);
      this.setNoOutsideFeeler();
    }

    // This logic is ported over from PieChart.sortSliversBySlice, and pushed
    // from the PieChart to the PieSlice
    /**
     * Sorts this DvtChartPieSlice's surfaces by z-order
     *
     * @param {Array} topSurface An array of DvtShapes representing the top of this DvtChartPieSlice
     * @param {Array} leftSurface An array of DvtShapes representing the left side of this DvtChartPieSlice (as seen from
                      the tip of the slice)
     * @param {Array} rightSurface An array of DvtShapes representing the right side of this DvtChartPieSlice (as seen from
                      the tip of the slice)
     * @param {Array} crustSurface An array of DvtShapes representing the crust of this DvtChartPieSlice
     * @param {number} angleStart The starting position of this pie slice
     * @param {number} angleExtent The angular size of this pie slice
     *
     * @return {Array} A sorted array of arrays (two-dimensional array) of dvt.Shape objects for this slice to render.
     * @private
     */
    static _sortPieSurfaces(
      topSurface,
      leftSurface,
      rightSurface,
      crustSurface,
      angleStart,
      angleExtent
    ) {
      var sortedSurfaces = [];

      if (leftSurface && rightSurface && crustSurface) {
        // ported from PieChart.sortSliversBySlice
        // NOTE that instead of relying on the order in which the surfaces were
        // originally created, we just get them from associative array by name
        // the last slice to render,
        // or if a slice starts at 270 degrees/6 o'clock (Fix for )
        if (angleStart <= 270 && angleStart + angleExtent > 270) {
          //we're in the bottom-most slice, so add surfaces in back-to-front z-order:
          //left edge, right edge, crust
          sortedSurfaces.push(leftSurface);
          sortedSurfaces.push(rightSurface);
          sortedSurfaces.push(crustSurface);
        }

        // right-side of the pie
        else if (angleStart > 270 || angleStart + angleExtent <= 90) {
          //we're in the right side of the pie, so add surfaces in back-to-front z-order:
          //left edge, crust, right edge
          sortedSurfaces.push(leftSurface);
          sortedSurfaces.push(crustSurface);
          sortedSurfaces.push(rightSurface);
        } else {
          //we're in the left side of the pie, so add surfaces in back-to-front z-order:
          //right edge, crust, left edge
          sortedSurfaces.push(rightSurface);
          sortedSurfaces.push(crustSurface);
          sortedSurfaces.push(leftSurface);
        }
      }

      // top is rendered last
      sortedSurfaces.push(topSurface);

      return sortedSurfaces;
    }

    /**
     * Returns true if (x-y1) and (x-y2) have different signs.
     * @param {number} x
     * @param {number} y1
     * @param {number} y2
     * @return {boolean}
     */
    static oppositeDir(x, y1, y2) {
      var positive1 = x - y1 > 0;
      var positive2 = x - y2 > 0;
      return positive1 != positive2;
    }

    /**
     * Explodes the DvtChartPieSlice and feeler line.
     * @private
     */
    _explodeSlice() {
      if (this._explode != 0) {
        var arc = this._angleExtent;
        var angle = this._angleStart;
        var fAngle = angle + arc / 2;
        var radian = (360 - fAngle) * dvt.Math.RADS_PER_DEGREE;
        var tilt = this._pieChart.is3D() ? DvtChartPieSlice.THREED_TILT : 1;

        var explodeOffset = this._explode * this._pieChart.__calcMaxExplodeDistance();
        this._explodeOffsetX = Math.cos(radian) * explodeOffset;
        this._explodeOffsetY = Math.sin(radian) * tilt * explodeOffset;

        // To work around , in the 2D pie case, we need to poke the
        // DOM element that contains the shadow filter that is applied to the pie slices.
        // However, due to , just poking the DOM also causes jitter in the
        // slice animation.  To get rid of the jitter, we round the amount of the translation we
        // apply to the pie slice and we also shorten the duration of the animation to visually smooth
        // out the result of the rounding.
        // 
        if (dvt.Agent.browser === 'safari' || dvt.Agent.engine === 'blink') {
          this._explodeOffsetX = Math.round(this._explodeOffsetX);
          this._explodeOffsetY = Math.round(this._explodeOffsetY);
        }
      } else {
        this._explodeOffsetX = 0;
        this._explodeOffsetY = 0;
      }

      // now update each surface
      if (this._topSurface) {
        var offsets =
          this._pieChart.is3D() && this._topSurface[0].getSelectionOffset
            ? this._topSurface[0].getSelectionOffset()
            : [];
        DvtChartPieSlice._translateShapes(
          this._topSurface,
          offsets[0] ? offsets[0] + this._explodeOffsetX : this._explodeOffsetX,
          offsets[1] ? offsets[1] + this._explodeOffsetY : this._explodeOffsetY
        );
      }

      if (this._rightSurface) {
        DvtChartPieSlice._translateShapes(
          this._rightSurface,
          this._explodeOffsetX,
          this._explodeOffsetY
        );
      }

      if (this._leftSurface) {
        DvtChartPieSlice._translateShapes(
          this._leftSurface,
          this._explodeOffsetX,
          this._explodeOffsetY
        );
      }

      if (this._crustSurface) {
        DvtChartPieSlice._translateShapes(
          this._crustSurface,
          this._explodeOffsetX,
          this._explodeOffsetY
        );
      }

      // update the feeler line
      if (this._hasFeeler) {
        // get current starting x and y, and then update the feeler line only
        var oldStartX = this._outsideFeelerStart.x;
        var oldStartY = this._outsideFeelerStart.y;

        var newStartX = oldStartX + this._explodeOffsetX;
        var newStartY = oldStartY + this._explodeOffsetY;

        this._feelerRad.setX1(newStartX);
        this._feelerRad.setY1(newStartY);

        var oldMidX = this._outsideFeelerMid.x;
        var oldMidY = this._outsideFeelerMid.y;

        //The midpoint of the feeler has to be updated if the new radial feeler is pointing towards an opposite direction;
        //otherwise, the feeler will go through the slice.
        //The easy solution is to set the x/y of the midPt to be the same as startPt.
        if (DvtChartPieSlice.oppositeDir(oldMidX, oldStartX, newStartX)) {
          this._feelerRad.setX2(newStartX);
          this._feelerHoriz.setX1(newStartX);
        } else {
          this._feelerRad.setX2(oldMidX);
          this._feelerHoriz.setX1(oldMidX);
        }

        if (DvtChartPieSlice.oppositeDir(oldMidY, oldStartY, newStartY)) {
          this._feelerRad.setY2(newStartY);
          this._feelerHoriz.setY1(newStartY);
        } else {
          this._feelerRad.setY2(oldMidY);
          this._feelerHoriz.setY1(oldMidY);
        }
      }

      //update the label position
      if (this._sliceLabel && !this._hasFeeler) {
        this._sliceLabel.setTranslate(this._explodeOffsetX, this._explodeOffsetY);
      }
    }

    /**
     * Translates each element in an array of shapes by the same delta x and delta y
     *
     * @param {Array} shapes An array of dvt.Shape objects to translate
     * @param {number} tx
     * @param {number} ty
     *
     * @private
     */
    static _translateShapes(shapes, tx, ty) {
      if (!shapes) return;

      var len = shapes.length;

      for (var i = 0; i < len; i++) {
        var shape = shapes[i];
        shape.setTranslate(tx, ty);
      }
    }

    /** Getters and setters **/

    /**
     * Returns the x radius of the slice.
     * @return {number}
     */
    getRadiusX() {
      return this._radiusX;
    }

    /**
     * Returns the y radius of the slice.
     * @return {number}
     */
    getRadiusY() {
      return this._radiusY;
    }

    /**
     * Returns the center of the pie. This is used to animate between pies with different center points.
     * @return {dvt.Point}
     */
    getCenter() {
      return new dvt.Point(this._centerX, this._centerY);
    }

    /**
     * Returns the depth of the pie. This is used to animate between pies with and without 3d effect.
     * @return {number}
     */
    getDepth() {
      return this._depth;
    }

    /**
     * @return {number} The size of this pie slice's angle
     */
    getAngleExtent() {
      return this._angleExtent;
    }

    /**
     * @param {number} extent The size of this pie slice's angle
     */
    setAngleExtent(extent) {
      this._angleExtent = extent;
    }

    /**
     * @return {number} The starting angle location of this pie slice
     */
    getAngleStart() {
      return this._angleStart;
    }

    /**
     * @param {number} start The starting angle location of this pie slice
     */
    setAngleStart(start) {
      this._angleStart = start;
    }

    /**
     * @return {number} The x-offset for this pie slice. Zero if the slice is not exploded.
     */
    __getExplodeOffsetX() {
      return this._explodeOffsetX;
    }

    /**
     * @return {number} The y-offset for this pie slice. Zero if the slice is not exploded.
     */
    __getExplodeOffsetY() {
      return this._explodeOffsetY;
    }

    /**
     * Set the points for a feeler outside the slice.
     *
     * @param {object} startPt The starting point of the feeler, located on the pie slice. Point has an x and y field
     * @param {object} midPt The mid point of the feeler, located between the slice and the label. Point has an x and y field
     * @param {object} endPt The ending point of the feeler, located on the pie label. Point has an x and y field
     */
    setOutsideFeelerPoints(startPt, midPt, endPt) {
      this._outsideFeelerStart = startPt;
      this._outsideFeelerMid = midPt;
      this._outsideFeelerEnd = endPt;
      this._hasFeeler = true;
    }

    /**
     * Set the slice without feeler.
     */
    setNoOutsideFeeler() {
      this._outsideFeelerStart = null;
      this._outsideFeelerMid = null;
      this._outsideFeelerEnd = null;
      this._hasFeeler = false;
    }

    /**
     * Returns an array containing the label and feeler objects of the slice.
     * @return {array}
     */
    getLabelAndFeeler() {
      var ar = [];
      if (this._sliceLabel) ar.push(this._sliceLabel);
      if (this._feelerRad) ar.push(this._feelerRad);
      if (this._feelerHoriz) ar.push(this._feelerHoriz);
      return ar;
    }

    /**
     * @return {dvt.OutputText|dvt.MultilineText} The label for this slice
     */
    getSliceLabel() {
      return this._sliceLabel;
    }

    /**
     * @param {dvt.OutputText|dvt.MultilineText} sliceLabel
     */
    setSliceLabel(sliceLabel) {
      this._sliceLabel = sliceLabel;
    }

    /**
     * @return {String} Untruncated slice label if slice label is truncated.
     */
    getSliceLabelString() {
      return this._sliceLabelString;
    }

    /**
     * @param {String} labelStr Untruncated slice label if slice label is truncated.
     */
    setSliceLabelString(labelStr) {
      this._sliceLabelString = labelStr;
    }

    /**
     * @return {Array} The top surface displayables of this Pie Slice
     */
    getTopSurface() {
      return this._topSurface;
    }

    /**
     * Returns the numeric data value associated with this slice
     * @return {number}
     */
    getVal() {
      return this._value;
    }

    /**
     * @return {String} The series id
     */
    getId() {
      return this._id;
    }

    /**
     * @return {Number} The series index
     */
    getSeriesIndex() {
      return this._seriesIndex;
    }

    /**
     * Returns true if the specified displayable can be selected or hovered.
     * @param {dvt.Displayable} shape
     * @return {boolean}
     * @private
     */
    static _shapeIsSelectable(shape) {
      return shape instanceof DvtChartSelectableWedge;
    }

    /**
     * Returns true if this slice contains the given coordinates.
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    contains(x, y) {
      var ir = this._pieChart.getInnerRadius();
      var c = this._pieChart.getCenter();
      var cos = (x - c.x) / this._radiusX;
      var sin = (y - c.y) / this._radiusY;

      // Compute the angle
      var angle = -Math.atan2(sin, cos) * (180 / Math.PI); // in degrees
      // First adjust angle to be greater than the start angle.
      while (angle < this._angleStart) angle += 360;
      // Then adjust to be within 360 degrees of it
      while (angle - this._angleStart >= 360) angle -= 360;

      var distance = Math.pow(cos, 2) + Math.pow(sin, 2);
      var containsRadius = Math.sqrt(distance) > ir / this._radiusX && distance <= 1;
      var containsAngle = angle <= this._angleStart + this._angleExtent;
      return containsRadius && containsAngle;
    }

    //---------------------------------------------------------------------//
    // Animation Support                                                   //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    GetAnimParams() {
      var r = dvt.ColorUtils.getRed(this._fillColor);
      var g = dvt.ColorUtils.getGreen(this._fillColor);
      var b = dvt.ColorUtils.getBlue(this._fillColor);
      var a = dvt.ColorUtils.getAlpha(this._fillColor);
      return [
        this._value,
        this._radiusX,
        this._radiusY,
        this._explode,
        this._centerX,
        this._centerY,
        this._depth,
        r,
        g,
        b,
        a
      ];
    }

    /**
     * @override
     */
    SetAnimParams(params) {
      this._value = params[0];
      this._radiusX = params[1];
      this._radiusY = params[2];
      this._explode = params[3];
      this._centerX = params[4];
      this._centerY = params[5];
      this._depth = params[6];

      // Update the color.  Round them since color parts must be ints
      var r = Math.round(params[7]);
      var g = Math.round(params[8]);
      var b = Math.round(params[9]);
      var a = Math.round(params[10]);
      this._fillColor = dvt.ColorUtils.makeRGBA(r, g, b, a);
    }

    /**
     * Returns the animation params of a deleted slice.
     * @return {Array} animation params.
     */
    getDeletedAnimParams() {
      var params = this.GetAnimParams();
      params[0] = 0; // value
      params[1] = this.getInnerRadius(); // radiusX
      params[2] = this.getInnerRadius(); // radiusY
      params[3] = 0; // explode
      return params;
    }

    /**
     * Creates the update animation for this object.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     * @param {DvtChartPieSlice} oldSlice The old pie state to animate from.
     */
    animateUpdate(handler, oldSlice) {
      var startState = oldSlice.GetAnimParams();
      var endState = this.GetAnimParams();

      if (!dvt.ArrayUtils.equals(startState, endState)) {
        // Create the animation
        var anim = new dvt.CustomAnimation(
          this._pieChart.getCtx(),
          this,
          this.getPieChart().getAnimDuration()
        );
        anim
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            this,
            this.GetAnimParams,
            this.SetAnimParams,
            endState
          );
        handler.add(anim, 0);

        // Initialize to the start state
        this.SetAnimParams(startState);
      }
    }

    /**
     * Creates the insert animation for this object.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     */
    animateInsert(handler) {
      // Create the animation
      var anim = new dvt.CustomAnimation(
        this._pieChart.getCtx(),
        this,
        this.getPieChart().getAnimDuration()
      );
      anim
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.GetAnimParams,
          this.SetAnimParams,
          this.GetAnimParams()
        );
      handler.add(anim, 0);

      // Initialize to the start state
      this.SetAnimParams(this.getDeletedAnimParams());
    }

    /**
     * Creates the delete animation for this object.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     * @param {DvtChartPie} container The new container where the pie slice should be moved for animation.
     */
    animateDelete(handler, container) {
      var newSlices = container.__getSlices();
      var oldSlices = this.getPieChart().__getSlices();

      // Add the deleted slice to the new pie in the right spot
      var oldIndex = oldSlices.indexOf(this);
      var prevIndex = oldIndex - 1;
      if (prevIndex >= 0) {
        var prevId = oldSlices[prevIndex].getId();
        // Find the location of the previous slice
        for (var i = 0; i < newSlices.length; i++) {
          if (newSlices[i].getId().equals(prevId)) {
            newSlices.splice(i + 1, 0, this);
            break;
          }
        }
      } else newSlices.splice(0, 0, this);

      this._pieChart = container; // reparent this slice to the new pie

      // Create the animation to delete the slice
      var anim = new dvt.CustomAnimation(
        container.getCtx(),
        this,
        this.getPieChart().getAnimDuration()
      );
      anim
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.GetAnimParams,
          this.SetAnimParams,
          this.getDeletedAnimParams()
        );

      // Set the onEnd listener so that the slice can be deleted
      anim.setOnEnd(this._removeDeletedSlice, this);

      // Finally add the animation
      handler.add(anim, 0);
    }

    /**
     * Removes a deleted slice from the owning pie chart.  A re-render must be performed for the
     * results to be visible.
     * @private
     */
    _removeDeletedSlice() {
      var slices = this.getPieChart().__getSlices();
      var index = slices.indexOf(this);

      if (index >= 0) slices.splice(index, 1);
    }

    //---------------------------------------------------------------------//
    // DvtLogicalObject impl                                               //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getDisplayables() {
      var ret = new Array();

      if (this._topSurface) ret = ret.concat(this._topSurface);

      if (this._leftSurface) ret = ret.concat(this._leftSurface);

      if (this._rightSurface) ret = ret.concat(this._rightSurface);

      if (this._crustSurface) ret = ret.concat(this._crustSurface);

      if (this._sliceLabel) ret.push(this._sliceLabel);

      if (this._feelerRad) ret.push(this._feelerRad);

      if (this._feelerHoriz) ret.push(this._feelerHoriz);

      return ret;
    }

    /**
     * @override
     */
    getAriaLabel() {
      var shortDesc;
      var translations = this._pieChart.getOptions().translations;
      if (this._seriesIndex == null)
        // other slice
        shortDesc = DvtChartTooltipUtils.getOtherSliceDatatip(this._chart, this._value, false);
      else
        shortDesc = DvtChartTooltipUtils.getDatatip(this._chart, this._seriesIndex, 0, null, false);

      // Include percentage in the shortDesc
      var percentageLabel = translations.labelPercentage;
      var percentage = DvtChartPieLabelUtils.generateSlicePercentageString(this);
      shortDesc +=
        '; ' + dvt.ResourceUtils.format(translations.labelAndValue, [percentageLabel, percentage]);

      var states = [];
      if (this.isSelectable())
        states.push(translations[this.isSelected() ? 'stateSelected' : 'stateUnselected']);

      if (DvtChartDataUtils.isDataItemDrillable(this._chart, this._seriesIndex, this._groupIndex))
        states.push(translations.stateDrillable);

      return dvt.Displayable.generateAriaLabel(shortDesc, states);
    }

    /**
     * Updates the aria-label as needed. On desktop, we can defer the aria creation, and the aria-label will be updated
     * when the activeElement is set.
     * @private
     */
    _updateAriaLabel() {
      var displayable = this.getTopDisplayable();
      if (displayable && !dvt.Agent.deferAriaCreation())
        displayable.setAriaProperty('label', this.getAriaLabel());
    }

    /**
     * Returns the displayable of the top surface.
     * @return {dvt.Shape}
     */
    getTopDisplayable() {
      if (this._topSurface && this._topSurface.length > 0) return this._topSurface[0];
      return null;
    }

    /**
     * @override
     */
    isSelectable() {
      return this._chart.isSelectionSupported();
    }

    /**
     * @override
     */
    isSelected() {
      return this._selected;
    }

    /**
     * @override
     */
    setSelected(bSelected, isInitial) {
      this._selected = bSelected;
      if (!this.getTopSurface()) {
        // Skip slices not rendered for performance optimization
        return;
      } else if (this._selected) {
        this._pieChart.bringToFrontOfSelection(this);
      } else if (!this._selecting) {
        this._pieChart.pushToBackOfSelection(this);
      }

      // Selection effect: Highlight
      if (DvtChartStyleUtils.isSelectionHighlighted(this._chart)) {
        var shapeArr = this.getDisplayables();
        for (var i = 0; i < shapeArr.length; i++) {
          if (DvtChartPieSlice._shapeIsSelectable(shapeArr[i])) {
            shapeArr[i].setSelected(bSelected);
          }
        }
      }

      // Selection effect: Explode
      if (DvtChartStyleUtils.isSelectionExploded(this._chart)) {
        var explode = bSelected ? 1 : 0;
        if (!isInitial && DvtChartStyleUtils.getAnimOnDataChange(this._chart) != 'none') {
          // animate the explosion
          var anim = new dvt.CustomAnimation(
            this._pieChart.getCtx(),
            this,
            this._pieChart.getAnimDuration() / 2
          );
          anim
            .getAnimator()
            .addProp(dvt.Animator.TYPE_NUMBER, this, this.getExplode, this.setExplode, explode);
          anim.play();
        } else this.setExplode(explode);
      }

      this._updateAriaLabel();
    }

    /**
     * @override
     */
    showHoverEffect() {
      this._selecting = true;
      this._pieChart.bringToFrontOfSelection(this);
      var shapeArr = this.getDisplayables();
      for (var i = 0; i < shapeArr.length; i++) {
        if (DvtChartPieSlice._shapeIsSelectable(shapeArr[i])) {
          shapeArr[i].showHoverEffect();
        }
      }
    }

    /**
     * @override
     */
    hideHoverEffect() {
      this._selecting = false;
      if (!this._selected) {
        this._pieChart.pushToBackOfSelection(this);
      }
      var shapeArr = this.getDisplayables();
      for (var i = 0; i < shapeArr.length; i++) {
        if (DvtChartPieSlice._shapeIsSelectable(shapeArr[i])) {
          shapeArr[i].hideHoverEffect();
        }
      }
    }

    //---------------------------------------------------------------------//
    // Tooltip Support: DvtTooltipSource impl                              //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getDatatip(target, x, y) {
      if (target == this._sliceLabel) {
        if (this._sliceLabel && this._sliceLabel.isTruncated()) return this.getSliceLabelString();
      }
      return this.getTooltip();
    }

    /**
     * @override
     */
    getDatatipColor() {
      return this.getFillColor();
    }

    //---------------------------------------------------------------------//
    // Rollover and Hide/Show Support: DvtCategoricalObject impl           //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getCategories() {
      if (this._categories && this._categories.length > 0) return this._categories;
      return [this.getId().series];
    }

    //---------------------------------------------------------------------//
    // Keyboard Support: DvtKeyboardNavigables impl                        //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    getNextNavigable(event) {
      var keyCode = event.keyCode;
      if (event.type == dvt.MouseEvent.CLICK) {
        return this;
      } else if (keyCode == dvt.KeyboardEvent.SPACE && event.ctrlKey) {
        // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
        // care of the selection
        return this;
      }

      var rtl = dvt.Agent.isRightToLeft(this._chart.getCtx());
      var slices = this._pieChart.__getSlices();
      var idx = slices.indexOf(this);
      var next = null;

      if (
        keyCode == dvt.KeyboardEvent.RIGHT_ARROW ||
        (keyCode == dvt.KeyboardEvent.DOWN_ARROW && !rtl) ||
        (keyCode == dvt.KeyboardEvent.UP_ARROW && rtl)
      ) {
        if (idx < slices.length - 1) next = slices[idx + 1];
        else next = slices[0];
      } else if (
        keyCode == dvt.KeyboardEvent.LEFT_ARROW ||
        (keyCode == dvt.KeyboardEvent.DOWN_ARROW && rtl) ||
        (keyCode == dvt.KeyboardEvent.UP_ARROW && !rtl)
      ) {
        if (idx == 0) next = slices[slices.length - 1];
        else next = slices[idx - 1];
      }
      return next;
    }

    /**
     * @override
     */
    getKeyboardBoundingBox(targetCoordinateSpace) {
      var displayables = this.getDisplayables();
      if (displayables[0]) return displayables[0].getDimensions(targetCoordinateSpace);
      else return new dvt.Rectangle(0, 0, 0, 0);
    }

    /**
     * @override
     */
    getTargetElem() {
      var displayables = this.getDisplayables();
      if (displayables[0]) return displayables[0].getElem();
      return null;
    }

    /**
     * @override
     */
    showKeyboardFocusEffect() {
      this._isShowingKeyboardFocusEffect = true;
      this.showHoverEffect();
    }

    /**
     * @override
     */
    hideKeyboardFocusEffect() {
      this._isShowingKeyboardFocusEffect = false;
      this.hideHoverEffect();
    }

    /**
     * @override
     */
    isShowingKeyboardFocusEffect() {
      return this._isShowingKeyboardFocusEffect;
    }

    //---------------------------------------------------------------------//
    // DnD Support: DvtDraggable impl                                      //
    //---------------------------------------------------------------------//

    /**
     * @override
     */
    isDragAvailable() {
      return true;
    }

    /**
     * @override
     */
    getDragTransferable() {
      return [this.getId()];
    }

    /**
     * @override
     */
    getDragFeedback() {
      // If more than one object is selected, return the displayables of all selected objects
      if (
        this._chart.isSelectionSupported() &&
        this._chart.getSelectionHandler().getSelectedCount() > 1
      ) {
        var selection = this._chart.getSelectionHandler().getSelection();
        var displayables = [];
        for (var i = 0; i < selection.length; i++) {
          displayables = displayables.concat(selection[i].getDisplayables());
        }
        return displayables;
      }

      // Otherwise, return its own displayables
      return this.getDisplayables();
    }

    /**
     * Returns the current explode value for this pie slice
     * @return {number}
     */
    getExplode() {
      return this._explode;
    }

    /**
     * Sets the current explode value for this pie slice
     * @param {number} explode
     */
    setExplode(explode) {
      this._explode = explode;
      this._explodeSlice();
    }

    /**
     * Returns the user-defined label for this pie slice.
     * @return {string}
     */
    getCustomLabel() {
      return this._customLabel;
    }

    /**
     * Returns the default series label for this pie slice.
     * @return {string}
     */
    getSeriesLabel() {
      return this._seriesLabel;
    }

    /**
     * Returns the color of this pie slice, represented as a String
     * @return {String}
     */
    getFillColor() {
      return this._fillColor;
    }

    /**
     * Returns the name of the fill pattern for this pie slice
     * @return {string}
     */
    getFillPattern() {
      return this._fillPattern;
    }

    /**
     * Returns the color of this pie slice border
     * @return {String}
     */
    getStrokeColor() {
      return this._strokeColor;
    }

    /**
     * Returns the color of this pie slice border
     * @return {String}
     */
    getBorderWidth() {
      return this._borderWidth;
    }

    /**
     * Returns the slice gaps
     * @return {Number}
     */
    getSliceGaps() {
      // Slice gap is only supported if the pie is not tilted (depth = 0)
      if (this._depth == 0) return 3 * DvtChartStyleUtils.getDataItemGaps(this._chart);
      else return 0;
    }

    /**
     * Returns the inner radius
     * @return {Number}
     */
    getInnerRadius() {
      return this._pieChart.getInnerRadius();
    }

    /**
     * Returns the tooltip string associated with this slice
     * @return {String}
     */
    getTooltip() {
      if (this._seriesIndex == null)
        // other slice
        return DvtChartTooltipUtils.getOtherSliceDatatip(this._chart, this._value, true);

      return DvtChartTooltipUtils.getDatatip(this._chart, this._seriesIndex, 0, null, true);
    }

    /**
     * Returns whether the pie slice is drillable.
     * @return {boolean}
     */
    isDrillable() {
      return this._drillable;
    }

    /**
     * Creates a filler slice (for fan effect in display animation).
     * @param {DvtChartPie} pieChart
     * @param {number} value The value of the filler slice.
     * @return {DvtChartPieSlice} filler slice.
     */
    static createFillerSlice(pieChart, value) {
      var slice = new DvtChartPieSlice(pieChart);
      slice._value = value;
      slice._bFillerSlice = true;
      slice._centerX = pieChart.getCenter().x;
      slice._centerY = pieChart.getCenter().y;
      slice._fillColor = 'rgba(255,255,255,0)';
      slice._strokeColor = 'rgba(255,255,255,0)';
      slice._id = new DvtChartDataItem(null, null, null, null);
      return slice;
    }

    /**
     * Returns the seriesIndex of the slice
     * @return {Number}
     */
    getSeriesIndex() {
      return this._seriesIndex;
    }
  }
  /** @const */
  DvtChartPieSlice.THREED_TILT = 0.59;

  /**
   *  Provides automation services for a DVT component.
   *  @class DvtChartAutomation
   *  @param {Chart} dvtComponent
   *  @implements {dvt.Automation}
   *  @constructor
   */
  class DvtChartAutomation extends dvt.Automation {
    constructor(dvtComponent) {
      super(dvtComponent);
      this._options = this._comp.getOptions();
      this._legend = this._comp.legend;
      this._xAxis = this._comp.xAxis;
      this._yAxis = this._comp.yAxis;
      this._y2Axis = this._comp.y2Axis;

      this._legendAutomation = this._legend ? this._legend.getAutomation() : null;
      this._xAxisAutomation = this._xAxis ? this._xAxis.getAutomation() : null;
      this._yAxisAutomation = this._yAxis ? this._yAxis.getAutomation() : null;
      this._y2AxisAutomation = this._y2Axis ? this._y2Axis.getAutomation() : null;
    }
    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>dataItem[seriesIndex][itemIndex]</li>
     * <li>series[seriesIndex] / legend:section[sectionIndex]:item[itemIndex]</li>
     * <li>group[groupIndex0]...[groupIndexN]</li>
     * <li>axis["axisType"]:title</li>
     * <li>axis["axisType"]:referenceObject[index]</li>
     * </ul>
     * @override
     */
    GetSubIdForDomElement(displayable) {
      var axisSubId = null;
      if (displayable.isDescendantOf(this._xAxis)) {
        axisSubId = this._xAxisAutomation.GetSubIdForDomElement(displayable);
        return axisSubId ? this._convertAxisSubIdToChartSubId(axisSubId, 'xAxis') : null;
      } else if (displayable.isDescendantOf(this._yAxis)) {
        axisSubId = this._yAxisAutomation.GetSubIdForDomElement(displayable);
        return axisSubId ? this._convertAxisSubIdToChartSubId(axisSubId, 'yAxis') : null;
      } else if (displayable.isDescendantOf(this._y2Axis)) {
        axisSubId = this._y2AxisAutomation.GetSubIdForDomElement(displayable);
        return axisSubId ? this._convertAxisSubIdToChartSubId(axisSubId, 'y2Axis') : null;
      } else if (displayable.isDescendantOf(this._legend)) {
        var legendSubId = this._legendAutomation.GetSubIdForDomElement(displayable);
        return legendSubId ? this._convertLegendSubIdToChartSubId(legendSubId) : null;
      } else {
        var logicalObj = this._comp.getEventManager().GetLogicalObject(displayable);
        if (!logicalObj) return null;

        if (logicalObj instanceof dvt.SimpleObjPeer) {
          var type = logicalObj.getParams()['type'];
          if (type == 'pieCenterLabel') return 'pieCenterLabel';
          else if (type == 'plotArea') return 'plotArea';
        }

        if (logicalObj instanceof DvtChartPieSlice)
          // pie chart data items do not use ChartObjPeer and return only dataItem[seriesIndex]
          return 'dataItem[' + logicalObj.getSeriesIndex() + ']';

        if (logicalObj instanceof DvtChartObjPeer) {
          // Chart data items
          var seriesIndex = logicalObj.getSeriesIndex();
          var itemIndex = logicalObj.getGroupIndex(); // corresponds to data items position in its series array

          if (
            seriesIndex != null &&
            itemIndex >= 0 &&
            (this._options['type'] != 'funnel' || this._options['type'] != 'pyramid')
          )
            return 'dataItem[' + seriesIndex + '][' + itemIndex + ']';
          else if (
            seriesIndex != null &&
            itemIndex == DvtChartFunnelRenderer._GROUP_IDX &&
            (this._options['type'] == 'funnel' || this._options['type'] == 'pyramid')
          )
            return 'dataItem[' + seriesIndex + ']';
          // funnel or pyramid chart only returns dataItem[seriesIndex]
          else if (seriesIndex != null && (itemIndex == null || itemIndex < 0))
            // displayable represents a seriesItem e.g. line, area
            return 'series[' + seriesIndex + ']';
        } else if (logicalObj instanceof DvtChartRefObjPeer) {
          // reference objects
          var axisType = logicalObj.getAxisType();
          var refObjIndex = logicalObj.getIndex();
          return axisType && refObjIndex >= 0
            ? axisType + ':referenceObject[' + refObjIndex + ']'
            : null;
        }
      }
      return null;
    }

    /**
     * Takes the subId for a legend item and converts it to a valid subId for chart legends
     * @param {String} subId for legend
     * @return {String} series[seriesIndex] / legend:section[sectionIndex]:item[itemIndex]
     * @private
     */
    _convertLegendSubIdToChartSubId(subId) {
      // Get the legend item that corresponds to the legend subId
      var legendOptions = this._legend.getOptions();
      var legendItem = this._legendAutomation.getLegendItem(legendOptions, subId);
      if (legendItem) {
        // Get index of series item that has same name as legend items's text
        for (var s = 0; s < this._options['series'].length; s++) {
          var series = this._options['series'][s];
          if (series['name'] == legendItem['text']) return 'series[' + s + ']';
        }
        // legend item is not associated with a series
        return 'legend:' + subId;
      }
      return null;
    }

    /**
     * Takes the subId for an axis item and converts it to a valid subId for chart axes
     * @param {String} subId for returned by the axis
     * @param {String=} axisType The axisType
     * @return {String} group[groupIndex0]...[groupIndexN] or axis["axisType"]:title
     * @private
     */
    _convertAxisSubIdToChartSubId(subId, axisType) {
      if (subId == 'title' && axisType) return axisType + ':' + subId;
      else {
        // Take item[groupIndex0]...[groupIndexN] string and return group[groupIndex0]...[groupIndexN]
        var indexList = subId.substring(subId.indexOf('['));
        if (indexList) return 'group' + indexList;
      }

      return null;
    }

    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>dataItem[seriesIndex][itemIndex]</li>
     * <li>series[seriesIndex] / legend:section[sectionIndex]:item[itemIndex]</li>
     * <li>group[groupIndex0]...[groupIndexN]</li>
     * <li>axis["axisType"]:title</li>
     * <li>axis["axisType"]:referenceObject[index]</li>
     * </ul>
     * @override
     */
    getDomElementForSubId(subId) {
      // First check for subIds that don't have to be parsed
      if (subId == dvt.Automation.TOOLTIP_SUBID)
        // TOOLTIP
        return this.GetTooltipElement(
          this._comp,
          DvtChartTooltipUtils.isDataCursorEnabled(this._comp) ? DvtChartDataCursor.TOOLTIP_ID : null
        );
      else if (subId == 'pieCenterLabel')
        // PIE CENTER LABEL
        return this._comp.pieChart.getCenterLabel().getElem();
      else if (subId == 'plotArea')
        // PLOT AREA
        return this._comp.getPlotArea().getElem();

      // CHART ELEMENTS
      var openParen1 = subId.indexOf('[');
      var closeParen1 = subId.indexOf(']');
      var openParen2, closeParen2, logicalObj;
      var colon = subId.indexOf(':');
      if ((openParen1 > 0 && closeParen1 > 0) || colon > 0) {
        var objType = colon < 0 ? subId.substring(0, openParen1) : subId.substring(0, colon);
        // GROUP AXIS LABELS
        if (objType == 'group') {
          return this._xAxisAutomation.getDomElementForSubId(subId);
        }
        // LEGEND ITEMS
        if (objType == 'series') {
          subId = this._convertToLegendSubId(subId);
          return this._legendAutomation.getDomElementForSubId(subId);
        } else if (subId.substring(0, colon) == 'legend') {
          subId = subId.substring(colon + 1);
          return this._legendAutomation.getDomElementForSubId(subId);
        }
        var seriesIndex = subId.substring(openParen1 + 1, closeParen1);
        // AXIS TITLE & REFERENCE OBJECTS
        if (objType == 'xAxis' || objType == 'yAxis' || objType == 'y2Axis') {
          var axisObjectType = subId.substring(colon + 1);
          if (axisObjectType == 'title') {
            // subId for axis title
            if (objType == 'xAxis')
              return this._xAxisAutomation.getDomElementForSubId(axisObjectType);
            else if (objType == 'yAxis')
              return this._yAxisAutomation.getDomElementForSubId(axisObjectType);
            else if (objType == 'y2Axis')
              return this._y2AxisAutomation.getDomElementForSubId(axisObjectType);
          } else {
            // subId for axis reference objects
            openParen2 = axisObjectType.indexOf('[');
            closeParen2 = axisObjectType.indexOf(']');
            if (axisObjectType.substring(0, openParen2) == 'referenceObject') {
              var index = axisObjectType.substring(openParen2 + 1, closeParen2);
              logicalObj = this._getRefObjPeer(index);
              if (logicalObj) return logicalObj.getDisplayables()[0].getElem();
            }
          }
        }

        // CHART DATA ITEMS
        if (this._options['type'] == 'pie') {
          var pieSlice = this._comp.pieChart.getSliceDisplayable(seriesIndex);
          if (pieSlice) return pieSlice.getElem();
        }
        // If funnel/pyramid chart set the default itemIndex, else parse it from the given subId
        var itemIndex;
        if (this._options['type'] == 'funnel') {
          itemIndex = DvtChartFunnelRenderer._GROUP_IDX;
        } else if (this._options['type'] == 'pyramid') {
          itemIndex = DvtChartPyramidRenderer._GROUP_IDX;
        } else {
          subId = subId.substring(closeParen1 + 1);
          openParen2 = subId.indexOf('[');
          closeParen2 = subId.indexOf(']');
          if (openParen2 >= 0 && closeParen2 >= 0) {
            itemIndex = subId.substring(openParen2 + 1, closeParen2);
          }
        }
        // Get the logical object and return the dom element of its associated displayable
        logicalObj = this._getChartObjPeer(seriesIndex, itemIndex);
        if (logicalObj) return logicalObj.getDisplayables()[0].getElem();
      }
      return null;
    }

    /**
     * Returns the DvtChartObjPeer for the given seriesIndex and itemIndex
     * @param {String} seriesIndex The seriesIndex for dataItem types
     * @param {String} itemIndex The itemIndex for dataItem types
     * @return {DvtChartObjPeer} The DvtChartObjPeer matching the parameters or null if none exists
     * @private
     */
    _getChartObjPeer(seriesIndex, itemIndex) {
      var peers = this._comp.getChartObjPeers();
      for (var i = 0; i < peers.length; i++) {
        var series = peers[i].getSeriesIndex();
        var item = peers[i].getGroupIndex(); // correspinds to the data item's position in its series array
        if (series == seriesIndex && item == itemIndex) return peers[i];
      }
      return null;
    }

    /**
     * Returns the DvtChartObjPeer for the given series and groupid
     * @param {String} seriesId The seriesId for dataItem types
     * @param {Array} groupId The groupIds for dataItem types
     * @param {number} itemIndex The index for dataItem corresponding to index in boxplot sub items.
     * @return {DvtChartObjPeer} The DvtChartObjPeer matching the parameters or null if none exists
     * @private
     */

    _getChartObjPeerFromId(seriesId, groupId, itemIndex) {
      var peers = this._comp.getChartObjPeers();
      for (var i = 0; i < peers.length; i++) {
        var series = peers[i].getSeries();
        var group = peers[i].getGroup();
        if (
          series === seriesId &&
          ((typeof group === 'string' && groupId.length === 1 && groupId[0] === group) ||
            (Array.isArray(group) && dvt.ArrayUtils.equals(group, groupId)))
        ) {
          if (itemIndex == null || itemIndex === peers[i]._itemIndex) {
            return peers[i];
          }
        }
      }
      return null;
    }

    /**
     * Returns the DvtChartRefObjPeer for the given index
     * @param {String} index The index of the object in the referenceObjects array
     * @return {DvtChartObjPeer} The DvtChartRefObjPeer matching the index or null if none exists
     * @private
     */
    _getRefObjPeer(index) {
      var peers = this._comp.getRefObjPeers();
      for (var i = 0; i < peers.length; i++) {
        if (index == peers[i].getIndex()) return peers[i];
      }
      return null;
    }

    /**
     * Takes the subId for a chart series and converts it to a valid subId for legend item
     * @param {String} subId series[seriesIndex]
     * @return {String} section[sectionIndex0]:item[itemIndex]
     * @private
     */
    _convertToLegendSubId(subId) {
      var openParen = subId.indexOf('[');
      var closeParen = subId.indexOf(']');
      var seriesIndex = subId.substring(openParen + 1, closeParen);

      var legendOptions = this._legend.getOptions();
      var series = this._options['series'][seriesIndex];

      var indices = this._legendAutomation.getIndicesFromSeries(series, legendOptions);
      return 'section' + indices;
    }

    /**
     * Returns an object containing data for a chart data item. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>borderColor</li>
     * <li>color</li>
     * <li>label</li>
     * <li>targetValue</li>
     * <li>tooltip</li>
     * <li>value</li>
     * <li>open</li>
     * <li>close</li>
     * <li>high</li>
     * <li>low</li>
     * <li>volume</li>
     * <li>x</li>
     * <li>y</li>
     * <li>z</li>
     * <li>group</li>
     * <li>series</li>
     * <li>selected</li>
     * </ul>
     * @param {String} seriesIndex The seriesIndex for dataItem and series types, the itemIndex for group types
     * @param {String} itemIndex The itemIndex for dataItem types
     * @return {Object} An object containing data for the dataItem
     */
    getDataItem(seriesIndex, itemIndex) {
      if (
        this._options['type'] == 'pie' ||
        this._options['type'] == 'funnel' ||
        this._options['type'] == 'pyramid'
      )
        itemIndex = 0; //Not sure if neccessary but getDataItem will be null if itemIndex is null

      var dataItem = DvtChartDataUtils.getDataItem(this._comp, seriesIndex, itemIndex);

      if (dataItem) {
        return {
          borderColor: DvtChartStyleUtils.getBorderColor(this._comp, seriesIndex, itemIndex),
          color: DvtChartStyleUtils.getColor(this._comp, seriesIndex, itemIndex),
          label: DvtChartStyleUtils.getDataLabel(this._comp, seriesIndex, itemIndex),
          targetValue: DvtChartDataUtils.getTargetVal(this._comp, seriesIndex, itemIndex),
          tooltip: DvtChartTooltipUtils.getDatatip(this._comp, seriesIndex, itemIndex, null, false),
          value: DvtChartDataUtils.getVal(this._comp, seriesIndex, itemIndex),
          open: dataItem['open'],
          close: dataItem['close'],
          high: DvtChartDataUtils.getHighVal(this._comp, seriesIndex, itemIndex),
          low: DvtChartDataUtils.getLowVal(this._comp, seriesIndex, itemIndex),
          volume: dataItem['volume'],
          x: DvtChartDataUtils.getXVal(this._comp, seriesIndex, itemIndex),
          y: dataItem['y'],
          z: dataItem['z'],
          min: dataItem['min'],
          max: dataItem['max'],
          group: DvtChartDataUtils.getGroup(this._comp, itemIndex),
          series: DvtChartDataUtils.getSeries(this._comp, seriesIndex),
          selected: DvtChartDataUtils.isDataSelected(this._comp, seriesIndex, itemIndex)
        };
      }
      return null;
    }

    /**
     * Returns the group corresponding to the given index. Used for verification.
     * @param {String} itemIndex The index of the desired group
     * @return {String} The group corresponding to the given index
     */
    getGroup(itemIndex) {
      return DvtChartDataUtils.getGroup(this._comp, itemIndex);
    }

    /**
     * Returns the name of the series corresponding to the given index. Used for verification.
     * @param {String} seriesIndex The index of the desired series
     * @return {String} the name of the series corresponding to the given index
     */
    getSeries(seriesIndex) {
      return this._options['series'][seriesIndex]['name'];
    }

    /**
     * Returns the number of groups in the chart data. Used for verification.
     * @return {Number} The number of groups
     */
    getGroupCount() {
      return DvtChartDataUtils.getGroupCount(this._comp);
    }

    /**
     * Returns the number of series in the chart data. Used for verification.
     * @return {Number} The number of series
     */
    getSeriesCount() {
      return this._options['series'].length;
    }

    /**
     * Returns the chart title. Used for verification.
     * @return {String} The chart title
     */
    getTitle() {
      return this._options['title']['text'];
    }

    /**
     * Returns an object that represents the legend data. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>bounds</li>
     * <li>title</li>
     * </ul>
     * @return {Object} An object that represents the legend data
     */
    getLegend() {
      var legendSpace = this._legend.__getBounds();
      var point = this._legend.localToStage(new dvt.Point(legendSpace.x, legendSpace.y));
      var legendBounds = {
        x: point.x,
        y: point.y,
        width: legendSpace.w,
        height: legendSpace.h
      };

      return {
        bounds: legendBounds,
        title: this._legend.getOptions()['title']
      };
    }

    /**
     * Returns an object that represents the plot area data. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>bounds</li>
     * </ul>
     * @return {Object} An object that represents the plot area data
     */
    getPlotArea() {
      var plotAreaSpace = this._comp.__getPlotAreaSpace();

      var plotAreaBounds = {
        x: plotAreaSpace.x,
        y: plotAreaSpace.y,
        width: plotAreaSpace.w,
        height: plotAreaSpace.h
      };

      return { bounds: plotAreaBounds };
    }

    /**
     * Returns an object that represents the xAxis data. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>bounds</li>
     * <li>title</li>
     * </ul>
     * @return {Object} An object that represents the xAxis data
     */
    getXAxis() {
      return this._getAxis('x');
    }

    /**
     * Returns an object that represents the yAxis data. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>bounds</li>
     * <li>title</li>
     * </ul>
     * @return {Object} An object that represents the yAxis data
     */
    getYAxis() {
      return this._getAxis('y');
    }

    /**
     * Returns an object that represents the y2Axis data. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>bounds</li>
     * <li>title</li>
     * </ul>
     * @return {Object} An object that represents the y2Axis data
     */
    getY2Axis() {
      return this._getAxis('y2');
    }

    /**
     * Returns an object that represents the axis data.
     * @param {string} type The axis type: x, y, or y2
     * @return {object} An object that represents the axis data
     * @private
     */
    _getAxis(type) {
      var axis = type == 'x' ? this._xAxis : type == 'y' ? this._yAxis : this._y2Axis;
      if (axis) {
        var axisSpace = axis.__getBounds();
        var stageCoord = axis.localToStage(new dvt.Point(axisSpace.x, axisSpace.y));
        var axisBounds = {
          x: stageCoord.x,
          y: stageCoord.y,
          width: axisSpace.w,
          height: axisSpace.h
        };

        var chart = this._comp;
        var getPreferredSize = (width, height) => {
          var axisOptions = axis.getOptions();
          var position = axisOptions['position'];
          var tickLabelGap = DvtChartAxisUtils.getTickLabelGapSize(chart, type);
          var outerGap =
            DvtChartAxisUtils.isStandaloneXAxis(chart) ||
            DvtChartAxisUtils.isStandaloneYAxis(chart) ||
            DvtChartAxisUtils.isStandaloneY2Axis(chart)
              ? 2
              : 0;

          // the preferred size computed by the axis excludes tick label gap, so we have to subtract the gap
          // before passing to the axis, and add it again later
          var prefSize;
          if (position == 'top' || position == 'bottom') {
            prefSize = axis.getPreferredSize(axisOptions, width, height - tickLabelGap - outerGap);
            prefSize.h = Math.ceil(prefSize.h + tickLabelGap + outerGap);
          } else {
            prefSize = axis.getPreferredSize(axisOptions, width - tickLabelGap - outerGap, height);
            prefSize.w = Math.ceil(prefSize.w + tickLabelGap + outerGap);
          }
          return { width: prefSize.w, height: prefSize.h };
        };

        return {
          bounds: axisBounds,
          title: this._options[type + 'Axis']['title'],
          getPreferredSize: getPreferredSize
        };
      }

      return null;
    }

    /**
     * @override
     */
    IsTooltipElement(domElement) {
      var id = domElement.getAttribute('id');
      if (
        id &&
        (id.indexOf(DvtChartDataCursor.TOOLTIP_ID) == 0 ||
          id.indexOf(dvt.HtmlTooltipManager._TOOLTIP_DIV_ID) == 0)
      )
        return true;
      return false;
    }

    /**
     * Method to fire synthetic item drill event. Used by chart webdriver.
     * @param {string} seriesId The series id of the data item.
     * @param {Array<string>} groupId The group id of the data item.
     * @param {number} itemIndex The index of data item belonging to boxplot sub items.
     */

    dispatchItemDrill(seriesId, groupId, itemIndex) {
      var obj = this._getChartObjPeerFromId(seriesId, groupId, itemIndex);
      if (obj) {
        this._comp.getEventManager().processDrillEvent(obj);
      }
    }

    /**
     * Method to fire synthetic multiseries drill event. Used by chart webdriver.
     */
    dispatchMultiSeriesDrill() {
      var pie = this._comp.pieChart;
      if (pie && pie.otherSlice) {
        this._comp.getEventManager().processDrillEvent(pie.otherSlice);
      }
    }

    /**
     * Fires synthetic group drill event from chart. Used by chart webdriver.
     * @param {Array<string>} groupId The group id of the axis label from which group drill event is fired.
     */
    dispatchGroupDrill(groupId) {
      if (this._xAxisAutomation && groupId) {
        this._xAxisAutomation.dispatchDrillEvent(groupId);
      }
    }

    /**
     * Fires synthetic series drill event from chart. Used by chart webdriver.
     * @param {string} seriesId The id of chart series from which series drill event is fired.
     */

    dispatchSeriesDrill(seriesId) {
      if (this._legendAutomation && seriesId) {
        this._legendAutomation.dispatchDrillEvent(seriesId);
      }
    }
  }

  /**
   * Event Manager for Chart.
   * @param {Chart} chart
   * @class
   * @extends {dvt.EventManager}
   * @constructor
   */
  class DvtChartEventManager extends dvt.EventManager {
    constructor(chart) {
      super(chart.getCtx(), chart.processEvent, chart, chart);
      this._chart = chart;

      this._dragMode = null;
      this._dragButtonsVisible = dvt.Agent.isTouchDevice();

      /**
       * The pan button
       * @type {dvt.IconButton}
       */
      this.panButton = null;
      /**
       * The marquee zoom button
       * @type {dvt.IconButton}
       */
      this.zoomButton = null;
      /**
       * The marquee select button
       * @type {dvt.IconButton}
       */
      this.selectButton = null;

      // Event handlers
      this._dataCursorHandler = null;
      this._panZoomHandler = null;
      this._marqueeZoomHandler = null;
      this._marqueeSelectHandler = null;
    }

    /**
     * @override
     */
    addListeners(displayable) {
      dvt.SvgDocumentUtils.addDragListeners(
        this._chart,
        this._onDragStart,
        this._onDragMove,
        this._onDragEnd,
        this
      );
      super.addListeners(displayable);

      if (!dvt.Agent.isTouchDevice()) {
        displayable.addEvtListener(dvt.MouseEvent.MOUSEWHEEL, this.OnMouseWheel, false, this);
      }
    }

    /**
     * @override
     */
    RemoveListeners(displayable) {
      super.RemoveListeners(displayable);
      if (!dvt.Agent.isTouchDevice()) {
        displayable.removeEvtListener(dvt.MouseEvent.MOUSEWHEEL, this.OnMouseWheel, false, this);
      }
    }

    /**
     * Returns the logical object corresponding to the specified dvt.Displayable.  All high level event handlers,
     * such as the selection handlers, are designed to react to the logical objects.
     * @param {dvt.Displayable} target The displayable.
     * @return {object} The logical object corresponding to the target.
     */
    getLogicalObject(target) {
      return this.GetLogicalObject(target, true);
    }

    /**
     * Returns an event handler for the current drag mode.
     * @param {dvt.Point} relPos (optional) The current cursor position relative to the stage. If provided, the relPos will
     *    be considered in choosing the drag handler.
     * @return {dvt.MarqueeHandler or dvt.PanZoomHandler} Drag handler.
     * @private
     */
    _getDragHandler(relPos) {
      if (
        relPos &&
        this._chart.getOptions()['dragMode'] == 'user' &&
        DvtChartTypeUtils.isBLAC(this._chart) &&
        (this._dragMode == DvtChartEventManager.DRAG_MODE_PAN ||
          this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM)
      ) {
        // For BLAC chart on desktop, the pan and zoom modes are combined.
        // If the drag starts inside the plot area, it's a pan. If the drag starts inside the axis, it's a marquee zoom.
        if (this._panZoomHandler && this._panZoomHandler.isWithinBounds(relPos))
          this._dragMode = DvtChartEventManager.DRAG_MODE_PAN;
        else this._dragMode = DvtChartEventManager.DRAG_MODE_ZOOM;
      }

      if (this._dragMode == DvtChartEventManager.DRAG_MODE_PAN) return this._panZoomHandler;
      if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM) return this._marqueeZoomHandler;
      if (this._dragMode == DvtChartEventManager.DRAG_MODE_SELECT) return this._marqueeSelectHandler;
      return null;
    }

    /**
     * Drag start callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean} Whether drag is initiated.
     * @private
     */
    _onDragStart(event) {
      if (dvt.EventManager.isTouchEvent(event)) return this._onTouchDragStart(event);
      else return this._onMouseDragStart(event);
    }

    /**
     * Drag move callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean}
     * @private
     */
    _onDragMove(event) {
      if (dvt.EventManager.isTouchEvent(event)) return this._onTouchDragMove(event);
      else return this._onMouseDragMove(event);
    }

    /**
     * Drag end callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean}
     * @private
     */
    _onDragEnd(event) {
      if (dvt.EventManager.isTouchEvent(event)) return this._onTouchDragEnd(event);
      else return this._onMouseDragEnd(event);
    }

    /**
     * Mouse drag start callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean} Whether drag is initiated.
     * @private
     */
    _onMouseDragStart(event) {
      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
      var dragHandler = this._getDragHandler(relPos);
      var chartEvent;

      // Do not initiate drag if the target is selectable. Drag only on left click.
      var obj = this.GetLogicalObject(event.target);
      var selectable = obj && obj.isSelectable && obj.isSelectable();
      if (!selectable && event.button == 0 && dragHandler) {
        chartEvent = dragHandler.processDragStart(relPos, event.ctrlKey);
        if (chartEvent) this._callback.call(this._callbackObj, chartEvent);

        this._chart.setCursor(dragHandler.getCursor(relPos));
        this.setDragButtonsVisible(false); // hide drag buttons on drag

        // Ensure the chart is currently focused so that it can accept cancel events
        if (this._chart != this.getCtx().getCurrentKeyboardFocus())
          this.getCtx().setCurrentKeyboardFocus(this._chart);
      }

      if (chartEvent) {
        if (this._dataCursorHandler) this._dataCursorHandler.processEnd();
        return true;
      }
      return false;
    }

    /**
     * Mouse drag move callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onMouseDragMove(event) {
      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
      var dragHandler = this._getDragHandler(); // don't pass the relPos so that the drag mode stays
      var chartEvent;

      if (dragHandler) {
        chartEvent = dragHandler.processDragMove(relPos, event.ctrlKey);
        if (chartEvent) {
          this._callback.call(this._callbackObj, chartEvent);
          this.setDragButtonsVisible(false); // hide drag buttons on drag
        }
      }

      if (chartEvent) event.stopPropagation(); // prevent data cursor from appearing
    }

    /**
     * Mouse drag end callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onMouseDragEnd(event) {
      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
      var dragHandler = this._getDragHandler(); // don't pass the relPos so that the drag mode stays
      var chartEvent;

      if (dragHandler) {
        chartEvent = dragHandler.processDragEnd(relPos, event.ctrlKey);
        if (chartEvent) {
          this._callback.call(this._callbackObj, chartEvent);
          this.autoToggleZoomButton();
        }

        this._chart.setCursor(dragHandler.getCursor(relPos));

        // Show the drag buttons
        var axisSpace = this._chart.__getAxisSpace();
        if (axisSpace) this.setDragButtonsVisible(axisSpace.containsPoint(relPos.x, relPos.y));
      }
    }

    /**
     * @override
     */
    OnMouseMove(event) {
      super.OnMouseMove(event);

      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
      if (this._dataCursorHandler) {
        if (this.GetLogicalObjectAndDisplayable(event.target).displayable instanceof dvt.IconButton)
          // don't show DC over buttons
          this._dataCursorHandler.processEnd();
        else {
          relPos = this._component.stageToLocal(relPos);
          this._dataCursorHandler.processMove(relPos);
        }
      }

      // Update the cursor
      var dragHandler = this._getDragHandler(relPos);
      if (dragHandler) this._chart.setCursor(dragHandler.getCursor(relPos));
      else this._chart.setCursor('default');
    }

    /**
     * @override
     */
    OnMouseOut(event) {
      super.OnMouseOut(event);
      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);

      // Hide the drag buttons
      var axisSpace = this._chart.__getAxisSpace();
      if (axisSpace) this.setDragButtonsVisible(axisSpace.containsPoint(relPos.x, relPos.y));

      if (this._dataCursorHandler) {
        relPos = this._component.stageToLocal(relPos);
        this._dataCursorHandler.processMove(relPos);

        if (!event.relatedTarget) {
          this._dataCursorHandler.processEnd();
        }
      }

      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;
    }

    /**
     * @override
     */
    OnMouseWheel(event) {
      if (!DvtChartBehaviorUtils.isZoomable(this._chart)) return;

      var delta = event.wheelDelta != null ? event.wheelDelta : 0;
      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);

      if (this._panZoomHandler) {
        var panZoomEvent = this._panZoomHandler.processMouseWheel(relPos, delta);
        if (panZoomEvent) {
          event.preventDefault();
          event.stopPropagation();
          this._callback.call(this._callbackObj, panZoomEvent);

          // Update the data cursor since the viewport has changed
          if (this._dataCursorHandler) {
            relPos = this._component.stageToLocal(relPos);
            this._dataCursorHandler.processMove(relPos);
          }
        }
      }
    }

    /**
     * @override
     */
    ShowFocusEffect(event, navigable) {
      if (this._dataCursorHandler) {
        var pos = navigable.getDataPosition();
        if (pos) {
          var plotAreaBounds = this._chart.__getPlotAreaSpace();
          this._dataCursorHandler.processMove(
            new dvt.Point(pos.x + plotAreaBounds.x, pos.y + plotAreaBounds.y)
          );
        }
      }
      super.ShowFocusEffect(event, navigable);
    }

    /**
     * @override
     */
    OnBlur(event) {
      if (this._dataCursorHandler) this._dataCursorHandler.processEnd();
      super.OnBlur(event);
    }

    /**
     * @override
     */
    OnClickInternal(event) {
      var obj = this.GetLogicalObject(event.target);
      var pos = this._context.pageToStageCoords(event.pageX, event.pageY);
      if (this.SeriesFocusHandler) this.SeriesFocusHandler.processSeriesFocus(pos, obj);

      if (!obj) return;

      // Only drill if not selectable. If selectable, drill with double click.
      if (!(obj.isSelectable && obj.isSelectable())) this.processDrillEvent(obj);
    }

    /**
     * @override
     */
    OnDblClickInternal(event) {
      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;

      // Only double click to drill if selectable. Otherwise, drill with single click.
      if (obj.isSelectable && obj.isSelectable()) this.processDrillEvent(obj);
    }

    /**
     * @override
     */
    HandleTouchHoverStartInternal(event) {
      if (this._dataCursorHandler && !this.isTouchResponseTouchStart()) {
        var relPos = this._context.pageToStageCoords(event.touch.pageX, event.touch.pageY);
        this._dataCursorHandler.processMove(relPos);
        return false;
      }

      var dlo = this.GetLogicalObject(event.target);
      this.TouchManager.setTooltipEnabled(event.touch.identifier, this.getTooltipsEnabled(dlo));
      return false;
    }

    /**
     * @override
     */
    HandleTouchHoverMoveInternal(event) {
      if (this._dataCursorHandler && !this.isTouchResponseTouchStart()) {
        var relPos = this._context.pageToStageCoords(event.touch.pageX, event.touch.pageY);
        this._dataCursorHandler.processMove(relPos);
        return false;
      }

      var dlo = this.GetLogicalObject(event.target);
      this.TouchManager.setTooltipEnabled(event.touch.identifier, this.getTooltipsEnabled(dlo));
      return false;
    }

    /**
     * @override
     */
    HandleTouchHoverEndInternal(event) {
      this.endDrag();
    }

    /**
     * @override
     */
    HandleTouchClickInternal(event) {
      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;

      // Only drill if not selectable. If selectable, drill using double click.
      if (!(obj.isSelectable && obj.isSelectable())) this.processDrillEvent(obj);
    }

    /**
     * @override
     */
    HandleTouchDblClickInternal(event) {
      var obj = this.GetLogicalObject(event.target);
      if (!obj) return;

      // Only double click to drill if selectable. Otherwise, drill with single click.
      if (obj.isSelectable && obj.isSelectable()) {
        event.preventDefault();
        event.stopPropagation();
        this.processDrillEvent(obj);
      }
    }

    /**
     * Processes an drill on the specified chart item.
     * @param {DvtChartObjPeer} obj The chart item that was clicked.
     */
    processDrillEvent(obj) {
      if (obj && obj.isDrillable && obj.isDrillable()) {
        var id = obj.getId();
        if (obj instanceof DvtChartObjPeer) {
          // when clicked on line and area instead of marker, chart fires seriesDrill
          if (obj.getGroupIndex() === -1) {
            this.FireEvent(dvt.EventFactory.newChartDrillEvent(id, obj.getSeries(), null, 'series'));
          } else {
            this.FireEvent(
              dvt.EventFactory.newChartDrillEvent(
                id.id != null ? id.id : id,
                obj.getSeries(),
                obj.getGroup(),
                'item'
              )
            );
          }
        } else if (obj instanceof DvtChartPieSlice) {
          // chart does not use DvtChartObjPeer for pieslice
          var subType = id.series === '_dvtOther' ? 'multiSeries' : 'item';
          this.FireEvent(dvt.EventFactory.newChartDrillEvent(id.id, id.series, id.group, subType));
        }
      }
    }

    /**
     * @override
     */
    ProcessRolloverEvent(event, obj, bOver) {
      // Don't continue if not enabled
      var options = this._chart.getOptions();
      if (DvtChartBehaviorUtils.getHoverBehavior(this._chart) != 'dim') return;

      // Compute the new highlighted categories and update the options
      var categories = obj.getCategories ? obj.getCategories() : [];
      options['highlightedCategories'] = bOver ? categories.slice() : null;

      // Fire the event to the rollover handler, who will fire to the component callback.
      var rolloverEvent = dvt.EventFactory.newCategoryHighlightEvent(
        options['highlightedCategories'],
        bOver
      );
      var hoverBehaviorDelay = DvtChartStyleUtils.getHoverBehaviorDelay(this._chart);

      // Find all the objects that may need to be highlighted
      var objs = this._chart.getObjects();
      if (this._chart.pieChart) objs = objs.concat(this._chart.pieChart.__getSlices());

      this.RolloverHandler.processEvent(
        rolloverEvent,
        objs,
        hoverBehaviorDelay,
        options['highlightMatch'] == 'any'
      );
    }

    /**
     * Touch drag start callback.
     * @param {dvt.BaseEvent} event
     * @return {boolean} Whether drag is initiated.
     * @private
     */
    _onTouchDragStart(event) {
      var touches = event.touches;
      var chartEvent, dataCursorOn;

      if (touches.length == 1) {
        var relPos = this._context.pageToStageCoords(touches[0].pageX, touches[0].pageY);
        var dragHandler = this._getDragHandler();
        if (dragHandler) chartEvent = dragHandler.processDragStart(relPos, true);
        else if (this._dataCursorHandler && this.isTouchResponseTouchStart()) {
          this._dataCursorHandler.processMove(relPos);
          dataCursorOn = true;
        }
      } else if (
        touches.length == 2 &&
        this._panZoomHandler &&
        DvtChartBehaviorUtils.isZoomable(this._chart)
      ) {
        this.endDrag(); // clean 1-finger events before starting pinch zoom
        var relPos1 = this._context.pageToStageCoords(touches[0].pageX, touches[0].pageY);
        var relPos2 = this._context.pageToStageCoords(touches[1].pageX, touches[1].pageY);
        chartEvent = this._panZoomHandler.processPinchStart(relPos1, relPos2);
      }

      if (chartEvent) {
        this._callback.call(this._callbackObj, chartEvent);
        this.getCtx().getTooltipManager().hideTooltip();
      }

      if (chartEvent || dataCursorOn) {
        event.preventDefault();
        event.stopPropagation();
        this.setDragButtonsVisible(false); // hide drag buttons on drag
        return true;
      }

      return false;
    }

    /**
     * Touch drag move callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onTouchDragMove(event) {
      var touches = event.touches;
      var chartEvent, dataCursorOn;

      if (touches.length == 1) {
        var relPos = this._context.pageToStageCoords(touches[0].pageX, touches[0].pageY);
        var dragHandler = this._getDragHandler();
        if (dragHandler) chartEvent = dragHandler.processDragMove(relPos, true);
        else if (this._dataCursorHandler && this.isTouchResponseTouchStart()) {
          this._dataCursorHandler.processMove(relPos);
          dataCursorOn = true;
        }
      } else if (
        touches.length == 2 &&
        this._panZoomHandler &&
        DvtChartBehaviorUtils.isZoomable(this._chart)
      ) {
        var relPos1 = this._context.pageToStageCoords(touches[0].pageX, touches[0].pageY);
        var relPos2 = this._context.pageToStageCoords(touches[1].pageX, touches[1].pageY);
        chartEvent = this._panZoomHandler.processPinchMove(relPos1, relPos2);
      }

      if (chartEvent || dataCursorOn) {
        event.preventDefault();
      }

      if (chartEvent) {
        this._callback.call(this._callbackObj, chartEvent);
        this.getCtx().getTooltipManager().hideTooltip();
      }
    }

    /**
     * Touch drag end callback.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onTouchDragEnd(event) {
      // End 1-finger event
      var chartEvent1 = this.endDrag();

      // End 2-finger event
      var chartEvent2;
      if (this._panZoomHandler && DvtChartBehaviorUtils.isZoomable(this._chart)) {
        chartEvent2 = this._panZoomHandler.processPinchEnd();
        if (chartEvent2) this._callback.call(this._callbackObj, chartEvent2);
      }

      if (chartEvent1 || chartEvent2) {
        event.preventDefault();
        this.getCtx().getTooltipManager().hideTooltip();

        var touchManager = this.getTouchManager();
        var identifier =
          event['changedTouches'].length == 1 ? event['changedTouches'][0].identifier : null;
        var touchInfo = identifier != null ? touchManager.getTouchInfo(identifier) : null;

        // : Reset the touch manager if we will be processing a touchMove, because we do not use the touch manager to handle the dragging
        // but the dragging updates the touch manager state
        if (!touchInfo || touchInfo['touchMoved']) touchManager.reset();
      }

      this.setDragButtonsVisible(true);
    }

    /**
     * @override
     */
    endDrag() {
      var dragHandler = this._getDragHandler();
      var chartEvent;

      if (dragHandler) chartEvent = dragHandler.processDragEnd(null, true);

      if (this._dataCursorHandler) this._dataCursorHandler.processEnd();

      if (chartEvent) this._callback.call(this._callbackObj, chartEvent);

      return chartEvent;
    }

    /**
     * Zooms by the specified amount.
     * @param {number} dz A number specifying the zoom ratio. dz = 1 means no zoom.
     */
    zoomBy(dz) {
      if (this._panZoomHandler && DvtChartBehaviorUtils.isZoomable(this._chart)) {
        var chartEvent = this._panZoomHandler.zoomBy(dz);
        if (chartEvent) this._callback.call(this._callbackObj, chartEvent);
      }
    }

    /**
     * Pans by the specified amount.
     * @param {number} dx A number from specifying the pan ratio in the x direction, e.g. dx = 0.5 means pan end by 50%..
     * @param {number} dy A number from specifying the pan ratio in the y direction, e.g. dy = 0.5 means pan down by 50%.
     */
    panBy(dx, dy) {
      if (this._panZoomHandler && DvtChartBehaviorUtils.isScrollable(this._chart)) {
        var chartEvent = this._panZoomHandler.panBy(dx, dy);
        if (chartEvent) this._callback.call(this._callbackObj, chartEvent);
      }
    }

    /**
     * Helper function to hide tooltips and data cursor, generally in preparation for render or removal of the chart. This
     * is not done in hideTooltip to avoid interactions with the superclass, which would cause problems with the data cursor.
     */
    hideHoverFeedback() {
      // Hide tooltip and data cursor
      this.hideTooltip();

      // Hide the data cursor. This is necessary to hide the data cursor line when the user mouses over the tooltip div in
      // IE9, which does not support pointer-events.
      if (this._dataCursorHandler) this._dataCursorHandler.processEnd();
    }

    /**
     * @override
     */
    hideTooltip() {
      // Don't hide the tooltip if data cursor is shown on a touch device
      if (!this._dataCursorHandler || !this._dataCursorHandler.isDataCursorShown())
        super.hideTooltip();
    }

    /**
     * @override
     */
    getTooltipsEnabled(logicalObj) {
      // Don't allow tooltips to conflict with the data cursor
      if (
        this._dataCursorHandler &&
        (logicalObj instanceof DvtChartObjPeer ||
          logicalObj instanceof DvtChartRefObjPeer ||
          this._dataCursorHandler.isDataCursorShown())
      )
        return false;
      else return super.getTooltipsEnabled();
    }

    /**
     * Gets the data cursor handler.
     * @return {DvtChartDataCursorHandler} The data cursor handler.
     */
    getDataCursorHandler() {
      return this._dataCursorHandler;
    }

    /**
     * Sets the data cursor handler.
     * @param {DvtChartDataCursorHandler} handler The data cursor handler.
     */
    setDataCursorHandler(handler) {
      this._dataCursorHandler = handler;
    }

    /**
     * Sets the pan zoom handler.
     * @param {dvt.PanZoomHandler} handler The pan zoom handler.
     */
    setPanZoomHandler(handler) {
      this._panZoomHandler = handler;
    }

    /**
     * Sets the marquee zoom handler.
     * @param {dvt.MarqueeHandler} handler The marquee zoom handler.
     */
    setMarqueeZoomHandler(handler) {
      this._marqueeZoomHandler = handler;
    }

    /**
     * Sets the marquee select handler.
     * @param {dvt.MarqueeHandler} handler The marquee select handler.
     */
    setMarqueeSelectHandler(handler) {
      this._marqueeSelectHandler = handler;
    }

    /**
     * @override
     */
    getMarqueeGlassPane() {
      if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM)
        return this._marqueeZoomHandler.getGlassPane();
      else if (this._dragMode == DvtChartEventManager.DRAG_MODE_SELECT)
        return this._marqueeSelectHandler.getGlassPane();

      return null;
    }

    /**
     * Cancels marquee zoom/select.
     * @param {dvt.BaseEvent} event The event
     */
    cancelMarquee(event) {
      if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM) {
        if (this._marqueeZoomHandler.cancelMarquee()) event.preventDefault();
      } else if (this._dragMode == DvtChartEventManager.DRAG_MODE_SELECT) {
        // If marquee is in progress, re-render from the options obj, which has the old selection
        if (this._marqueeSelectHandler && this._marqueeSelectHandler.cancelMarquee())
          this._chart.render();
      }
    }

    /**
     * Gets the current drag mode.
     * @return {string} The drag mode.
     */
    getDragMode() {
      return this._dragMode;
    }

    /**
     * Sets the drag mode. If set to null, the drag mode will become the default one.
     * @param {string} dragMode The drag mode, or null.
     */
    setDragMode(dragMode) {
      if (dragMode == null) this._dragMode = this._getDefaultDragMode();
      else this._dragMode = dragMode;

      // If the chart is fully zoomed out, the pan mode should fall back to the zoom mode on desktop
      if (
        this._chart.xAxis.isFullViewport() &&
        (!this._chart.yAxis || this._chart.yAxis.isFullViewport())
      )
        this.autoToggleZoomButton();
    }

    /**
     * Returns the default drag mode for the chart.
     * @return {string} The default drag mode.
     * @private
     */
    _getDefaultDragMode() {
      if (dvt.Agent.isTouchDevice()) return DvtChartEventManager.DRAG_MODE_OFF;
      else if (DvtChartBehaviorUtils.isScrollable(this._chart))
        return DvtChartEventManager.DRAG_MODE_PAN;
      else if (this._chart.getOptions()['selectionMode'] == 'multiple')
        return DvtChartEventManager.DRAG_MODE_SELECT;
      else return null;
    }

    /**
     * Handles the zoom button click event.
     * @param {object} event
     */
    onZoomButtonClick(event) {
      if (this.zoomButton.isToggled()) {
        if (this.selectButton) this.selectButton.setToggled(false);
        this.setDragMode(DvtChartEventManager.DRAG_MODE_ZOOM);
      } else this.setDragMode(null);
    }

    /**
     * Handles the pan button click event.
     * @param {object} event
     */
    onPanButtonClick(event) {
      if (this.panButton.isToggled()) {
        if (this.selectButton) this.selectButton.setToggled(false);
        this.setDragMode(DvtChartEventManager.DRAG_MODE_PAN);
      } else this.setDragMode(null);
    }

    /**
     * Handles the select button click event.
     * @param {object} event
     */
    onSelectButtonClick(event) {
      if (this.selectButton.isToggled()) {
        if (this.zoomButton) this.zoomButton.setToggled(false);
        if (this.panButton) this.panButton.setToggled(false);
        this.setDragMode(DvtChartEventManager.DRAG_MODE_SELECT);
      } else this.setDragMode(null);
    }

    /**
     * Sets the visibility of the drag buttons.
     * @param {boolean} visible The visibility.
     */
    setDragButtonsVisible(visible) {
      if (visible && !this._dragButtonsVisible) {
        this._chart.showDragButtons();
        this._dragButtonsVisible = true;
      } else if (!visible && this._dragButtonsVisible) {
        this._chart.hideDragButtons();
        this._dragButtonsVisible = false;
      }
    }

    /**
     * Returns whether the drag buttons are visible.
     * @return {boolean}
     */
    areDragButtonsVisible() {
      return this._dragButtonsVisible;
    }

    /**
     * Toggles the marquee zoom button automatically:
     * - Marquee select button is unaffected.
     * - If the chart is fully zoomed out, turn on the marquee zoom mode; otherwise, turn it off.
     * Doesn't apply to touch devices.
     */
    autoToggleZoomButton() {
      if (dvt.Agent.isTouchDevice() || !this.zoomButton) return;

      if (this._chart.xAxis.isFullViewport() && this._chart.yAxis.isFullViewport()) {
        if (this._dragMode == DvtChartEventManager.DRAG_MODE_PAN) {
          this.zoomButton.setToggled(true);
          this.onZoomButtonClick(null);
        }
      } else {
        if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM) {
          this.zoomButton.setToggled(false);
          this.onZoomButtonClick(null);
        }
      }
    }

    /**
     * @override
     */
    GetTouchResponse() {
      if (this._dragMode && this._dragMode != DvtChartEventManager.DRAG_MODE_OFF) {
        return dvt.EventManager.TOUCH_RESPONSE_TOUCH_HOLD;
      } else return this._chart.getOptions()['touchResponse'];
    }

    // Drag & Drop Support
    /**
     * @override
     */
    isDndSupported() {
      return true;
    }

    /**
     * @override
     */
    GetDragSourceType() {
      var obj = this.DragSource.getDragObject();
      if (
        (obj instanceof DvtChartObjPeer && obj.getSeriesIndex() >= 0 && obj.getGroupIndex() >= 0) ||
        obj instanceof DvtChartPieSlice
      )
        return 'items';
      return null;
    }

    /**
     * @override
     */
    GetDragDataContexts(bSanitize) {
      // If more than one object is selected, return the contexts of all selected objects
      if (
        this._chart.isSelectionSupported() &&
        this._chart.getSelectionHandler().getSelectedCount() > 1
      ) {
        var selection = this._chart.getSelectionHandler().getSelection();
        var contexts = [];
        for (var i = 0; i < selection.length; i++) {
          var context = DvtChartStyleUtils.getDataContext(
            this._chart,
            selection[i].getSeriesIndex(),
            selection[i].getGroupIndex(),
            selection[i].getNestedDataItemIndex()
          );
          if (bSanitize) dvt.ToolkitUtils.cleanDragDataContext(context);
          contexts.push(context);
        }
        return contexts;
      }

      // Otherwise, return the context of the current drag object
      var obj = this.DragSource.getDragObject();
      var dataContext = null;
      if (obj instanceof DvtChartObjPeer)
        dataContext = DvtChartStyleUtils.getDataContext(
          this._chart,
          obj.getSeriesIndex(),
          obj.getGroupIndex(),
          obj.getNestedDataItemIndex()
        );
      if (obj instanceof DvtChartPieSlice)
        dataContext = DvtChartStyleUtils.getDataContext(this._chart, obj.getSeriesIndex(), 0);
      if (dataContext && bSanitize) dvt.ToolkitUtils.cleanDragDataContext(dataContext);
      return dataContext ? [dataContext] : null;
    }

    /**
     * @override
     */
    GetDropOffset(event) {
      var obj = this.DragSource.getDragObject();

      if (obj instanceof DvtChartObjPeer) {
        var dataPos = obj.getDataPosition();
        if (dataPos) {
          dataPos = this._chart.getPlotArea().localToStage(dataPos);
          var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
          return new dvt.Point(dataPos.x - relPos.x, dataPos.y - relPos.y);
        }
      }

      return null;
    }

    /**
     * @override
     */
    GetDropTargetType(event) {
      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
      var dropOptions = this._chart.getOptions()['dnd']['drop'];

      var paBounds = this._chart.__getPlotAreaSpace();
      if (
        Object.keys(dropOptions['plotArea']).length > 0 &&
        paBounds.containsPoint(relPos.x, relPos.y)
      )
        return 'plotArea';

      if (
        Object.keys(dropOptions['xAxis']).length > 0 &&
        DvtChartAxisUtils.isAxisRendered(this._chart, 'x') &&
        DvtChartAxisUtils.axisContainsPoint(this._chart.xAxis, relPos)
      )
        return 'xAxis';

      if (
        Object.keys(dropOptions['yAxis']).length > 0 &&
        DvtChartAxisUtils.isAxisRendered(this._chart, 'y') &&
        DvtChartAxisUtils.axisContainsPoint(this._chart.yAxis, relPos)
      )
        return 'yAxis';

      if (
        Object.keys(dropOptions['y2Axis']).length > 0 &&
        DvtChartAxisUtils.isAxisRendered(this._chart, 'y2') &&
        DvtChartAxisUtils.axisContainsPoint(this._chart.y2Axis, relPos)
      )
        return 'y2Axis';

      return null;
    }

    /**
     * @override
     */
    GetDropEventPayload(event) {
      // Apply the drop offset if the drag source is a DVT component
      // NOTE: The drop offset is stored in dataTransfer, so it's only accessible from "drop" event. It can't be
      //       accessed from "dragEnter", "dragOver", and "dragLeave".
      var dataTransfer = event.getNativeEvent().dataTransfer;
      var offsetX = Number(dataTransfer.getData(dvt.EventManager.DROP_OFFSET_X_DATA_TYPE)) || 0;
      var offsetY = Number(dataTransfer.getData(dvt.EventManager.DROP_OFFSET_Y_DATA_TYPE)) || 0;

      var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
      return this._chart.getValsAt(relPos.x + offsetX, relPos.y + offsetY);
    }

    /**
     * @override
     */
    ShowDropEffect(event) {
      var dropObject = this._getDropObject(event);

      if (dropObject) {
        dropObject.setClassName('oj-active-drop');
        dropObject.setSolidFill(this._chart.getOptions()['_dropColor']);
      }
    }

    /**
     * @override
     */
    ClearDropEffect() {
      // Clear the plot area
      var plotArea = this._chart.getCache().getFromCache('plotAreaBackground');
      if (plotArea) {
        var plotAreaColor = DvtChartStyleUtils.getBackgroundColor(this._chart);
        if (plotAreaColor) plotArea.setSolidFill(plotAreaColor);
        else plotArea.setInvisibleFill();
        dvt.ToolkitUtils.removeClassName(plotArea.getElem(), 'oj-invalid-drop');
        dvt.ToolkitUtils.removeClassName(plotArea.getElem(), 'oj-active-drop');
      }

      // Clear the axes
      var clearAxisDropEffect = (axis) => {
        if (axis) {
          var background = axis.getCache().getFromCache('background');
          if (background) {
            background.setInvisibleFill();
            dvt.ToolkitUtils.removeClassName(background.getElem(), 'oj-invalid-drop');
            dvt.ToolkitUtils.removeClassName(background.getElem(), 'oj-active-drop');
          }
        }
      };
      clearAxisDropEffect(this._chart.xAxis);
      clearAxisDropEffect(this._chart.yAxis);
      clearAxisDropEffect(this._chart.y2Axis);
    }

    /**
     * @override
     */
    ShowRejectedDropEffect(event) {
      var dropObject = this._getDropObject(event);

      if (dropObject) dropObject.setClassName('oj-invalid-drop');
    }

    /**
     * Returns the background object that accepts DnD drops
     * @param {object} event
     * @return {dvt.Rect}
     * @private
     */
    _getDropObject(event) {
      var dropTargetType = this.GetDropTargetType(event);
      var dropObject;

      if (dropTargetType == 'plotArea') {
        dropObject = this._chart.getCache().getFromCache('plotAreaBackground');
      } else if (dropTargetType == 'xAxis') {
        dropObject = this._chart.xAxis.getCache().getFromCache('background');
      } else if (dropTargetType == 'yAxis') {
        dropObject = this._chart.yAxis.getCache().getFromCache('background');
      } else if (dropTargetType == 'y2Axis') {
        dropObject = this._chart.y2Axis.getCache().getFromCache('background');
      }

      return dropObject;
    }
  }

  /** @const */
  DvtChartEventManager.DRAG_MODE_PAN = 'pan';
  /** @const */
  DvtChartEventManager.DRAG_MODE_ZOOM = 'zoom';
  /** @const */
  DvtChartEventManager.DRAG_MODE_SELECT = 'select';
  /** @const */
  DvtChartEventManager.DRAG_MODE_OFF = 'off';

  /*---------------------------------------------------------------------------------*/
  /*  DvtChartKeyboardHandler     Keyboard handler for Chart                         */
  /*---------------------------------------------------------------------------------*/
  /**
   *  @param {dvt.EventManager} manager The owning dvt.EventManager
   *  @param {Chart} chart
   *  @class DvtChartKeyboardHandler
   *  @extends {dvt.KeyboardHandler}
   *  @constructor
   */
  class DvtChartKeyboardHandler extends dvt.KeyboardHandler {
    constructor(manager, chart) {
      super(manager);
      this._chart = chart;
    }

    /**
     * @override
     */
    isSelectionEvent(event) {
      return this.isNavigationEvent(event) && !event.ctrlKey;
    }

    /**
     * @override
     */
    isMultiSelectEvent(event) {
      return event.keyCode == dvt.KeyboardEvent.SPACE && event.ctrlKey;
    }

    /**
     * @override
     */
    processKeyDown(event) {
      var keyCode = event.keyCode;
      if (keyCode == dvt.KeyboardEvent.TAB) {
        var currentNavigable = this._eventManager.getFocus();
        if (currentNavigable) {
          dvt.EventManager.consumeEvent(event);
          return currentNavigable;
        }

        // navigate to the default
        var navigables = DvtChartEventUtils.getKeyboardNavigables(this._chart);
        if (navigables.length > 0) {
          dvt.EventManager.consumeEvent(event);
          return this.getDefaultNavigable(navigables);
        }
      } else if (keyCode == dvt.KeyboardEvent.ENTER) {
        var currentNavigable = this._eventManager.getFocus();
        if (currentNavigable) {
          this._eventManager.processDrillEvent(currentNavigable);
          dvt.EventManager.consumeEvent(event);
          return currentNavigable;
        }
      } else if (keyCode == dvt.KeyboardEvent.ESCAPE) {
        this._eventManager.cancelMarquee(event);
      } else if (keyCode == dvt.KeyboardEvent.PAGE_UP) {
        if (
          (event.ctrlKey || event.shiftKey || DvtChartTypeUtils.isBLAC(this._chart)) &&
          DvtChartTypeUtils.isVertical(this._chart)
        ) {
          // pan left
          this._eventManager.panBy(-0.25, 0);
        } else {
          // pan up. Also used for horizontal bar charts
          this._eventManager.panBy(0, -0.25);
        }
        dvt.EventManager.consumeEvent(event);
      } else if (keyCode == dvt.KeyboardEvent.PAGE_DOWN) {
        if (
          (event.ctrlKey || event.shiftKey || DvtChartTypeUtils.isBLAC(this._chart)) &&
          DvtChartTypeUtils.isVertical(this._chart)
        ) {
          // pan right
          this._eventManager.panBy(0.25, 0);
        } else {
          // pan down. Also used for horizontal bar charts
          this._eventManager.panBy(0, 0.25);
        }
        dvt.EventManager.consumeEvent(event);
      } else if (dvt.KeyboardEvent.isEquals(event) || dvt.KeyboardEvent.isPlus(event)) {
        // zoom in
        this._eventManager.zoomBy(1.5);
      } else if (dvt.KeyboardEvent.isMinus(event) || dvt.KeyboardEvent.isUnderscore(event)) {
        // zoom out
        this._eventManager.zoomBy(1 / 1.5);
      }

      return super.processKeyDown(event);
    }

    /**
     * @override
     */
    getDefaultNavigable(navigableItems) {
      if (!navigableItems || navigableItems.length <= 0) return null;

      var isPie = DvtChartTypeUtils.isPie(this._chart);
      var defaultNavigable, defaultSeries, defaultGroup;
      var navigable;

      // Pick the first group in the first series
      for (var i = 0; i < navigableItems.length; i++) {
        navigable = navigableItems[i];

        if (!defaultNavigable || navigable.getSeriesIndex() < defaultSeries) {
          defaultNavigable = navigable;
          defaultSeries = navigable.getSeriesIndex();
          if (!isPie) defaultGroup = navigable.getGroupIndex();
          continue;
        }

        if (!isPie && navigable.getGroupIndex() < defaultGroup) {
          defaultNavigable = navigable;
          defaultSeries = navigable.getSeriesIndex();
          defaultGroup = navigable.getGroupIndex();
        }
      }

      return defaultNavigable;
    }
  }

  /**
   *  Data change handler for a chart object peer.
   *  @extends {dvt.Obj}
   *  @class DvtChartDataChange  Data change Handler for a chart object peer.
   *  @constructor
   *  @param {DvtChartObjPeer} peer  The chart object peer to be animated on datachange.
   *  @param {Number} duration  the duration of the animation in seconds.
   */
  class DvtChartDataChangeHandler {
    constructor(peer, duration, animId) {
      this._peer = peer;
      this._updateDuration = duration * 0.75;
      this._insertDuration = duration * 0.5;
      this._deleteDuration = duration * 0.5;
      this._shape = peer.getDisplayables()[0];
      this._animId = (peer.getDataItemId() || peer.getSeries() + '/' + peer.getGroup()) + animId;
    }

    /**
     * Creates an update animation from the old node to this node.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can
     *                                  be used to chain animations. Animations
     *                                  created should be added via
     *                                  dvt.DataAnimationHandler.add()
     * @param {DvtChartDataChange} oldNode The old node state to animate from.
     */
    animateUpdate(handler, oldNode) {
      var oldShape = oldNode._shape;

      // Use update animation defined by the shape if available.
      if (this._shape && this._shape.getUpdateAnim)
        handler.add(this._shape.getUpdateAnim(this._updateDuration, oldShape), 1);
    }

    /**
     * Creates an insert animation for this node.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can
     *                                  be used to chain animations. Animations
     *                                  created should be added via
     *                                  dvt.DataAnimationHandler.add()
     */
    animateInsert(handler) {
      // Use insert animation defined by the shape if available.
      if (this._shape && this._shape.getInsertAnim)
        handler.add(this._shape.getInsertAnim(this._insertDuration), 2);
      else {
        // Fade In
        var nodePlayable = new dvt.AnimFadeIn(
          this._shape.getCtx(),
          this._shape,
          this._insertDuration
        );
        handler.add(nodePlayable, 0);
      }
    }

    /**
     * Creates a delete animation for this node.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can
     *                                  be used to chain animations. Animations
     *                                  created should be added via
     *                                  dvt.DataAnimationHandler.add()
     * @param {dvt.Container} delContainer   The container to which deleted objects can
     *                                      be moved for animation.
     */
    animateDelete(handler, delContainer) {
      // Move from the old chart to the delete container on top of the new chart.
      delContainer.addChild(this._shape);

      // Use the delete animation defined by the shape if available.
      if (this._shape && this._shape.getDeleteAnim)
        handler.add(this._shape.getDeleteAnim(this._deleteDuration), 0);
      else {
        // Fade Out
        var nodePlayable = new dvt.AnimFadeOut(
          this._shape.getCtx(),
          this._shape,
          this._deleteDuration
        );
        handler.add(nodePlayable, 0);
      }
    }

    /**
     * @return {String} A unique id for object comparison during data change animation of a chart.
     */
    getId() {
      return this._animId;
    }

    /**
     * Sets the id for the data change object. Generally the id is created automatically, so this method should only be
     * used if the default id needs to be overridden.
     * @param {String} id A unique id for object comparison during data change animation of a chart.
     */
    setId(id) {
      this._animId = id;
    }

    /**
     *   Saves the psuedo old chart object.
     *   @param {Object} chart  a synopsis object created by Chart before
     *   the chart object is updated and rendered with new data.
     */
    setOldChart(chart) {
      this._oldChart = chart;
    }
  }

  /*---------------------------------------------------------------------*/
  /*  DvtChartDataChangeUtils()                                                       */
  /*---------------------------------------------------------------------*/

  // Utilities for Chart data change animations

  /**
   * @constructor
   */
  const DvtChartDataChangeUtils = {
    DIR_UP: 0, // pointer directions
    DIR_DOWN: 1,
    DIR_NOCHANGE: 2,

    /**
     * Creates an update value direction pointer and positions it.
     * @param {Object} oldChart old chart.
     * @param {number} oldSIdx old series index.
     * @param {number} oldGIdx old group index.
     * @param {Chart} newChart new chart.
     * @param {number} newSIdx new series index.
     * @param {number} newGIdx new group index.
     * @return {dvt.Path} indicator.
     */
    makeIndicator: (oldChart, oldSIdx, oldGIdx, newChart, newSIdx, newGIdx) => {
      if (DvtChartTypeUtils.isPolar(newChart)) return null;

      var uiDirection = DvtChartDataChangeUtils.getDirection(
        oldChart,
        oldSIdx,
        oldGIdx,
        newChart,
        newSIdx,
        newGIdx
      );
      if (uiDirection == DvtChartDataChangeUtils.DIR_NOCHANGE) return null;

      var bDown = uiDirection === DvtChartDataChangeUtils.DIR_DOWN;
      var fc = bDown
        ? DvtChartStyleUtils.getAnimDownColor(newChart)
        : DvtChartStyleUtils.getAnimUpColor(newChart);

      //  Create a path object that draws the indicator (it will be positioned in _setAnimParams).
      var indicator = DvtChartDataChangeUtils._drawIndicator(
        newChart.getCtx(),
        bDown,
        DvtChartTypeUtils.isHorizontal(newChart),
        fc
      );
      newChart.getPlotArea().addChild(indicator);
      return indicator;
    },

    /**
     * Returns the direction of data change for use with animation indicators
     * @param {Object} oldChart old chart.
     * @param {number} oldSIdx old series index.
     * @param {number} oldGIdx old group index.
     * @param {Chart} newChart new chart.
     * @param {number} newSIdx new series index.
     * @param {number} newGIdx new group index.
     * @return {number} direction.
     */
    getDirection: (oldChart, oldSIdx, oldGIdx, newChart, newSIdx, newGIdx) => {
      var oldValue = DvtChartDataUtils.getVal(oldChart, oldSIdx, oldGIdx);
      var newValue = DvtChartDataUtils.getVal(newChart, newSIdx, newGIdx);

      if (newValue == null || oldValue == null || newValue == oldValue)
        return DvtChartDataChangeUtils.DIR_NOCHANGE;

      return newValue > oldValue ? DvtChartDataChangeUtils.DIR_UP : DvtChartDataChangeUtils.DIR_DOWN;
    },

    /**
     * Creates and returns a dvt.Path centered at (0,0) for the animation indicator.
     * @param {dvt.Context} context
     * @param {boolean} bDown True if the indicator represents a decrease in value.
     * @param {boolean} bHoriz True if the y axis is horizontal.
     * @param {string} fc The fill color of the indicator
     * @return {dvt.Path}
     * @private
     */
    _drawIndicator: (context, bDown, bHoriz, fc) => {
      var ptrCmds;
      if (bHoriz) {
        var bLeft = dvt.Agent.isRightToLeft(context) ? !bDown : bDown;
        ptrCmds = bLeft ? 'M3.5,-5L3.5,5L-3.5,0L3.5,-5' : 'M-3.5,-5L-3.5,5L3.5,0L-3.5,-5';
      } // Vertical
      else ptrCmds = bDown ? 'M-5,-3.5L5,-3.5L0,3.5L-5,-3.5Z' : 'M-5,3.5L5,3.5L0,-3.5L-5,3.5Z';

      var cssClass = bDown ? 'oj-chart-animation-down' : 'oj-chart-animation-up';
      var ret = new dvt.Path(context, ptrCmds);
      ret.setClassName(cssClass);
      ret.setStyle({ fill: fc });
      return ret;
    }
  };

  /**
   *  Data change Handler for 2D Bar Riser (implements DvtChartDataChangeHandler).
   *  @extends {DvtChartDataChangeHandler}
   *  @class DvtChartDataChangeBar  Data change Handler for 2D Bar Riser.
   *  @constructor
   *  @param {DvtChartObjPeer} peer The chart object peer for the shape to be animated.
   *  @param {number} duration  the animation duration is seconds.
   */
  class DvtChartDataChangeBar extends DvtChartDataChangeHandler {
    constructor(peer, duration, animId) {
      super(peer, duration, animId);
      this._indicator = null;
    }

    /**
     * @override
     */
    animateInsert(handler) {
      var playable = this._shape.getInsertAnim(this._insertDuration);
      handler.add(playable, 2);
    }

    /**
     * @override
     */
    animateDelete(handler, delContainer) {
      // Move from the old chart to the new chart
      delContainer.addChild(this._shape);

      // Create the delete animation
      var playable = this._shape.getDeleteAnim(this._deleteDuration);
      handler.add(playable, 0);
    }

    /**
     * @override
     */
    animateUpdate(handler, oldDC) {
      var oldChart = this._oldChart;
      var newChart = this._peer.getChart();

      // Get the start and end state for the animation. Get flipped coordinates if orientation has changed.
      var bFlip =
        DvtChartTypeUtils.isHorizontal(oldChart) != DvtChartTypeUtils.isHorizontal(newChart);
      var startState = oldDC._getAnimParams(bFlip);
      var endState = this._getAnimParams();

      // Get the start and end state for the fill animation. If either shape is selected, skip the fill animation so
      // that it doesn't animate the black fill of the selection outer shape
      var startFill = oldDC._shape.getPrimaryFill();
      var endFill = this._shape.getPrimaryFill();
      var bSkipFillAnimation =
        oldDC._shape.isSelected() || this._shape.isSelected() || startFill.equals(endFill);

      if (dvt.ArrayUtils.equals(startState, endState) && startFill.equals(endFill)) return;

      var newSIdx = this._peer.getSeriesIndex();
      var oldSIdx = oldDC._peer.getSeriesIndex();
      var newGIdx = this._peer.getGroupIndex();
      var oldGIdx = oldDC._peer.getGroupIndex();

      //  Create an animate indicator if requested
      if (DvtChartStyleUtils.getAnimIndicators(newChart) !== 'none')
        this._indicator = DvtChartDataChangeUtils.makeIndicator(
          oldChart,
          oldSIdx,
          oldGIdx,
          newChart,
          newSIdx,
          newGIdx
        );

      // Initialize start state
      this._setAnimParams(startState);
      if (!bSkipFillAnimation) this._shape.setFill(startFill);

      // Create the animator for this bar update
      var nodePlayable = new dvt.CustomAnimation(this._shape.getCtx(), this, this._updateDuration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this._getAnimParams,
          this._setAnimParams,
          endState
        );

      if (!bSkipFillAnimation)
        nodePlayable
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_FILL,
            this._shape,
            this._shape.getFill,
            this._shape.setFill,
            endFill
          );

      if (this._indicator) {
        nodePlayable.setOnEnd(this._onEndAnim, this);
        this._indicator.setAlpha(0);
      }

      handler.add(nodePlayable, 1); // create the playable
    }

    /**
     * Returns the geometry of the bar.
     * @param {boolean} bFlip True if the result should be flipped for horizontal/vertical orientation change.
     * @return {Array}
     * @private
     */
    _getAnimParams(bFlip) {
      return this._shape.getAnimParams(bFlip);
    }

    /**
     * Updates the geometry of the bar.
     * @param {Array} ar  an array containing the polygon points.
     * @private
     */
    _setAnimParams(ar) {
      this._shape.setAnimParams(ar, this._indicator);
    }

    /**
     * Callback to remove the indicator object at the end of the animation.
     * @private
     */
    _onEndAnim() {
      if (this._indicator) {
        this._indicator.getParent().removeChild(this._indicator);
        this._indicator = null;
      }
    }
  }

  /**
   *  Data change Handler for DvtChartFunnelSlice (implements DvtChartDataChangeHandler).
   *  @extends {DvtChartDataChangeHandler}
   *  @class DvtChartDataChangeFunnelSlice  Data change Handler for Funnel Slices.
   *  @constructor
   *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
   *  @param {Number} duration  the animation duration is seconds.
   */
  class DvtChartDataChangeFunnelSlice extends DvtChartDataChangeHandler {
    /**
     * @override
     */
    animateUpdate(handler, oldDC) {
      var obj = this._shape;

      var startState = oldDC._shape.getAnimParams();
      var endState = obj.getAnimParams();

      var startFill = oldDC._shape.getFill();
      var endFill = this._shape.getFill();

      if (dvt.ArrayUtils.equals(startState, endState) && startFill.equals(endFill))
        // if no change,
        return; // nothing to animate.

      // Initialize start state
      obj.setAnimParams(startState);

      // Create the animator for this slice update
      var nodePlayable = new dvt.CustomAnimation(obj.getCtx(), this, this._updateDuration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER_ARRAY, obj, obj.getAnimParams, obj.setAnimParams, endState);

      // TODO  this only works for slices without target values. Slices with target values are drawn within
      // DvtChartFunnelSlice, so wait until the animation code is collapsed to do that work.
      if (!startFill.equals(endFill)) {
        this._shape.setFill(startFill);
        nodePlayable
          .getAnimator()
          .addProp(dvt.Animator.TYPE_FILL, obj, obj.getFill, obj.setFill, endFill);
      }

      // TODO  this line of code makes no sense, since we never draw an indicator for funnel
      if (this._indicator) {
        nodePlayable.setOnEnd(this._onEndAnim, this);
      }

      handler.add(nodePlayable, 1); // create the playable
    }

    /**
     * @override
     */
    animateInsert(handler) {
      var obj = this._shape;

      var endState = obj.getAnimParams();
      var startState = endState.slice(0);
      startState[0] += startState[1] / 2;
      startState[1] = 0;
      startState[3] = 0; // start alpha

      obj.setAnimParams(startState); // set the start state
      var nodePlayable = new dvt.CustomAnimation(obj.getCtx(), this, this._insertDuration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER_ARRAY, obj, obj.getAnimParams, obj.setAnimParams, endState);

      handler.add(nodePlayable, 2); // create the playable
    }

    /**
     * @override
     */
    animateDelete(handler, delContainer) {
      var obj = this._shape;

      delContainer.setClipPath(null); // remove clipping
      delContainer.addChild(obj); // move from existing container to the delete container on top of the new chart.

      var startState = obj.getAnimParams();
      var endState = startState.slice(0);

      endState[0] += startState[1] / 2;
      endState[1] = 0;
      endState[3] = 0; // end alpha

      var nodePlayable = new dvt.CustomAnimation(obj.getCtx(), this, this._deleteDuration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER_ARRAY, obj, obj.getAnimParams, obj.setAnimParams, endState);

      handler.add(nodePlayable, 0); // create the playable
    }
  }

  /**
   *  Data change Handler for Line or Area (implements DvtChartDataChange).
   *  @extends {dvt.Obj}
   *  @class DvtChartDataChangeLineArea  Data change Handler for Line and Area.
   *  @constructor
   *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
   *  @param {number} duration  the animation duration is seconds.
   */
  class DvtChartDataChangeLineArea extends DvtChartDataChangeHandler {
    constructor(peer, duration) {
      super(peer, duration, '');
      this._context = this._shape.getCtx();
      this._chart = this._peer.getChart();
      this._animId += '/' + (this._shape.isArea() ? 'area' : 'line');
    }
    /**
     * Creates the update animation for this Line or Area. Insert/delete of
     * groups within an existing series is treated as a special case of animateUpdate.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be
     *                                          used to chain animations.
     * @param {DvtChartDataChangeLineArea} oldDC   The old node DC Handler to animate from.
     * @override
     */
    animateUpdate(handler, oldDC) {
      this._baseCoords = this._shape.getBaseCoords();
      this._coords = this._shape.getCoords();
      var isArea = this._shape.isArea();

      var oldChart = this._oldChart;
      var newChart = this._chart;
      var newSIdx = this._peer.getSeriesIndex();
      var oldSIdx = oldDC._peer.getSeriesIndex();
      var newGIdcs = this._shape.getCommonGroupIndices(oldDC._shape);
      var oldGIdcs = oldDC._shape.getCommonGroupIndices(this._shape);

      // Construct animation for the area base.
      var baseAnim;
      if (isArea) {
        var baseStartState = oldDC._getBaseAnimParams(this._shape);
        var baseEndState = this._getBaseAnimParams(oldDC._shape);
        DvtChartDataChangeLineArea._matchGroupIndices(baseStartState, baseEndState);
        if (!dvt.ArrayUtils.equals(baseStartState, baseEndState)) {
          this._setBaseAnimParams(baseStartState); // initialize the start state
          baseAnim = new dvt.CustomAnimation(this._context, this, this._updateDuration);
          baseAnim
            .getAnimator()
            .addProp(
              dvt.Animator.TYPE_NUMBER_ARRAY,
              this,
              this._getBaseAnimParams,
              this._setBaseAnimParams,
              baseEndState
            );
        }
      }

      // Construct animation for the line or the area top.
      var topAnim;
      var startState = oldDC._getAnimParams(this._shape);
      var endState = this._getAnimParams(oldDC._shape);
      DvtChartDataChangeLineArea._matchGroupIndices(startState, endState);
      if (!dvt.ArrayUtils.equals(startState, endState)) {
        this._setAnimParams(startState); // initialize the start state
        topAnim = new dvt.CustomAnimation(this._context, this, this._updateDuration);
        topAnim
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            this,
            this._getAnimParams,
            this._setAnimParams,
            endState
          );
      }

      // Create animate indicators if requested. If seriesType is lineWithArea, add indicators only to the line.
      var seriesType = DvtChartDataUtils.getSeriesType(this._peer.getChart(), newSIdx);
      if (
        DvtChartStyleUtils.getAnimIndicators(newChart) !== 'none' &&
        !(isArea && seriesType == 'lineWithArea')
      ) {
        var direction, indicator;
        for (var i = 0; i < newGIdcs.length; i++) {
          direction = DvtChartDataChangeUtils.getDirection(
            oldChart,
            oldSIdx,
            oldGIdcs[i],
            newChart,
            newSIdx,
            newGIdcs[i]
          );
          indicator = DvtChartDataChangeUtils.makeIndicator(
            oldChart,
            oldSIdx,
            oldGIdcs[i],
            newChart,
            newSIdx,
            newGIdcs[i]
          );
          if (indicator) this._shape.addIndicator(newGIdcs[i], direction, indicator);
        }
      }

      // Combine the top and base animation.
      if (baseAnim || topAnim) {
        var nodePlayable = new dvt.ParallelPlayable(this._context, baseAnim, topAnim);
        nodePlayable.setOnEnd(this._onAnimEnd, this);
        handler.add(nodePlayable, 1);
      }
    }

    /**
     * Creates the insert animation for this Line or Area.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     * @override
     */
    animateInsert(handler) {
      this._shape.setAlpha(0); // set alpha=0 so that the inserted object is hidden until the insert animation starts

      var nodePlayable = new dvt.AnimFadeIn(this._context, this._shape, this._insertDuration);
      handler.add(nodePlayable, 2);
    }

    /**
     * Creates the delete animation for this Line or Area
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to
     *                                          chain animations.
     * @param {dvt.Container} delContainer   The container to which the deleted objects should
     *                                      be moved for animation.
     * @override
     */
    animateDelete(handler, delContainer) {
      var nodePlayable;
      var seriesType = DvtChartDataUtils.getSeriesType(this._oldChart, this._peer.getSeriesIndex()); // get from old chart

      if (seriesType == 'area') {
        // For area chart, we need to add and fade out all of the areas (not just the deleted ones) to make sure that the
        // areas are in the correct z-order. Furthermore, the delContainer should be the areaContainer of the new chart
        // so that the deleted areas appear below the gridlines and other data items.
        var areaContainer = this._chart.__getAreaContainer(); // new chart's areaContainer
        this._deletedAreas = this._shape.getParent().getParent(); // the parent is the clipGroup, and the grandparent is the old chart's areaContainer
        if (areaContainer) areaContainer.addChild(this._deletedAreas);
        else return;
        nodePlayable = new dvt.AnimFadeOut(this._context, this._deletedAreas, this._deleteDuration);
        nodePlayable.setOnEnd(this._removeDeletedAreas, this);
        handler.add(nodePlayable, 0);
      } else {
        // Move from the old chart to the delete container on top of the new chart.
        delContainer.addChild(this._shape);
        nodePlayable = new dvt.AnimFadeOut(this._context, this._shape, this._deleteDuration);
        handler.add(nodePlayable, 0);
      }
    }

    /**
     * Removes the deleted areas at the end of delete animation.
     * @private
     */
    _removeDeletedAreas() {
      var areaContainer = this._chart.__getAreaContainer();
      if (areaContainer) areaContainer.removeChild(this._deletedAreas);
    }

    /**
     * Returns the animation params for the line or the area top.
     * @param {DvtChartLineArea} otherShape
     * @return {array} params
     * @private
     */
    _getAnimParams(otherShape) {
      return this._shape.getAnimParams(otherShape);
    }

    /**
     * Updates the animation params for the line or the area top.
     * @param {array} params
     * @private
     */
    _setAnimParams(params) {
      this._shape.setAnimParams(params);
    }

    /**
     * Returns the animation params for the area base.
     * @param {DvtChartLineArea} otherShape
     * @return {array} params
     * @private
     */
    _getBaseAnimParams(otherShape) {
      return this._shape.getBaseAnimParams(otherShape);
    }

    /**
     * Updates the animation params for the area base.
     * @param {array} params
     * @private
     */
    _setBaseAnimParams(params) {
      this._shape.setBaseAnimParams(params);
    }

    /**
     * Clean up at the end of update animation.
     * @private
     */
    _onAnimEnd() {
      this._shape.removeIndicators();
      this._shape.setCoords(this._coords, this._baseCoords);
    }

    /**
     * Sets the group indices of the startParams to be the group indices of the endParams.
     * Required because the group indices of the startParams is taken from the oldChart.
     * @param {array} startParams
     * @param {array} endParams
     * @private
     */
    static _matchGroupIndices(startParams, endParams) {
      // group index is the 4th, 8th, 12th... param
      for (var i = 3; i < startParams.length; i += 4) {
        startParams[i] = endParams[i];
      }
    }
  }

  /**
   *  Data change Handler for markers.
   *  @extends {DvtChartDataChangeHandler}
   *  @class DvtChartDataChangeMarker  Data change Handler for markers.
   *  @constructor
   *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
   *  @param {Number} duration  The animation duration is seconds.
   */
  class DvtChartDataChangeMarker extends DvtChartDataChangeHandler {
    /**
     * @override
     */
    animateUpdate(handler, oldDC) {
      var startRect = oldDC._shape.getCenterDimensions();
      var endRect = this._shape.getCenterDimensions();

      // Return if no change in the geometry
      if (endRect.equals(startRect)) return;

      // Initialize the start state
      this._shape.setCenterDimensions(startRect);

      // Create the animator for this node
      var nodePlayable = new dvt.CustomAnimation(this._shape.getCtx(), this, this._updateDuration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_RECTANGLE,
          this._shape,
          this._shape.getCenterDimensions,
          this._shape.setCenterDimensions,
          endRect
        );

      // If animation indicators required, and the value changed, add visual effect to marker.
      var chart = this._peer.getChart();
      if (
        this.isValueChange(oldDC) &&
        DvtChartStyleUtils.getAnimIndicators(chart) != 'none' &&
        DvtChartTypeUtils.isScatterBubble(chart)
      ) {
        // Use the old shape for the update color overlay
        var overlay = oldDC._shape;
        overlay.setAlpha(0.9);
        overlay.setClassName('oj-chart-animation-marker');
        overlay.setCenterDimensions(startRect);
        this._peer.getChart().getPlotArea().addChild(overlay);

        //  Move and fade the overlay
        nodePlayable
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_RECTANGLE,
            overlay,
            overlay.getCenterDimensions,
            overlay.setCenterDimensions,
            endRect
          );
        nodePlayable
          .getAnimator()
          .addProp(dvt.Animator.TYPE_NUMBER, overlay, overlay.getAlpha, overlay.setAlpha, 0);

        // Set end listener to remove the overlay
        this._overlay = overlay;
        nodePlayable.setOnEnd(this._onEndAnim, this);
      }

      handler.add(nodePlayable, 1);
    }

    /**
     * @override
     */
    animateInsert(handler) {
      this._shape.setAlpha(0);
      var nodePlayable = new dvt.AnimFadeIn(this._shape.getCtx(), this._shape, this._insertDuration);

      handler.add(nodePlayable, 2);
    }

    /**
     * @override
     */
    animateDelete(handler, delContainer) {
      delContainer.addChild(this._shape); // Move from the old chart to the delete
      // container on top of the new chart.

      var nodePlayable = new dvt.AnimFadeOut(this._shape.getCtx(), this._shape, this._deleteDuration);

      handler.add(nodePlayable, 0);
    }

    /**
     * Check if there is data change.
     * @param {DvtChartDataChangeMarker} oldDC    The old node state to animate from.
     * @return {boolean}  true if node data has changed.
     */
    isValueChange(oldDC) {
      var bRet = false;

      if (oldDC) {
        var oldSIdx = oldDC._peer.getSeriesIndex();
        var oldGIdx = oldDC._peer.getGroupIndex();
        var newSIdx = this._peer.getSeriesIndex();
        var newGIdx = this._peer.getGroupIndex();
        var oldData = oldDC._oldChart.getOptions();
        var newData = this._peer.getChart().getOptions();

        var oldX = oldData['series'][oldSIdx]['items'][oldGIdx]['x'];
        var oldY = oldData['series'][oldSIdx]['items'][oldGIdx]['y'];
        var oldZ = oldData['series'][oldSIdx]['items'][oldGIdx]['z'];
        var newX = newData['series'][newSIdx]['items'][newGIdx]['x'];
        var newY = newData['series'][newSIdx]['items'][newGIdx]['y'];
        var newZ = newData['series'][newSIdx]['items'][newGIdx]['z'];

        bRet = newX !== oldX || newY !== oldY || newZ !== oldZ;
      }

      return bRet;
    }

    /**
     * Remove update animation overlay
     * @private
     */
    _onEndAnim() {
      if (this._overlay) {
        this._peer.getChart().getPlotArea().removeChild(this._overlay);
        this._overlay = null;
      }
    }
  }

  /**
   *  Data change Handler for DvtChartPyramidSlice (implements DvtChartDataChange).
   *  @extends {DvtChartDataChangeHandler}
   *  @class DvtChartDataChangePyramidSlice  Data change Handler for Pyramid Slices.
   *  @constructor
   *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
   *  @param {Number} duration  the animation duration is seconds.
   */
  class DvtChartDataChangePyramidSlice extends DvtChartDataChangeHandler {
    /**
     * @override
     */
    animateUpdate(handler, oldDC) {
      var obj = this._shape;

      var startState = oldDC._shape.getAnimParams();
      var endState = obj.getAnimParams();

      var startFill = oldDC._shape.getPrimaryFill();
      var endFill = this._shape.getPrimaryFill();

      if (dvt.ArrayUtils.equals(startState, endState) && startFill.equals(endFill))
        // if no change,
        return; // nothing to animate.

      // Initialize start state
      obj.setAnimParams(startState);

      // Create the animator for this slice update
      var nodePlayable = new dvt.CustomAnimation(obj.getCtx(), this, this._updateDuration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER_ARRAY, obj, obj.getAnimParams, obj.setAnimParams, endState);

      if (!startFill.equals(endFill)) {
        this._shape.setFill(startFill);
        nodePlayable
          .getAnimator()
          .addProp(dvt.Animator.TYPE_FILL, obj, obj.getFill, obj.setFill, endFill);
      }

      handler.add(nodePlayable, 1); // create the playable
    }

    /**
     * @override
     */
    animateInsert(handler) {
      var obj = this._shape;

      var endState = obj.getAnimParams();
      var startState = endState.slice(0);
      startState[1] = 0;
      startState[2] = 0; // start alpha

      obj.setAnimParams(startState); // set the start state
      var nodePlayable = new dvt.CustomAnimation(obj.getCtx(), this, this._insertDuration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER_ARRAY, obj, obj.getAnimParams, obj.setAnimParams, endState);

      handler.add(nodePlayable, 2); // create the playable
    }

    /**
     * @override
     */
    animateDelete(handler, delContainer) {
      var obj = this._shape;

      delContainer.setClipPath(null); // remove clipping
      delContainer.addChild(obj); // move from existing container to the delete container on top of the new chart.

      var startState = obj.getAnimParams();
      var endState = startState.slice(0);

      endState[1] = 0;
      endState[2] = 0; // end alpha

      var nodePlayable = new dvt.CustomAnimation(obj.getCtx(), this, this._deleteDuration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER_ARRAY, obj, obj.getAnimParams, obj.setAnimParams, endState);
      handler.add(nodePlayable, 0); // create the playable
    }
  }

  /**
   *  Data change handler for range markers (implements DvtChartDataChange).
   *  @extends {DvtChartDataChangeHandler}
   *  @class DvtChartDataChangeRangeMarker  Data change Handler for range markers.
   *  @constructor
   *  @param {DvtChartObjPeer} peer The chart object peer for the shape to be animated.
   *  @param {number} duration  the animation duration is seconds.
   */
  class DvtChartDataChangeRangeMarker extends DvtChartDataChangeHandler {
    /**
     * @override
     */
    animateInsert(handler) {
      this._shape.setAlpha(0);
      var nodePlayable = new dvt.AnimFadeIn(this._shape.getCtx(), this._shape, this._insertDuration);

      handler.add(nodePlayable, 2);
    }

    /**
     * @override
     */
    animateDelete(handler, delContainer) {
      delContainer.addChild(this._shape); // Move from the old chart to the delete
      // container on top of the new chart.

      var nodePlayable = new dvt.AnimFadeOut(this._shape.getCtx(), this._shape, this._deleteDuration);

      handler.add(nodePlayable, 0);
    }

    /**
     * @override
     */
    animateUpdate(handler, oldDC) {
      var start = oldDC._shape.getAnimParams();
      var end = this._shape.getAnimParams();

      // Initialize the start state
      this._shape.setAnimParams(start);

      // Create the animator for this node
      var nodePlayable = new dvt.CustomAnimation(this._shape.getCtx(), this, this._updateDuration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this._shape,
          this._shape.getAnimParams,
          this._shape.setAnimParams,
          end
        );

      handler.add(nodePlayable, 1);
    }
  }

  /**
   * A selectable polygon displayable.
   * @class DvtChartSelectableRectangularPolygon
   * @extends {dvt.Polygon}
   * @constructor
   * @param {dvt.Context} context
   * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
   * @param {string} id The optional id for the corresponding DOM element.
   */
  class DvtChartSelectableRectangularPolygon extends dvt.Polygon {
    constructor(context, arPoints, id, doNotRender) {
      let coords, _x1, _x2, _y1, _y2;
      if (arPoints) {
        _x1 = Math.min(arPoints[0], arPoints[4]);
        _x2 = Math.max(arPoints[0], arPoints[4]);
        _y1 = Math.min(arPoints[1], arPoints[5]);
        _y2 = Math.max(arPoints[1], arPoints[5]);
        coords = [_x1, _y1, _x2, _y1, _x2, _y2, _x1, _y2];
      }

      super(context, coords, id, doNotRender);
      this._x1 = _x1;
      this._x2 = _x2;
      this._y1 = _y1;
      this._y2 = _y2;
    }

    /**
     * Specifies the colors needed to generate the selection effect.
     * @param {dvt.Fill} fill
     * @param {dvt.Stroke} stroke
     * @param {string} dataColor The color of the data.
     * @param {string} innerColor The color of the inner selection border.
     * @param {string} outerColor The color of the outer selection border.
     * @param {string} className The className of the shape.
     * @param {object} style The style of the shape.
     */
    setStyleProperties(fill, stroke, dataColor, innerColor, outerColor, className, style) {
      this._fill = fill;
      // Save original stroke style to get reapplied in _showNestedBorders. Cannot use this._stroke, as it gets overwritten during select and hover
      this._borderStroke = stroke;
      this._hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(dataColor);
      this._innerColor = innerColor;
      this._outerColor = outerColor;
      this._shapeClassName = className;
      this._shapeStyle = style;
      this.setStyle(style).setClassName(className);

      // Apply the fill and stroke
      this.setFill(fill);
      if (stroke) this.setStroke(stroke);
    }

    /**
     * To allow the updating of the size of the child shapes during animation
     * @param {array} ar The array of points.
     */
    setAnimParams(ar) {
      this._x1 = Math.min(ar[0], ar[4]);
      this._x2 = Math.max(ar[0], ar[4]);
      this._y1 = Math.min(ar[1], ar[5]);
      this._y2 = Math.max(ar[1], ar[5]);
      this.setPoints(ar);
      this._initializeSelectionEffects();
    }

    /**
     * @override
     */
    showHoverEffect() {
      if (this.IsShowingHoverEffect) return;

      this.IsShowingHoverEffect = true;
      if (this.getCtx().getThemeBehavior() === 'redwood') {
        if (!this.isSelected()) {
          var hoverColor = this.getFill().getColor();
          this._showNestedBorders(hoverColor, this._innerColor);
        }
      } else {
        this._showNestedBorders(this._hoverColor, this._innerColor);
      }
    }

    /**
     * @override
     */
    hideHoverEffect() {
      if (!this.IsShowingHoverEffect) return;

      this.IsShowingHoverEffect = false;
      if (this.getCtx().getThemeBehavior() === 'redwood') {
        if (!this.isSelected()) {
          this._showNestedBorders();
        }
      } else {
        if (this.isSelected()) this._showNestedBorders(this._outerColor, this._innerColor);
        else this._showNestedBorders();
      }
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this.IsSelected == selected) return;

      this.IsSelected = selected;
      if (this.getCtx().getThemeBehavior() === 'redwood') {
        var hoverColor = this.getPrimaryFill().getColor();
        if (this.isSelected()) {
          this._showNestedBorders(this._outerColor, this._innerColor);
        } else {
          if (this.isHoverEffectShown()) this._showNestedBorders(hoverColor, this._innerColor);
          else this._showNestedBorders();
        }
      } else {
        if (this.isHoverEffectShown()) this._showNestedBorders(this._hoverColor, this._innerColor);
        else if (this.isSelected()) this._showNestedBorders(this._outerColor, this._innerColor);
        else this._showNestedBorders();
      }
    }

    /**
     * @override
     */
    UpdateSelectionEffect() {
      // noop: Selection effects fully managed by this class
    }

    /**
     * Returns the primary dvt.Fill for this bar. Used for animation, since getFill may return the fill of the selection
     * shapes.
     * @return {dvt.Fill}
     */
    getPrimaryFill() {
      return this._fill;
    }

    /**
     * Helper function that creates and adds the shapes used for displaying hover and selection effects. Should only be
     * called on hover or select operations, since it assumes that the fill, stroke, and shape size are already determined.
     * @private
     */
    _initializeSelectionEffects() {
      // Calculate the geometry of the shapes used for the selection effects
      var outerBorderWidth = this.isSelected()
        ? DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH
        : DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH_HOVER;
      var outerChildPoints = this._createPointsArray(outerBorderWidth);
      var innerChildPoints = this._createPointsArray(
        outerBorderWidth + DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
      );

      // Just update the geometries if already initialized
      if (this.OuterChild) {
        this.OuterChild.setPoints(outerChildPoints);
        this.InnerChild.setPoints(innerChildPoints);
        return;
      }

      this.OuterChild = new dvt.Polygon(this.getCtx(), outerChildPoints);
      this.OuterChild.setInvisibleFill();
      this.OuterChild.setMouseEnabled(true);
      this.addChild(this.OuterChild);

      this.InnerChild = new dvt.Polygon(this.getCtx(), innerChildPoints);
      this.InnerChild.setInvisibleFill();
      this.InnerChild.setMouseEnabled(true);
      this.addChild(this.InnerChild);
    }

    /**
     * Helper function to apply border colors for hover and selection.
     * @param {string=} outerBorderColor
     * @param {string=} innerBorderColor
     * @private
     */
    _showNestedBorders(outerBorderColor, innerBorderColor) {
      // Ensure that selection and hover shapes are created
      this._initializeSelectionEffects();

      // Modify the shapes based on which borders should be shown
      if (innerBorderColor) {
        this.setSolidFill(outerBorderColor);
        this.setStroke(null);
        this.setClassName().setStyle();

        this.OuterChild.setSolidFill(innerBorderColor);
        this.OuterChild.setClassName().setStyle();

        this.InnerChild.setFill(this._fill);
        this.InnerChild.setClassName(this._shapeClassName).setStyle(this._shapeStyle);
      } else if (outerBorderColor) {
        this.setSolidFill(outerBorderColor);
        this.setStroke(null);
        this.setClassName().setStyle();

        this.OuterChild.setFill(this._fill);
        this.OuterChild.setClassName(this._shapeClassName).setStyle(this._shapeStyle);

        this.InnerChild.setInvisibleFill();
        this.InnerChild.setClassName().setStyle();
      } else {
        this.setFill(this._fill);
        this.setStroke(this._borderStroke);
        this.setClassName(this._shapeClassName).setStyle(this._shapeStyle);

        this.OuterChild.setInvisibleFill();
        this.OuterChild.setClassName().setStyle();

        this.InnerChild.setInvisibleFill();
        this.InnerChild.setClassName().setStyle();
      }
    }

    /**
     * Returns the points array for the polygon used to render the polygon, with an inset to show nested border effects.
     * @param {number} inset The number of pixels to inset the polygon.  Defaults to 0.
     * @return {array} The list of points for the polygon
     * @private
     */
    _createPointsArray(inset) {
      var x1 = this._x1 + inset;
      var x2 = this._x2 - inset;
      var y1 = this._y1 + inset;
      var y2 = this._y2 - inset;
      return [x1, y1, x2, y1, x2, y2, x1, y2];
    }
  }

  /** @const */
  DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH = 2;

  /** @const */
  DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH_HOVER = 1.25;

  /** @const */
  DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH = 1;

  /**
   *  A selectable bar for charting.
   *  @class DvtChartBar
   *  @extends {dvt.Polygon}
   *  @constructor
   *  @param {Chart} chart
   *  @param {number} axisCoord The location of the axis line.
   *  @param {number} baselineCoord The location from which the bar grows.
   *  @param {number} endCoord The location where the bar length ends.
   *  @param {number} x1 The left coord of a vertical bar, or the top of a horizontal bar.
   *  @param {number} x2 The right coord of a vertical bar, or the bottom of a horizontal bar.
   *  @param {boolean} doNotRender Flag to indicate that this shape is only used as a property bag, so the DOM elem shouldn't be rendered.
   */
  class DvtChartBar extends DvtChartSelectableRectangularPolygon {
    constructor(chart, axisCoord, baselineCoord, endCoord, x1, x2, doNotRender) {
      super(chart.getCtx(), null, null, doNotRender);
      /** @private @const */
      this._MAX_GAP_SIZE = 2;

      /** @private @const */
      this._MIN_BAR_LENGTH_FOR_GAPS = 5;

      /** @private @const */
      this._INDICATOR_OFFSET = 8;

      /** @private @const */
      this._MIN_BAR_WIDTH_FOR_GAPS_PIXEL_HINTING = 15;

      this._bHoriz = DvtChartTypeUtils.isHorizontal(chart);
      this._bStacked = DvtChartDataUtils.isStacked(chart);
      this._barGapRatio = DvtChartGroupUtils.getBarGapRatio(chart);
      this._dataItemGaps = DvtChartStyleUtils.getDataItemGaps(chart);
      this._axisCoord = axisCoord;
      this._doNotRender = !!doNotRender;

      // Calculate the points array and apply to the polygon
      this._setBarCoords(baselineCoord, endCoord, x1, x2, true);
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this.IsSelected == selected) return;

      this.IsSelected = selected;
      var hoverColor;
      if (this.getCtx().getThemeBehavior() === 'redwood') {
        var hoverColor = this.getPrimaryFill().getColor();
      } else {
        var hoverColor = this._hoverColor;
      }

      if (this.isSelected()) {
        // Remove the gaps from the sides of the bar per UX spec
        this._tempX1 = this._x1;
        this._tempX2 = this._x2;
        this._tempBaselineCoord = this._baselineCoord;
        this._x1 = this._origX1;
        this._x2 = this._origX2;
        this._baselineCoord = this._origBaselineCoord;
        this.setPoints(this._createPointsArray());
        if (this.getCtx().getThemeBehavior() === 'redwood') {
          this._showNestedBorders(this._outerColor, this._innerColor);
        } else {
          this._showNestedBorders(
            this.isHoverEffectShown() ? hoverColor : this._outerColor,
            this._innerColor
          );
        }
      } else {
        // Restore the gaps from the sides of the bar per UX spec
        this._x1 = this._tempX1;
        this._x2 = this._tempX2;
        this._baselineCoord = this._tempBaselineCoord;
        this.setPoints(this._createPointsArray());
        if (this.getCtx().getThemeBehavior() === 'redwood') {
          if (this.isHoverEffectShown()) this._showNestedBorders(hoverColor, this._innerColor);
          else this._showNestedBorders(null);
        } else this._showNestedBorders(this.isHoverEffectShown() ? hoverColor : null);
      }
    }

    /**
     * Returns the layout parameters for the current animation frame.
     * @param {boolean=} bFlip True if the result should be flipped for horizontal/vertical orientation change.
     * @return {array} The array of layout parameters.
     */
    getAnimParams(bFlip) {
      if (bFlip) {
        if (this._bHoriz)
          // flipping to vertical
          return [this._x2, this._x1, this._baselineCoord, this._endCoord];
        // flipping to horizontal
        else return [this._x1, this._x2, this._endCoord, this._baselineCoord];
      } else return [this._baselineCoord, this._endCoord, this._x1, this._x2];
    }

    /**
     * Sets the layout parameters for the current animation frame.
     * @param {array} params The array of layout parameters.
     * @param {dvt.Displayable=} indicator The animation indicator, whose geometry is centered at (0,0).
     */
    setAnimParams(params, indicator) {
      // Set bar coords but don't adjust for gaps, since they've already been factored in.
      this._setBarCoords(params[0], params[1], params[2], params[3], false);

      // Update animation indicator if present.
      if (indicator) {
        var indicatorPosition = this.getIndicatorPos();
        indicator.setTranslate(indicatorPosition.x, indicatorPosition.y);
        indicator.setAlpha(1);

        // Reparent to keep indicator on top
        indicator.getParent().addChild(indicator);
      }
    }

    /**
     * Returns a dvt.Playable containing the animation of the bar to its initial data value.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable} A playable for the initial bar animation.
     */
    getDisplayAnim(duration) {
      // Current state is the end state
      var endState = this.getAnimParams();

      // Initialize the start state. To grow the bar, just set the end coord to the axis coord.
      this.setAnimParams([this._axisCoord, this._axisCoord, this._x1, this._x2]);

      // Create and return the playable
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.getAnimParams,
          this.setAnimParams,
          endState
        );
      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the animation to delete the bar.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getDeleteAnim(duration) {
      // End state is for the bar length to shrink to 0
      var endState = [this._baselineCoord, this._baselineCoord, this._x1, this._x2];

      // Create and return the playable
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.getAnimParams,
          this.setAnimParams,
          endState
        );
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 0);
      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the insert animation of the bar.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getInsertAnim(duration) {
      // Initialize the alpha to fade in the bar
      this.setAlpha(0);

      // Create the playable
      var nodePlayable = this.getDisplayAnim(duration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 1);
      return nodePlayable;
    }

    /**
     * Returns the position where the value change indicator should be displayed.
     * @return {dvt.Point}
     */
    getIndicatorPos() {
      var widthCoord = (this._x1 + this._x2) / 2;
      var x, y;
      if (this._bStacked) {
        // Center the indicator within the stacked bar
        var midLength = (this._endCoord + this._baselineCoord) / 2;
        x = this._bHoriz ? midLength : widthCoord;
        y = this._bHoriz ? widthCoord : midLength;
      } else {
        var lengthCoord =
          this._endCoord >= this._baselineCoord
            ? this._endCoord + this._INDICATOR_OFFSET
            : this._endCoord - this._INDICATOR_OFFSET;
        x = this._bHoriz ? lengthCoord : widthCoord;
        y = this._bHoriz ? widthCoord : lengthCoord;
      }

      return new dvt.Point(x, y);
    }

    /**
     * Stores the point coords defining the bar.
     * @param {number} baselineCoord The location from which the bar grows.
     * @param {number} endCoord The location where the bar length ends.
     * @param {number} x1 The left coord of a vertical bar, or the top of a horizontal bar.
     * @param {number} x2 The right coord of a vertical bar, or the bottom of a horizontal bar.
     * @param {boolean} bAdjustForGaps True if the specified coordinate should be adjusted to produce gaps.
     * @private
     */
    _setBarCoords(baselineCoord, endCoord, x1, x2, bAdjustForGaps) {
      // Store the geometry values
      this._baselineCoord = baselineCoord;
      this._endCoord = endCoord;
      this._x1 = x1;
      this._x2 = x2;

      // Bar width has to be at least 1px to prevent disappearing bars
      var barWidth = this._x2 - this._x1;
      if (barWidth < 1) {
        this._x1 = Math.floor(this._x1);
        this._x2 = this._x1 + 1;
        barWidth = 1;
      }

      // Store the values before the gaps are applied
      this._origX1 = this._x1;
      this._origX2 = this._x2;
      this._origBaselineCoord = this._baselineCoord;
      this._origSize = this._x2 - this._x1;

      // If data item gaps enabled, add gaps between bars.
      if (this._dataItemGaps > 0 && bAdjustForGaps && !this.isSelected()) {
        // Note: The gap sizes were found via experimentation and we may need to tweak them for browser updates. Firefox
        // vertical pixel hinting behavior requires double gaps.
        var gapSize = Math.ceil(this._MAX_GAP_SIZE * this._dataItemGaps);
        var barLength = Math.abs(this._baselineCoord - this._endCoord);
        var bStartsAtBaseline = this._axisCoord == this._baselineCoord;

        // Gaps between bars in stack
        if (barLength >= this._MIN_BAR_LENGTH_FOR_GAPS && this._bStacked && !bStartsAtBaseline)
          this._baselineCoord += this._endCoord > this._baselineCoord ? gapSize : -gapSize;

        // Gaps between bars in cluster
        if (barWidth >= DvtChartBar._MIN_BAR_WIDTH_FOR_GAPS) {
          if (
            dvt.Agent.getDevicePixelRatio() == 1 &&
            this._barGapRatio > 0 &&
            barWidth > this._MIN_BAR_WIDTH_FOR_GAPS_PIXEL_HINTING
          ) {
            // If devicePixelRatio is 1, we need to be extremely precise since anti-aliasing must be disabled for correct
            // gaps. We can only do this for barGapRatio > 0, as otherwise positioning is more important than crispness.

            // Don't do this for FF though, since it does pixel hinting incorrectly.
            if (dvt.Agent.browser !== 'firefox' && !this._doNotRender) this.setPixelHinting(true);

            // Round the coords for crisp looking bars
            this._x1 = Math.round(this._x1);
            this._x2 = Math.round(this._x2);

            // Update to use the rounded coords
            this._origX1 = this._x1;
            this._origX2 = this._x2;

            // Apply the gap
            this._x2 -= gapSize;
          } else {
            // Browser zoom or retina display.  Allow anti-aliasing to do the work.
            this._x1 += gapSize / 2;
            this._x2 -= gapSize / 2;
          }

          this._origSize -= gapSize;
        }
      }

      if (this._doNotRender) return;

      // Calculate the points array for the outer shape
      var points = this._createPointsArray();
      this.setPoints(points);

      // If the inner shapes are already defined, update them as well
      if (this.OuterChild)
        this.OuterChild.setPoints(
          this._createPointsArray(DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH)
        );

      if (this.InnerChild)
        this.InnerChild.setPoints(
          this._createPointsArray(
            DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH +
              DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
          )
        );
    }

    /**
     * Returns the points array for the polygon used to render the bar. An optional inset can be provided to show nested
     * border effects.
     * @param {number=} inset The number of pixels to inset the polygon.  Defaults to 0.
     * @return {array}
     * @private
     */
    _createPointsArray(inset) {
      var baselineCoord = this._baselineCoord;
      var endCoord = this._endCoord;
      var x1 = this._x1;
      var x2 = this._x2;

      // Check the inset if specified
      if (inset > 0) {
        // Ensure there's enough space for the inset
        if (Math.abs(x1 - x2) < 2 * inset || Math.abs(baselineCoord - endCoord) < 2 * inset)
          return [];

        // x1 is always less than x2
        x1 += inset;
        x2 -= inset;

        // Relationship between baseline and endCoord aren't so static
        if (endCoord < baselineCoord) {
          baselineCoord -= inset;
          endCoord += inset;
        } else {
          baselineCoord += inset;
          endCoord -= inset;
        }
      }

      if (this._bHoriz) return [endCoord, x1, endCoord, x2, baselineCoord, x2, baselineCoord, x1];
      else return [x1, endCoord, x2, endCoord, x2, baselineCoord, x1, baselineCoord];
    }

    /**
     * Returns the bounding box of the shape
     * @return {dvt.Rectangle} bbox
     */
    getBoundingBox() {
      var x = Math.min(this._x2, this._x1);
      var y = Math.min(this._endCoord, this._baselineCoord);
      var w = Math.abs(this._x2 - this._x1);
      var h = Math.abs(this._endCoord - this._baselineCoord);

      if (this._bHoriz) return new dvt.Rectangle(y, x, h, w);
      else return new dvt.Rectangle(x, y, w, h);
    }

    /**
     * Returns the non rounded width(horizontal) or height(vertical) of the bar
     * @return {number}
     */
    getOriginalBarSize() {
      return this._origSize;
    }

    /**
     * Returns the bounds of the displayable relative to the target coordinate space.  If the target
     * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
     * into account any child displayables.
     * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
     * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
     */
    getDimensionsSelf(targetCoordinateSpace) {
      // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
      //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
      return this.ConvertCoordSpaceRect(this.getBoundingBox(), targetCoordinateSpace);
    }
  }

  /** @private @const */
  DvtChartBar._MIN_BAR_WIDTH_FOR_GAPS = 5;

  /**
   * Displayable for box and whisker shape (box plot).
   * @extends {dvt.Container}
   * @param {Chart} chart
   * @param {number} xCoord
   * @param {number} boxWidth
   * @param {number} lowCoord
   * @param {number} q1Coord
   * @param {number} q2Coord
   * @param {number} q3Coord
   * @param {number} highCoord
   * @param {object} styleOptions
   * @class
   * @constructor
   */
  class DvtChartBoxAndWhisker extends dvt.Shape {
    constructor(
      chart,
      xCoord,
      boxWidth,
      lowCoord,
      q1Coord,
      q2Coord,
      q3Coord,
      highCoord,
      styleOptions
    ) {
      super(chart.getCtx());
      this._chart = chart;
      this._bHoriz = DvtChartTypeUtils.isHorizontal(chart);

      this._styleOptions = styleOptions;
      this._innerColor = DvtChartStyleUtils.getSelectedInnerColor(this._chart);
      this._outerColor = DvtChartStyleUtils.getSelectedOuterColor(this._chart);
      this._hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(this._styleOptions['_color']);

      var x1 = xCoord - boxWidth / 2;
      var x2 = xCoord + boxWidth / 2;
      if (
        DvtChartStyleUtils.getDataItemGaps(chart) > 0 &&
        boxWidth > DvtChartBar._MIN_BAR_WIDTH_FOR_GAPS
      )
        x2--;

      this._render(x1, x2, lowCoord, q1Coord, q2Coord, q3Coord, highCoord);
    }

    /**
     * Renders the box and whisker shapes.
     * @param {number} x1
     * @param {number} x2
     * @param {number} low
     * @param {number} q1
     * @param {number} q2
     * @param {number} q3
     * @param {number} high
     * @private
     */
    _render(x1, x2, low, q1, q2, q3, high) {
      this._cleanUp();
      var context = this.getCtx();

      // Round the coords to produce crisp edges
      this._x1 = Math.round(x1);
      this._x2 = Math.round(x2);
      this._low = Math.round(low);
      this._q1 = Math.round(q1);
      this._q2 = Math.round(q2);
      this._q3 = Math.round(q3);
      this._high = Math.round(high);

      // Ensure that the whisker ends are wider than the box and that the length is an odd integer
      var boxWidth = x2 - x1;
      var whiskerEndLength = DvtChartStyleUtils.getSizeInPixels(
        this._styleOptions['whiskerEndLength'],
        boxWidth
      );
      whiskerEndLength = Math.min(boxWidth, whiskerEndLength);
      whiskerEndLength = Math.floor((whiskerEndLength - 1) / 2) * 2 + 1;

      // Create the whiskers
      var whiskerX = Math.floor((x1 + x2) / 2) + 0.5;
      var whiskerX1 = whiskerX - Math.floor(whiskerEndLength / 2) - 0.5;
      var whiskerX2 = whiskerX + Math.floor(whiskerEndLength / 2) + 0.5;

      this._drawLine(whiskerX, this._low, whiskerX, this._high, 'whisker');
      this._drawLine(whiskerX1, this._low, whiskerX2, this._low, 'whiskerEnd');
      this._drawLine(whiskerX1, this._high, whiskerX2, this._high, 'whiskerEnd');

      // Create the box shape on top of whiskers
      this._q2Box = new dvt.Polygon(context, this._createQ2PointsArray(0));
      var q2Fill = DvtChartSeriesEffectUtils.getRectangleFill(
        this._chart,
        this._styleOptions['q2Color'],
        this._styleOptions['_q2Pattern'],
        boxWidth
      );
      this._q2Box.setFill(q2Fill);
      this._applyCustomStyle(this._q2Box, 'q2');
      this.addChild(this._q2Box);

      this._q3Box = new dvt.Polygon(context, this._createQ3PointsArray(0));
      var q3Fill = DvtChartSeriesEffectUtils.getRectangleFill(
        this._chart,
        this._styleOptions['q3Color'],
        this._styleOptions['_q3Pattern'],
        boxWidth
      );
      this._q3Box.setFill(q3Fill);
      this._applyCustomStyle(this._q3Box, 'q3');
      this.addChild(this._q3Box);

      // Create the median line
      this._drawMedianLine(0);

      // Create box border
      this._borderColor = this._styleOptions['borderColor'];
      if (this._borderColor) {
        this._borderWidth = this._styleOptions['borderWidth'];
        this._drawBorders(this._borderColor, this._borderWidth);
      }

      // Reapply selection effect (during animation)
      if (this.IsSelected) {
        this.IsSelected = false; // force selection effect to be reapplied
        this.setSelected(true);
      }
    }

    /**
     * @override
     */
    showHoverEffect() {
      if (this.IsShowingHoverEffect) return;

      this.IsShowingHoverEffect = true;

      if (this.isSelected()) {
        if (this.getCtx().getThemeBehavior() !== 'redwood')
          this._drawBorders(
            this._hoverColor,
            DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH,
            this._innerColor,
            DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
          );
      } else {
        this._drawBorders(
          this._hoverColor,
          DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH_HOVER,
          this._innerColor,
          DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
        );
      }
    }

    /**
     * @override
     */
    hideHoverEffect() {
      if (!this.IsShowingHoverEffect) return;

      this.IsShowingHoverEffect = false;

      if (this.isSelected())
        this._drawBorders(
          this._outerColor,
          DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH,
          this._innerColor,
          DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
        );
      else this._drawBorders(this._borderColor, this._borderWidth); // set original border
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this.IsSelected == selected) return;

      this.IsSelected = selected;

      if (this.isHoverEffectShown()) {
        if (selected) {
          if (this.getCtx().getThemeBehavior() === 'redwood') {
            this._drawBorders(
              this._outerColor,
              DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH,
              this._innerColor,
              DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
            );
          } else
            this._drawBorders(
              this._hoverColor,
              DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH,
              this._innerColor,
              DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
            );
        } else {
          this._drawBorders(
            this._hoverColor,
            DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH_HOVER,
            this._innerColor,
            DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
          );
        }
      } else {
        if (selected)
          this._drawBorders(
            this._outerColor,
            DvtChartSelectableRectangularPolygon.OUTER_BORDER_WIDTH,
            this._innerColor,
            DvtChartSelectableRectangularPolygon.INNER_BORDER_WIDTH
          );
        else this._drawBorders(this._hoverColor, this._borderWidth); // set original border
      }
    }

    /**
     * @override
     */
    UpdateSelectionEffect() {
      // noop: Selection effects fully managed by this class
    }

    /**
     * Returns a dvt.Playable containing the display animation for the shape.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable} A playable for the display animation.
     */
    getDisplayAnim(duration) {
      return this.getInsertAnim(duration);
    }

    /**
     * Returns a dvt.Playable containing the animation to delete this displayable.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getDeleteAnim(duration) {
      // Animation: Shink into the median & fade out.
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);

      var endState = [this._x1, this._x2, this._q2, this._q2, this._q2, this._q2, this._q2];
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this._getAnimParams,
          this._setAnimParams,
          endState
        );

      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 0);

      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the insert animation for this displayable.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getInsertAnim(duration) {
      // Animation: Grow from the median.
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);

      var endState = this._getAnimParams();
      this._setAnimParams([this._x1, this._x2, this._q2, this._q2, this._q2, this._q2, this._q2]);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this._getAnimParams,
          this._setAnimParams,
          endState
        );

      this.setAlpha(0);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 1);

      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the update animation for this displayable.
     * @param {number} duration The duration of the animation in seconds.
     * @param {DvtChartBoxAndWhisker} oldShape The old shape to animate from.
     * @return {dvt.Playable}
     */
    getUpdateAnim(duration, oldShape) {
      // Animation: Transition shape and color.
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);

      var startQ2Fill = oldShape._getQ2Fill();
      var endQ2Fill = this._getQ2Fill();
      if (!startQ2Fill.equals(endQ2Fill)) {
        this._setQ2Fill(startQ2Fill);
        nodePlayable
          .getAnimator()
          .addProp(dvt.Animator.TYPE_FILL, this, this._getQ2Fill, this._setQ2Fill, endQ2Fill);
      }

      var startQ3Fill = oldShape._getQ3Fill();
      var endQ3Fill = this._getQ3Fill();
      if (!startQ3Fill.equals(endQ3Fill)) {
        this._setQ3Fill(startQ3Fill);
        nodePlayable
          .getAnimator()
          .addProp(dvt.Animator.TYPE_FILL, this, this._getQ3Fill, this._setQ3Fill, endQ3Fill);
      }

      var endState = this._getAnimParams();
      this._setAnimParams(oldShape._getAnimParams());
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this._getAnimParams,
          this._setAnimParams,
          endState
        );

      return nodePlayable;
    }

    /**
     * Get animation params.
     * @return {array} The array of params.
     * @private
     */
    _getAnimParams() {
      return [this._x1, this._x2, this._low, this._q1, this._q2, this._q3, this._high];
    }

    /**
     * Set animation params.
     * @param {array} ar The array of params.
     * @private
     */
    _setAnimParams(ar) {
      this._render(ar[0], ar[1], ar[2], ar[3], ar[4], ar[5], ar[6]);
    }

    /**
     * Get the Q2 box fill for animation.
     * @return {dvt.Fill}
     * @private
     */
    _getQ2Fill() {
      // Return from the _styleOptions bc it's the source of truth.
      // Can't rely on the shape fill because the shape is recreated at each _render.
      return new dvt.SolidFill(this._styleOptions['q2Color']);
    }

    /**
     * Set the Q2 box fill for animation.
     * @param {dvt.Fill} fill
     * @private
     */
    _setQ2Fill(fill) {
      // Set the _styleOptions bc it's the source of truth. The color will be updated on _render.
      this._styleOptions['q2Color'] = fill.getColor();
    }

    /**
     * Get the Q3 box fill for animation.
     * @return {dvt.Fill}
     * @private
     */
    _getQ3Fill() {
      // Return from the _styleOptions bc it's the source of truth.
      // Can't rely on the shape fill because the shape is recreated at each _render.
      return new dvt.SolidFill(this._styleOptions['q3Color']);
    }

    /**
     * Set the Q3 box fill for animation.
     * @param {dvt.Fill} fill
     * @private
     */
    _setQ3Fill(fill) {
      // Set the _styleOptions bc it's the source of truth. The color will be updated on _render.
      this._styleOptions['q3Color'] = fill.getColor();
    }

    /**
     * Draws a line with the specified coords.
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {string} prefix The _styleOptions prefix
     * @return {dvt.Line} The line shape.
     * @private
     */
    _drawLine(x1, y1, x2, y2, prefix) {
      var line = this._bHoriz
        ? new dvt.Line(this.getCtx(), y1, x1, y2, x2)
        : new dvt.Line(this.getCtx(), x1, y1, x2, y2);
      this._applyCustomStyle(line, prefix);
      line.setPixelHinting(true);
      this.addChild(line);
      return line;
    }

    /**
     * Draws the median line.
     * @param {number} inset The number of pixels to inset the median line.
     * @private
     */
    _drawMedianLine(inset) {
      if (!this._medianLine) {
        var line = new dvt.Line(this.getCtx(), 0, 0, 0, 0);
        this._applyCustomStyle(line, 'median');
        line.setPixelHinting(true);
        this.addChild(line);
        this._medianLine = line;
      }

      var x1 = this._x1 + inset;
      var x2 = this._x2 - inset;
      var q2 = this._q2;

      if (this._bHoriz) {
        this._medianLine.setX1(q2);
        this._medianLine.setX2(q2);
        this._medianLine.setY1(x1);
        this._medianLine.setY2(x2);
      } else {
        this._medianLine.setY1(q2);
        this._medianLine.setY2(q2);
        this._medianLine.setX1(x1);
        this._medianLine.setX2(x2);
      }
    }

    /**
     * Helper function to apply up to two border colors for the shape.
     * @param {string=} outerBorderColor
     * @param {number=} outerBorderWidth
     * @param {string=} innerBorderColor
     * @param {number=} innerBorderWidth
     * @private
     */
    _drawBorders(outerBorderColor, outerBorderWidth, innerBorderColor, innerBorderWidth) {
      // Initialize the border shapes if this is called the first time
      if (!this._outerBorderShape) {
        var childIndex = this.getChildIndex(this._q2Box);

        this._innerBorderShape = new dvt.Polygon(this.getCtx());
        this._innerBorderShape.setInvisibleFill();
        this.addChildAt(this._innerBorderShape, childIndex);

        this._outerBorderShape = new dvt.Polygon(this.getCtx());
        this._outerBorderShape.setInvisibleFill();
        this.addChildAt(this._outerBorderShape, childIndex);
      }

      var boxInset = 0;
      if (outerBorderWidth) {
        this._outerBorderShape.setPoints(this._createBoxPointsArray(0));
        this._outerBorderShape.setSolidFill(outerBorderColor);
        boxInset += outerBorderWidth;

        if (innerBorderWidth) {
          this._innerBorderShape.setPoints(this._createBoxPointsArray(outerBorderWidth));
          this._innerBorderShape.setSolidFill(innerBorderColor);
          boxInset += innerBorderWidth;
        } else this._innerBorderShape.setInvisibleFill();
      } else {
        this._outerBorderShape.setInvisibleFill();
        this._innerBorderShape.setInvisibleFill();
      }

      this._q2Box.setPoints(this._createQ2PointsArray(boxInset));
      this._q3Box.setPoints(this._createQ3PointsArray(boxInset));
      this._drawMedianLine(boxInset);
    }

    /**
     * Returns the points array for the polygon used to render the shape covering the entire box.
     * @param {number} inset The number of pixels to inset the polygon.
     * @return {Array}
     * @private
     */
    _createBoxPointsArray(inset) {
      var x1 = this._x1 + inset;
      var x2 = this._x2 - inset;

      var q1, q3;
      if (this._q1 < this._q3) {
        q1 = this._q1 + inset;
        q3 = this._q3 - inset;
      } else {
        q1 = this._q1 - inset;
        q3 = this._q3 + inset;
      }

      return this._createPointsArray(x1, x2, q1, q3);
    }

    /**
     * Returns the points array for the polygon used to render the shape covering the q2-q3 segment of the box.
     * @param {number} inset The number of pixels to inset the polygon.
     * @return {Array}
     * @private
     */
    _createQ3PointsArray(inset) {
      var x1 = this._x1 + inset;
      var x2 = this._x2 - inset;
      var q2 = this._q2; // don't apply inset for q2

      var q3;
      if (this._q2 < this._q3) q3 = this._q3 - inset;
      else q3 = this._q3 + inset;

      return this._createPointsArray(x1, x2, q2, q3);
    }

    /**
     * Returns the points array for the polygon used to render the shape covering the q1-q2 segment of the box.
     * @param {number} inset The number of pixels to inset the polygon.
     * @return {Array}
     * @private
     */
    _createQ2PointsArray(inset) {
      var x1 = this._x1 + inset;
      var x2 = this._x2 - inset;
      var q2 = this._q2; // don't apply inset for q2

      var q1;
      if (this._q2 < this._q1) q1 = this._q1 - inset;
      else q1 = this._q1 + inset;

      return this._createPointsArray(x1, x2, q1, q2);
    }

    /**
     * Returns the points array for a polygon with the specified coords.
     * @param {number} x1
     * @param {number} x2
     * @param {number} y1
     * @param {number} y2
     * @return {Array}
     * @private
     */
    _createPointsArray(x1, x2, y1, y2) {
      if (this._bHoriz) return [y1, x1, y1, x2, y2, x2, y2, x1];
      else return [x1, y1, x2, y1, x2, y2, x1, y2];
    }

    /**
     * Apply the custom style in the _styleOptions to the shape.
     * @param {dvt.Shape} shape The shape to apply the style to.
     * @param {string} prefix The style prefix, e.g. 'q2', 'whisker', etc.
     * @private
     */
    _applyCustomStyle(shape, prefix) {
      shape.setStyle(
        this._styleOptions[prefix + 'Style'] || this._styleOptions[prefix + 'SvgStyle'],
        true
      );
      shape.setClassName(
        this._styleOptions[prefix + 'ClassName'] || this._styleOptions[prefix + 'SvgClassName'],
        true
      );
    }

    /**
     * Clean up previous render.
     * @private
     */
    _cleanUp() {
      this.removeChildren();

      // Remove references to the old shapes to ensure that they're rerendered
      this._q2Box = null;
      this._q3Box = null;
      this._medianLine = null;
      this._outerBorderShape = null;
      this._innerBorderShape = null;
    }
  }

  /**
   * Displayable for stock bars.
   * @extends {dvt.Container}
   * @param {dvt.Context} context
   * @param {number} xCoord
   * @param {number} barWidth
   * @param {number} openCoord
   * @param {number} closeCoord
   * @param {number=} lowCoord
   * @param {number=} highCoord
   * @class
   * @constructor
   */
  class DvtChartCandlestick extends dvt.Container {
    constructor(context, xCoord, barWidth, openCoord, closeCoord, lowCoord, highCoord) {
      super(context);

      /**
       * The minimum width fraction of the range bar with respect to the change bar width.
       * @const
       * @private
       */
      this._BAR_WIDTH = 0.3;

      // Calculate the bar width. For width >= 2, use even integer widths to ensure symmetry with range bar.
      barWidth = Math.max(Math.round(barWidth / 2) * 2, 1);
      var rangeWidth = Math.min(Math.ceil((this._BAR_WIDTH * barWidth) / 2) * 2, barWidth);

      // Calculate the x coords of the bar. Round the xCoord to ensure pixel location.
      var x1 = Math.round(xCoord) - barWidth / 2;
      var x2 = x1 + barWidth;

      // Create the range shape if coords provided
      if (lowCoord != null && highCoord != null) {
        var rangeX1 = Math.round(xCoord) - rangeWidth / 2;
        var rangeX2 = rangeX1 + rangeWidth;
        this._rangeShape = new DvtChartSelectableRectangularPolygon(context, [
          rangeX1,
          lowCoord,
          rangeX2,
          lowCoord,
          rangeX2,
          highCoord,
          rangeX1,
          highCoord
        ]);
        this.addChild(this._rangeShape);
      }

      // Create the change shape on top of range
      this._changeShape = new DvtChartSelectableRectangularPolygon(context, [
        x1,
        openCoord,
        x2,
        openCoord,
        x2,
        closeCoord,
        x1,
        closeCoord
      ]);
      this.addChild(this._changeShape);

      // Never anti-alias. Coords are carefully chosen to be perfectly aligned.
      this.setPixelHinting(true);
    }

    /**
     * Specifies the fill and stroke for the change shape.
     * @param {dvt.Fill} fill
     * @param {dvt.Stroke} stroke
     * @param {string} dataColor The primary color of this data item.
     * @param {string} innerColor The inner color of the selection effect.
     * @param {string} outerColor The outer color of the selection effect.
     */
    setChangeStyle(fill, stroke, dataColor, innerColor, outerColor) {
      this._changeShape.setStyleProperties(fill, stroke, dataColor, innerColor, outerColor);
    }

    /**
     * Specifies the fill and stroke for the range shape.
     * @param {dvt.Fill} fill
     * @param {dvt.Stroke} stroke
     * @param {string} rangeColor The primary color of the range bar.
     * @param {string} outerColor The outer color of the selection effect.
     */
    setRangeStyle(fill, stroke, rangeColor, outerColor) {
      if (!this._rangeShape) return;

      this._rangeShape.setStyleProperties(fill, stroke, rangeColor, null, outerColor);
    }

    /**
     * Set selected obj for stock
     * @param {boolean} selected Indicates if the container is selested. We never want to display the range as selected
     */
    setSelected(selected) {
      this._changeShape.setSelected(selected);
      if (this._rangeShape) this._rangeShape.setSelected(selected);
    }

    /**
     * Only show the hover effect for the change and range shape, ignore volume
     */
    showHoverEffect() {
      this._changeShape.showHoverEffect();
      if (this._rangeShape) this._rangeShape.showHoverEffect();
    }

    /**
     * Hide the hover effect for change and range shape, ignore volume
     */
    hideHoverEffect() {
      this._changeShape.hideHoverEffect();
      if (this._rangeShape) this._rangeShape.hideHoverEffect();
    }

    /**
     * Returns a dvt.ParallelPlayable containing the display animations for the stock bars
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.ParallelPlayable} A playable for the initial bar animation.
     */
    getDisplayAnim(duration) {
      // Animation: Grow from the center of each bar.
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);

      // Change Shape
      var endStateChange = this._changeShape.getPoints();
      this._changeShape.setPoints(DvtChartCandlestick._getInitialPoints(endStateChange));
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this._changeShape,
          this._changeShape.getPoints,
          this._changeShape.setAnimParams,
          endStateChange
        );

      // Range Shape
      if (this._rangeShape) {
        var endStateRange = this._rangeShape.getPoints();
        this._rangeShape.setPoints(DvtChartCandlestick._getInitialPoints(endStateRange));
        nodePlayable
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            this._rangeShape,
            this._rangeShape.getPoints,
            this._rangeShape.setAnimParams,
            endStateRange
          );
      }

      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the animation to delete this displayable.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getDeleteAnim(duration) {
      // Animation: Shrink to the center of each bar.
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);

      // Change Shape
      var endStateChange = DvtChartCandlestick._getInitialPoints(this._changeShape.getPoints());
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this._changeShape,
          this._changeShape.getPoints,
          this._changeShape.setAnimParams,
          endStateChange
        );

      // Range Shape
      if (this._rangeShape) {
        var endStateRange = DvtChartCandlestick._getInitialPoints(this._rangeShape.getPoints());
        nodePlayable
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            this._rangeShape,
            this._rangeShape.getPoints,
            this._rangeShape.setAnimParams,
            endStateRange
          );
      }

      // Alpha Fade
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 0);

      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the insert animation for this displayable.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getInsertAnim(duration) {
      // Initialize the alpha to fade in the bar
      this.setAlpha(0);

      // Create the playable
      var nodePlayable = this.getDisplayAnim(duration);
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 1);
      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the update animation for this displayable.
     * @param {number} duration The duration of the animation in seconds.
     * @param {DvtChartCandlestick} oldShape The old shape to animate from.
     * @return {dvt.Playable}
     */
    getUpdateAnim(duration, oldShape) {
      // Animation: Transition from old points to new points arrays.
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);

      // Change Shape: Points
      var endStateChange = this._changeShape.getPoints();
      this._changeShape.setPoints(oldShape._changeShape.getPoints());
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this._changeShape,
          this._changeShape.getPoints,
          this._changeShape.setAnimParams,
          endStateChange
        );

      // Change Shape: Fill. Need the get the primary color, since it might be overwritten during selection
      var startFill = oldShape._changeShape.getPrimaryFill();
      var endFill = this._changeShape.getPrimaryFill();
      var bSkipFillAnimation =
        oldShape._changeShape.isSelected() ||
        this._changeShape.isSelected() ||
        startFill.equals(endFill);
      if (!bSkipFillAnimation) {
        this._changeShape.setFill(startFill);
        nodePlayable
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_FILL,
            this._changeShape,
            this._changeShape.getFill,
            this._changeShape.setFill,
            endFill
          );
      }
      // Range Shape: Points
      if (this._rangeShape && oldShape._rangeShape) {
        var endStateRange = this._rangeShape.getPoints();
        this._rangeShape.setPoints(oldShape._rangeShape.getPoints());
        nodePlayable
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            this._rangeShape,
            this._rangeShape.getPoints,
            this._rangeShape.setAnimParams,
            endStateRange
          );
      }
      return nodePlayable;
    }

    /**
     * @override
     */
    UpdateSelectionEffect() {
      // noop: Selection effects fully managed by this class
    }

    /**
     * Returns the array of points for initial animation of the specified points array.
     * @param {array} points
     * @return {array}
     * @private
     */
    static _getInitialPoints(points) {
      var x1 = points[0];
      var x2 = points[2];
      var y1 = points[1];
      var y2 = points[5];
      var yMid = (y1 + y2) / 2;
      return [x1, yMid, x2, yMid, x2, yMid, x1, yMid];
    }
  }

  /**
   * Property bag of line/area coordinate for DvtChartPolygonSet.
   * The coordinates are represented by x, y1, and y2. Usually, y1 == y2. If y1 != y2, it means that there's a jump in
   * the y value at that x position (from y1 to y2) due to a null in the data.
   * @class DvtChartCoord
   * @extends {DvtObject}
   * @constructor
   * @param {number} x The x coordinate.
   * @param {number} y1 The first y coordinate.
   * @param {number} y2 The second y coordinate.
   * @param {number} groupIndex The group index of the coordinate.
   * @param {string} group The group name of the coordinate.
   * @param {boolean} filtered Whether the coordinate is filtered for performance.
   */
  class DvtChartCoord {
    constructor(x, y1, y2, groupIndex, group, filtered) {
      this.x = x;
      this.y1 = y1;
      this.y2 = y2;
      this.groupIndex = groupIndex;
      this.group = group;
      this.filtered = filtered;
    }

    /**
     * Returns whether the step from y1 to y2 is upward. "Upward" is defined as moving further from the baseline.
     * @param {number} baseline The coordinate of the baseline.
     * @return {boolean}
     */
    isUpstep(baseline) {
      return Math.abs(this.y2 - baseline) > Math.abs(this.y1 - baseline);
    }

    /**
     * Returns a clone of itself.
     * @return {DvtChartCoord}
     */
    clone() {
      return new DvtChartCoord(this.x, this.y1, this.y2, this.groupIndex, this.group, this.filtered);
    }
  }

  /**
   * A collection of line/area shapes for a chart series.
   * Usually there's only one shape for each series, but there can be multiple if there are null values in the data.
   * @class DvtChartLineArea
   * @extends {dvt.Container}
   * @constructor
   * @param {Chart} chart The chart.
   * @param {boolean} bArea Whether this is an Area (it is a Line otherwise).
   * @param {dvt.Rectangle} availSpace The available space.
   * @param {number} baseline The axis baseline coordinate.
   * @param {object} style The style of the shape.
   * @param {string} className The className of the shape.
   * @param {dvt.Fill} fill The fill of the shapes.
   * @param {dvt.Stroke} stroke The stroke of the shapes.
   * @param {string} type The type of the line or the area top: straight, curved, stepped, centeredStepped, segmented, or centeredSegmented.
   * @param {array} arCoord Array of DvtChartCoord representing the coordinates of the line or the area top.
   * @param {string} baseType The type of the area base: straight, curved, stepped, centeredStepped, segmented, or centeredSegmented.
   * @param {array} arBaseCoord Array of DvtChartCoord representing the coordinates of the area base.
   */
  class DvtChartLineArea extends dvt.Container {
    constructor(
      chart,
      bArea,
      availSpace,
      baseline,
      style,
      className,
      fill,
      stroke,
      type,
      arCoord,
      baseType,
      arBaseCoord
    ) {
      super(chart.getCtx());

      /** @private **/
      this._INDICATOR_OFFSET = 8;

      // Calculate the points array and apply to the polygon
      this._chart = chart;
      this._bArea = bArea;
      this._availSpace = availSpace;
      this._baseline = baseline;
      this._style = style;
      this._className = className;
      this._fill = fill;
      this._stroke = stroke;
      this._type = type;
      this._baseType = baseType ? baseType : type;
      this._indicatorMap = {};

      this.setCoords(arCoord, arBaseCoord);
      this.chartShapeType = 'lineArea';
    }

    /**
     * Sets the coordinates of the shapes.
     * @param {array} arCoord Array of DvtChartCoord representing the coordinates of the line or the area top.
     * @param {array} arBaseCoord Array of DvtChartCoord representing the coordinates of the area base.
     */
    setCoords(arCoord, arBaseCoord) {
      this._arCoord = arCoord;
      if (arBaseCoord) this._arBaseCoord = arBaseCoord;

      this.removeChildren(); // clean up

      if (this._bArea) this._renderAreas();
      else this._renderLines();

      this._positionIndicators();
    }

    /**
     * Returns the coordinates of the line or the area top.
     * @return {array} Array of DvtChartCoord representing the coordinates of the line or the area top.
     */
    getCoords() {
      return this._arCoord;
    }

    /**
     * Returns the coordinates of the area base.
     * @return {array} Array of DvtChartCoord representing the coordinates of the area base.
     */
    getBaseCoords() {
      return this._arBaseCoord;
    }

    /**
     * Returns the axis baseline coordinate.
     * @return {number}
     */
    getBaseline() {
      return this._baseline;
    }

    /**
     * Returns whether this is an area (otherwise, it's a line).
     * @return {boolean}
     */
    isArea() {
      return this._bArea;
    }

    /**
     * Creates arrays of dvt.Point for drawing polygons or polylines based on the DvtChartCoord array.
     * An array of dvt.Point arrays is returned, with each array being a set of contiguous points.
     * @param {array} coords The array of DvtChartCoords representing axis coordinates.
     * @param {string} type The line type: straight, curved, stepped, centeredStepped, segmented, or centeredSegmented.
     * @return {array} The arrays of contiguous points for drawing polygons or polylines.
     * @private
     */
    _getPointArrays(coords, type) {
      var pointsArrays = [];
      var points = [];
      pointsArrays.push(points);
      coords = DvtChartLineArea._convertToPointCoords(coords);

      var isPolar = DvtChartTypeUtils.isPolar(this._chart);
      var isCentered = type == 'centeredStepped' || type == 'centeredSegmented';
      var isParallel = isCentered || type == 'stepped' || type == 'segmented';
      var groupWidth = DvtChartStyleUtils.getGroupWidth(this._chart);
      var dir =
        dvt.Agent.isRightToLeft(this.getCtx()) && DvtChartTypeUtils.isVertical(this._chart) ? -1 : 1;

      var lastCoord;
      if (isPolar)
        // initiate lastCoord to be the final point
        lastCoord = coords[coords.length - 1];

      var coord, xCoord, isY2, finalXCoord;
      var inBump = false; // flag to indicate whether we're in a bump (a section surrounded by y1 != y2 cliffs)
      for (var i = 0; i < coords.length; i++) {
        if (coords[i] == null) {
          if (!DvtChartTypeUtils.isMixedFrequency(this._chart)) {
            // Draw the last step
            if (isParallel && !isPolar && lastCoord && !isY2) {
              finalXCoord = isCentered
                ? lastCoord.x + 0.5 * groupWidth * dir
                : lastCoord.x + groupWidth * dir;
              this._pushCoord(points, finalXCoord, lastCoord.y);
            }
          }
          // Start a new list of points, except in ADF and MAF mixed freq where we want to connect points across nulls.
          points = [];
          pointsArrays.push(points);
          lastCoord = null;
          continue;
        }

        coord = coords[i];
        isY2 = coords[i]._isY2;
        xCoord = isCentered ? coord.x - (groupWidth / 2) * dir : coord.x;

        if (isY2) {
          if (inBump && isParallel) xCoord += groupWidth * dir; // draw the segment at the end of the bump
          inBump = !inBump;
        }

        if (type == 'curved' && isY2) points.push(null, null); // flag to indicate that the curve should be broken

        if (lastCoord && isParallel)
          // draw the step
          this._pushCoord(points, xCoord, lastCoord.y);

        if (!this._bArea && (type == 'segmented' || type == 'centeredSegmented')) {
          // Start a new list of points to break the segments
          points = [];
          pointsArrays.push(points);
        }

        this._pushCoord(points, xCoord, coord.y);
        lastCoord = coord;
      }

      // Draw the last step
      if (isParallel && !isPolar && lastCoord && !isY2) {
        finalXCoord = isCentered
          ? lastCoord.x + 0.5 * groupWidth * dir
          : lastCoord.x + groupWidth * dir;
        this._pushCoord(points, finalXCoord, lastCoord.y);
      }

      // Connect the last points with the first ones for polar
      if (isPolar && pointsArrays.length > 1) {
        var lastPoints = pointsArrays.pop();
        pointsArrays[0] = lastPoints.concat(pointsArrays[0]);
      }

      return pointsArrays;
    }

    /**
     * Converts the axis coordinate to the stage coordinate and pushes the points to the pointArray.
     * @param {array} pointArray The point array.
     * @param {number} x The x-axis coordinate.
     * @param {number} y The y-axis coordinate.
     * @private
     */
    _pushCoord(pointArray, x, y) {
      var coord = DvtChartCoordUtils.convertAxisCoord(
        this._chart,
        new dvt.Point(x, y),
        this._availSpace
      );

      // Round to 1 decimal to keep the DOM small, but prevent undesidered gaps due to rounding errors
      pointArray.push(Math.round(coord.x * 10) / 10, Math.round(coord.y * 10) / 10);
    }

    /**
     * Returns whether the points form a complete ring/donut shape. Only applicable to polar charts.
     * @return {boolean}
     * @private
     */
    _isRing() {
      if (
        !DvtChartTypeUtils.isPolar(this._chart) ||
        !DvtChartTypeUtils.hasGroupAxis(this._chart) ||
        this._arCoord.length < DvtChartDataUtils.getGroupCount(this._chart)
      )
        return false;

      // Check if there is any null that breaks the ring/donut.
      for (var i = 0; i < this._arCoord.length; i++) {
        if (this._arCoord[i].x == null) return false;
      }
      return true;
    }

    /**
     * Returns the spline type of the line/area based on the chart type.
     * @return {string} Spline type.
     * @private
     */
    _getSplineType() {
      if (DvtChartTypeUtils.isScatterBubble(this._chart)) return dvt.PathUtils.SPLINE_TYPE_CARDINAL;
      else if (DvtChartTypeUtils.isPolar(this._chart))
        return this._isRing()
          ? dvt.PathUtils.SPLINE_TYPE_CARDINAL_CLOSED
          : dvt.PathUtils.SPLINE_TYPE_CARDINAL;
      else if (DvtChartTypeUtils.isHorizontal(this._chart))
        return dvt.PathUtils.SPLINE_TYPE_MONOTONE_HORIZONTAL;
      else return dvt.PathUtils.SPLINE_TYPE_MONOTONE_VERTICAL;
    }

    /**
     * Renders lines.
     * @private
     */
    _renderLines() {
      var pointArrays = this._getPointArrays(this._arCoord, this._type);
      var line;
      for (var i = 0; i < pointArrays.length; i++) {
        var points = pointArrays[i];
        if (points && points.length > 1) {
          if (this._type == 'curved') {
            var cmd = DvtChartLineArea._getCurvedPathCommands(points, false, this._getSplineType());
            line = new dvt.Path(this.getCtx(), cmd);
            line.setFill(null);
          } else {
            // not curved
            if (this._isRing()) {
              // create a closed loop
              line = new dvt.Polygon(this.getCtx(), points);
              line.setFill(null);
            } else line = new dvt.Polyline(this.getCtx(), points);
          }
          line.setStroke(this._stroke);
          line.setClassName(this._className).setStyle(this._style);
          this.addChild(line);
        }
      }
    }

    /**
     * Renders areas.
     * @private
     */
    _renderAreas() {
      // If both the area has both top and bottom coords, remove the edge points that go to the baseline at the two ends.
      // These edge points are invisible, but may show up if border is turned on, and also during animation.
      var arCoord = this._arCoord;
      var arBaseCoord = this._arBaseCoord;
      if (!DvtChartTypeUtils.isPolar(this._chart) && arCoord.length > 0 && arBaseCoord.length > 0) {
        // Don't update the stored arrays (this._arCoord and this._arBaseCoord) as the edge points may be needed later for animation.
        arCoord = arCoord.slice(0);
        arBaseCoord = arBaseCoord.slice(0);

        if (arCoord[0].x != null && arBaseCoord[0].x != null) {
          DvtChartLineArea._removeAreaEdge(arCoord, 0, this._baseline);
          DvtChartLineArea._removeAreaEdge(arBaseCoord, 0, this._baseline);
          arBaseCoord[0].x = arCoord[0].x;
        }
        if (arCoord[arCoord.length - 1].x != null && arBaseCoord[arBaseCoord.length - 1].x != null) {
          DvtChartLineArea._removeAreaEdge(arCoord, arCoord.length - 1, this._baseline);
          DvtChartLineArea._removeAreaEdge(arBaseCoord, arBaseCoord.length - 1, this._baseline);
          arBaseCoord[arBaseCoord.length - 1].x = arCoord[arCoord.length - 1].x;
        }
      }

      var highArrays = this._getPointArrays(arCoord, this._type);
      var lowArrays = this._getPointArrays(arBaseCoord, this._baseType);

      if (highArrays.length != lowArrays.length) return;

      var area;
      for (var i = 0; i < highArrays.length; i++) {
        var highArray = highArrays[i];
        var lowArray = lowArrays[i];

        if (highArray.length < 2) continue;

        var highCurved = this._type == 'curved';
        var lowCurved = this._baseType == 'curved';

        // For polar with group axis, form an polygonal donut if possible
        if (this._isRing()) {
          if (!highCurved) highArray.push(highArray[0], highArray[1]);
          if (lowArray.length >= 2 && !lowCurved) lowArray.push(lowArray[0], lowArray[1]);
        }

        // Reverse the lowArray
        var revLowArray = [];
        for (var j = 0; j < lowArray.length; j += 2)
          revLowArray.unshift(lowArray[j], lowArray[j + 1]);

        // If either the top or the base is a curve, we have to draw a path. Otherwise, we can use polygon.
        if (highCurved || lowCurved) {
          var splineType = this._getSplineType();
          var cmd = highCurved
            ? DvtChartLineArea._getCurvedPathCommands(highArray, false, splineType)
            : dvt.PathUtils.polyline(highArray, false);
          cmd += lowCurved
            ? DvtChartLineArea._getCurvedPathCommands(revLowArray, true, splineType)
            : dvt.PathUtils.polyline(revLowArray, true);
          cmd += dvt.PathUtils.closePath();
          area = new dvt.Path(this.getCtx(), cmd);
        } else {
          // not curved
          // Add the reversed low points to the high points to form a range
          var points = revLowArray.concat(highArray);
          area = new dvt.Polygon(this.getCtx(), points);
        }

        area.setFill(this._fill);
        area.setClassName(this._className).setStyle(this._style);

        if (this._stroke) area.setStroke(this._stroke);
        this.addChild(area);
      }
    }

    /**
     * Positions the animation indicators.
     * @private
     */
    _positionIndicators() {
      var indicatorObj, indicator, pos, y, coord;
      for (var i = 0; i < this._arCoord.length; i++) {
        coord = this._arCoord[i];
        indicatorObj = this._indicatorMap[coord.groupIndex];

        if (indicatorObj && indicatorObj.indicator) {
          // If the coord has unequal y1 and y2, pick the one farthest from the baseline.
          y =
            (coord.isUpstep(this._baseline) ? coord.y2 : coord.y1) +
            this._INDICATOR_OFFSET *
              (indicatorObj.direction == DvtChartDataChangeUtils.DIR_UP ? -1 : 1);
          pos = DvtChartCoordUtils.convertAxisCoord(
            this._chart,
            new dvt.Point(coord.x, y),
            this._availSpace
          );

          indicator = indicatorObj.indicator;
          indicator.setTranslate(pos.x, pos.y);
          indicator.setAlpha(1); // show it because it's hidden when added
          indicator.getParent().addChild(indicator); // reparent to keep at top
        }
      }
    }

    /**
     * Returns the animation params for the line or the area top.
     * @param {DvtChartLineArea} other The shape it is animating from/to. If provided, the animation params are guaranteed
     *     to contain all the groups that the other shape has, in the correct order.
     * @return {array} The animation params in the form of [x y1 y2 groupIndex x y1 y2 groupIndex ...]
     */
    getAnimParams(other) {
      return DvtChartLineArea._coordsToAnimParams(
        this._arCoord,
        other ? other._arCoord : null,
        this._baseline
      );
    }

    /**
     * Updates the animation params for the line or the area top.
     * @param {array} params The animation params in the form of [x y1 y2 groupIndex x y1 y2 groupIndex ...]
     */
    setAnimParams(params) {
      var coords = DvtChartLineArea._animParamsToCoords(params);
      this.setCoords(coords);
    }

    /**
     * Returns the animation params for the area base.
     * @param {DvtChartLineArea} other The shape it is animating from/to. If provided, the animation params are guaranteed
     *     to contain all the groups that the other shape has, in the correct order.
     * @return {array} The animation params in the form of [x y1 y2 groupIndex x y1 y2 groupIndex ...]
     */
    getBaseAnimParams(other) {
      return DvtChartLineArea._coordsToAnimParams(
        this._arBaseCoord,
        other ? other._arBaseCoord : null,
        this._baseline
      );
    }

    /**
     * Updates the animation params for the area base.
     * @param {array} params The animation params in the form of [x y1 y2 groupIndex x y1 y2 groupIndex ...]
     */
    setBaseAnimParams(params) {
      this._arBaseCoord = DvtChartLineArea._animParamsToCoords(params);
    }

    /**
     * Returns a list of group indices that are common between this and other (used for generating animation indicators).
     * @param {DvtChartLineArea} other The shape it is animating from/to.
     * @return {array} The array of common group indices.
     */
    getCommonGroupIndices(other) {
      var indices = [];
      for (var i = 0; i < this._arCoord.length; i++) {
        if (this._arCoord[i].filtered || this._arCoord[i].x == null) continue;

        for (var j = 0; j < other._arCoord.length; j++) {
          if (other._arCoord[j].filtered || other._arCoord[j].x == null) continue;

          if (this._arCoord[i].group == other._arCoord[j].group) {
            indices.push(this._arCoord[i].groupIndex);
            break;
          }
        }
      }
      return indices;
    }

    /**
     * Adds an animation indicator.
     * @param {number} groupIndex The group index corresponding to the indicator.
     * @param {number} direction The direction of the indicator.
     * @param {dvt.Shape} indicator The indicator shape.
     */
    addIndicator(groupIndex, direction, indicator) {
      indicator.setAlpha(0); // hide it until animation starts
      this._indicatorMap[groupIndex] = { direction: direction, indicator: indicator };
    }

    /**
     * Removes all animation indicators.
     */
    removeIndicators() {
      for (var groupIndex in this._indicatorMap) {
        var indicator = this._indicatorMap[groupIndex].indicator;
        if (indicator) indicator.getParent().removeChild(indicator);
      }

      this._indicatorMap = {};
    }

    /**
     * Converts DvtChartCoord array into dvt.Point array. Excludes filtered points.
     * @param {array} coords DvtChartCoord array.
     * @return {array} dvt.Point array.
     * @private
     */
    static _convertToPointCoords(coords) {
      var pointCoords = [];
      for (var i = 0; i < coords.length; i++) {
        if (coords[i].filtered) continue;

        if (coords[i].x == null) pointCoords.push(null);
        else {
          // if y1 == y2, then add just one point. Otherwise, add two points.
          pointCoords.push(new dvt.Point(coords[i].x, coords[i].y1));
          if (coords[i].y1 != coords[i].y2) {
            var p2 = new dvt.Point(coords[i].x, coords[i].y2);
            p2._isY2 = true; // flag to indicate the point comes from y2
            pointCoords.push(p2);
          }
        }
      }
      return pointCoords;
    }

    /**
     * Converts array of DvtChartCoord into animation params.
     * @param {array} coords Array of DvtChartCoord.
     * @param {array} otherCoords The array of DvtChartCoord it is animating from/to. If provided, the animation params are
     *     guaranteed to contain all the groups that the other shape has, in the correct order.
     * @param {number} baseline The axis baseline coordinate.
     * @return {array} The animation params in the form of [x y1 y2 groupIndex x y1 y2 groupIndex ...].
     * @private
     */
    static _coordsToAnimParams(coords, otherCoords, baseline) {
      if (otherCoords && otherCoords.length > 0) {
        // Construct coords list that contains all the groups that this shape and other shape have.
        if (coords && coords.length > 0) {
          coords = coords.slice(0);
          var otherGroups = DvtChartLineArea._coordsToGroups(otherCoords);
          var groups = DvtChartLineArea._coordsToGroups(coords);
          var idx = coords.length;

          // Iterate otherGroups backwards. For each group, check if the current shape has it. If not, insert a dummy coord
          // into the array, which has an identical value to the coord before it (or after it if the insertion is at the start).
          var group, groupIdx, dummyCoord;
          for (var g = otherGroups.length - 1; g >= 0; g--) {
            group = otherGroups[g];
            groupIdx = groups.indexOf(group);
            if (groupIdx == -1) {
              // Group not found -- insert dummy coord
              if (idx == 0) {
                dummyCoord = coords[0].clone(); // copy coord after it
                coords[0] = coords[0].clone();
                DvtChartLineArea._removeCoordJump(dummyCoord, coords[0], baseline);
              } else {
                dummyCoord = coords[idx - 1].clone(); // copy coord before it
                coords[idx - 1] = coords[idx - 1].clone();
                DvtChartLineArea._removeCoordJump(coords[idx - 1], dummyCoord, baseline);
              }
              dummyCoord.groupIndex = -1;
              coords.splice(idx, 0, dummyCoord);
            } // Group found -- use idx to keep track of the last found group so we know where to add the dummy coord
            else idx = groupIdx;
          }
        } else {
          // this coords is empty, so return the baseline coords
          coords = [];
          for (var g = 0; g < otherCoords.length; g++) {
            coords.push(new DvtChartCoord(otherCoords[g].x, baseline, baseline));
          }
        }
      }

      // Construct the animation params
      var params = [];
      for (var i = 0; i < coords.length; i++) {
        if (coords[i].filtered) continue;

        if (coords[i].x == null) {
          params.push(Infinity); // placeholder for nulls
          params.push(Infinity);
          params.push(Infinity);
        } else {
          params.push(coords[i].x);
          params.push(coords[i].y1);
          params.push(coords[i].y2);
        }
        params.push(coords[i].groupIndex);
      }
      return params;
    }

    /**
     * Converts animation params into array of DvtChartCoord.
     * @param {array} params The animation params in the form of [x y1 y2 groupIndex x y1 y2 groupIndex ...].
     * @return {array} Array of DvtChartCoord.
     * @private
     */
    static _animParamsToCoords(params) {
      var coords = [];
      for (var i = 0; i < params.length; i += 4) {
        if (params[i] == Infinity || isNaN(params[i]))
          coords.push(new DvtChartCoord(null, null, null, params[i + 3]));
        else coords.push(new DvtChartCoord(params[i], params[i + 1], params[i + 2], params[i + 3]));
      }
      return coords;
    }

    /**
     * Converts array of DvtChartCoord into array of group names.
     * @param {array} coords Array of DvtChartCoord.
     * @return {array} Array of group names.
     * @private
     */
    static _coordsToGroups(coords) {
      var groups = [];
      for (var i = 0; i < coords.length; i++) {
        if (!coords[i].filtered) groups.push(coords[i].group);
      }
      return groups;
    }

    /**
     * Removes the jump (due to null values) between startCoord and endCoord, which are duplicates of each other:
     * - If the jump is upward, it eliminates the jump in the endCoord.
     * - If the jump is downward, it eliminates the jump in the startCoord.
     * @param {DvtChartCoord} startCoord The coord on the left (or right in R2L).
     * @param {DvtChartCoord} endCoord The coord on the right (or left in R2L).
     * @param {number} baseline The axis baseline coordinate.
     * @private
     */
    static _removeCoordJump(startCoord, endCoord, baseline) {
      if (startCoord.isUpstep(baseline)) endCoord.y1 = endCoord.y2;
      else startCoord.y2 = startCoord.y1;
    }

    /**
     * Returns the path commands for a curve that goes through the points.
     * @param {array} points The points array.
     * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.
     * @param {string} splineType The spline type.
     * @return {string} Path commands.
     * @private
     */
    static _getCurvedPathCommands(points, connectWithLine, splineType) {
      // First we need to split the points into multiple arrays. The separator between arrays are the nulls, which
      // indicate that the two segments should be connected by a straight line instead of a curve.
      var arP = [];
      var p = [];
      arP.push(p);
      for (var i = 0; i < points.length; i += 2) {
        if (points[i] == null) {
          p = [];
          arP.push(p);
        } else p.push(points[i], points[i + 1]);
      }

      // Connect the last segment with the first one for polar
      if (splineType == dvt.PathUtils.SPLINE_TYPE_CARDINAL_CLOSED && arP.length > 1) {
        var lastPoints = arP.pop();
        arP[0] = lastPoints.concat(arP[0]);
        splineType = dvt.PathUtils.SPLINE_TYPE_CARDINAL; // multiple segments, so not a closed curve
      }

      var cmd = '';
      for (var i = 0; i < arP.length; i++) {
        p = arP[i];
        cmd += dvt.PathUtils.curveThroughPoints(p, connectWithLine, splineType);
        connectWithLine = true; // after the first segment, the rest are connected by straight lines
      }

      return cmd;
    }

    /**
     * Removes the edge point of an area. Used to create range area shape without the extra lines at the edges.
     * @param {array} arCoord The coord array.
     * @param {number} index The index of the edge to be removed.
     * @param {number} baseline The baseline coord.
     * @private
     */
    static _removeAreaEdge(arCoord, index, baseline) {
      var coord = arCoord[index].clone();
      if (coord.isUpstep(baseline)) coord.y1 = coord.y2;
      else coord.y2 = coord.y1;
      arCoord[index] = coord;
    }
  }

  /**
   *  A marker object for selectable invisible markers.
   *  @param {dvt.Context} context
   *  @param {number} type The marker type.
   *  @param {number} cx The x position of the center of the marker.
   *  @param {number} cy The y position of the center of the marker.
   *  @param {number} size The size of the marker.
   *  @param {boolean} bOptimizeStroke True if the stroke of the markers has been applied on a container.
   *  @extends {dvt.SimpleMarker}
   *  @class DvtChartLineMarker
   *  @constructor
   */
  class DvtChartLineMarker extends dvt.SimpleMarker {
    constructor(context, type, cx, cy, size, bOptimizeStroke) {
      super(context, type, cx, cy, size, size, null, null, true);

      // Set the stroke if the container may have defined a different one.
      if (bOptimizeStroke) this.setStroke(DvtChartLineMarker.DEFAULT_STROKE);
    }

    /**
     * @override
     */
    setDataColor(dataColor) {
      this._dataColor = dataColor;
      this._hoverStroke = new dvt.Stroke(dataColor, 1, 1.5);
    }

    /**
     * @override
     */
    getDataColor() {
      return this._dataColor;
    }

    /**
     * @override
     */
    showHoverEffect() {
      this.IsShowingHoverEffect = true;
      this.setStroke(this._hoverStroke);
    }

    /**
     * @override
     */
    hideHoverEffect() {
      this.IsShowingHoverEffect = false;
      this.setStroke(
        this.isSelected() ? DvtChartLineMarker.SELECTED_STROKE : DvtChartLineMarker.DEFAULT_STROKE
      );
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this.IsSelected == selected) return;

      this.IsSelected = selected;
      if (this.isSelected()) {
        this.setFill(DvtChartLineMarker.SELECTED_FILL);
        this.setStroke(
          this.isHoverEffectShown() ? this._hoverStroke : DvtChartLineMarker.SELECTED_STROKE
        );
      } else {
        this.setInvisibleFill();
        this.setStroke(
          this.isHoverEffectShown() ? this._hoverStroke : DvtChartLineMarker.DEFAULT_STROKE
        );
      }
    }

    /**
     * @override
     */
    UpdateSelectionEffect() {
      // noop: Selection effects fully managed by this class
    }
  }

  /** @const */
  DvtChartLineMarker.DEFAULT_STROKE = new dvt.Stroke('none');

  /** @const */
  DvtChartLineMarker.SELECTED_FILL = new dvt.SolidFill('#FFFFFF');

  /** @const */
  DvtChartLineMarker.SELECTED_STROKE = new dvt.Stroke('#5A5A5A', 1, 1.5);

  /**
   *  A selectable polar bar for charting.
   *  @class DvtChartPolarBar
   *  @extends {dvt.Path}
   *  @constructor
   *  @param {Chart} chart
   *  @param {number} axisCoord The location of the axis line.
   *  @param {number} baselineCoord The location from which the bar grows.
   *  @param {number} endCoord The location where the bar length ends.
   *  @param {number} x1 The left coord of a vertical bar, or the top of a horizontal bar.
   *  @param {number} x2 The right coord of a vertical bar, or the bottom of a horizontal bar.
   *  @param {number} availSpace The plotAreaSpace, to convert the polar coordinates.
   */
  class DvtChartPolarBar extends DvtChartSelectableWedge {
    constructor(chart, axisCoord, baselineCoord, endCoord, x1, x2, availSpace) {
      // Initialize the path
      super(chart.getCtx());

      /**
       * Min bar length for gaps to be added, in pixels.
       * @const
       * @private
       */
      this._MIN_BAR_LENGTH_FOR_GAPS = 4;

      /**
       * Gap between bars in a stack in pixels.
       * @const
       * @private
       */
      this._MAX_DATA_ITEM_GAP = 3;

      this._axisCoord = axisCoord;
      this._availSpace = availSpace.clone();
      this._bbox = null;
      this._dataItemGaps = DvtChartStyleUtils.getDataItemGaps(chart) * this._MAX_DATA_ITEM_GAP;

      // Calculate the path commands and apply to the path
      this._setBarCoords(baselineCoord, endCoord, x1, x2);
    }

    /**
     * Returns the layout parameters for the current animation frame.
     * @return {array} The array of layout parameters.
     */
    getAnimParams() {
      return [this._baselineCoord, this._endCoord, this._x1, this._x2];
    }

    /**
     * Sets the layout parameters for the current animation frame.
     * @param {array} params The array of layout parameters.
     * @param {dvt.Displayable=} indicator The animation indicator, whose geometry is centered at (0,0).
     */
    setAnimParams(params) {
      // Set bar coords but don't adjust for gaps, since they've already been factored in.
      this._setBarCoords(params[0], params[1], params[2], params[3]);
    }

    /**
     * Returns the primary dvt.Fill for this bar. Used for animation, since getFill may return the fill of the selection
     * shapes.
     * @return {dvt.Fill}
     */
    getPrimaryFill() {
      // Note: getFill is currently correct, but will change once we stop using filters.
      return this.getFill();
    }

    /**
     * Returns a dvt.Playable containing the animation of the bar to its initial data value.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable} A playable for the initial bar animation.
     */
    getDisplayAnim(duration) {
      // Current state is the end state
      var endState = this.getAnimParams();

      // Initialize the start state. To grow the bar, just set the end coord to the baseline coord.
      this.setAnimParams([this._axisCoord, this._axisCoord, 0, 0]);

      // Create and return the playable
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.getAnimParams,
          this.setAnimParams,
          endState
        );
      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the animation to delete the bar.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getDeleteAnim(duration) {
      // End state is for the bar length to shrink to 0
      var endState = [this._baselineCoord, this._baselineCoord, this._x1, this._x2];

      // Create and return the playable
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.getAnimParams,
          this.setAnimParams,
          endState
        );
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 0);
      return nodePlayable;
    }

    /**
     * Returns a dvt.Playable containing the insert animation of the bar.
     * @param {number} duration The duration of the animation in seconds.
     * @return {dvt.Playable}
     */
    getInsertAnim(duration) {
      // Initialize the alpha to fade in the bar
      this.setAlpha(0);

      // Current state is the end state
      var endState = this.getAnimParams();

      // Initialize the start state. To grow the bar, just set the end coord to the baseline coord.
      this.setAnimParams([this._baselineCoord, this._baselineCoord, this._x1, this._x2]);

      // Create and return the playable
      var nodePlayable = new dvt.CustomAnimation(this.getCtx(), this, duration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this.getAnimParams,
          this.setAnimParams,
          endState
        );
      nodePlayable
        .getAnimator()
        .addProp(dvt.Animator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 1);
      return nodePlayable;
    }

    /**
     * Stores the point coords defining the bar.
     * @param {number} baselineCoord The location from which the bar grows.
     * @param {number} endCoord The location where the bar length ends.
     * @param {number} x1 The left coord of a vertical bar, or the top of a horizontal bar.
     * @param {number} x2 The right coord of a vertical bar, or the bottom of a horizontal bar.
     * @private
     */
    _setBarCoords(baselineCoord, endCoord, x1, x2) {
      var cx = this._availSpace.x + this._availSpace.w / 2;
      var cy = this._availSpace.y + this._availSpace.h / 2;
      var r = Math.max(endCoord, baselineCoord);
      var ir =
        Math.abs(endCoord - baselineCoord) >= this._MIN_BAR_LENGTH_FOR_GAPS &&
        this._axisCoord != baselineCoord
          ? Math.min(endCoord, baselineCoord) + this._dataItemGaps
          : Math.min(endCoord, baselineCoord);
      var sa = 360 - dvt.Math.radsToDegrees(Math.max(x1, x2)) + 90;
      var ae = dvt.Math.radsToDegrees(Math.abs(x2 - x1));
      this.setWedgeParams(cx, cy, r, r, sa, ae, this._dataItemGaps, ir);

      // Calculate the coords to compute the bounding box
      var inner1 = DvtChartCoordUtils.polarToCartesian(baselineCoord, x1, this._availSpace);
      var inner2 = DvtChartCoordUtils.polarToCartesian(baselineCoord, x2, this._availSpace);
      var outer1 = DvtChartCoordUtils.polarToCartesian(endCoord, x1, this._availSpace);
      var outer2 = DvtChartCoordUtils.polarToCartesian(endCoord, x2, this._availSpace);
      var minX = Math.min(inner1.x, inner2.x, outer1.x, outer2.x);
      var maxX = Math.max(inner1.x, inner2.x, outer1.x, outer2.x);
      var minY = Math.min(inner1.y, inner2.y, outer1.y, outer2.y);
      var maxY = Math.max(inner1.y, inner2.y, outer1.y, outer2.y);
      this._bbox = new dvt.Rectangle(minX, minY, maxX - minX, maxY - minY);

      // Store the geometry values, needed for animation
      this._baselineCoord = baselineCoord;
      this._endCoord = endCoord;
      this._x1 = x1;
      this._x2 = x2;
    }

    /**
     * Returns the bounding box of the shape
     * @return {dvt.Rectangle} bbox
     */
    getBoundingBox() {
      return this._bbox;
    }

    /**
     * Returns the non rounded width of the bar
     * @return {number}
     */
    getOriginalBarSize() {
      return this._bbox.w;
    }
  }

  /**
   * A marker for range area chart.
   * @class DvtChartRangeMarker
   * @extends {dvt.Path}
   * @constructor
   * @param {dvt.Context} context
   * @param {number} x1 The x coord of the first point.
   * @param {number} y1 The y coord of the first point.
   * @param {number} x2 The x coord of the second point.
   * @param {number} y2 The y coord of the second point.
   * @param {number} markerSize The diameter of the marker.
   * @param {boolean} isInvisible Whether the marker is invisible unless hovered/selected.
   */
  class DvtChartRangeMarker extends dvt.Path {
    constructor(context, x1, y1, x2, y2, markerSize, isInvisible) {
      super(context);
      this._markerSize = markerSize;
      this._isInvisible = isInvisible;

      this._drawPath(x1, y1, x2, y2);
    }

    /**
     * Draws the marker shape.
     * @param {number} x1 The x coord of the first point.
     * @param {number} y1 The y coord of the first point.
     * @param {number} x2 The x coord of the second point.
     * @param {number} y2 The y coord of the second point.
     * @private
     */
    _drawPath(x1, y1, x2, y2) {
      // Construct the path
      var angle = Math.atan2(y2 - y1, x2 - x1);
      var r = this._markerSize / 2;
      var lineAngle = Math.PI / 8;

      var cmds =
        dvt.PathUtils.moveTo(
          x1 + r * Math.cos(angle + lineAngle),
          y1 + r * Math.sin(angle + lineAngle)
        ) +
        dvt.PathUtils.arcTo(
          r,
          r,
          2 * (Math.PI - lineAngle),
          1,
          x1 + r * Math.cos(angle - lineAngle),
          y1 + r * Math.sin(angle - lineAngle)
        ) +
        dvt.PathUtils.lineTo(
          x2 - r * Math.cos(angle + lineAngle),
          y2 - r * Math.sin(angle + lineAngle)
        ) +
        dvt.PathUtils.arcTo(
          r,
          r,
          2 * (Math.PI - lineAngle),
          1,
          x2 - r * Math.cos(angle - lineAngle),
          y2 - r * Math.sin(angle - lineAngle)
        ) +
        dvt.PathUtils.closePath();

      this.setCmds(cmds);

      // Save the coords
      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;
    }

    /**
     * Specifies the styles needed to generate the selection effect.
     * @param {dvt.Fill} fill
     * @param {dvt.Stroke} stroke
     * @param {string} dataColor The color of the data.
     * @param {string} innerColor The color of the inner selection border.
     * @param {string} outerColor The color of the outer selection border.
     */
    setStyleProperties(fill, stroke, dataColor, innerColor, outerColor) {
      this._dataColor = dataColor;
      var hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(dataColor);

      if (this._isInvisible) {
        this.setInvisibleFill();
        this._hoverStroke = new dvt.Stroke(hoverColor, 1, 1.5);
      } else {
        this.setFill(fill);
        this.setStroke(stroke);
        this.setHoverStroke(new dvt.Stroke(innerColor, 1, 1), new dvt.Stroke(hoverColor, 1, 3.5));
        this.setSelectedStroke(
          new dvt.Stroke(innerColor, 1, 1.5),
          new dvt.Stroke(outerColor, 1, 4.5)
        );
        this.setSelectedHoverStroke(
          new dvt.Stroke(innerColor, 1, 1.5),
          new dvt.Stroke(hoverColor, 1, 4.5)
        );
      }
    }

    /**
     * @override
     */
    getDataColor() {
      return this._dataColor;
    }

    /**
     * @override
     */
    showHoverEffect() {
      if (this._isInvisible) {
        this.IsShowingHoverEffect = true;
        this.setStroke(this._hoverStroke);
      } else super.showHoverEffect();
    }

    /**
     * @override
     */
    hideHoverEffect() {
      if (this._isInvisible) {
        this.IsShowingHoverEffect = false;
        this.setStroke(
          this.isSelected() ? DvtChartLineMarker.SELECTED_STROKE : DvtChartLineMarker.DEFAULT_STROKE
        );
      } else super.hideHoverEffect();
    }

    /**
     * @override
     */
    setSelected(selected) {
      if (this._isInvisible) {
        if (this.IsSelected == selected) return;

        this.IsSelected = selected;
        if (this.isSelected()) {
          this.setFill(DvtChartLineMarker.SELECTED_FILL);
          this.setStroke(
            this.isHoverEffectShown() ? this._hoverStroke : DvtChartLineMarker.SELECTED_STROKE
          );
        } else {
          this.setInvisibleFill();
          this.setStroke(
            this.isHoverEffectShown() ? this._hoverStroke : DvtChartLineMarker.DEFAULT_STROKE
          );
        }
      } else super.setSelected(selected);
    }

    /**
     * @override
     */
    UpdateSelectionEffect() {
      if (!this._isInvisible) super.UpdateSelectionEffect();
    }

    /**
     * Returns the animation params for the marker.
     * @return {array} params
     */
    getAnimParams() {
      return [this._x1, this._y1, this._x2, this._y2];
    }

    /**
     * Updates the animation params for the marker.
     * @param {array} params
     */
    setAnimParams(params) {
      this._drawPath(params[0], params[1], params[2], params[3]);
    }

    /**
     * Returns whether the marker is invisible.
     * @return {boolean}
     */
    isInvisible() {
      return this._isInvisible;
    }

    /**
     * Returns the bounding box of the shape
     * @return {dvt.Rectangle} bbox
     */
    getBoundingBox() {
      return this.getBoundingBox1().getUnion(this.getBoundingBox2());
    }

    /**
     * Returns the bounding box of marker #1 (x1, y1)
     * @return {dvt.Rectangle} bbox
     */
    getBoundingBox1() {
      return new dvt.Rectangle(
        this._x1 - this._markerSize / 2,
        this._y1 - this._markerSize / 2,
        this._markerSize,
        this._markerSize
      );
    }

    /**
     * Returns the bounding box of marker #2 (x2, y2)
     * @return {dvt.Rectangle} bbox
     */
    getBoundingBox2() {
      return new dvt.Rectangle(
        this._x2 - this._markerSize / 2,
        this._y2 - this._markerSize / 2,
        this._markerSize,
        this._markerSize
      );
    }
  }

  /**
   *   Animation on Datachange functionality.
   *   @class
   */

  const DvtChartAnimOnDC = {
    /**
     * Creates a dvt.Playable that performs animation between a chart's data states.
     * @param {Chart} oldChart
     * @param {Chart} newChart
     * @param {string} type The animation type.
     * @param {number} duration The duration of the animation in seconds.
     * @param {dvt.Container} delContainer The container for adding the deleted objects.
     * @return {dvt.Playable}
     */
    createAnim: (oldChart, newChart, type, duration, delContainer) => {
      if (!DvtChartAnimOnDC._canAnimate(oldChart, newChart)) {
        return null;
      }

      var ctx = newChart.getCtx();

      // Build arrays of old and new data change handlers.
      var arOldList = [];
      var arNewList = [];
      if (DvtChartTypeUtils.isPie(newChart)) {
        arOldList.push(oldChart.pieChart);
        arNewList.push(newChart.pieChart);
      } else {
        DvtChartAnimOnDC._buildAnimLists(ctx, arOldList, oldChart, arNewList, newChart, duration);
      }

      //  Walk the datachange handler arrays, and create animators for risers
      //  that need to be updated/deleted/inserted.
      var playable;
      var handler = new dvt.DataAnimationHandler(ctx, delContainer);
      handler.constructAnimation(arOldList, arNewList);
      if (handler.getNumPlayables() > 0) playable = handler.getAnimation(true);

      // Animating the fade-in of data labels if they exist for this chart.
      var newLabels = newChart.getDataLabels();
      if (playable && newLabels.length > 0) {
        for (var i = 0; i < newLabels.length; i++) newLabels[i].setAlpha(0);
        playable = new dvt.SequentialPlayable(
          ctx,
          playable,
          new dvt.AnimFadeIn(ctx, newLabels, duration / 4)
        );
      }

      return playable;
    },

    /**
     * Builds two (supplied) arrays of data change handlers (such as {@link DvtChartDataChange3DBar}
     * for the old and new charts. Also creates this._Y1Animation list of gridline
     * playables if axis scale change.
     * @param {dvt.Context} ctx
     * @param {array} arOldList The array to fill in the old peers.
     * @param {Chart} oldChart
     * @param {array} arNewList The array to fill in the new peers.
     * @param {Chart} newChart
     * @param {number} duration Animation duration.
     * @private
     */
    _buildAnimLists: (ctx, arOldList, oldChart, arNewList, newChart, duration) => {
      //  Create a list of DC handlers in arOldPeers and arNewPeers for the old and new peers.
      var i, j;
      var ar = oldChart.getChartObjPeers();
      var aOut = arOldList; // start on old peers first
      var peer, obj, dch;
      var isDataFiltered = newChart.getCache().getFromCache('dataFiltered');

      for (i = 0; i < 2; i++) {
        // loop over old peers and new peers
        var barCount = {}; // keeps track of how many bars have been handled for each series
        var lineAreaCount = {}; // keeps track of areas and lines for areas
        for (j = 0; j < ar.length; j++) {
          peer = ar[j];

          obj = peer.getDisplayables()[0];
          dch = null;

          if (obj instanceof DvtChartFunnelSlice) {
            dch = new DvtChartDataChangeFunnelSlice(peer, duration, '/funnel');
          } else if (obj instanceof DvtChartPyramidSlice) {
            dch = new DvtChartDataChangePyramidSlice(peer, duration, '/pyramid');
          } else if (obj instanceof DvtChartBar || obj instanceof DvtChartPolarBar) {
            dch = new DvtChartDataChangeBar(peer, duration, '/bar');

            // When the bars are filtered, the groups that are rendered would vary depending on data, so we workaround by
            // animating the rendered bars based on the ordering, regardless of which group they belong to. Otherwise,
            // we'd see undesired insert/delete animations every time.
            // Note that this approach is only correct if the number of groups stays the same before and after the animation.
            if (isDataFiltered) {
              var series = peer.getSeries();
              barCount[series] = barCount[series] ? barCount[series] + 1 : 1;
              dch.setId(series + '/' + barCount[series] + '/bar');
            }
          } else if (obj instanceof DvtChartLineArea) {
            dch = new DvtChartDataChangeLineArea(peer, duration);
            var lineAreaId = dch.getId();
            lineAreaCount[lineAreaId] = lineAreaCount[lineAreaId] ? lineAreaCount[lineAreaId] + 1 : 1;
            dch.setId(lineAreaId + '/' + lineAreaCount[lineAreaId]);
          } else if (obj instanceof dvt.SimpleMarker) {
            // DvtChartLineMarker is invisible unless selected.
            if (obj instanceof DvtChartLineMarker && !obj.isSelected()) continue;

            dch = new DvtChartDataChangeMarker(peer, duration, '/marker');
          } else if (obj instanceof DvtChartRangeMarker) {
            if (obj.isInvisible() && !obj.isSelected()) continue;

            dch = new DvtChartDataChangeRangeMarker(peer, duration, '/rangeMarker');
          } else if (obj instanceof DvtChartCandlestick) {
            dch = new DvtChartDataChangeHandler(peer, duration);
          } else if (obj instanceof DvtChartBoxAndWhisker) {
            dch = new DvtChartDataChangeHandler(peer, duration, '/boxAndWhisker');
          }

          if (dch) {
            aOut.push(dch);
            dch.setOldChart(oldChart);
          }
        }

        // repeat on the new chart's peer
        aOut = arNewList;
        ar = newChart.getChartObjPeers();
      }
    },

    /**
     * Checks if animation between the two charts is possible.
     * @param {Chart} oldChart
     * @param {Chart} newChart
     * @return {boolean} true if animation can be performed, else false.
     * @private
     */
    _canAnimate: (oldChart, newChart) => {
      //  Test for conditions for which we will not animate.
      if (DvtChartTypeUtils.isPie(oldChart) && DvtChartTypeUtils.isPie(newChart))
        return oldChart && newChart;
      else if (DvtChartTypeUtils.isPolar(oldChart) != DvtChartTypeUtils.isPolar(newChart))
        return false;
      else if (DvtChartTypeUtils.isBLAC(oldChart) && DvtChartTypeUtils.isBLAC(newChart)) return true;
      else if (
        DvtChartTypeUtils.isScatterBubble(oldChart) &&
        DvtChartTypeUtils.isScatterBubble(newChart)
      )
        return true;
      else if (oldChart.getType() == newChart.getType()) return true;
      else return false;
    }
  };

  /**
   *   Animation on Display funtionality.
   *   @class
   */
  const DvtChartAnimOnDisplay = {
    /**
     *  Creates a dvt.Playable that performs initial animation for a chart.
     *  @param {Chart} chart
     *  @param {string} type The animation type.
     *  @param {number} duration The duration of the animation in seconds.
     *  @return {dvt.Playable} The animation of the chart objects that are subject to animation.
     */
    createAnim: (chart, type, duration) => {
      var arPlayables = [];

      if (DvtChartTypeUtils.isBLAC(chart)) {
        DvtChartAnimOnDisplay._animBarLineArea(chart, duration, arPlayables);
      } else if (
        DvtChartTypeUtils.isScatterBubble(chart) ||
        DvtChartTypeUtils.isFunnel(chart) ||
        DvtChartTypeUtils.isPyramid(chart)
      ) {
        DvtChartAnimOnDisplay._animBubbleScatterFunnelPyramid(chart, duration, arPlayables);
      } else if (DvtChartTypeUtils.isPie(chart) && chart.pieChart) {
        // Delegate to the pie to create the animation.
        return chart.pieChart.getDisplayAnim();
      }

      return arPlayables.length > 0 ? new dvt.ParallelPlayable(chart.getCtx(), arPlayables) : null;
    },

    /**
     *  Adds a list of playables that animates the chart on initial display, for
     *  the bar and line/area components (including visible markers) to the
     *  supplied array.
     *  @param {Chart} chart
     *  @param {number} duration The duration of the animation in seconds.
     *  @param {Array} arPlayables The array to which the playables should be added.
     *  @private
     */
    _animBarLineArea: (chart, duration, arPlayables) => {
      var objs = chart.getChartObjPeers();
      var objCount = objs ? objs.length : 0;

      if (objCount) {
        var obj, peer;
        var nodePlayable;

        for (var i = 0; i < objCount; i++) {
          peer = objs[i];

          obj = peer.getDisplayables()[0];
          var seriesType = DvtChartDataUtils.getSeriesType(peer.getChart(), peer.getSeriesIndex());

          nodePlayable = null;
          if (
            obj instanceof DvtChartBar ||
            obj instanceof DvtChartPolarBar ||
            obj instanceof DvtChartCandlestick ||
            obj instanceof DvtChartBoxAndWhisker
          ) {
            nodePlayable = obj.getDisplayAnim(duration);
          } else if (obj instanceof DvtChartLineArea) {
            if (seriesType == 'line')
              nodePlayable = DvtChartAnimOnDisplay._getLinePlayable(chart, obj, duration);
            else nodePlayable = DvtChartAnimOnDisplay._getAreaPlayable(chart, obj, duration);
          } else if (obj instanceof dvt.SimpleMarker || obj instanceof DvtChartRangeMarker) {
            // DvtChartLineMarker is invisible unless selected.
            if (obj instanceof DvtChartLineMarker && !obj.isSelected()) continue;

            // Fade-in the marker near the end of the line/area animation
            nodePlayable = new dvt.AnimFadeIn(chart.getCtx(), obj, duration - 0.8, 0.8);
          }

          if (nodePlayable) {
            arPlayables.push(nodePlayable);
          }
        } // end for
      } // end if objs
    },

    /**
     *  Adds a list of playables that animates the chart on initial display, for
     *  the bubble, scatter, funnel and pyramid components to the supplied array.
     *  @param {Chart} chart
     *  @param {number} duration The duration of the animation in seconds.
     *  @param {Array} arPlayables The array to which the playables should be added.
     *  @private
     */
    _animBubbleScatterFunnelPyramid: (chart, duration, arPlayables) => {
      var objs = chart.getObjects();
      var objCount = objs ? objs.length : 0;

      if (objCount) {
        var obj, peer;
        var nodePlayable;

        for (var i = 0; i < objCount; i++) {
          peer = objs[i];
          obj = peer.getDisplayables()[0];

          if (obj instanceof dvt.SimpleMarker)
            nodePlayable = new dvt.AnimPopIn(chart.getCtx(), obj, true, duration);
          else if (obj instanceof DvtChartFunnelSlice || obj instanceof DvtChartPyramidSlice) {
            nodePlayable = DvtChartAnimOnDisplay._getFunnelPyramidPlayable(chart, obj, duration);
          }

          if (nodePlayable) arPlayables.push(nodePlayable);
        }
      }
    },

    /**
     *   Returns a dvt.Playable representing the animation of an area polygon
     *   to its initial data value.
     *   @param {Chart} chart
     *   @param {DvtChartLineArea} shape  the area shape to be animated.
     *   @param {number} duration The duration of the animation in seconds.
     *   @return {dvt.Playable} a playable representing the animation of the area to its initial data value.
     *   @private
     */
    _getAreaPlayable: (chart, shape, duration) => {
      var context = chart.getCtx();
      var baselineCoord = shape.getBaseline();

      // Create animation for the area base
      var baseAnim;
      if (shape.isArea()) {
        var baseCoords = shape.getBaseCoords();
        var baseParams = shape.getBaseAnimParams();
        var baseEndState = baseParams.slice(0); // copy, we will update the original
        for (var j = 0; j < baseParams.length; j++) {
          if (j % 4 == 1 || j % 4 == 2)
            // y1 or y2
            baseParams[j] = baselineCoord;
        }
        shape.setBaseAnimParams(baseParams); // set initial position
        baseAnim = new dvt.CustomAnimation(context, shape, duration);
        baseAnim
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            shape,
            shape.getBaseAnimParams,
            shape.setBaseAnimParams,
            baseEndState
          );
      }

      // Create animation for the area top
      var coords = shape.getCoords();
      var params = shape.getAnimParams();
      var endState = params.slice(0); // copy, we will update the original
      for (var j = 0; j < params.length; j++) {
        if (j % 4 == 1 || j % 4 == 2)
          // y1 or y2
          params[j] = baselineCoord;
      }
      shape.setAnimParams(params); // set initial position
      var topAnim = new dvt.CustomAnimation(context, shape, duration);
      topAnim
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          shape,
          shape.getAnimParams,
          shape.setAnimParams,
          endState
        );

      // Combine the top and base animation
      var nodePlayable = new dvt.ParallelPlayable(chart.getCtx(), baseAnim, topAnim);
      nodePlayable.setOnEnd(() => {
        shape.setCoords(coords, baseCoords);
      });

      return nodePlayable;
    },

    /**
     *   Returns a dvt.Playable representing the animation of a funnel or pyramid slice to
     *   its initial data value and location.
     *   @param {Chart} chart
     *   @param {DvtChartFunnelSlice|DvtChartPyramidSlice} slice  The funnel or pyramid slice to be animated.
     *   @param {number} duration The duration of the animation in seconds.
     *   @return {dvt.Playable} a playable representing the animation of the slice polygon to its initial data value.
     *   @private
     */
    _getFunnelPyramidPlayable: (chart, slice, duration) => {
      var context = chart.getCtx();
      var arPoints = slice.getAnimParams();
      var endState1 = arPoints.slice(0);
      var endState2 = arPoints.slice(0); // copy, we will update the original
      arPoints[0] = 0;
      if (DvtChartTypeUtils.isFunnel(chart)) {
        arPoints[2] = 0;
        endState1[2] = 0;
      }

      slice.setAnimParams(arPoints); // set initial position
      var nodePlayable1 = new dvt.CustomAnimation(context, slice, duration / 2);
      nodePlayable1
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          slice,
          slice.getAnimParams,
          slice.setAnimParams,
          endState1
        );
      var nodePlayable2 = new dvt.CustomAnimation(context, slice, duration / 2);
      nodePlayable2
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          slice,
          slice.getAnimParams,
          slice.setAnimParams,
          endState2
        );

      return new dvt.SequentialPlayable(context, [nodePlayable1, nodePlayable2]);
    },

    /**
     *   Returns a dvt.Playable representing the animation of the line to
     *   its initial data value.
     *   @param {Chart} chart
     *   @param {DvtChartLineArea} line  the line shape to be animated.
     *   @param {number} duration The duration of the animation in seconds.
     *   @return {dvt.Playable} a playable representing the animation of the line to its initial data value.
     *   @private
     */
    _getLinePlayable: (chart, line, duration) => {
      var coords = line.getCoords();
      var params = line.getAnimParams();
      var endState = params.slice(0); // copy, we will update the original
      DvtChartAnimOnDisplay._getMeanPoints(params); // update params to initial coords
      line.setAnimParams(params); // set initial position

      var nodePlayable = new dvt.CustomAnimation(chart.getCtx(), line, duration);
      nodePlayable
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          line,
          line.getAnimParams,
          line.setAnimParams,
          endState
        );
      nodePlayable.setOnEnd(() => {
        line.setCoords(coords);
      });
      return nodePlayable;
    },

    /**
     * Updates the supplied array of line coordinates to reflect the mean x or y position of the line data.
     * @param {array} params  The line animation parameters; should be positive values for plot area coordinate points
     * @private
     */
    _getMeanPoints: (params) => {
      var mean = 0;
      var min = Number.MAX_VALUE;
      var max = -1 * Number.MAX_VALUE;
      var len = params.length;
      var i;

      for (i = 0; i < len; i++) {
        // find largest and smallest y-values
        var v = params[i];
        if (i % 4 == 0 || i % 4 == 3 || v == Infinity)
          // x value or groupIndex
          continue;
        if (v < min) min = v;
        if (v > max) max = v;
        mean += v;
      }

      // if more than 2 data points, discard smallest and largest values to get a generally more representative mean.
      if (len > 8) {
        mean -= 2 * min;
        mean -= 2 * max;
        mean /= len / 2 - 4;
      } else mean /= len / 2;

      for (i = 0; i < len; i++) {
        if (i % 4 == 1 || i % 4 == 2)
          // y1 or y2
          params[i] = mean;
      }
    }
  };

  /**
   * Calculated axis information and drawable creation for a data axis.
   * @param {dvt.Context} context
   * @param {object} options The object containing specifications and data for this component.
   * @param {dvt.Rectangle} availSpace The available space.
   * @class
   * @constructor
   * @extends {DvtAxisInfo}
   */
  class DvtDataAxisInfo extends ojdvtAxis.DataAxisInfoMixin(DvtAxisInfo) {
    /**
     * Returns the value correspoding to the first tick label (or gridline) of the axis.
     * @return {number} The value of the min label.
     */
    getMinLabel() {
      if (
        this.ZeroBaseline ||
        (this.Options['_continuousExtent'] == 'on' && this.Options['min'] == null)
      ) {
        // the tickLabels and gridlines should be at integer intervals from zero
        return Math.ceil(this.LinearMinValue / this.MajorIncrement) * this.MajorIncrement;
      }
      // the tickLabels and gridlines should be at integer intervals from the globalMin
      return (
        Math.ceil((this.LinearMinValue - this.LinearGlobalMin) / this.MajorIncrement) *
          this.MajorIncrement +
        this.LinearGlobalMin
      );
    }

    /**
     * @override
     */
    getLabels(context, levelIdx) {
      if (levelIdx && levelIdx > 0)
        // data axis has only one level
        return null;

      var labels = this.getAllLabels(context);
      var labelDims = [];
      var container = context.getStage();

      if (this.Position != 'tangential') {
        labelDims = this.GetLabelDims(labels, container);
        labels = this.SkipLabels(labels, labelDims);
      }

      return labels;
    }

    /**
     * Returns an array of either strings or dvt.OutputTexts containing all the tick labels for this axis.
     *
     * @param {dvt.Context} context
     * @param {Boolean} asString If true, function will return array of label strings and dvt.OutputText objects otherwise
     * @return {Array} An array of label strings or dvt.OutputText objects
     */
    getAllLabels(context, asString) {
      var labels = [];

      // when scaling is set then init formatter
      if (this.Options['tickLabel'] && this.Options['tickLabel']['scaling']) {
        var autoPrecision = this.Options['tickLabel']['autoPrecision']
          ? this.Options['tickLabel']['autoPrecision']
          : 'on';
        this._axisValueFormatter = new ojdvtAxis.LinearScaleAxisValueFormatter(
          this.LinearMinValue,
          this.LinearMaxValue,
          this.MajorIncrement,
          this.Options['tickLabel']['scaling'],
          autoPrecision,
          this.Options.translations
        );
      }

      // Iterate on an integer to reduce rounding error.  We use <= since the first
      // tick is not counted in the tick count.
      for (var i = 0; i <= this.MajorTickCount; i++) {
        var value = i * this.MajorIncrement + this.getMinLabel();
        if (value - this.LinearMaxValue > this.MAJOR_TICK_INCREMENT_BUFFER)
          // Use buffer to address js arithmetic inaccurracy
          break;

        var coord = this.GetUnboundedCoordAt(value);
        if (this.Options['_skipHighestTick']) {
          if (value == this.LinearMaxValue) continue;
          if (
            this.Position != 'tangential' &&
            Math.abs(coord - this.MaxCoord) < this.getTickLabelHeight()
          )
            continue;
        }

        var label;
        if (this.IsLog) {
          // for log scale, format each label individually as the scaling don't need to match across labels
          value = this.linearToActual(value);
          this._axisValueFormatter = new ojdvtAxis.LinearScaleAxisValueFormatter(
            value,
            value,
            value,
            this.Options['tickLabel']['scaling'],
            autoPrecision,
            this.Options.translations
          );
          label = this._formatValue(value);
        } else label = this._formatValue(value);

        if (asString) labels.push(label);
        else labels.push(this.CreateLabel(context, label, coord));
      }

      return labels;
    }

    /**
     * @override
     */
    getMajorTickCoords() {
      var coords = [];

      // Iterate on an integer to reduce rounding error.  We use <= since the first
      // tick is not counted in the tick count.
      for (var i = 0; i <= this.MajorTickCount; i++) {
        var value = i * this.MajorIncrement + this.getMinLabel();
        if (value - this.LinearMaxValue > this.MAJOR_TICK_INCREMENT_BUFFER)
          // Use buffer to address js arithmetic inaccurracy
          break;
        if (this.Options['_skipHighestTick'] && value == this.LinearMaxValue) continue;

        var coord = this.GetUnboundedCoordAt(value);
        coords.push(coord);
      }

      return coords;
    }

    /**
     * @override
     */
    getMinorTickCoords() {
      var coords = [];

      // Iterate on an integer to reduce rounding error.  We use <= since the first
      // tick is not counted in the tick count.
      // Start from i=-1 so that minorTicks that should get rendered before the first majorTick are evaluated
      for (var i = -1; i <= this.MajorTickCount; i++) {
        var value = i * this.MajorIncrement + this.getMinLabel();
        if (this.IsLog && this.MajorIncrement == 1 && this.MinorIncrement == 1) {
          // draw linear ticks from 2 to 9
          for (var j = 2; j <= 9; j++) {
            var linearValue = value + dvt.Math.log10(j);
            if (linearValue > this.LinearMaxValue) break;
            if (linearValue < this.LinearMinValue) continue;

            coord = this.GetUnboundedCoordAt(linearValue);
            coords.push(coord);
          }
        } else {
          for (var j = 1; j < this.MinorTickCount; j++) {
            var minorValue = value + j * this.MinorIncrement;
            if (minorValue > this.LinearMaxValue) break;
            if (minorValue < this.LinearMinValue) continue;

            var coord = this.GetUnboundedCoordAt(minorValue);
            coords.push(coord);
          }
        }
      }
      return coords;
    }

    /**
     * @param {number} value
     * @return {string} Formatted value.
     * @private
     */
    _formatValue(value) {
      if (this.Converter && this.Converter['format']) {
        if (this._axisValueFormatter) return this._axisValueFormatter.format(value, this.Converter);
        return this.Converter['format'](value);
      } else if (this._axisValueFormatter) return this._axisValueFormatter.format(value);

      // set the # of decimals of the value to the # of decimals of the major increment
      var t = dvt.Math.log10(this.MajorIncrement);
      var decimals = Math.max(Math.ceil(-t), 0);
      return value.toFixed(decimals);
    }

    /**
     * @override
     */
    getMajorTickCount() {
      return this.MajorTickCount;
    }

    /**
     * @override
     */
    getMinorTickCount() {
      return this.MinorTickCount;
    }

    /**
     * @override
     */
    getMajorIncrement() {
      return this.linearToActual(this.MajorIncrement);
    }

    /**
     * @override
     */
    getMinorIncrement() {
      return this.linearToActual(this.MinorIncrement);
    }

    /**
     * @override
     */
    getMinExtent() {
      return (this.LinearGlobalMax - this.LinearGlobalMin) / DvtDataAxisInfo.MAX_ZOOM;
    }

    /**
     * @override
     */
    getStartOverflow() {
      if (
        (this.Position == 'top' || this.Position == 'bottom') &&
        dvt.Agent.isRightToLeft(this.getCtx())
      )
        return this.EndOverflow;
      return this.StartOverflow;
    }

    /**
     * @override
     */
    getEndOverflow() {
      if (
        (this.Position == 'top' || this.Position == 'bottom') &&
        dvt.Agent.isRightToLeft(this.getCtx())
      )
        return this.StartOverflow;
      return this.EndOverflow;
    }

    /**
     * @override
     */
    alignLogScaleToTickCount(scaleUnit, tickCount) {
      // only applies to log axis
      if (this.IsLog) {
        var currentMajorTickCount = this.getMajorTickCount();

        // increase the scale unit until we can fit the data into the given number of tick counts
        while (tickCount < currentMajorTickCount) {
          // reset values before recalculation
          this.MajorIncrement = null;
          this.MajorTickCount = null;
          this.MinorIncrement = null;
          this.MinorTickCount = null;

          scaleUnit++;
          this.CalcMajorMinorIncr(scaleUnit);
          currentMajorTickCount = this.getMajorTickCount();
        }
      }

      return scaleUnit;
    }

    /**
     * @override
     */
    getLogScaleUnit() {
      return this.LogScaleUnit;
    }
  }

  DvtAxisInfo.registerConstructor('data', DvtDataAxisInfo);

  /** @private @const */
  DvtDataAxisInfo.MAX_ZOOM = 64;

  /**
   * Calculated axis information and drawable creation for a time axis.
   * @param {dvt.Context} context
   * @param {object} options The object containing specifications and data for this component.
   * @param {dvt.Rectangle} availSpace The available space.
   * @class
   * @constructor
   * @extends {DvtAxisInfo}
   */

  class DvtTimeAxisInfo extends DvtAxisInfo {
    constructor(context, options, availSpace) {
      super(context, options, availSpace);

      // Figure out the coords for the min/max values
      if (this.Position == 'top' || this.Position == 'bottom') {
        // Provide at least the minimum buffer at each side to accommodate labels
        if (!options['_isOverview'] && options['tickLabel']['rendered'] == 'on') {
          this.StartOverflow = Math.max(ojdvtAxis.BaseAxisInfo.MIN_AXIS_BUFFER - options['leftBuffer'], 0);
          this.EndOverflow = Math.max(ojdvtAxis.BaseAxisInfo.MIN_AXIS_BUFFER - options['rightBuffer'], 0);
        }

        // Axis is horizontal, so flip for BIDI if needed
        if (dvt.Agent.isRightToLeft(context)) {
          this._startCoord = this.EndCoord - this.EndOverflow;
          this._endCoord = this.StartCoord + this.StartOverflow;
        } else {
          this._startCoord = this.StartCoord + this.StartOverflow;
          this._endCoord = this.EndCoord - this.EndOverflow;
        }
      } else {
        // Vertical axis should go from top to bottom
        this._startCoord = this.StartCoord;
        this._endCoord = this.EndCoord;
      }

      var converter = options['tickLabel'] != null ? options['tickLabel']['converter'] : null;
      this._label1Converter = converter && converter[0] ? converter[0] : converter;
      this._label2Converter = converter && converter[1] ? converter[1] : null;
      this._dateToIsoWithTimeZoneConverter =
        context.getLocaleHelpers()['dateToIsoWithTimeZoneConverter'];

      this._groups = options['groups'];

      var timeAxisType = options['timeAxisType'];
      this._skipGaps = timeAxisType == 'skipGaps';
      this._mixedFrequency = timeAxisType == 'mixedFrequency';

      this.DataMin = options['dataMin'];
      this.DataMax = options['dataMax'];

      if (this._groups.length > 1)
        this._averageInterval = (this.DataMax - this.DataMin) / (this._groups.length - 1);
      else if (this.DataMax - this.DataMin > 0) this._averageInterval = this.DataMax - this.DataMin;
      else this._averageInterval = 6 * DvtTimeAxisInfo.TIME_MINUTE; // to get the time axis to show YMDHM information
      this._step = options['step'];

      // Calculate the increment and add offsets if specified
      var endOffset =
        options['endGroupOffset'] > 0 ? options['endGroupOffset'] * this._averageInterval : 0;
      var startOffset =
        options['startGroupOffset'] > 0 ? options['startGroupOffset'] * this._averageInterval : 0;

      this.GlobalMin = options['min'] != null ? options['min'] : this.DataMin - startOffset;
      this.GlobalMax = options['max'] != null ? options['max'] : this.DataMax + endOffset;

      // Set min/max by start/endGroup
      if (options['viewportStartGroup'] != null)
        this.MinValue = options['viewportStartGroup'] - startOffset;
      if (options['viewportEndGroup'] != null)
        this.MaxValue = options['viewportEndGroup'] + endOffset;

      // Set min/max by viewport min/max
      if (options['viewportMin'] != null) this.MinValue = options['viewportMin'];
      if (options['viewportMax'] != null) this.MaxValue = options['viewportMax'];

      // If min/max is still undefined, fall back to global min/max
      if (this.MinValue == null) this.MinValue = this.GlobalMin;
      if (this.MaxValue == null) this.MaxValue = this.GlobalMax;

      if (this.GlobalMin > this.MinValue) this.GlobalMin = this.MinValue;
      if (this.GlobalMax < this.MaxValue) this.GlobalMax = this.MaxValue;

      this._timeRange = this.MaxValue - this.MinValue;

      this._level1Labels = null;
      this._level2Labels = null;
      // Coordinates of labels need to be stored for gridline rendering
      this._level1Coords = null;
      this._level2Coords = null;
      this._isOneLevel = true;

      // Overflow of labels need to be stored for attempting to align level1 & level2 labels
      this._level1Overflow = [];
      this._level2Overflow = [];

      this._locale = options['_locale'].toLowerCase();

      this._monthResources = context.LocaleData.getMonthNames('abbreviated');
    }

    /**
     * Formats the label given an axis value (used for generating tooltips).
     * @param {Number} axisValue The axis value (in milliseconds)
     * @return {String} A formatted axis label
     */
    formatLabel(axisValue) {
      var date = new Date(axisValue);
      var twoLabels = this._formatAxisLabel(date, null, true);
      if (twoLabels[1] != null) {
        if (
          DvtTimeAxisInfo._getDMYOrder(this._locale) == 'YMD' ||
          (this._timeRange < DvtTimeAxisInfo.TIME_MONTH_MIN && this._step < DvtTimeAxisInfo.TIME_DAY)
        )
          // time showing HH:MM:SS or YMD order
          return twoLabels[1] + ' ' + twoLabels[0];
        else return twoLabels[0] + ' ' + twoLabels[1];
      } else return twoLabels[0];
    }

    /**
     * Calculates the level of granularity in the data
     * @return {Number} The level of granularity (Eg. Second, Minute, Hour, Day, Month, Year)
     *                  represented in milliseconds.
     * @private
     */
    _calculateGranularity() {
      if (
        this._step >= DvtTimeAxisInfo.TIME_YEAR_MIN ||
        this._timeRange >= 6 * DvtTimeAxisInfo.TIME_YEAR_MIN
      )
        return DvtTimeAxisInfo.TIME_YEAR_MIN;

      if (
        this._step >= DvtTimeAxisInfo.TIME_MONTH_MIN ||
        this._timeRange >= 6 * DvtTimeAxisInfo.TIME_MONTH_MIN
      )
        return DvtTimeAxisInfo.TIME_MONTH_MIN;

      if (this._step >= DvtTimeAxisInfo.TIME_DAY || this._timeRange >= 6 * DvtTimeAxisInfo.TIME_DAY)
        return DvtTimeAxisInfo.TIME_DAY;

      if (this._step >= DvtTimeAxisInfo.TIME_HOUR || this._timeRange >= 6 * DvtTimeAxisInfo.TIME_HOUR)
        return DvtTimeAxisInfo.TIME_HOUR;

      if (
        this._step >= DvtTimeAxisInfo.TIME_MINUTE ||
        this._timeRange >= 6 * DvtTimeAxisInfo.TIME_MINUTE
      )
        return DvtTimeAxisInfo.TIME_MINUTE;

      return DvtTimeAxisInfo.TIME_SECOND;
    }

    /**
     * Formats the given date with the given converter
     * @param {Date} date The current date
     * @param {Date} prevDate The date of the previous set of labels
     * @param {Object} converter The converter
     * @return {String} An axis label
     * @private
     */
    _formatAxisLabelWithConverter(date, prevDate, converter) {
      if (converter) {
        var label = null;
        var prevLabel = null;

        if (converter['format']) {
          label = converter['format'](
            this._dateToIsoWithTimeZoneConverter && date
              ? this._dateToIsoWithTimeZoneConverter(date)
              : date
          );
          prevLabel = converter['format'](
            this._dateToIsoWithTimeZoneConverter && prevDate
              ? this._dateToIsoWithTimeZoneConverter(prevDate)
              : prevDate
          );
        }
        if (prevLabel !== label || label == null) {
          return label;
        }

        if (!converter.resolvedOptions) {
          return null;
        }
        // JET-36468: do not skip label when it is same as prevLabel checking for granularity
        // for eg. if June and July both convert to 'J' and granularity is TIME_MONTH_MIN, we want to keep both 'J's
        // for eg. if Saturday and Sunday both convert to 'S' and granularity is TIME_MONTH_DAY, we want to keep both 'S's
        var granularity = this._calculateGranularity();
        if (
          granularity === DvtTimeAxisInfo.TIME_MONTH_MIN &&
          prevDate.getMonth() !== date.getMonth() &&
          converter.resolvedOptions()['month'] != undefined
        ) {
          return label;
        } else if (
          granularity === DvtTimeAxisInfo.TIME_DAY &&
          prevDate.getDate() !== date.getDate() &&
          converter.resolvedOptions()['day'] != undefined
        ) {
          return label;
        }

        return null;
      }
    }

    /**
     * Formats the level 1 and level 2 axis labels
     * @param {Date} date The current date
     * @param {Date} prevDate The date of the previous set of labels
     * @param {boolean} bOneLabel Whether we want to show only one label. Used for tooltip to get correct order for MDY
     * @return {Array} An array [level1Label, level2Label]
     * @private
     */
    _formatAxisLabel(date, prevDate, bOneLabel) {
      var label1 = null; // level 1 label
      var label2 = null; // level 2 label
      var isVert = this.Position == 'left' || this.Position == 'right';
      var granularity = this._calculateGranularity();

      // If dateTimeFormatter is used, use it
      if (this._label1Converter || this._label2Converter) {
        if (this._label1Converter)
          label1 = this._formatAxisLabelWithConverter(date, prevDate, this._label1Converter);
        if (this._label2Converter)
          label2 = this._formatAxisLabelWithConverter(date, prevDate, this._label2Converter);

        return [label1, label2];
      }

      if (granularity === DvtTimeAxisInfo.TIME_YEAR_MIN) {
        label1 = this._formatDate(date, false, false, true); // Year
      } else if (granularity === DvtTimeAxisInfo.TIME_MONTH_MIN) {
        if (prevDate == null || prevDate.getMonth() != date.getMonth())
          label1 = this._formatDate(date, false, true, false); // Month

        if (prevDate == null || prevDate.getYear() != date.getYear())
          label2 = this._formatDate(date, false, false, true); // Year
      } else if (granularity === DvtTimeAxisInfo.TIME_DAY) {
        if (bOneLabel) {
          label1 = this._formatDate(date, true, true, true); // Day, Month, Year
        } else {
          if (prevDate == null || prevDate.getDate() != date.getDate())
            label1 = this._formatDate(date, true, false, false); // Day

          if (prevDate == null || prevDate.getYear() != date.getYear())
            label2 = this._formatDate(date, false, true, true); // Year, Month
          else if (prevDate.getMonth() != date.getMonth())
            label2 = this._formatDate(date, false, true, false); // Month
        }
      } else {
        if (granularity === DvtTimeAxisInfo.TIME_HOUR) {
          if (prevDate == null || prevDate.getHours() != date.getHours())
            label1 = this._formatTime(date, false, false); // HH AM/PM or HH:MM
        } else if (granularity === DvtTimeAxisInfo.TIME_MINUTE) {
          if (prevDate == null || prevDate.getMinutes() != date.getMinutes())
            label1 = this._formatTime(date, true, false); // HH:MM
        } else {
          if (prevDate == null || prevDate.getSeconds() != date.getSeconds())
            label1 = this._formatTime(date, true, true); // HH:MM:SS
        }

        if (isVert) {
          if (prevDate == null || prevDate.getDate() != date.getDate())
            label2 = this._formatDate(date, true, true, false); // Month, Day
        } else {
          if (prevDate == null || prevDate.getYear() != date.getYear())
            label2 = this._formatDate(date, true, true, true); // Year, Month, Day
          else if (prevDate.getMonth() != date.getMonth())
            label2 = this._formatDate(date, true, true, false); // Month, Day
          else if (prevDate.getDate() != date.getDate())
            label2 = this._formatDate(date, true, false, false); // Day
        }
      }

      return [label1, label2];
    }

    /**
     * Returns the date as a DMY string
     * @param {Date} date The date
     * @param {boolean} showDay Whether the day is shown
     * @param {boolean} showMonth Whether the month is shown
     * @param {boolean} showYear Whether the year is shown
     * @return {string} The formatted string
     * @private
     */
    _formatDate(date, showDay, showMonth, showYear) {
      // . Manually add 543 years to the Gregorian year if using a Thai locale.
      // Should use date.toLocaleDateString once it's available on Safari
      var yearStr = date.getFullYear();

      var monthStr;
      if (this._monthResources && this._monthResources.length >= 12)
        monthStr = this._monthResources[date.getMonth()];
      else monthStr = date.toString().split(' ')[1]; // date.toString() returns "Day Mon Date HH:MM:SS TZD YYYY"
      var dayStr = date.getDate();

      // Add the day and year trailing characters if needed
      // These will be "" if not needed
      yearStr += DvtTimeAxisInfo._getYearTrailingCharacters(this._locale);
      dayStr += DvtTimeAxisInfo._getDayTrailingCharacters(this._locale);

      // Process the DMY Order
      var dmyOrder = DvtTimeAxisInfo._getDMYOrder(this._locale);

      var dateStr = '';

      for (var i = 0; i < dmyOrder.length; i++) {
        if (showDay && dmyOrder[i] == 'D') {
          dateStr += dayStr + ' ';
        } else if (showMonth && dmyOrder[i] == 'M') {
          dateStr += monthStr + ' ';
        } else if (showYear && dmyOrder[i] == 'Y') {
          dateStr += yearStr + ' ';
        }
      }

      return dateStr.length > 0 ? dateStr.slice(0, dateStr.length - 1) : dateStr;
    }

    /**
     * Returns the date as an HH:MM:SS string
     * @param {Date} date The date
     * @param {boolean} showMinute Whether the minute is shown
     * @param {boolean} showSecond Whether the second is shown
     * @return {string} The formatted string
     * @private
     */
    _formatTime(date, showMinute, showSecond) {
      var hours = date.getHours();
      var mins = date.getMinutes();
      var secs = date.getSeconds();

      var am = DvtTimeAxisInfo._getAMString(this._locale);
      var pm = DvtTimeAxisInfo._getPMString(this._locale);
      var ampmBefore = DvtTimeAxisInfo._getAMPMBefore(this._locale);

      var b12HFormat = am != '' && pm != '';
      var ampm;
      var timeLabel = '';

      if (dvt.Agent.isRightToLeft(this.getCtx())) timeLabel = '\u200F';

      if (b12HFormat) {
        if (hours < 12) {
          ampm = am;
          if (hours == 0) hours = 12;
        } else {
          ampm = pm;
          if (hours > 12) hours -= 12;
        }
        timeLabel += hours;

        if (showMinute || mins != 0) timeLabel += ':' + this._doubleDigit(mins);
      } else timeLabel += this._doubleDigit(hours) + ':' + this._doubleDigit(mins);

      if (showSecond) {
        timeLabel += ':' + this._doubleDigit(secs);
      }

      if (b12HFormat) {
        if (ampmBefore) return ampm + ' ' + timeLabel;
        else return timeLabel + ' ' + ampm;
      } else {
        return timeLabel;
      }
    }

    /**
     * Creates a double-digit number string for the HH:MM:SS format
     * @param {Number} num A number less than 100
     * @return {String} A double-digit number string
     * @private
     */
    _doubleDigit(num) {
      if (num < 10) {
        return '0' + num;
      }
      return '' + num;
    }

    /**
     * Returns the time label interval for mixed frequency data.
     * Makes sure that the interval is a regular time unit.
     * @return {number} The interval.
     * @private
     */
    _getMixedFrequencyStep() {
      if (this._timeRange >= 6 * DvtTimeAxisInfo.TIME_YEAR_MIN) return DvtTimeAxisInfo.TIME_YEAR_MIN;
      if (this._timeRange >= 6 * DvtTimeAxisInfo.TIME_MONTH_MIN)
        return DvtTimeAxisInfo.TIME_MONTH_MIN;
      if (this._timeRange >= 6 * DvtTimeAxisInfo.TIME_DAY) return DvtTimeAxisInfo.TIME_DAY;
      if (this._timeRange >= DvtTimeAxisInfo.TIME_DAY) return 3 * DvtTimeAxisInfo.TIME_HOUR;
      if (this._timeRange >= 6 * DvtTimeAxisInfo.TIME_HOUR) return DvtTimeAxisInfo.TIME_HOUR;
      if (this._timeRange >= DvtTimeAxisInfo.TIME_HOUR) return 15 * DvtTimeAxisInfo.TIME_MINUTE;
      if (this._timeRange >= 30 * DvtTimeAxisInfo.TIME_MINUTE) return 5 * DvtTimeAxisInfo.TIME_MINUTE;
      if (this._timeRange >= 6 * DvtTimeAxisInfo.TIME_MINUTE) return DvtTimeAxisInfo.TIME_MINUTE;
      if (this._timeRange >= DvtTimeAxisInfo.TIME_MINUTE) return 15 * DvtTimeAxisInfo.TIME_SECOND;
      if (this._timeRange >= 30 * DvtTimeAxisInfo.TIME_SECOND) return 5 * DvtTimeAxisInfo.TIME_SECOND;
      return DvtTimeAxisInfo.TIME_SECOND;
    }

    /**
     * Generates the level 1 and level 2 tick labels
     * @param {dvt.Context} context
     * @private
     */
    _generateLabels(context) {
      var labels1 = [];
      var labels2 = [];
      var labelInfos1 = [];
      var coords1 = [];
      var coords2 = [];
      var prevDate = null;
      var c1 = 0; // number of level 1 labels
      var c2 = 0; // number of level 2 labels
      var container = context.getStage(context);
      var isRTL = dvt.Agent.isRightToLeft(context);
      var isVert = this.Position == 'left' || this.Position == 'right';
      var scrollable = this.Options['zoomAndScroll'] != 'off';
      var first = true;

      //  : On Chrome, creating a gap value to be used for spacing level1 labels and level2 labels
      var levelsGap = 0;
      if (isVert && dvt.Agent.engine === 'blink') {
        levelsGap = this.getTickLabelHeight() * 0.16;
      }

      // Find the time positions where labels are located
      var times = [];
      if (this._step != null) {
        times = DvtTimeAxisInfo._getLabelPos(this.MinValue, this.MaxValue, this._step);
      } else if (this._mixedFrequency) {
        this._step = this._getMixedFrequencyStep();
        times = DvtTimeAxisInfo._getLabelPos(this.MinValue, this.MaxValue, this._step);
      } else {
        for (var i = 0; i < this._groups.length; i++) {
          if (this._groups[i] >= this.MinValue && this._groups[i] <= this.MaxValue)
            times.push(this._groups[i]);
        }
        this._step = this._averageInterval;

        if (!this._skipGaps) {
          //  (30393656) MISSING '28' ON X AXIS FOR COORDINATE TO VALUE CONVERSION DEMO
          // Since the axis labels are obtained from the groups, it may miss a few values.
          // Find and treat the missing values before proceeding.
          times = DvtTimeAxisInfo._treatMissingValues(times, this._calculateGranularity());

          // Since the contents of the times array might have been updated, the step value should
          // be updated.
          // The step value is approximated to the estimated average of the intervals in the updated
          // times array.
          // It is safe to do so even when there were no missing values as it should not have any side-effects
          // on rendering the axis.
          // If there are less than 2 values in the times array, proceed with the existing step value.
          if (times.length > 1) {
            this._step = (times[times.length - 1] - times[0]) / (times.length - 1);
          }
          // Check the width of the first level1 label. If we expect that we'll have more group labels than we can fit in the
          // available space, then render the time labels at a regular interval (using mixed freq algorithm).
          var labelWidth;
          if (isVert)
            labelWidth = dvt.TextUtils.getTextStringHeight(
              context,
              this.Options['tickLabel']['style']
            );
          else {
            var firstLabelString = this._formatAxisLabel(new Date(times[0] || this.MinValue))[0];
            labelWidth = dvt.TextUtils.getTextStringWidth(
              context,
              firstLabelString,
              this.Options['tickLabel']['style']
            );
          }
          var totalWidth = (labelWidth + this.GetTickLabelGapSize()) * (times.length - 1);
          var availWidth = Math.abs(this._endCoord - this._startCoord);
          if (totalWidth > availWidth) {
            this._step = this._getMixedFrequencyStep();
            times = DvtTimeAxisInfo._getLabelPos(this.MinValue, this.MaxValue, this._step);
          }
        }
      }
      if (times.length === 0) times = [this.MinValue]; // render at least one label
      // Create and format the labels
      for (var i = 0; i < times.length; i++) {
        var time = times[i];
        var coord = this.getCoordAt(time);
        if (coord == null) continue;

        var date = new Date(time);
        var twoLabels = this._formatAxisLabel(date, prevDate);

        var label1 = twoLabels[0];
        var label2 = twoLabels[1];
        //level 1 label
        if (label1 != null) {
          // If level 2 exists put a levelsGap space between labels. levelsGap is only non-zero on Chrome.
          labelInfos1.push({ text: label1, coord: label2 != null ? coord + levelsGap : coord });
          coords1.push(coord);
          c1++;
        } else {
          labelInfos1.push(null);
          coords1.push(null);
        }
        // Defer label1 creation for now for performance optimization.
        // Only the labels we expect not to skip will be created in skipLabelsUniform().
        labels1.push(null);

        // Make sure that the position of first level2 label is constant if the chart is scrollable to prevent jumping around
        if (scrollable && first) coord = this.MinValue ? this.getCoordAt(this.MinValue) : coord;
        first = false;

        //level 2 label
        if (label2 != null) {
          var text = this.CreateLabel(context, label2, coord - levelsGap);
          coords2.push(coord);
          if (!isVert)
            //set alignment now in order to determine if the labels will overlap
            isRTL ? text.alignRight() : text.alignLeft();
          labels2.push(text);
          this._isOneLevel = false;
          c2++;
        } else {
          labels2.push(null);
          coords2.push(null);
        }

        prevDate = date;
      }

      // skip level 1 labels every uniform interval
      c1 = this._skipLabelsUniform(labelInfos1, labels1, container, false, isRTL);

      if (!scrollable && c2 > 1 && c1 < 1.5 * c2) {
        // too few level 1 labels
        labels1 = labels2;
        labels2 = null;
        // center align the new level1 labels
        for (var j = 0; j < labels1.length; j++) {
          if (labels1[j] != null) labels1[j].alignCenter();
        }
        c1 = this._skipLabelsGreedy(labels1, this.GetLabelDims(labels1, container), false, isRTL);
      } else {
        // skip level 2 labels greedily
        c2 = this._skipLabelsGreedy(labels2, this.GetLabelDims(labels2, container), true, isRTL);
        if (c2 == 0) labels2 = null; // null it so DvtAxisRenderer.getPreferredSize won't allocate space for it
      }

      if (isVert && labels2 != null) this._skipVertLabels(labels1, labels2, container);

      this._level1Labels = labels1;
      this._level2Labels = labels2;

      // Store coordinates of labels for gridline rendering
      this._level1Coords = coords1;
      this._level2Coords = coords2;
    }

    /**
     * Returns how much a label overflows outside of rendering bounds.
     * @param {Number} coord The current coordinate of a label
     * @param {Number} labelLength The length of a label
     * @param {boolean} isStartAligned Whether or not the labels are text-anchored start, assumes center alignment if false.
     * @param {boolean} isRTL Whether or not the context is right to left.
     * @return {Number} The label overflow
     * @private
     */
    _getLabelOverflow(coord, labelLength, isStartAligned, isRTL) {
      var minOverflow = coord - (isStartAligned ? (isRTL ? labelLength : 0) : labelLength * 0.5);
      if (minOverflow < this.Options['_minOverflowCoord'])
        // Negative overflow : Label overflows the beginning of the axis
        return Math.floor(minOverflow - this.Options['_minOverflowCoord']);

      var maxOverflow = coord + (isStartAligned ? (isRTL ? 0 : labelLength) : labelLength * 0.5);
      if (maxOverflow > this.Options['_maxOverflowCoord'])
        // Negative overflow : Label overflows the beginning of the axis
        return Math.ceil(maxOverflow - this.Options['_maxOverflowCoord']);

      return 0; // No overflow
    }

    /**
     * Skip labels greedily. Delete all labels that overlap with the last rendered label.
     * @param {Array} labels An array of dvt.Text labels for the axis. This array will be modified by the method.
     * @param {Array} labelDims An array of dvt.Rectangle objects that describe the x, y, height, width of the axis labels.
     * @param {boolean} isStartAligned Whether or not the labels are text-anchored start, assumes center alignment if false.
     * @param {boolean} isRTL Whether or not the context is right to left.
     * @return {Number} The number of remaining labels after skipping.
     * @private
     */
    _skipLabelsGreedy(labels, labelDims, isStartAligned, isRTL) {
      // If there are no labels, return
      if (!labelDims || labelDims.length <= 0) return false;

      var isVert = this.Position == 'left' || this.Position == 'right';
      var labelHeight = this.getTickLabelHeight();
      var gap = isVert ? labelHeight * 0.08 : labelHeight * 0.24;

      var count = 0; // the number of non-null labels
      var pointA1, pointA2, pointB1, pointB2;

      // Check for potential overflow
      var label;
      var availWidth = Math.abs(this._endCoord - this._startCoord); // The available width for the axis
      for (var j = 0; j < labelDims.length; j++) {
        this._level2Overflow.push(0);
        if (labels[j] != null) {
          label = labels[j];
          var labelLength = label.getDimensions().w;

          if (labelDims[j].w > availWidth) labels[j] = null;
          else {
            var overflow = this._getLabelOverflow(label.getX(), labelLength, isStartAligned, isRTL);
            this._level2Overflow[j] = overflow;
            if (overflow != 0) {
              label.setX(label.getX() - overflow); // move label
              labelDims[j].x -= overflow; // adjust recorded dims so skipping takes into account new label position
            }
          }
        }
      }

      for (j = 0; j < labelDims.length; j++) {
        if (labelDims[j] == null) continue;

        if (isVert) {
          pointB1 = labelDims[j].y;
          pointB2 = labelDims[j].y + labelDims[j].h;
        } else {
          pointB1 = labelDims[j].x;
          pointB2 = labelDims[j].x + labelDims[j].w;
        }

        if (
          pointA1 != null &&
          pointA2 != null &&
          DvtTimeAxisInfo._isOverlapping(pointA1, pointA2, pointB1, pointB2, gap)
        )
          labels[j] = null;

        if (labels[j] != null) {
          // start evaluating from label j
          pointA1 = pointB1;
          pointA2 = pointB2;
          count++;
        }
      }

      return count;
    }

    /**
     * Skip labels uniformly (every regular interval).
     * @param {array} labelInfos An array of object containing text (the label text string) and coord (the label coordinate).
     * @param {array} labels An array of dvt.OutputText labels for the axis (initially empty). This array will be populated by the method.
     * @param {dvt.Container} container The label container.
     * @param {boolean} isRTL Whether or not the context is right to left.
     * @return {number} The number of remaining labels after skipping.
     * @private
     */
    _skipLabelsUniform(labelInfos, labels, container, isRTL) {
      var rLabelInfos = []; // contains rendered labels only
      var rLabelDims = [];

      // The available width for the axis
      var availWidth = Math.abs(this._endCoord - this._startCoord);

      for (var j = 0; j < labelInfos.length; j++) {
        if (labelInfos[j] != null) {
          rLabelInfos.push(labelInfos[j]);
          rLabelDims.push(null);
          this._level1Overflow.push(0);
        }
      }

      // Method that returns the label size. If the label object doesn't exist yet, it will create it and measure the
      // dimensions. Otherwise, it simply returns the stored dimensions.
      var isVert = this.Position == 'left' || this.Position == 'right';
      var _this = this;
      var getDim = (i) => {
        if (rLabelDims[i] == null) {
          rLabelInfos[i].label = _this.CreateLabel(
            container.getCtx(),
            rLabelInfos[i].text,
            rLabelInfos[i].coord
          );
          rLabelDims[i] = rLabelInfos[i].label.getDimensions(container);

          if (rLabelDims[i].w > availWidth) {
            rLabelInfos[i].label = null;
            rLabelDims[i].w = 0;
            rLabelDims[i].h = 0;
          } else {
            var overflow = _this._getLabelOverflow(
              rLabelInfos[i].coord,
              rLabelDims[i].w,
              false,
              isRTL
            );
            if (overflow != 0) {
              rLabelInfos[i].coord -= overflow;
              rLabelDims[i].x -= overflow; // adjust recorded dims so skipping takes into account new label position
              rLabelInfos[i].label.setX(rLabelInfos[i].label.getX() - overflow);
              _this._level1Overflow[i] = overflow;
            }
          }
        }
        return isVert ? rLabelDims[i].h : rLabelDims[i].w;
      };

      // Estimate the minimum amount of skipping by dividing the total label width (estimated) by the
      // available axis width.
      var totalWidth = (getDim(0) + this.GetTickLabelGapSize()) * (rLabelInfos.length - 1);
      var skip = availWidth > 0 ? Math.ceil(totalWidth / availWidth) - 1 : 0;

      // Iterate to find the minimum amount of skipping
      var bOverlaps = true;
      while (bOverlaps) {
        for (var j = 0; j < rLabelInfos.length; j++) {
          if (j % (skip + 1) == 0) {
            getDim(j); // create the label and obtain the dim
            rLabelInfos[j].skipped = false;
          } else rLabelInfos[j].skipped = true;
        }
        bOverlaps = this.IsOverlapping(rLabelDims, skip);
        skip++;
      }

      // Populate the labels array with non-skipped labels
      var count = 0; // # of rendered labels
      for (var j = 0; j < labelInfos.length; j++) {
        if (labelInfos[j] != null && !labelInfos[j].skipped) {
          labels[j] = labelInfos[j].label;
          count++;
        }
      }
      return count;
    }

    /**
     * Format the alignments of the vertical axis labels and skip them accordingly so that level1 and level2 don't overlap.
     * @param {Array} labels1 An array of level 1 dvt.Text labels for the axis. This array will be modified by the method.
     * @param {Array} labels2 An array of level 2 dvt.Text labels for the axis. This array will be modified by the method.
     * @param {dvt.Container} container
     * @private
     */
    _skipVertLabels(labels1, labels2, container) {
      var gap = this.getTickLabelHeight() * 0.08;

      // returns if two rectangles (dimsA and dimsB) overlap vertically
      var isOverlapping = (dimsA, dimsB) => {
        return DvtTimeAxisInfo._isOverlapping(
          dimsA.y,
          dimsA.y + dimsA.h,
          dimsB.y,
          dimsB.y + dimsB.h,
          gap
        );
      };

      var lastDims = null;
      var overlapping = false;

      // attempt to render both level 1 and level 2 and see if they fit on the axis
      for (var i = 0; i < labels1.length; i++) {
        if (labels1[i] && labels2[i]) {
          labels1[i].alignTop();
          labels2[i].alignBottom();
          if (lastDims && isOverlapping(lastDims, labels2[i].getDimensions())) {
            overlapping = true;
            break;
          }
          lastDims = labels1[i].getDimensions();
        } else if (labels1[i] || labels2[i]) {
          var label = labels1[i] ? labels1[i] : labels2[i];
          if (lastDims && isOverlapping(lastDims, label.getDimensions())) {
            overlapping = true;
            break;
          }
          lastDims = label.getDimensions();
        }
      }

      if (!overlapping) return; // if both levels fit, we're done
      var lastLv1Idx = null;
      var lastLv1Dims = null;
      var lastLv2Dims = null;
      var dims;

      // if they don't fit:
      // - for points that have level 2 labels, don't generate the level 1 (one level nesting)
      // - skip all level 1 labels that overlaps with level 2 labels
      for (i = 0; i < labels1.length; i++) {
        if (labels2[i]) {
          // if level 2 exists
          labels1[i] = null; // delete level 1
          labels2[i].alignMiddle();
          dims = labels2[i].getDimensions();
          if (lastLv1Dims && isOverlapping(lastLv1Dims, dims)) {
            labels1[lastLv1Idx] = null;
          }
          lastLv2Dims = dims;
        } else if (labels1[i]) {
          // if level 1 exists but not level 2
          dims = labels1[i].getDimensions();
          if (lastLv2Dims && isOverlapping(lastLv2Dims, dims)) {
            labels1[i] = null;
          } else {
            lastLv1Dims = dims;
            lastLv1Idx = i;
          }
        }
      }
    }

    /**
     * @override
     */
    getLabels(context, levelIdx) {
      if (levelIdx && levelIdx > 1)
        // time axis has no more than two levels
        return null;

      if (!this._level1Labels) this._generateLabels(context);

      if (levelIdx == 1) {
        return this._level2Labels;
      }

      return this._level1Labels;
    }

    /**
     * @override
     */
    getMajorTickCoords() {
      var coords = [];
      if (this._isOneLevel) {
        // only one level, level1 is majorTick
        for (var i = 0; i < this._level1Coords.length; i++) {
          if (this._level1Coords[i] != null && this._level1Labels[i] != null)
            coords.push(this._level1Coords[i]);
        }
      } else {
        // level1 is minorTick, level2 is majorTick
        // don't draw majorTick for the first level2 label bc it's not the beginning of period
        for (var i = 1; i < this._level2Coords.length; i++) {
          if (this._level2Coords[i] != null) coords.push(this._level2Coords[i]); // render gridline even if label is skipped
        }
      }

      return coords;
    }

    /**
     * @override
     */
    getMinorTickCoords() {
      if (this._isOneLevel)
        // minorTick only applies on timeAxis if there is more than one level
        return [];

      var coords = [];
      for (var i = 0; i < this._level1Coords.length; i++) {
        if (this._level1Coords[i] != null && this._level1Labels[i] != null)
          coords.push(this._level1Coords[i]);
      }

      return coords;
    }

    /**
     * @override
     */
    getUnboundedValAt(coord) {
      if (coord == null) return null;

      var ratio = (coord - this._startCoord) / (this._endCoord - this._startCoord);

      if (this._skipGaps) {
        var minVal = this._timeToIndex(this.MinValue);
        var maxVal = this._timeToIndex(this.MaxValue);
        return this._indexToTime(minVal + ratio * (maxVal - minVal));
      } else return this.MinValue + ratio * (this.MaxValue - this.MinValue);
    }

    /**
     * @override
     */
    getUnboundedCoordAt(value) {
      if (value == null) return null;

      var ratio;
      if (this._skipGaps) {
        var minVal = this._timeToIndex(this.MinValue);
        var maxVal = this._timeToIndex(this.MaxValue);
        var val = this._timeToIndex(value);
        ratio = (val - minVal) / (maxVal - minVal);
      } else ratio = (value - this.MinValue) / (this.MaxValue - this.MinValue);

      return this._startCoord + ratio * (this._endCoord - this._startCoord);
    }

    /**
     * @override
     */
    linearToActual(value) {
      if (value == null) return null;
      return this._skipGaps ? this._indexToTime(value) : value;
    }

    /**
     * @override
     */
    actualToLinear(value) {
      if (value == null) return null;
      return this._skipGaps ? this._timeToIndex(value) : value;
    }

    /**
     * Converts time to group index for regular time axis.
     * @param {number} time
     * @return {number} index
     * @private
     */
    _timeToIndex(time) {
      var endIndex = this._groups.length;
      for (var i = 0; i < this._groups.length; i++) {
        if (time <= this._groups[i]) {
          endIndex = i;
          break;
        }
      }
      var startIndex = endIndex - 1;

      var startTime =
        this._groups[startIndex] !== undefined
          ? this._groups[startIndex]
          : this._groups[0] - this._averageInterval;
      var endTime =
        this._groups[endIndex] !== undefined
          ? this._groups[endIndex]
          : this._groups[this._groups.length - 1] + this._averageInterval;

      return startIndex + (time - startTime) / (endTime - startTime);
    }

    /**
     * Converts group index to time for regular time axis.
     * @param {number} index
     * @return {number} time
     * @private
     */
    _indexToTime(index) {
      var endIndex = Math.min(Math.max(Math.ceil(index), 0), this._groups.length);
      var startIndex = endIndex - 1;

      var startTime =
        this._groups[startIndex] !== undefined
          ? this._groups[startIndex]
          : this._groups[0] - this._averageInterval;
      var endTime =
        this._groups[endIndex] !== undefined
          ? this._groups[endIndex]
          : this._groups[this._groups.length - 1] + this._averageInterval;

      return startTime + (index - startIndex) * (endTime - startTime);
    }

    /**
     * @override
     */
    getGroupWidth() {
      if (this._skipGaps)
        return Math.abs(
          this.getUnboundedCoordAt(this._indexToTime(1)) -
            this.getUnboundedCoordAt(this._indexToTime(0))
        );
      else
        return Math.abs(
          this.getUnboundedCoordAt(this.MinValue + this._averageInterval) -
            this.getUnboundedCoordAt(this.MinValue)
        );
    }

    /**
     * @override
     */
    getMinExtent() {
      return this._skipGaps
        ? 1
        : this._mixedFrequency
        ? Math.min((this.getGlobalMax() - this.getGlobalMin()) / 8, this._averageInterval)
        : this._averageInterval;
    }

    /**
     * @override
     */
    getStartOverflow() {
      if (
        (this.Position == 'top' || this.Position == 'bottom') &&
        dvt.Agent.isRightToLeft(this.getCtx())
      )
        return this.EndOverflow;
      else return this.StartOverflow;
    }

    /**
     * @override
     */
    getEndOverflow() {
      if (
        (this.Position == 'top' || this.Position == 'bottom') &&
        dvt.Agent.isRightToLeft(this.getCtx())
      )
        return this.StartOverflow;
      else return this.EndOverflow;
    }

    /**
     * Returns the am string for this locale if applicable.
     * @param {String} locale the locale for the axis.
     * @return {String} the string representing "am"
     * @private
     */
    static _getAMString(locale) {
      var language = locale.substring(0, 2);
      if (locale == 'en-au' || locale == 'en-ie' || locale == 'en-ph') return 'am';
      else if (locale == 'en-gb') return '';
      switch (language) {
        case 'en':
          return 'AM';
        case 'ar':
          return '\u0635';
        case 'el':
          return '\u03c0\u03bc';
        case 'ko':
          return '\uc624\uc804';
        case 'zh':
          return '\u4e0a\u5348';
        default:
          return '';
      }
    }

    /**
     * Returns the pm string for this locale if applicable.
     * @param {String} locale the locale for the axis.
     * @return {String} the string representing "pm"
     * @private
     */
    static _getPMString(locale) {
      var language = locale.substring(0, 2);
      if (locale == 'en-au' || locale == 'en-ie' || locale == 'en-ph') return 'pm';
      else if (locale == 'en-gb') return '';
      switch (language) {
        case 'en':
          return 'PM';
        case 'ar':
          return '\u0645';
        case 'el':
          return '\u03bc\u03bc';
        case 'ko':
          return '\uc624\ud6c4';
        case 'zh':
          return '\u4e0b\u5348';
        default:
          return '';
      }
    }

    /**
     * Returns whether the AM/PM string should be displayed before or after the time string based on locale.
     * @param {String} locale the locale for the axis
     * @return {boolean} whether the AM/PM string before the time.
     * @private
     */
    static _getAMPMBefore(locale) {
      var language = locale.substring(0, 2);
      if (language == 'ko' || language == 'zh') return true;
      else return false;
    }

    /**
     * Returns the DMY order based on the locale
     * @param {String} locale the locale for the axis
     * @return {String} the order of date, month and year
     * @private
     */
    static _getDMYOrder(locale) {
      var language = locale.substring(0, 2);
      if (locale == 'en-us' || locale == 'en-ph') return 'MDY';
      else if (
        language == 'fa' ||
        language == 'hu' ||
        language == 'ja' ||
        language == 'ko' ||
        language == 'lt' ||
        language == 'mn' ||
        language == 'zh'
      )
        return 'YMD';
      else return 'DMY';
    }

    /**
     * Returns the trailing characters for the year
     * @param {String} locale the locale for the axis
     * @return {String} the year trailing character by locale
     * @private
     */
    static _getYearTrailingCharacters(locale) {
      if (locale.indexOf('ja') == 0 || locale.indexOf('zh') == 0) return '\u5e74';
      else if (locale.indexOf('ko') == 0) return '\ub144';
      else return '';
    }

    /**
     * Returns the trailing characters for the day
     * @param {String} locale the locale for the axis
     * @return {String} the day trailing character by locale
     * @private
     */
    static _getDayTrailingCharacters(locale) {
      if (locale.indexOf('ja') == 0 || locale.indexOf('zh') == 0) return '\u65e5';
      else if (locale.indexOf('ko') == 0) return '\uc77c';
      else return '';
    }

    /**
     * Returns the positions of time axis labels, given the start, end, and step
     * @param {number} start The start time of the axis.
     * @param {number} end The end time of the axis.
     * @param {number} step The increment between labels.
     * @return {array} A list of label positions.
     * @private
     */
    static _getLabelPos(start, end, step) {
      // The time positions has to be at even intervals from the beginning of a year (January 1, 12:00:00 AM), otherwise
      // we may have labels such as [2013, 2014, 2015, ...] that are drawn at [June 8 2013, June 8 2014, June 8 2015, ...],
      // which is data misrepresentation.
      var anchor = new Date(start);
      var initialTimezoneOffset = anchor.getTimezoneOffset();
      anchor.setMonth(0, 1); // January 1
      anchor.setHours(0, 0, 0, 0); // 00:00:00
      var time = anchor.getTime();

      var times = [];
      if (step >= DvtTimeAxisInfo.TIME_YEAR_MIN && step <= DvtTimeAxisInfo.TIME_YEAR_MAX) {
        // Assume that the step is one year, which can mean different # of days depending on the year
        while (time < start) time = DvtTimeAxisInfo._addOneYear(time);
        while (time <= end) {
          times.push(time);
          time = DvtTimeAxisInfo._addOneYear(time);
        }
      } else if (step >= DvtTimeAxisInfo.TIME_MONTH_MIN && step <= DvtTimeAxisInfo.TIME_MONTH_MAX) {
        // Assume that the step is one month, which can mean different # of days depending on the month
        while (time < start) time = DvtTimeAxisInfo._addOneMonth(time);
        while (time <= end) {
          times.push(time);
          time = DvtTimeAxisInfo._addOneMonth(time);
        }
      } else {
        // . Correction is needed due to daylight savings.
        // Only apply daylight correction when step is less than a month. Daylight savings does not impact any step higher than month.
        // JET-52348 - Ideally we should be using Date api to add and substract date offsets to calculate labels since
        // Date will automatically handle daylight savings. This approach should solve issues for steps greater than month but we could encounter
        // offsets in axis labels when dataset values are in different daylight savings and chart step is low (eg day or hour);
        var timezoneCorrection = (initialTimezoneOffset - anchor.getTimezoneOffset()) * 60 * 1000;
        var correction = step < DvtTimeAxisInfo.TIME_MONTH_MIN ? timezoneCorrection : 0;
        time += Math.ceil((start - time - correction) / step) * step + correction;
        while (time <= end) {
          times.push(time);
          time += step;
        }
      }
      return times;
    }

    /**
     * Adds the time by one year, e.g. 2014 January 15 -> 2015 January 15 -> ...
     * @param {number} time The current time
     * @return {number} Next year
     * @private
     */
    static _addOneYear(time) {
      var date = new Date(time);
      date.setFullYear(date.getFullYear() + 1);
      return date.getTime();
    }

    /**
     * Adds the time by one month, e.g. January 15 -> February 15 -> March 15 -> ...
     * @param {number} time The current time
     * @return {number} Next month
     * @private
     */
    static _addOneMonth(time) {
      var date = new Date(time);
      date.setMonth(date.getMonth() + 1);
      return date.getTime();
    }

    /**
     * Calulates the GCD of all the intervals in the given array
     * @param {Array} intervals The array of intervals in the time axis values
     * @return {Number} The GCD of the intervals
     */
    static _getGCDInterval(intervals) {
      var gcd = (interval1, interval2) => {
        if (interval1 === 0) return interval2;
        return gcd(interval2 % interval1, interval1);
      };

      var result = intervals[0];
      for (var i = 1; i < intervals.length; i++) {
        result = gcd(result, intervals[i]);
        if (result === 1) return 1;
      }

      return result;
    }

    /**
     * Calculates interval between two times based on the current granularity level
     * @param {Date} previousValue
     * @param {Date} currentValue
     * @param {Number} granularity The granularity level
     * @return {Number} The interval in the current granular level
     *                  (Eg. if the interval is 1 month and graularity level is month, then returns 1)
     * @private
     * @static
     */
    static _calculateGranularInterval(previousDate, currentDate, granularity) {
      // Treat times for the day light savings.
      var prevTimezoneOffset = previousDate.getTimezoneOffset();
      var currentTimezoneOffset = currentDate.getTimezoneOffset();
      var currentTime = currentDate.getTime();
      var currentTimezoneOffsetCorrection = (prevTimezoneOffset - currentTimezoneOffset) * 1000 * 60;
      if (currentTimezoneOffsetCorrection > 0) {
        currentDate.setTime(currentTime + currentTimezoneOffsetCorrection);
      }

      var granularInterval;
      if (granularity === DvtTimeAxisInfo.TIME_YEAR_MIN)
        granularInterval = currentDate.getFullYear() - previousDate.getFullYear();
      else if (granularity === DvtTimeAxisInfo.TIME_MONTH_MIN)
        granularInterval =
          12 * (currentDate.getFullYear() - previousDate.getFullYear()) +
          (currentDate.getMonth() - previousDate.getMonth());
      else
        granularInterval = Math.round((currentDate.getTime() - previousDate.getTime()) / granularity);

      if (currentTimezoneOffsetCorrection > 0) {
        currentDate.setTime(currentTime); // reset to original value
      }

      return granularInterval;
    }

    /**
     * Checks if any of the times array has any missing value and fills in the gap.
     * @param {Array} times An array of times in milliseconds representing the axis values.
     * @param {Number} granularity The granularity level
     * @return {Array} The treated times array
     * @private
     * @static
     */
    static _treatMissingValues(times, granularity) {
      var initialInterval;
      var intervals = new Set();
      var hasMissingValues = false;
      var ret = times; // If there are no missing values, the original array will be returned.
      var intervalsCache = [];

      var timeLength = times.length;
      var i;
      var previousDate = new Date(times[0]);
      for (i = 1; i < timeLength; i++) {
        // Calculate the current interval.
        var currentDate = new Date(times[i]);
        var currentInterval = DvtTimeAxisInfo._calculateGranularInterval(
          previousDate,
          currentDate,
          granularity
        );
        previousDate = currentDate;

        // Cache the result so as to not calculate again while filling the missing values
        // Since the cache is only used for filling in the missing values, and the operation
        // is performed in the same order as this one, having the cache key in the format
        // '1546318800000-1514782800000' should be fine.
        intervalsCache.push(currentInterval);

        // Proceed only if the current interval is greater than the current
        // granularity level.
        if (currentInterval <= 0) {
          continue;
        }

        // Add the current interval to the set.
        // The GCD of all the intervals will be used to fill in the missing the
        // values.
        intervals.add(currentInterval);

        // During the initial iteration, we will not have any information on intervals,
        // so, store the current interval and continue.
        if (!initialInterval) {
          initialInterval = currentInterval;
          continue;
        }

        // Check if the current interval is regular.
        if (currentInterval !== initialInterval) {
          hasMissingValues = true;
        }
      }

      // If missing values are present, treat them.
      if (hasMissingValues) {
        // Get the GCD of intervals and it will be the minimum interval in the new set of times
        var minimumInterval = DvtTimeAxisInfo._getGCDInterval([...intervals]);
        ret = [];
        ret.push(times[0]);
        for (i = 1; i < timeLength; i++) {
          var currentValue = times[i];
          var previousValue = times[i - 1];

          // Retrieve the interval from cache.
          // As we are looping through the same array the cache will have the interval value
          // and will never be undefined.
          var currentInterval = intervalsCache[i - 1];

          // If no values are missing in this interval,
          // add current value to the return array and continue.
          // Note: Values are considered missing only when the interval is greater than the current granularity level (minimumInterval).
          // Example: Jan 1, Jan 15, Feb 1, Mar 1, May 1, Jun 1
          // Granularity = Month; Minimum Interval = 1 (1 month)
          // Mar 1, May 1 => has one missing value: Apr
          // Jan 1, Jan 15 => has no missing value
          if (currentInterval <= minimumInterval) {
            ret.push(currentValue);
            continue;
          }

          // Calculate the interval at which the values are to be filled
          var ratioOfCurrentIntervalToMinimumInterval = currentInterval / minimumInterval; // Should be a round number as minimumInterval is a divisor of currentInterval
          var numMissingValues = ratioOfCurrentIntervalToMinimumInterval - 1;
          var fillIntervalInMilliseconds = Math.round(
            (currentValue - previousValue) / ratioOfCurrentIntervalToMinimumInterval
          );

          // Fill in the missing values
          var j;
          for (j = 1; j <= numMissingValues; j++) {
            previousValue += fillIntervalInMilliseconds;
            ret.push(previousValue);
          }
          ret.push(currentValue); // Finally, add the current value
          previousValue = currentValue; // Update the previous value
        }
      }
      return ret;
    }

    /**
     * Determines if rectangle A (bounded by pointA1 and pointA2) and rectangle B (bounded by pointB1 and B2) overlap.
     * All the points should lie in one dimension.
     * @param {Number} pointA1
     * @param {Number} pointA2
     * @param {Number} pointB1
     * @param {Number} pointB2
     * @param {Number} gap The minimum gap between the two rectangles
     * @return {Boolean} whether rectangle A and B overlap
     * @private
     */
    static _isOverlapping(pointA1, pointA2, pointB1, pointB2, gap) {
      if (pointB1 >= pointA1 && pointB1 - gap < pointA2) return true;
      else if (pointB1 < pointA1 && pointB2 + gap > pointA1) return true;
      return false;
    }
  }

  // ------------------------
  // Constants
  //
  /** @const */
  DvtTimeAxisInfo.TIME_SECOND = 1000;
  /** @const */
  DvtTimeAxisInfo.TIME_MINUTE = 60 * DvtTimeAxisInfo.TIME_SECOND;
  /** @const */
  DvtTimeAxisInfo.TIME_HOUR = 60 * DvtTimeAxisInfo.TIME_MINUTE;
  /** @const */
  DvtTimeAxisInfo.TIME_DAY = 24 * DvtTimeAxisInfo.TIME_HOUR;
  /** @const */
  DvtTimeAxisInfo.TIME_MONTH_MIN = 28 * DvtTimeAxisInfo.TIME_DAY;
  /** @const */
  DvtTimeAxisInfo.TIME_MONTH_MAX = 31 * DvtTimeAxisInfo.TIME_DAY;
  /** @const */
  DvtTimeAxisInfo.TIME_YEAR_MIN = 365 * DvtTimeAxisInfo.TIME_DAY;
  /** @const */
  DvtTimeAxisInfo.TIME_YEAR_MAX = 366 * DvtTimeAxisInfo.TIME_DAY;

  DvtAxisInfo.registerConstructor('time', DvtTimeAxisInfo);

  /**
   * Renderer for the reference objects of a Chart.
   * @class
   */
  const DvtChartRefObjRenderer = {
    /**
     * Renders the background reference objects.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     */
    renderBackgroundObjects: (chart, container, plotAreaBounds) => {
      DvtChartRefObjRenderer._renderObjects(chart, container, plotAreaBounds, 'back');
    },

    /**
     * Renders the foreground reference objects.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     */
    renderForegroundObjects: (chart, container, plotAreaBounds) => {
      DvtChartRefObjRenderer._renderObjects(chart, container, plotAreaBounds, 'front');
    },

    /**
     * Renders the reference objects for the given location.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     * @param {string} location The location of the reference objects.
     * @private
     */
    _renderObjects: (chart, container, plotAreaBounds, location) => {
      DvtChartRefObjRenderer._renderObjectsForAxis(
        chart,
        container,
        plotAreaBounds,
        location,
        chart.xAxis,
        DvtChartDataUtils.getAxisRefObjs(chart, 'x')
      );
      DvtChartRefObjRenderer._renderObjectsForAxis(
        chart,
        container,
        plotAreaBounds,
        location,
        chart.yAxis,
        DvtChartDataUtils.getAxisRefObjs(chart, 'y')
      );
      DvtChartRefObjRenderer._renderObjectsForAxis(
        chart,
        container,
        plotAreaBounds,
        location,
        chart.y2Axis,
        DvtChartDataUtils.getAxisRefObjs(chart, 'y2')
      );
    },

    /**
     * Renders the reference objects for the given location.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     * @param {string} location The location of the reference objects.
     * @param {DvtAxis} axis The axis corresponding to the reference objects.
     * @param {array} objects The array of reference objects.
     * @private
     */
    _renderObjectsForAxis: (chart, container, plotAreaBounds, location, axis, objects) => {
      if (!objects || !axis) return;

      // Loop through and render each reference object
      for (var i = 0; i < objects.length; i++) {
        var refObj = objects[i];

        if (!DvtChartRefObjUtils.isObjRendered(chart, refObj)) {
          continue;
        }

        if (!refObj) continue;

        if (DvtChartRefObjUtils.getLocation(refObj) != location) continue;

        var shape, outerShape;
        var type = DvtChartRefObjUtils.getType(refObj);
        if (type == 'area')
          shape = DvtChartRefObjRenderer._createReferenceArea(refObj, chart, plotAreaBounds, axis);
        else if (type == 'line') {
          shape = DvtChartRefObjRenderer._createReferenceLine(refObj, chart, plotAreaBounds, axis);
          outerShape = DvtChartRefObjRenderer._createReferenceLine(
            refObj,
            chart,
            plotAreaBounds,
            axis,
            true
          );
        }

        if (shape == null) continue;

        //  - HIDE & SHOW FOR REFERENCE OBJECTS
        // Associate for interactivity and tooltip support
        var yAxisType = axis == chart.yAxis ? 'yAxis' : 'y2Axis';
        var axisType = axis == chart.xAxis ? 'xAxis' : yAxisType;
        var refObjShapes = outerShape ? [shape, outerShape] : [shape];
        var refObjPeer = new DvtChartRefObjPeer(chart, refObjShapes, refObj, i, axisType);
        chart.registerObject(refObjPeer);
        chart.getEventManager().associate(shape, refObjPeer);

        // Add the shape to the container
        container.addChild(shape);

        if (outerShape) container.addChild(outerShape);
      }
    },

    /**
     * Creates a reference area.
     * @param {object} refObj The options object for the reference area.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     * @param {DvtAxis} axis The axis corresponding to the reference area.
     * @return {dvt.Shape} The reference area.
     * @private
     */
    _createReferenceArea: (refObj, chart, plotAreaBounds, axis) => {
      var context = chart.getCtx();
      var position = axis.getPosition();
      var bHoriz = position == 'top' || position == 'bottom';
      var bRadial = position == 'radial';
      var color = DvtChartRefObjUtils.getColor(chart, refObj);
      var lineType = DvtChartRefObjUtils.getLineType(refObj);
      var style = refObj['style'] || refObj['svgStyle'];
      var className = refObj['className'] || refObj['svgClassName'];
      var shape;

      if (refObj['items'] != null && (axis == chart.yAxis || axis == chart.y2Axis)) {
        // REF AREA WITH MULTIPLE VALUES
        var items = refObj['items'];
        var highCoords = [];
        var lowCoords = [];

        // Match the number of items with the group count
        if (chart.xAxis.isGroupAxis()) {
          while (items.length < DvtChartDataUtils.getGroupCount(chart)) {
            items.push(null);
          }
        }

        // Build arrays of high/low axis coords
        for (var pointIndex = 0; pointIndex < items.length; pointIndex++) {
          var dataItem = items[pointIndex];
          var lVal = DvtChartRefObjUtils.getLowVal(dataItem);
          var hVal = DvtChartRefObjUtils.getHighVal(dataItem);
          if (lVal == null || hVal == null) {
            highCoords.push(new DvtChartCoord());
            lowCoords.push(new DvtChartCoord());
            continue;
          }

          // x is always the xCoord, and min and max along the yAxis
          var lCoord = axis.getUnboundedCoordAt(lVal);
          var hCoord = axis.getUnboundedCoordAt(hVal);
          var xCoord = chart.xAxis.getUnboundedCoordAt(
            DvtChartRefObjUtils.getXVal(chart, items, pointIndex)
          );

          highCoords.push(new DvtChartCoord(xCoord, hCoord, hCoord));
          lowCoords.push(new DvtChartCoord(xCoord, lCoord, lCoord));
        }

        // Create the area shapes
        shape = new DvtChartLineArea(
          chart,
          true,
          plotAreaBounds,
          null,
          style,
          className,
          new dvt.SolidFill(color),
          null,
          lineType,
          highCoords,
          lineType,
          lowCoords
        );
      } else {
        // REF AREA WITH SINGLE VALUE
        var lowVal = DvtChartRefObjUtils.getLowVal(refObj);
        var highVal = DvtChartRefObjUtils.getHighVal(refObj);

        // Populate the default value if either low or high is missing or infinite
        if (lowVal == null || lowVal == -Infinity) lowVal = axis.getInfo().getGlobalMin();
        if (highVal == null || highVal == Infinity) highVal = axis.getInfo().getGlobalMax();

        // Find the coordinates
        var lowCoord = DvtChartRefObjRenderer._getAxisCoord(chart, axis, lowVal);
        var highCoord = DvtChartRefObjRenderer._getAxisCoord(chart, axis, highVal);

        if (DvtChartTypeUtils.isPolar(chart)) {
          var cmds;
          var cx = plotAreaBounds.x + plotAreaBounds.w / 2;
          var cy = plotAreaBounds.y + plotAreaBounds.h / 2;
          if (bRadial) {
            if (DvtChartAxisUtils.isGridPolygonal(chart)) {
              // draw polygonal donut
              var nSides = DvtChartDataUtils.getGroupCount(chart);
              var outerPoints = dvt.PolygonUtils.getRegularPolygonPoints(
                cx,
                cy,
                nSides,
                highCoord,
                0,
                1
              );
              var innerPoints = dvt.PolygonUtils.getRegularPolygonPoints(
                cx,
                cy,
                nSides,
                lowCoord,
                0,
                0
              );
              cmds =
                dvt.PathUtils.polyline(outerPoints) +
                dvt.PathUtils.polyline(innerPoints) +
                dvt.PathUtils.closePath();
            } else {
              // draw circular donut
              // To work around a chrome/safari bug, we draw two segments around each of the outer and inner arcs
              cmds =
                dvt.PathUtils.moveTo(cx, cy - highCoord) +
                dvt.PathUtils.arcTo(highCoord, highCoord, Math.PI, 1, cx, cy + highCoord) +
                dvt.PathUtils.arcTo(highCoord, highCoord, Math.PI, 1, cx, cy - highCoord) +
                dvt.PathUtils.moveTo(cx, cy - lowCoord) +
                dvt.PathUtils.arcTo(lowCoord, lowCoord, Math.PI, 0, cx, cy + lowCoord) +
                dvt.PathUtils.arcTo(lowCoord, lowCoord, Math.PI, 0, cx, cy - lowCoord) +
                dvt.PathUtils.closePath();
            }
          } else {
            // for tangential axis, draw circular segment. If polygonal, the shape will be clipped by the container.
            var radius = chart.getRadius();
            var pLow = DvtChartCoordUtils.polarToCartesian(radius, lowCoord, plotAreaBounds);
            var pHigh = DvtChartCoordUtils.polarToCartesian(radius, highCoord, plotAreaBounds);
            cmds =
              dvt.PathUtils.moveTo(cx, cy) +
              dvt.PathUtils.lineTo(pLow.x, pLow.y) +
              dvt.PathUtils.arcTo(
                radius,
                radius,
                highCoord - lowCoord,
                dvt.Agent.isRightToLeft(context) ? 0 : 1,
                pHigh.x,
                pHigh.y
              ) +
              dvt.PathUtils.lineTo(pHigh.x, pHigh.y) +
              dvt.PathUtils.closePath();
          }
          shape = new dvt.Path(context, cmds);
        } else {
          // draw rectangle
          var points;
          if (bHoriz)
            points = [
              lowCoord,
              0,
              highCoord,
              0,
              highCoord,
              plotAreaBounds.h,
              lowCoord,
              plotAreaBounds.h
            ];
          else
            points = [
              0,
              lowCoord,
              0,
              highCoord,
              plotAreaBounds.w,
              highCoord,
              plotAreaBounds.w,
              lowCoord
            ];
          shape = new dvt.Polygon(context, points);
        }
        shape.setSolidFill(color);
        shape.setStyle(style).setClassName(className);
      }

      return shape;
    },

    /**
     * Creates a reference line.
     * @param {object} refObj The options object for the reference line.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Rectangle} plotAreaBounds The bounds of the plot area.
     * @param {DvtAxis} axis The axis corresponding to the reference line.
     * @param {boolean} isOuterLine True if this is the border line for the reference line.
     * @return {dvt.Shape} The reference line.
     * @private
     */
    _createReferenceLine: (refObj, chart, plotAreaBounds, axis, isOuterLine) => {
      var position = axis.getPosition();
      var bHoriz = position == 'top' || position == 'bottom';
      var bRadial = position == 'radial';
      var bTangential = position == 'tangential';

      // Set style attributes
      var lineWidth = DvtChartRefObjUtils.getLineWidth(chart, refObj);
      var lineType = DvtChartRefObjUtils.getLineType(refObj);
      var color = DvtChartRefObjUtils.getColor(chart, refObj);
      var style = refObj['style'] || refObj['svgStyle'];
      var className = isOuterLine
        ? 'oj-chart-reference-object-inner-line'
        : refObj['className'] || refObj['svgClassName'];
      var stroke = new dvt.Stroke(
        color,
        1,
        lineWidth,
        false,
        dvt.Stroke.getDefaultDashProps(refObj['lineStyle'], lineWidth)
      );

      var context = chart.getCtx();
      var shape;

      if (refObj['items'] != null && (axis == chart.yAxis || axis == chart.y2Axis)) {
        // REF LINE WITH MULTIPLE VALUES
        var items = refObj['items'];
        // Match the number of items with the group count
        if (chart.xAxis.isGroupAxis()) {
          while (items.length < DvtChartDataUtils.getGroupCount(chart)) {
            items.push(null);
          }
        }

        // Build array of axis coords
        var coords = [];
        for (var pointIndex = 0; pointIndex < items.length; pointIndex++) {
          var dataItem = items[pointIndex];

          // Extract the value for the dataItem
          var value = null;
          if (dataItem != null) {
            if (typeof dataItem != 'object') value = dataItem;
            else if (dataItem['value'] != null) value = dataItem['value'];
          }

          if (value == null) {
            coords.push(new DvtChartCoord());
            continue;
          }

          // y is always along the xAxis, and value for yAxis
          var yCoord = axis.getUnboundedCoordAt(value) - (isOuterLine ? lineWidth / 2 : 0);
          var xCoord = chart.xAxis.getUnboundedCoordAt(
            DvtChartRefObjUtils.getXVal(chart, items, pointIndex)
          );
          coords.push(new DvtChartCoord(xCoord, yCoord, yCoord));
        }

        // Create line shapes
        shape = new DvtChartLineArea(
          chart,
          false,
          plotAreaBounds,
          null,
          style,
          className,
          null,
          stroke,
          lineType,
          coords
        );
      } else if (refObj['value'] != null) {
        // REF LINE WITH SINGLE VALUE
        var lineCoord = DvtChartRefObjRenderer._getAxisCoord(chart, axis, refObj['value']);

        // Don't continue if the line is outside of the axis
        if (lineCoord == null || lineCoord == Infinity || lineCoord == -Infinity) return null;

        if (isOuterLine) lineCoord -= Math.ceil(lineWidth / 2);

        var cx = plotAreaBounds.x + plotAreaBounds.w / 2;
        var cy = plotAreaBounds.y + plotAreaBounds.h / 2;
        if (bRadial) {
          if (DvtChartAxisUtils.isGridPolygonal(chart)) {
            var points = dvt.PolygonUtils.getRegularPolygonPoints(
              cx,
              cy,
              DvtChartDataUtils.getGroupCount(chart),
              lineCoord,
              0
            );
            shape = new dvt.Polygon(context, points);
          } else shape = new dvt.Circle(context, cx, cy, lineCoord);
          shape.setFill(null);
        } else if (bTangential) {
          var cartesian = DvtChartCoordUtils.polarToCartesian(
            chart.getRadius(),
            lineCoord,
            plotAreaBounds
          );
          shape = new dvt.Line(context, cx, cy, cartesian.x, cartesian.y);
        } else {
          if (bHoriz) shape = new dvt.Line(context, lineCoord, 0, lineCoord, plotAreaBounds.h);
          else shape = new dvt.Line(context, 0, lineCoord, plotAreaBounds.w, lineCoord);
          shape.setPixelHinting(true);
        }
        shape.setStroke(stroke);
        shape.setStyle(style).setClassName(className);
      } // no line created
      else return null;

      return shape;
    },

    /**
     * Returns the coordinate of the specified value on the axis.  If the coordinate cannot be located, then returns null.
     * @param {Chart} chart
     * @param {DvtAxis} axis The axis corresponding to the reference object.
     * @param {object} value The value whose coordinate will be returned.
     * @return {number}
     * @private
     */
    _getAxisCoord: (chart, axis, value) => {
      if (axis.isGroupAxis()) {
        // For group axis, find the index of the group and pass it to the axis
        var index = DvtChartDataUtils.getGroupIdx(chart, value);
        if (index >= 0) return axis.getUnboundedCoordAt(index);
      }

      // If value is number, treat is as the group index for group axis
      if (!isNaN(value)) return axis.getUnboundedCoordAt(value);

      return null;
    }
  };

  /**
   * Bubble chart utility functions for Chart.
   * @class
   */
  const DvtChartMarkerUtils = {
    /** @private */
    _MIN_BUBBLE_SIZE: 6,

    /** @private */
    _MAX_BUBBLE_SIZE_RATIO: 0.5,

    /**
     * Calculates the bubble sizes for the chart.
     * @param {Chart} chart
     * @param {dvt.Rectangle} availSpace
     */
    calcBubbleSizes: (chart, availSpace) => {
      // Calculate the min and max z values
      var minMax = DvtChartAxisUtils.getMinMaxVal(chart, 'z');
      var minZ = minMax['min'];
      var maxZ = minMax['max'];

      // Calculate the max allowed bubble sizes
      var minSize = DvtChartMarkerUtils._MIN_BUBBLE_SIZE;
      var maxSize = DvtChartMarkerUtils._MAX_BUBBLE_SIZE_RATIO * Math.min(availSpace.w, availSpace.h);

      // Loop through the data and update the sizes
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var bIncludeHiddenSeries =
        DvtChartBehaviorUtils.getHideAndShowBehavior(chart) == 'withoutRescale';

      var optionsCache = chart.getOptionsCache();

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        if (!bIncludeHiddenSeries && !DvtChartDataUtils.isSeriesRendered(chart, seriesIndex))
          continue;

        var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
        var numGroups = seriesItem['items'] ? seriesItem['items'].length : 0;
        for (var j = 0; j < numGroups; j++) {
          var dataItem = seriesItem['items'][j];

          // If a z value exists, calculate and set the marker size
          if (dataItem) {
            var markerSize = dvt.LayoutUtils.getBubbleSize(
              dataItem['z'],
              minZ,
              maxZ,
              minSize,
              maxSize
            );
            optionsCache.putToCachedMap2D('bubbleSizeCache', seriesIndex, j, markerSize);
          }
        }
      }

      // The rest of the code is to determine how much the axis needs to be extended to cover the bubble
      // radii. _x/yAxisBubbleRatio will be used in DvtChartAxisUtils.getBubbleAxisRadius().
      // NOTE: The computed values here are approximations, so they can be grossly inaccurate in some
      //       circumstances. We can't get the exact values at this point since the axes are not rendered yet, but
      //       we need to approximate now in order to layout the axes correctly.
      var axisWidth, axisHeight;
      if (DvtChartTypeUtils.isPolar(chart)) {
        axisWidth = Infinity; // polar x-axis is circular
        axisHeight = chart.getRadius();
      } else {
        // At this point, we still don't know the actual dimensions of the axes since they're not rendered yet, so we
        // approximate based on the tick label height
        axisWidth = availSpace.w - 2.4 * DvtChartAxisUtils.getTickLabelHeight(chart, 'y');
        axisHeight = availSpace.h - 1.6 * DvtChartAxisUtils.getTickLabelHeight(chart, 'x');
      }

      // Subtract the axis width and height based on the largest bubble size. This is to approximate the extra axis
      // space that is allocated to accommodate the bubbles near the plot area borders.
      axisWidth -= 0.5 * maxSize;
      axisHeight -= 0.5 * maxSize;

      // Store the computed ratios in the options cache
      var cache = chart.getCache();
      var xAxisValueRange = DvtChartMarkerUtils._getAxisValueRange(chart, 'x');
      cache.putToCache('_xAxisBubbleRatio', xAxisValueRange / axisWidth);

      var yAxisValueRange = DvtChartMarkerUtils._getAxisValueRange(chart, 'y');
      cache.putToCache('_yAxisBubbleRatio', yAxisValueRange / axisHeight);
    },

    /**
     * Returns the axis value range, disregarding the bubble radii (which we don't know yet at this point)
     * @param {Chart} chart
     * @param {string} type The axis type, 'x' or 'y'.
     * @return {number} Axis value range.
     * @private
     */
    _getAxisValueRange: (chart, type) => {
      var axisOptions = chart.getOptions()[type + 'Axis'];
      var isLog = DvtChartAxisUtils.isLog(chart, type);
      var zeroBaseline = !isLog && DvtChartAxisUtils.getBaselineScaling(chart, type) == 'zero';
      var minMax = DvtChartAxisUtils.getMinMaxVal(chart, type, true);

      var min = axisOptions['min'];
      if (min == null) min = zeroBaseline ? Math.min(0, minMax['min']) : minMax['min'];

      var max = axisOptions['max'];
      if (max == null) max = zeroBaseline ? Math.max(0, minMax['max']) : minMax['max'];

      if (isLog && max > 0 && min > 0) return max == min ? 6 : dvt.Math.log10(max / min);
      return max == min ? 60 : max - min;
    },

    /**
     * Sorts the markers in order of descending marker size.
     * @param {array} markers The array of dvt.SimpleMarker objects or objects with size properties.
     */
    sortMarkers: (markers) => {
      markers.sort(DvtChartMarkerUtils._compareSize);
    },

    /**
     * Sorts the markers in order of descending marker size.
     * @param {array} markers The array of markerInfo objects with size properties.
     */
    sortMarkerInfos: (markers) => {
      markers.sort(DvtChartMarkerUtils._compareInfoSize);
    },

    /**
     * Compare function to sort markers in order of descending size.
     * @param {dvt.SimpleMarker | object} a
     * @param {dvt.SimpleMarker | object} b
     * @return {number} Comparison.
     * @private
     */
    _compareSize: (a, b) => {
      return b.getSize() - a.getSize();
    },

    /**
     * Compare function to sort markerInfo objects in order of descending size.
     * @param {object} a
     * @param {object} b
     * @return {number} Comparison.
     * @private
     */
    _compareInfoSize: (a, b) => {
      // We want to sort the markers from biggest to smallest
      return b.size - a.size;
    },

    /**
     * Returns true if the specified marker would be fully obscured.
     * @param {dvt.PixelMap} pixelMap
     * @param {number} markerX
     * @param {number} markerY
     * @param {number} markerSize
     * @return {boolean}
     */
    checkPixelMap: (pixelMap, markerX, markerY, markerSize) => {
      // Note: This function is conservative about the pixels occupied.
      var halfSize = markerSize / 2;
      var x1 = Math.max(Math.floor(markerX - halfSize), 0);
      var y1 = Math.max(Math.floor(markerY - halfSize), 0);
      var x2 = Math.max(Math.ceil(markerX + halfSize), 0);
      var y2 = Math.max(Math.ceil(markerY + halfSize), 0);
      return pixelMap.isObscured(x1, y1, x2, y2);
    },

    /**
     * Updates the pixel map for the specified marker.
     * @param {dvt.Map2D} pixelMap
     * @param {number} markerX
     * @param {number} markerY
     * @param {number} markerSize
     * @param {number} alpha
     */
    updatePixelMap: (pixelMap, markerX, markerY, markerSize, alpha) => {
      // Note: This function uses several approximations. Only 80% of the marker size is counted as occupied, partly to
      // account for marker shape. The coords are rounded, since the browser will likely anti-alias in the direction of
      // rounding.
      var halfSize = markerSize * 0.4;
      var x1 = Math.max(Math.round(markerX - halfSize), 0);
      var x2 = Math.max(Math.round(markerX + halfSize), 0);
      var y1 = Math.max(Math.round(markerY - halfSize), 0);
      var y2 = Math.max(Math.round(markerY + halfSize), 0);
      pixelMap.obscure(x1, y1, x2, y2, alpha);
    }
  };

  /**
   * Renderer for the plot area of a Chart.
   * @class
   */
  const DvtChartPlotAreaRenderer = {
    /** @private @const */
    _MIN_TOUCH_MARKER_SIZE: 16, // minimum marker size for touch device,

    /** @private @const */
    _MIN_CHARS_DATA_LABEL: 3, // minimum number of chars to be displayed of a data label when truncatin,

    /**
     * The minimum number of data points after which data filtering will be enabled for scatter and bubble charts.
     * @const
     */
    FILTER_THRESHOLD_SCATTER_BUBBLE: 10000,

    /**
     * Renders the plot area into the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (chart, container, availSpace) => {
      if (chart.getOptions()['plotArea']['rendered'] == 'off') {
        DvtChartPlotAreaRenderer._renderAxisLines(chart, container, availSpace);
      } else if (availSpace.w > 0 && availSpace.h > 0) {
        // TODO: change to formal location for displayed data
        chart._currentMarkers = [];
        chart._currentAreas = [];
        DvtChartPlotAreaRenderer._renderBackgroundObjs(chart, container, availSpace);
        DvtChartPlotAreaRenderer._renderTicks(chart, container, availSpace);
        DvtChartPlotAreaRenderer._renderForegroundObjs(chart, container, availSpace);
      }
    },

    /**
     * Renders objects in the background of the plot area.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderBackgroundObjs: (chart, container, availSpace) => {
      // Chart background
      var options = chart.getOptions();
      var background = DvtChartPlotAreaRenderer._getBackgroundShape(chart, availSpace);

      var backgroundColor = DvtChartStyleUtils.getBackgroundColor(chart);
      if (backgroundColor) background.setSolidFill(backgroundColor);
      else background.setInvisibleFill(); // Always render a background plot area rectangle and save for interactivity

      container.addChild(background);
      chart.getCache().putToCache('plotAreaBackground', background);

      var isPlotAreaDraggable = DvtChartBehaviorUtils.isPlotAreaDraggable(chart);
      if (isPlotAreaDraggable) background.setClassName('oj-draggable');

      // Reference Objects
      if (
        options['xAxis']['referenceObjects'] ||
        options['yAxis']['referenceObjects'] ||
        options['y2Axis']['referenceObjects']
      ) {
        var clipGroup = DvtChartPlotAreaRenderer.createClippedGroup(chart, container, availSpace);
        DvtChartRefObjRenderer.renderBackgroundObjects(chart, clipGroup, availSpace);
      }

      // Draw area series behind the gridlines (because they would obscure the grids)
      if (DvtChartTypeUtils.isBLAC(chart)) {
        // Create area container for all BLAC types to allow delete animation from a chart with area to a chart without area
        var areaContainer = new dvt.Container(chart.getCtx());
        container.addChild(areaContainer);
        chart.__setAreaContainer(areaContainer);
        const comboSeriesOrder = options['comboSeriesOrder'];

        if (
          DvtChartDataUtils.hasAreaSeries(chart) &&
          (comboSeriesOrder === 'seriesType' || !DvtChartTypeUtils.isCombo(chart))
        )
          DvtChartPlotAreaRenderer._renderAreas(chart, areaContainer, availSpace, false);
      }
    },

    /**
     * Helper function to create the background shape.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {dvt.Shape} The background shape
     * @private
     */
    _getBackgroundShape: (chart, availSpace) => {
      var background;
      var context = chart.getCtx();
      if (DvtChartTypeUtils.isPolar(chart)) {
        var cx = availSpace.x + availSpace.w / 2;
        var cy = availSpace.y + availSpace.h / 2;
        if (DvtChartAxisUtils.isGridPolygonal(chart)) {
          var points = dvt.PolygonUtils.getRegularPolygonPoints(
            cx,
            cy,
            DvtChartDataUtils.getGroupCount(chart),
            chart.getRadius(),
            0
          );
          background = new dvt.Polygon(context, points);
        } else background = new dvt.Circle(context, cx, cy, chart.getRadius());
      } else
        background = new dvt.Rect(context, availSpace.x, availSpace.y, availSpace.w, availSpace.h);
      return background;
    },

    /**
     * Renders the major and minor ticks for the chart.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderTicks: (chart, container, availSpace) => {
      // Minor Ticks
      if (chart.xAxis && DvtChartAxisUtils.isMinorTickRendered(chart, 'x'))
        DvtChartPlotAreaRenderer._renderMinorTicks(chart, container, chart.xAxis, availSpace);

      if (chart.yAxis && DvtChartAxisUtils.isMinorTickRendered(chart, 'y'))
        DvtChartPlotAreaRenderer._renderMinorTicks(chart, container, chart.yAxis, availSpace);

      if (chart.y2Axis && DvtChartAxisUtils.isMinorTickRendered(chart, 'y2'))
        DvtChartPlotAreaRenderer._renderMinorTicks(chart, container, chart.y2Axis, availSpace);

      // Major Ticks
      if (chart.xAxis && DvtChartAxisUtils.isMajorTickRendered(chart, 'x'))
        DvtChartPlotAreaRenderer._renderMajorTicks(chart, container, chart.xAxis, availSpace);

      if (chart.yAxis && DvtChartAxisUtils.isMajorTickRendered(chart, 'y'))
        DvtChartPlotAreaRenderer._renderMajorTicks(chart, container, chart.yAxis, availSpace);

      if (chart.y2Axis && DvtChartAxisUtils.isMajorTickRendered(chart, 'y2'))
        DvtChartPlotAreaRenderer._renderMajorTicks(chart, container, chart.y2Axis, availSpace);
    },

    /**
     * Renders the axis lines for the chart.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderAxisLines: (chart, container, availSpace) => {
      if (chart.xAxis && chart.yAxis && DvtChartAxisUtils.isAxisLineRendered(chart, 'x'))
        DvtChartPlotAreaRenderer._renderAxisLine(
          chart,
          container,
          chart.xAxis,
          chart.yAxis,
          availSpace
        );

      // Render x-axis line based on y2 if there's no y1 or if split dual-Y
      if (chart.xAxis && chart.y2Axis && DvtChartAxisUtils.isAxisLineRendered(chart, 'x')) {
        if (!chart.yAxis || DvtChartDataUtils.isSplitDualY(chart))
          DvtChartPlotAreaRenderer._renderAxisLine(
            chart,
            container,
            chart.xAxis,
            chart.y2Axis,
            availSpace
          );
      }

      if (chart.yAxis && chart.xAxis && DvtChartAxisUtils.isAxisLineRendered(chart, 'y'))
        DvtChartPlotAreaRenderer._renderAxisLine(
          chart,
          container,
          chart.yAxis,
          chart.xAxis,
          availSpace
        );

      if (chart.y2Axis && chart.xAxis && DvtChartAxisUtils.isAxisLineRendered(chart, 'y2'))
        DvtChartPlotAreaRenderer._renderAxisLine(
          chart,
          container,
          chart.y2Axis,
          chart.xAxis,
          availSpace
        );
    },

    /**
     * Renders the major ticks for the axis.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {DvtChartAxis} axis The axis owning the major ticks.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderMajorTicks: (chart, container, axis, availSpace) => {
      DvtChartPlotAreaRenderer._renderGridlines(
        chart,
        container,
        axis.getOptions()['majorTick'],
        axis.getPosition(),
        axis.getMajorTickCoords(),
        axis.getBaselineCoord(),
        availSpace
      );
    },

    /**
     * Renders the minor ticks for the axis.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {DvtChartAxis} axis The axis owning the minor ticks.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderMinorTicks: (chart, container, axis, availSpace) => {
      DvtChartPlotAreaRenderer._renderGridlines(
        chart,
        container,
        axis.getOptions()['minorTick'],
        axis.getPosition(),
        axis.getMinorTickCoords(),
        null,
        availSpace
      );
    },

    /**
     * Renders the axis line for the axis.
     * Axis lines are drawn by the opposite axis. For example, x-axis line is drawn based on the y-axis coord (and will be
     * parallel to the y-axis gridlines), and vice versa.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {DvtChartAxis} oAxis The axis owning the axis line.
     * @param {DvtChartAxis} dAxis The axis drawing the axis line (i.e. the axis orthogonal to oAxis).
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderAxisLine: (chart, container, oAxis, dAxis, availSpace) => {
      var options = oAxis.getOptions();
      var position = options['position'];
      var coord =
        position == 'bottom' || position == 'right' || position == 'tangential'
          ? dAxis.getMaxCoord()
          : dAxis.getMinCoord();
      DvtChartPlotAreaRenderer._renderGridlines(
        chart,
        container,
        options['axisLine'],
        dAxis.getPosition(),
        [coord],
        null,
        availSpace
      );
    },

    /**
     * Renders the specified set of gridlines (ticks or axis lines).
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {Object} options The options object of the gridline.
     * @param {String} position The axis position.
     * @param {Array} coords The array gridline coords.
     * @param {Number} baselineCoord The baseline coord (to use baseline style).
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderGridlines: (chart, container, options, position, coords, baselineCoord, availSpace) => {
      // Construct the default line stroke
      var lineColor = options['lineColor'];
      var type = options['lineStyle'];
      var lineStroke = new dvt.Stroke(
        lineColor,
        1,
        options['lineWidth'],
        false,
        dvt.Stroke.getDefaultDashProps(type, options['lineWidth'])
      );

      // Construct the baseline stroke
      var baselineColor = lineStroke.getColor();
      if (options['baselineColor'] != 'inherit') {
        if (options['baselineColor'] == 'auto')
          baselineColor = dvt.ColorUtils.getDarker(lineColor, 0.6);
        // derive the baselineColor from lineColor
        else baselineColor = options['baselineColor'];
      }
      var baselineWidth =
        options['baselineWidth'] != null ? options['baselineWidth'] : options['lineWidth'];
      var baselineType = options['baselineStyle'] ? options['baselineStyle'] : options['lineStyle'];
      var baselineStroke = new dvt.Stroke(
        baselineColor,
        1,
        baselineWidth,
        false,
        dvt.Stroke.getDefaultDashProps(baselineType, baselineWidth)
      );

      // Render a single path for horizontal and vertical gridlines otherwise render individual lines/circles
      var pathCmd = '';
      for (var i = 0; i < coords.length; i++) {
        var isBaseline = baselineCoord != null && coords[i] == baselineCoord;
        if (position == 'radial' || position == 'tangential' || isBaseline) {
          DvtChartPlotAreaRenderer._renderGridline(
            chart,
            container,
            position,
            coords[i],
            isBaseline ? baselineStroke : lineStroke,
            availSpace
          );
        } else if (position == 'top' || position == 'bottom')
          pathCmd +=
            dvt.PathUtils.moveTo(coords[i], availSpace.y) +
            dvt.PathUtils.verticalLineTo(availSpace.y + availSpace.h);
        else
          pathCmd +=
            dvt.PathUtils.moveTo(availSpace.x, coords[i]) +
            dvt.PathUtils.horizontalLineTo(availSpace.x + availSpace.w);
      }
      if (pathCmd != '') {
        var path = new dvt.Path(chart.getCtx(), pathCmd);
        if (!dvt.Agent.isTouchDevice() || dvt.Agent.getDevicePixelRatio() > 1)
          path.setPixelHinting(true);
        path.setStroke(lineStroke);
        path.setMouseEnabled(false);
        container.addChild(path);
      }
    },

    /**
     * Renders the specified gridline (tick or axis line).
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {String} position The axis position.
     * @param {Number} coord The gridline coord.
     * @param {dvt.Stroke} stroke The gridline stroke.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderGridline: (chart, container, position, coord, stroke, availSpace) => {
      var line;
      var context = container.getCtx();
      var usePixelHinting = !dvt.Agent.isTouchDevice() || dvt.Agent.getDevicePixelRatio() > 1;

      if (position == 'radial') {
        if (DvtChartAxisUtils.isGridPolygonal(chart)) {
          var points = dvt.PolygonUtils.getRegularPolygonPoints(
            0,
            0,
            DvtChartDataUtils.getGroupCount(chart),
            coord,
            0
          );
          line = new dvt.Polygon(context, points);
        } else line = new dvt.Circle(context, 0, 0, coord);
        line.setInvisibleFill();
        line.setTranslate(availSpace.x + availSpace.w / 2, availSpace.y + availSpace.h / 2);
      } else if (position == 'tangential') {
        line = new dvt.Line(
          context,
          0,
          0,
          chart.getRadius() * Math.sin(coord),
          -chart.getRadius() * Math.cos(coord)
        );
        var mod = coord % (Math.PI / 2); // use pixel hinting at 0, 90, 180, and 270 degrees
        if ((mod < 0.001 || mod > Math.PI / 2 - 0.001) && usePixelHinting) line.setPixelHinting(true);

        line.setTranslate(availSpace.x + availSpace.w / 2, availSpace.y + availSpace.h / 2);
      } else {
        if (position == 'top' || position == 'bottom')
          line = new dvt.Line(context, coord, availSpace.y, coord, availSpace.y + availSpace.h);
        else line = new dvt.Line(context, availSpace.x, coord, availSpace.x + availSpace.w, coord);
        if (usePixelHinting) line.setPixelHinting(true);
      }
      line.setStroke(stroke);
      line.setMouseEnabled(false);
      container.addChild(line);
    },

    /**
     * Renders objects in the foreground of the plot area.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderForegroundObjs: (chart, container, availSpace) => {
      // : Axis lines are generally rendered in the back of the foreground, but we render them after the
      // bars if only bar series are present.  We can't apply this fix with lines/areas, since the markers must appear over
      // the axis lines.
      var options = chart.getOptions();

      const hasLayering = options['comboSeriesOrder'] === 'data' && DvtChartTypeUtils.isCombo(chart);
      var clipGroup = hasLayering
        ? null
        : DvtChartPlotAreaRenderer.createClippedGroup(chart, container, availSpace);

      // Render axis lines after the clipGroup
      DvtChartPlotAreaRenderer._renderAxisLines(chart, container, availSpace);

      // plotArea border. We add it here to be above the clipGroup, but below the other foreground items
      var plotAreaBorderColor = options['plotArea']['borderColor'];
      var plotAreaBorderWidth = options['plotArea']['borderWidth'];
      if (plotAreaBorderColor && plotAreaBorderWidth != 0) {
        var plotAreaBorder = DvtChartPlotAreaRenderer._getBackgroundShape(chart, availSpace);
        plotAreaBorder.setInvisibleFill();
        plotAreaBorder.setSolidStroke(plotAreaBorderColor, null, plotAreaBorderWidth);
        plotAreaBorder.setMouseEnabled(false);
        container.addChild(plotAreaBorder);
      }

      // Data Objects for BLAC
      if (DvtChartTypeUtils.isBLAC(chart)) {
        const seriesCount = options['series'].length;
        if (hasLayering) {
          for (let index = seriesCount - 1; index >= 0; index--) {
            const seriesType = DvtChartDataUtils.getSeriesType(chart, index);
            if (seriesType !== 'area' && seriesType !== 'lineWithArea')
              clipGroup = DvtChartPlotAreaRenderer.createClippedGroup(chart, container, availSpace);

            if (seriesType === 'area')
              DvtChartPlotAreaRenderer._renderAreas(chart, container, availSpace, false, index);
            else if (seriesType === 'lineWithArea')
              DvtChartPlotAreaRenderer._renderAreas(chart, container, availSpace, true, index);
            else if (seriesType === 'bar')
              DvtChartPlotAreaRenderer._renderBars(chart, clipGroup, availSpace, index);
            else if (seriesType === 'stock')
              DvtChartPlotAreaRenderer._renderStock(chart, clipGroup, index);
            else if (seriesType === 'boxPlot')
              DvtChartPlotAreaRenderer._renderBoxPlot(chart, clipGroup, availSpace, index);
            else if (seriesType === 'line')
              DvtChartPlotAreaRenderer._renderLines(chart, container, clipGroup, availSpace, index);
          }
        } else {
          // Areas were drawn in the background. Draw lineWithAreas, bars, and lines
          if (DvtChartDataUtils.hasLineWithAreaSeries(chart))
            DvtChartPlotAreaRenderer._renderAreas(chart, container, availSpace, true);

          if (DvtChartDataUtils.hasBarSeries(chart))
            DvtChartPlotAreaRenderer._renderBars(chart, clipGroup, availSpace);

          if (DvtChartDataUtils.hasCandlestickSeries(chart))
            DvtChartPlotAreaRenderer._renderStock(chart, clipGroup);

          if (DvtChartDataUtils.hasBoxPlotSeries(chart))
            DvtChartPlotAreaRenderer._renderBoxPlot(chart, clipGroup, availSpace);

          if (DvtChartDataUtils.hasLineSeries(chart))
            DvtChartPlotAreaRenderer._renderLines(chart, container, clipGroup, availSpace);
        }
      } else if (DvtChartTypeUtils.isScatterBubble(chart)) {
        DvtChartPlotAreaRenderer._renderScatterBubble(chart, container, clipGroup, true, availSpace);
      }

      // Reference Objects
      if (
        options['xAxis']['referenceObjects'] ||
        options['yAxis']['referenceObjects'] ||
        options['y2Axis']['referenceObjects']
      ) {
        clipGroup = DvtChartPlotAreaRenderer.createClippedGroup(chart, container, availSpace);
        DvtChartRefObjRenderer.renderForegroundObjects(chart, clipGroup, availSpace);
      }

      // Initial Selection
      var selected = DvtChartDataUtils.getInitialSelection(chart);
      DvtChartEventUtils.setInitialSelection(chart, selected);

      // Initial Highlighting
      chart.highlight(DvtChartDataUtils.getHighlightedCategories(chart));
    },

    /**
     * Renders a single data label associated with a data item.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} dataItemBounds The space occupied by the data item this is associated with.
     * @param {number} seriesIndex The series of this data label.
     * @param {number} groupIndex The group of this data label.
     * @param {number} itemIndex The nested item index of this data label.
     * @param {Color} dataColor The color of the data item this label is associated with.
     * @param {number} type (optional) Data label type: low, high, or value.
     * @param {boolean} isStackLabel true if label for stack cummulative, false otherwise
     * @param {number=} originalBarSize The non rounded width(vertical) or height(horizontal) of the bar
     * @private
     */
    _renderDataLabel: (
      chart,
      container,
      dataItemBounds,
      seriesIndex,
      groupIndex,
      itemIndex,
      dataColor,
      type,
      isStackLabel,
      originalBarSize,
      marker
    ) => {
      if (DvtChartTypeUtils.isOverview(chart))
        // no data label in overview
        return;

      var isBar = DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'bar';
      const supportsOutline = DvtChartStyleUtils.supportsLabelOutline(chart, seriesIndex);
      var bHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var barDataItemDims = {
        width: bHoriz ? dataItemBounds.w : originalBarSize,
        height: bHoriz ? originalBarSize : dataItemBounds.h
      };
      var chartOptions = chart.getOptions();
      var styleDefaults = chartOptions['styleDefaults'];
      var hasY2Axis = chart.y2Axis != null;
      var hasLegend = chartOptions.legend.rendered === 'on';

      if (isBar)
        chart.getOptionsCache().putToCachedMap2D('barDims', seriesIndex, groupIndex, barDataItemDims);

      var labelString = DvtChartStyleUtils.getDataLabel(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex,
        type,
        isStackLabel
      );
      if (labelString == null) return;

      var position = DvtChartGroupUtils.getDataLabelPos(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex,
        type,
        isStackLabel
      );
      if (position == 'none') return;

      var label = new dvt.OutputText(chart.getCtx(), labelString, 0, 0);
      label.setMouseEnabled(false);

      var style = isStackLabel
        ? styleDefaults['stackLabelStyle']
        : DvtChartStyleUtils.getDataLabelStyle(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex,
            dataColor,
            position,
            type
          );
      label.setCSSStyle(style);

      if (supportsOutline) {
        label.addClassName('oj-chart-data-label-contrast');
      }

      label.setY(dataItemBounds.y + dataItemBounds.h / 2);
      label.setX(dataItemBounds.x + dataItemBounds.w / 2);
      label.alignCenter();
      label.alignMiddle();
      label._seriesIndex = seriesIndex;
      label._groupIndex = groupIndex;
      label._marker = marker;
      var textDim = label.getDimensions();
      var plotAreaDims = chart.getCache().getFromCache('plotAreaDims');
      if (!plotAreaDims) {
        plotAreaDims = chart.getPlotArea().getDimensions();
        chart.getCache().putToCache('plotAreaDims', plotAreaDims);
      }

      // Get the label coordinates for labels position outside the data item
      var getCenteredOutsideLabelCoords = (pos, itemBounds, labelDims, detectedCollisions) => {
        var coord = { x: null, y: null };

        // Check if the data label's position needs to be shift
        var nudgeUp =
          detectedCollisions && detectedCollisions.xAxis && (pos == 'left' || pos == 'right');
        var nudgeDown =
          detectedCollisions && detectedCollisions.top && (pos == 'left' || pos == 'right');
        var nudgeLeft =
          detectedCollisions &&
          (((hasY2Axis || !hasLegend) && detectedCollisions.y2Axis) || detectedCollisions.legend) &&
          (pos == 'top' || pos == 'bottom');
        var nudgeRight =
          detectedCollisions && detectedCollisions.yAxis && (pos == 'top' || pos == 'bottom');

        if (pos == 'left') {
          coord.x = itemBounds.x - labelDims.w / 2 - DvtChartStyleUtils.MARKER_DATA_LABEL_GAP;
        } else if (pos == 'right') {
          coord.x =
            itemBounds.x + itemBounds.w + labelDims.w / 2 + DvtChartStyleUtils.MARKER_DATA_LABEL_GAP;
        } else if (pos == 'top') {
          coord.y = itemBounds.y - labelDims.h / 2; // No need for buffer because itemBounds.y accounts for typography baseline
        } else if (pos == 'bottom') {
          coord.y =
            itemBounds.y +
            itemBounds.h +
            labelDims.h / 2 +
            DvtChartStyleUtils.MARKER_DATA_LABEL_GAP / 2;
        }

        var edgeLabelGap = 2 * DvtChartStyleUtils.MARKER_DATA_LABEL_GAP; // Doubling the gap around the edges because the single gap looks too small
        if (nudgeLeft) {
          coord.x = plotAreaDims.x + plotAreaDims.w - labelDims.w / 2 - edgeLabelGap;
        } else if (nudgeRight) {
          coord.x = labelDims.w / 2 + edgeLabelGap;
        } else if (nudgeUp) {
          coord.y = plotAreaDims.y + plotAreaDims.h - labelDims.h / 2 - edgeLabelGap;
        } else if (nudgeDown) {
          coord.y = labelDims.h / 2 + edgeLabelGap;
        }
        return coord;
      };

      var collision = styleDefaults['dataLabelCollision'];
      var outsideCenteredLabelCoords = getCenteredOutsideLabelCoords(
        position,
        dataItemBounds,
        textDim
      );
      if (collision === 'fitInBounds') {
        // Reset label position and coordinates if labels have collisions
        var detectedCollisions = DvtChartStyleUtils.getDataLabelCollisions(
          chart,
          outsideCenteredLabelCoords,
          textDim,
          plotAreaDims,
          bHoriz
        );
        var adjustedPosition = DvtChartStyleUtils.adjustDataLabelPos(
          position,
          detectedCollisions,
          hasY2Axis
        );

        if (adjustedPosition != position && DvtChartTypeUtils.isBubble(chart)) {
          // Adjust bubble label style if position changed
          style = isStackLabel
            ? styleDefaults['stackLabelStyle']
            : DvtChartStyleUtils.getDataLabelStyle(
                chart,
                seriesIndex,
                groupIndex,
                itemIndex,
                dataColor,
                adjustedPosition,
                type
              );
          label.setCSSStyle(style);
        }

        position = adjustedPosition;
        outsideCenteredLabelCoords = getCenteredOutsideLabelCoords(
          position,
          dataItemBounds,
          textDim,
          detectedCollisions
        );
      }

      if (outsideCenteredLabelCoords.x != null || outsideCenteredLabelCoords.y != null) {
        if (outsideCenteredLabelCoords.x != null) {
          label.setX(outsideCenteredLabelCoords.x);
        }
        if (outsideCenteredLabelCoords.y != null) {
          label.setY(outsideCenteredLabelCoords.y);
        }
      } else {
        // inside label
        if (isBar) {
          if (textDim.w > barDataItemDims.width || textDim.h > barDataItemDims.height) return; //dropping text if doesn't fit.

          if (position == 'inLeft') {
            label.setX(dataItemBounds.x + textDim.w / 2.0 + DvtChartStyleUtils.MARKER_DATA_LABEL_GAP);
          } else if (position == 'inRight') {
            label.setX(
              dataItemBounds.x +
                dataItemBounds.w -
                textDim.w / 2.0 -
                DvtChartStyleUtils.MARKER_DATA_LABEL_GAP
            );
          } else if (position == 'inTop') {
            label.setY(dataItemBounds.y + textDim.h / 2.0 + DvtChartStyleUtils.MARKER_DATA_LABEL_GAP);
          } else if (position == 'inBottom') {
            label.setY(
              dataItemBounds.y +
                dataItemBounds.h -
                textDim.h / 2.0 -
                DvtChartStyleUtils.MARKER_DATA_LABEL_GAP / 2
            );
          }
        } else if (DvtChartTypeUtils.isBubble(chart)) {
          dataItemBounds.x += DvtChartStyleUtils.MARKER_DATA_LABEL_GAP;
          dataItemBounds.y += DvtChartStyleUtils.MARKER_DATA_LABEL_GAP;
          dataItemBounds.h -= DvtChartStyleUtils.MARKER_DATA_LABEL_GAP * 2;
          dataItemBounds.w -= DvtChartStyleUtils.MARKER_DATA_LABEL_GAP * 2;

          var size = dvt.TextUtils.getOptimalFontSize(
            label.getCtx(),
            label.getTextString(),
            label.getCSSStyle(),
            dataItemBounds
          );
          label.setFontSize(size);
          if (
            !dvt.TextUtils.fitText(
              label,
              dataItemBounds.w,
              dataItemBounds.h,
              container,
              DvtChartPlotAreaRenderer._MIN_CHARS_DATA_LABEL
            )
          )
            return; //dropping text if doesn't fit.
        }

        const isPatternBg = DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex) != null;
        if (isPatternBg && !supportsOutline) {
          DvtChartPlotAreaRenderer._addLabelContrastBackground(chart, container, label);
        }
      }

      // Truncate or drop labels if they go outside the plot area. 
      if (DvtChartTypeUtils.isBar(chart)) {
        var labelDim = label.getDimensions();
        var isLabelOutsidePlotArea = false;
        var maxWidth;
        if (position == 'left' && labelDim.x < 0) {
          isLabelOutsidePlotArea = true;
          maxWidth = dataItemBounds.x - DvtChartStyleUtils.MARKER_DATA_LABEL_GAP;
        } else if (
          position == 'right' &&
          labelDim.x + labelDim.w > plotAreaDims.w + DvtChartStyleUtils.MARKER_DATA_LABEL_GAP
        ) {
          isLabelOutsidePlotArea = true;
          maxWidth = plotAreaDims.w - dataItemBounds.w - DvtChartStyleUtils.MARKER_DATA_LABEL_GAP;
        } else if (position == 'top' && labelDim.y < 0) return;
        else if (
          position == 'bottom' &&
          labelDim.y + labelDim.h >
            plotAreaDims.y + plotAreaDims.h + DvtChartStyleUtils.MARKER_DATA_LABEL_GAP
        )
          return;

        if (isLabelOutsidePlotArea) {
          if (!isNaN(labelString)) return;
          else if (dvt.TextUtils.fitText(label, maxWidth, dataItemBounds.h, container, 1)) {
            // Recalculate x co-ordinate if truncated
            textDim = label.getDimensions();
            if (position == 'left') {
              label.setX(dataItemBounds.x - textDim.w / 2 - DvtChartStyleUtils.MARKER_DATA_LABEL_GAP);
            } else if (position == 'right') {
              label.setX(
                dataItemBounds.x +
                  dataItemBounds.w +
                  textDim.w / 2 +
                  DvtChartStyleUtils.MARKER_DATA_LABEL_GAP
              );
            }
          } else return;
        }
      }

      // Reset the stroke so that the container properties aren't inherited
      if (DvtChartStyleUtils.optimizeMarkerStroke(chart)) label.setSolidStroke('none');

      container.addChild(label);
      chart.addDataLabel(label);
    },

    /**
     * Helper function. Calculates and passes the marker bounds to the data label rendering code.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.SimpleMarker} marker
     * @private
     */
    _renderDataLabelForMarker: (chart, container, marker) => {
      var logicalObject = chart.getEventManager().getLogicalObject(marker);
      if (!logicalObject) return;

      var seriesIndex = logicalObject.getSeriesIndex();
      var groupIndex = logicalObject.getGroupIndex();
      var itemIndex = logicalObject.getNestedDataItemIndex();

      if (marker instanceof dvt.SimpleMarker) {
        var markerBounds = new dvt.Rectangle(
          marker.getCx() - marker.getWidth() / 2,
          marker.getCy() - marker.getHeight() / 2,
          marker.getWidth(),
          marker.getHeight()
        );
        DvtChartPlotAreaRenderer._renderDataLabel(
          chart,
          container,
          markerBounds,
          seriesIndex,
          groupIndex,
          itemIndex,
          marker.getDataColor(),
          null,
          null,
          null,
          marker
        );
      } else if (marker instanceof DvtChartRangeMarker) {
        DvtChartPlotAreaRenderer._renderDataLabel(
          chart,
          container,
          marker.getBoundingBox1(),
          seriesIndex,
          groupIndex,
          itemIndex,
          marker.getDataColor(),
          'low'
        );
        DvtChartPlotAreaRenderer._renderDataLabel(
          chart,
          container,
          marker.getBoundingBox2(),
          seriesIndex,
          groupIndex,
          itemIndex,
          marker.getDataColor(),
          'high'
        );
      }
    },

    /**
     * Renders the data markers for scatter and bubble chart.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Container} clipGroup The group for clipping the lines and bubbles.
     * @param {boolean} bSortBySize True if markers should be sorted by size to reduce overlaps.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderScatterBubble: (chart, container, clipGroup, bSortBySize, availSpace) => {
      // Performance optimization for huge data sets.
      var markerInfos = DvtChartPlotAreaRenderer._filterScatterBubble(chart, bSortBySize);

      // Loop through the series and draw line connectors.
      var seriesIndex;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Draw the line connector if the series has one
        if (DvtChartStyleUtils.getLineType(chart, seriesIndex) != 'none')
          DvtChartPlotAreaRenderer._renderLinesForSeries(chart, clipGroup, seriesIndex, availSpace);
      }

      // Calculate the default stroke to save DOM calls.
      var borderColor = DvtChartStyleUtils.getMarkerBorderColor(chart);
      var borderWidth = DvtChartStyleUtils.getBorderWidth(chart);
      var defaultStroke = new dvt.Stroke(borderColor, 1, borderWidth);

      // Create the markers
      var markers = [];
      if (markerInfos) {
        // The stroke is optimized onto the parent container when possible.
        var bOptimizeStroke = DvtChartStyleUtils.optimizeMarkerStroke(chart);
        var defaultBorderColor = bOptimizeStroke ? defaultStroke.getColor() : null;
        var defaultBorderWidth = bOptimizeStroke ? defaultStroke.getWidth() : null;

        // Markers were filtered and markerInfo contains only the visible markers.
        for (var markerIndex = 0; markerIndex < markerInfos.length; markerIndex++) {
          var markerInfo = markerInfos[markerIndex];
          var marker = DvtChartPlotAreaRenderer._createMarker(
            chart,
            markerInfo,
            defaultBorderColor,
            defaultBorderWidth
          );
          markers.push(marker);
        }
      } else {
        for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
          var seriesMarkers = DvtChartPlotAreaRenderer._getMarkersForSeries(
            chart,
            seriesIndex,
            availSpace,
            defaultStroke
          );
          markers = markers.concat(seriesMarkers);
        }

        // Sort the markers from smallest to largest. Filtered markers were already sorted.
        if (bSortBySize) DvtChartMarkerUtils.sortMarkers(markers);
      }

      // Finally add the markers to their container.
      if (DvtChartTypeUtils.isBubble(chart))
        // For bubble, all the lines and markers are added to the clipGroups
        DvtChartPlotAreaRenderer._addMarkersToContainer(chart, clipGroup, markers, defaultStroke);
      // For scatter, don't want to have the markers in the clipGroup so they don't get clipped
      else DvtChartPlotAreaRenderer._addMarkersToContainer(chart, container, markers, defaultStroke);
    },

    /**
     * Renders the data markers for the specified line/area series.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {number} seriesIndex The series to render.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderMarkersForSeries: (chart, container, seriesIndex, availSpace) => {
      // Calculate the default stroke to save DOM calls.
      var borderColor = DvtChartStyleUtils.getMarkerBorderColor(chart, seriesIndex);
      var borderWidth = DvtChartStyleUtils.getBorderWidth(chart, seriesIndex);
      var defaultStroke = new dvt.Stroke(borderColor, 1, borderWidth);

      var markers;
      if (DvtChartDataUtils.isRangeSeries(chart, seriesIndex))
        markers = DvtChartPlotAreaRenderer._getRangeMarkersForSeries(chart, seriesIndex, availSpace);
      else
        markers = DvtChartPlotAreaRenderer._getMarkersForSeries(
          chart,
          seriesIndex,
          availSpace,
          defaultStroke
        );

      DvtChartPlotAreaRenderer._addMarkersToContainer(chart, container, markers, defaultStroke);
    },

    _addLabelContrastBackground: (chart, container, label) => {
      var textDim = label.getDimensions();
      var padding = textDim.h * 0.15;
      var cmd = dvt.PathUtils.roundedRectangle(
        textDim.x - padding,
        textDim.y,
        textDim.w + 2 * padding,
        textDim.h,
        2,
        2,
        2,
        2
      );
      var bbox = new dvt.Path(chart.getCtx(), cmd);
      bbox.setSolidFill('#FFFFFF', 0.9);
      container.addChild(bbox);
    },

    /**
     * Adds the specified data markers to the container.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {array} markers The array of data markers.
     * @param {dvt.Stroke} defaultStroke The default stroke of the markers for optimization.
     * @private
     */
    _addMarkersToContainer: (chart, container, markers, defaultStroke) => {
      // Performance optimization for scatter and bubble: Create a container for the markers and data labels.
      var markerContainer = container;
      var bOptimizeStroke = DvtChartStyleUtils.optimizeMarkerStroke(chart);
      var bOptimizeFill = DvtChartStyleUtils.optimizeMarkerFill(chart);

      if (bOptimizeStroke || bOptimizeFill) {
        markerContainer = new dvt.Container(chart.getCtx());
        if (bOptimizeStroke) markerContainer.setStroke(defaultStroke);
        else markerContainer.setInvisibleFill();
        container.addChild(markerContainer);
      }

      // Add the markers to the container
      for (var i = 0; i < markers.length; i++) {
        markerContainer.addChild(markers[i]);

        // Data Label Support
        DvtChartPlotAreaRenderer._renderDataLabelForMarker(chart, markerContainer, markers[i]);
      }

      // TODO: change to formal location for displayed data
      chart._currentMarkers.push(markers);
    },

    /**
     * Returns an object with rendering information for a single marker. Returns null
     * if the marker should be skipped. The returned object must remain consistent
     * with that returned by _getScatterBubbleMarkerInfo.
     * @param {Chart} chart The chart being rendered.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {number} itemIndex
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {object} An object with rendering information. Fields not documented as it is intended for use within this
     *                 class only.
     * @private
     */
    _getMarkerInfo: (chart, seriesIndex, groupIndex, itemIndex, availSpace) => {
      var options = chart.getOptions();

      // Skip for null or undefined values
      var dataValue = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex, itemIndex);
      if (dataValue == null || isNaN(dataValue)) return null;

      // Filter markers to optimize rendering
      if (DvtChartDataUtils.isDataItemFiltered(chart, seriesIndex, groupIndex)) return null;

      // Determine whether a visible marker is to be displayed
      var numGroups = DvtChartDataUtils.getGroupCount(chart);
      var bMarkerDisplayed = DvtChartStyleUtils.isMarkerDisplayed(
        chart,
        seriesIndex,
        groupIndex,
        itemIndex
      );
      if (!bMarkerDisplayed && (itemIndex == null || itemIndex < 0)) {
        // If both previous and next values are null, then always display a marker
        // In computing the prev and next indices for polar chart, allow the index to wrap around
        var lastIndex = numGroups - 1;
        var isPolar = DvtChartTypeUtils.isPolar(chart);
        var prevIndex = isPolar && lastIndex > 0 && groupIndex == 0 ? lastIndex : groupIndex - 1;
        var nextIndex = isPolar && lastIndex > 0 && groupIndex == lastIndex ? 0 : groupIndex + 1;

        var prevValue = DvtChartDataUtils.getVal(chart, seriesIndex, prevIndex);
        var nextValue = DvtChartDataUtils.getVal(chart, seriesIndex, nextIndex);
        if ((prevValue == null || isNaN(prevValue)) && (nextValue == null || isNaN(nextValue)))
          bMarkerDisplayed = true;
      }

      // Skip hidden markers for overview, animation, and spark.
      if (!bMarkerDisplayed) {
        if (
          DvtChartTypeUtils.isSpark(chart) ||
          ((options['_duringZoomAndScroll'] || DvtChartTypeUtils.isOverview(chart)) &&
            !DvtChartDataUtils.isDataSelected(chart, seriesIndex, groupIndex, itemIndex))
        )
          return null;
      }

      // Skip if not visible. This check is relatively slow so we do it after the above checks.
      if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex, itemIndex))
        return false;

      var bInViewport = true;
      var pos = DvtChartDataUtils.getMarkerPos(chart, seriesIndex, groupIndex, itemIndex, availSpace);
      var markerSize = DvtChartStyleUtils.getMarkerSize(chart, seriesIndex, groupIndex, itemIndex);
      if (availSpace && pos && markerSize)
        bInViewport = availSpace.intersects(
          new dvt.Rectangle(pos.x - markerSize / 2, pos.y - markerSize / 2, markerSize, markerSize)
        );

      if (!pos || !bInViewport) return null;

      return {
        seriesIndex: seriesIndex,
        groupIndex: groupIndex,
        itemIndex: itemIndex,
        x: pos.x,
        y: pos.y,
        size: markerSize,
        markerDisplayed: bMarkerDisplayed
      };
    },

    /**
     * Optimized version of _getMarkerInfo for large data bubble and scatter charts.
     * The returned object's fields must remain consistent with that returned by
     * _getMarkerInfo.
     * @param {Chart} chart The chart being rendered.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {object} An object with rendering information. Fields not documented as it is intended for use within this
     *                 class only.
     * @private
     */
    _getScatterBubbleMarkerInfo: (chart, seriesIndex, groupIndex) => {
      // Skip if not visible. This check is relatively slow so we do it after the above checks.
      if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex)) return false;

      var pos = DvtChartDataUtils.getScatterBubbleMarkerPos(chart, seriesIndex, groupIndex);
      if (!pos) return null;

      var markerSize = DvtChartStyleUtils.getMarkerSize(chart, seriesIndex, groupIndex);
      if (!markerSize) return null;

      return {
        seriesIndex: seriesIndex,
        groupIndex: groupIndex,
        x: pos.x,
        y: pos.y,
        size: markerSize
      };
    },

    /**
     * Creates and returns the array of dvt.SimpleMarker objects for the specified series.
     * @param {Chart} chart The chart being rendered.
     * @param {number} seriesIndex
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {dvt.Stroke} defaultStroke The default stroke that will be applied to the container of the markers.
     * @return {array} The array of dvt.SimpleMarker objects for the specified series.
     * @private
     */
    _getMarkersForSeries: (chart, seriesIndex, availSpace, defaultStroke) => {
      // Skip the series if it shouldn't be rendered
      if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) return [];

      // The stroke is optimized onto the parent container when possible.
      var bOptimizeStroke = DvtChartStyleUtils.optimizeMarkerStroke(chart);
      var defaultBorderColor = bOptimizeStroke ? defaultStroke.getColor() : null;
      var defaultBorderWidth = bOptimizeStroke ? defaultStroke.getWidth() : null;

      // Keep track of the markers so that they can be sorted and added
      var markers = [];

      // Loop through the groups in the series
      var numGroups = DvtChartDataUtils.getGroupCount(chart);
      for (var groupIndex = 0; groupIndex < numGroups; groupIndex++) {
        // Calculate the rendering info for the marker. If null is returned, skip.
        var markerInfo = DvtChartPlotAreaRenderer._getMarkerInfo(
          chart,
          seriesIndex,
          groupIndex,
          null,
          availSpace
        );
        if (!markerInfo) continue;

        var marker = DvtChartPlotAreaRenderer._createMarker(
          chart,
          markerInfo,
          defaultBorderColor,
          defaultBorderWidth
        );
        if (marker != null) markers.push(marker);
      }

      return markers;
    },

    /**
     * Creates the marker for the specified data item.
     * @param  {DvtChart} chart
     * @param  {object} markerInfo
     * @param  {string} defaultBorderColor
     * @param  {string} defaultBorderWidth
     * @return {dvt.SimpleMarker}
     * @private
     */
    _createMarker: (chart, markerInfo, defaultBorderColor, defaultBorderWidth) => {
      var isTouchDevice = dvt.Agent.isTouchDevice();
      var context = chart.getCtx();

      var bOptimizeStroke = DvtChartStyleUtils.optimizeMarkerStroke(chart);
      var bOptimizeInvisibleFill = DvtChartStyleUtils.optimizeMarkerFill(chart);

      // Create the marker
      var marker;
      var seriesIndex = markerInfo.seriesIndex;
      var groupIndex = markerInfo.groupIndex;
      var itemIndex = markerInfo.itemIndex;
      var dataColor = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex, itemIndex);
      var markerShape = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex, groupIndex, itemIndex);
      var markerDisplayed = markerInfo.markerDisplayed;
      if (markerDisplayed == null)
        markerDisplayed = DvtChartStyleUtils.isMarkerDisplayed(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex
        );

      if (markerDisplayed) {
        // Support for visible markers
        var source = DvtChartStyleUtils.getImageSource(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex,
          'source'
        );
        if (source) {
          var sourceSelected = DvtChartStyleUtils.getImageSource(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex,
            'sourceSelected'
          );
          var sourceHover = DvtChartStyleUtils.getImageSource(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex,
            'sourceHover'
          );
          var sourceHoverSelected = DvtChartStyleUtils.getImageSource(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex,
            'sourceHoverSelected'
          );
          marker = new dvt.ImageMarker(
            context,
            markerInfo.x,
            markerInfo.y,
            markerInfo.size,
            markerInfo.size,
            null,
            source,
            sourceSelected,
            sourceHover,
            sourceHoverSelected
          );
          if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex)) {
            marker.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
          }
        } else {
          marker = new dvt.SimpleMarker(
            context,
            markerShape,
            markerInfo.x,
            markerInfo.y,
            markerInfo.size,
            markerInfo.size,
            null,
            null,
            true
          );

          // Apply the marker style
          marker.setFill(
            DvtChartSeriesEffectUtils.getMarkerFill(chart, seriesIndex, groupIndex, itemIndex)
          );

          var userBorderColor = DvtChartStyleUtils.getBorderColor(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex
          );
          var markerDefaultBorderColor = DvtChartStyleUtils.getDefaultMarkerBorderColor(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex
          );
          var userBorderWidth = DvtChartStyleUtils.getUserBorderWidth(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex
          );
          var markerDefaultBorderWidth = DvtChartStyleUtils.getDefaultMarkerBorderWidth(
            chart,
            seriesIndex,
            groupIndex,
            itemIndex
          );

          var borderColor = userBorderColor || markerDefaultBorderColor;
          var borderWidth = userBorderWidth !== null ? userBorderWidth : markerDefaultBorderWidth;

          if (borderColor !== defaultBorderColor || borderWidth !== defaultBorderWidth) {
            marker.setSolidStroke(borderColor, null, borderWidth);
          }

          // Set the data color, used for data label generation
          marker.setDataColor(dataColor, true);

          if (chart.getCtx().getThemeBehavior() === 'redwood') {
            if (DvtChartTypeUtils.isBubble(chart)) {
              marker.addClassName('oj-dvt-bubble-marker');
            }
            if (!userBorderColor && !DvtChartTypeUtils.isBubble(chart)) {
              marker.addClassName('oj-dvt-default-border-color');
            }
            if (userBorderWidth == null) {
              marker.addClassName('oj-dvt-default-border-width');
            }
            if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex)) {
              marker.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
              if (DvtChartTypeUtils.isBubble(chart)) {
                marker.setFeedbackClassName('oj-dvt-selectable');
              } else {
                marker.setFeedbackClassName('oj-dvt-selectable-marker');
              }
            }
          } else {
            if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex)) {
              marker.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
            }
            // Apply the selection effects, which are also used for keyboard focus.
            var hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(dataColor);
            var innerColor = DvtChartStyleUtils.getSelectedInnerColor(chart);
            var outerColor = DvtChartStyleUtils.getSelectedOuterColor(chart);
            marker.setHoverStroke(
              new dvt.Stroke(innerColor, 1, 1),
              new dvt.Stroke(hoverColor, 1, 3.5)
            );
            marker.setSelectedStroke(
              new dvt.Stroke(innerColor, 1, 1.5),
              new dvt.Stroke(outerColor, 1, 4.5)
            );
            marker.setSelectedHoverStroke(
              new dvt.Stroke(innerColor, 1, 1.5),
              new dvt.Stroke(hoverColor, 1, 4.5)
            );
          }
          marker.addClassName(
            DvtChartStyleUtils.getMarkerClassName(chart, seriesIndex, groupIndex, itemIndex)
          );
          marker.setStyle(
            DvtChartStyleUtils.getMarkerStyle(chart, seriesIndex, groupIndex, itemIndex)
          );
        }

        // Make sure that the marker hit area is large enough for touch devices ()
        // Also make sure there is only 1 invisible marker ()
        if (isTouchDevice && markerInfo.size < DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE)
          DvtChartPlotAreaRenderer._addMarkerHitArea(
            marker,
            markerInfo.x,
            markerInfo.y,
            bOptimizeStroke
          );
      } else {
        // Support for invisible markers for tooltips/interactivity
        if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex)) {
          marker = new DvtChartLineMarker(
            context,
            markerShape,
            markerInfo.x,
            markerInfo.y,
            markerInfo.size,
            bOptimizeStroke
          );
          marker.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
          if (isTouchDevice)
            DvtChartPlotAreaRenderer._addMarkerHitArea(
              marker,
              markerInfo.x,
              markerInfo.y,
              bOptimizeStroke
            );
        } else {
          // Selection not supported
          if (isTouchDevice) markerInfo.size = DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE;

          marker = new DvtChartLineMarker(
            context,
            dvt.SimpleMarker.SQUARE,
            markerInfo.x,
            markerInfo.y,
            markerInfo.size,
            bOptimizeStroke
          );
        }

        if (!bOptimizeInvisibleFill) marker.setInvisibleFill();

        marker.setDataColor(dataColor);
      }

      // Associate the marker for interactivity
      DvtChartObjPeer.associate(marker, chart, seriesIndex, groupIndex, itemIndex, markerInfo);

      return marker;
    },

    /**
     * Adds hit area to marker.
     * @param {dvt.SimpleMarker} marker
     * @param {number} x The marker x position.
     * @param {number} y The marker y position.
     * @param {boolean} bOptimizeStroke Whether the marker stroke is defined in the marker container.
     * @private
     */
    _addMarkerHitArea: (marker, x, y, bOptimizeStroke) => {
      var hitArea = new dvt.Rect(
        marker.getCtx(),
        x - DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE / 2,
        y - DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE / 2,
        DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE,
        DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE
      );

      // If stroke is optimized by defining in the container, it needs to be removed from the hit area.
      if (bOptimizeStroke) hitArea.setSolidStroke('none');

      hitArea.setInvisibleFill();
      marker.addChild(hitArea);
    },

    /**
     * Creates and returns the array of DvtChartRangeMarker objects for the specified series.
     * @param {Chart} chart The chart being rendered.
     * @param {number} seriesIndex
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {array} The array of DvtChartRangeMarker objects for the specified series.
     * @private
     */
    _getRangeMarkersForSeries: (chart, seriesIndex, availSpace) => {
      // Skip the series if it shouldn't be rendered
      if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) return [];

      var isTouchDevice = dvt.Agent.isTouchDevice();
      var context = chart.getCtx();
      var xAxis = chart.xAxis;
      var yAxis = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex) ? chart.y2Axis : chart.yAxis;
      var options = chart.getOptions();
      var numGroups = DvtChartDataUtils.getGroupCount(chart);

      // Keep track of the markers so that they can be sorted and added
      var markers = [];

      // Loop through the groups in the series
      for (var groupIndex = 0; groupIndex < numGroups; groupIndex++) {
        // Filter markers to optimize rendering
        if (DvtChartDataUtils.isDataItemFiltered(chart, seriesIndex, groupIndex)) continue;

        // Skip if not visible
        if (!DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex)) continue;

        // Get the axis values
        var xCoord = xAxis.getCoordAt(DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex));
        var lowCoord = yAxis.getUnboundedCoordAt(
          DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex)
        );
        var highCoord = yAxis.getUnboundedCoordAt(
          DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex)
        );

        if (xCoord == null || lowCoord == null || highCoord == null) continue;

        var bMarkerDisplayed = DvtChartStyleUtils.isMarkerDisplayed(chart, seriesIndex, groupIndex);
        if (!bMarkerDisplayed) {
          // If both previous and next values are null, then always display a marker
          // In computing the prev and next indices for polar chart, allow the index to wrap around
          var lastIndex = numGroups - 1;
          var isPolar = DvtChartTypeUtils.isPolar(chart);
          var prevIndex = isPolar && lastIndex > 0 && groupIndex == 0 ? lastIndex : groupIndex - 1;
          var nextIndex = isPolar && lastIndex > 0 && groupIndex == lastIndex ? 0 : groupIndex + 1;

          var prevLowValue = DvtChartDataUtils.getLowVal(chart, seriesIndex, prevIndex);
          var prevHighValue = DvtChartDataUtils.getHighVal(chart, seriesIndex, prevIndex);
          var nextLowValue = DvtChartDataUtils.getLowVal(chart, seriesIndex, nextIndex);
          var nextHighValue = DvtChartDataUtils.getHighVal(chart, seriesIndex, prevIndex);

          if (
            prevLowValue == null &&
            prevHighValue == null &&
            nextLowValue == null &&
            nextHighValue == null
          )
            bMarkerDisplayed = true;
        }

        // If the chart is inside overview or in the middle of animation, don't render invisible markers unless the marker is selected.
        if (
          (options['_duringZoomAndScroll'] ||
            DvtChartTypeUtils.isOverview(chart) ||
            DvtChartTypeUtils.isSpark(chart)) &&
          !bMarkerDisplayed &&
          !DvtChartDataUtils.isDataSelected(chart, seriesIndex, groupIndex)
        )
          continue;

        // Store the center of the data point relative to the plot area (for marquee selection)
        var pLow = DvtChartCoordUtils.convertAxisCoord(
          chart,
          new dvt.Point(xCoord, lowCoord),
          availSpace
        );
        var pHigh = DvtChartCoordUtils.convertAxisCoord(
          chart,
          new dvt.Point(xCoord, highCoord),
          availSpace
        );
        var dataPos = new dvt.Point((pLow.x + pHigh.x) / 2, (pLow.y + pHigh.y) / 2);

        // Create the marker. Even if the marker is invisible, we need it for keyboard and voiceover support.
        var markerSize = DvtChartStyleUtils.getMarkerSize(chart, seriesIndex, groupIndex);
        var marker = new DvtChartRangeMarker(
          context,
          pLow.x,
          pLow.y,
          pHigh.x,
          pHigh.y,
          markerSize,
          !bMarkerDisplayed
        );
        var fill = DvtChartSeriesEffectUtils.getMarkerFill(chart, seriesIndex, groupIndex);
        var borderColor = DvtChartStyleUtils.getMarkerBorderColor(chart, seriesIndex, groupIndex);
        var borderWidth = DvtChartStyleUtils.getBorderWidth(chart, seriesIndex, groupIndex);
        var stroke = new dvt.Stroke(borderColor, 1, borderWidth);
        var dataColor = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex);
        var innerColor = DvtChartStyleUtils.getSelectedInnerColor(chart);
        var outerColor = DvtChartStyleUtils.getSelectedOuterColor(chart);
        marker.setStyleProperties(fill, stroke, dataColor, innerColor, outerColor);

        if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex))
          marker.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());

        // Create hit area
        var hitArea = new dvt.Line(context, pLow.x, pLow.y, pHigh.x, pHigh.y);
        hitArea.setSolidStroke(
          'rgba(0,0,0,0)',
          null,
          isTouchDevice
            ? Math.max(markerSize, DvtChartPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE)
            : markerSize
        );
        marker.addChild(hitArea);

        // Add it to the markers array for sorting and addition to the display list later
        markers.push(marker);

        // Associate the marker for interactivity
        DvtChartObjPeer.associate(marker, chart, seriesIndex, groupIndex, null, dataPos);
      }

      return markers;
    },

    /**
     * Renders all bar series for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace
     * @private
     */
    _renderBars: (chart, container, availSpace, barSeriesIndex) => {
      var bHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var bPolar = DvtChartTypeUtils.isPolar(chart);
      var bStock = DvtChartTypeUtils.isStock(chart);
      var bPixelSpacing = DvtChartStyleUtils.getBarSpacing(chart) == 'pixel';
      var isR2L = dvt.Agent.isRightToLeft(chart.getCtx());
      var hasStackLabel = DvtChartStyleUtils.isStackLabelRendered(chart);
      var isStacked = DvtChartDataUtils.isStacked(chart);

      // fix for chart stack label for data with series count < 2; 
      if (DvtChartDataUtils.getSeriesCount(chart) < 2 && hasStackLabel) {
        isStacked = true;
      }
      var innerColor = DvtChartStyleUtils.getSelectedInnerColor(chart);
      var outerColor = DvtChartStyleUtils.getSelectedOuterColor(chart);
      var duringZoomAndScroll = chart.getOptions()['_duringZoomAndScroll'];
      var groupWidth = DvtChartStyleUtils.getGroupWidth(chart);
      var prevStackYCoords = {};

      // Iterate through the data
      for (
        var seriesIndex = 0;
        seriesIndex < DvtChartDataUtils.getSeriesCount(chart);
        seriesIndex++
      ) {
        if (
          DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'bar' ||
          (barSeriesIndex !== undefined && barSeriesIndex !== seriesIndex)
        )
          continue;

        DvtChartPlotAreaRenderer._filterPointsForSeries(chart, seriesIndex);

        var pathCmd = ''; // path command for optimized rendering during zoom & scroll
        var itemStyleSet = chart.getOptionsCache().getFromCachedMap('itemStyleSet', seriesIndex);
        var stackCategory = DvtChartDataUtils.getStackCategory(chart, seriesIndex) || '';
        var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);

        var minMaxGroupIndex = DvtChartAxisUtils.getViewportMinMaxGroupIdx(chart, seriesIndex);
        for (
          var groupIndex = minMaxGroupIndex['min'] - 1;
          groupIndex <= minMaxGroupIndex['max'] + 1;
          groupIndex++
        ) {
          if (
            DvtChartDataUtils.isDataItemFiltered(chart, seriesIndex, groupIndex) ||
            !DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex)
          )
            continue;

          if (DvtChartDataUtils.getZVal(chart, seriesIndex, groupIndex) == 0) continue;

          var barInfo = DvtChartGroupUtils.getBarInfo(chart, seriesIndex, groupIndex, availSpace);
          if (barInfo == null) continue;

          // Get the y-axis position
          var yCoord = barInfo.yCoord;
          var baseCoord = barInfo.baseCoord;
          var axisCoord = barInfo.axisCoord;
          var x1 = barInfo.x1;
          var x2 = barInfo.x2;
          var barWidth = barInfo.barWidth;

          // For stack bars, don't render bar if it's height is less than .5px and
          // the gap between the previously rendered series is less than .5px
          if (isStacked) {
            var bNegative = DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex) < 0;
            var stackKey = '' + groupIndex + stackCategory + bAssignedToY2 + bNegative;
            if (
              Math.abs(baseCoord - yCoord) < 0.5 &&
              Math.abs(yCoord - prevStackYCoords[stackKey]) < 0.5 &&
              !DvtChartDataUtils.isOutermostBar(chart, seriesIndex, groupIndex)
            )
              continue;
            else {
              if (prevStackYCoords[stackKey]) baseCoord = prevStackYCoords[stackKey];
              prevStackYCoords[stackKey] = yCoord;
            }
          }

          // Support for 0 value bars. If the bar is smaller than a pixel:
          // - draw as 1px bar if it's range series
          // - draw as an invisible 3px bar otherwise
          var bInvisible = false;
          if (Math.abs(yCoord - baseCoord) < 1) {
            if (DvtChartDataUtils.isRangeSeries(chart, seriesIndex)) yCoord--;
            else if (!isStacked || DvtChartDataUtils.isOutermostBar(chart, seriesIndex, groupIndex)) {
              bInvisible = true;
              const globalMax = bAssignedToY2
                ? chart.y2Axis.getInfo().getGlobalMax()
                : chart.yAxis.getInfo().getGlobalMax(); // JET-42766: Make sure the small bar should render inside the plot area.
              if (yCoord > baseCoord || (bHoriz && !isR2L && yCoord == baseCoord) || globalMax <= 0)
                // if horizontal, R2L must be considered to draw bar on positive side of baseline
                yCoord = baseCoord + 3;
              else yCoord = baseCoord - 3;
            }
          }

          // Create and apply the style
          var shape;
          if (bPolar)
            shape = new DvtChartPolarBar(chart, axisCoord, baseCoord, yCoord, x1, x2, availSpace);
          else {
            // Optimize rendering during zoom & scroll by drawing all the bars belonging to one series as a single path.
            // If the items in the series have custom styles, we can't use this optimization.
            var bOptimize = duringZoomAndScroll && groupWidth < 5 && !itemStyleSet;
            shape = new DvtChartBar(chart, axisCoord, baseCoord, yCoord, x1, x2, bOptimize);
            if (bOptimize) {
              var bbox = shape.getBoundingBox();
              pathCmd +=
                dvt.PathUtils.moveTo(bbox.x, bbox.y) +
                dvt.PathUtils.horizontalLineTo(bbox.x + bbox.w) +
                dvt.PathUtils.verticalLineTo(bbox.y + bbox.h) +
                dvt.PathUtils.horizontalLineTo(bbox.x) +
                dvt.PathUtils.closePath();
              continue;
            }
          }
          container.addChild(shape);

          if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex))
            shape.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());

          var fill,
            stroke = null;
          if (bInvisible)
            // Apply an invisible fill for small bars
            fill = dvt.SolidFill.invisibleFill();
          else {
            // Apply the specified style
            fill = DvtChartSeriesEffectUtils.getBarFill(chart, seriesIndex, groupIndex, barWidth);
            var borderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex, groupIndex);
            var borderWidth = DvtChartStyleUtils.getBorderWidth(chart, seriesIndex, groupIndex);
            if (borderColor) stroke = new dvt.Stroke(borderColor, 1, borderWidth);
          }

          // Apply the fill, stroke, and selection colors
          var dataColor = DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
          var className = DvtChartStyleUtils.getClassName(chart, seriesIndex, groupIndex);
          var style = DvtChartStyleUtils.getStyle(chart, seriesIndex, groupIndex);
          shape.setStyleProperties(fill, stroke, dataColor, innerColor, outerColor, className, style);

          // Use pixel hinting for pixel bar spacing
          if (bPixelSpacing) shape.setPixelHinting(true);

          // Associate for interactivity
          DvtChartObjPeer.associate(shape, chart, seriesIndex, groupIndex, null, barInfo.dataPos);

          // Rendering data labels for this bar
          if (DvtChartDataUtils.isRangeSeries(chart, seriesIndex)) {
            DvtChartPlotAreaRenderer._renderDataLabel(
              chart,
              container,
              shape.getBoundingBox(),
              seriesIndex,
              groupIndex,
              null,
              dataColor,
              'low',
              false,
              shape.getOriginalBarSize()
            );
            DvtChartPlotAreaRenderer._renderDataLabel(
              chart,
              container,
              shape.getBoundingBox(),
              seriesIndex,
              groupIndex,
              null,
              dataColor,
              'high',
              false,
              shape.getOriginalBarSize()
            );
          } else
            DvtChartPlotAreaRenderer._renderDataLabel(
              chart,
              container,
              shape.getBoundingBox(),
              seriesIndex,
              groupIndex,
              null,
              dataColor,
              null,
              false,
              shape.getOriginalBarSize()
            );

          var markers = [];
          markers.push(shape);

          if (!(bStock && seriesIndex != 0)) {
            // TODO: change to formal location for displayed data
            chart._currentMarkers.push(markers);
          }

          // Render stack cumulative labels
          if (hasStackLabel && DvtChartDataUtils.isOutermostBar(chart, seriesIndex, groupIndex)) {
            DvtChartPlotAreaRenderer._renderDataLabel(
              chart,
              container,
              shape.getBoundingBox(),
              seriesIndex,
              groupIndex,
              null,
              null,
              null,
              true,
              shape.getOriginalBarSize()
            );
          }
        }

        if (pathCmd) {
          // If optimizing for zoom & scroll, create the path and set the series style properties
          var path = new dvt.Path(chart.getCtx(), pathCmd);

          var seriesColor = DvtChartStyleUtils.getColor(chart, seriesIndex);
          path.setSolidFill(seriesColor);

          var seriesBorderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex);
          if (seriesBorderColor) {
            var seriesBorderWidth = DvtChartStyleUtils.getBorderWidth(chart, seriesIndex);
            path.setSolidStroke(seriesBorderColor, null, seriesBorderWidth);
          }

          var seriesClassName = DvtChartStyleUtils.getClassName(chart, seriesIndex);
          var seriesStyle = DvtChartStyleUtils.getStyle(chart, seriesIndex);
          path.setClassName(seriesClassName).setStyle(seriesStyle);

          if (bPixelSpacing) path.setPixelHinting(true);

          container.addChild(path);
        }
      }
    },

    /**
     * Renders all stock values and ranges for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @private
     */
    _renderStock: (chart, container) => {
      var options = chart.getOptions();
      var xAxis = chart.xAxis;
      var yAxis = chart.yAxis;

      // Only a single series is supported right now
      if (DvtChartDataUtils.getSeriesType(chart, 0) != 'candlestick') return;

      // Iterate through the data
      var minMaxGroupIndex = DvtChartAxisUtils.getViewportMinMaxGroupIdx(chart, 0);
      for (
        var groupIndex = minMaxGroupIndex['min'] - 1;
        groupIndex <= minMaxGroupIndex['max'] + 1;
        groupIndex++
      ) {
        if (!DvtChartDataUtils.isDataItemRendered(chart, 0, groupIndex)) continue;

        var dataItem = DvtChartDataUtils.getDataItem(chart, 0, groupIndex);
        if (!dataItem) continue;

        var openValue = dataItem['open'];
        var closeValue = dataItem['close'];
        var lowValue = dataItem['low'];
        var highValue = dataItem['high'];

        var renderRange = lowValue != null && highValue != null;
        // Don't render bars whose value is null
        if (openValue == null || closeValue == null) continue;

        // Get the position on the x axis and the bar width.
        var xValue = DvtChartDataUtils.getXVal(chart, 0, groupIndex);
        var xCoord = xAxis.getUnboundedCoordAt(xValue);
        var barWidth = DvtChartStyleUtils.getBarWidth(chart, 0, groupIndex);

        // Get the position on the y axis
        var openCoord = yAxis.getBoundedCoordAt(openValue);
        var closeCoord = yAxis.getBoundedCoordAt(closeValue);
        var lowCoord,
          highCoord = null;
        if (renderRange) {
          lowCoord = yAxis.getBoundedCoordAt(lowValue);
          highCoord = yAxis.getBoundedCoordAt(highValue);
        }

        // Create the candlestick
        var candlestick = new DvtChartCandlestick(
          chart.getCtx(),
          xCoord,
          barWidth,
          openCoord,
          closeCoord,
          lowCoord,
          highCoord
        );
        container.addChild(candlestick);

        if (DvtChartStyleUtils.isSelectable(chart, 0, groupIndex))
          candlestick.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());

        // Find the fill and stroke to be applied.
        var fill = DvtChartSeriesEffectUtils.getBarFill(chart, 0, groupIndex, barWidth);
        var stroke = null;
        var borderColor = DvtChartStyleUtils.getBorderColor(chart, 0, groupIndex);
        var borderWidth = DvtChartStyleUtils.getBorderWidth(chart, 0, groupIndex);
        if (borderColor) stroke = new dvt.Stroke(borderColor, 1, borderWidth);
        else if (fill instanceof dvt.PatternFill)
          // Patterns aren't usable here without the stroke.
          stroke = new dvt.Stroke(fill.getColor(), 1, borderWidth);

        // Find the hover and selected styles and pass to the candlestick.
        var dataColor = DvtChartStyleUtils.getColor(chart, 0, groupIndex);
        var innerColor = DvtChartStyleUtils.getSelectedInnerColor(chart);
        var outerColor = DvtChartStyleUtils.getSelectedOuterColor(chart);
        var rangeColor = options['styleDefaults']['stockRangeColor'];
        candlestick.setChangeStyle(fill, stroke, dataColor, innerColor, outerColor);
        candlestick.setRangeStyle(new dvt.SolidFill(rangeColor), stroke, rangeColor, outerColor);

        // Associate for interactivity
        var dataPos = new dvt.Point(xCoord, (openCoord + closeCoord) / 2);
        DvtChartObjPeer.associate(candlestick, chart, 0, groupIndex, null, dataPos);

        // TODO: Illegal private accesses for data cursor.
        // chart._currentMarkers will be removed when data cursor code is cleaned up
        var markers = [];
        markers.push(candlestick._changeShape);
        chart._currentMarkers.push(markers);
      }
    },

    /**
     * Renders box plot series for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace
     * @private
     */
    _renderBoxPlot: (chart, container, availSpace, boxPlotSeriesIndex) => {
      var xAxis = chart.xAxis;

      for (
        var seriesIndex = 0;
        seriesIndex < DvtChartDataUtils.getSeriesCount(chart);
        seriesIndex++
      ) {
        if (boxPlotSeriesIndex !== undefined && boxPlotSeriesIndex !== seriesIndex) continue;
        var minMaxGroupIndex = DvtChartAxisUtils.getViewportMinMaxGroupIdx(chart, seriesIndex);

        for (
          var groupIndex = minMaxGroupIndex['min'] - 1;
          groupIndex <= minMaxGroupIndex['max'] + 1;
          groupIndex++
        ) {
          if (
            !DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex) ||
            DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'boxPlot'
          )
            continue;

          var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
          if (!dataItem) continue;

          var lowValue = dataItem['low'];
          var q1Value = dataItem['q1'];
          var q2Value = dataItem['q2'];
          var q3Value = dataItem['q3'];
          var highValue = dataItem['high'];

          // Don't render anything if the required values aren't specified
          if (
            lowValue == null ||
            q1Value == null ||
            q2Value == null ||
            q3Value == null ||
            highValue == null
          )
            continue;

          // Get the position on the x axis and the box width

          var boxWidth = DvtChartStyleUtils.getBarWidth(chart, seriesIndex, groupIndex);
          var offsetMap = DvtChartStyleUtils.getBarCategoryOffsetMap(chart, groupIndex);
          var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
          var category = DvtChartDataUtils.getStackCategory(chart, seriesIndex);
          var boxOffset = offsetMap[bAssignedToY2 ? 'y2' : 'y'][category] + boxWidth / 2;
          if (dvt.Agent.isRightToLeft(chart.getCtx()) && DvtChartTypeUtils.isVertical(chart))
            boxOffset *= -1;

          var xValue = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);
          var xCoord = xAxis.getUnboundedCoordAt(xValue) + boxOffset;

          // Get the position on the y axis
          var yAxis = bAssignedToY2 ? chart.y2Axis : chart.yAxis;
          var lowCoord = yAxis.getBoundedCoordAt(lowValue);
          var q1Coord = yAxis.getBoundedCoordAt(q1Value);
          var q2Coord = yAxis.getBoundedCoordAt(q2Value);
          var q3Coord = yAxis.getBoundedCoordAt(q3Value);
          var highCoord = yAxis.getBoundedCoordAt(highValue);

          // Create the candlestick
          var styleOptions = DvtChartStyleUtils.getBoxPlotStyleOptions(
            chart,
            seriesIndex,
            groupIndex
          );
          var boxAndWhisker = new DvtChartBoxAndWhisker(
            chart,
            xCoord,
            boxWidth,
            lowCoord,
            q1Coord,
            q2Coord,
            q3Coord,
            highCoord,
            styleOptions
          );
          container.addChild(boxAndWhisker);

          if (DvtChartStyleUtils.isSelectable(chart, seriesIndex, groupIndex))
            boxAndWhisker.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());

          // Associate for interactivity
          var dataPos = DvtChartCoordUtils.convertAxisCoord(
            chart,
            new dvt.Point(xCoord, q2Coord),
            availSpace
          );
          DvtChartObjPeer.associate(boxAndWhisker, chart, seriesIndex, groupIndex, null, dataPos);

          DvtChartPlotAreaRenderer._renderBoxPlotMarkers(
            chart,
            container,
            seriesIndex,
            groupIndex,
            availSpace,
            xCoord
          );

          // TODO: Illegal private accesses for data cursor.
          // chart._currentMarkers will be removed when data cursor code is cleaned up
          chart._currentMarkers.push([boxAndWhisker._medianLine]);
        }
      }
    },

    /**
     * Renders box plot markers for the given data item.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @param {dvt.Rectangle} availSpace
     * @param {number} xCoord The x coord of the markers.
     * @private
     */
    _renderBoxPlotMarkers: (chart, container, seriesIndex, groupIndex, availSpace, xCoord) => {
      // Calculate the default stroke to save DOM calls.
      var defaultBorderColor = DvtChartStyleUtils.getMarkerBorderColor(
        chart,
        seriesIndex,
        groupIndex
      );
      var defaultBorderWidth = DvtChartStyleUtils.getBorderWidth(chart, seriesIndex, groupIndex);
      var defaultStroke = new dvt.Stroke(defaultBorderColor, 1, defaultBorderWidth);

      // Keep track of the markers so that they can be sorted and added
      var markers = [];

      // Loop through the groups in the series
      var numItems = DvtChartDataUtils.getNestedDataItemCount(chart, seriesIndex, groupIndex);
      for (var itemIndex = 0; itemIndex < numItems; itemIndex++) {
        // Calculate the rendering info for the marker. If null is returned, skip.
        var markerInfo = DvtChartPlotAreaRenderer._getMarkerInfo(
          chart,
          seriesIndex,
          groupIndex,
          itemIndex,
          availSpace
        );
        if (!markerInfo) continue;

        // Box plot markers should also use the box offset, so pass it here instead of recalculating
        if (DvtChartTypeUtils.isHorizontal(chart)) markerInfo.y = xCoord;
        else markerInfo.x = xCoord;

        var marker = DvtChartPlotAreaRenderer._createMarker(
          chart,
          markerInfo,
          defaultBorderColor,
          defaultBorderWidth
        );
        if (marker != null) markers.push(marker);
      }

      DvtChartPlotAreaRenderer._addMarkersToContainer(chart, container, markers, defaultStroke);
    },

    /**
     * Renders all line series for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Container} clipGroup The group for clipping the line and the area.
     * @param {dvt.Rectangle} availSpace
     * @private
     */
    _renderLines: (chart, container, clipGroup, availSpace, lineSeriesIndex) => {
      // Find all series that are lines
      var lineSeries = [],
        seriesIndex;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if it shouldn't be rendered or if the series type is not line.
        if (
          !DvtChartDataUtils.isSeriesRendered(chart, seriesIndex) ||
          DvtChartDataUtils.getSeriesType(chart, seriesIndex) != 'line' ||
          (lineSeriesIndex !== undefined && lineSeriesIndex !== seriesIndex)
        )
          continue;
        else lineSeries.push(seriesIndex);
      }

      // Render the lines
      for (var lineIndex = 0; lineIndex < lineSeries.length; lineIndex++) {
        seriesIndex = lineSeries[lineIndex];

        if (DvtChartStyleUtils.getLineType(chart, seriesIndex) == 'none') continue;

        // Filter points to reduce render time
        DvtChartPlotAreaRenderer._filterPointsForSeries(chart, seriesIndex);

        DvtChartPlotAreaRenderer._renderLinesForSeries(chart, clipGroup, seriesIndex, availSpace);
      }

      // Render the markers
      for (lineIndex = 0; lineIndex < lineSeries.length; lineIndex++)
        DvtChartPlotAreaRenderer._renderMarkersForSeries(
          chart,
          container,
          lineSeries[lineIndex],
          availSpace
        );
    },

    /**
     * Renders all area series for the given chart.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace
     * @param {boolean} isLineWithArea True if rendering lineWithArea.
     * @private
     */
    _renderAreas: (chart, container, availSpace, isLineWithArea, areaSeriesIndex) => {
      // Find all series that are areas
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var seriesType = isLineWithArea ? 'lineWithArea' : 'area';
      var yAreaSeries = [],
        y2AreaSeries = [];

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if it shouldn't be rendered or if the series type is not area.
        if (
          !DvtChartDataUtils.isSeriesRendered(chart, seriesIndex) ||
          DvtChartDataUtils.getSeriesType(chart, seriesIndex) != seriesType ||
          (areaSeriesIndex !== undefined && areaSeriesIndex !== seriesIndex)
        )
          continue;

        if (DvtChartDataUtils.isAssignedToY2(chart, seriesIndex)) y2AreaSeries.push(seriesIndex);
        else yAreaSeries.push(seriesIndex);
      }

      if (yAreaSeries.length > 0)
        DvtChartPlotAreaRenderer._renderAreasForAxis(
          chart,
          container,
          yAreaSeries,
          chart.yAxis.getBaselineCoord(),
          availSpace,
          isLineWithArea
        );

      if (y2AreaSeries.length > 0)
        DvtChartPlotAreaRenderer._renderAreasForAxis(
          chart,
          container,
          y2AreaSeries,
          chart.y2Axis.getBaselineCoord(),
          availSpace,
          isLineWithArea
        );
    },

    /**
     * Renders all area series for the given y or y2 axis.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render to.
     * @param {array} areaSeries The series indices for the area series that belongs to the axis.
     * @param {number} baselineCoord The baseline coord of the axis.
     * @param {dvt.Rectangle} availSpace
     * @param {boolean} isLineWithArea True if rendering lineWithArea.
     * @private
     */
    _renderAreasForAxis: (
      chart,
      container,
      areaSeries,
      baselineCoord,
      availSpace,
      isLineWithArea
    ) => {
      var bStacked = DvtChartDataUtils.isStacked(chart);

      // Create group to clip the areas
      var clippedGroup = DvtChartPlotAreaRenderer.createClippedGroup(chart, container, availSpace);

      // For stacked areas, the bottom shape of the area has to follow the shape formed by the areas below it.
      // The prevCoords array stores the shape that has formed so far. For each group, it stores x, y1, and y2. When there's
      // a transition to/from null values, the shape at x jumps from y1 to y2. Otherwise, y1 == y2.
      var prevCoordsMap = {};
      var prevTypeMap = {};
      var prevCoordsMapNegative = {};
      var prevTypeMapNegative = {};

      // Construct baseline coords array to build the first area on the stack
      var baselineCoords = [];
      var groupCount = DvtChartDataUtils.getGroupCount(chart);
      for (var i = 0; i < groupCount; i++) {
        baselineCoords.push(
          new DvtChartCoord(
            null,
            baselineCoord,
            baselineCoord,
            i,
            DvtChartDataUtils.getGroup(chart, i),
            true
          )
        );
      }

      // Loop through the series
      for (var areaIndex = 0; areaIndex < areaSeries.length; areaIndex++) {
        var seriesIndex = areaSeries[areaIndex];
        var category = DvtChartDataUtils.getStackCategory(chart, seriesIndex);
        var isSeriesNegative = DvtChartDataUtils.isSeriesNegative(chart, seriesIndex);
        // Use previous coords of the last area on the current series' axis with the same stackCategory
        var prevCoords = prevCoordsMap[category];
        var prevType = prevTypeMap[category];
        var prevCoordsNegative = prevCoordsMapNegative[category];
        var prevTypeNegative = prevTypeMapNegative[category];

        if (DvtChartStyleUtils.getLineType(chart, seriesIndex) == 'none') {
          // render markers only
          DvtChartPlotAreaRenderer._renderMarkersForSeries(chart, container, seriesIndex, availSpace);
          continue;
        }

        var fill = DvtChartSeriesEffectUtils.getAreaFill(chart, seriesIndex);
        var borderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex);
        var borderWidth = DvtChartStyleUtils.getBorderWidth(chart, seriesIndex);
        var className = DvtChartStyleUtils.getAreaClassName(chart, seriesIndex);
        var style = DvtChartStyleUtils.getAreaStyle(chart, seriesIndex);

        var stroke = borderColor ? new dvt.Stroke(borderColor, 1, borderWidth) : null;
        var type = DvtChartStyleUtils.getLineType(chart, seriesIndex);

        // Filter points to reduce render time
        DvtChartPlotAreaRenderer._filterPointsForSeries(chart, seriesIndex);

        var coords, baseCoords, baseType;
        var isRange = DvtChartDataUtils.isRangeSeries(chart, seriesIndex);
        if (isRange) {
          coords = DvtChartPlotAreaRenderer._getCoordsForSeries(
            chart,
            seriesIndex,
            availSpace,
            'high'
          );
          baseCoords = DvtChartPlotAreaRenderer._getCoordsForSeries(
            chart,
            seriesIndex,
            availSpace,
            'low'
          );
          baseType = type;
        } else {
          if (isSeriesNegative) {
            coords = DvtChartPlotAreaRenderer._getAreaCoordsForSeries(
              chart,
              seriesIndex,
              availSpace,
              prevCoordsNegative ? prevCoordsNegative : baselineCoords
            );
            baseCoords = prevCoordsNegative ? prevCoordsNegative : [];
            baseType = prevTypeNegative;
          } else {
            coords = DvtChartPlotAreaRenderer._getAreaCoordsForSeries(
              chart,
              seriesIndex,
              availSpace,
              prevCoords ? prevCoords : baselineCoords
            );
            baseCoords = prevCoords ? prevCoords : [];
            baseType = prevType;
          }
        }

        var area = new DvtChartLineArea(
          chart,
          true,
          availSpace,
          baselineCoord,
          style,
          className,
          fill,
          stroke,
          type,
          coords,
          baseType,
          baseCoords
        );
        clippedGroup.addChild(area);
        chart._currentAreas.push(area); // TODO: change to formal API for storage
        DvtChartObjPeer.associate(area, chart, seriesIndex); // Associate for interactivity

        // Store for the base of the next area in the stack
        if (isSeriesNegative) {
          prevCoordsMapNegative[category] = coords;
          prevTypeMapNegative[category] = type;
        } else {
          prevCoordsMap[category] = coords;
          prevTypeMap[category] = type;
        }

        // If not stacked, draw with each series so that lines and markers don't bleed through
        if (!bStacked) {
          // Draw line as data item gap only if the area doesn't have border. Otherwise the gap will be drawn on top of the border
          if (isLineWithArea || (DvtChartStyleUtils.getDataItemGaps(chart) > 0 && !borderColor))
            DvtChartPlotAreaRenderer._renderLinesForSeries(
              chart,
              clippedGroup,
              seriesIndex,
              availSpace,
              !isLineWithArea
            );

          // For lineWithArea, always draw the markers last since the areas are semi-transparent
          if (!isLineWithArea)
            DvtChartPlotAreaRenderer._renderMarkersForSeries(
              chart,
              container,
              seriesIndex,
              availSpace
            );

          // : New group generated for the next area so that, in unstacked charts, the clipGroup for each area is
          // added after the markers of previous series
          if (areaIndex + 1 < areaSeries.length)
            clippedGroup = DvtChartPlotAreaRenderer.createClippedGroup(chart, container, availSpace);
        }
      }

      // If stacked, draw lines and markers at the end so that the stacked areas don't overlap them
      for (areaIndex = 0; areaIndex < areaSeries.length; areaIndex++) {
        seriesIndex = areaSeries[areaIndex];
        if (DvtChartStyleUtils.getLineType(chart, seriesIndex) == 'none') continue; // markers are already rendered in previous loop

        // Draw line as data item gap only if the area doesn't have border. Otherwise the gap will be drawn on top of the border
        var hasBorder =
          DvtChartStyleUtils.getBorderColor(chart, seriesIndex) ||
          DvtChartStyleUtils.getBorderColor(chart, seriesIndex + 1);
        if (
          bStacked &&
          (isLineWithArea || (DvtChartStyleUtils.getDataItemGaps(chart) > 0 && !hasBorder))
        )
          DvtChartPlotAreaRenderer._renderLinesForSeries(
            chart,
            clippedGroup,
            seriesIndex,
            availSpace,
            !isLineWithArea
          );

        // Also draw markers last for unstacked lineWithArea so people can interact with them through the semi-transparent areas
        if (bStacked || isLineWithArea)
          DvtChartPlotAreaRenderer._renderMarkersForSeries(chart, container, seriesIndex, availSpace);
      }
    },

    /**
     * Returns the coordinates for the specified area series.
     * @param {Chart} chart The chart being rendered.
     * @param {number} seriesIndex The series being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {array} prevCoords The array of DvtChartCood from the previous series.
     * @return {array} The arrays of DvtChartCoord for the current series.
     * @private
     */
    _getAreaCoordsForSeries: (chart, seriesIndex, availSpace, prevCoords) => {
      var rawCoords = DvtChartPlotAreaRenderer._getCoordsForSeries(chart, seriesIndex, availSpace);
      var coords = [];
      for (var i = 0; i < prevCoords.length; i++) coords.push(prevCoords[i].clone());

      // Construct the coords based on the prevCoords.
      // At each point, if it's not null:
      // - if the previous point is null, update only the y2 so that the shape jumps up from the old y1 to the new y2;
      // - if the next point is null, update only the y1 so that the shape jumps down from the new y1 to the old y2;
      // - else, y1 == y2 and there's no jump at that point.
      var lastIndex = rawCoords.length - 1;
      var bPolar = DvtChartTypeUtils.isPolar(chart);
      for (var z = 0; z < rawCoords.length; z++) {
        if (rawCoords[z].x != null) {
          var coord = coords[rawCoords[z].groupIndex];
          var prevIndex = bPolar && z == 0 ? lastIndex : z - 1; // prev/nextIndex in polar is circular
          var nextIndex = bPolar && z == lastIndex ? 0 : z + 1;

          if (prevIndex >= 0 && rawCoords[prevIndex].x != null) coord.y1 = rawCoords[z].y1;
          if (nextIndex <= lastIndex && rawCoords[nextIndex].x != null) coord.y2 = rawCoords[z].y2;

          coord.x = rawCoords[z].x;

          // If y1!=y2, there's a jump so the point can't be filtered
          coord.filtered = coord.y1 == coord.y2 ? rawCoords[z].filtered : false;
        }
      }

      return coords;
    },

    /**
     * Create lines for a series (for line and lineWithArea) and add them to the container.
     * @param {Chart} chart
     * @param {dvt.Container} container The line container.
     * @param {Number} seriesIndex
     * @param {dvt.Rectangle} availSpace
     * @param {Boolean} isDataItemGap Whether this line is for drawing area gap.
     * @private
     */
    _renderLinesForSeries: (chart, container, seriesIndex, availSpace, isDataItemGap) => {
      // Get the style info
      var stroke;
      if (isDataItemGap) {
        var gapSize = DvtChartStyleUtils.getDataItemGaps(chart) * 2.5;
        stroke = new dvt.Stroke(DvtChartStyleUtils.getBackgroundColor(chart, true), 1, gapSize);
      } else {
        var color = DvtChartStyleUtils.getColor(chart, seriesIndex);
        var lineWidth = DvtChartStyleUtils.getLineWidth(chart, seriesIndex);
        var lineStyle = DvtChartStyleUtils.getLineStyle(chart, seriesIndex);
        stroke = new dvt.Stroke(
          color,
          1,
          lineWidth,
          false,
          dvt.Stroke.getDefaultDashProps(lineStyle, lineWidth)
        );
      }

      // Create the lines
      var baseline = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex)
        ? chart.y2Axis.getBaselineCoord()
        : chart.yAxis.getBaselineCoord();
      var lineType = DvtChartStyleUtils.getLineType(chart, seriesIndex);
      var className = DvtChartStyleUtils.getClassName(chart, seriesIndex);
      var style = DvtChartStyleUtils.getStyle(chart, seriesIndex);

      var renderLine = (type) => {
        var coords = DvtChartPlotAreaRenderer._getCoordsForSeries(
          chart,
          seriesIndex,
          availSpace,
          type
        );
        var line = new DvtChartLineArea(
          chart,
          false,
          availSpace,
          baseline,
          style,
          className,
          null,
          stroke,
          lineType,
          coords
        );
        container.addChild(line);
        DvtChartObjPeer.associate(line, chart, seriesIndex); // Associate for interactivity
      };

      var isRange = DvtChartDataUtils.isRangeSeries(chart, seriesIndex);
      if (isRange) {
        renderLine('high');
        renderLine('low');
      } else renderLine('value');
    },

    /**
     * Filters the bubble and scatter markers for performance.
     * @param {Chart} chart The chart being rendered.
     * @param {boolean} bSortBySize True if markers should be sorted by size to reduce overlaps.
     * @return {array} The array of visible markerInfo objects, or null if filtering was not performed.
     * @private
     */
    _filterScatterBubble: (chart, bSortBySize) => {
      // Note: This function works by determining and marking the data to be filtered. When render of the data is called
      // afterwards, the filtering flag causes the item to be skipped.
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var groupCount = DvtChartDataUtils.getGroupCount(chart);

      // Filter only if there are a sufficient number of data points. The filtering cost has overhead based on the size of
      // the availSpace, and is not generally worthwhile until several thousand markers can be skipped.
      if (seriesCount * groupCount < DvtChartPlotAreaRenderer.FILTER_THRESHOLD_SCATTER_BUBBLE)
        return null;

      // Gather the marker information objects for all data items.
      var markerInfo;
      var markerInfos = [];
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        // Skip the series if it shouldn't be rendered
        if (!DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)) continue;

        for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {
          markerInfo = DvtChartPlotAreaRenderer._getScatterBubbleMarkerInfo(
            chart,
            seriesIndex,
            groupIndex
          );
          if (markerInfo != null) markerInfos.push(markerInfo);
        }
      }

      // Check the data count again now that obscured series accounted for.
      if (markerInfos.length < DvtChartPlotAreaRenderer.FILTER_THRESHOLD_SCATTER_BUBBLE) return null;

      if (bSortBySize) DvtChartMarkerUtils.sortMarkerInfos(markerInfos);

      // Create the data structure to track if pixels are occupied.
      var pixelMap = new dvt.PixelMap(25, new dvt.PixelMap(5, new dvt.PixelMap()));

      // Loop backwards to determine if objects are visible. Create an array of visible markers.
      var ret = [];
      var markerCount = markerInfos.length;
      for (var markerIndex = markerCount - 1; markerIndex >= 0; markerIndex--) {
        markerInfo = markerInfos[markerIndex];

        // Check if the pixels are occupied and adjust the filtered flag.
        var bObscured = DvtChartMarkerUtils.checkPixelMap(
          pixelMap,
          markerInfo.x,
          markerInfo.y,
          markerInfo.size
        );
        if (!bObscured) {
          var dataColor = DvtChartStyleUtils.getColor(
            chart,
            markerInfo.seriesIndex,
            markerInfo.groupIndex
          );
          var markerDisplayed = DvtChartStyleUtils.isMarkerDisplayed(chart, seriesIndex, groupIndex);
          var alpha = markerDisplayed ? dvt.ColorUtils.getAlpha(dataColor) : 0;
          if (alpha > 0) {
            // Update the pixel map for this marker
            DvtChartMarkerUtils.updatePixelMap(
              pixelMap,
              markerInfo.x,
              markerInfo.y,
              markerInfo.size,
              alpha
            );
            ret.push(markerInfo);
          }
        }
      }

      // Set the flag in the cache so that marquee selection will be based on the data rather than rendered objects.
      chart.getCache().putToCache('dataFiltered', true);

      // Markers were added top to bottom. Reverse for rendering order and return.
      ret.reverse();
      return ret;
    },

    /**
     * Filters the data points for line/area so that no more than one point is drawn per pixel.
     * @param {Chart} chart
     * @param {number} seriesIndex
     * @private
     */
    _filterPointsForSeries: (chart, seriesIndex) => {
      // TODO: implement filtering for range series
      if (DvtChartTypeUtils.isPolar(chart) || DvtChartDataUtils.isRangeSeries(chart, seriesIndex))
        return;

      var plotAreaDims = chart.__getPlotAreaSpace();
      var maxNumPts = DvtChartTypeUtils.isHorizontal(chart) ? plotAreaDims.h : plotAreaDims.w; // one point per pixel
      var seriesItems = DvtChartDataUtils.getSeriesItem(chart, seriesIndex)['items'];
      var isBar = DvtChartDataUtils.getSeriesType(chart, seriesIndex) == 'bar';
      var axisInfo = chart.xAxis.getInfo();
      var zoomFactor =
        (axisInfo.getDataMax() - axisInfo.getDataMin()) /
        (axisInfo.getViewportMax() - axisInfo.getViewportMin());
      var dataItem;
      // For line/area, pick two points (max and min) from each set, so each set can cover two pixels.
      // For bar, only pick the max for each set, so the set size should only cover 1/2 pixel to prevent sparse plot area.
      var numPixelsPerSet = isBar ? 0.5 : 2;
      var setSize = zoomFactor
        ? Math.round((numPixelsPerSet * (seriesItems.length / zoomFactor)) / maxNumPts)
        : 1;

      var minSetSize = isBar ? 2 : 3;
      if (setSize < minSetSize) {
        // Nothing should be filtered. Clear _filtered flags from previous rendering.
        for (var i = 0; i < seriesItems.length; i++) {
          dataItem = seriesItems[i];
          if (dataItem) dataItem['_filtered'] = false;
        }
        return;
      }

      var maxIndex, maxValue, minIndex, minValue, dataValue;
      var filtered = false;
      for (var y = 0; y < seriesItems.length; y += setSize) {
        maxIndex = -1;
        maxValue = -Infinity;
        minIndex = -1;
        minValue = Infinity;

        // Find the extreme points (min/max) of the set
        for (var j = y; j < Math.min(y + setSize, seriesItems.length); j++) {
          dataValue = DvtChartDataUtils.getCumulativeVal(chart, seriesIndex, j);
          dataItem = seriesItems[j];
          if (dataValue == null || dataItem == null) continue;
          if ((!isBar || dataValue > 0) && dataValue > maxValue) {
            // for bar, unfilter the maxValue only if the dataValue is positive
            maxIndex = j;
            maxValue = dataValue;
          }
          if ((!isBar || dataValue < 0) && dataValue < minValue) {
            // for bar, unfilter the minValue only if the dataValue is negative
            minIndex = j;
            minValue = dataValue;
          }
          dataItem['_filtered'] = true; // Filter every point in the meanwhile
          filtered = true;
        }

        // Unfilter the extreme points of the set
        for (var w = y; w < Math.min(y + setSize, seriesItems.length); w++) {
          dataItem = seriesItems[w];
          if (dataItem == null) continue;
          if (w == maxIndex || w == minIndex) dataItem['_filtered'] = false;
        }
      }

      chart.getCache().putToCache('dataFiltered', filtered);
    },

    /**
     * Creates and returns the coordinates for the specified series.
     * @param {Chart} chart The chart being rendered.
     * @param {number} seriesIndex The series being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {string} type (optional) The value type: 'value' (default), 'low', or 'high'.
     * @return {array} The array of DvtChartCoord.
     * @private
     */
    _getCoordsForSeries: (chart, seriesIndex, availSpace, type) => {
      var xAxis = chart.xAxis;
      var yAxis = chart.yAxis;
      if (DvtChartDataUtils.isAssignedToY2(chart, seriesIndex)) yAxis = chart.y2Axis;

      // Loop through the groups
      var coords = [];
      var minMaxGroupIndex = DvtChartAxisUtils.getViewportMinMaxGroupIdx(chart, seriesIndex);
      for (
        var groupIndex = minMaxGroupIndex['min'] - 1;
        groupIndex <= minMaxGroupIndex['max'] + 1;
        groupIndex++
      ) {
        var group = DvtChartDataUtils.getGroup(chart, groupIndex);
        if (group == null) continue;

        // Get the axis values
        var xValue = DvtChartDataUtils.getXVal(chart, seriesIndex, groupIndex);

        var yValue = null;
        if (type == 'low') yValue = DvtChartDataUtils.getLowVal(chart, seriesIndex, groupIndex);
        else if (type == 'high')
          yValue = DvtChartDataUtils.getHighVal(chart, seriesIndex, groupIndex);
        else if (DvtChartDataUtils.getVal(chart, seriesIndex, groupIndex) != null)
          yValue = DvtChartDataUtils.getCumulativeVal(chart, seriesIndex, groupIndex);

        // A null or undefined value begins another line or area and skips this data item
        if (
          yValue == null ||
          isNaN(yValue) ||
          !DvtChartDataUtils.isDataItemRendered(chart, seriesIndex, groupIndex)
        ) {
          // Skip this value since it's invalid
          coords.push(new DvtChartCoord(null, null, null, groupIndex, group, false));
          continue;
        }

        if (DvtChartTypeUtils.isPolar(chart))
          // The yValue for polar shouldn't go below the minimum because it will appear on the opposite side of the chart
          yValue = Math.max(yValue, yAxis.getInfo().getViewportMin());

        // Get the position on the axis
        var xCoord = xAxis.getUnboundedCoordAt(xValue);
        var yCoord = yAxis.getUnboundedCoordAt(yValue);

        if (xCoord == null || yCoord == null) {
          // Skip this value since it's invalid
          coords.push(new DvtChartCoord(null, null, null, groupIndex, group, false));
          continue;
        }

        var coord = new DvtChartCoord(
          xCoord,
          yCoord,
          yCoord,
          groupIndex,
          group,
          DvtChartDataUtils.isDataItemFiltered(chart, seriesIndex, groupIndex)
        );
        coords.push(coord);
      }

      return coords;
    },

    /**
     * Creates a container for plot area foreground objects with clipping.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render to.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {dvt.Container} The clipped container for plot area foreground objects.
     */
    createClippedGroup: (chart, container, availSpace) => {
      var clipGroup = new dvt.Container(container.getCtx());
      container.addChild(clipGroup);
      var clip = new dvt.ClipPath(chart.getId());

      //  - line gets cut off at plot area max
      //  - line charts vertex clipped if dataMax too close to globalMax
      // For a chart with a line/linewitharea series, increase clip group by several pixels if lines risk getting clipped
      var buffer = DvtChartPlotAreaRenderer._extendClipGroup(chart);

      // Add clip path depending on plot area shape
      if (DvtChartTypeUtils.isPolar(chart)) {
        var cx = availSpace.x + availSpace.w / 2;
        var cy = availSpace.y + availSpace.h / 2;
        if (DvtChartAxisUtils.isGridPolygonal(chart)) {
          var points = dvt.PolygonUtils.getRegularPolygonPoints(
            cx,
            cy,
            DvtChartDataUtils.getGroupCount(chart),
            chart.getRadius(),
            0
          );
          clip.addPolygon(points);
        } else clip.addCircle(cx, cy, chart.getRadius());
      } else if (DvtChartTypeUtils.isHorizontal(chart))
        clip.addRect(availSpace.x - buffer, availSpace.y, availSpace.w + 2 * buffer, availSpace.h);
      else clip.addRect(availSpace.x, availSpace.y - buffer, availSpace.w, availSpace.h + 2 * buffer);

      clipGroup.setClipPath(clip);
      return clipGroup;
    },

    /**
     * Checks or not the plot area should extend it's clip group, and returns how many pixels should be added.
     * Used for preventing clipping of line series at edge cases.
     * @param {Chart} chart
     * @return {number}
     * @private
     */
    _extendClipGroup: (chart) => {
      var hasLineSeries =
        DvtChartDataUtils.hasLineSeries(chart) || DvtChartDataUtils.hasLineWithAreaSeries(chart);
      if (hasLineSeries && !DvtChartTypeUtils.isSpark(chart)) {
        // Spark chart is already extended
        var lineWidth = DvtChartStyleUtils.getLineWidth(chart);
        var hasEdgeData = (axis) => {
          var axisInfo = axis.getInfo();
          var globalMaxCoord = axisInfo.getCoordAt(axisInfo.getGlobalMax());
          var dataMaxCoord = axisInfo.getCoordAt(axisInfo.getDataMax());
          var globalMinCoord = axisInfo.getCoordAt(axisInfo.getGlobalMin());
          var dataMinCoord = axisInfo.getCoordAt(axisInfo.getDataMin());

          if (
            globalMaxCoord != null &&
            dataMaxCoord != null &&
            dataMaxCoord - globalMaxCoord <= lineWidth / 2
          )
            return true;
          if (
            globalMinCoord != null &&
            dataMinCoord != null &&
            globalMinCoord - dataMinCoord <= lineWidth / 2
          )
            return true;

          return false;
        };

        if ((chart.yAxis && hasEdgeData(chart.yAxis)) || (chart.y2Axis && hasEdgeData(chart.y2Axis)))
          return Math.ceil(lineWidth / 2);
      }

      return 0;
    }
  };

  /*---------------------------------------------------------------------*/
  /*  DvtChartDataCursorHandler                 Data Cursor Event Handler                  */
  /*---------------------------------------------------------------------*/
  /**
   *  @class  DvtChartDataCursorHandler
   *  @extends {dvt.Obj}
   *  @constructor
   */
  class DvtChartDataCursorHandler {
    constructor(chart, dataCursor) {
      this._context = chart.getCtx();
      this._dataCursorShown = false;
      this._dataCursor = dataCursor;
      this._chart = chart;
    }

    // Show/hide the data cursor based on the global page coordinates of the action
    // Returns whether or not data cursor is shown
    processMove(pos, bSuppressEvent) {
      var plotRect = this._chart.__getPlotAreaSpace();
      if (
        plotRect &&
        plotRect.containsPoint(pos.x, pos.y) &&
        !this._chart.getOptions()['_duringZoomAndScroll']
      ) {
        // Show the data cursor only if the current point is within the plot area
        this._showDataCursor(plotRect, pos.x, pos.y, bSuppressEvent);
        return true;
      } else {
        this._removeDataCursor(bSuppressEvent);
      }
      return false;
    }

    processEnd(bSuppressEvent) {
      this._removeDataCursor(bSuppressEvent);
    }

    processOut(pos, bSuppressEvent) {
      var plotRect = this._chart.__getPlotAreaSpace();
      if (plotRect && !plotRect.containsPoint(pos.x, pos.y)) {
        this._removeDataCursor(bSuppressEvent);
      }
    }

    /**
     * Displays the data cursor.
     * @param {dvt.Rectangle} plotRect The bounds of the plot area
     * @param {number} x
     * @param {number} y
     * @param {object} targetObj
     * @private
     */
    _showDataCursor(plotRect, x, y, bSuppressEvent) {
      if (this._context.isOffscreen(true)) {
        this._removeDataCursor(bSuppressEvent);
        return;
      }

      var dataCursor = this._dataCursor;

      // Find the closest data point
      var closestMatch = this._getClosestMatch(x, y);
      if (closestMatch == null) {
        this._removeDataCursor(bSuppressEvent);
        return;
      }

      // Find the center of the data item
      var centerPoint = closestMatch.matchRegion.getCenter();

      var dcX = x;
      var dcY = y;
      // Adjust for snap behavior
      if (dataCursor.getBehavior() === 'snap') {
        if (dataCursor.isHorizontal())
          dcY = Math.min(Math.max(centerPoint.y, plotRect.y), plotRect.y + plotRect.h);
        else dcX = Math.min(Math.max(centerPoint.x, plotRect.x), plotRect.x + plotRect.w);
      }

      // If "dataCursor" attr is "auto", don't show the data cursor if tooltip text is null. Otherwise, always show the cursor.
      var logicalObject = closestMatch.logicalObject;
      var tooltipText = DvtChartTooltipUtils.getDatatip(
        this._chart,
        logicalObject.getSeriesIndex(),
        logicalObject.getGroupIndex(),
        logicalObject.getNestedDataItemIndex(),
        true
      );
      if (tooltipText == null) {
        dataCursor.setVisible(false);
        return;
      } else dataCursor.setVisible(true);

      var itemColor = DvtChartTooltipUtils.getDatatipColor(
        this._chart,
        logicalObject.getSeriesIndex(),
        logicalObject.getGroupIndex(),
        logicalObject.getNestedDataItemIndex()
      );
      var lineCoord = dataCursor.isHorizontal() ? dcY : dcX;
      var shape = logicalObject.getDisplayables()[0];
      // update the default maker shape and size
      if (shape instanceof dvt.SimpleMarker) {
        dataCursor.addMarker(shape.getType(), shape.getSize());
      }
      dataCursor.render(plotRect, centerPoint.x, centerPoint.y, lineCoord, tooltipText, itemColor);

      this._dataCursorShown = true;

      // fire optionChange event
      if (!bSuppressEvent) {
        var values = this._chart.getValsAt(x, y);
        this._chart.changeOption('dataCursorPosition', values);
      }
    }

    // Remove the data cursor
    _removeDataCursor(bSuppressEvent) {
      if (this._dataCursor.getVisible()) this._dataCursor.setVisible(false);

      this._context.getTooltipManager(DvtChartDataCursor.TOOLTIP_ID).hideTooltip();

      this._dataCursorShown = false;

      // fire optionChange event
      if (!bSuppressEvent) this._chart.changeOption('dataCursorPosition', null);
    }

    isDataCursorShown() {
      return this._dataCursorShown;
    }

    static _getClosestMatchSecondDirection(matchesInBounds, horizontal, x, y) {
      var closestMatch = null;
      var minDiff = Infinity;
      for (var i = matchesInBounds.length - 1; 0 <= i; i--) {
        var match = matchesInBounds[i];
        var lowerBound = horizontal ? match.matchRegion.x : match.matchRegion.y;
        var higherBound = horizontal
          ? match.matchRegion.x + match.matchRegion.w
          : match.matchRegion.y + match.matchRegion.h;
        var value = horizontal ? x : y;
        var midPoint = (lowerBound + higherBound) / 2;
        var diffValue = Math.round(Math.abs(midPoint - value));
        if (diffValue < minDiff) {
          minDiff = diffValue;
          closestMatch = match;
        }
      }
      return closestMatch;
    }

    static _getClosestMatchesFirstDirection(matches, horizontal, x, y, isHighlightMatched) {
      var minDiff = Infinity;
      var closestFirstDirectionMatches = new Array();
      // Get closest matches
      for (var i = 0; i < matches.length; i++) {
        var matchObj = matches[i];
        if (isHighlightMatched(matchObj.logicalObject)) {
          var matchRegion = matchObj.matchRegion;
          var lowerBound = horizontal ? matchRegion.y : matchRegion.x;
          var higherBound = horizontal
            ? matchRegion.y + matchRegion.h
            : matchRegion.x + matchRegion.w;
          var value = horizontal ? y : x;

          var midPoint = (lowerBound + higherBound) / 2;
          var diffValue = Math.round(Math.abs(midPoint - value));
          if (diffValue <= minDiff) {
            if (diffValue < minDiff) {
              closestFirstDirectionMatches = new Array();
            }
            closestFirstDirectionMatches.push(matchObj);
            minDiff = diffValue;
          }
        }
      }
      return closestFirstDirectionMatches;
    }

    // TODO JSDOC: This class needs to be rewritten to not access private properties and get rid of these implicit object returns.
    _findMatches() {
      var stage = this._context.getStage();
      var eventManager = this._chart.getEventManager();
      var matches = [];

      if (!this._chart._currentMarkers) return null;

      for (var i = 0; i < this._chart._currentMarkers.length; i++) {
        var markers = this._chart._currentMarkers[i];
        var numMarkers = markers.length;

        for (var idx = 0; idx < numMarkers; idx++) {
          var item = markers[idx];
          var logicalObject = eventManager.GetLogicalObject(item);

          // Find the bounding box of the item.  We use getDimensionsSelf, an optimized version of getDimensions, where
          // possible.  It's safe to use either API since chart data objects do not have children.
          var dims = item.getDimensionsSelf
            ? item.getDimensionsSelf(stage)
            : item.getDimensions(stage);

          var match = { matchRegion: dims, logicalObject: logicalObject };
          matches.push(match);
        }
      }
      return matches;
    }

    _getClosestMatch(x, y) {
      var horizontal = DvtChartTypeUtils.isHorizontal(this._chart);
      var useAllInGroup =
        DvtChartTypeUtils.isLineArea(this._chart) && !DvtChartTypeUtils.isMixedFrequency(this._chart);

      var matches = this._findMatches();

      var highlightedCategories = DvtChartDataUtils.getHighlightedCategories(this._chart);
      var isHighlightMatchAll = this._chart.getOptions()['highlightMatch'] == 'all';
      var matchFound =
        highlightedCategories.length > 0
          ? isHighlightMatchAll
            ? dvt.ArrayUtils.hasAllItems
            : dvt.ArrayUtils.hasAnyItem
          : null;
      var isHighlightMatched = (obj) => {
        return matchFound ? matchFound(obj.getCategories(), highlightedCategories) : true;
      };

      var matchesInBounds = DvtChartDataCursorHandler._getClosestMatchesFirstDirection(
        matches,
        horizontal,
        x,
        y,
        isHighlightMatched
      );

      // Non-numerical x axis
      if (!DvtChartTypeUtils.isScatterBubble(this._chart)) {
        var closestLowerBound = Infinity;
        var closestHigherBound = -Infinity;
        var closestGroup = null;

        for (var i = 0; i < matchesInBounds.length; i++) {
          var closestFirstDirectionMatch = matchesInBounds[i];
          closestLowerBound = Math.min(
            closestLowerBound,
            horizontal
              ? closestFirstDirectionMatch.matchRegion.y
              : closestFirstDirectionMatch.matchRegion.x
          );
          closestHigherBound = Math.max(
            closestHigherBound,
            horizontal
              ? closestFirstDirectionMatch.matchRegion.y + closestFirstDirectionMatch.matchRegion.h
              : closestFirstDirectionMatch.matchRegion.x + closestFirstDirectionMatch.matchRegion.w
          );
          closestGroup = closestFirstDirectionMatch.logicalObject.getGroupIndex();
        }

        for (var i = 0; i < matches.length; i++) {
          var match = matches[i];
          if (isHighlightMatched(match.logicalObject)) {
            if (useAllInGroup) {
              if (match.logicalObject.getGroupIndex() == closestGroup) {
                matchesInBounds.push(match);
              }
            } else {
              var lowerBound = horizontal ? match.matchRegion.y : match.matchRegion.x;
              var higherBound = horizontal
                ? match.matchRegion.y + match.matchRegion.h
                : match.matchRegion.x + match.matchRegion.w;
              var midPoint = (lowerBound + higherBound) / 2;
              if (closestHigherBound >= midPoint && closestLowerBound <= midPoint) {
                matchesInBounds.push(match);
              }
            }
          }
        }
      }
      return DvtChartDataCursorHandler._getClosestMatchSecondDirection(
        matchesInBounds,
        horizontal,
        x,
        y
      );
    }
  }

  /**
   * Axis component for use by Chart.  This class exposes additional functions needed for
   * rendering grid lines and data items.
   * @param {dvt.Context} context The rendering context.
   * @param {string} callback The function that should be called to dispatch component events.
   * @param {object} callbackObj The optional object instance on which the callback function is defined.
   * @class
   * @constructor
   * @extends {DvtAxis}
   */

  class DvtChartAxis extends DvtAxis {
    /**
     * Converts the axis coord to plot area coord.
     * @param {number} coord Axis coord.
     * @return {number} Plot area coord.
     */
    axisToPlotArea(coord) {
      if (this.getOptions()['position'] == 'tangential') return coord;

      if (coord == null) return null;

      var ret = coord - this.getLeftOverflow();

      // Round to 1 decimal to keep the DOM small, but prevent undesidered gaps due to rounding errors
      return Math.round(ret * 10) / 10;
    }

    /**
     * Converts the plot area coord to axis coord.
     * @param {number} coord Plot area coord.
     * @param {boolean=} bRoundResult Whether the resulting coordinate is rounded to the nearest pixel.  Defaults to true.
     * @return {number} Axis coord.
     */
    plotAreaToAxis(coord, bRoundResult) {
      if (this.getOptions()['position'] == 'tangential') return coord;

      if (coord == null) return null;

      var ret = coord + this.getLeftOverflow();
      return bRoundResult === false ? ret : Math.round(ret);
    }

    /**
     * Converts linear value to actual value.
     * For example, for a log scale, the linear value is the log of the actual value.
     * @param {number} value The linear value.
     * @return {number} The actual value.
     */
    linearToActual(value) {
      return this.Info.linearToActual(value);
    }

    /**
     * Converts actual value to linear value.
     * For example, for a log scale, the linear value is the log of the actual value.
     * @param {number} value The actual value.
     * @return {number} The linear value.
     */
    actualToLinear(value) {
      return this.Info.actualToLinear(value);
    }

    /**
     * Returns the value for the specified coordinate along the axis.  Returns null
     * if the coordinate is not within the axis.
     * @param {number} coord The coordinate along the axis.
     * @return {object} The value at that coordinate.
     */
    getValAt(coord) {
      return this.Info.getValAt(this.plotAreaToAxis(coord));
    }

    /**
     * Returns the coordinate for the specified value.
     * @param {object} value The value to locate.
     * @return {number} The coordinate for the value.
     */
    getCoordAt(value) {
      return this.axisToPlotArea(this.Info.getCoordAt(value));
    }

    /**
     * Returns the coordinate for the specified value.  If a value is not within the axis,
     * returns the coordinate of the closest value within the axis.
     * @param {object} value The value to locate.
     * @return {number} The coordinate for the value.
     */
    getBoundedCoordAt(value) {
      return this.axisToPlotArea(this.Info.getBoundedCoordAt(value));
    }

    /**
     * Returns the value for the specified coordinate along the axis.
     * @param {number} coord The coordinate along the axis.
     * @return {object} The value at that coordinate.
     */
    getUnboundedValAt(coord) {
      return this.Info.getUnboundedValAt(this.plotAreaToAxis(coord));
    }

    /**
     * Returns the coordinate for the specified value.
     * @param {object} value The value to locate.
     * @return {number} The coordinate for the value.
     */
    getUnboundedCoordAt(value) {
      return this.axisToPlotArea(this.Info.getUnboundedCoordAt(value));
    }

    /**
     * Returns the baseline coordinate for the axis, if applicable.
     * @return {number} The baseline coordinate for the axis.
     */
    getBaselineCoord() {
      return this.axisToPlotArea(this.Info.getBaselineCoord());
    }

    /**
     * Returns the position of the axis relative to the chart.
     * @return {string} The position of the axis.
     */
    getPosition() {
      return this.getOptions()['position'];
    }

    /**
     * Returns true if this is a group axis.
     * @return {boolean}
     */
    isGroupAxis() {
      return this.Info instanceof DvtGroupAxisInfo;
    }

    /**
     * Returns the coordinates of the major ticks.
     * @return {array} Array of coords.
     */
    getMajorTickCoords() {
      var coords = this.Info ? this.Info.getMajorTickCoords() : [];
      for (var i = 0; i < coords.length; i++) coords[i] = this.axisToPlotArea(coords[i]);
      return coords;
    }

    /**
     * Returns the coordinates of the minor ticks.
     * @return {array} Array of coords.
     */
    getMinorTickCoords() {
      var coords = this.Info ? this.Info.getMinorTickCoords() : [];
      for (var i = 0; i < coords.length; i++) coords[i] = this.axisToPlotArea(coords[i]);
      return coords;
    }

    /**
     * Returns the coordinates of the baseline (value = 0). Only applies to numerical axis.
     * @return {number} Baseline coord.
     */
    getBaselineCoord() {
      return this.axisToPlotArea(this.Info.getBaselineCoord());
    }

    /**
     * Returns the linearized global min value of the axis.
     * @return {number} The global min value.
     */
    getLinearGlobalMin() {
      return this.actualToLinear(this.Info.getGlobalMin());
    }

    /**
     * Returns the linearized global max value of the axis.
     * @return {number} The global max value.
     */
    getLinearGlobalMax() {
      return this.actualToLinear(this.Info.getGlobalMax());
    }

    /**
     * Returns the linearized viewport min value of the axis.
     * @return {number} The viewport min value.
     */
    getLinearViewportMin() {
      return this.actualToLinear(this.Info.getViewportMin());
    }

    /**
     * Returns the linearized viewport max value of the axis.
     * @return {number} The viewport max value.
     */
    getLinearViewportMax() {
      return this.actualToLinear(this.Info.getViewportMax());
    }

    /**
     * Returns the linearized value for the specified coordinate along the axis.
     * @param {number} coord The coordinate along the axis.
     * @return {object} The linearized value at that coordinate.
     */
    getUnboundedLinearValAt(coord) {
      return this.Info.actualToLinear(this.getUnboundedValAt(coord));
    }

    /**
     * Returns whether the viewport is showing the full extent of the chart.
     * @return {boolean}
     */
    isFullViewport() {
      return (
        this.Info.getViewportMin() == this.Info.getGlobalMin() &&
        this.Info.getViewportMax() == this.Info.getGlobalMax()
      );
    }

    /**
     * Returns how much the axis labels overflow to the left.
     * @return {number}
     */
    getLeftOverflow() {
      return dvt.Agent.isRightToLeft(this.getCtx())
        ? this.Info.getEndOverflow()
        : this.Info.getStartOverflow();
    }

    /**
     * Returns how much the axis labels overflow to the right.
     * @return {number}
     */
    getRightOverflow() {
      return dvt.Agent.isRightToLeft(this.getCtx())
        ? this.Info.getStartOverflow()
        : this.Info.getEndOverflow();
    }

    /**
     * Returns the length of the axis.
     * @return {number} The axis length.
     */
    getLength() {
      return Math.abs(this.Info.getStartCoord() - this.Info.getEndCoord());
    }

    /**
     * Returns the minimum coordinate of the axis.
     * @return {number}
     */
    getMinCoord() {
      return this.axisToPlotArea(Math.min(this.Info.getStartCoord(), this.Info.getEndCoord()));
    }

    /**
     * Returns the maximum coordinate of the axis.
     * @return {number}
     */
    getMaxCoord() {
      return this.axisToPlotArea(Math.max(this.Info.getStartCoord(), this.Info.getEndCoord()));
    }
  }

  /**
   * Performs layout and positioning for the chart axes.
   * @class
   */
  const DvtChartAxisRenderer = {
    /** @private */
    _DEFAULT_AXIS_MAX_SIZE: 0.33,

    /**
     * @this {DvtChartAxisRenderer}
     * Renders axes and updates the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (chart, container, availSpace) => {
      if (!DvtChartTypeUtils.hasAxes(chart)) return;

      DvtChartAxisUtils.applyInitialZooming(chart, availSpace);

      // Approximate bubble sizes are needed at this point to compute the axis ranges
      if (DvtChartTypeUtils.isBubble(chart)) DvtChartMarkerUtils.calcBubbleSizes(chart, availSpace);

      // Render axes based on coordinate system
      if (DvtChartTypeUtils.isPolar(chart))
        DvtChartAxisRenderer._renderPolar(chart, container, availSpace);
      else DvtChartAxisRenderer._renderCartesian(chart, container, availSpace);
    },

    /**
     * Renders axes in Cartesian coordinate system.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderCartesian: (chart, container, availSpace) => {
      var options = chart.getOptions();
      var isHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var isSplitDualY = DvtChartDataUtils.isSplitDualY(chart);
      var isOverview = DvtChartTypeUtils.isOverview(chart);
      var totalAvailSpace = availSpace.clone();
      var yPosition = DvtChartAxisUtils.getYAxisPos(chart);
      var y2Position = DvtChartAxisUtils.getY2AxisPos(chart);
      var ignoreYRendering =
        !isOverview &&
        options.overview.content &&
        options.overview.content.yAxis &&
        options.overview.content.yAxis.rendered == 'on'; // main chart's y-axis.rendered = "off" should be ignored(for sizing purposes) if the overview has a y-axis
      var ignoreY2Rendering =
        !isOverview &&
        options.overview.content &&
        options.overview.content.y2Axis &&
        options.overview.content.y2Axis.rendered == 'on'; // main chart's y2-axis.rendered = "off" should be ignored(for sizing purposes) if the overview has a y2-axis

      DvtChartAxisRenderer._addAxisGaps(chart, availSpace);

      // Set which axis loses its last label when both plot areas are rendered to avoid overlapping labels
      if (isSplitDualY && yPosition == y2Position) {
        options['yAxis']['_skipHighestTick'] = isHoriz;
        options['y2Axis']['_skipHighestTick'] = !isHoriz;
      }

      // Layout Algorithm
      // 1. Get preferred size of y axes and allocate space.
      // 2. Get preferred size of x axis and allocate space.
      // 3. Update y axes with reduced size (due to x axis)

      // Get preferred sizing for the y axes
      var yInfo = DvtChartAxisRenderer._createYAxis(
        chart,
        container,
        availSpace,
        totalAvailSpace,
        ignoreYRendering
      );
      var y2Info = DvtChartAxisRenderer._createY2Axis(
        chart,
        container,
        availSpace,
        totalAvailSpace,
        ignoreY2Rendering
      );

      // Align the y and y2 axis tick marks if needed
      var bAligned =
        !isSplitDualY &&
        options['y2Axis']['alignTickMarks'] == 'on' &&
        options['y2Axis']['step'] == null;
      if (bAligned && yInfo && y2Info) {
        // Alignment won't happen below if yAxis.getPreferredSize() is not called in _createYAxis(), so we must call
        // _alignYAxes() again later after rendering yAxis.
        DvtChartAxisRenderer._alignYAxes(chart, yInfo, y2Info);

        //  - y2 tick label is missing sometimes
        // recalculate preferred dimensions to account for new set of labels, which may be wider than previous dimensions
        if (!isHoriz)
          y2Info.dim = DvtChartAxisRenderer._getPreferredSize(
            chart,
            y2Info.axis,
            chart.y2Axis,
            y2Info.options,
            'y2',
            availSpace,
            totalAvailSpace,
            ignoreY2Rendering
          );
      }

      var yGap = DvtChartAxisUtils.getTickLabelGapSize(chart, 'y');
      var y2Gap = DvtChartAxisUtils.getTickLabelGapSize(chart, 'y2');

      // Position the axes to reserve space
      if (isSplitDualY && yPosition == y2Position) {
        var maxSize; // align the two y axes
        if (isHoriz) {
          maxSize = Math.max(yInfo.dim.h + yGap, y2Info.dim.h + y2Gap);
          yInfo.dim.h = maxSize - yGap;
          y2Info.dim.h = maxSize - y2Gap;
        } else {
          maxSize = Math.max(yInfo.dim.w + yGap, y2Info.dim.w + y2Gap);
          yInfo.dim.w = maxSize - yGap;
          y2Info.dim.w = maxSize - y2Gap;
        }
        DvtChartAxisRenderer._positionAxis(availSpace.clone(), yInfo, yGap, ignoreYRendering); // clone so availSpace not subtracted twice
        DvtChartAxisRenderer._positionAxis(availSpace, y2Info, y2Gap, ignoreY2Rendering);
      } else {
        DvtChartAxisRenderer._positionAxis(availSpace, yInfo, yGap, ignoreYRendering);
        DvtChartAxisRenderer._positionAxis(availSpace, y2Info, y2Gap, ignoreY2Rendering);
      }

      // Spark Bar Spacing Support
      var numGroups = DvtChartDataUtils.getGroupCount(chart);
      if (DvtChartStyleUtils.getBarSpacing(chart) == 'pixel' && DvtChartTypeUtils.isBar(chart)) {
        // Adjust the width so that it's an even multiple of the number of groups
        if (availSpace.w > numGroups) {
          var newWidth = Math.floor(availSpace.w / numGroups) * numGroups;
          availSpace.x += (availSpace.w - newWidth) / 2;
          availSpace.w = newWidth;
        }
      }

      // Get preferred sizing for the x axes, render, and position.
      var xInfo = DvtChartAxisRenderer._createXAxis(chart, container, availSpace, totalAvailSpace);
      xInfo.axis.render(xInfo.options, xInfo.dim.w, xInfo.dim.h);
      DvtChartAxisRenderer._positionAxis(
        availSpace,
        xInfo,
        DvtChartAxisUtils.getTickLabelGapSize(chart, 'x')
      );

      var splitterPosition = DvtChartStyleUtils.getSplitterPos(chart);
      var isR2L = dvt.Agent.isRightToLeft(chart.getCtx());
      var yAvailSpace = DvtChartAxisRenderer._getSplitAvailSpace(
        availSpace,
        splitterPosition,
        isHoriz,
        isHoriz && isR2L
      );
      var y2AvailSpace = DvtChartAxisRenderer._getSplitAvailSpace(
        availSpace,
        1 - splitterPosition,
        isHoriz,
        !isHoriz || !isR2L
      );

      // Render and position the y axes
      if (isHoriz) {
        if (yInfo) {
          yInfo.axis.setTranslateX(availSpace.x);
          if (isSplitDualY)
            yInfo.axis.render(yInfo.options, yAvailSpace.w, yInfo.dim.h, yAvailSpace.x, 0);
          else yInfo.axis.render(yInfo.options, availSpace.w, yInfo.dim.h);
        }

        if (bAligned && yInfo && y2Info)
          // align again after rendering yAxis
          DvtChartAxisRenderer._alignYAxes(chart, yInfo, y2Info);

        if (y2Info) {
          y2Info.axis.setTranslateX(availSpace.x);
          if (isSplitDualY)
            y2Info.axis.render(y2Info.options, y2AvailSpace.w, y2Info.dim.h, y2AvailSpace.x, 0);
          else y2Info.axis.render(y2Info.options, availSpace.w, y2Info.dim.h);
        }

        DvtChartAxisRenderer._setOverflow(availSpace, yInfo, xInfo);
      } else {
        if (yInfo) {
          if (isSplitDualY)
            yInfo.axis.render(yInfo.options, yInfo.dim.w, yAvailSpace.h, 0, yAvailSpace.y);
          else yInfo.axis.render(yInfo.options, yInfo.dim.w, availSpace.h);
        }

        if (bAligned && yInfo && y2Info)
          // align again after rendering yAxis
          DvtChartAxisRenderer._alignYAxes(chart, yInfo, y2Info);

        if (y2Info) {
          if (isSplitDualY)
            y2Info.axis.render(y2Info.options, y2Info.dim.w, y2AvailSpace.h, 0, y2AvailSpace.y);
          else y2Info.axis.render(y2Info.options, y2Info.dim.w, availSpace.h);
        }
        DvtChartAxisRenderer._setOverflow(availSpace, xInfo, yInfo, y2Info);
      }

      DvtChartAxisRenderer._storeAxes(chart, xInfo, yInfo, y2Info);
    },

    /**
     * Renders axes in polar coordinate system.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderPolar: (chart, container, availSpace) => {
      var xInfo = DvtChartAxisRenderer._createXAxis(chart, container, availSpace, availSpace);
      xInfo.axis.setTranslateX(availSpace.x);
      xInfo.axis.setTranslateY(availSpace.y);
      xInfo.axis.render(xInfo.options, availSpace.w, availSpace.h);

      var yInfo = DvtChartAxisRenderer._createYAxis(chart, container, availSpace, availSpace);
      yInfo.axis.setTranslateX(availSpace.x);
      yInfo.axis.setTranslateY(availSpace.y);
      yInfo.axis.render(yInfo.options, availSpace.w, availSpace.h);

      DvtChartAxisRenderer._storeAxes(chart, xInfo, yInfo);
    },

    /**
     * Returns an object containing the x-axis with its position and preferred size.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space for the axis.
     * @param {dvt.Rectangle} totalAvailSpace The total available space allocated for all axes and plot area.
     * @return {object}
     * @private
     */
    _createXAxis: (chart, container, availSpace, totalAvailSpace) => {
      var options = chart.getOptions();
      var position = DvtChartAxisUtils.getXAxisPos(chart);

      // Clone the axis options and fill with data info
      var axisOptions = dvt.JsonUtils.clone(
        options['xAxis'],
        null,
        chart.Defaults.getNoCloneObject().xAxis
      );
      axisOptions['position'] = position;
      axisOptions['isStandalone'] = DvtChartAxisUtils.isStandaloneXAxis(chart);
      axisOptions['groupSeparators'] = options['styleDefaults']['groupSeparators'];

      DvtChartAxisRenderer._addCommonAxisAttr(axisOptions, 'x', chart);

      // Calc the data attributes and pass in the min and max data values for that axis
      axisOptions['groups'] = options['groups'];
      axisOptions['_groupWidthRatios'] = DvtChartGroupUtils.getGroupWidthRatios(chart);
      axisOptions['timeAxisType'] = DvtChartTypeUtils.getTimeAxisType(chart);
      axisOptions['_locale'] = options['_locale'];
      axisOptions['drilling'] = options['drilling'];
      axisOptions['_isGroupAxis'] = DvtChartTypeUtils.hasGroupAxis(chart);

      var isHoriz = position == 'top' || position == 'bottom';
      var isGridShifted = DvtChartAxisUtils.isGridShifted(chart);

      // Add a time/group axis bar offset if needed
      if (position == 'tangential' && DvtChartTypeUtils.hasGroupAxis(chart)) {
        if (isGridShifted) {
          axisOptions['startGroupOffset'] = 0.5;
          axisOptions['endGroupOffset'] = 0.5;
        } else axisOptions['endGroupOffset'] = 1;
      } else {
        var axisOffset = DvtChartAxisUtils.getAxisOffset(chart);
        axisOptions['startGroupOffset'] = axisOffset;
        axisOptions['endGroupOffset'] = axisOffset;

        if (DvtChartStyleUtils.hasUncenteredSeries(chart)) axisOptions['endGroupOffset'] += 1;

        // Add extra offset if the y-axis tick label is inside
        if (!DvtChartBehaviorUtils.isScrollable(chart) && !DvtChartTypeUtils.isOverview(chart)) {
          var numGroups = DvtChartDataUtils.getGroupCount(chart);
          if (
            DvtChartAxisUtils.isAxisRendered(chart, 'y') &&
            DvtChartAxisUtils.isTickLabelInside(chart, 'y')
          )
            axisOptions[(isHoriz ? 'start' : 'end') + 'GroupOffset'] += numGroups * 0.04;
          if (
            DvtChartAxisUtils.isAxisRendered(chart, 'y2') &&
            DvtChartAxisUtils.isTickLabelInside(chart, 'y2')
          )
            axisOptions[(isHoriz ? 'end' : 'start') + 'GroupOffset'] += numGroups * 0.04;
        }
      }

      // Specify the buffers (how much the labels can overflow)
      axisOptions['leftBuffer'] = isHoriz ? availSpace.x - totalAvailSpace.x : 0;
      axisOptions['rightBuffer'] = isHoriz
        ? totalAvailSpace.w + totalAvailSpace.x - (availSpace.w + availSpace.x)
        : 0;

      // Variable to be used for features that may be rendered at the label or in between labels
      axisOptions['_renderGridAtLabels'] = !isGridShifted || DvtChartTypeUtils.hasTimeAxis(chart);

      axisOptions.translations = options.translations;

      // Create the x-axis
      var axis = new DvtChartAxis(chart.getCtx(), chart.processEvent, chart);
      container.addChild(axis);
      var preferredSize = DvtChartAxisRenderer._getPreferredSize(
        chart,
        axis,
        chart.xAxis,
        axisOptions,
        'x',
        availSpace,
        totalAvailSpace
      );

      // Update min/max coords for axis label overflow
      axisOptions['_minOverflowCoord'] = options['_minOverflowCoord'] - availSpace.x;
      axisOptions['_maxOverflowCoord'] = options['_maxOverflowCoord'] - availSpace.x;

      return { axis: axis, options: axisOptions, dim: preferredSize };
    },

    /**
     * Returns an object containing the y-axis with its position and preferred size.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space for the axis.
     * @param {dvt.Rectangle} totalAvailSpace The total available space allocated for all axes and plot area.
     * @param {boolean} ignoreRenderedOption rendered= "off" will be ignored if this is true
     * @return {object}
     * @private
     */
    _createYAxis: (chart, container, availSpace, totalAvailSpace, ignoreRenderedOption) => {
      var options = chart.getOptions();

      // Check that the graph needs a y1 axis
      if (DvtChartDataUtils.hasY2DataOnly(chart)) return null;

      // Clone the axis options and fill with data info
      var axisOptions = dvt.JsonUtils.clone(
        options['yAxis'],
        null,
        chart.Defaults.getNoCloneObject().yAxis
      );
      axisOptions['position'] = DvtChartAxisUtils.getYAxisPos(chart);
      axisOptions['isStandalone'] = DvtChartAxisUtils.isStandaloneYAxis(chart);

      DvtChartAxisRenderer._addCommonAxisAttr(axisOptions, 'y', chart);
      DvtChartAxisRenderer._addCommonYAxisAttr(axisOptions, chart);

      axisOptions.translations = options.translations;

      // Create the axis and add to the display list for calc and rendering
      var axis = new DvtChartAxis(chart.getCtx(), chart.processEvent, chart);
      container.addChild(axis);
      var preferredSize = DvtChartAxisRenderer._getPreferredSize(
        chart,
        axis,
        chart.yAxis,
        axisOptions,
        'y',
        availSpace,
        totalAvailSpace,
        ignoreRenderedOption
      );
      DvtChartAxisRenderer._adjustYAxisForLabels(axis, axisOptions, chart, 'y');

      // Store the axis min/max for zoom & scroll
      options['yAxis']['min'] = axisOptions['min'];
      options['yAxis']['max'] = axisOptions['max'];

      return { axis: axis, options: axisOptions, dim: preferredSize };
    },

    /**
     * Returns an object containing the y2-axis with its position and preferred size.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space for the axis.
     * @param {dvt.Rectangle} totalAvailSpace The total available space allocated for all axes and plot area.
     * @param {boolean} ignoreRenderedOption rendered= "off" will be ignored if this is true
     * @return {object}
     * @private
     */
    _createY2Axis: (chart, container, availSpace, totalAvailSpace, ignoreRenderedOption) => {
      var options = chart.getOptions();

      // Check that the graph has y2-axis data
      if (!DvtChartDataUtils.hasY2Data(chart)) return undefined;

      // Clone the axis options and fill with data info
      var axisOptions = dvt.JsonUtils.clone(
        options['y2Axis'],
        null,
        chart.Defaults.getNoCloneObject().y2Axis
      );
      axisOptions['position'] = DvtChartAxisUtils.getY2AxisPos(chart);
      axisOptions['isStandalone'] = DvtChartAxisUtils.isStandaloneY2Axis(chart);

      DvtChartAxisRenderer._addCommonAxisAttr(axisOptions, 'y2', chart);
      DvtChartAxisRenderer._addCommonYAxisAttr(axisOptions, chart);

      axisOptions.translations = options.translations;

      // Create the axis and add to the display list for calc and rendering
      var axis = new DvtChartAxis(chart.getCtx(), chart.processEvent, chart);
      container.addChild(axis);
      var preferredSize = DvtChartAxisRenderer._getPreferredSize(
        chart,
        axis,
        chart.y2Axis,
        axisOptions,
        'y2',
        availSpace,
        totalAvailSpace,
        ignoreRenderedOption
      );
      DvtChartAxisRenderer._adjustYAxisForLabels(axis, axisOptions, chart, 'y2');

      // Store the axis min/max for zoom & scroll
      options['y2Axis']['min'] = axisOptions['min'];
      options['y2Axis']['max'] = axisOptions['max'];

      return { axis: axis, options: axisOptions, dim: preferredSize };
    },

    /**
     * Add attributes that are common to any type of axis.
     * @param {object} axisOptions The axis options object to be filled in.
     * @param {string} type The axis type: x, y, or y2
     * @param {Chart} chart
     * @private
     */
    _addCommonAxisAttr: (axisOptions, type, chart) => {
      var options = chart.getOptions();

      axisOptions['skin'] = options['skin'];
      axisOptions['tickLabel']['position'] = DvtChartAxisUtils.isTickLabelInside(chart, type)
        ? 'inside'
        : 'outside';
      axisOptions['baselineScaling'] = DvtChartAxisUtils.getBaselineScaling(chart, type);
      // Skip highest tick mark and label if the axis tick label is inside or if the axis is tangential
      if (DvtChartAxisUtils.isTickLabelInside(chart, type) || axisOptions['position'] == 'tangential')
        axisOptions['_skipHighestTick'] = true;

      axisOptions['zoomAndScroll'] = DvtChartTypeUtils.isPolar(chart)
        ? 'off'
        : options['zoomAndScroll'];
      axisOptions['_isOverview'] = DvtChartTypeUtils.isOverview(chart);
      axisOptions['_duringZoomAndScroll'] = options['_duringZoomAndScroll'];

      // Data Axis Support
      if (type != 'x' || !DvtChartTypeUtils.hasGroupAxis(chart)) {
        var dataValues = DvtChartAxisUtils.getMinMaxVal(chart, type);
        axisOptions['dataMin'] =
          axisOptions['dataMin'] != null ? axisOptions['dataMin'] : dataValues['min'];
        axisOptions['dataMax'] =
          axisOptions['dataMax'] != null ? axisOptions['dataMax'] : dataValues['max'];
      }

      if (DvtChartTypeUtils.isPolar(chart)) {
        axisOptions['polarGridShape'] = DvtChartAxisUtils.isGridPolygonal(chart)
          ? 'polygon'
          : 'circle';
        axisOptions['_radius'] = chart.getRadius();
      }

      axisOptions['dnd'] = options['dnd'];
    },

    /**
     * Add attributes that are common to Y and Y2 axes.
     * @param {object} axisOptions The axis options object to be filled in.
     * @param {Chart} chart
     * @private
     */
    _addCommonYAxisAttr: (axisOptions, chart) => {
      axisOptions['timeAxisType'] = 'disabled';

      // Enable continuous extent for smooth y-axis rescaling animation
      if (
        DvtChartBehaviorUtils.isLiveScroll(chart) &&
        DvtChartTypeUtils.isBLAC(chart) &&
        !DvtChartTypeUtils.isPolar(chart)
      )
        axisOptions['_continuousExtent'] = 'on';

      // Specify the buffers (how much the labels can overflow)
      if (axisOptions['isStandalone']) {
        axisOptions['leftBuffer'] = 0;
        axisOptions['rightBuffer'] = 0;
      } else if (DvtChartDataUtils.isSplitDualY(chart)) {
        axisOptions['leftBuffer'] = Infinity;
        axisOptions['rightBuffer'] = Infinity;
      } else {
        var isR2L = dvt.Agent.isRightToLeft(chart.getCtx());
        axisOptions['leftBuffer'] = isR2L ? 0 : ojdvtAxis.BaseAxisInfo.MIN_AXIS_BUFFER;
        axisOptions['rightBuffer'] = isR2L ? ojdvtAxis.BaseAxisInfo.MIN_AXIS_BUFFER : 0;
      }
    },

    /**
     * Adjust the max and min of the axes considering the height of labels
     * @param {object} axis The axis object.
     * @param {object} axisOptions The axis options object to be filled in.
     * @param {Chart} chart
     * @param {string} type The y axis type: y, or y2
     * @private
     */
    _adjustYAxisForLabels: (axis, axisOptions, chart, type) => {
      var options = chart.getOptions();

      // 
      // Increase the data max/min to cause an extra interval to be added if max/min label will be hidden or covered
      if (DvtChartAxisUtils.isYAdjustmentNeeded(chart)) {
        var dataLabelStyle = dvt.CSSStyle.mergeStyles([
          options.styleDefaults._dataLabelStyle,
          options.styleDefaults.dataLabelStyle
        ]);
        var stackLabelStyle = options.styleDefaults.stackLabelStyle;
        var axisInfo = axis.getInfo();
        var isStackLabelRendered = DvtChartStyleUtils.isStackLabelRendered(chart);
        var textHeight = dvt.TextUtils.getTextStringHeight(
          chart.getCtx(),
          isStackLabelRendered ? stackLabelStyle : dataLabelStyle
        );
        var buffer = 0;

        if (axisOptions['scale'] == 'log') {
          // Only consider max since min can't go below 0
          var requiredMaxValue = axis.getUnboundedValAt(
            axis.getUnboundedCoordAt(axisInfo.getDataMax()) - textHeight
          );
          buffer = requiredMaxValue - axisInfo.getDataMax();
        } else {
          var splitYFactor = 1;
          if (DvtChartDataUtils.isSplitDualY(chart)) {
            splitYFactor =
              type == 'y'
                ? DvtChartStyleUtils.getSplitterPos(chart)
                : 1 - DvtChartStyleUtils.getSplitterPos(chart);
          }
          var yAxisHeight =
            Math.abs(axisInfo.getEndCoord() - axisInfo.getStartCoord()) * splitYFactor;
          buffer =
            (Math.abs(axisInfo.getViewportMax() - axisInfo.getViewportMin()) / yAxisHeight) *
            textHeight;
        }

        if (DvtChartTypeUtils.isHorizontal(chart)) buffer *= 4;
        else buffer *= 2;

        if (axisInfo.getDataMin() - axisInfo.getGlobalMin() <= buffer && axisInfo.getDataMin() < 0)
          axisOptions['dataMin'] -= buffer;

        if (axisInfo.getGlobalMax() - axisInfo.getDataMax() <= buffer && axisInfo.getDataMax() > 0)
          axisOptions['dataMax'] += buffer;
      }
    },

    /**
     * Returns the preferred size of the axis.
     * @param {Chart} chart
     * @param {DvtAxis} axis
     * @param {DvtAxis} oldAxis The axis from previous render. We use the dims from the old axis to increase animation performance.
     * @param {Object} axisOptions
     * @param {String} type The axis type: x, y, or y2.
     * @param {dvt.Rectangle} availSpace
     * @param {dvt.Rectangle} totalAvailSpace
     * @param {boolean} ignoreRenderedOption rendered= "off" will be ignored if this is true
     * @return {dvt.Dimension} The preferred size.
     * @private
     */
    _getPreferredSize: (
      chart,
      axis,
      oldAxis,
      axisOptions,
      type,
      availSpace,
      totalAvailSpace,
      ignoreRenderedOption
    ) => {
      var isStandalone = axisOptions['isStandalone'];
      var position = axisOptions['position'];
      var isHoriz = position == 'top' || position == 'bottom';
      var gap = DvtChartAxisUtils.getTickLabelGapSize(chart, type);
      var maxSize = axisOptions['maxSize'];
      var axisSize = axisOptions['size'];
      var preferredWidth = availSpace.w;
      var preferredHeight = availSpace.h;

      // preferredSize not needed for polar
      if (position == 'radial' || position == 'tangential') {
        preferredWidth = 0;
        preferredHeight = 0;
      }

      // if axis not rendered, return 0 for the size dimension
      else if (axisOptions['rendered'] == 'off' && !ignoreRenderedOption) {
        if (isHoriz) preferredHeight = 0;
        else preferredWidth = 0;
      }

      // for standalone axis, use the entire space
      else if (isStandalone) {
        if (isHoriz) preferredHeight = availSpace.h - gap;
        else preferredWidth = availSpace.w - gap;
      }

      // size is explicitly specified
      else if (axisSize != null) {
        if (!isHoriz) {
          preferredWidth = DvtChartStyleUtils.getSizeInPixels(axisSize, totalAvailSpace.w) - gap;
          if (maxSize != null)
            preferredWidth = Math.min(
              preferredWidth,
              DvtChartStyleUtils.getSizeInPixels(maxSize, totalAvailSpace.w) - gap
            );
        } else {
          preferredHeight = DvtChartStyleUtils.getSizeInPixels(axisSize, totalAvailSpace.h) - gap;
          if (maxSize != null)
            preferredHeight = Math.min(
              preferredHeight,
              DvtChartStyleUtils.getSizeInPixels(maxSize, totalAvailSpace.h) - gap
            );
        }
      }

      // during animation, reuse the previous axis size
      else if (chart.getOptions()['_duringZoomAndScroll'] && oldAxis) {
        if (isHoriz) {
          // The axis overflow amount has to be maintained to prevent jumpy animation
          var isR2L = dvt.Agent.isRightToLeft(chart.getCtx());
          axisOptions['_startOverflow'] = isR2L
            ? oldAxis.getRightOverflow()
            : oldAxis.getLeftOverflow();
          axisOptions['_endOverflow'] = isR2L
            ? oldAxis.getLeftOverflow()
            : oldAxis.getRightOverflow();

          preferredHeight = oldAxis.getHeight();
        } else preferredWidth = oldAxis.getWidth();
      } else {
        // last option: use axis.getPreferredSize based on the maxSize
        maxSize = maxSize == null ? DvtChartAxisRenderer._DEFAULT_AXIS_MAX_SIZE : maxSize;
        if (isHoriz)
          return axis.getPreferredSize(
            axisOptions,
            availSpace.w,
            DvtChartStyleUtils.getSizeInPixels(maxSize, totalAvailSpace.h) - gap,
            ignoreRenderedOption
          );
        else
          return axis.getPreferredSize(
            axisOptions,
            DvtChartStyleUtils.getSizeInPixels(maxSize, totalAvailSpace.w) - gap,
            availSpace.h,
            ignoreRenderedOption
          );
      }

      //  Calling getPreferredSize to ensure that axis info is populated.
      if (DvtChartAxisUtils.isYAdjustmentNeeded(chart))
        axis.getPreferredSize(axisOptions, preferredWidth, preferredHeight);

      return new dvt.Dimension(preferredWidth, preferredHeight);
    },

    /**
     * Apply gaps to availSpace to accommodate the vertical axis labels.
     * @param {Chart} chart
     * @param {dvt.Rectangle} availSpace
     * @private
     */
    _addAxisGaps: (chart, availSpace) => {
      var isHoriz = DvtChartTypeUtils.isHorizontal(chart);
      var yPosition = DvtChartAxisUtils.getYAxisPos(chart);
      var y2Position = DvtChartAxisUtils.getY2AxisPos(chart);
      var isXRendered = DvtChartAxisUtils.isAxisRendered(chart, 'x');
      var isYRendered = DvtChartAxisUtils.isAxisRendered(chart, 'y');
      var isY2Rendered = DvtChartAxisUtils.isAxisRendered(chart, 'y2');

      var axisGap = chart.getOptions()['layout']['verticalAxisGap'];
      if (isHoriz) axisGap *= DvtChartAxisUtils.getGapScalingFactor(chart, 'x');
      else
        axisGap *= Math.max(
          DvtChartAxisUtils.getGapScalingFactor(chart, 'y'),
          DvtChartAxisUtils.getGapScalingFactor(chart, 'y2')
        );
      axisGap = Math.ceil(axisGap); // prevent rounding errors

      // top gap if necessary
      if (
        (isHoriz && !(yPosition == 'top' && isYRendered) && !(y2Position == 'top' && isY2Rendered)) ||
        !isHoriz
      ) {
        availSpace.y += axisGap;
        availSpace.h -= axisGap;
      }

      // bottom gap if necessary
      if (
        (isHoriz &&
          !(yPosition == 'bottom' && isYRendered) &&
          !(y2Position == 'bottom' && isY2Rendered)) ||
        (!isHoriz && !isXRendered)
      )
        availSpace.h -= axisGap;
    },

    /**
     * Positions the axis.
     * @param {dvt.Rectangle} availSpace
     * @param {object} axisInfo
     * @param {number} gap The tick label gap size.
     * @param {boolean} ignoreRenderedOption rendered= "off" will be ignored if this is true
     * @private
     */
    _positionAxis: (availSpace, axisInfo, gap, ignoreRenderedOption) => {
      if (!axisInfo) return;
      // Adjust dimensions because the layout work should still be done.
      var height = ignoreRenderedOption ? Math.max(axisInfo.dim.h, 1) : axisInfo.dim.h;
      var width = ignoreRenderedOption ? Math.max(axisInfo.dim.w, 1) : axisInfo.dim.w;

      dvt.LayoutUtils.position(
        availSpace,
        axisInfo.options['position'],
        axisInfo.axis,
        width,
        height,
        gap
      );
    },

    /**
     * Aligns Y1 and Y2 axes gridlines if needed.
     * @param {Chart} chart
     * @param {object} yInfo
     * @param {object} y2Info
     * @private
     */
    _alignYAxes: (chart, yInfo, y2Info) => {
      var yAxisInfo = yInfo.axis.getInfo();
      if (!yAxisInfo) return; // alignYAxes doesn't work if the y info hasn't been created (either in getPreferredSize or render)

      var majorTickCount = yAxisInfo.getMajorTickCount();
      var minorTickCount = yAxisInfo.getMinorTickCount();

      var y2Options = y2Info.options;

      // support for aligning log axis with log axis (if an app attempts to align log w/ linear, we don't guarantee good results)
      var y2AxisInfo = y2Info.axis.getInfo();
      if (y2AxisInfo && DvtChartAxisUtils.isLog(chart, 'y') && DvtChartAxisUtils.isLog(chart, 'y2')) {
        // When a y2 log axis initially requires more ticks to render its content than the y log axis,
        // we must force an increase of the scaleUnit in order to align it to the y axis because we will be decreasing its tickCount
        if (majorTickCount < y2AxisInfo.getMajorTickCount()) {
          // save scale unit in options for use when axis into is re-created
          y2Options['_logScaleUnit'] = y2AxisInfo.alignLogScaleToTickCount(
            y2AxisInfo.getLogScaleUnit(),
            majorTickCount
          );
        }
      }

      // Save tick counts in options for use when data axis info is re-created after layout
      y2Options['_majorTickCount'] = majorTickCount;
      y2Options['_minorTickCount'] = minorTickCount;
    },

    /**
     * Returns the available space for the subchart of a split dual-Y chart
     * @param {dvt.Rectangle} availSpace The available space.
     * @param {number} splitRatio The percentage of the available height/width the subchart will use.
     * @param {boolean} isHoriz Whether or not the chart is horizontal.
     * @param {boolean} isEnd Whether this subchart is the right or the bottom half.
     * @return {dvt.Rectangle} The available space for the subchart
     * @private
     */
    _getSplitAvailSpace: (availSpace, splitRatio, isHoriz, isEnd) => {
      var splitSpace = availSpace.clone();
      if (isHoriz) {
        splitSpace.w = availSpace.w * splitRatio;
        splitSpace.x = isEnd ? availSpace.w * (1 - splitRatio) : 0;
      } else {
        splitSpace.h = availSpace.h * splitRatio;
        splitSpace.y = isEnd ? availSpace.h * (1 - splitRatio) : 0;
      }

      return splitSpace;
    },

    /**
     * Reduce the availSpace based on the overflow of the horizontal axis. Shifts the vertical axes based on the reduced
     * plot area size.
     * @param {dvt.Rectangle} availSpace
     * @param {object} xInfo
     * @param {object} yInfo
     * @param {object} y2Info
     * @private
     */
    _setOverflow: (availSpace, xInfo, yInfo, y2Info) => {
      if (!xInfo) return;

      // Adjust the y-axis position and plot area width depending on x-axis overflow
      var leftOverflow = xInfo.axis.getLeftOverflow();
      var rightOverflow = xInfo.axis.getRightOverflow();
      availSpace.x += leftOverflow;
      availSpace.w -= leftOverflow + rightOverflow;

      if (yInfo)
        yInfo.axis.setTranslateX(
          yInfo.axis.getTranslateX() +
            (yInfo.options['position'] == 'left' ? leftOverflow : -rightOverflow)
        );
      if (y2Info)
        y2Info.axis.setTranslateX(
          y2Info.axis.getTranslateX() +
            (y2Info.options['position'] == 'left' ? leftOverflow : -rightOverflow)
        );
    },

    /**
     * Destroys old axes and stores new axes to the chart.
     * @param {Chart} chart
     * @param {object} xInfo
     * @param {object} yInfo
     * @param {object} y2Info
     * @private
     */
    _storeAxes: (chart, xInfo, yInfo, y2Info) => {
      // Destroy the axis and remove event listeners to fix memory leak issue
      if (chart.xAxis) {
        chart.xAxis.destroy();
        chart.removeChild(chart.xAxis);
      }
      if (chart.yAxis) {
        chart.yAxis.destroy();
        chart.removeChild(chart.yAxis);
      }
      if (chart.y2Axis) {
        chart.y2Axis.destroy();
        chart.removeChild(chart.y2Axis);
      }

      // Store the axis objects on the chart
      chart.xAxis = xInfo.axis;
      chart.yAxis = yInfo ? yInfo.axis : null;
      chart.y2Axis = y2Info ? y2Info.axis : null;
    }
  };

  /**
   * Performs layout and positioning for the chart legend.
   * @class
   */
  const DvtChartLegendRenderer = {
    /** @private */
    _DEFAULT_LINE_WIDTH_WITH_MARKER: 2,

    /** @private */
    _DEFAULT_MAX_SIZE: 0.3,

    /** @private */
    _PIE_SIZE_RATIO: 1.2,

    /**
     * Renders legend and updates the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (chart, container, availSpace) => {
      var options = chart.getOptions();
      var position = options['legend']['position'];

      // Done if not rendering
      if (
        options['legend']['rendered'] == 'off' ||
        (options['legend']['rendered'] == 'auto' &&
          chart.getOptionsCache().getFromCache('hasLargeSeriesCount'))
      )
        return;

      // Create the options object for the legend
      var legendOptions = dvt.JsonUtils.clone(options['legend']);
      delete legendOptions['position'];
      legendOptions['skin'] = options['skin'];
      legendOptions['hideAndShowBehavior'] = DvtChartBehaviorUtils.getHideAndShowBehavior(chart);
      legendOptions['hoverBehavior'] = DvtChartBehaviorUtils.getHoverBehavior(chart);
      legendOptions['hoverBehaviorDelay'] = DvtChartStyleUtils.getHoverBehaviorDelay(chart);
      legendOptions['hiddenCategories'] = DvtChartDataUtils.getHiddenCategories(chart);
      legendOptions['highlightedCategories'] = DvtChartDataUtils.getHighlightedCategories(chart);
      legendOptions['dnd'] = options['dnd'];
      legendOptions['_dropColor'] = options['_dropColor'];
      legendOptions['translations'] = options['translations'];

      // Moving over to non deprecated api
      legendOptions['sectionTitleStyle'] = {
        ...legendOptions.sectionTitleStyle,
        ...legendOptions.titleStyle
      };
      legendOptions['sectionTitleHalign'] =
        legendOptions['titleHalign'] || legendOptions['sectionTitleHalign'];
      delete legendOptions['titleStyle'];
      delete legendOptions['titleHalign'];

      // Evaluate the automatic position
      // Position the legend to occupy the larger dimension so that the plot area is more square
      if (position == 'auto') {
        if (availSpace.w >= availSpace.h) position = 'end';
        else position = 'bottom';
      }

      // Add legend orientation
      var isHoriz = position == 'top' || position == 'bottom';
      legendOptions['orientation'] = isHoriz ? 'horizontal' : 'vertical';

      // Set legend alignment
      if (position == 'start') legendOptions['halign'] = 'end';
      if (position == 'start' || position == 'end') legendOptions['valign'] = 'middle';
      if (position == 'top') legendOptions['valign'] = 'bottom';
      if (position == 'top' || position == 'bottom') legendOptions['halign'] = 'center';

      // Add data for the legend
      DvtChartLegendRenderer._addLegendData(chart, legendOptions);

      // If no legend sections were added, then nothing should be rendered
      if (legendOptions['sections'].length == 0) return;

      // Create and add the legend to the display list for calc and rendering
      var legend = new ojlegendToolkit.Legend(chart.getCtx(), chart.processEvent, chart);
      if (chart.getId() != null) {
        //create and set legend id based on parent id
        legend.setId(chart.getId() + 'legend');
      }
      container.addChild(legend);

      var actualSize;
      if (legendOptions['size'] != null) {
        // exact size is specified
        if (isHoriz)
          actualSize = new dvt.Dimension(
            availSpace.w,
            DvtChartStyleUtils.getSizeInPixels(legendOptions['size'], availSpace.h)
          );
        else
          actualSize = new dvt.Dimension(
            DvtChartStyleUtils.getSizeInPixels(legendOptions['size'], availSpace.w),
            availSpace.h
          );
      } else {
        // use preferred size
        var maxSize = legendOptions['maxSize'];
        if (maxSize == null) {
          maxSize = DvtChartLegendRenderer._DEFAULT_MAX_SIZE;

          // Pie charts are usually almost square in the amount of space it takes, so we can allocate more space to the
          // legend if the legend needs it.
          if (DvtChartTypeUtils.isPie(chart)) {
            var availMaxSize =
              1 -
              DvtChartLegendRenderer._PIE_SIZE_RATIO *
                (isHoriz ? availSpace.w / availSpace.h : availSpace.h / availSpace.w);
            maxSize = Math.max(maxSize, availMaxSize);
          }
        }

        var maxWidth = isHoriz
          ? availSpace.w
          : DvtChartStyleUtils.getSizeInPixels(maxSize, availSpace.w);
        var maxHeight = isHoriz
          ? DvtChartStyleUtils.getSizeInPixels(maxSize, availSpace.h)
          : availSpace.h;
        actualSize = legend.getPreferredSize(legendOptions, maxWidth, maxHeight);
      }

      legend.render(legendOptions, actualSize.w, actualSize.h);
      var gap = isHoriz
        ? DvtChartDefaults.getGapHeight(chart, options['layout']['legendGapHeight'])
        : DvtChartDefaults.getGapWidth(chart, options['layout']['legendGapWidth']);
      dvt.LayoutUtils.position(availSpace, position, legend, actualSize.w, actualSize.h, gap);

      var isDraggable = Object.keys(legendOptions['dnd']['drag']['series']).length > 0;
      var background = legend.getCache().getFromCache('background');
      if (isDraggable && background) background.setClassName('oj-draggable');

      var bounds = legend.__getBounds();
      var shiftedPos = legend.localToStage(new dvt.Point(bounds.x, bounds.y));

      // Update min/max coords for axis label overflow
      if (!DvtChartTypeUtils.isOverview(chart)) {
        var isRTL = dvt.Agent.isRightToLeft(chart.getCtx());
        if (position == 'end') {
          if (isRTL) options['_minOverflowCoord'] = shiftedPos.x + bounds.w + gap / 2;
          else options['_maxOverflowCoord'] = shiftedPos.x - gap / 2;
        } else if (position == 'start') {
          if (isRTL) options['_maxOverflowCoord'] = shiftedPos.x - gap / 2;
          else options['_minOverflowCoord'] = shiftedPos.x + bounds.w + gap / 2;
        }
      }
      // Destroy the legend and remove event listeners to fix memory leak issue
      if (chart.legend) {
        chart.legend.destroy();
        container.removeChild(chart.legend);
      }

      // Cache the legend for interactivity
      chart.legend = legend;
      if (!DvtChartLegendRenderer.isLegendInteractive(chart)) {
        chart.legend.setAriaProperty('hidden', 'true', true);
      }
    },

    /**
     * Adds data into the options object for the legend.
     * @param {Chart} chart The chart whose data will be passed to the legend.
     * @param {object} legendOptions The legend options object into which data will be added.
     * @private
     */
    _addLegendData: (chart, legendOptions) => {
      // Series
      var seriesItems = DvtChartLegendRenderer._getSeriesItems(
        chart,
        legendOptions['orientation'] == 'vertical'
      );
      if (seriesItems.length > 0) {
        var seriesSection = legendOptions['seriesSection'];
        seriesSection['items'] = seriesItems;
        legendOptions['sections'].unshift(seriesSection); // add Series as the first section
        delete legendOptions['seriesSection'];
      }

      // Explicitly defined sections will be rendered between Series and Reference Objects

      // Reference Objects
      var refObjItems = DvtChartLegendRenderer._getRefObjItems(chart);
      if (refObjItems.length > 0) {
        var refObjSection = legendOptions['referenceObjectSection'];
        refObjSection['items'] = refObjItems;
        legendOptions['sections'].push(refObjSection); // add Reference Objects as the last section
        delete legendOptions['referenceObjectSection'];
      }
    },

    /**
     * Returns the array of series items to pass to the legend.
     * @param {Chart} chart The chart whose data will be passed to the legend.
     * @param {Boolean} isVertical Whether the legend is vertical.
     * @return {Array} The series items.
     * @private
     */
    _getSeriesItems: (chart, isVertical) => {
      var ret = [];
      var legendItem;
      var seriesIndex;

      if (chart.getType() == 'pie' || chart.getType() == 'pyramid' || chart.getType() == 'funnel') {
        var seriesIndices = DvtChartPieUtils.getRenderedSeriesIndices(chart);
        if (chart.getType() == 'pyramid' && isVertical) seriesIndices.reverse();
        // Add the series in the same order
        for (var i = 0; i < seriesIndices.length; i++) {
          seriesIndex = seriesIndices[i];
          var value = DvtChartDataUtils.getVal(chart, seriesIndex, 0);
          if (value >= 0 && value != null) {
            legendItem = DvtChartLegendRenderer._createLegendItem(chart, seriesIndex);
            if (legendItem) ret.push(legendItem);
          }
        }
        if (DvtChartPieUtils.hasOtherSeries(chart)) {
          // Create legend item for "other" slice
          legendItem = {
            id: DvtChartPieUtils.OTHER_ID,
            drilling: chart.getOptions().multiSeriesDrilling,
            text: chart.getOptions().translations.labelOther,
            categoryVisibility:
              DvtChartDataUtils.getHiddenCategories(chart).indexOf(DvtChartPieUtils.OTHER_ID) >= 0
                ? 'hidden'
                : 'visible',
            symbolType: 'marker',
            color: chart.getOptions()['styleDefaults']['otherColor'],
            borderColor: chart.getOptions()['styleDefaults']['borderColor']
          };
          ret.push(legendItem);
        }
      } else {
        var yCategoryMap = {};
        var y2CategoryMap = {};

        // Loop through series to create legendItem, and map each category to a legendItem array
        var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
        for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
          legendItem = DvtChartLegendRenderer._createLegendItem(chart, seriesIndex);
          if (legendItem) {
            var category = DvtChartDataUtils.getStackCategory(chart, seriesIndex);
            if (!DvtChartDataUtils.isAssignedToY2(chart, seriesIndex)) {
              if (yCategoryMap[category]) yCategoryMap[category].push(legendItem);
              else yCategoryMap[category] = [legendItem];
            } else {
              if (y2CategoryMap[category]) y2CategoryMap[category].push(legendItem);
              else y2CategoryMap[category] = [legendItem];
            }
          }
        }

        var categoryKeys = DvtChartDataUtils.getStackCategories(chart, null, true); // used for looping through categories in order to add legendItems
        var bReversed =
          DvtChartDataUtils.isStacked(chart) && DvtChartTypeUtils.isVertical(chart) && isVertical;
        // yAxis items
        ret = DvtChartLegendRenderer._getSeriesItemsForAxis(
          yCategoryMap,
          categoryKeys['y'],
          bReversed,
          ret
        );
        // y2Axis items
        ret = DvtChartLegendRenderer._getSeriesItemsForAxis(
          y2CategoryMap,
          categoryKeys['y2'],
          bReversed,
          ret
        );
      }

      return ret;
    },

    /**
     * Returns the array of series items to pass to the legend for the given axis.
     * @param {Object} categoryMap The map of stack categories and their corresponding array of legendItems
     * @param {Object} categoryKeys The in-order lists of yAxis and y2Axis stack categories
     * @param {Boolean} bReversed Whether or not to reverse legendItems when adding to array
     * @param {Array} ret The array to add legendItems to
     * @return {Array} The series items.
     * @private
     */
    _getSeriesItemsForAxis: (categoryMap, categoryKeys, bReversed, ret) => {
      var legendItemArray;
      for (var categoryIndex = 0; categoryIndex < categoryKeys.length; categoryIndex++) {
        legendItemArray = categoryMap[categoryKeys[categoryIndex]];
        if (legendItemArray) {
          // legendItemArray will be null if the only series item for a category has displayInLegend = 'off'
          if (bReversed) ret = ret.concat(legendItemArray.reverse());
          else ret = ret.concat(legendItemArray);
        }
      }
      return ret;
    },

    /**
     * Creates a legend item for a series
     * @param {Chart} chart The chart whose data will be passed to the legend
     * @param {Number} seriesIndex The series index
     * @return {Object} The legend item
     * @private
     */
    _createLegendItem: (chart, seriesIndex) => {
      var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
      var chartType = chart.getType();
      var seriesType = DvtChartDataUtils.getSeriesType(chart, seriesIndex);
      var lineType = DvtChartStyleUtils.getLineType(chart, seriesIndex);
      var displayInLegend = seriesItem['displayInLegend'];

      // Skip if the series item isn't defined or if not displayInLegend
      if (!seriesItem || displayInLegend == 'off') return null;

      // Skip if displayInLegend is auto and chart type is funnel or pyramid or stock
      if (
        displayInLegend != 'on' &&
        (DvtChartTypeUtils.isFunnel(chart) ||
          DvtChartTypeUtils.isPyramid(chart) ||
          DvtChartTypeUtils.isStock(chart))
      )
        return null;

      // Skip if displayInLegend is auto and series has no non-null data
      if (displayInLegend != 'on' && !DvtChartDataUtils.hasSeriesData(chart, seriesIndex))
        return null;

      // Skip if displayInLegend is auto and series label is an empty string
      var seriesLabel = DvtChartDataUtils.getSeriesLabel(chart, seriesIndex);
      if (
        displayInLegend != 'on' &&
        (seriesLabel == null || (typeof seriesLabel == 'string' && seriesLabel.trim().length === 0))
      )
        return null;

      // Create the legend item and add the properties for this series
      var legendItem = {
        id: DvtChartDataUtils.getSeries(chart, seriesIndex),
        text: seriesLabel,
        categories: DvtChartDataUtils.getCategories(chart, seriesIndex),
        categoryVisibility: DvtChartDataUtils.isSeriesRendered(chart, seriesIndex)
          ? 'visible'
          : 'hidden',
        _getDataContext: DvtChartStyleUtils.getDataContext.bind(null, chart, seriesIndex, -1) // for dnd callback todo: remove .bind after utils are converteed to es6
      };

      // Shape varies by chart type
      if (
        seriesType == 'line' ||
        seriesType == 'lineWithArea' ||
        chartType == 'scatter' ||
        chartType == 'bubble'
      ) {
        legendItem['lineStyle'] = DvtChartStyleUtils.getLineStyle(chart, seriesIndex);
        legendItem['lineWidth'] = DvtChartStyleUtils.getLineWidth(chart, seriesIndex);

        if (DvtChartStyleUtils.isMarkerDisplayed(chart, seriesIndex)) {
          var source = DvtChartStyleUtils.getImageSource(chart, seriesIndex, null, null, 'source');
          if (source) {
            legendItem['symbolType'] = 'image';
            legendItem['source'] = source;
          } else {
            legendItem['symbolType'] = lineType == 'none' ? 'marker' : 'lineWithMarker';
            if (legendItem['symbolType'] == 'lineWithMarker')
              legendItem['lineWidth'] = Math.min(
                DvtChartLegendRenderer._DEFAULT_LINE_WIDTH_WITH_MARKER,
                legendItem['lineWidth']
              );
            legendItem['markerShape'] = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex);
            legendItem['markerColor'] = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex);
          }
        } else legendItem['symbolType'] = 'line';
      } else if (seriesType == 'boxPlot') {
        // Create legend item with two colors only if the q2 and q3 colors are different
        var boxPlotOptions = DvtChartStyleUtils.getBoxPlotStyleOptions(chart, seriesIndex);
        if (boxPlotOptions['q2Color'] != boxPlotOptions['q3Color']) {
          legendItem['symbolType'] = DvtChartTypeUtils.isHorizontal(chart)
            ? '_horizontalBoxPlot'
            : '_verticalBoxPlot';
          legendItem['_boxPlot'] = boxPlotOptions;
        } else legendItem['symbolType'] = 'marker';
      } else {
        legendItem['symbolType'] = 'marker';
        if (DvtChartStyleUtils.getLineType(chart, seriesIndex) == 'none')
          // area with lineType == none
          legendItem['markerShape'] = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex);
      }

      // Also add the color and pattern
      legendItem['color'] = DvtChartStyleUtils.getColor(chart, seriesIndex);
      legendItem['borderColor'] = DvtChartStyleUtils.getBorderColor(chart, seriesIndex);
      legendItem['pattern'] = DvtChartStyleUtils.getPattern(chart, seriesIndex);
      legendItem['svgStyle'] =
        seriesType == 'area'
          ? DvtChartStyleUtils.getAreaStyle(chart, seriesIndex)
          : DvtChartStyleUtils.getStyle(chart, seriesIndex);
      legendItem['svgClassName'] =
        seriesType == 'area'
          ? DvtChartStyleUtils.getAreaClassName(chart, seriesIndex)
          : DvtChartStyleUtils.getClassName(chart, seriesIndex);
      legendItem['markerSvgStyle'] = DvtChartStyleUtils.getMarkerStyle(chart, seriesIndex);
      legendItem['markerSvgClassName'] = DvtChartStyleUtils.getMarkerClassName(chart, seriesIndex);

      // Drill and tooltip support
      legendItem['drilling'] = DvtChartDataUtils.isSeriesDrillable(chart, seriesIndex) ? 'on' : 'off';
      legendItem['shortDesc'] = seriesItem['shortDesc'];

      return legendItem;
    },

    /**
     * Returns the array of reference object items to pass to the legend.
     * @param {Chart} chart The chart whose data will be passed to the legend.
     * @return {array} The reference object items.
     * @private
     */
    _getRefObjItems: (chart) => {
      var refObjs = DvtChartDataUtils.getRefObjs(chart);
      if (refObjs.length <= 0) return [];

      var items = [];
      for (var i = 0; i < refObjs.length; i++) {
        var refObj = refObjs[i];

        // Reference Object must be defined with color and text to appear in legend
        if (!refObj || refObj['displayInLegend'] != 'on' || !refObj['text']) continue;

        var type = DvtChartRefObjUtils.getType(refObj);
        items.push({
          symbolType: type == 'area' ? 'square' : 'line',
          text: refObj['text'],
          color: DvtChartRefObjUtils.getColor(chart, refObj),
          lineStyle: refObj['lineStyle'],
          lineWidth: DvtChartRefObjUtils.getLineWidth(chart, refObj),
          categories: DvtChartRefObjUtils.getRefObjCategories(refObj),
          categoryVisibility: DvtChartRefObjUtils.isObjRendered(chart, refObj) ? 'visible' : 'hidden',
          shortDesc: refObj['shortDesc'],
          svgStyle: refObj['style'] || refObj['svgStyle'],
          svgClassName: refObj['className'] || refObj['svgClassName']
        });
      }

      return items;
    },

    isLegendDrillable: function (chart) {
      var options = chart.getOptions();
      if (
        options.drilling === 'on' ||
        options.drilling === 'seriesOnly' ||
        (DvtChartTypeUtils.isPie(chart) && options.multiSeriesDrilling === 'on')
      ) {
        return true;
      }

      return chart.getOptionsCache().getFromCache('hasDrillableSeries');
    },

    isLegendInteractive: function (chart) {
      var isHideShow = DvtChartBehaviorUtils.getHideAndShowBehavior(chart) !== 'none';
      return isHideShow || DvtChartLegendRenderer.isLegendDrillable(chart);
    }
  };

  /**
   * Overview window for chart.
   * @param {Chart} chart The parent chart who owns the overview.
   * @class
   * @constructor
   * @extends {Overview.Overview}
   */
  class DvtChartOverview extends ojdvtOverview.Overview {
    constructor(chart) {
      super(chart.getCtx(), chart.processEvent, chart);
      this._parentChart = chart;
      this._chart = chart.overview ? chart.overview.getBackgroundChart() : null; // save old background chart for animation
      this._id = chart.getId() + '_overview';
    }

    /**
     * Renders the background chart at the specified width and height.
     * @param {object} options Chart options.
     * @param {number} width Chart width.
     * @param {number} height Chart height.
     * @return {number} Chart plot area height.
     * @private
     */
    _renderChart(options, width, height) {
      var noCloneOptions = this._parentChart.Defaults.getNoCloneObject();
      this._chartContainer = new dvt.Container(this.getCtx());
      this.addChild(this._chartContainer);

      // Set the default options override for the overview background chart
      var defaultOptions = {
        legend: { rendered: 'off', size: null },
        xAxis: {
          viewportMin: null,
          viewportMax: null,
          viewportStartGroup: null,
          viewportEndGroup: null,
          axisLine: { rendered: 'off' },
          size: null,
          maxSize: 0.5,
          title: null
        },
        yAxis: { rendered: 'off', size: null },
        y2Axis: { rendered: 'off', size: null },
        splitDualY: 'off',
        title: { text: null },
        subtitle: { text: null },
        footnote: { text: null },
        titleSeparator: { rendered: 'off' },
        styleDefaults: { animationIndicators: 'none' },
        layout: { outerGapWidth: 0, outerGapHeight: 0 },
        _isOverview: true
      };
      options = dvt.JsonUtils.merge(defaultOptions, options, noCloneOptions);

      if (DvtChartTypeUtils.hasGroupAxis(this._parentChart))
        options['xAxis']['tickLabel']['rendered'] = 'off';

      if (DvtChartTypeUtils.isStock(this._parentChart) && options['series'] && options['series'][0]) {
        options['series'] = [options['series'][0]];
        options['series'][0]['type'] = 'lineWithArea';
      }

      // Set the user options override
      var parentOptions = this._parentChart.getOptions();
      var userOptions = parentOptions['overview']['content'];
      options = dvt.JsonUtils.merge(userOptions, options, noCloneOptions);
      var isOverviewYAxisRendered = options.yAxis.rendered === 'on';
      var isOverviewY2AxisRendered = options.y2Axis.rendered === 'on';

      // Turn off zoomAndScroll to prevent scrollbar/overview from appearing inside the overview
      // This has to be done after setting userOptions to prevent users from overriding it
      options['zoomAndScroll'] = 'off';

      // Render the chart
      if (!this._chart) {
        this._chart = this._parentChart.createOverviewChart();
        this._chart.setId(this._id); // Set the id to prevent randomly generated one from breaking tests
      }

      var chartWidth = width;
      var parentWidth = this._parentChart.getWidth();
      var parentPlotAreaSpace = this._parentChart.__getPlotAreaSpace();
      var parentHasY2Data = DvtChartDataUtils.hasY2Data(this._parentChart);
      var parentHasY2DataOnly = DvtChartDataUtils.hasY2DataOnly(this._parentChart);
      var isOverviewYAxisRendered = options.yAxis.rendered === 'on' && !parentHasY2DataOnly;
      var isOverviewY2AxisRendered = options.y2Axis.rendered === 'on' && parentHasY2Data;
      var parentPlotAreaXCoord = parentPlotAreaSpace.x;
      var yPreferredWidth = parentPlotAreaXCoord;
      var y2PreferredWidth = parentWidth - (yPreferredWidth + width);

      // Specify y-axis and y2-axis space for alignment
      if (isOverviewYAxisRendered) {
        chartWidth = yPreferredWidth + width;
        options.yAxis.size = yPreferredWidth;
      }
      if (isOverviewY2AxisRendered) {
        chartWidth = (isOverviewYAxisRendered ? yPreferredWidth : 0) + y2PreferredWidth + width;
        options.y2Axis.size = y2PreferredWidth;
      }

      this._chartContainer.addChild(this._chart);
      this._chart.render(options, chartWidth, height);

      // Cover the chart with a glass pane and remove the keyboard handler to prevent interaction
      var glassPane = new dvt.Rect(this.getCtx(), 0, 0, chartWidth, height);
      glassPane.setInvisibleFill();
      this._chartContainer.addChild(glassPane);
      this._chart.getEventManager().setKeyboardHandler(null);
      var chartPlotAreaDims = this._chart.__getPlotAreaSpace();

      if (isOverviewYAxisRendered) {
        // Shift the  overview chart so its plot area and the parent chart's plot area align
        var newX = this._chartContainer.getTranslateX() - chartPlotAreaDims.x;
        this._chartContainer.setTranslateX(newX);
      }

      return new dvt.Dimension(width, chartPlotAreaDims.h + chartPlotAreaDims.y);
    }

    /**
     * Override to change some of the styles
     * @override
     */
    render(options, width, height) {
      const filterPanelColor =
        options['chart']['_overviewFilterPanelBackgroundColor'] || 'rgba(5,65,135,0.1)';
      // override styles
      options.overview.style = {
        overviewBackgroundColor: 'rgba(0,0,0,0)',
        windowBackgroundColor: 'rgba(0,0,0,0)',
        windowBorderTopColor: '#333333',
        windowBorderRightColor: '#333333',
        windowBorderBottomColor: '#333333',
        windowBorderLeftColor: '#333333',
        leftFilterPanelColor: filterPanelColor,
        leftFilterPanelAlpha: 1,
        rightFilterPanelColor: filterPanelColor,
        rightFilterPanelAlpha: 1,
        handleBackgroundClass: options['chart']['_resources']['overviewGrippy'],
        handleSize: 16,
        handleFillColor: 'rgba(0,0,0,0)'
      };
      options.overview.animationOnClick = 'off';

      var windowDims = this._renderChart(options.chart, width, height);

      // now call super to render the scrollbar
      super.render(options.overview, windowDims.w, windowDims.h);
    }

    /**
     * @override
     */
    destroy() {
      super.destroy();

      this._parentChart = null;
      this._chart = null;
    }

    /**
     * Returns the overview background chart.
     * @return {Chart} Overview background chart.
     */
    getBackgroundChart() {
      return this._chart;
    }

    /**
     * @override
     */
    isBackgroundRendered() {
      return true;
    }

    /**
     * Renders filters beside the sliding window
     * @override
     */
    isLeftAndRightFilterRendered() {
      return true;
    }

    /**
     * @override
     */
    HandleKeyDown(event) {
      return; // remove keyboard behavior
    }

    /**
     * @override
     */
    HandleKeyUp(event) {
      return; // remove keyboard behavior
    }
  }

  /*---------------------------------------------------------------------*/
  /*   DvtChartPie                                                       */
  /*---------------------------------------------------------------------*/

  /*
   * Call chain:
   *
   * DvtChartPie.init gets called to create each logical DvtChartPieSlice object. Setting up the slice's size, location,
   * fill, label, label layout and the creation of the physical shapes are NOT done at this step.
   *
   * DvtChartPie.render then gets called to
   *
   * 1. create and layout the physical pie surface objects and physical labels
   * 2. order the slices for rendering
   * 3. layout the slice labels and feelers
   * 4. render the actual slices (add them to this DvtChartPie)
   * 5. render the slice labels and feelers.
   */

  /**
   * Creates an instance of DvtChartPie
   * @param {Chart} chart The chart object.
   * @param {dvt.Rectangle} availSpace The available space to render the chart.
   * @param {function} callback A function that responds to events
   * @param {object} callbackObj The optional object instance that the callback function is defined on.
   *  @class DvtChartPie
   *  @extends {dvt.Container}
   *  @constructor
   */
  class DvtChartPie extends dvt.Container {
    constructor(chart, availSpace, callback, callbackObj) {
      super(chart.getCtx());

      /** @private */
      this._THREED_TILT = DvtChartPieSlice.THREED_TILT;
      /** @private */
      this._THREED_DEPTH = 0.1;
      /** @private */
      this._RADIUS = 0.45;
      /** @private */
      this._RADIUS_LABELS = 0.38;
      /** @private */
      this._MIN_ARC_LENGTH = 1.5;

      this.chart = chart;
      this._options = chart.getOptions();
      this._frame = availSpace.clone();
      chart.pieChart = this; // store reference to itself for interactivity

      this.otherSlice = null;
      var labelPosition = this.getLabelPos();

      // Read the position from all series. Override if some label positions are inside/none and some outside.
      // Only used for figuring out the pie radius
      var numSeries = DvtChartDataUtils.getSeriesCount(chart);
      for (var seriesIndex = 0; seriesIndex < numSeries; seriesIndex++) {
        var data = DvtChartDataUtils.getDataItem(chart, seriesIndex, 0);
        if (
          data &&
          (labelPosition == 'center' || labelPosition == 'none') &&
          data['labelPosition'] == 'outsideSlice'
        )
          labelPosition = 'outsideSlice';
      }

      // Set position attributes
      this._center = new dvt.Point(
        availSpace.x + Math.floor(availSpace.w / 2),
        availSpace.y + Math.floor(availSpace.h / 2)
      );
      var radiusScale =
        labelPosition == 'center' || labelPosition == 'none' ? this._RADIUS : this._RADIUS_LABELS;
      this._radiusX = Math.floor(Math.min(availSpace.w, availSpace.h) * radiusScale);
      this._radiusY = this._radiusX;
      this._depth = 0;
      this._anchorOffset = 90;

      if (this.is3D()) {
        // Set depth as percentage of window height
        this._depth = availSpace.h * this._THREED_DEPTH;
        this._center.y -= Math.floor(this._depth / 2);
        this._radiusY *= this._THREED_TILT;
      }

      // Create slices and set initial selection
      this._slices = this._createSlices();

      // The center label text object
      this._centerLabel = null;

      // a dvt.Container where we add parts of the pie and feeler lines
      // any special filters (currently, drop shadow effect for 2D pies)
      // affecting the pie are added to this container
      this._shapesContainer = new dvt.Container(this.getCtx());

      // Support for changing z-order for selection
      this._numFrontObjs = 0;
      this._numSelectedObjsInFront = 0;
    }

    /**
     * Returns the options object of this pie chart.
     * @return {object}
     */
    getOptions() {
      return this._options;
    }

    /**
     * Highlights the specified categories.
     * @param {array} categories The array of categories whose data items will be highlighted. If null or empty, all
     *                           highlighting will be removed.
     */
    highlight(categories) {
      dvt.CategoryRolloverHandler.highlight(
        categories,
        this._slices,
        this.getOptions()['highlightMatch'] == 'any'
      );
    }

    /**
     * Create pie slices.
     * @return {array} slices
     * @private
     */
    _createSlices() {
      // Iterate through the data and create the slice objects
      var slices = [];
      var slice;

      var seriesIndices = DvtChartPieUtils.getRenderedSeriesIndices(this.chart);
      var seriesIndex;
      var otherValue = DvtChartPieUtils.getOtherVal(this.chart);

      for (var i = 0; i < seriesIndices.length; i++) {
        seriesIndex = seriesIndices[i];

        // Skip the series if it shouldn't be rendered
        if (!DvtChartDataUtils.isDataItemRendered(this.chart, seriesIndex)) continue;

        slice = new DvtChartPieSlice(this, seriesIndex);

        // Do not render if the value is not positive
        var sliceValue = slice.getVal();
        if (sliceValue == null || sliceValue <= 0) continue;

        slices.push(slice);
      }

      // Create an "Other" slice if needed
      var hiddenCategories = DvtChartDataUtils.getHiddenCategories(this.chart);
      var isOtherHidden = hiddenCategories.indexOf(DvtChartPieUtils.OTHER_ID) >= 0;
      if (otherValue > 0 && !isOtherHidden) {
        var otherSlice = new DvtChartPieSlice(this);
        if (this.chart.getOptions()['sorting'] == 'ascending') {
          slices.unshift(otherSlice);
        } else {
          slices.push(otherSlice);
        }
        // store otherSlice for easy access without having to search
        this.otherSlice = otherSlice;
      }

      // Reverse the slices for BIDI
      if (dvt.Agent.isRightToLeft(this.getCtx())) slices.reverse();

      return slices;
    }

    /**
     * Sets initial selection of the chart.
     */
    setInitialSelection() {
      var handler = this.chart.getSelectionHandler();
      if (!handler) return;

      var selected = DvtChartDataUtils.getInitialSelection(this.chart);
      var selectedIds = [];
      for (var i = 0; i < selected.length; i++) {
        for (var j = 0; j < this._slices.length; j++) {
          var peerId = this._slices[j].getId();
          if (
            peerId != null &&
            ((selected[i]['id'] != null && peerId.id == selected[i]['id']) ||
              (peerId.series == selected[i]['series'] && peerId.group == selected[i]['group']))
          ) {
            selectedIds.push(peerId);
            continue;
          }
        }
      }

      // Add other slice to the list if all series in the "other" slice is selected
      if (DvtChartPieUtils.isOtherSliceSelected(this.chart, selected)) {
        var otherPeerId = DvtChartPieUtils.getOtherSliceId(this.chart);
        selectedIds.push(otherPeerId);
      }

      handler.processInitialSelections(selectedIds, this._slices);
    }

    /**
     * Renders the pie chart.
     */
    render() {
      DvtChartEventUtils.addPlotAreaDnDBackground(this.chart, this, this._frame, true);

      if (!this.contains(this._shapesContainer)) {
        if (!this._shapesContainer) {
          this._shapesContainer = new dvt.Container(this.getCtx());
        }
        this.addChild(this._shapesContainer);
      }

      // Set each slice's angle start and angle extent
      // The order in which these slices are rendered is determined in the later call to orderSlicesForRendering
      DvtChartPie._layoutSlices(this._slices, this._anchorOffset);

      // create the physical surface objects and labels
      var pieCircumference = 2 * Math.PI * this.getRadiusX();
      var prevEndCoord = 0;
      var thinSlices = {};
      var hasLargeSeriesCount = this.chart.getOptionsCache().getFromCache('hasLargeSeriesCount');
      for (var i = 0; i < this._slices.length; i++) {
        // Skip rendering some of the thin slices for charts with large series counts
        if (hasLargeSeriesCount) {
          var angleExtent = this._slices[i].getAngleExtent();
          var sliceArc = (angleExtent / 360) * pieCircumference;
          var endCoord = ((this._slices[i].getAngleStart() + angleExtent) / 360) * pieCircumference;
          if (
            sliceArc < this._MIN_ARC_LENGTH &&
            Math.abs(prevEndCoord - endCoord) < this._MIN_ARC_LENGTH
          ) {
            thinSlices[this._slices[i].getSeriesIndex()] = true;
            continue; // skip pre render
          } else prevEndCoord = endCoord;
        }
        this._slices[i].preRender();
      }

      // we order the slices for rendering, such that
      // the "front-most" slice, the one closest to the user
      // is redered last.  each slice is then responsible
      // for properly ordering each of its surfaces before
      // the surfaces are rendered.
      var zOrderedSlices = DvtChartPie._orderSlicesForRendering(this._slices);

      if (!this._duringDisplayAnim) {
        DvtChartPieLabelUtils.createPieCenter(this);
        DvtChartPieLabelUtils.layoutLabelsAndFeelers(this);
      }

      // now that everything has been laid out, tell the slices to
      // render their surfaces
      for (var i = 0; i < zOrderedSlices.length; i++) {
        if (!thinSlices[zOrderedSlices[i].getSeriesIndex()])
          zOrderedSlices[i].render(this._duringDisplayAnim);
      }

      // perform initial selection
      this.setInitialSelection();

      // Initial Highlighting
      this.highlight(DvtChartDataUtils.getHighlightedCategories(this.chart));
    }

    /**
     * Returns the total value of the pie
     * @return {number} The total value of all pie slices
     */
    getTotalValue() {
      var total = 0;
      for (var i = 0; i < this._slices.length; i++) {
        var sliceValue = this._slices[i].getVal();
        if (sliceValue >= 0)
          // Ignore negative slice values
          total += sliceValue;
      }
      return total;
    }

    // ported over from PieChart.as
    /**
     * Sets the location of each slice in the pie. That is, each slice in the input slices array has its angle start and
     * angle extent set.  Label layout is not handled in this method.
     *
     * @param {Array} slices An array of DvtChartPieSlice objects
     * @param {number} anchorOffset The initial rotation offset for the pie, measured in degrees with 0 being the standard
     *                              0 from which trigonometric angles are measured. Thus, 90 means the first pie slice is
     *                              at the 12 o'clock position
     *
     * @private
     */
    static _layoutSlices(slices, anchorOffset) {
      var i;
      var slice;
      var angle;

      var arc = 0;

      var nSlices = slices ? slices.length : 0;

      if (anchorOffset > 360) anchorOffset -= 360;

      if (anchorOffset < 0) anchorOffset += 360;

      var percentage = 0;
      var dataTotal = 0;
      if (nSlices > 0) {
        dataTotal = slices[0].getPieChart().getTotalValue();
      }

      for (var i = 0; i < nSlices; i++) {
        slice = slices[i];

        var value = slice.getVal();

        if (value == dataTotal) percentage = 100;
        else if (dataTotal == 0) percentage = 0;
        // If the value is really large but not exactly 100%, cap allocated space to 99.99% otherwise slice path may not be rendered
        else percentage = Math.min((value / dataTotal) * 100, 99.99);

        arc = percentage * 3.6; // 3.60 = 360.0 / 100.0 - percentage of a 360 degree circle
        angle = anchorOffset - arc;

        if (angle < 0) angle += 360;

        slice.setAngleStart(angle);
        slice.setAngleExtent(arc);

        anchorOffset = slice.getAngleStart(); // update anchor position for next slice
      }
    }

    /**
     * Sort slices by walking slices in a clockwise and then counterclockwise fashion,
     * processing the bottom-most slice last.  Each slice is responsible for sorting its
     * own surfaces so that they get rendered in the proper order.
     *
     * @param {Array} slices The array of DvtChartPieSlices to order
     * @return {Array} A z-ordered array of DvtChartPieSlices
     *
     * @private
     */
    static _orderSlicesForRendering(slices) {
      var zOrderedSlices = [];
      var i;
      var nSlices = slices ? slices.length : 0;
      var slice;

      var rotateIdx = -1;
      var angleStart;
      var angleExtent;
      var sliceSpanEnd;

      // the amount of the slice, in degrees, by which the slice that spans the 12 o'clock position spans
      // counterclockwise from 12 o'clock (i.e., how much of the slice is "before noon")
      var sliceSpanBeforeNoon;

      // if we have any sort of pie rotation, then we need to rotate a copy of the _slices array
      // so that the first entry in the array is at 12 o'clock, or spans 12 o'clock position
      // to do this, we just check the angle start and angle extent of each slice. The first element in
      // the array would be that angle whose start + extent = 90 or whose start < 90 and
      // start + extent > 90.
      // find the index of the slice that spans the 12 o'clock position
      for (var i = 0; i < nSlices; i++) {
        slice = slices[i];
        angleStart = slice.getAngleStart();
        angleExtent = slice.getAngleExtent();
        sliceSpanEnd = angleStart + angleExtent;

        if (sliceSpanEnd > 360) sliceSpanEnd -= 360;

        if (sliceSpanEnd < 0) sliceSpanEnd += 360;

        if (sliceSpanEnd == 90 || (angleStart < 90 && sliceSpanEnd > 90)) {
          rotateIdx = i;
          sliceSpanBeforeNoon = sliceSpanEnd - 90;
          break;
        }
      }

      // now create an array in which the slices are ordered clockwise from the 12 o'clock position
      var rotatedSlices = [];
      for (var i = rotateIdx; i < nSlices; i++) {
        rotatedSlices.push(slices[i]);
      }
      for (var i = 0; i < rotateIdx; i++) {
        rotatedSlices.push(slices[i]);
      }

      //total accumulated angle of slice so far
      var accumAngle = 0;

      // the bottom-most slice index, whose extent either spans the two bottom
      // quadrants across the 270 degree mark (the "6 o'clock" position),
      // or is tangent to the 270 degree mark
      var lastSliceIndexToProcess = 0;

      //
      // process slices clockwise, starting at the top, series 0
      //
      var accumAngleThreshold = 180 + sliceSpanBeforeNoon;
      for (var i = 0; i < nSlices; i++) {
        slice = rotatedSlices[i];

        if (slice) {
          // if this slice makes the accumAngle exceed 180 degrees,
          // then save it for processing later because this is the
          // bottom-most slice (it crosses the 6 o'clock mark),
          // which means it should be in front in the z-order
          if (accumAngle + slice.getAngleExtent() > accumAngleThreshold) {
            lastSliceIndexToProcess = i;
            break;
          }

          // add this slice to the rendering queue for slices
          zOrderedSlices.push(slice);

          //add the current slice extent to the accumulated total
          accumAngle += slice.getAngleExtent();
        }
      }

      for (var i = nSlices - 1; i >= lastSliceIndexToProcess; i--) {
        slice = rotatedSlices[i];
        if (slice) {
          zOrderedSlices.push(slice);
        }
      }

      return zOrderedSlices;
    }

    /**
     * Returns a boolean indicating if the DvtChartPie is a 3D pie
     *
     * @return {boolean} true If the pie is to be rendered as a 3D pie
     */
    is3D() {
      return this._options['styleDefaults']['threeDEffect'] == 'on';
    }

    /**
     * Determine the maximum distance a pie slice can be exploded from the pie
     *
     * @return {number} The maximum distance a pie slice can be exploded from the pie
     */
    __calcMaxExplodeDistance() {
      var maxExplodeRatio = 0.5 / this._RADIUS - 1; //ensures that the exploded pie does not go outside the frame
      return this._radiusX * maxExplodeRatio;
    }

    /**
     * Returns the animation duration for this pie.
     * @return {number}
     */
    getAnimDuration() {
      return DvtChartStyleUtils.getAnimDur(this.chart);
    }

    /**
     * Creates initial display animation.  Called by DvtChartAnimOnDisplay.
     * @return {dvt.Playable} The display animation.
     */
    getDisplayAnim() {
      this._duringDisplayAnim = true; // flag to prevent label/feeler relayout
      var handler = new dvt.DataAnimationHandler(this.getCtx(), this);
      var duration = this.getAnimDuration();

      // Construct animation to grow the slices like a fan.
      // A filler slice is needed to fill in the empty space not occupied by the slices while growing.
      var fillerSlice = DvtChartPieSlice.createFillerSlice(this, this.getTotalValue());
      this._slices.push(fillerSlice);

      // Add animation to shrink the filler slice
      var fillerAnim = new dvt.CustomAnimation(this.getCtx(), fillerSlice, duration);
      fillerAnim
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          fillerSlice,
          fillerSlice.GetAnimParams,
          fillerSlice.SetAnimParams,
          fillerSlice.getDeletedAnimParams()
        );
      fillerAnim.setOnEnd(fillerSlice._removeDeletedSlice, fillerSlice);
      handler.add(fillerAnim, 0);

      // Add animation to grow the actual slices
      for (var i = 0; i < this._slices.length - 1; i++) {
        // don't include filler slice
        this._slices[i].animateInsert(handler);
      }

      // Construct the animation to render the pie using the updated values
      var renderAnim = new dvt.CustomAnimation(this.getCtx(), this, duration);
      renderAnim
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this._getAnimParams,
          this._setAnimParams,
          this._getAnimParams()
        );
      handler.add(renderAnim, 0);

      // Construct fade in animation for labels and feelers. Should start from the very beginning of the slices animation
      var ar = [];
      for (var i = 0; i < this._slices.length; i++) {
        ar = ar.concat(this._slices[i].getLabelAndFeeler());
      }

      var labelAnim = new dvt.AnimFadeIn(this._context, ar, duration);
      handler.add(labelAnim, 0);

      // Initialize to the start state
      this._setAnimParams();

      var anim = handler.getAnimation(true);
      anim.setOnEnd(this._onEnd, this); // restore label position
      return anim;
    }

    /**
     * Restores the label position and re-renders at the end of the display animation.
     * @private
     */
    _onEnd() {
      this._duringDisplayAnim = false;
      //  - need to re render at the end of the display animation
      this._setAnimParams();
    }

    /** Getters and setters **/

    /**
     * @return {dvt.Point} The center of this pie chart
     */
    getCenter() {
      return this._center;
    }

    /**
     * Returns an id for the chart. This is mainly for animation purposes.
     * @return {string} id for chart
     */
    getId() {
      return 'chart/pie';
    }

    /**
     * @return {number} The inner radius of this pie chart
     */
    getInnerRadius() {
      if (this.is3D())
        // not supported
        return 0;
      else
        return (
          this._options['styleDefaults']['pieInnerRadius'] *
          Math.min(this._radiusX, this._radiusY) *
          0.95
        );
    }

    /**
     * @return {dvt.Rectangle} This DvtChartPie's pie frame
     */
    __getFrame() {
      return this._frame;
    }

    /**
     * @return {number} the length of the pie chart's x-radius
     */
    getRadiusX() {
      return this._radiusX;
    }

    /**
     * @return {number} the length of the pie chart's y-radius
     */
    getRadiusY() {
      return this._radiusY;
    }

    /**
     * @return {number} The pie chart's depth
     */
    getDepth() {
      return this._depth;
    }

    /**
     * Return the top surface displayable belonging to the slice with the given seriesIdx.
     * Internal API used for Automation purposes.
     * @param {Number} seriesIdx
     * @return {dvt.Displayable}
     */
    getSliceDisplayable(seriesIdx) {
      var slice = DvtChartPieUtils.getSliceBySeriesIdx(this.chart, seriesIdx);
      if (slice) return slice.getTopDisplayable();
      return null;
    }

    /**
     * @return {dvt.Container} The dvt.Container where we add pie shapes and feeler lines to
     */
    __getShapesContainer() {
      return this._shapesContainer;
    }

    /**
     * @return {Array} An array containing the DvtChartPieSlice objects in this pie chart
     */
    __getSlices() {
      return this._slices;
    }

    //---------------------------------------------------------------------//
    // Animation Support                                                   //
    //---------------------------------------------------------------------//
    /**
     * Creates the update animation for this object.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     * @param {DvtChartPie} oldPie The old pie state to animate from.
     */
    animateUpdate(handler, oldPie) {
      // Create a new handler for the slices.  This handler is created to provide
      // access to the new chart for deleted objects, and to isolate the playables
      // for the pie animation from the other playables in the handler.
      var sliceHandler = new dvt.DataAnimationHandler(this.getCtx(), this);

      // Construct the animation to update slice values for the children
      sliceHandler.constructAnimation(oldPie.__getSlices(), this.__getSlices());
      var sliceAnim = sliceHandler.getAnimation(true);

      // Construct the animation to render the pie using the updated values
      var renderAnim = new dvt.CustomAnimation(this.getCtx(), this, this.getAnimDuration());
      renderAnim
        .getAnimator()
        .addProp(
          dvt.Animator.TYPE_NUMBER_ARRAY,
          this,
          this._getAnimParams,
          this._setAnimParams,
          this._getAnimParams()
        );

      // Combine and add to the chart handler
      var anim = new dvt.ParallelPlayable(this.getCtx(), sliceAnim, renderAnim);
      anim.setOnEnd(this._setAnimParams, this); // at the end, clear the container and render the final state

      handler.add(anim, 0);

      // Initialize to the start state
      this._setAnimParams([oldPie.getDepth(), oldPie.getRadiusY(), oldPie.getCenter().y]);
    }

    /**
     * Creates the insert animation for this object.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     */
    animateInsert(handler) {
      // This should never get called, since animation is only supported for a single pie
    }

    /**
     * Creates the delete animation for this object.
     * @param {dvt.DataAnimationHandler} handler The animation handler, which can be used to chain animations.
     * @param {dvt.Container} container The container where deletes should be moved for animation.
     */
    animateDelete(handler, container) {
      // This should never get called, since animation is only supported for a single pie
    }

    /**
     * @return {array} params
     * @private
     */
    _getAnimParams() {
      return [this._depth, this._radiusY, this._center.y];
    }

    /**
     * Called by the animation loop with a dummy parameter to force the chart to re-render.
     * @param {array} params
     * @private
     */
    _setAnimParams(params) {
      // First delete the current contents
      this.removeChildren();

      if (this._shapesContainer) this._shapesContainer.destroy();

      // Clear references to the removed displayables
      this._shapesContainer = null;

      if (params) {
        this._depth = params[0];
        this._radiusY = params[1];
        this._center.y = params[2];
      }

      // Then render the new ones
      this.render();
    }

    //---------------------------------------------------------------------//
    // End Animation Support                                               //
    //---------------------------------------------------------------------//

    //---------------------------------------------------------------------//
    // Ordering Support: ZOrderManager impl                                //
    //---------------------------------------------------------------------//
    /**
     * @override
     */
    bringToFrontOfSelection(slice) {
      var par = slice.getPieChart()._shapesContainer;
      if (par) {
        var parentChildCount = par.getNumChildren();
        if (parentChildCount - this._numFrontObjs > 1) {
          // Only change z-order for top surface
          par.removeChild(slice._topSurface[0]);
          var newIndex = parentChildCount - this._numFrontObjs - 1;
          par.addChildAt(slice._topSurface[0], newIndex);
        }
      }
    }

    /**
     * @override
     */
    pushToBackOfSelection(slice) {
      var len = this._slices.length;
      var counter = 0;
      for (var i = 0; i < len; i++) {
        if (this._slices[i].isSelected()) counter++;
      }
      this._numSelectedObjsInFront = counter;
      //move the object to the first z-index before the selected objects
      var par = slice.getPieChart()._shapesContainer;
      if (par) {
        var parentChildCount = par.getNumChildren();
        var newIndex = parentChildCount - this._numFrontObjs - 1 - this._numSelectedObjsInFront;
        if (newIndex >= 0) {
          par.removeChild(slice._topSurface[0]);
          par.addChildAt(slice._topSurface[0], newIndex);
        }
      }
    }

    /**
     * Returns the location of the labels
     * @return {string} "auto", "none", "center", or "outsideSlice"
     */
    getLabelPos() {
      return DvtChartPie.parseLabelPos(this._options['styleDefaults']['dataLabelPosition']);
    }

    /**
     * Returns the location of the labels
     * @param {number} seriesIndex  The index of the slice. If not passed in, we read the styleDefaults value
     * @return {string} "auto", "none", "center", or "outsideSlice"
     */
    getSeriesLabelPos(seriesIndex) {
      // Start out with the default label position for the pie
      var position = this.getLabelPos();

      // Check if it's overriden for this series
      var data = DvtChartDataUtils.getDataItem(this.chart, seriesIndex, 0);
      if (data && data['labelPosition']) position = data['labelPosition'];

      return DvtChartPie.parseLabelPos(position);
    }

    /**
     * Utility to standardize the position name
     * @param {string} position The position value read from the chart
     * @return {string} "auto", "none", "inside", or "outside"
     */
    static parseLabelPos(position) {
      if (position == 'center' || position == 'inside') return 'center';
      else if (position == 'outsideSlice' || position == 'outside') return 'outsideSlice';
      else if (position == 'none') return 'none';
      else return 'auto';
    }

    /**
     * Return the skin to use for rendering.
     * @return {string} skin
     */
    getSkin() {
      return this._options['skin'];
    }

    /**
     * Stores the center label text object, if one is created.
     * @param {DvtMultilineText} text The center label text object
     */
    setCenterLabel(text) {
      this._centerLabel = text;
    }

    /**
     * Returns the center label text object, if one exists.
     * @return {DvtMultilineText} text The center label text object
     */
    getCenterLabel() {
      return this._centerLabel;
    }
  }

  /**
   * Renderer for Chart.
   * @class
   */
  const DvtChartRenderer = {
    /** @const @private */
    _BUTTON_SIZE: 16,
    /** @const @private */
    _BUTTON_PADDING: 5,
    /** @const @private */
    _BUTTON_CORNER_DIST: 4,
    /** @const @private */
    _MOUSE_WHEEL_ZOOM_RATE_SLOW: 0.05,
    /** @const @private */
    _MOUSE_WHEEL_ZOOM_RATE_FAST: 0.2,

    /**
     * Renders the chart contents into the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    render: (chart, container, availSpace) => {
      DvtChartRenderer._renderBackground(chart, container, availSpace);

      if (!DvtChartDataUtils.hasInvalidData(chart)) {
        // Store min/max coords for axis label overflow
        if (!DvtChartTypeUtils.isOverview(chart)) {
          chart.getOptions()['_maxOverflowCoord'] = availSpace.x + availSpace.w;
          chart.getOptions()['_minOverflowCoord'] = availSpace.x;
        }

        // Layout and draw the contents.  Each render call will update availSpace.
        // 1. Fixed space items: Titles and title separator
        // 2. Variable size: Legend and Axes
        // 3. Remaining space: Plot Area
        DvtChartRenderer._addOuterGaps(chart, availSpace);
        var titleSpace = availSpace.clone();
        DvtChartRenderer._renderTitles(chart, container, availSpace);
        DvtChartRenderer._adjustAvailSpace(availSpace);

        DvtChartLegendRenderer.render(chart, container, availSpace);
        DvtChartRenderer._adjustAvailSpace(availSpace);

        var horizSbDim = DvtChartRenderer._prerenderHorizScrollbar(chart, container, availSpace);
        var vertSbDim = DvtChartRenderer._prerenderVertScrollbar(chart, container, availSpace);
        DvtChartRenderer._adjustAvailSpace(availSpace);
        chart.__setAxisSpace(availSpace.clone());

        DvtChartAxisRenderer.render(chart, container, availSpace);
        DvtChartRenderer._adjustAvailSpace(availSpace);
        DvtChartRenderer._positionLegend(chart.legend, availSpace);
        chart.__setPlotAreaSpace(availSpace.clone());

        DvtChartRenderer._setEventHandlers(chart);
        DvtChartRenderer._renderScrollbars(chart, horizSbDim, vertSbDim);

        DvtChartRenderer._updateTitles(chart, container, titleSpace, availSpace); // reposition title and/or footnote if aligned to plot area
        DvtChartRenderer._renderPlotArea(chart, container, availSpace);
        DvtChartRenderer._renderDragButtons(chart);
      } // Render the empty text
      else DvtChartTextUtils.renderEmptyText(chart, container, availSpace);
    },

    /**
     * Sets the marquee and pan/zoom event handlers.
     * @param {Chart} chart
     * @private
     */
    _setEventHandlers: (chart) => {
      var options = chart.getOptions();
      var em = chart.getEventManager();

      if (!DvtChartTypeUtils.hasAxes(chart) || DvtChartTypeUtils.isOverview(chart)) return;

      var chartBounds = new dvt.Rectangle(0, 0, chart.getWidth(), chart.getHeight());
      var plotAreaBounds = chart.__getPlotAreaSpace();
      var axisBounds = chart.__getAxisSpace();
      var horizAxisBounds = new dvt.Rectangle(
        plotAreaBounds.x,
        axisBounds.y,
        plotAreaBounds.w,
        axisBounds.h
      );
      var vertAxisBounds = new dvt.Rectangle(
        axisBounds.x,
        plotAreaBounds.y,
        axisBounds.w,
        plotAreaBounds.h
      );

      var marqueeFill = new dvt.SolidFill(options['styleDefaults']['marqueeColor']);
      var marqueeStroke = new dvt.Stroke(options['styleDefaults']['marqueeBorderColor']);

      var marqueeHandler, panZoomHandler;

      if (DvtChartBehaviorUtils.isScrollable(chart)) {
        // Pan/Zoom
        var zoomRate = DvtChartBehaviorUtils.isDelayedScroll(chart)
          ? DvtChartRenderer._MOUSE_WHEEL_ZOOM_RATE_FAST
          : DvtChartRenderer._MOUSE_WHEEL_ZOOM_RATE_SLOW;
        panZoomHandler = new dvt.PanZoomHandler(chart, plotAreaBounds, chartBounds, zoomRate);
        em.setPanZoomHandler(panZoomHandler);

        if (DvtChartBehaviorUtils.isZoomable(chart)) {
          var direction = DvtChartBehaviorUtils.getZoomDir(chart);
          // Marquee Zoom
          if (DvtChartTypeUtils.isHorizontal(chart) || direction == 'y')
            marqueeHandler = new dvt.MarqueeHandler(
              chart,
              plotAreaBounds,
              chartBounds,
              marqueeFill,
              marqueeStroke,
              false,
              true,
              null,
              vertAxisBounds
            );
          else if (DvtChartTypeUtils.isBLAC(chart) || direction == 'x')
            marqueeHandler = new dvt.MarqueeHandler(
              chart,
              plotAreaBounds,
              chartBounds,
              marqueeFill,
              marqueeStroke,
              true,
              false,
              horizAxisBounds,
              null
            );
          else
            marqueeHandler = new dvt.MarqueeHandler(
              chart,
              plotAreaBounds,
              chartBounds,
              marqueeFill,
              marqueeStroke,
              true,
              true,
              horizAxisBounds,
              vertAxisBounds
            );
          em.setMarqueeZoomHandler(marqueeHandler);
        }
      }

      if (options['selectionMode'] == 'multiple') {
        // Marquee Select
        marqueeHandler = new dvt.MarqueeHandler(
          chart,
          plotAreaBounds,
          chartBounds,
          marqueeFill,
          marqueeStroke,
          true,
          true,
          horizAxisBounds,
          vertAxisBounds
        );
        em.setMarqueeSelectHandler(marqueeHandler);
      }
    },

    /**
     * Cleans up and rerenders the axis and the plot area.
     * @param {Chart} chart
     * @param {dvt.Container} container The container to render into.
     */
    rerenderAxisAndPlotArea: (chart, container) => {
      if (DvtChartDataUtils.hasInvalidData(chart)) return;

      var availSpace = chart.__getAxisSpace().clone();

      // Save focus and selection and clean up
      var selectionHandler = chart.getSelectionHandler();
      if (selectionHandler) var selectedIds = selectionHandler.getSelectedIds();
      var focusState = chart.__cacheChartFocus();
      chart.__cleanUpAxisAndPlotArea();

      DvtChartAxisRenderer.render(chart, container, availSpace);
      DvtChartRenderer._adjustAvailSpace(availSpace);

      chart.__setPlotAreaSpace(availSpace.clone());
      DvtChartRenderer._renderPlotArea(chart, container, availSpace);

      // Reapply selection
      if (selectionHandler)
        selectionHandler.processInitialSelections(selectedIds, chart.getChartObjPeers());

      chart.getEventManager().autoToggleZoomButton();
      DvtChartRenderer.positionDragButtons(chart); //reposition because the plot area dims may have changed

      // Restore focus and reapply highlight
      chart.highlight(DvtChartDataUtils.getHighlightedCategories(chart));
      chart.__restoreChartFocus(focusState);
      chart.__resolveDataLabelPosition();
    },

    /**
     * Renders the chart background.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderBackground: (chart, container, availSpace) => {
      // Chart background: Apply invisible background for interaction support
      var rect = new dvt.Rect(chart.getCtx(), availSpace.x, availSpace.y, availSpace.w, availSpace.h);
      rect.setInvisibleFill();
      container.addChild(rect);
    },

    /**
     * Adds paddings to the chart.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _addOuterGaps: (chart, availSpace) => {
      var options = chart.getOptions();
      var gapWidth = DvtChartDefaults.getGapWidth(chart, options['layout']['outerGapWidth']);
      var gapHeight = DvtChartDefaults.getGapHeight(chart, options['layout']['outerGapHeight']);

      if (!DvtChartRenderer._needsOuterGaps(chart)) {
        // Set the padding to at most 1px.
        gapWidth = Math.min(gapWidth, 1);
        gapHeight = Math.min(gapHeight, 1);
      }

      availSpace.x += gapWidth;
      availSpace.w -= 2 * gapWidth;
      availSpace.y += gapHeight;
      availSpace.h -= 2 * gapHeight;
    },

    /**
     * Checks if outer gap is needed for the chart
     * @param {Chart} chart The instance of the chart
     * @return {boolean} true, if it is needed to add outer gaps
     */
    _needsOuterGaps: (chart) => {
      var options = chart.getOptions();
      // For funnel 3d chart, outer gap is needed, since
      // the 3d effect overflows on the top and bottom
      if (DvtChartTypeUtils.isFunnel(chart) && options['styleDefaults']['threeDEffect'] === 'on') {
        return true;
      }

      // No need for outer gap it is a standalone chart object
      if (
        DvtChartAxisUtils.isStandalonePlotArea(chart) ||
        DvtChartAxisUtils.isStandaloneXAxis(chart) ||
        DvtChartAxisUtils.isStandaloneYAxis(chart) ||
        DvtChartAxisUtils.isStandaloneY2Axis(chart)
      ) {
        return false;
      }

      return true;
    },

    /**
     * Renders the chart titles and updates the available space.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderTitles: (chart, container, availSpace) => {
      var options = chart.getOptions();

      // Title
      if (options['title']['text']) {
        var titleObj = DvtChartTextUtils.createText(
          chart.getEventManager(),
          container,
          options['title']['text'],
          options['title']['style'],
          availSpace.x,
          availSpace.y,
          availSpace.w,
          availSpace.h
        );

        var titleHeight;
        var titleDims;
        var titleAlign =
          options['title']['hAlign'] != null
            ? options['title']['hAlign']
            : options['title']['halign'];
        var alignTitlesToPlotArea = titleAlign.substring(0, 8) == 'plotArea';
        if (titleObj) {
          // Calc the dimensions to figure out remaining space
          titleDims = titleObj.getDimensions();
          titleHeight = titleDims.h;

          // WAI-ARIA
          titleObj.setAriaProperty('hidden', null);
        } else {
          titleHeight = 0;
          titleDims = new dvt.Rectangle(0, 0, 0, 0);
        }

        // Subtitle
        if (options['subtitle']['text']) {
          var subtitleObj = new dvt.OutputText(
            chart.getCtx(),
            options['subtitle']['text'],
            availSpace.x,
            availSpace.y
          );
          subtitleObj.setCSSStyle(options['subtitle']['style']);
          container.addChild(subtitleObj);
          var subtitleDims = subtitleObj.getDimensions();

          // Put subtitle on next next line if it does not fit on same line as title, or if titles will be aligned to plot area
          var titleSubtitleGap = DvtChartDefaults.getGapWidth(
            chart,
            options['layout']['titleSubtitleGapWidth']
          );
          var titleSpace = titleDims.w + titleSubtitleGap + subtitleDims.w;
          if (titleSpace > availSpace.w || alignTitlesToPlotArea) {
            titleSubtitleGap = DvtChartDefaults.getGapHeight(
              chart,
              options['layout']['titleSubtitleGapHeight']
            );
            subtitleObj.setY(availSpace.y + titleHeight + titleSubtitleGap);

            if (dvt.TextUtils.fitText(subtitleObj, availSpace.w, availSpace.h, container)) {
              subtitleDims = subtitleObj.getDimensions();
              titleHeight += subtitleDims.h + titleSubtitleGap;
              if (dvt.Agent.isRightToLeft(chart.getCtx())) {
                if (subtitleObj) subtitleObj.setX(availSpace.w - subtitleDims.w);
                if (titleObj) titleObj.setX(availSpace.w - titleDims.w);
              }
            }
          } else {
            var alignTextBottomsDiff = titleDims.h - subtitleDims.h;
            subtitleObj.setY(alignTextBottomsDiff + availSpace.y);
            if (titleObj) {
              dvt.LayoutUtils.align(availSpace, titleAlign, titleObj, titleSpace);
              // Adjust the positions based on locale
              if (dvt.Agent.isRightToLeft(chart.getCtx())) {
                subtitleObj.setX(titleObj.getX());
                titleObj.setX(titleObj.getX() + subtitleDims.w + titleSubtitleGap);
              } else {
                subtitleObj.setX(titleObj.getX() + titleSpace - subtitleDims.w);
              }
            }

            // WAI-ARIA
            subtitleObj.setAriaProperty('hidden', null);

            // Associate with logical object to support truncation
            chart
              .getEventManager()
              .associate(subtitleObj, new dvt.SimpleObjPeer(subtitleObj.getUntruncatedTextString()));
          }
        } else {
          dvt.LayoutUtils.align(availSpace, titleAlign, titleObj, titleDims.w);
        }

        // Put to cache for use when repositioning to plot area
        if (alignTitlesToPlotArea) {
          chart.getCache().putToCache('title', titleObj);
          chart.getCache().putToCache('subtitle', subtitleObj);
        }

        // Update available space
        var titleGapBelow =
          options['titleSeparator']['rendered'] == 'on'
            ? options['layout']['titleSeparatorGap']
            : options['layout']['titlePlotAreaGap'];
        availSpace.y += titleHeight + DvtChartDefaults.getGapHeight(chart, titleGapBelow);
        availSpace.h -= titleHeight + DvtChartDefaults.getGapHeight(chart, titleGapBelow);

        // Title Separator
        if (options['titleSeparator']['rendered'] == 'on') {
          var upperSepObj = new dvt.Line(
            chart.getCtx(),
            availSpace.x,
            availSpace.y,
            availSpace.x + availSpace.w,
            availSpace.y
          );
          var lowerSepObj = new dvt.Line(
            chart.getCtx(),
            availSpace.x,
            availSpace.y + 1,
            availSpace.x + availSpace.w,
            availSpace.y + 1
          );
          upperSepObj.setSolidStroke(options['titleSeparator']['upperColor']);
          lowerSepObj.setSolidStroke(options['titleSeparator']['lowerColor']);
          container.addChild(upperSepObj);
          container.addChild(lowerSepObj);

          // Remove the title separator and gap height from available space
          var titleSepHeight =
            2 + DvtChartDefaults.getGapHeight(chart, options['layout']['titlePlotAreaGap']);
          availSpace.y += titleSepHeight;
          availSpace.h -= titleSepHeight;
        }
      }

      // Footnote
      if (options['footnote']['text']) {
        var footnoteObj = DvtChartTextUtils.createText(
          chart.getEventManager(),
          container,
          options['footnote']['text'],
          options['footnote']['style'],
          availSpace.x,
          0,
          availSpace.w,
          availSpace.h
        );

        var footnoteAlign =
          options['footnote']['hAlign'] != null
            ? options['footnote']['hAlign']
            : options['footnote']['halign'];
        var alignFootnoteToPlotArea = footnoteAlign.substring(0, 8) == 'plotArea';

        if (footnoteObj) {
          // Get height and reposition at correct location
          var footnoteDims = footnoteObj.getDimensions();
          footnoteObj.setY(availSpace.y + availSpace.h - footnoteDims.h);
          availSpace.h -=
            footnoteDims.h + DvtChartDefaults.getGapHeight(chart, options['layout']['footnoteGap']);
          dvt.LayoutUtils.align(availSpace, footnoteAlign, footnoteObj, footnoteDims.w);

          // WAI-ARIA
          footnoteObj.setAriaProperty('hidden', null);
        }

        // Put to cache for use when repositioning to plot area
        if (alignFootnoteToPlotArea) chart.getCache().putToCache('footnote', footnoteObj);
      }
    },

    /**
     * Repositions the chart titles and/or footnote if they are aligned to the plot area.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} titleSpace The space that was available for the titles when initially rendered.
     * @param {dvt.Rectangle} availSpace The current available space.
     * @private
     */
    _updateTitles: (chart, container, titleSpace, availSpace) => {
      var options = chart.getOptions();

      var titleAlign =
        options['title']['hAlign'] != null ? options['title']['hAlign'] : options['title']['halign'];
      var footnoteAlign =
        options['footnote']['hAlign'] != null
          ? options['footnote']['hAlign']
          : options['footnote']['halign'];

      var updateTitle = options['title']['text'] && titleAlign.substring(0, 8) == 'plotArea';
      var updateFootnote = options['footnote']['text'] && footnoteAlign.substring(0, 8) == 'plotArea';

      // Update the space available for the titles
      titleSpace.x = availSpace.x;
      titleSpace.w = availSpace.w;

      // Reposition title and subtitle
      if (updateTitle) {
        var titleObj = chart.getCache().getFromCache('title');
        var subtitleObj = chart.getCache().getFromCache('subtitle');
        var titleDims = titleObj.getDimensions();
        var subtitleDims;

        DvtChartRenderer._alignTextToPlotArea(
          container,
          titleSpace,
          titleAlign,
          titleObj,
          titleDims.w
        );
        if (subtitleObj) {
          subtitleDims = subtitleObj.getDimensions();
          DvtChartRenderer._alignTextToPlotArea(
            container,
            titleSpace,
            titleAlign,
            subtitleObj,
            subtitleDims.w
          );
        }
      }

      // Reposition footnote
      if (updateFootnote) {
        var footnoteObj = chart.getCache().getFromCache('footnote');
        var footnoteDims = footnoteObj.getDimensions();

        DvtChartRenderer._alignTextToPlotArea(
          container,
          titleSpace,
          footnoteAlign,
          footnoteObj,
          footnoteDims.w
        );
      }
    },

    /**
     * Realigns the given text object to the plot area space
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The current available space for the plot area.
     * @param {String} halign The alignment of the text.
     * @param {dvt.OutputText} text The text object to be aligned.
     * @param {Number} width The width of the text object.
     * @private
     */
    _alignTextToPlotArea: (container, availSpace, halign, text, width) => {
      if (dvt.TextUtils.fitText(text, availSpace.w, availSpace.h, container)) {
        if (halign == 'plotAreaStart') dvt.LayoutUtils.align(availSpace, 'start', text, width);
        else if (halign == 'plotAreaCenter') dvt.LayoutUtils.align(availSpace, 'center', text, width);
        else if (halign == 'plotAreaEnd') dvt.LayoutUtils.align(availSpace, 'end', text, width);
      }
    },

    /**
     * Renders plot area.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _renderPlotArea: (chart, container, availSpace) => {
      if (DvtChartTypeUtils.hasAxes(chart)) {
        // Create a container for the plot area contents
        var plotArea = new dvt.Container(chart.getCtx());
        plotArea.setTranslate(availSpace.x, availSpace.y);
        // Add plotArea at index 1, so axes and legends render on top of it
        container.addChildAt(plotArea, 1);
        chart.setPlotArea(plotArea);

        // Associate plot area with logical object to support automation
        chart
          .getEventManager()
          .associate(plotArea, new dvt.SimpleObjPeer(null, null, null, { type: 'plotArea' }));

        // Render the plot area contents
        var plotAreaBounds = new dvt.Rectangle(0, 0, availSpace.w, availSpace.h);
        DvtChartPlotAreaRenderer.render(chart, plotArea, plotAreaBounds);
      } else if (DvtChartTypeUtils.isPie(chart)) {
        var pieChart = new DvtChartPie(chart, availSpace);
        if (pieChart.__getSlices().length > 0) {
          container.addChild(pieChart);
          chart.setPlotArea(pieChart);
          pieChart.render();
        } else DvtChartTextUtils.renderEmptyText(chart, container, availSpace);
      } else if (DvtChartTypeUtils.isFunnel(chart)) {
        DvtChartFunnelRenderer.render(chart, container, availSpace);
      } else if (DvtChartTypeUtils.isPyramid(chart)) {
        DvtChartPyramidRenderer.render(chart, container, availSpace);
      }

      // All space is now used
      availSpace.w = 0;
      availSpace.h = 0;
    },

    /**
     * Prepares the horizontal scrollbar for rendering.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {dvt.Dimension} The dimension of the scrollbar.
     * @private
     */
    _prerenderHorizScrollbar: (chart, container, availSpace) => {
      var width = availSpace.w;
      var height = 0;
      if (
        DvtChartBehaviorUtils.isScrollable(chart) &&
        DvtChartBehaviorUtils.isHorizScrollbarSupported(chart)
      ) {
        // Overview scrollbar
        if (DvtChartStyleUtils.isOverviewRendered(chart)) {
          height = Math.min(DvtChartStyleUtils.getOverviewHeight(chart), availSpace.h);
          if (height > 0) {
            chart.overview = new DvtChartOverview(chart);
            container.addChild(chart.overview);
            dvt.LayoutUtils.position(availSpace, 'bottom', chart.overview, width, height, 10); // TODO : store as default
          }
        }

        // Simple scrollbar
        else {
          height = chart.getOptions()['styleDefaults']['_scrollbarHeight'];
          chart.xScrollbar = new dvt.SimpleScrollbar(chart.getCtx(), chart.processEvent, chart);
          container.addChild(chart.xScrollbar);
          dvt.LayoutUtils.position(availSpace, 'bottom', chart.xScrollbar, width, height, 8);
          chart.overview = null; // clean up overview if existed from previous render
        }
      } else chart.overview = null; // clean up overview if existed from previous render

      return new dvt.Dimension(width, height);
    },

    /**
     * Prepares the vertical scrollbar for rendering.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     * @return {dvt.Dimension} The dimension of the scrollbar.
     * @private
     */
    _prerenderVertScrollbar: (chart, container, availSpace) => {
      var width = 0;
      var height = availSpace.h;
      if (
        DvtChartBehaviorUtils.isScrollable(chart) &&
        DvtChartBehaviorUtils.isVertScrollbarSupported(chart)
      ) {
        width = chart.getOptions()['styleDefaults']['_scrollbarHeight'];
        var scrollbar = new dvt.SimpleScrollbar(chart.getCtx(), chart.processEvent, chart);
        container.addChild(scrollbar);
        dvt.LayoutUtils.position(
          availSpace,
          dvt.Agent.isRightToLeft(chart.getCtx()) ? 'right' : 'left',
          scrollbar,
          width,
          height,
          8
        );

        // Assign scrollbar to x- or y-axis depending on chart type
        if (DvtChartTypeUtils.isHorizontal(chart)) chart.xScrollbar = scrollbar;
        else chart.yScrollbar = scrollbar;
      }

      return new dvt.Dimension(width, height);
    },

    /**
     * Renders the scrollbars.
     * @param {Chart} chart The chart being rendered.
     * @param {dvt.Dimension} horizScrollbarDim The dimension of the horizontal scrollbar.
     * @param {dvt.Dimension} vertScrollbarDim The dimension of the vertical scrollbar.
     * @private
     */
    _renderScrollbars: (chart, horizScrollbarDim, vertScrollbarDim) => {
      var options = chart.getOptions();
      var sbOptions = {
        color: options['styleDefaults']['_scrollbarHandleColor'],
        backgroundColor: options['styleDefaults']['_scrollbarTrackColor']
      };
      var plotAreaDim = chart.__getPlotAreaSpace();

      // Render x-axis simple scrollbar
      if (chart.xScrollbar) {
        sbOptions['min'] = chart.xAxis.getLinearGlobalMin();
        sbOptions['max'] = chart.xAxis.getLinearGlobalMax();
        // Vertical x-axis scrollbar
        if (DvtChartTypeUtils.isHorizontal(chart)) {
          sbOptions['isHorizontal'] = false;
          sbOptions['isReversed'] = false;
          chart.xScrollbar.setTranslateY(plotAreaDim.y);
          chart.xScrollbar.render(sbOptions, vertScrollbarDim.w, plotAreaDim.h);
        }
        // Horizontal x-axis scrollbar
        else {
          sbOptions['isHorizontal'] = true;
          sbOptions['isReversed'] = dvt.Agent.isRightToLeft(chart.getCtx());
          chart.xScrollbar.setTranslateX(plotAreaDim.x);
          chart.xScrollbar.render(sbOptions, plotAreaDim.w, horizScrollbarDim.h);
        }
        chart.xScrollbar.setViewportRange(
          chart.xAxis.getLinearViewportMin(),
          chart.xAxis.getLinearViewportMax()
        );
      }

      // Render y-axis simple scrollbar
      if (chart.yScrollbar) {
        sbOptions['min'] = chart.yAxis.getLinearGlobalMin();
        sbOptions['max'] = chart.yAxis.getLinearGlobalMax();
        sbOptions['isHorizontal'] = false;
        sbOptions['isReversed'] = true;
        chart.yScrollbar.setTranslateY(plotAreaDim.y);
        chart.yScrollbar.render(sbOptions, vertScrollbarDim.w, plotAreaDim.h);
        chart.yScrollbar.setViewportRange(
          chart.yAxis.getLinearViewportMin(),
          chart.yAxis.getLinearViewportMax()
        );
      }

      // Render x-axis overview scrollbar
      if (chart.overview) {
        var noCloneOptions = chart.Defaults.getNoCloneObject();
        var ovOptions = {
          overview: {
            xMin: chart.xAxis.getLinearGlobalMin(),
            xMax: chart.xAxis.getLinearGlobalMax(),
            x1: chart.xAxis.getLinearViewportMin(),
            x2: chart.xAxis.getLinearViewportMax(),
            minimumWindowSize: chart.xAxis.getInfo().getMinExtent()
          },
          chart: dvt.JsonUtils.clone(options, null, noCloneOptions)
        };

        if (!DvtChartBehaviorUtils.isZoomable(chart)) ovOptions['featuresOff'] = 'zoom';

        // Update min/max coords for axis label overflow
        ovOptions['chart']['_minOverflowCoord'] = options['_minOverflowCoord'] - plotAreaDim.x;
        ovOptions['chart']['_maxOverflowCoord'] = options['_maxOverflowCoord'] - plotAreaDim.x;
        chart.overview.setTranslateX(plotAreaDim.x);
        chart.overview.render(ovOptions, plotAreaDim.w, horizScrollbarDim.h);
        chart.overview.setViewportRange(
          chart.xAxis.getLinearViewportMin(),
          chart.xAxis.getLinearViewportMax()
        );
      }
    },

    /**
     * Centers the legend within the availSpace.
     * @param {Legend.Legend} legend
     * @param {dvt.Rectangle} availSpace
     * @private
     */
    _positionLegend: (legend, availSpace) => {
      if (!legend) return;

      var dims = legend.getDimensions();
      var orientation = legend.getOptions()['orientation'];
      if (orientation == 'vertical' && dims.h <= availSpace.h)
        legend.setTranslateY(Math.round(availSpace.y + availSpace.h / 2 - dims.h / 2));
      else if (orientation == 'horizontal' && dims.w <= availSpace.w)
        legend.setTranslateX(Math.round(availSpace.x + availSpace.w / 2 - dims.w / 2));
    },

    /**
     * Renders the drag buttons.
     * @param {Chart} chart
     * @private
     */
    _renderDragButtons: (chart) => {
      var minSize =
        DvtChartRenderer._BUTTON_SIZE +
        2 * (DvtChartRenderer._BUTTON_PADDING + DvtChartRenderer._BUTTON_CORNER_DIST);
      var plotAreaSpace = chart.__getPlotAreaSpace();
      if (
        !DvtChartTypeUtils.hasAxes(chart) ||
        DvtChartTypeUtils.isOverview(chart) ||
        plotAreaSpace.w < minSize ||
        plotAreaSpace.h < minSize
      )
        return;

      var options = chart.getOptions();
      var resources = options['_resources'];
      var translations = options.translations;
      var em = chart.getEventManager();
      var dragMode = options['dragMode'];

      // If drag mode is specified by app, simply set the drag mode and don't draw the buttons
      if (dragMode != 'user') {
        if (dragMode == 'pan') em.setDragMode(DvtChartEventManager.DRAG_MODE_PAN);
        else if (dragMode == 'zoom') em.setDragMode(DvtChartEventManager.DRAG_MODE_ZOOM);
        else if (dragMode == 'select') em.setDragMode(DvtChartEventManager.DRAG_MODE_SELECT);
        else em.setDragMode(DvtChartEventManager.DRAG_MODE_OFF);
        return;
      }

      var isTouch = dvt.Agent.isTouchDevice();
      var isScrollable = DvtChartBehaviorUtils.isScrollable(chart);

      chart.dragButtons = new dvt.Container(chart.getCtx());

      var tooltip, position, iconStyles;
      var classNamesList = [];
      var hasSelectButton = options['selectionMode'] == 'multiple' && (isTouch || isScrollable);
      var hasPanButton = isScrollable && isTouch;
      var hasZoomButton =
        isScrollable &&
        !isTouch &&
        DvtChartBehaviorUtils.isZoomable(chart) &&
        DvtChartTypeUtils.isScatterBubble(chart);

      // Compute the list of required class names for the drag buttons
      if (hasSelectButton) {
        resources['select'] && classNamesList.push(resources['select']);
      }

      if (hasPanButton) {
        resources['pan'] && classNamesList.push(resources['pan']);
      }

      if (hasZoomButton) {
        resources['zoom'] && classNamesList.push(resources['zoom']);
      }

      // Compute the icon styles using the classlist
      iconStyles = dvt.ToolkitUtils.getIconStyles(chart.getCtx(), classNamesList);

      // Create the required drag buttons
      if (hasSelectButton) {
        position = hasPanButton || hasZoomButton ? 'end' : 'solo';
        em.selectButton = DvtChartRenderer._createDragButton(
          chart,
          chart.dragButtons,
          iconStyles[resources['select']],
          em.onSelectButtonClick,
          em,
          position
        );
        tooltip = translations.tooltipSelect;
        em.selectButton.setTooltip(tooltip);
        em.associate(em.selectButton, em.selectButton);
      }

      if (hasPanButton) {
        position = hasSelectButton ? 'start' : 'solo';
        em.panButton = DvtChartRenderer._createDragButton(
          chart,
          chart.dragButtons,
          iconStyles[resources['pan']],
          em.onPanButtonClick,
          em,
          position
        );
        tooltip = translations.tooltipPan;
        em.panButton.setTooltip(tooltip);
        em.associate(em.panButton, em.panButton);
      }

      if (hasZoomButton) {
        position = hasSelectButton ? 'start' : 'solo';
        em.zoomButton = DvtChartRenderer._createDragButton(
          chart,
          chart.dragButtons,
          iconStyles[resources['zoom']],
          em.onZoomButtonClick,
          em,
          position
        );
        tooltip = translations.tooltipZoom;
        em.zoomButton.setTooltip(tooltip);
        em.associate(em.zoomButton, em.zoomButton);
      }

      DvtChartRenderer.positionDragButtons(chart);
      em.setDragMode(null); // set the default drag mode

      if (chart.dragButtons.getNumChildren() > 0) {
        chart.addChild(chart.dragButtons);

        if (isTouch) {
          if (isScrollable) {
            // Set initial mode to pan
            em.panButton.setToggled(true);
            em.onPanButtonClick(null);
          }
        } else {
          // Buttons are not shown initially on desktop.
          chart.hideDragButtons();
        }

        // Override the chart cursor.
        chart.dragButtons.setCursor('default');
      }
    },

    /**
     * Positions the drag button
     * @param {Chart} chart
     * @param {dvt.IconButton} button
     * @param {dvt.Rectangle} availSpace
     * @private
     */
    _positionDragButton: (chart, button, availSpace) => {
      var transX;
      if (dvt.Agent.isRightToLeft(chart.getCtx())) {
        transX = availSpace.x + DvtChartRenderer._BUTTON_PADDING;
        availSpace.x += DvtChartRenderer._BUTTON_SIZE + 2 * DvtChartRenderer._BUTTON_PADDING;
      } else
        transX =
          availSpace.x +
          availSpace.w -
          DvtChartRenderer._BUTTON_SIZE -
          DvtChartRenderer._BUTTON_PADDING;

      availSpace.w -= DvtChartRenderer._BUTTON_SIZE + 2 * DvtChartRenderer._BUTTON_PADDING;
      button.setTranslate(transX, availSpace.y + DvtChartRenderer._BUTTON_PADDING);
    },

    /**
     * Positions the drag buttons at the top left/right corner of the plot area.
     * @param {Chart} chart
     */
    positionDragButtons: (chart) => {
      var availSpace = chart.__getPlotAreaSpace().clone();
      availSpace.x += DvtChartRenderer._BUTTON_CORNER_DIST;
      availSpace.w -= 2 * DvtChartRenderer._BUTTON_CORNER_DIST;
      availSpace.y += DvtChartRenderer._BUTTON_CORNER_DIST;

      var em = chart.getEventManager();
      if (em.selectButton) DvtChartRenderer._positionDragButton(chart, em.selectButton, availSpace);
      if (em.panButton) DvtChartRenderer._positionDragButton(chart, em.panButton, availSpace);
      if (em.zoomButton) DvtChartRenderer._positionDragButton(chart, em.zoomButton, availSpace);
    },

    /**
     * Creates the rounded square background for the drag button.
     * @param {dvt.Context} context
     * @param {string} position The position of the button: start, end, or solo.
     * @return {dvt.Rect} The button background.
     * @private
     */
    _createDragButtonBackground: (context, position) => {
      var isR2L = dvt.Agent.isRightToLeft(context);
      var blcr = (position == 'start' && isR2L) || (position == 'end' && !isR2L) ? 0 : 2;
      var trcr = (position == 'start' && !isR2L) || (position == 'end' && isR2L) ? 0 : 2;
      var tlcr = blcr;
      var brcr = trcr;

      var pos = -DvtChartRenderer._BUTTON_PADDING;
      var size = DvtChartRenderer._BUTTON_SIZE + DvtChartRenderer._BUTTON_PADDING * 2;
      var cmd = dvt.PathUtils.roundedRectangle(pos, pos, size, size, tlcr, trcr, brcr, blcr);

      var background = new dvt.Path(context, cmd);

      // don't use pixel hinting on desktop bc the corners look broken
      background.setPixelHinting(dvt.Agent.getDevicePixelRatio() > 1);
      return background;
    },

    /**
     * Computes the image url using the imageUrlMapping cache and chart resources
     * @param {Chart} chart the chart instance\
     * @param {object} imageUrlMapping object that maps image source string to url
     * @param {string} resourceKey the key for the image source in the resources map
     * @param {string=} fallbackUrl the optional fallback url
     * @return {string|null} the image url if available in the cache, or the fallbackUrl
     *                       if provided and null if neither of them is avilable.
     */
    _getImageUrl: (chart, imageUrlMapping, resourceKey, fallbackUrl) => {
      var resources = chart.getOptions()['_resources'];
      var imageSource = resources[resourceKey];
      var url;

      // if image source is not available, return the fallback url
      if (imageSource == null) {
        return fallbackUrl;
      }

      // if image url exists in the cache and return the url
      url = imageUrlMapping[imageSource];
      if (url != null) {
        return url;
      }

      // return the image source if the url is not available in the cache
      return imageSource;
    },

    /**
     * Creates and a drag button.
     * @param {Chart} chart
     * @param {dvt.Container} container The container for the button.
     * @param {object} iconStyle The icon style information
     * @param {object} callback The callback method of the button.
     * @param {object} callbackObj The object of the callback method.
     * @param {string} position The position of the button: start, end, or solo.
     * @return {dvt.IconButton}
     * @private
     */
    _createDragButton: (chart, container, iconStyle, callback, callbackObj, position) => {
      // Create the button and add to the container
      var context = chart.getCtx();

      // background
      var background = DvtChartRenderer._createDragButtonBackground(context, position);

      var button = new dvt.IconButton(
        context,
        'outlined',
        { style: iconStyle, size: DvtChartRenderer._BUTTON_SIZE },
        background,
        null,
        callback,
        callbackObj
      );

      // Add hit area to the button for touch devices
      if (dvt.Agent.isTouchDevice()) {
        var isR2L = dvt.Agent.isRightToLeft(context);
        var hitPadding = DvtChartRenderer._BUTTON_PADDING * 2;

        var hitArea;
        if (position == 'solo')
          hitArea = new dvt.Rect(
            context,
            -hitPadding,
            -hitPadding,
            DvtChartRenderer._BUTTON_SIZE + 2 * hitPadding,
            DvtChartRenderer._BUTTON_SIZE + 2 * hitPadding
          );
        else if ((position == 'start' && !isR2L) || (position == 'end' && isR2L))
          // left button
          hitArea = new dvt.Rect(
            context,
            -hitPadding,
            -hitPadding,
            DvtChartRenderer._BUTTON_SIZE + 1.5 * hitPadding,
            DvtChartRenderer._BUTTON_SIZE + 2 * hitPadding
          );
        // right button
        else
          hitArea = new dvt.Rect(
            context,
            -0.5 * hitPadding,
            -hitPadding,
            DvtChartRenderer._BUTTON_SIZE + 1.5 * hitPadding,
            DvtChartRenderer._BUTTON_SIZE + 2 * hitPadding
          );

        hitArea.setInvisibleFill();
        hitArea.setSolidStroke('none');
        button.addChild(hitArea);
      }

      button.setToggleEnabled(true);
      container.addChild(button);

      // Button should consume mousedown event so that drag is not initiated
      button.addEvtListener(dvt.MouseEvent.MOUSEDOWN, (event) => {
        event.stopPropagation();
      });

      return button;
    },

    /**
     * Helper function that adjusts the input rectangle to the closest pixel.
     * @param {dvt.Rectangle} availSpace The available space.
     * @private
     */
    _adjustAvailSpace: (availSpace) => {
      // : Adjust the bounds to the closest pixel to prevent antialiasing issues.
      availSpace.x = Math.round(availSpace.x);
      availSpace.y = Math.round(availSpace.y);
      availSpace.w = Math.round(availSpace.w);
      availSpace.h = Math.round(availSpace.h);
    },

    /**
     * Renders the chart data cursor.
     * @param {Chart} chart
     * @return {DvtChartDataCursor}
     */
    renderDataCursor: (chart) => {
      var dataCursor = null;
      var options = chart.getOptions();
      var eventManager = chart.getEventManager();

      if (DvtChartTooltipUtils.isDataCursorEnabled(chart)) {
        dataCursor = new DvtChartDataCursor(
          chart.getCtx(),
          options['styleDefaults']['dataCursor'],
          DvtChartTypeUtils.isHorizontal(chart)
        );
        dataCursor.setBehavior(DvtChartTooltipUtils.getDataCursorBehavior(chart));
        chart.addChild(dataCursor);

        var dataCursorHandler = new DvtChartDataCursorHandler(chart, dataCursor);
        eventManager.setDataCursorHandler(dataCursorHandler);

        // Initially display the data cursor based on the options
        chart.positionDataCursor(options['dataCursorPosition']);
      } else eventManager.setDataCursorHandler(null);

      return dataCursor;
    }
  };

  const DvtChartDataObjectUtils = {
    /**
     * Processes the data object.  Generates default group labels if none or
     * not enough have been specified.
     * @param {Chart} chart
     */
    processDataObj: (chart) => {
      // If no data or unusable data, return
      if (!DvtChartDataUtils.hasData(chart)) return;

      var options = chart.getOptions();
      var optionsCache = chart.getOptionsCache();
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);

      // If chart type invalid, set to bar.
      if (!DvtChartTypeUtils.isValidType(chart)) options['type'] = 'bar';

      // Cached variables
      var hasY2Assignment = false;
      var hasVolume = false;
      var hasConstantZValue = true;
      var constantZValue = null; // the constant z value in the data, null if the z values vary
      var hasLowHighSeries = false;
      var hasNegativeValues = false;
      var hasDataOutsideBarEdge = false;
      var hasSeriesDisplayedInLegend = false;
      var hasDrillableSeries = false;

      // Stock Chart Overrides
      var isStock = DvtChartTypeUtils.isStock(chart);
      if (isStock) {
        // Only a single series is supported currently
        if (seriesCount > 1) {
          options['series'] = options['series'].slice(0, 1);
          seriesCount = 1;
        }
      }

      var isMixedFrequency = DvtChartTypeUtils.isMixedFrequency(chart);
      var hasLargeSeriesCount = seriesCount > 100;
      optionsCache.putToCache('hasLargeSeriesCount', hasLargeSeriesCount);

      // Iterate through the series to keep track of the count and the series style indices
      var maxGroups = 0;
      var arSeriesStyle = chart.getSeriesStyleArray();
      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
        var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
        if (!hasLargeSeriesCount && series != null && arSeriesStyle.indexOf(series) < 0)
          arSeriesStyle.push(series);

        var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
        if (seriesItem['items'] && seriesItem['items'].length > maxGroups)
          maxGroups = seriesItem['items'].length;

        if (seriesItem['visibility'] === 'hidden') {
          var hiddenCategories = DvtChartDataUtils.getHiddenCategories(chart);
          if (hiddenCategories.indexOf(series) < 0) hiddenCategories.push(series);
        }
        seriesItem['visibility'] = null;

        if (seriesItem['assignedToY2'] === 'on') hasY2Assignment = true;

        if (seriesItem['displayInLegend'] === 'on') hasSeriesDisplayedInLegend = true;

        if (seriesItem['drilling'] === 'on') hasDrillableSeries = true;

        //  - SANITIZE CHART OPTIONS OBJECT
        if (seriesItem && seriesItem['items']) {
          var items = seriesItem['items'];
          var item;
          for (var j = 0; j < items.length; j++) {
            if (items[j] != null) {
              item = items[j];
              if (typeof item != 'object') {
                item = { y: item };
                items[j] = item;
              }
              if (!isMixedFrequency && item['x'] != null) {
                item['x'] = Number(item['x']);
              }
              if (item['y'] != null) {
                item['y'] = Number(item['y']);
                if (item['y'] < 0) hasNegativeValues = true;
              }
              if (item['z'] != null) {
                item['z'] = Number(item['z']);
                if (constantZValue == null) constantZValue = item['z'];
                else if (constantZValue != item['z']) hasConstantZValue = false;
              } else constantZValue = 1;
              if (item['value'] != null) {
                item['value'] = Number(item['value']);
                if (item['value'] < 0) hasNegativeValues = true;
              }
              if (item['targetValue'] != null) {
                item['targetValue'] = Number(item['targetValue']);
              }
              if (item['open'] != null) {
                item['open'] = Number(item['open']);
                hasLowHighSeries = true;
              }
              if (item['close'] != null) {
                item['close'] = Number(item['close']);
                hasLowHighSeries = true;
                if (item['close'] < 0) hasNegativeValues = true;
              }
              if (item['low'] != null) {
                item['low'] = Number(item['low']);
                hasLowHighSeries = true;
              }
              if (item['high'] != null) {
                item['high'] = Number(item['high']);
                hasLowHighSeries = true;
              }
              if (item['volume'] != null) {
                item['volume'] = Number(item['volume']);
                hasVolume = true;
              }
              if (
                item['color'] ||
                item['borderColor'] ||
                item['borderWidth'] ||
                item['style'] ||
                item['svgStyle'] ||
                item['className'] ||
                item['svgClassName']
              ) {
                optionsCache.putToCachedMap('itemStyleSet', seriesIndex, true);
              }
              if (item['labelPosition'] == 'outsideBarEdge') {
                hasDataOutsideBarEdge = true;
              }
            }
          }
        }
      }

      // Cache the computed values
      optionsCache.putToCache('hasVolume', hasVolume);
      optionsCache.putToCache('hasConstantZValue', hasConstantZValue);
      optionsCache.putToCache('constantZValue', hasConstantZValue ? constantZValue : null);
      optionsCache.putToCache('hasLowHighSeries', hasLowHighSeries);
      optionsCache.putToCache('hasNegativeValues', hasNegativeValues);
      optionsCache.putToCache('hasDataOutsideBarEdge', hasDataOutsideBarEdge);
      optionsCache.putToCache('hasSeriesDisplayedInLegend', hasSeriesDisplayedInLegend);
      optionsCache.putToCache('hasDrillableSeries', hasDrillableSeries);

      // Add Volume Series
      if (
        isStock &&
        DvtChartDataUtils.hasVolumeSeries(chart) &&
        !DvtChartTypeUtils.isOverview(chart)
      ) {
        var volumeSeries = dvt.JsonUtils.clone(DvtChartDataUtils.getSeriesItem(chart, 0));
        volumeSeries['assignedToY2'] = 'on';
        hasY2Assignment = true;
        volumeSeries['type'] = 'bar';
        volumeSeries['categories'] = DvtChartDataUtils.getCategories(chart, 0);
        volumeSeries['id'] = '_volume';
        volumeSeries['_selectable'] = 'off';
        volumeSeries['items'] = [];
        var itemCount = seriesItem ? seriesItem['items'].length : 0;
        for (var itemIndex = 0; itemIndex < itemCount; itemIndex++) {
          var volumeItem = {};
          volumeItem['color'] = DvtChartStyleUtils.getStockVolumeColor(chart, 0, itemIndex);
          volumeItem['x'] = seriesItem && seriesItem['items'][itemIndex]['x'];
          volumeItem['value'] = seriesItem && seriesItem['items'][itemIndex]['volume'];
          volumeItem['drilling'] = 'off';
          volumeSeries['items'].push(volumeItem);
        }

        options['series'].push(volumeSeries);
        optionsCache.putToCachedMap('itemStyleSet', options['series'].length - 1, true);
      }

      optionsCache.putToCache('hasY2Assignment', hasY2Assignment);

      // Reference Objects
      var refObjs = DvtChartDataUtils.getRefObjs(chart);
      for (var i = 0; i < refObjs.length; i++) {
        var itemsArr = refObjs[i]['items'];
        if (!itemsArr) continue;
        for (var z = 0; z < itemsArr.length; z++) {
          var itemObj = itemsArr[z];
          if (!itemObj) continue;
          if (typeof itemObj !== 'object') {
            itemsArr[z] = Number(itemObj);
          } else {
            if (!DvtChartTypeUtils.isMixedFrequency(chart) && itemObj['x']) {
              itemObj['x'] = Number(itemObj['x']);
            }
            if (itemObj['max']) {
              itemObj['max'] = Number(itemObj['max']);
            }
            if (itemObj['min']) {
              itemObj['min'] = Number(itemObj['min']);
            }
            if (itemObj['value']) {
              itemObj['value'] = Number(itemObj['value']);
            }
          }
        }
      }

      // Make sure the data object specifies enough groups
      if (!options['groups']) options['groups'] = [];

      // Lengthen the array so that there are enough groups
      var groupCount = DvtChartDataUtils.getGroupCount(chart);
      for (var p = 0; p < maxGroups - groupCount; p++) {
        // Chart will have this translation, but Spark won't.  However, this string won't actually ever show up in Spark, so can just
        // hardcode it to keep the code working.
        var groupString = options.translations.labelDefaultGroupName || 'Group {0}';
        var group = dvt.ResourceUtils.format(groupString, [options['groups'].length + 1]); // +1 so we start at "Group 1"
        options['groups'].push(group);
      }
      optionsCache.putToCache('groupsArray', null);

      // Time Axis: Support date strings provided in the JSON
      DvtChartDataObjectUtils._processTimeAxis(chart);

      // Sorting: Sort the groups based on their values if sorting is turned on
      var sorting = options['sorting'];
      var offValCheck = sorting !== 'ascending' && sorting !== 'descending' ? 'off' : sorting;
      sorting = sorting === 'on' ? 'descending' : offValCheck;
      if (
        DvtChartTypeUtils.isBLAC(chart) &&
        DvtChartTypeUtils.hasGroupAxis(chart) &&
        sorting != 'off' &&
        DvtChartDataUtils.getNumLevels(chart) == 1
      ) {
        // Find all the group totals
        var groups = DvtChartDataUtils.getGroups(chart);

        var totalsMap = {};
        for (var q = 0; q < groups.length; q++) {
          var total = 0;
          for (var r = 0; r <= seriesCount; r++) {
            // Only count rendered series that are assigned to Y1
            if (
              DvtChartDataUtils.isSeriesRendered(chart, r) &&
              !DvtChartDataUtils.isAssignedToY2(chart, r)
            ) {
              // Add up all the values for items in the group.  Null values are treated as 0.
              var value = DvtChartDataUtils.getVal(chart, r, q);
              total += value == null || isNaN(value) ? 0 : value;
            }
          }
          totalsMap[groups[q]] = { index: q, total: total, group: options['groups'][q] };
        }
        // Sort the groups list
        if (sorting === 'ascending')
          groups.sort((a, b) => {
            return totalsMap[a]['total'] - totalsMap[b]['total'];
          });
        else
          groups.sort((a, b) => {
            return totalsMap[b]['total'] - totalsMap[a]['total'];
          });

        // Sort the series items based on the groups order.
        for (var s = 0; s < seriesCount; s++) {
          var seriesItems = [];
          for (var t = 0; t < groups.length; t++) {
            seriesItems.push(DvtChartDataUtils.getDataItem(chart, s, totalsMap[groups[t]]['index']));
          }
          options['series'][s]['items'] = seriesItems;
        }

        var groupItems = [];
        for (var w = 0; w < groups.length; w++) groupItems.push(totalsMap[groups[w]]['group']);

        options['groups'] = groupItems;

        // Reset cached groupsArray and value because the data item ordering has been changed
        optionsCache.putToCache('groupsArray', null);
        optionsCache.putToCache('value', null);
      }

      // Data Cursor Styles
      options['styleDefaults']['dataCursor']['lineWidth'] = parseFloat(
        options['styleDefaults']['dataCursor']['lineWidth']
      );

      // Don't allow axis extents where the min and max are the same
      DvtChartDataObjectUtils._sanitizeAxis(options['xAxis']);
      DvtChartDataObjectUtils._sanitizeAxis(options['yAxis']);
      DvtChartDataObjectUtils._sanitizeAxis(options['y2Axis']);
    },

    /**
     * Processes the options object for time axis.
     * @param {Chart} chart
     * @private
     */
    _processTimeAxis: (chart) => {
      var context = chart.getCtx();
      var options = chart.getOptions();
      var seriesIndex, groupIndex;
      var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
      var groupCount = DvtChartDataUtils.getGroupCount(chart);

      // Sanitize values specific to mixed frequency or regular time axis
      if (DvtChartTypeUtils.isMixedFrequency(chart)) {
        // Mixed frequency time axis uses x values to specify the dates
        for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
          for (groupIndex = 0; groupIndex < groupCount; groupIndex++) {
            var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
            if (dataItem != null && typeof dataItem['x'] == 'string') {
              if (dataItem['x'] != null)
                dataItem['x'] = DvtChartDataObjectUtils._sanitizeDateTime(context, dataItem['x']);
            }
          }
        }
      } else if (DvtChartTypeUtils.hasTimeAxis(chart)) {
        // Regular time axis specify the dates in the groups array
        for (groupIndex = 0; groupIndex < groupCount; groupIndex++) {
          var group = DvtChartDataUtils.getGroup(chart, groupIndex);
          if (group != null)
            options['groups'][groupIndex] = DvtChartDataObjectUtils._sanitizeDateTime(context, group);
        }
        chart.getOptionsCache().putToCache('groupsArray', null);
      }

      // Sanitize values that apply for all time axes
      if (DvtChartTypeUtils.hasTimeAxis(chart)) {
        // X-Axis Attributes
        var xOptions = options['xAxis'];
        if (xOptions['dataMin'] != null)
          xOptions['dataMin'] = DvtChartDataObjectUtils._sanitizeDateTime(
            context,
            xOptions['dataMin']
          );

        if (xOptions['dataMax'] != null)
          xOptions['dataMax'] = DvtChartDataObjectUtils._sanitizeDateTime(
            context,
            xOptions['dataMax']
          );

        if (xOptions['min'] != null)
          xOptions['min'] = DvtChartDataObjectUtils._sanitizeDateTime(context, xOptions['min']);

        if (xOptions['max'] != null)
          xOptions['max'] = DvtChartDataObjectUtils._sanitizeDateTime(context, xOptions['max']);

        if (xOptions['viewportMin'] != null)
          xOptions['viewportMin'] = DvtChartDataObjectUtils._sanitizeDateTime(
            context,
            xOptions['viewportMin']
          );

        if (xOptions['viewportMax'] != null)
          xOptions['viewportMax'] = DvtChartDataObjectUtils._sanitizeDateTime(
            context,
            xOptions['viewportMax']
          );

        if (xOptions['viewportStartGroup'] != null)
          xOptions['viewportStartGroup'] = DvtChartDataObjectUtils._sanitizeDateTime(
            context,
            xOptions['viewportStartGroup']
          );

        if (xOptions['viewportEndGroup'] != null)
          xOptions['viewportEndGroup'] = DvtChartDataObjectUtils._sanitizeDateTime(
            context,
            xOptions['viewportEndGroup']
          );

        // Reference Object X Values
        var refObjs = DvtChartDataUtils.getRefObjs(chart);
        for (var i = 0; i < refObjs.length; i++) {
          var items = refObjs[i]['items'];
          if (!items) {
            if (refObjs[i]['value'] && refObjs[i]['value'] != null) {
              refObjs[i]['value'] = DvtChartDataObjectUtils._sanitizeDateTime(
                context,
                refObjs[i]['value']
              );
            }
            continue;
          }

          for (var j = 0; j < items.length; j++) {
            if (items[j] && items[j]['x'] != null)
              items[j]['x'] = DvtChartDataObjectUtils._sanitizeDateTime(context, items[j]['x']);
            if (items[j] && items[j]['value'] != null)
              items[j]['value'] = DvtChartDataObjectUtils._sanitizeDateTime(
                context,
                items[j]['value']
              );
          }
        }
      }
    },

    /**
     * Sanitizes the options for a chart axis. Currently just ensures that equal min/max are not passed in.
     * @param {object} axisOptions
     * @private
     */
    _sanitizeAxis: (axisOptions) => {
      if (axisOptions['min'] == axisOptions['max']) {
        axisOptions['min'] = null;
        axisOptions['max'] = null;
      }
    },

    /**
     * Process the dateTime object and returns as a number. Valid inputs include number of milliseconds, an iso string, or
     * a string that can be processed by Date.parse().
     * @param {dvt.Context} context
     * @param {object} dateTime
     * @return {number}
     * @private
     */
    _sanitizeDateTime: (context, dateTime) => {
      var ret = null;

      // First try the converter if available
      var isoToDateConverter = context.getLocaleHelpers()['isoToDateConverter'];
      if (isoToDateConverter) {
        // Enclose in a try/catch because the converter will throw an exception if the string is not in iso format
        try {
          ret = isoToDateConverter(dateTime);
        } catch (err) {
          ret = null;
        }

        // Convert to number
        if (ret != null && ret.getTime) ret = ret.getTime();
        else ret = null;
      }

      if (ret == null) {
        if (!isNaN(dateTime)) {
          return dateTime;
        }
        return Date.parse(dateTime);
      }

      return ret;
    }
  };

  function getLabelPosition(chart, seriesIndex, groupIndex) {
    const item = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
    const labelPositionItem =
      item.labelPosition != 'auto' && item.labelPosition != undefined
        ? item.labelPosition
        : undefined;
    const series = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
    const labelPositionSeries =
      series.labelPosition != 'auto' && series.labelPosition != undefined
        ? series.labelPosition
        : undefined;
    return labelPositionItem || labelPositionSeries;
  }

  function getDataLabelOverlapPreference(labelPosition, resolveLabelOverlap) {
    if (resolveLabelOverlap === 'off') {
      return [labelPosition];
    }

    if (labelPosition === 'aboveMarker') {
      return ['aboveMarker', 'belowMarker', 'beforeMarker', 'afterMarker'];
    } else if (labelPosition === 'belowMarker') {
      return ['belowMarker', 'aboveMarker', 'beforeMarker', 'afterMarker'];
    } else if (labelPosition === 'beforeMarker') {
      return ['beforeMarker', 'afterMarker', 'aboveMarker', 'belowMarker'];
    } else {
      return ['afterMarker', 'aboveMarker', 'belowMarker', 'beforeMarker'];
    }
  }

  function getLabelLayout(chart, label, labelPosition, status, isRTL, removeOverlappingLabel) {
    let { x: labelX, y: labelY, h: labelHeight, w: labelWidth } = label.getDimensions();
    let { x: markerX, y: markerY, h: markerHeight, w: markerWidth } = label._marker.getDimensions();

    let seriesIndex = label._seriesIndex;
    let groupIndex = label._groupIndex;

    const userPosition = getLabelPosition(chart, seriesIndex, groupIndex);
    const position = userPosition || labelPosition;
    const labelPadding = 4;

    switch (position) {
      case 'aboveMarker':
        labelX = markerX + markerWidth / 2 - labelWidth / 2;
        labelY = markerY - labelHeight; // No need for buffer because itemBounds.y accounts for typography baselines
        break;
      case 'belowMarker':
        labelX = markerX + markerWidth / 2 - labelWidth / 2;
        labelY = markerY + markerHeight + labelPadding;
        break;
      case 'beforeMarker':
        labelX = isRTL ? markerX + markerWidth + labelPadding : markerX - labelPadding - labelWidth;
        labelY = markerY + markerHeight / 2 - labelHeight / 2;
        break;
      case 'afterMarker':
        labelX = isRTL ? markerX - labelPadding - labelWidth : markerX + markerWidth + labelPadding;
        labelY = markerY + markerHeight / 2 - labelHeight / 2;
        break;
      case 'none':
        // No need to do anything; label won't be rendered anyway
        break;
      default:
        break;
    }

    return {
      labelX,
      labelY,
      labelWidth,
      labelHeight,
      labelPosition: position,
      label,
      status: userPosition && !removeOverlappingLabel ? 'DONE' : status
    };
  }

  function getInitialAnchors(chart) {
    // sort markers based on y values
    const dataLabels =
      chart._dataLabels?.sort((a, b) => {
        const dimA = a._marker.getDimensions();
        const dimB = b._marker.getDimensions();

        return dimA.y - dimB.y || dimA.x - dimB.x;
      }) || [];

    const anchors = dataLabels.map((label) => {
      const { x, y, w, h } = label._marker.getDimensions();
      return {
        minX: x,
        minY: y,
        maxX: x + w,
        maxY: y + h
      };
    });

    return { pending: dataLabels, anchors };
  }

  function resolveDataLabelOverlap(chart) {
    const { w: plotAreaWidth, h: plotAreaHeight } = chart.__getPlotAreaSpace();

    const styleDefaults = chart.getOptions().styleDefaults;
    const removeOverlappingLabel = styleDefaults.hideOverlappingLabels === 'on';

    const isRTL = dvt.Agent.isRightToLeft(chart.getCtx());
    const { pending, anchors } = getInitialAnchors(chart);

    const spatialIndex = new dvt.PixelMap();

    anchors.forEach(({ minX, minY, maxX, maxY }) => {
      spatialIndex.setOverlap(minX, minY, maxX, maxY);
    });

    const positionOrder = getDataLabelOverlapPreference(
      styleDefaults.dataLabelPosition,
      styleDefaults.resolveLabelOverlap
    );

    if (removeOverlappingLabel) {
      positionOrder.push('none');
    }

    let pendingLayouts = pending.map((label) =>
      getLabelLayout(chart, label, positionOrder[0], 'PENDING', isRTL, removeOverlappingLabel)
    );

    positionOrder.forEach((labelPosition, i) => {
      const pending = pendingLayouts.filter((l) => l.status === 'PENDING');
      pending.forEach((l) => {
        const { labelX, labelY, labelWidth, labelHeight } = getLabelLayout(
          chart,
          l.label,
          labelPosition,
          'PENDING',
          isRTL,
          removeOverlappingLabel
        );

        const isOutofBound =
          labelX < 0 ||
          labelY < 0 ||
          labelX + labelWidth > plotAreaWidth ||
          labelY + labelHeight > plotAreaHeight;

        if (
          !isOutofBound &&
          !spatialIndex.isOverlapping(labelX, labelY, labelX + labelWidth, labelY + labelHeight)
        ) {
          l.labelX = labelX;
          l.labelY = labelY;
          l.labelPosition = labelPosition;
          l.status = 'DONE';
          spatialIndex.setOverlap(labelX, labelY, labelX + labelWidth, labelY + labelHeight);
          l.label.setX(l.labelX + l.labelWidth / 2);
          l.label.setY(l.labelY + l.labelHeight / 2);
        } else if (labelPosition === 'none') {
          l.status = 'DONE';
          l.label._parent.removeChild(l.label);
        }
      });
    });
  }

  /**
   * Chart component.
   * @param {dvt.Context} context The rendering context.
   * @param {function} callback The function that should be called to dispatch component events.
   * @param {object} callbackObj The optional object instance on which the callback function is defined.
   * @class
   * @constructor
   * @extends {dvt.BaseComponent}
   */
  class Chart extends dvt.BaseComponent {
    constructor(context, callback, callbackObj, doNotInit) {
      super(context, callback, callbackObj, doNotInit);

      if (!doNotInit) {
        // Create the defaults object
        this.Defaults = new DvtChartDefaults(context);

        // Create the event handler and add event listeners
        this.EventManager = new DvtChartEventManager(this);
        this.EventManager.addListeners(this);

        // Set up keyboard handler
        this.EventManager.setKeyboardHandler(this.CreateKeyboardHandler(this.EventManager));

        // Make sure the object has an id for clipRect naming
        this.setId('chart' + 1000 + Math.floor(Math.random() * 1000000000)); //@RandomNumberOK

        /**
         * The legend of the chart.  This will be set during render time.
         * @type {Legend.Legend}
         */
        this.legend = null;
        /**
         * The x axis of the chart.  This will be set during render time.
         * @type {DvtChartAxis}
         */
        this.xAxis = null;
        /**
         * The y axis of the chart.  This will be set during render time.
         * @type {DvtChartAxis}
         */
        this.yAxis = null;
        /**
         * The y2 axis of the chart.  This will be set during render time for dual-y graphs.
         * @type {DvtChartAxis}
         */
        this.y2Axis = null;
        /**
         * The overview scrollbar of the chart.  This will be set during render time.
         * @type {DvtChartOverview}
         */
        this.overview = null;
        /**
         * The x-axis simple scrollbar of the chart.  This will be set during render time.
         * @type {dvt.SimpleScrollbar}
         */
        this.xScrollbar = null;
        /**
         * The y-axis simple scrollbar of the chart.  This will be set during render time.
         * @type {dvt.SimpleScrollbar}
         */
        this.yScrollbar = null;
        /**
         * The drag mode buttons of the chart.  This will be set during render time.
         * @type {dvt.Container}
         */
        this.dragButtons = null;
        /**
         * The pie chart subcomponent.  This will be set during render time for pie graphs.
         * @type {DvtChartPie}
         */
        this.pieChart = null;

        /**
         * The pie chart custom center content.
         * @type {Element}
         */
        this.pieCenterDiv = null;

        /**
         * The array of logical objects for this chart.
         * @protected
         */
        this.Peers = [];

        /**
         * Array to make sure that the styles of the series don't mutate of data change.
         * @protected
         */
        this.SeriesStyleArray = [];

        // Support for changing z-order for selection
        this._numFrontObjs = 0;
        this._numSelectedObjsInFront = 0;

        /** @private */
        this._dataLabels = null;

        /**
         * Reference to user options before it's processed and used to create the chart.
         * @private
         */
        this._rawOptions = null;
      }
    }

    /**
     * Returns a copy of the default options for the specified skin.
     * @param {string} skin The skin whose defaults are being returned.
     * @return {object} The object containing defaults for this component.
     */
    static getDefaults(skin) {
      return new DvtChartDefaults().getDefaults(skin);
    }

    /**
     *
     * @returns
     */
    createOverviewChart() {
      return new Chart(this.getCtx());
    }

    /**
     * @override
     */
    GetComponentDescription() {
      var options = this.getOptions();
      var compName = options.translations.componentName;

      var compDesc = '';
      var delimiter = dvt.AriaUtils.ARIA_LABEL_DESC_DELIMITER;
      if (options['title']['text']) {
        compDesc += this.Options['title']['text'];
        if (options['subtitle']['text']) compDesc += delimiter + this.Options['subtitle']['text'];
      }
      if (options['footnote']['text'])
        compDesc =
          compDesc.length === 0
            ? this.Options['footnote']['text']
            : compDesc.concat(delimiter, this.Options['footnote']['text']);

      if (compDesc.length > 0)
        return dvt.ResourceUtils.format(this.Options.translations.labelAndValue, [
          compName,
          compDesc
        ]);
      else return compName;
    }

    /**
     * @override
     */
    SetOptions(options) {
      super.SetOptions(options);

      if (options) {
        // Combine the user options with the defaults and store
        this._rawOptions = options;
        this.Options = this.Defaults.calcOptions(options);

        // Process the data to add bulletproofing
        DvtChartDataObjectUtils.processDataObj(this);

        // Disable animation for canvas, xml and large bubble/scatter data
        if (
          dvt.Agent.isEnvironmentTest() ||
          (DvtChartTypeUtils.isScatterBubble(this) &&
            DvtChartDataUtils.getSeriesCount(this) * DvtChartDataUtils.getGroupCount(this) >
              DvtChartPlotAreaRenderer.FILTER_THRESHOLD_SCATTER_BUBBLE)
        ) {
          this.Options['animationOnDisplay'] = 'none';
          this.Options['animationOnDataChange'] = 'none';
        }
      } else if (!this.Options)
        // No object has ever been provided, copy the defaults
        this.Options = this.GetDefaults();

      // Initialize the selection handler
      var selectionMode = this.Options['selectionMode'];
      if (selectionMode === 'single')
        this._selectionHandler = new dvt.SelectionHandler(
          this.getCtx(),
          dvt.SelectionHandler.TYPE_SINGLE
        );
      else if (selectionMode === 'multiple')
        this._selectionHandler = new dvt.SelectionHandler(
          this.getCtx(),
          dvt.SelectionHandler.TYPE_MULTIPLE
        );
      else this._selectionHandler = null;

      // Pass to event handler
      this.EventManager.setSelectionHandler(this._selectionHandler);
    }

    /**
     * @override
     */
    render(options, width, height) {
      // Reset cache
      this.getCache().clearCache();

      var context = this.getCtx();

      // current options takes precedent over previous options.
      var animationOnDataChange =
        options?.['animationOnDataChange'] || this.Options?.['animationOnDataChange'] || 'none';

      // Cache and cleanup objects from the previous render
      var oldChart = animationOnDataChange != 'none' ? new DvtChartDataChange(this) : null;
      var focusState = this.__cacheChartFocus();
      if (this._container) this.__cleanUp();

      // Update if a new options object has been provided or initialize with defaults if needed. This is done first to
      // ensure that property access, like DvtChartStyleUtils.setAnimOnDataChange, do not generate default options.
      this.SetOptions(options);

      // Update the width and height if provided
      if (!isNaN(width) && !isNaN(height)) {
        this.Width = width;
        this.Height = height;
      }

      // Create a new container and render the component into it
      var container = new dvt.Container(context);
      this.addChild(container);
      DvtChartRenderer.render(this, container, new dvt.Rectangle(0, 0, this.Width, this.Height));

      // . We don't want the inner chart's listeners to be invoked when it is a spark chart, thus we are removing them.
      if (DvtChartTypeUtils.isSpark(this)) {
        this.EventManager.removeListeners(this);
        // deferred data case won't have xAxis and yAxis initialized.
        if (this.xAxis) this.xAxis.EventManager.removeListeners(this.xAxis);
        if (this.yAxis) this.yAxis.EventManager.removeListeners(this.yAxis);
      }

      // Animation Support
      this.StopAnimation();

      // Construct the new animation playable
      var animationOnDisplay = DvtChartStyleUtils.getAnimOnDisplay(this);
      var animationDuration = DvtChartStyleUtils.getAnimDur(this);
      var bounds = new dvt.Rectangle(0, 0, this.Width, this.Height);
      var bBlackBoxUpdate = false; // true if this is a black box update animation

      if (!this._container) {
        if (animationOnDisplay != 'none') {
          // AnimationOnDisplay
          this.Animation = dvt.BlackBoxAnimationHandler.getInAnimation(
            context,
            animationOnDisplay,
            container,
            bounds,
            animationDuration
          );
          if (!this.Animation && animationOnDisplay === 'auto') {
            this.Animation = DvtChartAnimOnDisplay.createAnim(
              this,
              animationOnDisplay,
              animationDuration
            );
          }
        }
      } else if (animationOnDataChange != 'none' && options) {
        // AnimationOnDataChange
        this.Animation = dvt.BlackBoxAnimationHandler.getCombinedAnimation(
          context,
          animationOnDataChange,
          this._container,
          container,
          bounds,
          animationDuration
        );
        if (this.Animation)
          // Black Box Animation
          bBlackBoxUpdate = true;
        else if (animationOnDataChange === 'auto' && this.getPlotArea()) {
          var paSpace = this.__getPlotAreaSpace();
          this._delContainer = DvtChartPlotAreaRenderer.createClippedGroup(
            this,
            this._container,
            new dvt.Rectangle(0, 0, paSpace.w, paSpace.h)
          );
          this.Animation = DvtChartAnimOnDC.createAnim(
            oldChart,
            this,
            animationOnDataChange,
            animationDuration,
            this._delContainer
          );

          if (this._delContainer.getNumChildren() > 0)
            this.getPlotArea().addChild(this._delContainer);
        }
      }

      // If an animation was created, play it
      if (this.Animation) {
        // Disable event listeners temporarily
        this.EventManager.removeListeners(this);

        // Run the animation
        dvt.Playable.appendOnEnd(this.Animation, this._onAnimationEnd, this);
        this.Animation.play();

        // Store a reference to the old container to be cleaned up after the animation. Remove
        // from the DOM if we don't need it for black box animation.
        this._oldContainer = this._container;
        if (!bBlackBoxUpdate && this._oldContainer) this._oldContainer.removeFromParent();
      } else if (this._container) {
        // No animation, so delete the previously rendered contents.
        this._container.removeFromParent();
        this._container.destroy();
        this._container = null;
      }

      // Update the pointer to the new container
      this._container = container;

      // Data Cursor
      this._dataCursor = DvtChartRenderer.renderDataCursor(this);

      this.UpdateAriaAttributes();

      // Restore focus
      this.__restoreChartFocus(focusState);
      this.__resolveDataLabelPosition();

      if (!this.Animation)
        // If not animating, that means we're done rendering, so fire the ready event.
        this.RenderComplete();
    }

    __resolveDataLabelPosition() {
      const isScatter = this.Options.type === 'scatter';
      const hasDataLabel = this._dataLabels && this._dataLabels.length > 0;
      const removeOverlappingLabel = this.Options.styleDefaults.hideOverlappingLabels === 'on';
      const resolveOverlap = this.Options.styleDefaults.resolveLabelOverlap === 'on';
      if (!isScatter || !hasDataLabel) {
        return;
      }

      if (removeOverlappingLabel || resolveOverlap) {
        resolveDataLabelOverlap(this);
      }
    }

    /**
     * Performs cleanup of the previously rendered content.  Note that this doesn't cleanup anything needed for animation.
     * @protected
     */
    __cleanUp() {
      // Data cursor cleanup
      if (this._dataCursor) {
        this.removeChild(this._dataCursor);
        this._dataCursor = null;
      }

      if (this.EventManager) {
        // Tooltip cleanup
        this.EventManager.hideHoverFeedback();

        // Event handler cleanup
        this.EventManager.setPanZoomHandler(null);
        this.EventManager.setMarqueeZoomHandler(null);
        this.EventManager.setMarqueeSelectHandler(null);

        // Drag button cleanup
        this.EventManager.panButton = null;
        this.EventManager.zoomButton = null;
        this.EventManager.selectButton = null;
      }

      // Remove pie center content
      if (this.pieCenterDiv) {
        this.getCtx().getContainer().removeChild(this.pieCenterDiv);
        this.pieCenterDiv = null;
      }

      // Clear the list of registered peers
      this.Peers = [];

      // Clear scrollbars, buttons
      this.xScrollbar = null;
      this.yScrollbar = null;

      if (this.dragButtons) {
        this.removeChild(this.dragButtons);
        this.dragButtons.destroy();
        this.dragButtons = null;
      }

      this._plotArea = null;
      this._areaContainer = null;
      this._dataLabels = null;

      // Reset cache
      this.getCache().clearCache();
    }

    /**
     * Clean up axis and plot area for rerendering (zoom/scroll).
     */
    __cleanUpAxisAndPlotArea() {
      // Tooltip cleanup
      this.EventManager.hideHoverFeedback();

      // Clear the list of registered peers
      this.Peers = [];

      // Clean up the axis and plot area
      if (this.xAxis) {
        this._container.removeChild(this.xAxis);
        this.xAxis.destroy();
      }
      if (this.yAxis) {
        this._container.removeChild(this.yAxis);
        this.yAxis.destroy();
      }
      if (this.y2Axis) {
        this._container.removeChild(this.y2Axis);
        this.y2Axis.destroy();
      }

      // Plot area which is a touch target needs to be kept so that subsequent touch events are fired.
      if (this._plotArea && this._plotArea == this._panZoomTarget) this._plotArea.setVisible(false);
      else if (this._plotArea) {
        this._container.removeChild(this._plotArea);
        this._plotArea.destroy();
      }

      this._plotArea = null;
      this._dataLabels = [];

      // Reset cache
      this.getCache().clearCache();
    }

    /**
     * Hook for cleaning up animation behavior at the end of the animation.
     * @private
     */
    _onAnimationEnd() {
      // Clean up the old container. This is done after the animation to avoid garbage
      // collection during the animation and because the black box updates need it.
      if (this._oldContainer) {
        this._oldContainer.removeFromParent();
        this._oldContainer.destroy();
        this._oldContainer = null;
      }

      if (this._delContainer) {
        this._delContainer.removeFromParent();
        this._delContainer.destroy();
        this._delContainer = null;
      }

      // Fire ready event saying animation is finished.
      if (!this.AnimationStopped) this.RenderComplete();

      // Restore event listeners
      this.EventManager.addListeners(this);

      // Reset animation flags
      this.Animation = null;
      this.AnimationStopped = false;
    }

    /**
     * Creates the keyboard handler.
     * @param {DvtChartEventManager} manager Event manager.
     * @return {DvtChartKeyboardHandler}
     * @protected
     */
    CreateKeyboardHandler(manager) {
      return new DvtChartKeyboardHandler(manager, this);
    }

    /**
     * Returns the automation object for this chart
     * @return {dvt.Automation} The automation object
     */
    getAutomation() {
      return new DvtChartAutomation(this);
    }

    /**
     * Returns the x, y, and y2 axis values at the specified X and Y coordinate.
     * @param {Number} x The X coordinate relative to the component.
     * @param {Number} y The Y coordinate relative to the component.
     * @return {object} An object containing the "x", "y", and "y2" axis values.
     */
    getValsAt(x, y) {
      var paBounds = this.__getPlotAreaSpace();
      var relX = x - paBounds.x;
      var relY = y - paBounds.y;

      var isPolar = DvtChartTypeUtils.isPolar(this);
      var isHoriz = DvtChartTypeUtils.isHorizontal(this);

      if (isPolar) {
        // Convert cartesian to polar
        relX -= paBounds.w / 2;
        relY -= paBounds.h / 2;
        var r = Math.sqrt(relX * relX + relY * relY);
        var theta = Math.atan2(relX, -relY);
        if (theta < 0) theta += 2 * Math.PI;

        return {
          x: this.xAxis ? this.xAxis.getValAt(theta) : null,
          y: this.yAxis ? this.yAxis.getValAt(r) : null
        };
      } else {
        return {
          x: this.xAxis ? this.xAxis.getValAt(isHoriz ? relY : relX) : null,
          y: this.yAxis ? this.yAxis.getValAt(isHoriz ? relX : relY) : null,
          y2: this.y2Axis ? this.y2Axis.getValAt(isHoriz ? relX : relY) : null
        };
      }
    }

    /**
     * Filters or removes the filter from the specified category.
     * @param {string} category The category which has been filtered out.
     * @param {string} type "out" to filter out the specified category, or "in" to remove the filter.
     */
    filter(category, type) {
      // Update the component state
      var visibility = type === 'out' ? 'hidden' : 'visible';
      DvtChartEventUtils.setVisibility(this, category, visibility);
      // Rerender the component. Pass the options to cause animation to happen.
      this.render(this.Options);
    }

    /**
     * @override
     */
    highlight(categories) {
      // Update the options
      this.getOptions()['highlightedCategories'] = dvt.JsonUtils.clone(categories);

      // Perform the highlighting and propagate to children
      dvt.CategoryRolloverHandler.highlight(
        categories,
        this.getObjects(),
        this.getOptions()['highlightMatch'] === 'any'
      );

      if (this.legend) this.legend.highlight(categories);

      if (this.pieChart) this.pieChart.highlight(categories);

      if (this.overview) this.overview.getBackgroundChart().highlight(categories);
    }

    /**
     * @override
     */
    select(selection) {
      // Update the options
      var options = this.getOptions();
      options['selection'] = dvt.JsonUtils.clone(selection);

      // Perform the selection
      var selected = DvtChartDataUtils.getInitialSelection(this);
      DvtChartEventUtils.setInitialSelection(this, selected);

      // Propagate to children
      if (this.pieChart) this.pieChart.setInitialSelection();
    }

    /**
     * Positions the data cursor.
     * @param {object} position The data cursor position, containing x, y, y2. If null, the data cursor will be hidden.
     */
    positionDataCursor(position) {
      var handler = this.getEventManager().getDataCursorHandler();
      if (!handler) return;

      if (position) {
        var xCoord =
          this.xAxis && position['x'] != null ? this.xAxis.getCoordAt(position['x']) : null;
        var yCoord = null;
        if (DvtChartTypeUtils.isBLAC(this)) {
          // For BLAC use bounded coord for y-axis to enable syncing across charts with different scales
          if (this.yAxis && position['y'] != null)
            yCoord = this.yAxis.getBoundedCoordAt(position['y']);
          else if (this.y2Axis && position['y2'] != null)
            yCoord = this.yAxis.getBoundedCoordAt(position['y2']);
        } else
          yCoord = this.yAxis && position['y'] != null ? this.yAxis.getCoordAt(position['y']) : null;

        if (xCoord != null && yCoord != null) {
          // Convert to stage coords and pass them to data cursor handler
          var paBounds = this.__getPlotAreaSpace();
          var paCoords = DvtChartCoordUtils.convertAxisCoord(
            this,
            new dvt.Point(xCoord, yCoord),
            paBounds
          );
          handler.processMove(new dvt.Point(paBounds.x + paCoords.x, paBounds.y + paCoords.y), true);
          return;
        }
      }

      handler.processEnd(true);
    }

    /**
     * Processes the specified event.
     * @param {object} event
     * @param {object} source The component that is the source of the event, if available.
     */
    processEvent(event, source) {
      var type = event['type'];
      if (type === 'categoryHide' || type === 'categoryShow')
        this.filter(event['category'], type === 'categoryHide' ? 'out' : 'in');
      else if (type === 'categoryHighlight') {
        // If the chart is not the source of the event, perform highlighting.
        if (this != source) this.highlight(event['categories']);

        if (this.legend && this.legend != source) this.legend.processEvent(event, source);
      } else if (type === 'selection') event = this._processSelectionEvent(event);
      else if (type === 'dvtPanZoom') event = this._processPanZoomEvent(event);
      else if (type === 'dvtMarquee') event = this._processMarqueeEvent(event);
      else if (type === 'overview') {
        var subtype = event.subtype;
        if (subtype === 'dropCallback') return;
        var actionDone =
          subtype === 'scrollTime' || subtype === 'scrollEnd' || subtype === 'rangeChange';
        event = this._processScrollbarEvent(event.newX1, event.newX2, actionDone, source);
      } else if (type === 'dvtSimpleScrollbar')
        event = this._processScrollbarEvent(
          event.newMin,
          event.newMax,
          event.subtype === 'end',
          source
        );
      else if (type === 'ready' && this != source) return; // Ready event fired by legend shouldn't be dispatched because the chart isn't ready yet ()

      // Return if there's no event to dispatch
      if (!event) return;

      // The event type may change after processing
      type = event['type'];

      // For selection events, update the options object and calculate the added/removed arrays
      if (type === 'selection') {
        // TODO : The calculation of added/removedSet should ideally happen in the selectionHandler, but the code there
        // was changed such that it doesn't fire the selection event directly anymore.
        var options = this.getOptions();
        var oldItems = options['selection'];
        var newItems = DvtChartDataUtils.getCurrentSelection(this);
        if (event['complete'])
          // don't update options on input
          options['selection'] = newItems;

        // Ensure old and new items are not null
        oldItems = oldItems ? oldItems : [];
        newItems = newItems ? newItems : [];

        // Calculate the old and set selection id sets
        var oldIndex, newIndex;

        var oldSet = {};
        for (oldIndex = 0; oldIndex < oldItems.length; oldIndex++) {
          oldSet[oldItems[oldIndex]['id']] = true;
        }

        var newSet = {};
        for (newIndex = 0; newIndex < newItems.length; newIndex++) {
          newSet[newItems[newIndex]['id']] = true;
        }

        // Calculate the added and remove sets using the old and new
        var addedSet = {};
        for (newIndex = 0; newIndex < newItems.length; newIndex++) {
          var newItemId = newItems[newIndex]['id'];
          if (!oldSet[newItemId]) addedSet[newItemId] = true;
        }

        var removedSet = {};
        for (oldIndex = 0; oldIndex < oldItems.length; oldIndex++) {
          var oldItemId = oldItems[oldIndex]['id'];
          if (!newSet[oldItemId]) removedSet[oldItemId] = true;
        }

        // Finally add to the selection event
        event['addedSet'] = addedSet;
        event['removedSet'] = removedSet;

        // Populate the data context
        for (var i = 0; i < event['selection'].length; i++) {
          DvtChartEventUtils.addEventData(this, event['selection'][i]);
        }
        event['component'] = this.getOptions()['_widgetConstructor'];
      } else if (type === 'drill') {
        if (!event.subType) {
          // events fired from the legend
          event.subType = event.id === '_dvtOther' ? 'multiSeries' : 'series';
          event.series = event.id;
        }

        this._processDrillSubType(event);
        if (event.subType === 'multiSeries') {
          // original drill events didn't support multiSeries
          return;
        }
        // Populate the data context
        DvtChartEventUtils.addEventData(this, event);
        delete event.subType;
        event['component'] = this.getOptions()['_widgetConstructor'];
      }

      // Dispatch the event to the callback
      this.dispatchEvent(event);
    }

    /**
     * Processes the drill events.
     * @param {object} event
     * @param {object} source The component that is the source of the event, if available.
     */
    _processDrillSubType(event) {
      var subType = event.subType;
      var newEvent;

      if (subType === 'item') {
        newEvent = DvtChartEventUtils.addItemDrillEventData(this, event);
      } else if (subType === 'group') {
        newEvent = DvtChartEventUtils.addGroupDrillEventData(this, event);
      } else if (subType === 'series') {
        newEvent = DvtChartEventUtils.addSeriesDrillEventData(this, event);
      } else if (subType === 'multiSeries') {
        newEvent = DvtChartEventUtils.addMultiSeriesDrillEventData(this, event);
      }
      // Dispatch the event to the callback
      this.dispatchEvent(newEvent);
    }

    /**
     * Processes selection event.
     * @param {object} event Selection event.
     * @return {object} Processed event.
     * @private
     */
    _processSelectionEvent(event) {
      var selection = DvtChartEventUtils.processIds(this, event['selection']);
      this._updateOverviewSelection();
      return dvt.EventFactory.newChartSelectionEvent(selection, true);
    }

    /**
     * Processes pan/zoom event.
     * @param {object} event Pan/zoom event.
     * @return {object} Processed event.
     * @private
     */
    _processPanZoomEvent(event) {
      var subtype = event.subtype;
      var actionStart = subtype === 'panStart' || subtype === 'pinchStart';
      if (actionStart) {
        // The initial touch target has to be kept so that the subsequent touch move events are fired
        if (dvt.Agent.isTouchDevice() && this._panZoomTarget != this._plotArea) {
          this._container.removeChild(this._panZoomTarget);
          this._panZoomTarget = this._plotArea;
        }
        return null; // start event does not need to be processed further because the viewport does not change
      }

      if (this._lastPanZoomEvent) {
        // If there is an existing event waiting for the next animation frame, add up the dx's and dy's of the current event
        // to be processed together as one event in the next frame. This ensures that each animation frame only processes
        // one event so that the z&s behavior is smoother.
        event.dxMin += this._lastPanZoomEvent.dxMin;
        event.dxMax += this._lastPanZoomEvent.dxMax;
        event.dyMin += this._lastPanZoomEvent.dyMin;
        event.dyMax += this._lastPanZoomEvent.dyMax;
      } else {
        // If there is not an existing event in the queue, request an animation frame to process the current event.
        dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this._animatePanZoomEvent));
      }

      this._lastPanZoomEvent = event;

      return null; // viewportChange event is created and dispatched in the animate callback
    }

    /**
     * requestAnimationFrame callback to animate pan/zoom.
     * It will rerender the chart based on the last pan/zoom event that is fired since the last frame.
     * @private
     */
    _animatePanZoomEvent() {
      var event = this._lastPanZoomEvent;
      this._lastPanZoomEvent = null; // nullify to indicate that the event has been processed

      var subtype = event.subtype;
      var actionDone = subtype === 'panEnd' || subtype === 'zoom' || subtype === 'pinchEnd';

      // Calculate the bounds and update the viewport
      var bounds;
      if (DvtChartBehaviorUtils.isLiveScroll(this)) {
        // live
        bounds = DvtChartEventUtils.getAxisBoundsByDelta(
          this,
          event.dxMin,
          event.dxMax,
          event.dyMin,
          event.dyMax
        );
        this._setScrollbarViewport(bounds);
        this._setViewport(bounds, actionDone);
      } else {
        // delayed
        bounds = DvtChartEventUtils.getAxisBoundsByDelta(
          this,
          event.dxMinTotal,
          event.dxMaxTotal,
          event.dyMinTotal,
          event.dyMaxTotal
        );
        this._setScrollbarViewport(bounds); // always update the scrollbars
        if (actionDone) this._setViewport(bounds, actionDone);
      }

      if (actionDone) {
        // Event handlers have to be reset because the plot area space may change
        DvtChartRenderer._setEventHandlers(this);

        // Clear the touch target, if there's one
        if (this._panZoomTarget != this._plotArea) {
          this._container.removeChild(this._panZoomTarget);
          this._panZoomTarget = null;
        }
      }

      // Fire viewport change event
      if (actionDone || !bounds.unchanged) {
        var viewportChangeEvent;
        if (DvtChartTypeUtils.isBLAC(this))
          viewportChangeEvent = dvt.EventFactory.newChartViewportChangeEvent(
            actionDone,
            bounds.xMin,
            bounds.xMax,
            bounds.startGroup,
            bounds.endGroup,
            null,
            null
          );
        else
          viewportChangeEvent = dvt.EventFactory.newChartViewportChangeEvent(
            actionDone,
            bounds.xMin,
            bounds.xMax,
            null,
            null,
            bounds.yMin,
            bounds.yMax
          );

        this.dispatchEvent(viewportChangeEvent);
      }
    }

    /**
     * Processes marquee event.
     * @param {object} event Marquee event.
     * @return {object} Processed event.
     * @private
     */
    _processMarqueeEvent(event) {
      var subtype = event.subtype;
      var em = this.EventManager;
      var bounds; // chart bounds
      DvtChartEventUtils.adjustBounds(event);

      // Marquee selection
      if (em.getDragMode() === DvtChartEventManager.DRAG_MODE_SELECT) {
        var selectionHandler = em.getSelectionHandler();

        if (subtype === 'start') {
          // If ctrl key is pressed at start of drag, the previous selection should be preserved.
          this._initSelection = event.ctrlKey ? selectionHandler.getSelectedIds() : [];
        } else {
          var targets = DvtChartEventUtils.getBoundedObjs(this, event);
          selectionHandler.processInitialSelections(this._initSelection, this.getChartObjPeers());
          selectionHandler.processGroupSelection(targets, true);
        }

        // Create and populate selection event
        var selection = selectionHandler.getSelectedIds();
        bounds = DvtChartEventUtils.getAxisBounds(this, event, false);
        var bComplete = subtype === 'end' ? true : false;
        var selectionEvent = dvt.EventFactory.newChartSelectionEvent(
          selection,
          bComplete,
          bounds.xMin,
          bounds.xMax,
          bounds.startGroup,
          bounds.endGroup,
          bounds.yMin,
          bounds.yMax,
          bounds.y2Min,
          bounds.y2Max
        );

        // Update the selection in the overview bg chart
        if (subtype === 'end') this._updateOverviewSelection();

        return selectionEvent;
      }

      // Marquee zoom
      else if (em.getDragMode() === DvtChartEventManager.DRAG_MODE_ZOOM) {
        if (subtype != 'end') return null;

        // Compute and limit the bounds
        bounds = DvtChartEventUtils.getAxisBounds(this, event, true);
        this._setViewport(bounds, true);
        this._setScrollbarViewport(bounds);

        // Event handlers have to be reset because the plot area space may change
        DvtChartRenderer._setEventHandlers(this);

        if (DvtChartTypeUtils.isBLAC(this))
          return dvt.EventFactory.newChartViewportChangeEvent(
            true,
            bounds.xMin,
            bounds.xMax,
            bounds.startGroup,
            bounds.endGroup,
            null,
            null
          );
        else
          return dvt.EventFactory.newChartViewportChangeEvent(
            true,
            bounds.xMin,
            bounds.xMax,
            null,
            null,
            bounds.yMin,
            bounds.yMax
          );
      }

      return null;
    }

    /**
     * Processes scrollbar event (overview or simple scrollbar).
     * @param {number} start The min value.
     * @param {number} end The max value.
     * @param {boolean} actionDone Whether the scrolling has finished.
     * @param {object} source The component that is the source of the event, if available.
     * @return {object} Processed event.
     * @private
     */
    _processScrollbarEvent(start, end, actionDone, source) {
      // If there is not an existing event in the queue, request an animation frame to process the current event
      if (!this._lastScrollbarEvent)
        dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this._animateScrollbarEvent));

      this._lastScrollbarEvent = { start: start, end: end, actionDone: actionDone, source: source };

      return null; // viewportChange event is created and dispatched in the animate callback
    }

    /**
     * requestAnimationFrame callback to animate on scrollbar event.
     * It will rerender the chart based on the last scrollbar event that is fired since the last frame.
     * @private
     */
    _animateScrollbarEvent() {
      // Rerender the chart based on the last scrollbar event that is fired within the current animation frame
      var start = this._lastScrollbarEvent.start;
      var end = this._lastScrollbarEvent.end;
      var actionDone = this._lastScrollbarEvent.actionDone;
      var source = this._lastScrollbarEvent.source;
      this._lastScrollbarEvent = null; // nullify to indicate that the event has been processed

      var axis = source == this.yScrollbar ? this.yAxis : this.xAxis;
      var minMax = DvtChartEventUtils.getActualMinMax(axis, start, end);
      start = minMax.min;
      end = minMax.max;

      if (DvtChartBehaviorUtils.isLiveScroll(this) || actionDone) {
        if (source == this.yScrollbar) this._setViewport({ yMin: start, yMax: end }, actionDone);
        else this._setViewport({ xMin: start, xMax: end, unchanged: minMax.unchanged }, actionDone);
      }

      // Fire viewport change event
      if (actionDone || !minMax.unchanged) {
        var viewportChangeEvent;
        if (source == this.yScrollbar)
          viewportChangeEvent = dvt.EventFactory.newChartViewportChangeEvent(
            actionDone,
            null,
            null,
            null,
            null,
            start,
            end,
            null,
            null
          );
        else {
          var startEndGroup = DvtChartEventUtils.getAxisStartEndGroup(this.xAxis, start, end);
          viewportChangeEvent = dvt.EventFactory.newChartViewportChangeEvent(
            actionDone,
            start,
            end,
            startEndGroup.startGroup,
            startEndGroup.endGroup,
            null,
            null,
            null,
            null
          );
        }
        this.dispatchEvent(viewportChangeEvent);
      }
    }

    /**
     * Updates the selection in the overview background chart.
     * @private
     */
    _updateOverviewSelection() {
      if (this.overview) {
        var ovChart = this.overview.getBackgroundChart();
        ovChart.getOptions()['selection'] = DvtChartDataUtils.getCurrentSelection(this);
        ovChart.render(); // rerender because unselected markers were not rendered
      }
    }

    /**
     * Updates the chart option and fires the optionChange event.
     * @param {string} key The name of the option to set.
     * @param {Object} value The value to set for the option.
     * @param {Object} optionMetadata (optional) The option metadata for the event.
     */
    changeOption(key, value, optionMetadata) {
      this.getOptions()[key] = value;
      this.dispatchEvent(dvt.EventFactory.newOptionChangeEvent(key, value, optionMetadata));
    }

    /**
     * Registers the object peer with the chart.  The peer must be registered to participate
     * in interactivity.
     * @param {DvtChartObjPeer} peer
     */
    registerObject(peer) {
      this.Peers.push(peer);
    }

    /**
     * Returns the peers for all objects within the chart.
     * @return {array}
     */
    getObjects() {
      return this.Peers;
    }

    /**
     * Returns the peers for all chart objects within the chart.
     * @return {array}
     */
    getChartObjPeers() {
      var chartObjPeers = [];
      for (var i = 0; i < this.Peers.length; i++) {
        if (this.Peers[i] instanceof DvtChartObjPeer) chartObjPeers.push(this.Peers[i]);
      }
      return chartObjPeers;
    }

    /**
     * Returns the peers for all reference objects within the chart.
     * @return {array}
     */
    getRefObjPeers() {
      var refObjPeers = [];
      for (var i = 0; i < this.Peers.length; i++) {
        if (this.Peers[i] instanceof DvtChartRefObjPeer) refObjPeers.push(this.Peers[i]);
      }
      return refObjPeers;
    }

    /**
     * Returns the peer specified by the seriesIndex and groupIndex.
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @return {DvtChartObjPeer}
     */
    getObject(seriesIndex, groupIndex) {
      for (var i = 0; i < this.Peers.length; i++) {
        if (
          this.Peers[i] instanceof DvtChartObjPeer &&
          this.Peers[i].getSeriesIndex() === seriesIndex &&
          this.Peers[i].getGroupIndex() === groupIndex
        )
          return this.Peers[i];
      }
      return null;
    }

    /**
     * @return {number} chart width
     */
    getWidth() {
      return this.Width;
    }

    /**
     * @return {number} chart height
     */
    getHeight() {
      return this.Height;
    }

    /**
     * Returns the array containing unique series ids.  This array is used
     * to maintain default styles for each unique series.
     * @return {array}
     */
    getSeriesStyleArray() {
      return this.SeriesStyleArray;
    }

    /**
     * Returns the plot area container.
     * @return {dvt.Container}  the plot area container.
     */
    getPlotArea() {
      return this._plotArea;
    }

    /**
     * Sets the plot area container.
     * @param {dvt.Container} plot  the plot area container.
     */
    setPlotArea(plot) {
      this._plotArea = plot;
    }

    /**
     * Returns the type of this chart, such as "bar" or "scatter".
     * @return {string}
     */
    getType() {
      return this.getOptions()['type'];
    }

    /**
     * Returns the skin of this chart.
     * @return {string}
     */
    getSkin() {
      return this.getOptions()['skin'];
    }

    /**
     * Returns the scale factor for gap widths on this chart.
     * @return {number}
     */
    getGapWidthRatio() {
      // If defined in the options, use that instead
      var options = this.getOptions();
      if (options['layout']['gapWidthRatio'] !== null) return options['layout']['gapWidthRatio'];
      else return Math.min(this.Width / 400, 1);
    }

    /**
     * Returns the scale factor for gap heights on this chart.
     * @return {number}
     */
    getGapHeightRatio() {
      // If defined in the options, use that instead
      var options = this.getOptions();
      if (options['layout']['gapHeightRatio'] !== null) return options['layout']['gapHeightRatio'];
      else return Math.min(this.Height / 300, 1);
    }

    /**
     * Returns the selection handler for the graph.
     * @return {dvt.SelectionHandler} The selection handler for the graph
     */
    getSelectionHandler() {
      return this._selectionHandler;
    }

    /**
     * Returns whether selecton is supported on the graph.
     * @return {boolean} True if selection is turned on for the graph and false otherwise.
     */
    isSelectionSupported() {
      return this._selectionHandler ? true : false;
    }

    //---------------------------------------------------------------------//
    // Ordering Support: ZOrderManager impl                                //
    //---------------------------------------------------------------------//
    /**
     * Sets the chart viewport and rerender the axis and plot area.
     * @param {dvt.Rectangle} bounds An object containing the xMin, xMax, yMin, yMax of the new viewport.
     * @param {boolean} actionDone Whether the animation is done, so that the chart should be fully rendered.
     * @private
     */
    _setViewport(bounds, actionDone) {
      // If the bounds are unchanged, do not rerender the viewport unless the action is done
      if (!actionDone && bounds.unchanged) return;

      if (bounds.xMax != null) this.Options['xAxis']['viewportMax'] = bounds.xMax;
      if (bounds.xMin != null) this.Options['xAxis']['viewportMin'] = bounds.xMin;

      if (DvtChartTypeUtils.isBLAC(this)) {
        this.Options['xAxis']['viewportStartGroup'] = null;
        this.Options['xAxis']['viewportEndGroup'] = null;

        // Turn off initial zooming after pan/zoom
        this.Options['_initialZoomed'] = false;
      } else {
        if (bounds.yMax != null) this.Options['yAxis']['viewportMax'] = bounds.yMax;
        if (bounds.yMin != null) this.Options['yAxis']['viewportMin'] = bounds.yMin;
      }

      this.Options['_duringZoomAndScroll'] = !actionDone;
      DvtChartRenderer.rerenderAxisAndPlotArea(this, this._container);
    }

    /**
     * Sets the scrollbar viewport.
     * @param {dvt.Rectangle} bounds An object containing the xMin, xMax, yMin, yMax of the new viewport.
     * @private
     */
    _setScrollbarViewport(bounds) {
      if (this.xAxis && bounds.xMin != null && bounds.xMax != null) {
        var xMin = this.xAxis.actualToLinear(bounds.xMin);
        var xMax = this.xAxis.actualToLinear(bounds.xMax);
        var xGlobalMin = this.xAxis.getLinearGlobalMin();
        var xGlobalMax = this.xAxis.getLinearGlobalMax();
        if (this.overview) this.overview.setViewportRange(xMin, xMax);
        if (this.xScrollbar) {
          this.xScrollbar.setViewportRange(xMin, xMax, xGlobalMin, xGlobalMax);
        }
      }

      if (this.yAxis && bounds.yMin != null && bounds.yMax != null) {
        var yMin = this.yAxis.actualToLinear(bounds.yMin);
        var yMax = this.yAxis.actualToLinear(bounds.yMax);
        var yGlobalMin = this.yAxis.getLinearGlobalMin();
        var yGlobalMax = this.yAxis.getLinearGlobalMax();
        if (this.yScrollbar) {
          this.yScrollbar.setViewportRange(yMin, yMax, yGlobalMin, yGlobalMax);
        }
      }
    }

    /**
     * Sets the space for the axis and the plot area.
     * @param {dvt.Rectangle} space
     */
    __setAxisSpace(space) {
      this._axisSpace = space;

      // Set the polar chart radius
      var maxWidth, maxHeight;
      if (DvtChartAxisUtils.isAxisRendered(this, 'x')) {
        maxWidth = space.w * 0.8;
        maxHeight = space.h - 4 * DvtChartAxisUtils.getTickLabelHeight(this, 'x');
      } else if (DvtChartAxisUtils.isAxisRendered(this, 'y')) {
        maxWidth = space.w;
        maxHeight = space.h - DvtChartAxisUtils.getTickLabelHeight(this, 'y');
      } else {
        maxWidth = space.w;
        maxHeight = space.h;
      }
      this._radius = Math.min(maxWidth, maxHeight) / 2;
    }

    /**
     * Gets the space for the axis and the plot area.
     * @return {dvt.Rectangle} space
     */
    __getAxisSpace() {
      return this._axisSpace;
    }

    /**
     * Sets the space for the plot area.
     * @param {dvt.Rectangle} space
     */
    __setPlotAreaSpace(space) {
      this._plotAreaSpace = space;
    }

    /**
     * Gets the space for the plot area.
     * @return {dvt.Rectangle} space
     */
    __getPlotAreaSpace() {
      return this._plotAreaSpace;
    }

    /**
     * Sets the container of the chart area shapes.
     * @param {dvt.Container} container
     */
    __setAreaContainer(container) {
      this._areaContainer = container;
    }

    /**
     * Gets the container of the chart area shapes.
     * @return {dvt.Container} container
     */
    __getAreaContainer() {
      return this._areaContainer;
    }

    /**
     * Returns the radius of a polar chart.
     * @return {number} Polar chart radius.
     */
    getRadius() {
      return this._radius;
    }

    /**
     * Shows the drag buttons.
     */
    showDragButtons() {
      if (this.dragButtons) this.dragButtons.setVisible(true);
    }

    /**
     * Hides the drag buttons.
     */
    hideDragButtons() {
      if (this.dragButtons) this.dragButtons.setVisible(false);
    }

    /**
     * Adds a data label to the internal list of labels to help with animation.
     * @param {dvt.OutputText} label
     */
    addDataLabel(label) {
      this.getDataLabels().push(label);
    }

    /**
     * Provides the list of data labels so they can be animated.
     * @return {array} data labels in this chart
     */
    getDataLabels() {
      if (!this._dataLabels) this._dataLabels = [];
      return this._dataLabels;
    }

    /**
     * Cache the chart focus so it's not lost on rerender.
     * @return {object} Object containing the chart, legend and axis focus
     */
    __cacheChartFocus() {
      // Store the current chart and legend keyboard focus.
      var chartFocus = this.EventManager.getFocus();
      if (chartFocus) var chartShowingFocusEffect = chartFocus.isShowingKeyboardFocusEffect();
      if (this.xAxis) {
        var axisFocus = this.xAxis.getKeyboardFocus();
        if (axisFocus) var axisShowingFocusEffect = axisFocus.isShowingKeyboardFocusEffect();
      }
      if (this.legend) {
        var legendFocus = this.legend.getKeyboardFocus();
        if (legendFocus) var legendShowingFocusEffect = legendFocus.isShowingKeyboardFocusEffect();
      }
      return {
        chartFocus: chartFocus,
        chartShowingFocusEffect: chartShowingFocusEffect,
        axisFocus: axisFocus,
        axisShowingFocusEffect: axisShowingFocusEffect,
        legendFocus: legendFocus,
        legendShowingFocusEffect: legendShowingFocusEffect,
        sorting: this.getOptions()['sorting']
      };
    }

    /**
     * Restore the chart focus
     * @param {object} focusState Object containing the chart, legend and axis focus
     */
    __restoreChartFocus(focusState) {
      if (DvtChartTypeUtils.isOverview(this) || DvtChartTypeUtils.isSpark(this)) {
        return;
      }

      // Initialize the keyboard focus array with the new axis and legend
      var keyboardArray = [this];
      if (this.xAxis && this.xAxis.isNavigable()) keyboardArray.push(this.xAxis);
      if (this.legend && this.legend.isNavigable()) keyboardArray.push(this.legend);
      this.getCtx().setKeyboardFocusArray(keyboardArray);

      if (focusState.legendFocus) {
        this.legend.setKeyboardFocus(focusState.legendFocus, focusState.legendShowingFocusEffect);
        if (focusState.legendShowingFocusEffect) {
          this.getCtx().setCurrentKeyboardFocus(this.legend);
        }
      }

      // Restore the keyboard focus after rerendering.
      var sortChanged = this.Options['sorting'] != focusState['sorting'];
      if (sortChanged) {
        if (focusState.chartFocus) {
          var navigableList = DvtChartEventUtils.getKeyboardNavigables(this);
          this.EventManager.setFocusObj(
            this.EventManager.getKeyboardHandler().getDefaultNavigable(navigableList)
          );
        }
        if (focusState.axisFocus) {
          this.xAxis.setKeyboardFocus(
            this.xAxis.EventManager.getKeyboardHandler().getDefaultNavigable(
              this.xAxis.__getKeyboardObjects()
            ),
            focusState.axisShowingFocusEffect
          );
        }
        if (focusState.axisShowingFocusEffect) {
          this.getCtx().setCurrentKeyboardFocus(this.xAxis);
        }
        return;
      }
      if (focusState.chartFocus) {
        var navigables = DvtChartEventUtils.getKeyboardNavigables(this);
        var matchFound = false;
        for (var i = 0; i < navigables.length; i++) {
          var id = navigables[i].getId();
          if (id instanceof DvtChartDataItem && id.equals(focusState.chartFocus.getId())) {
            this.EventManager.setFocusObj(navigables[i]);
            if (focusState.chartShowingFocusEffect) navigables[i].showKeyboardFocusEffect();
            matchFound = true;
            break;
          }
        }
        if (!matchFound) {
          this.EventManager.setFocusObj(
            this.EventManager.getKeyboardHandler().getDefaultNavigable(navigables)
          );
        }
      }
      if (focusState.axisFocus) {
        this.xAxis.setKeyboardFocus(focusState.axisFocus, focusState.axisShowingFocusEffect);
        if (focusState.axisShowingFocusEffect) {
          this.getCtx().setCurrentKeyboardFocus(this.xAxis);
        }
      }
    }

    /**
     * Returns the user options before being processed and used to create the chart.
     * @return {object} User options.
     */
    getRawOptions() {
      return this._rawOptions;
    }
  }

  /**
   * Data context for an old chart during a data change animation.
   * @param {Chart} chart The actual chart, before being updated with the new data.
   * @class
   * @constructor
   * @extends {Chart}
   */
  class DvtChartDataChange extends Chart {
    constructor(chart) {
      super(null, null, null, true);
      this.Options = chart.Options;
      this.Peers = chart.Peers;
      this.SeriesStyleArray = chart.SeriesStyleArray;
      this.Cache = chart.Cache;
      this.pieChart = chart.pieChart;
      this._optionsCache = new dvt.BaseComponentCache();
      this._cache = new dvt.BaseComponentCache();
    }

    /**
     * Returns the cache. Cleared at anytime by component.
     * @return {object}
     */
    getCache() {
      return this._cache;
    }

    /**
     * Returns the options cache. Cleared only when the chart's options are reset.
     * @return {object}
     */
    getOptionsCache() {
      return this._optionsCache;
    }
  }

  /**
   *  Provides automation services for a DVT component.
   *  @class DvtSparkChartAutomation
   *  @param {SparkChart} dvtComponent
   *  @implements {dvt.Automation}
   *  @constructor
   */
  class DvtSparkChartAutomation extends dvt.Automation {
    /**
     * Returns an object containing data for a spark chart data item. Used for verification.
     * Valid verification values inlcude:
     * <ul>
     * <li>borderColor</li>
     * <li>color</li>
     * <li>date</li>
     * <li>floatValue</li>
     * <li>value/li>
     * </ul>
     * @param {String} itemIndex The index for a sparkChart dataItem
     * @return {Object} An object containing data for the dataItem
     */
    getDataItem(itemIndex) {
      // Retrieve the information from the chart automation.
      var chart = this._comp.__getChart();
      var dataItem = chart.getAutomation().getDataItem(0, itemIndex);

      // Population the spark automation results.
      if (dataItem) {
        return {
          borderColor: dataItem['borderColor'],
          color: dataItem['color'],
          date: dataItem['x'],
          low: dataItem['low'],
          high: dataItem['high'],
          value:
            dataItem['low'] == null || dataItem['high'] == null
              ? dataItem['value']
              : dataItem['high'] - dataItem['low']
        };
      }
      return null;
    }
  }

  /**
   * Default values and utility functions for chart versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {dvt.BaseComponentDefaults}
   */
  class DvtSparkChartDefaults extends dvt.BaseComponentDefaults {
    constructor(context) {
      /**
       * Defaults for version 1.
       */
      const SKIN_ALTA = {
        skin: dvt.CSSStyle.SKIN_ALTA,
        type: 'line',
        animationOnDisplay: 'none',
        animationOnDataChange: 'none',
        areaSvgClassName: '',
        emptyText: null,
        firstColor: '',
        lastColor: '',
        highColor: '',
        lowColor: '',
        visualEffects: 'auto',
        baselineScaling: 'min',
        barSpacing: 'auto',
        lineWidth: 1,
        lineStyle: 'solid',
        lineType: 'straight',
        markerSize: 5,
        markerShape: 'auto',
        barGapRatio: 0.25,
        referenceObjects: [],
        svgClassName: '',
        _statusMessageStyle: new dvt.CSSStyle('font-size: 12px; color: #404259;')
      };

      super({ alta: SKIN_ALTA }, context);
    }
  }

  /**
   * Event Manager for SparkChart.
   * @param {SparkChart} sparkChart
   * @class
   * @extends {dvt.EventManager}
   * @constructor
   */
  class DvtSparkChartEventManager extends dvt.EventManager {
    constructor(sparkChart) {
      super(sparkChart.getCtx(), sparkChart.dispatchEvent, sparkChart, sparkChart);
      this._sparkChart = sparkChart;
    }

    /**
     * @override
     */
    ProcessKeyboardEvent(event) {
      if (!this.KeyboardHandler) return false;

      if (event.keyCode == dvt.KeyboardEvent.TAB) {
        var pos = this._sparkChart.getCtx().getStageAbsolutePosition();
        this.ProcessObjectTooltip(
          event,
          pos.x,
          pos.y,
          this._sparkChart.__getLogicalObj(),
          this._sparkChart
        );
      }

      return false;
    }

    /**
     * @override
     */
    OnBlur(event) {
      super.OnBlur(event);
      this.hideTooltip();
    }
  }

  /**
   * Renderer for SparkChart.
   * @class
   */
  const DvtSparkChartRenderer = {
    /**
     * @this {DvtSparkChartRenderer}
     * Renders the spark chart in the specified area.
     * @param {SparkChart} spark The spark chart being rendered.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     */
    render: (spark, width, height) => {
      // Convert spark options into chart options
      var chart = spark.__getChart();
      var chartOptions = DvtSparkChartRenderer._convertOptionsObj(spark);

      // Allocate a gap for markers if they are enabled.
      var options = spark.getOptions();
      if (
        options['type'] == 'area' ||
        options['type'] == 'line' ||
        options['type'] == 'lineWithArea'
      ) {
        var items = DvtSparkChartRenderer._getDataItems(spark);
        var hasMarkers = false;

        // Look for the first/last/high/lowColor attributes, which cause markers to display
        if (
          options['firstColor'] ||
          options['lastColor'] ||
          options['highColor'] ||
          options['lowColor']
        )
          hasMarkers = true;
        else {
          // Loop through the data to look for markerDisplayed
          for (var i = 0; i < items.length; i++) {
            if (items[i] && items[i]['markerDisplayed'] == 'on') {
              hasMarkers = true;
              break;
            }
          }
        }

        // Allocate the gap if markers were found
        if ((hasMarkers && items.length > 0) || options['lineType'] == 'none') {
          var markerGap = options['markerSize'] / 2;
          width -= 2 * markerGap;
          height -= 2 * markerGap;
          chart.setTranslate(markerGap, markerGap);
        }
      }

      // Render the chart
      chart.render(chartOptions, width, height);
    },

    /**
     * Returns the array of spark data items.
     * @param {SparkChart} spark
     * @return {array}
     * @private
     */
    _getDataItems: (spark) => {
      var options = spark.getOptions();
      return options && options['items'] ? options['items'] : [];
    },

    /**
     * Converts the spark chart options object into a chart options object.
     * @param {SparkChart} spark The spark chart.
     * @return {object} The resulting chart options object.
     * @private
     */
    _convertOptionsObj: (spark) => {
      var options = spark.getOptions();
      var chartOptions = {
        styleDefaults: {},
        xAxis: {},
        yAxis: {},
        groups: [],
        translations: options['translations']
      };

      // Data Attributes
      var chartItems = [];

      // Loop through the data
      var highIndex = -1;
      var lowIndex = -1;
      var highValue = -Infinity;
      var lowValue = Infinity;
      var items = DvtSparkChartRenderer._getDataItems(spark);
      for (var i = 0; i < items.length; i++) {
        var item = items[i];

        // Parse the spark data item properties
        var chartItem = {};
        if (item instanceof Object) {
          chartItem['value'] = item['value'];
          chartItem['low'] = item['low'];
          chartItem['high'] = item['high'];

          // Time Axis Support
          if (item['date']) {
            chartOptions['timeAxisType'] = 'enabled';
            chartOptions['groups'].push(item['date']);
          }

          if (item['markerDisplayed'] == 'on') chartItem['markerDisplayed'] = 'on';

          if (item['color']) chartItem['color'] = item['color'];

          if (item['borderColor']) chartItem['borderColor'] = item['borderColor'];

          if (item['markerShape']) chartItem['markerShape'] = item['markerShape'];

          if (item['markerSize']) chartItem['markerSize'] = item['markerSize'];

          if (item['className'] || item['svgClassName'])
            chartItem['svgClassName'] = item['className'] || item['svgClassName'];

          if (item['style'] || item['svgStyle'])
            chartItem['svgStyle'] = item['style'] || item['svgStyle'];
        } else {
          // Item is just the value, wrap and push onto the array.
          chartItem['value'] = item;
        }

        // Push onto the array
        chartItems.push(chartItem);

        // Keep track of low and high values
        var topValue =
          chartItem['value'] != null
            ? chartItem['value']
            : Math.max(chartItem['low'], chartItem['high']);
        if (highValue < topValue) {
          highValue = topValue;
          highIndex = i;
        }

        var baseValue =
          chartItem['value'] != null
            ? chartItem['value']
            : Math.min(chartItem['low'], chartItem['high']);
        if (lowValue > baseValue) {
          lowValue = baseValue;
          lowIndex = i;
        }
      }

      // First/Last/High/LowColor Support: Process high and low first since they take precedence
      if (options['highColor'] && highIndex >= 0) {
        chartItems[highIndex]['markerDisplayed'] = 'on';
        if (!chartItems[highIndex]['color']) chartItems[highIndex]['color'] = options['highColor'];
      }

      if (options['lowColor'] && lowIndex >= 0) {
        chartItems[lowIndex]['markerDisplayed'] = 'on';
        if (!chartItems[lowIndex]['color']) chartItems[lowIndex]['color'] = options['lowColor'];
      }

      if (options['firstColor'] && chartItems.length > 0) {
        chartItems[0]['markerDisplayed'] = 'on';
        if (!chartItems[0]['color']) chartItems[0]['color'] = options['firstColor'];
      }

      if (options['lastColor'] && chartItems.length > 0) {
        chartItems[chartItems.length - 1]['markerDisplayed'] = 'on';
        if (!chartItems[chartItems.length - 1]['color'])
          chartItems[chartItems.length - 1]['color'] = options['lastColor'];
      }

      // Add the data items into a data object
      chartOptions['series'] = [
        {
          items: chartItems,
          areaColor: options['areaColor'],
          svgClassName: options['className'] || options['svgClassName'],
          svgStyle: options['style'] || options['svgStyle'],
          areaSvgClassName: options['areaClassName'] || options['areaSvgClassName'],
          areaStyle: options['areaStyle'] || options['areaSvgStyle']
        }
      ];

      // Reference Objects
      if (options['referenceObjects'] && options['referenceObjects'].length > 0) {
        chartOptions['yAxis']['referenceObjects'] = options['referenceObjects'];
        // pass in default reference object line width
        chartOptions._defaultReferenceObjectLineWidth = 1;
        var obj;
        for (var ii = 0; ii < options.referenceObjects.length; ii++) {
          obj = options.referenceObjects[ii];
          if (obj.type === 'area') {
            if (obj.high != null) {
              highValue = Math.max(highValue, obj.high);
              lowValue = Math.min(lowValue, obj.high);
            }
            if (obj.low != null) {
              highValue = Math.max(highValue, obj.low);
              lowValue = Math.min(lowValue, obj.low);
            }
          } else if (obj.value != null) {
            highValue = Math.max(highValue, obj.value);
            lowValue = Math.min(lowValue, obj.value);
          }
        }
      }

      // Style Attributes
      chartOptions['__spark'] = true;

      // barSpacing default is based on device
      var barSpacing = options['barSpacing'];
      if (barSpacing == 'auto')
        barSpacing = dvt.Agent.getDevicePixelRatio() > 1 ? 'subpixel' : 'pixel';
      chartOptions['__sparkBarSpacing'] = barSpacing;

      chartOptions['type'] = options['type'];
      chartOptions['animationOnDataChange'] = options['animationOnDataChange'];
      chartOptions['animationOnDisplay'] = options['animationOnDisplay'];
      chartOptions['emptyText'] = options['emptyText'];

      if (options['color']) chartOptions['styleDefaults']['colors'] = [options['color']];

      chartOptions['styleDefaults']['animationDuration'] = options['animationDuration'];
      chartOptions['styleDefaults']['animationIndicators'] = 'none';
      chartOptions['styleDefaults']['lineWidth'] = options['lineWidth'];
      chartOptions['styleDefaults']['lineStyle'] = options['lineStyle'];
      chartOptions['styleDefaults']['lineType'] = options['lineType'];
      chartOptions['styleDefaults']['markerSize'] = options['markerSize'];
      chartOptions['styleDefaults']['markerShape'] = options['markerShape'];
      chartOptions['styleDefaults']['barGapRatio'] = options['barGapRatio'];
      chartOptions['styleDefaults']['dataItemGaps'] = '0%';

      chartOptions['xAxis']['rendered'] = 'off';
      chartOptions['yAxis']['rendered'] = 'off';

      // Set Y-axis min and max
      var zeroBaseline = options['baselineScaling'] == 'zero';
      var axisGap = highValue != lowValue ? (highValue - lowValue) * 0.1 : Math.abs(highValue) * 0.1;
      chartOptions['yAxis']['min'] = zeroBaseline && lowValue >= 0 ? 0 : lowValue - axisGap;
      chartOptions['yAxis']['max'] = zeroBaseline && highValue <= 0 ? 0 : highValue + axisGap;

      // Visual Effects Support: Only for areas because gradients don't show up nicely for small bars
      if (
        options['visualEffects'] == 'none' ||
        !(options['type'] == 'area' || options['type'] == 'lineWithArea')
      )
        chartOptions['styleDefaults']['seriesEffect'] = 'color';
      else chartOptions['styleDefaults']['seriesEffect'] = 'gradient';

      // Remove Gaps
      chartOptions['layout'] = { gapWidthRatio: 0, gapHeightRatio: 0 };

      // Disable Legend
      chartOptions['legend'] = { rendered: 'off' };

      // Empty Text Style
      chartOptions['_statusMessageStyle'] = options['_statusMessageStyle'];

      return chartOptions;
    }
  };

  /**
   * Spark chart component.  This chart should never be instantiated directly.
   * @class
   * @constructor
   * @extends {dvt.BaseComponent}
   */
  class SparkChart extends dvt.BaseComponent {
    constructor(context, callback, callbackObj) {
      super(context, callback, callbackObj);

      //  - unable to get mouse pointer on spark chart
      context.getStage().setCursor('');

      // Create the defaults object
      this.Defaults = new DvtSparkChartDefaults(context);

      // Create the event handler and add event listeners
      this.EventManager = new DvtSparkChartEventManager(this);
      this.EventManager.addListeners(this);

      // Create the underlying chart instance for the component
      this._chart = new Chart(context, this._onRenderEnd, this);
      this.addChild(this._chart);

      // Add a keyboard handler to the spark chart itself so it can show tooltip on it
      this.EventManager.setKeyboardHandler(new dvt.KeyboardHandler(this.EventManager, this));

      // Create the masking shape used for the tooltip
      this._tooltipMask = new dvt.Rect(context);
      this.addChild(this._tooltipMask);

      // Make sure the object has an id for clipRect naming
      this.setId('sparkChart' + 1000 + Math.floor(Math.random() * 1000000000)); //@RandomNumberOK
    }

    /**
     * @override
     */
    SetOptions(options) {
      if (options) {
        // Combine the user options with the defaults and store
        this.Options = this.Defaults.calcOptions(options);

        if (dvt.Agent.isEnvironmentTest()) {
          this.Options['animationOnDisplay'] = 'none';
          this.Options['animationOnDataChange'] = 'none';
        }
      } else if (!this.Options) this.Options = this.GetDefaults();
    }

    /**
     * @override
     */
    setId(id) {
      super.setId(id);
      if (this._chart) this._chart.setId(id + 'chart');
    }

    /**
     * @override
     */
    render(options, width, height) {
      // Update if a new options object has been provided or initialize with defaults if needed.
      this.SetOptions(options);

      // Update the store width and height if provided
      if (!isNaN(width) && !isNaN(height)) {
        this.Width = width;
        this.Height = height;
      }
      this._eventReceived = false;
      this._isDoneRendering = false;

      // Render the spark chart
      DvtSparkChartRenderer.render(this, this.Width, this.Height);

      // Apply the tooltip
      var tooltip = this.Options['shortDesc'];
      this._tooltipMask.setWidth(this.Width);
      this._tooltipMask.setHeight(this.Height);
      this._tooltipMask.setInvisibleFill();
      var customTooltip = this.Options['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;
      var color = this.Options['color'];
      if (tooltipFunc) {
        var dataContext = {
          component: this.Options['_widgetConstructor'],
          color
        };
        this._peer = new dvt.CustomDatatipPeer(
          this.getCtx().getTooltipManager(),
          tooltipFunc,
          color,
          dataContext
        );
        this.EventManager.associate(this._tooltipMask, this._peer);
      } else if (tooltip) {
        this._peer = new dvt.SimpleObjPeer(null, tooltip, color);
        this.EventManager.associate(this._tooltipMask, this._peer);
      } else this._peer = null;

      if (this.Options['_selectingCursor']) {
        this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
      }

      this.UpdateAriaAttributes();

      if (this._eventReceived) {
        this.RenderComplete();
      }
      this._isDoneRendering = true;
    }

    /**
     * Sending the ready event at the end of a render.
     * @param {dvt.BaseEvent} event
     * @private
     */
    _onRenderEnd(event) {
      this._eventReceived = true;

      if (event['type'] == 'ready' && this._isDoneRendering) {
        this.RenderComplete();
      }
    }

    /**
     * Returns the underlying chart instance for the component.
     * @return {Chart} The underlying chart instance for this component.
     */
    __getChart() {
      return this._chart;
    }

    /**
     * Returns the automation object for this sparkChart
     * @return {dvt.Automation} The automation object
     */
    getAutomation() {
      return new DvtSparkChartAutomation(this);
    }

    /**
     * @override
     */
    UpdateAriaAttributes() {
      var isNoData = DvtChartDataUtils.hasInvalidData(this.__getChart());
      var translations = this.Options.translations;

      var desc = dvt.Displayable.generateAriaLabel(
        dvt.AriaUtils.processAriaLabel(this.GetComponentDescription()),
        [
          this.Options['shortDesc'] ? this.Options['shortDesc'] : null,
          isNoData ? translations.labelNoData : null
        ].filter(Boolean)
      );

      if (this.IsParentRoot()) {
        this.getCtx().setAriaRole('img');
        this.getCtx().setAriaLabel(
          dvt.ResourceUtils.format(translations.labelAndValue, [
            translations.labelDataVisualization,
            desc
          ])
        );
      } else {
        this.setAriaRole('img');
        this.setAriaProperty('label', desc);
      }
    }

    /**
     * Returns the logical object corresponding to the spark chart
     * @return {Object}
     */
    __getLogicalObj() {
      return this._peer;
    }
  }

  exports.Chart = Chart;
  exports.SparkChart = SparkChart;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojgauge-toolkit',['exports', 'ojs/ojdvt-toolkit', 'ojs/ojdvt-axis'], function (exports, dvt, ojdvtAxis) { 'use strict';

  /**
   * Style related utility functions for gauge components.
   * @class
   */
  const DvtGaugeDataUtils = {
    /**
     * Returns true if the specified chart has data.
     * @param {DvtGauge} gauge
     * @return {boolean}
     */
    hasData: (gauge) => {
      var options = gauge.getOptions();

      // Check that there is a data object with a valid value
      return options && options['value'] != null && DvtGaugeDataUtils.hasValidData(gauge);
    },

    /**
     * Returns true if the specified chart has valid data.
     * @param {DvtGauge} gauge
     * @return {boolean}
     */
    hasValidData: (gauge) => {
      var options = gauge.getOptions();
      // Check that the min and max are not equal to each other
      return Number(options['min']) < Number(options['max']);
    },

    hasUndefinedValue: (gauge) => {
      var options = gauge.getOptions();
      return options['value'] === null;
    },

    /**
     * Returns the index of the threshold corresponding to the gauge value.
     * @param {DvtGauge} gauge
     * @param {number} value Optional parameter for thresholdIndex of value that isn't the gauge value
     * @return {number} The index of the threshold definition or null if none is available.
     */
    getValThresholdIdx: (gauge, value) => {
      var options = gauge.getOptions();
      var gaugeValue = value != null ? value : options['value'];
      var thresholds = options['thresholds'];

      // Return -1 if no thresholds exist
      if (!thresholds) return -1;

      // Loop through and find the threshold
      for (var i = 0; i < thresholds.length; i++) {
        if (gaugeValue <= thresholds[i]['max']) return i;
      }

      // None found, but thresholds exist, this means the last threshold
      return thresholds.length - 1;
    },

    /**
     * Returns the specified threshold.
     * @param {DvtGauge} gauge
     * @param {number} index The index of the threshold.
     * @return {object} The threshold definition or null if none is available.
     */
    getThreshold: (gauge, index) => {
      var thresholds = gauge.getOptions()['thresholds'];

      if (thresholds && index >= 0 && index < thresholds.length) return thresholds[index];
      else return null;
    },

    /**
     * Returns the specified referenceObject.
     * @param {DvtGauge} gauge
     * @param {number} index The index of the referenceObject.
     * @return {object} The referenceObject definition or null if none is available.
     */
    getReferenceObject: (gauge, index) => {
      var options = gauge.getOptions();
      var referenceObjects = options['referenceLines'];
      if (referenceObjects && index >= 0 && index < referenceObjects.length)
        return referenceObjects[index];
      else return null;
    }
  };

  /**
   * Renderer for DvtGauge.
   * @class
   */
  const DvtGaugeRenderer = {
    /**
     * Renders the empty text for the component.
     * @param {DvtGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} availSpace The available space.
     */
    renderEmptyText: (gauge, container, availSpace) => {
      // Get the empty text string
      if (DvtGaugeDataUtils.hasUndefinedValue(gauge)) {
        return;
      }
      var options = gauge.getOptions();
      var translations = options.translations;
      var emptyTextStr = options['emptyText'];

      if (!DvtGaugeDataUtils.hasValidData(gauge)) emptyTextStr = translations.labelInvalidData;

      // Set font size
      var metricLabelStyle = options['_statusMessageStyle'];
      if (!metricLabelStyle.getStyle('font-size')) metricLabelStyle.setStyle('font-size', '13px');

      if (gauge.type === 'statusMeter') {
        var metricLabelColor = metricLabelStyle.getStyle('color');
        metricLabelColor = metricLabelColor ? metricLabelColor : '#333333';
        metricLabelStyle.setStyle('color', metricLabelColor);
      }

      gauge.renderEmptyText(
        container,
        emptyTextStr,
        new dvt.Rectangle(availSpace.x, availSpace.y, availSpace.w, availSpace.h),
        gauge.getEventManager(),
        metricLabelStyle
      );
    },

    /**
     * Formats gauge metricLabel.
     * @param {float} value The value to render into.
     * @param {Object} gauge The gauge.
     * @return {string} The formatted metric label string
     */
    getFormattedMetricLabel: (value, gauge) => {
      var options = gauge.getOptions();
      if (options['metricLabel']['text']) return options['metricLabel']['text'];

      var converter = options['metricLabel']['converter'];
      var scaling = options['metricLabel']['scaling'];
      var autoPrecision = options['metricLabel']['autoPrecision']
        ? options['metricLabel']['autoPrecision']
        : 'on';
      var isPercent = options['metricLabel']['textType'] === 'percent';
      return DvtGaugeRenderer._formatMetricLabelValue(
        value,
        gauge,
        converter,
        scaling,
        autoPrecision,
        isPercent
      );
    },

    /**
     * Formats gauge metricLabel.
     * @param {float} value The value to render into.
     * @param {Object} gauge The gauge.
     * @param {object} converter The converter object to use for formatting
     * @param {string} scaling The scale used for formatting the number
     * @param {string} autoPrecision "on" if auto precision should be applied otherwise "off"; if null or undefined then auto precision is applied.
     * @param {boolean} isPercent Specifies whether we should use percent formatting for this metricLabel.
     * @return {string} The formatted string value for this metricLabel
     * @private
     */
    _formatMetricLabelValue: (value, gauge, converter, scaling, autoPrecision, isPercent) => {
      var options = gauge.getOptions();

      var minValue = options['min'];
      var maxValue = options['max'];
      var output;

      var difference = maxValue - minValue;
      var divider = difference < 1000 ? 100 : 1000;
      var increment = null;
      if (!isNaN(difference)) increment = difference / divider;

      if (isPercent) {
        value = DvtGaugeRenderer.getFillPercentage(
          options,
          options['min'],
          options['max'],
          value,
          true
        );
      }

      // when scaling is set then init formatter
      var formatter = new ojdvtAxis.LinearScaleAxisValueFormatter(
        minValue,
        maxValue,
        increment,
        scaling,
        autoPrecision,
        options.translations
      );
      if (converter && converter['format']) output = formatter.format(value, converter);
      else if (isPercent) {
        var percentConverter = gauge.getCtx().getNumberConverter({
          style: 'percent',
          maximumFractionDigits: 0,
          minimumFractionDigits: 0
        });
        if (percentConverter && percentConverter['format']) {
          output = percentConverter['format'](value);
        } else {
          output = String(Math.round(value * 100)) + '%';
        }
      } else output = formatter.format(value);

      return output;
    },

    /**
     * Determine percent of total area to fill
     * @param {object} options The object containing the data.
     * @param {number} min Min value.
     * @param {number} max Max value.
     * @param {number} value Value to draw to.
     * @param {boolean} unbound Specifies whether to not bound the return value by 0 and 1
     * @return {number} Percent of the area filled
     */
    getFillPercentage: (options, min, max, value, unbound) => {
      var percentFill = (value - min) / (options['max'] - options['min']);
      percentFill = unbound ? percentFill : Math.min(Math.max(0, percentFill), 1);
      return percentFill;
    },

    /**
     * Returns the tooltip string for the specified gauge.
     * @param {DvtGauge} gauge
     * @return {string}
     */
    getTooltipString: (gauge) => {
      var options = gauge.getOptions();
      var thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(gauge);
      var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
      var metricValue = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
      // Tooltip is based on the threshold shortDesc, top level shortDesc, or metric label. Check null to allow suppression.
      if (threshold && threshold['shortDesc'] != null) return threshold['shortDesc'];
      else if (options['shortDesc'] != null) return options['shortDesc'];
      else if (options['label']['text'])
        return dvt.ResourceUtils.format(options.translations.labelAndValue, [
          options['label']['text'],
          metricValue
        ]);
      // Use the formatted metric label
      else return metricValue;
    },

    /**
     * Renders the metricLabel into the specified area.
     * @param {DvtGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {color} color MetricLabel color
     * @param {string} halign The horizontal alignment
     * @param {string} valign The vertical alignment
     * @param {boolean=} isRenderedByDefault Whether the metricLabel is rendered by default. Defaults to false.
     * @return {boolean} Return true if the label is rendered
     */
    renderMetricLabel: (gauge, container, bounds, color, halign, valign, isRenderedByDefault) => {
      var options = gauge.getOptions();
      var rendered = false;

      // Create and position the metricLabel
      if (
        options['metricLabel']['rendered'] === 'on' ||
        (isRenderedByDefault && options['metricLabel']['rendered'] !== 'off')
      ) {
        var metricLabelString = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
        var minString = DvtGaugeRenderer.getFormattedMetricLabel(options['min'], gauge);
        var maxString = DvtGaugeRenderer.getFormattedMetricLabel(options['max'], gauge);

        // Create the label and align
        var metricLabel = new dvt.OutputText(
          gauge.getCtx(),
          metricLabelString,
          bounds.x + bounds.w / 2,
          bounds.y + bounds.h / 2
        );
        metricLabel.setCSSStyle(options['metricLabel']['style']);
        var size = options['metricLabel']['style'].getStyle('font-size');
        if (!size) {
          size = DvtGaugeRenderer.calcLabelFontSize(
            [metricLabelString, minString, maxString],
            metricLabel,
            bounds
          );
          metricLabel.setTextString(metricLabelString);
          metricLabel.setFontSize(size);
        }

        if (valign === 'top') {
          metricLabel.setY(bounds.y);
          metricLabel.alignTop();
        } else if (valign === 'middle') {
          dvt.TextUtils.centerTextVertically(metricLabel, bounds.y + bounds.h / 2);
        } else if (valign === 'bottom') {
          metricLabel.setY(bounds.y + bounds.h);
          metricLabel.alignBottom();
        }

        if (halign === 'center') metricLabel.alignCenter();
        else if (halign == 'left') {
          metricLabel.setX(bounds.x);
          metricLabel.alignLeft();
        } else if (halign === 'right') {
          metricLabel.setX(bounds.x + bounds.w);
          metricLabel.alignRight();
        }

        // Set color
        if (color != null) metricLabel.setSolidFill(color);

        // Truncate if needed, null is returned if the label doesn't fit
        rendered = dvt.TextUtils.fitText(metricLabel, bounds.w, bounds.h, container);
      }
      return rendered;
    },

    /**
     * Renders the label into the specified area.
     * @param {DvtGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {color} color Label color
     * @param {string} valign The vertical alignment
     * @return {boolean} Return true if the label is rendered
     */
    renderLabel: (gauge, container, bounds, color, valign) => {
      var options = gauge.getOptions();
      var rendered = false;

      // Create and position the metricLabel
      if (options['label']['text']) {
        var labelString = options['label']['text'];
        var labelStyle = options['label']['style'];
        var label = new dvt.MultilineText(gauge.getCtx(), labelString);
        var fontStyle = labelStyle.clone();
        label.setCSSStyle(labelStyle);
        var size =
          labelStyle.getStyle('font-size') ||
          dvt.TextUtils.getOptimalFontSize(
            label.getCtx(),
            label.getTextString(),
            label.getCSSStyle(),
            bounds
          );
        fontStyle.setFontSize('font-size', size, gauge.getCtx());

        // Set color
        if (color != null) fontStyle.setStyle('color', color);

        label.setCSSStyle(fontStyle);
        rendered = dvt.TextUtils.fitText(label, bounds.w, bounds.h, gauge);

        var textHeight = label.getDimensions().h;
        if (valign === 'top') label.setY(bounds.y);
        else if (valign === 'bottom') label.setY(bounds.y + bounds.h - textHeight);
        else label.setY(bounds.y + bounds.h / 2 - textHeight / 2);

        label.setX(bounds.x + bounds.w / 2);
        label.alignCenter();
        container.addChild(label);
      }
      return rendered;
    },

    /**
     * Returns the optimal font size based on a list of labels and the available bounds
     * @param {Array} labels A list of label strings used to find the optimal string size for the label
     * @param {dvt.OutputText} label The text object used to get the optimal size
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @return {string} The optimal font size with the unit 'px'
     */
    calcLabelFontSize: (labels, label, bounds) => {
      var maxWidth = 0;
      var maxLabel = null;
      var width = 0;
      for (var i = 0; i < labels.length; i++) {
        label.setTextString(labels[i]);
        width = label.getDimensions().w;
        if (width > maxWidth) {
          maxLabel = labels[i];
          maxWidth = width;
        }
      }
      label.setTextString(maxLabel);
      return dvt.TextUtils.getOptimalFontSize(
        label.getCtx(),
        label.getTextString(),
        label.getCSSStyle(),
        bounds
      );
    },

    /**
     * Get step adjusted value.
     * @param {object} options The object containing the data.
     * @param {number} value Current value
     * @return {number} Adjusted value
     */
    adjustForStep: (options, value) => {
      var step = Number(options['step']);
      if (step && step > 0) {
        var stepNum = value / step;

        // If the min is 0 stars, we should allocate the first half of the star for the 0 value in order to give it
        // some selection space.
        if (stepNum < 0.5) return options['min'];
        else {
          var adjustedValue = Math.ceil(stepNum) * step;
          return Math.max(Math.min(options['max'], adjustedValue), options['min']);
        }
      }
      return value;
    }
  };

  /**
   *  Provides automation services for a DVT component.
   *  @class DvtGaugeAutomation
   *  @param {DvtGauge} dvtComponent
   *  @implements {dvt.Automation}
   *  @constructor
   */
  class DvtGaugeAutomation extends dvt.Automation {
    /**
     * Valid subIds inlcude:
     * <ul>
     * <li>tooltip</li>
     * </ul>
     * @override
     */
    getDomElementForSubId(subId) {
      if (subId === dvt.Automation.TOOLTIP_SUBID) return this.GetTooltipElement(this._comp);
      else if (subId.indexOf('item') === 0) {
        var openParen = subId.indexOf('[');
        var closeParen = subId.indexOf(']');

        if (openParen > 0 && closeParen > 0) {
          var index = subId.substring(openParen + 1, closeParen);
          var item = this._comp.__getRatingGaugeItem(index);
          if (item) return item.getElem();
        }
      }
      return null;
    }

    /**
     * @override
     */
    GetSubIdForDomElement(displayable) {
      var gauge = this._comp;
      var options = gauge.getOptions();
      for (var i = 0; i < options['max']; i++) {
        var item = gauge.__getRatingGaugeItem(i);
        if (item === displayable) {
          return 'item[' + i + ']';
        }
      }
      return null;
    }

    /**
     * Returns the value of the gauge. Used for verification.
     * @return {Number} the value of the gauge
     */
    getValue() {
      return this._comp.getOptions()['value'];
    }

    /**
     * Returns the formatted metric label of the gauge. Used for verification.
     * Valid only for DialGauge, LedGauge, and StatusMeterGauge.
     * @return {String} the formatted metric label string
     */
    getMetricLabel() {
      return DvtGaugeRenderer.getFormattedMetricLabel(this.getValue(), this._comp);
    }
  }

  /**
   * Event Manager for DvtGauge.
   * @param {DvtGauge} gauge
   * @class
   * @extends {dvt.EventManager}
   * @constructor
   */
  class DvtGaugeEventManager extends dvt.EventManager {
    constructor(gauge) {
      super(gauge.getCtx(), gauge.dispatchEvent, gauge, gauge);
      this._gauge = gauge;
      this.IsMouseEditing = false;
    }

    /**
     * @override
     */
    OnMouseDown(event) {
      // Set the editing flag so moves are tracked
      if (this._gauge.IsInteractive()) {
        this.IsMouseEditing = true;
        this.hideTooltip();
        var coords = this.GetRelativePosition(event.pageX, event.pageY);
        this._gauge.__processValueChangeStart(coords.x, coords.y);
        //  - Need to prevent default because of firefox issue
        event.preventDefault();
      } // Don't call super if editing, just handle it in this subclass
      else super.OnMouseDown(event);
    }

    /**
     * @override
     */
    OnMouseUp(event) {
      // Reset the editing flag
      if (this.IsMouseEditing) {
        this.StopMouseEditing(event);
      } // Don't call super if editing, just handle it in this subclass
      else super.OnMouseUp(event);
    }

    /**
     * @override
     */
    OnMouseMove(event) {
      // Only process move events when editing
      if (this.IsMouseEditing) {
        var coords = this.GetRelativePosition(event.pageX, event.pageY);
        this._gauge.__processValueChangeMove(coords.x, coords.y);
      }
      if (this.IsShowingTooltipWhileEditing() || !this.IsMouseEditing) super.OnMouseMove(event);
    }

    /**
     * Controls whether the tooltip shows up on hover/mousemove
     * @return {boolean}
     */
    IsShowingTooltipWhileEditing() {
      return false;
    }

    /**
     * @override
     */
    PreEventBubble(event) {
      var coords;
      if (dvt.TouchEvent.TOUCHSTART === event.type && this._gauge.IsInteractive()) {
        // Set the editing flag so moves are tracked
        this.IsMouseEditing = true;
        coords = this.GetRelativePosition(event.touches[0].pageX, event.touches[0].pageY);
        this._gauge.__processValueChangeStart(coords.x, coords.y);

        // Prevent default action from occuring
        event.preventDefault();
      } else if (dvt.TouchEvent.TOUCHMOVE === event.type && this.IsMouseEditing) {
        coords = this.GetRelativePosition(event.touches[0].pageX, event.touches[0].pageY);
        this._gauge.__processValueChangeMove(coords.x, coords.y);

        // Prevent default action from occuring
        event.preventDefault();
      } else if (dvt.TouchEvent.TOUCHEND === event.type && this.IsMouseEditing) {
        this.IsMouseEditing = false;
        coords = this.GetRelativePosition(
          event.changedTouches[0].pageX,
          event.changedTouches[0].pageY
        );
        this._gauge.__processValueChangeEnd(coords.x, coords.y);

        // Prevent default action from occuring
        event.preventDefault();
      }
      // If editing, only show tooltip if it is enabled
      if (!this.IsMouseEditing || this.IsShowingTooltipWhileEditing()) super.PreEventBubble(event);
    }

    /**
     * @override
     */
    ProcessKeyboardEvent(event) {
      if (!this.KeyboardHandler) return false;

      this.KeyboardHandler.processKeyDown(event);
      var keyCode = event.keyCode;

      if (
        keyCode === dvt.KeyboardEvent.UP_ARROW ||
        keyCode === dvt.KeyboardEvent.LEFT_ARROW ||
        keyCode === dvt.KeyboardEvent.DOWN_ARROW ||
        keyCode === dvt.KeyboardEvent.RIGHT_ARROW ||
        keyCode === dvt.KeyboardEvent.TAB
      ) {
        var pos = this._gauge.getCtx().getStageAbsolutePosition();
        this.ProcessObjectTooltip(event, pos.x, pos.y, this._gauge.__getLogicalObject(), this._gauge);
      }

      return false;
    }

    /**
     * @override
     */
    OnBlur(event) {
      super.OnBlur(event);
      this.hideTooltip();
    }

    /**
     * Returns the position of the specified page coords, relative to the component.
     * @param {number} pageX
     * @param {number} pageY
     * @return {dvt.Point}
     * @protected
     */
    GetRelativePosition(pageX, pageY) {
      var stageCoords = this.getCtx().pageToStageCoords(pageX, pageY);
      return this._gauge.stageToLocal(stageCoords);
    }

    /**
     * @override
     */
    UpdateActiveElement(obj, displayable) {
      // noop: Gauges manage their own WAI-ARIA properties and should not participate in default event manager support.
    }

    /**
     * Returns whether we are currenctly editing by mouse or touch. Used to decide which tooltip to show for rating gauge.
     * @return {boolean}
     */
    __isMouseEditing() {
      return this.IsMouseEditing;
    }

    /**
     * Processes end of hover state and sets mouse edit flag to false
     * @param {event} event
     */
    StopMouseEditing(event) {
      this.IsMouseEditing = false;
      var coords = this.GetRelativePosition(event.pageX, event.pageY);
      this._gauge.__processValueChangeEnd(coords.x, coords.y);
    }
  }

  /**
   * @param {dvt.EventManager} manager The owning dvt.EventManager
   * @param {DvtGauge} gauge
   * @class DvtGaugeKeyboardHandler
   * @extends {dvt.KeyboardHandler}
   * @constructor
   */
  class DvtGaugeKeyboardHandler extends dvt.KeyboardHandler {
    constructor(manager, gauge) {
      super(manager);
      this._gauge = gauge;
    }

    /**
     * @override
     */
    processKeyDown(event) {
      // Note: Don't call superclass so that the arrow key behaviors are not overridden
      var keyCode = event.keyCode;
      var isR2L = dvt.Agent.isRightToLeft(this._gauge.getCtx());
      var value = this._gauge.getOptions()['value'];
      if (!this._gauge.getOptions()['readOnly'] && !this._gauge.getOptions()['disabled']) {
        if (
          (keyCode === dvt.KeyboardEvent.ENTER || keyCode === dvt.KeyboardEvent.TAB) &&
          this._oldValue !== value
        ) {
          this._gauge.dispatchEvent(
            dvt.EventFactory.newValueChangeEvent(this._oldValue, value, true)
          );
          this._oldValue = null;
        } else if (
          keyCode === dvt.KeyboardEvent.UP_ARROW ||
          keyCode === (isR2L ? dvt.KeyboardEvent.LEFT_ARROW : dvt.KeyboardEvent.RIGHT_ARROW)
        ) {
          this._gauge.__increaseValue();
          dvt.EventManager.consumeEvent(event);
        } else if (
          keyCode === dvt.KeyboardEvent.DOWN_ARROW ||
          keyCode === (isR2L ? dvt.KeyboardEvent.RIGHT_ARROW : dvt.KeyboardEvent.LEFT_ARROW)
        ) {
          this._gauge.__decreaseValue();
          dvt.EventManager.consumeEvent(event);
        }

        if (this._oldValue === null) this._oldValue = value;
      }
    }
  }

  /**
   * Style related utility functions for gauge components.
   * @class
   */
  const DvtGaugeStyleUtils = {
    /**
     * Returns the color, taking into account the thresholds if specified.
     * @param {DvtGauge} gauge
     * @return {string} The color of the gauge.
     */
    getColor: (gauge) => {
      // Options Object
      var options = gauge.getOptions();

      // Thresholds
      var thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(gauge);
      var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
      if (
        threshold &&
        (!(gauge.type === 'statusMeter') ||
          (gauge.type === 'statusMeter' && options['thresholdDisplay'] === 'onIndicator'))
      ) {
        return DvtGaugeStyleUtils.getThresholdColor(gauge, threshold, thresholdIndex);
      }

      return options['color'];
    },

    /**
     * Returns the border color, taking into account the thresholds if specified.
     * @param {DvtGauge} gauge
     * @return {string} The border color of the gauge.
     */
    getBorderColor: (gauge) => {
      // Options Object
      var options = gauge.getOptions();

      // Thresholds
      var thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(gauge);
      var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);

      if (
        threshold &&
        threshold['borderColor'] &&
        (!(gauge.type === 'statusMeter') ||
          (gauge.type === 'statusMeter' && options['thresholdDisplay'] === 'onIndicator'))
      )
        return threshold['borderColor'];

      return options['borderColor'];
    },

    /**
     * Returns the color, taking into account the thresholds if specified.
     * @param {DvtGauge} gauge
     * @return {string} The color of the gauge.
     */
    getPlotAreaColor: (gauge) => {
      // Options Object
      var options = gauge.getOptions();

      // Thresholds
      var thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(gauge);
      var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
      if (
        threshold &&
        (!(gauge.type === 'statusMeter') ||
          (gauge.type === 'statusMeter' && options['thresholdDisplay'] !== 'onIndicator'))
      ) {
        return DvtGaugeStyleUtils.getThresholdColor(gauge, threshold, thresholdIndex);
      }

      return options['plotArea']['color'];
    },

    /**
     * Returns the color, taking into account the thresholds if specified.
     * @param {DvtGauge} gauge
     * @return {string} The border color of the gauge.
     */
    getPlotAreaBorderColor: (gauge) => {
      // Options Object
      var options = gauge.getOptions();
      var borderColor = options['plotArea']['borderColor'];
      if (gauge.type === 'statusMeter' && options['orientation'] == 'circular') {
        return null;
      }
      return borderColor;
    },

    /**
     * Returns the defined threshold color or gets it from the threshold color ramp
     * @param {DvtGauge} gauge
     * @param {object} threshold
     * @param {number} thresholdIndex
     * @return {string} The Threshold color of the gauge.
     */
    getThresholdColor: (gauge, threshold, thresholdIndex) => {
      if (threshold['color']) return threshold['color'];
      // Style Defaults
      var options = gauge.getOptions();
      var defaultColors = options['_thresholdColors'];
      var colorIndex = thresholdIndex % defaultColors.length;
      return options['_thresholdColors'][colorIndex];
    }
  };

  /**
   * Abstract Base Class for Gauge component.
   * @class
   * @constructor
   * @extends {dvt.BaseComponent}
   */
  class DvtGauge extends dvt.BaseComponent {
    constructor(context, callback, callbackObj, bStaticRendering) {
      super(context, callback, callbackObj);

      //  - unable to get cursor on gauges
      context.getStage().setCursor('');

      // If non-interactive, we can skip the following
      this._bStaticRendering = bStaticRendering;
      if (!this._bStaticRendering) {
        // Create the event handler and add event listeners
        this.EventManager = this.CreateEventManager();
        this.EventManager.addListeners(this);

        // Set up keyboard handler
        this.EventManager.setKeyboardHandler(this.CreateKeyboardHandler(this.EventManager));

        // Make sure the object has an id for clipRect naming
        this.setId('gauge' + 1000 + Math.floor(Math.random() * 1000000000)); //@RandomNumberOK

        // Create an editing overlay to prevent touch conflicts
        this._editingOverlay = new dvt.Rect(context, 0, 0);
        this._editingOverlay.setInvisibleFill();
        this.addChild(this._editingOverlay);
      }

      /** @private **/
      this._bEditing = false;

      /** @private **/
      this._bResizeRender = false;

      /** @private **/
      this._oldValue = null;
    }

    SetOptions(options) {
      super.SetOptions(options);
      this.Options = options;

      if (dvt.Agent.isEnvironmentTest()) {
        this.Options['animationOnDisplay'] = 'none';
        this.Options['animationOnDataChange'] = 'none';
      }

      //  - Disable gradient overlay by default for IE
      if (
        (dvt.Agent.browser === 'ie' || dvt.Agent.browser === 'edge') &&
        this.Options['visualEffects'] === 'auto'
      ) {
        this.Options['visualEffects'] = 'none';
      }

      if (options['className']) {
        this.Options['svgClassName'] = options['className'];
      }

      if (options['style']) {
        this.Options['svgStyle'] = options['style'];
      }
    }

    render(options, width, height) {
      // Update if a new options object has been provided or initialize with defaults if needed.
      if (options) {
        this.SetOptions(options);
      } else if (!this.Options) {
        this.SetOptions(null);
      }

      // Sort the thresholds by value if defined
      if (this.Options['thresholds']) {
        var thresholds = this.Options['thresholds'];
        this.Options['thresholds'] = thresholds.sort(DvtGauge._thresholdComparator);
      }

      // Update the store width and height if provided
      if (typeof width === 'number' && typeof height === 'number') {
        // Turn off animation if the gauge is being resized
        if (
          (this.Width !== 0 && this.Width !== width) ||
          (this.Height !== 0 && this.Height !== height)
        ) {
          this._bResizeRender = true;
        } else {
          this._bResizeRender = false;
        }

        this.Width = width;
        this.Height = height;
      }

      this.__oldShapes = this.__shapes;
      this.__shapes = [];

      // Render the gauge.  Add the container at index 0 to avoid interfering with the editable overlay.
      var container = new dvt.Container(this.getCtx());
      this.addChildAt(container, 0);
      var isRenderComplete = this.Render(container, this.Width, this.Height) !== false;
      if (isRenderComplete) {
        this.PostRender(options, container);
      }
    }

    /**
     * Post processing after gauge is rendered.
     * @param {object} options component options
     * @param {dvt.Container} container The container to render within.
     * @protected
     */
    PostRender(options, container) {
      this._setAnimation(container, options != null, this.__oldShapes, this.Width, this.Height);

      // Set the size of the editing overlay if editable
      if (this._editingOverlay) {
        this._editingOverlay.setWidth(this.Width);
        this._editingOverlay.setHeight(this.Height);

        // Tooltip support
        this.getEventManager().associate(this._editingOverlay, this.__getLogicalObject(), true);
      }

      this.UpdateAriaAttributes();

      if (!this._bStaticRendering && !this.Options['readOnly']) {
        this.setAriaAttributes();
      }

      // . To support ADF action attribute
      if (this.Options['_selectingCursor']) {
        this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
      }

      if (!this.Animation) {
        // If not animating, that means we're done rendering, so fire the ready event.
        this.RenderComplete();
      }
    }

    setAriaAttributes() {
      var parentContainer = this.getCtx().getContainer();
      parentContainer.setAttribute('role', 'slider');
      parentContainer.setAttribute('aria-valuemin', this.Options['min']);
      parentContainer.setAttribute('aria-valuemax', this.Options['max']);

      if (this.Options['value'] != null) {
        var valueText = DvtGaugeRenderer.getFormattedMetricLabel(this.Options['value'], this);
        if (Number(valueText) === this.Options['value']) valueText = this.Options['value'].toString();
        parentContainer.setAttribute('aria-valuetext', valueText);
        parentContainer.setAttribute('aria-valuenow', this.Options['value']);
      }
      if (this.Options['disabled']) {
        parentContainer.setAttribute('aria-disabled', true);
        parentContainer.setAttribute('tabindex', '-1');
      }
    }

    /**
     * Creates and returns a logical object for this gauge.
     * @return {dvt.SimpleObjPeer}
     */
    __getLogicalObject() {
      var customTooltip = this.Options['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;
      var color = DvtGaugeStyleUtils.getColor(this);
      if (tooltipFunc) {
        var dataContext = {
          component: this.Options['_widgetConstructor'],
          label: DvtGaugeRenderer.getFormattedMetricLabel(this.Options['value'], this),
          color: color
        };
        return new dvt.CustomDatatipPeer(
          this.getCtx().getTooltipManager(),
          tooltipFunc,
          color,
          dataContext
        );
      }
      var tooltip = DvtGaugeRenderer.getTooltipString(this);
      return new dvt.SimpleObjPeer(null, tooltip, color);
    }

    /**
     * Renders the component at the specified size.
     * @param {dvt.Container} container The container to render within.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     */
    Render(container, width, height) {
      // subclasses should override
    }

    /**
     * Checks animation settings for the gauge and creates and plays animation on display
     * or animation on data change.
     * @param {dvt.Container} container The container to render within.
     * @param {boolean} bData True if new data was provided to the gauge.
     * @param {Array} oldShapes The array of DvtShapes that can be animated
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     * @private
     */
    _setAnimation(container, bData, oldShapes, width, height) {
      // Stop any animation in progress before starting new animation
      this.StopAnimation();

      var bBlackBoxUpdate = false;
      var animationOnDataChange =
        this._bEditing || this._bResizeRender ? 'none' : this.getOptions()['animationOnDataChange'];
      var animationOnDisplay =
        this._bEditing || this._bResizeRender ? 'none' : this.getOptions()['animationOnDisplay'];
      var animationDuration =
        dvt.CSSStyle.getTimeMilliseconds(this.getOptions()['animationDuration']) / 1000;

      if (!animationOnDisplay && !animationOnDataChange) return;

      var bounds = new dvt.Rectangle(0, 0, width, height);
      var context = this.getCtx();

      if (!this._container && animationOnDisplay !== 'none' && this.__shapes[0] != null) {
        // animationOnDisplay
        this.Animation = dvt.BlackBoxAnimationHandler.getInAnimation(
          context,
          animationOnDisplay,
          container,
          bounds,
          animationDuration
        );
        if (!this.Animation)
          this.Animation = this.CreateAnimOnDisplay(
            this.__shapes,
            animationOnDisplay,
            animationDuration
          );
      } else if (
        this._container &&
        animationOnDataChange !== 'none' &&
        bData &&
        this.__shapes[0] != null
      ) {
        // animationOnDataChange
        this.Animation = dvt.BlackBoxAnimationHandler.getCombinedAnimation(
          context,
          animationOnDataChange,
          this._container,
          container,
          bounds,
          animationDuration
        );
        if (this.Animation) bBlackBoxUpdate = true;
        else
          this.Animation = this.CreateAnimOnDataChange(
            oldShapes,
            this.__shapes,
            animationOnDisplay,
            animationDuration
          );
      }

      if (!bBlackBoxUpdate && this._container) {
        this.removeChild(this._container);
        this._container.destroy();
      }

      if (this.Animation) {
        this.Animation.play();
        this.Animation.setOnEnd(this._onAnimEnd, this);
      }

      if (bBlackBoxUpdate) this._oldContainer = this._container;

      this._container = container;
    }

    /**
     * Creates a dvt.Playable that performs animation upon inital gauge display.
     * @param {Array} objs The array of DvtShapes to animate to.
     * @param {string} animationType The animation type.
     * @param {number} animationDuration The duration of the animation in seconds.
     * @return {dvt.Playable}
     * @protected
     */
    CreateAnimOnDisplay(objs, animationType, animationDuration) {
      // subclasses may implement
      return null;
    }

    /**
     * Creates a dvt.Playable that performs animation for a gauge update.
     * @param {Array} oldObjs The array of DvtShapes to animate from.
     * @param {Array} newObjs The array of DvtShapes to animate to.
     * @param {string} animationType The animation type.
     * @param {number} animationDuration The duration of the animation in seconds.
     * @return {dvt.Playable}
     * @protected
     */
    CreateAnimOnDataChange(oldObjs, newObjs, animationType, animationDuration) {
      var animatedObjs = [];
      for (var i = 0; i < oldObjs.length; i++) {
        var oldObj = oldObjs[i];
        var newObj = newObjs[i];
        var startState = oldObj.getAnimParams();
        var endState = newObj.getAnimParams();

        newObj.setAnimParams(startState);
        var animation = new dvt.CustomAnimation(this.getCtx(), newObj, animationDuration);
        animation
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            newObj,
            newObj.getAnimParams,
            newObj.setAnimParams,
            endState
          );
        animatedObjs.push(animation);
      }
      return new dvt.ParallelPlayable(this.getCtx(), animatedObjs);
    }

    /**
     * Returns the value at the specified coordinates.  Subclasses must override to support editing behavior.
     * @param {number} x The x coordinate of the value change.
     * @param {number} y The y coordinate of the value change.
     * @return {number}
     * @protected
     */
    GetValueAt(x, y) {
      return null;
    }

    /**
     * Wrapper for the render function to be overridden if subclasses want to behave differently during update events
     */
    renderUpdate() {
      this.render();
    }

    /**
     * Cleans up the old container used by black box updates.
     * @private
     */
    _onAnimEnd() {
      if (this._oldContainer) {
        this.removeChild(this._oldContainer);
        this._oldContainer.destroy();
        this._oldContainer = null;
      }

      // Fire ready event saying animation is finished.
      if (!this.AnimationStopped) this.RenderComplete();

      // Reset animation flags
      this.Animation = null;
      this.AnimationStopped = false;
    }

    /**
     * Handles the start of a value change update driven by a touch or mouse gesture at the specified coordinates.
     * @param {number} x The x coordinate of the value change.
     * @param {number} y The y coordinate of the value change.
     */
    __processValueChangeStart(x, y) {
      this._bEditing = true;
      this._oldValue = this.Options['value'];
      this.__processValueChangeMove(x, y);
    }

    /**
     * Handles the continuation of a value change update driven by a touch or mouse gesture at the specified coordinates.
     * @param {number} x The x coordinate of the value change.
     * @param {number} y The y coordinate of the value change.
     */
    __processValueChangeMove(x, y) {
      // Only process the update if there is data to update
      if (this._oldValue != null) {
        // Update the data value and re-render
        var newValue = DvtGaugeRenderer.adjustForStep(this.Options, this.GetValueAt(x, y));
        if (newValue !== this.Options['value']) {
          this.Options['value'] = newValue;
          this.renderUpdate();

          // Fire the value change input event
          this.dispatchEvent(
            dvt.EventFactory.newValueChangeEvent(this._oldValue, this.Options['value'], false)
          );
        }
      }
    }

    /**
     * Handles the end of a value change update driven by a touch or mouse gesture at the specified coordinates.
     * @param {number} x The x coordinate of the value change.
     * @param {number} y The y coordinate of the value change.
     */
    __processValueChangeEnd(x, y) {
      // Render again in case a move was skipped
      this.__processValueChangeMove(x, y);

      // Need to reset the tooltip value if overridden by UpdateAriaLiveValue
      if (dvt.Agent.isTouchDevice()) {
        var value = DvtGaugeRenderer.getFormattedMetricLabel(this.Options['value'], this);
        var tooltip = DvtGaugeRenderer.getTooltipString(this);
        if (value !== tooltip) {
          tooltip = value + dvt.AriaUtils.ARIA_LABEL_DESC_DELIMITER + tooltip;
          this._container.setAriaProperty('label', tooltip);
        }
      }

      // Fire the event and reset
      this.dispatchEvent(
        dvt.EventFactory.newValueChangeEvent(this._oldValue, this.Options['value'], true)
      );
      this._bEditing = false;
      this._oldValue = null;
    }

    /**
     * Increases the gauge value by one step.
     */
    __increaseValue() {
      if (this.Options['readOnly']) return;

      var oldValue = this.Options['value'];

      // Update the data value and re-render
      if (this.Options['step'] != null) {
        var newValue = this.Options['value'] + this.Options['step'];
        this.Options['value'] = DvtGaugeRenderer.adjustForStep(this.Options, newValue);
      } else {
        var step = (this.Options['max'] - this.Options['min']) / 100;
        this.Options['value'] = Math.min(
          Math.max(this.Options['value'] + step, this.Options['min']),
          this.Options['max']
        );
      }
      this.renderUpdate();

      // Fire the value change input event
      this.dispatchEvent(
        dvt.EventFactory.newValueChangeEvent(oldValue, this.Options['value'], false)
      );
    }

    /**
     * Decreases the gauge value by one step.
     */
    __decreaseValue() {
      if (this.Options['readOnly']) return;

      var oldValue = this.Options['value'];

      // Update the data value and re-render
      if (this.Options['step'] != null) {
        var newValue = this.Options['value'] - this.Options['step'];
        this.Options['value'] = DvtGaugeRenderer.adjustForStep(this.Options, newValue);
      } else {
        var step = (this.Options['max'] - this.Options['min']) / 100;
        this.Options['value'] = Math.min(
          Math.max(this.Options['value'] - step, this.Options['min']),
          this.Options['max']
        );
      }
      this.renderUpdate();

      // Fire the value change input event
      this.dispatchEvent(
        dvt.EventFactory.newValueChangeEvent(oldValue, this.Options['value'], false)
      );
    }

    /**
     * Creates the event manager for the gauge
     * @return {DvtGaugeEventManager} new event manager
     */
    CreateEventManager() {
      return new DvtGaugeEventManager(this);
    }

    /**
     * Comparison function
     * @param {object} a threshold object.
     * @param {object} b threshold object.
     * @return {number} Positive, negative, or 0 value indicating which threshold is larger.
     * @private
     */
    static _thresholdComparator(a, b) {
      if (a['max'] != null && b['max'] != null) {
        return a['max'] - b['max'];
      }

      return a['max'] ? -Infinity : Infinity;
    }

    /**
     * Returns the automation object for this gauge
     * @return {dvt.Automation} The automation object
     */
    getAutomation() {
      return new DvtGaugeAutomation(this);
    }

    /**
     * Creates the keyboard handler.
     * @param {DvtGaugeEventManager} manager Event manager.
     * @return {dvt.KeyboardHandler}
     * @protected
     */
    CreateKeyboardHandler(manager) {
      return new DvtGaugeKeyboardHandler(manager, this);
    }

    /**
     * @override
     */
    UpdateAriaAttributes() {
      if (!this._bStaticRendering) {
        var tooltip = DvtGaugeRenderer.getTooltipString(this);
        if (this.IsParentRoot()) {
          var translations = this.Options.translations;
          this.getCtx().setAriaLabel(
            dvt.ResourceUtils.format(translations.labelAndValue, [
              translations.labelDataVisualization,
              dvt.Displayable.generateAriaLabel(
                dvt.AriaUtils.processAriaLabel(this.GetComponentDescription()),
                tooltip ? [tooltip] : null
              )
            ])
          );
          if (!this.IsInteractive()) {
            this.getCtx().setAriaRole('img');
          } else {
            this.getCtx().setAriaRole('slider');
          }
        } else if (!this.IsInteractive()) {
          this.setAriaRole('img');
          this.setAriaProperty(
            'label',
            dvt.Displayable.generateAriaLabel(
              dvt.AriaUtils.processAriaLabel(this.GetComponentDescription()),
              tooltip ? [tooltip] : null
            )
          );
        }
      }
    }

    /**
     * Checks if the gauge is interactive.
     */
    IsInteractive() {
      return !this.Options.readOnly;
    }
  }

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @extends {dvt.BaseComponentDefaults}
   */
  class DvtGaugeDefaults extends dvt.BaseComponentDefaults {
    constructor(defaultsMap) {
      const SKIN_ALTA = {
        skin: dvt.CSSStyle.SKIN_ALTA,
        min: 0,
        max: 100,
        center: {},
        color: '#393737',
        borderColor: null,
        visualEffects: 'auto',
        emptyText: null,
        animationOnDataChange: 'none',
        animationOnDisplay: 'none',
        animationDuration: 500,
        readOnly: 'true',
        metricLabel: {
          rendered: 'auto',
          scaling: 'auto',
          style: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA),
          textType: 'number'
        },
        _statusMessageStyle: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA),
        label: {
          style: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA),
          position: 'auto'
        },

        _thresholdColors: ['#ed6647', '#fad55c', '#68c182'],
        // Internal layout constants
        __layout: { outerGap: 1, labelGap: 5 }
      };

      // This will only be called via subclasses.  Combine with defaults from this class before passing to super.
      super({
        alta: dvt.JsonUtils.merge(defaultsMap['alta'], SKIN_ALTA)
      });
    }
  }

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {DvtGaugeDefaults}
   */
  class DvtLedGaugeDefaults extends DvtGaugeDefaults {
    constructor(context) {
      const SKIN_ALTA = {
        type: 'circle'
      };

      super({ alta: SKIN_ALTA }, context);
    }
  }

  /**
   * Renderer for LedGauge.
   * @class
   */
  const DvtLedGaugeRenderer = {
    /** @private **/
    _SHAPE_TRIANGLE_CMDS: [-50, 36.6, 0, -50, 50, 36.6],

    /**
     * Polygon commands for star shape.  Centered at (0,0) with size of 100.
     * @private
     */
    _SHAPE_STAR_CMDS:
      'M 13.686617627555295 -14.844072859624454 L 0 -49.99999973529656 L -13.686617627555295 -14.844072859624454 L -49.21031057098533 -11.804119976838445 L -22.1446397569434 12.966333294730747 L -30.4142789122285 49.99999973529656 L 0 30.151376755728354 L 30.4142789122285 49.99999973529656 L 22.1446397569434 12.966333294730747 L 49.21031057098533 -11.804119976838445 Z ',
    /** @private **/
    _SHAPE_ARROW_CMDS: [25, 48, 25, 8, 47.5, 8, 0, -39, -47.5, 8, -25, 8, -25, 48],

    /** @private **/
    _SHAPE_HUMAN_CMDS:
      'M -0.06059525142297417 -50.86842065108466 C -11.4496388584463 -50.86842065108466 ' +
      '-20.708163169810554 -39.024253028220556 -20.708163169810554 -24.413724255650386 C -20.708163169810554 -9.803195483080515 ' +
      '-11.4496388584463 2.040972139783591 -0.06059525142297417 2.040972139783591 C 11.328499974520241 2.040972139783591 20.586972666964613 ' +
      '-9.803195483080515 20.586972666964613 -24.413724255650386 C 20.586972666964613 -39.024253028220556 11.328499974520241 -50.86842065108466 ' +
      '-0.06059525142297417 -50.86842065108466 z M -23.93434565705865 -2.959610715450779 C -30.908061721494278 3.3998402034127153 -42.00096758564793 ' +
      '18.817121073473572 -38.77478509839983 33.65756051481475 C -20.651382358034887 47.30044101688934 14.372054723529814 49.13162219665128 ' +
      '39.298831093003386 32.85101489300273 C 40.26410489318826 16.477493533721187 32.34060070450674 4.7883891459240715 23.167918656763206 ' +
      '-2.959610715450779 C 11.553661702670112 21.074158341552575 -11.029615708066558 16.237465556670102 -23.93434565705865 -2.959610715450779 z ',

    /**
     * Renders the gauge in the specified area.
     * @param {LedGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     */
    render: (gauge, container, width, height) => {
      if (DvtGaugeDataUtils.hasData(gauge)) {
        // Allocate the outer gap for the component
        var options = gauge.getOptions();
        var outerGap = options['__layout']['outerGap'];
        var size =
          options && (options['size'] >= 0 || options['size'] < 1) ? Math.sqrt(options['size']) : 1;
        var bounds = new dvt.Rectangle(
          outerGap + ((width - 2 * outerGap) * (1 - size)) / 2,
          outerGap + ((height - 2 * outerGap) * (1 - size)) / 2,
          (width - 2 * outerGap) * size,
          (height - 2 * outerGap) * size
        );

        // Render the LED shape first
        DvtLedGaugeRenderer._renderShape(gauge, container, bounds);

        // Render the label on top of the LED
        var bLabelRendered = false;
        var metricLabelColor = dvt.ColorUtils.getContrastingTextColor(
          DvtGaugeStyleUtils.getColor(gauge)
        );
        if (options['label']['text']) {
          var labelValign = 'middle';
          var labelBounds = DvtLedGaugeRenderer._getMetricLabelBounds(gauge, container, bounds);
          if (options['metricLabel']['rendered'] === 'on') {
            labelBounds.y = labelBounds.y + labelBounds.h * 0.6;
            labelBounds.h = labelBounds.h * 0.4;
            labelValign = 'top';
          }
          // Use the specified metricLabel color unless in high contrast mode
          if (!dvt.Agent.isHighContrast() && options['label']['style'].getStyle('color') != null) {
            bLabelRendered = DvtGaugeRenderer.renderLabel(
              gauge,
              container,
              labelBounds,
              null,
              labelValign
            );
          } else {
            bLabelRendered = DvtGaugeRenderer.renderLabel(
              gauge,
              container,
              labelBounds,
              metricLabelColor,
              labelValign
            );
          }
        }

        // Render the metricLabel on top of the LED
        if (options['metricLabel']['rendered'] === 'on') {
          var metricLabelBounds = DvtLedGaugeRenderer._getMetricLabelBounds(gauge, container, bounds);
          var valign = 'middle';
          if (bLabelRendered) {
            metricLabelBounds.h = metricLabelBounds.h * 0.55;
            valign = 'bottom';
          }

          // Use the specified metricLabel color unless in high contrast mode
          if (
            !dvt.Agent.isHighContrast() &&
            options['metricLabel']['style'].getStyle('color') != null
          ) {
            DvtGaugeRenderer.renderMetricLabel(
              gauge,
              container,
              metricLabelBounds,
              null,
              'center',
              valign
            );
          } else {
            DvtGaugeRenderer.renderMetricLabel(
              gauge,
              container,
              metricLabelBounds,
              metricLabelColor,
              'center',
              valign
            );
          }
        }
      } // Render the empty text
      else DvtGaugeRenderer.renderEmptyText(gauge, container, new dvt.Rectangle(0, 0, width, height));
    },

    /**
     * Renders the led shape into the specified area.
     * @param {LedGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @private
     */
    _renderShape: (gauge, container, bounds) => {
      var context = gauge.getCtx();
      var options = gauge.getOptions();

      // Find the styles
      var type = options['type'];
      var color = DvtGaugeStyleUtils.getColor(gauge);
      var borderColor = DvtGaugeStyleUtils.getBorderColor(gauge);

      // Calculate the center and radius for convenience
      var cx = bounds.x + bounds.w / 2;
      var cy = bounds.y + bounds.h / 2;
      var r = Math.min(bounds.w, bounds.h) / 2;

      // Initialize the cache if not done already.  The cache stores the paths centered at 0,0 and at scale 100.
      if (!DvtLedGaugeRenderer._cache) DvtLedGaugeRenderer._cache = new dvt.Cache(50);

      // Render the LED shape
      var shape;
      var cmds;

      // Scale is relative to reference size of 100
      var scale = Math.min(bounds.w / 100, bounds.h / 100);
      if (type === 'square') {
        shape = new dvt.Rect(context, cx - r, cy - r, 2 * r, 2 * r);
      } else if (type == 'rectangle') {
        shape = new dvt.Rect(context, bounds.x, bounds.y, bounds.w, bounds.h);
      } else if (type === 'diamond') {
        shape = new dvt.Polygon(context, [cx - r, cy, cx, cy - r, cx + r, cy, cx, cy + r]);
      } else if (type === 'circle') {
        shape = new dvt.Circle(context, cx, cy, r);
      } else {
        if (type === 'star') cmds = DvtLedGaugeRenderer._SHAPE_STAR_CMDS;
        else if (type === 'triangle') cmds = DvtLedGaugeRenderer._SHAPE_TRIANGLE_CMDS;
        else if (type === 'arrow') cmds = DvtLedGaugeRenderer._SHAPE_ARROW_CMDS;
        else if (type === 'human') cmds = DvtLedGaugeRenderer._SHAPE_HUMAN_CMDS;
        else {
          // Assume we're using a custom path
          cmds = DvtLedGaugeRenderer._cache.get(type);
          if (!cmds) {
            shape = new dvt.Path(context, type);
            // Calculate the dimensions and shift the shape to be centered at 0,0 within its containing rectangle
            var dim = dvt.DisplayableUtils.getDimForced(context, shape);
            var scaleTo100 = 100 / Math.max(dim.w, dim.h);
            cmds = dvt.PathUtils.transformPath(
              shape.getCommandsArray(),
              -scaleTo100 * (dim.x + dim.w / 2),
              -scaleTo100 * (dim.y + dim.h / 2),
              scaleTo100,
              scaleTo100
            );
            DvtLedGaugeRenderer._cache.put(type, cmds);
          }
        }

        // These shapes are defined as polygons
        if (type === 'triangle' || type === 'arrow') {
          cmds = dvt.PolygonUtils.scale(cmds, scale, scale);

          // Translate from center of (0,0)
          cmds = dvt.PolygonUtils.translate(cmds, bounds.x + bounds.w / 2, bounds.y + bounds.h / 2);
          shape = new dvt.Polygon(context, cmds);
        }
        // All others use paths
        else {
          // Translate from center of (0,0)
          cmds = dvt.PathUtils.transformPath(
            dvt.PathUtils.createPathArray(cmds),
            bounds.x + bounds.w / 2,
            bounds.y + bounds.h / 2,
            scale,
            scale
          );
          shape = new dvt.Path(context, cmds);
        }
      }

      var theme = gauge.getCtx().getThemeBehavior();
      // Apply the style properties
      if (options['visualEffects'] === 'none' || theme === 'redwood') shape.setSolidFill(color);
      else {
        var arColors = [
          dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04),
          dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05)
        ];
        var rotation = options && options['rotation'] % 90 == 0 ? options['rotation'] : 0;
        var gradientRotation =
          type === 'arrow' || type === 'star' || type === 'triangle' ? rotation - 90 : 270;
        shape.setFill(new dvt.LinearGradientFill(gradientRotation, arColors, [1, 1], [0, 1]));
      }
      if (borderColor) shape.setSolidStroke(borderColor);

      // Custom style and class
      shape.setClassName(options['svgClassName']);
      shape.setStyle(options['svgStyle']);

      // rotate the shape if needed
      rotation = options['rotation'];
      if (
        rotation &&
        (type === 'arrow' ||
          type === 'triangle' ||
          (shape instanceof dvt.Path && type !== 'human' && type !== 'star'))
      )
        shape = DvtLedGaugeRenderer._rotate(gauge, container, shape, bounds);

      // Add the shape to the container
      container.addChild(shape);
    },

    /**
     * Scales and rotates the shape into the specified bounds.
     * @param {LedGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Displayable} shape The shape for the gauge.
     * @param {dvt.Rectangle} bounds The bounds of the shape.
     * @return {dvt.Displayable} The scaled shape
     * @private
     */
    _rotate: (gauge, container, shape, bounds) => {
      var options = gauge.getOptions();

      // Add containers for the tranforms, add to display list to calc dimensions
      var translateGroup = new dvt.Container(gauge.getCtx());
      container.addChild(translateGroup);
      translateGroup.addChild(shape);

      // Rotate the shape, non-90 degree rotation values are ignored
      var rotation = options && options['rotation'] % 90 == 0 ? options['rotation'] : 0;
      var rotationMatrix = new dvt.Matrix();
      shape.setMatrix(rotationMatrix.rotate((Math.PI * rotation) / 180));

      // Translate the shape so that it's centered within the bounds
      var groupDims = translateGroup.getDimensions();
      var tx = bounds.x + bounds.w / 2 - (groupDims.x + groupDims.w / 2);
      var ty = bounds.y + bounds.h / 2 - (groupDims.y + groupDims.h / 2);

      var matrix = new dvt.Matrix();
      translateGroup.setMatrix(matrix.translate(tx, ty));

      // Return the group with its transform
      return translateGroup;
    },

    /**
     * Find correct metricLabel bounds
     * @param {LedGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The bounds of the shape.
     * @return {dvt.Rectangle} Bounds for the metricLabel
     * @private
     */
    _getMetricLabelBounds: (gauge, container, bounds) => {
      var options = gauge.getOptions();
      var type = options['type'];
      var rotation = options['rotation'] % 90 == 0 ? options['rotation'] : 0;
      var minDim = Math.min(bounds.w, bounds.h);
      var newX = bounds.x + bounds.w / 2 - minDim / 2;
      var newY = bounds.y + bounds.h / 2 - minDim / 2;
      var newWidth = minDim;
      var newHeight = minDim;
      if (type === 'triangle') {
        if (rotation === 0) {
          newX += minDim * 0.2;
          newY += minDim * 0.25;
          newWidth -= minDim * 0.4;
          newHeight -= minDim * 0.3;
        } else if (rotation === 90) {
          newX += minDim * 0.05;
          newY += minDim * 0.2;
          newWidth -= minDim * 0.3;
          newHeight -= minDim * 0.4;
        } else if (rotation === 180) {
          newX += minDim * 0.2;
          newY += minDim * 0.05;
          newWidth -= minDim * 0.4;
          newHeight -= minDim * 0.3;
        } else if (rotation === 270) {
          newX += minDim * 0.25;
          newY += minDim * 0.2;
          newWidth -= minDim * 0.3;
          newHeight -= minDim * 0.4;
        }
      } else if (type === 'arrow') {
        if (rotation === 0) {
          newX += minDim * 0.2;
          newY += minDim * 0.2;
          newWidth -= minDim * 0.4;
          newHeight -= minDim * 0.4;
        } else if (rotation === 90) {
          newX += minDim * 0.05;
          newY += minDim * 0.2;
          newWidth -= minDim * 0.28;
          newHeight -= minDim * 0.4;
        } else if (rotation === 180) {
          newX += minDim * 0.2;
          newY += minDim * 0.2;
          newWidth -= minDim * 0.4;
          newHeight -= minDim * 0.4;
        } else if (rotation === 270) {
          newX += minDim * 0.23;
          newY += minDim * 0.2;
          newWidth -= minDim * 0.28;
          newHeight -= minDim * 0.4;
        }
      } else if (type === 'star') {
        newX += minDim * 0.25;
        newY += minDim * 0.25;
        newWidth -= minDim * 0.5;
        newHeight -= minDim * 0.4;
      } else if (type === 'diamond') {
        newX += minDim * 0.15;
        newY += minDim * 0.15;
        newWidth -= minDim * 0.3;
        newHeight -= minDim * 0.3;
      } else if (type === 'rectangle') {
        newX += minDim * 0.1;
        newY += minDim * 0.1;
        newWidth -= minDim * 0.2;
        newHeight -= minDim * 0.2;
      } else {
        newX += minDim * 0.15;
        newY += minDim * 0.15;
        newWidth -= minDim * 0.3;
        newHeight -= minDim * 0.3;
      }
      return new dvt.Rectangle(newX, newY, newWidth, newHeight);
    }
  };

  /**
   * LED Gauge component.
   * @class
   * @constructor
   * @extends {DvtGauge}
   */
  class LedGauge extends DvtGauge {
    constructor(context, callback, callbackObj, bStaticRendering) {
      super(context, callback, callbackObj, bStaticRendering);

      this.type = 'led';
      // Create the defaults object
      this.Defaults = new DvtLedGaugeDefaults(context);
    }

    /**
     * @override
     */
    SetOptions(options) {
      // NOTE: This extra clone should be removed once we stop supporting the deprecated attrs
      options = dvt.JsonUtils.clone(options);

      if (options['title']) {
        options['label'] = options['title'];
      }

      // Combine the user options with the defaults and store
      super.SetOptions(this.Defaults.calcOptions(options));

      // animationOnDisplay="auto" will do "zoom"
      if (this.Options['animationOnDisplay'] === 'auto') {
        this.Options['animationOnDisplay'] = 'zoom';
      }

      // animationOnDataChange="auto" will do "alphaFade"
      if (this.Options['animationOnDataChange'] === 'auto') {
        this.Options['animationOnDataChange'] = 'alphaFade';
      }

      // readOnly="false" is not supported
      this.Options['readOnly'] = true;
    }

    /**
     * @override
     */
    Render(container, width, height) {
      DvtLedGaugeRenderer.render(this, container, width, height);
    }
  }

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {DvtGaugeDefaults}
   */
  class DvtRatingGaugeDefaults extends DvtGaugeDefaults {
    constructor(context) {
      /**
       * Defaults for version 1.
       */
      const SKIN_ALTA = {
        min: 0,
        max: 5,
        orientation: 'horizontal',
        unselectedState: { shape: 'star', color: '#C4CED7' },
        selectedState: { shape: 'star', color: '#F8C15A' },
        hoverState: { shape: 'star', color: '#007CC8' },
        changedState: { shape: 'star', color: '#ED2C02' },
        preserveAspectRatio: 'meet',
        step: 1
      };

      super({ alta: SKIN_ALTA }, context);
    }
  }

  /**
   * Event Manager for RatingGauge.
   * @param {DvtGauge} gauge
   * @class
   * @extends {dvt.EventManager}
   * @constructor
   */
  class DvtRatingGaugeEventManager extends DvtGaugeEventManager {
    constructor(gauge) {
      super(gauge);
      this._gauge = gauge;
    }

    /**
     * @override
     */
    OnMouseOver(event) {
      // Only editable gauges
      if (this._gauge.IsInteractive()) {
        var coords = this.GetRelativePosition(event.pageX, event.pageY);
        this._gauge.__processValueChangeStart(coords.x, coords.y);
        this.IsMouseEditing = true;
      }

      // Need to call the superclass here to support tooltips during hover.
      super.OnMouseOver(event);
    }

    /**
     * @override
     */
    OnMouseOut(event) {
      // Only editable gauges
      if (this._gauge.IsInteractive()) {
        var coords = this.GetRelativePosition(event.pageX, event.pageY);
        this._gauge.__processHoverEnd(coords.x, coords.y);
        this.IsMouseEditing = false;
      }
      // To dismiss the tooltip if it's showing.
      super.OnMouseOut(event);
    }

    /**
     * @override
     */
    OnMouseMove(event) {
      var coords = this.GetRelativePosition(event.pageX, event.pageY);
      var isDisabled = this._gauge.getOptions()['disabled'] === true;
      if (
        this._gauge.IsInteractive() &&
        !this.IsMouseEditing &&
        this._gauge.getOptions()['value'] !== this._gauge.GetValueAt(coords.x, coords.y)
      ) {
        this.IsMouseEditing = true;
      }

      if (!isDisabled) super.OnMouseMove(event);
    }

    /**
     * @override
     */
    OnMouseDown(event) {
      // Want to directly call the OnMouseDown from dvt.EventManager, so we don't go through the
      // default gauge behavior since it's already covered in OnMouseOver
      dvt.EventManager.prototype.OnMouseDown.call(this, event);
    }

    /**
     * @override
     */
    OnContextMenu(event) {
      // jet-32846; value change happens in mouseup event but chrome and
      // safari in mac do not fire mouseup on right click
      // change value after context menu in such case
      var engine = dvt.Agent.engine;
      if ((engine === 'webkit' || engine === 'blink') && dvt.Agent.os === 'mac') {
        // Reset the editing flag
        if (this.IsMouseEditing) {
          this.StopMouseEditing(event);
        }
      }
      super.OnContextMenu(event);
    }

    /**
     * @override
     */
    ProcessKeyboardEvent(event) {
      // Need to clear out the flag to make rating gauge tooltips work with keyboarding
      this.IsMouseEditing = false;
      return super.ProcessKeyboardEvent(event);
    }

    /**
     * @override
     */
    IsShowingTooltipWhileEditing() {
      return true;
    }
  }

  /**
   * Rating gauge tooltip support
   * @param {RatingGauge} gauge The rating gauge.
   * @class
   * @constructor
   * @implements {DvtTooltipSource}
   */
  class DvtRatingGaugePeer extends dvt.SimpleObjPeer {
    constructor(gauge) {
      super();
      this._gauge = gauge;
    }

    /**
     * @override
     */
    getDatatip(target, x, y) {
      var options = this._gauge.getOptions();
      var thresholdIndex;
      if (this._gauge.getEventManager().__isMouseEditing())
        thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(
          this._gauge,
          this._gauge.GetValueAt(x, y)
        );
      else thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(this._gauge);
      var threshold = DvtGaugeDataUtils.getThreshold(this._gauge, thresholdIndex);
      return threshold && threshold['shortDesc'] ? threshold['shortDesc'] : options['shortDesc'];
    }
  }

  /**
   * Renderer for RatingGauge.
   * @class
   */
  const DvtRatingGaugeRenderer = {
    /**
     * Renders the gauge in the specified area.
     * @param {RatingGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     */
    render: (gauge, container, width, height) => {
      if (DvtGaugeDataUtils.hasData(gauge)) {
        var options = gauge.getOptions();
        var thresholdIndex = DvtGaugeDataUtils.getValThresholdIdx(gauge);
        var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
        var selectedColor = options['selectedState']['color'];
        var changedColor = options['changedState']['color'];
        var selectedBorderColor = options['selectedState']['borderColor'];
        var changedBorderColor = options['changedState']['borderColor'];
        if (threshold && threshold['color']) {
          selectedColor = threshold['color'];
          changedColor = threshold['color'];
        }

        if (threshold && threshold['borderColor']) {
          selectedBorderColor = threshold['borderColor'];
          changedBorderColor = threshold['borderColor'];
        }

        // Create the options objects for the shapes
        var unselectedOptions = {
          value: 0,
          state: 'unselected',
          type: options['unselectedState']['shape'],
          color: options['unselectedState']['color'],
          borderColor: options['unselectedState']['borderColor'],
          visualEffects: options['visualEffects'],
          source: options['unselectedState']['source'],
          svgClassName: options['unselectedState']['svgClassName'],
          svgStyle: options['unselectedState']['svgStyle']
        };
        var selectedOptions = {
          value: 0,
          state: 'selected',
          type: options['selectedState']['shape'],
          color: selectedColor,
          borderColor: selectedBorderColor,
          visualEffects: options['visualEffects'],
          source: options['selectedState']['source'],
          svgClassName: options['selectedState']['svgClassName'],
          svgStyle: options['selectedState']['svgStyle']
        };
        var changedOptions = {
          value: 0,
          state: 'changed',
          type: options['changedState']['shape'],
          color: changedColor,
          borderColor: changedBorderColor,
          visualEffects: options['visualEffects'],
          source: options['changedState']['source'],
          svgClassName: options['changedState']['svgClassName'],
          svgStyle: options['changedState']['svgStyle']
        };
        var hoverOptions = {
          value: 0,
          state: 'hover',
          type: options['hoverState']['shape'],
          color: options['hoverState']['color'],
          borderColor: options['hoverState']['borderColor'],
          visualEffects: options['visualEffects'],
          source: options['hoverState']['source'],
          svgClassName: options['hoverState']['svgClassName'],
          svgStyle: options['hoverState']['svgStyle']
        };

        if (options['unselectedState']['shape'] == 'dot') {
          unselectedOptions['type'] = 'circle';
          unselectedOptions['visualEffects'] = 'none';
          unselectedOptions['size'] = 0.05;
        }

        DvtRatingGaugeRenderer._createShapes(gauge, container, unselectedOptions);
        DvtRatingGaugeRenderer._createShapes(
          gauge,
          container,
          options['changed'] ? changedOptions : selectedOptions
        );
        if (!(options.readOnly || options.disabled)) {
          DvtRatingGaugeRenderer._createShapes(gauge, container, hoverOptions);
        }

        gauge.__updateClipRects(options['value'], 'render', container);
      } // Render the empty text
      else DvtGaugeRenderer.renderEmptyText(gauge, container, new dvt.Rectangle(0, 0, width, height));
    },

    /**
     * Creates the shapes for the rating gauge at the given position
     * @param {RatingGauge} gauge
     * @param {dvt.Container} container The container to render into.
     * @param {object} stateOptions The options object for this state.
     * @private
     */
    _createShapes: (gauge, container, stateOptions) => {
      var context = gauge.getCtx();
      var shapesContainer = new dvt.Container(context);
      container.addChild(shapesContainer);
      var options = gauge.getOptions();
      var bounds = gauge.__bounds;
      var shapeWidth = gauge.__shapeWidth;
      var shapeHeight = gauge.__shapeHeight;

      var useShape =
        dvt.Agent.browser === 'ie' || dvt.Agent.browser === 'edge'
          ? null
          : DvtRatingGaugeRenderer._createShape(
              context,
              0,
              0,
              shapeWidth,
              shapeHeight,
              stateOptions,
              options
            );

      for (var i = 0; i < options['max']; i++) {
        var x, y;
        if (options['orientation'] == 'vertical') {
          x = bounds.x + bounds.w / 2 - shapeWidth / 2;
          y = bounds.y + bounds.h - (i + 1) * shapeHeight;
        } else if (dvt.Agent.isRightToLeft(context)) {
          x = bounds.x + bounds.w - (i + 1) * shapeWidth;
          y = bounds.y + bounds.h / 2 - shapeHeight / 2;
        } else {
          x = bounds.x + i * shapeWidth;
          y = bounds.y + bounds.h / 2 - shapeHeight / 2;
        }

        if (dvt.Agent.browser === 'ie' || dvt.Agent.browser === 'edge') {
          var shape = DvtRatingGaugeRenderer._createShape(
            context,
            x,
            y,
            shapeWidth,
            shapeHeight,
            stateOptions,
            options
          );

          if (shape) {
            shapesContainer.addChild(shape);
          }
        } else if (useShape) {
          var use = new dvt.Use(context, x, y, useShape);
          shapesContainer.addChild(use);
        }
      }
    },

    /**
     * Creates a shape used to create the rating gauge
     * @param {dvt.Context} context
     * @param {number} x  The x position of the marker.
     * @param {number} y  The y position of the marker.
     * @param {number} width  The width of the marker.
     * @param {number} height  The height of the marker.
     * @param {object} stateOptions The options object for this state.
     * @param {object} gaugeOptions The options object for the gauge.
     * @return {dvt.Obj} shape The led gauge or image marker shape
     * @private
     */
    _createShape: (context, x, y, width, height, stateOptions, gaugeOptions) => {
      var shape;
      if (stateOptions['source']) {
        shape = new dvt.ImageMarker(
          context,
          x + width / 2,
          y + height / 2,
          width,
          height,
          null,
          stateOptions['source']
        );
        if (gaugeOptions['preserveAspectRatio'] === 'none') shape.setPreserveAspectRatio('none');
      } else if (stateOptions['type'] != 'none') {
        shape = new LedGauge(context, null, null, true);
        if (x != 0 && y != 0) shape.setTranslate(x, y);

        if (gaugeOptions['disabled'] || dvt.Agent.isHighContrast()) {
          var className = `oj-rating-gauge-${
          stateOptions.state === 'unselected' ? 'unselected' : 'selected'
        }${gaugeOptions['disabled'] ? '-disabled' : ''}`;
          if (gaugeOptions['disabled']) {
            stateOptions.svgClassName = className;
            stateOptions.svgStyle = null;
          } else {
            stateOptions.svgClassName = `${stateOptions.svgClassName || ''} ${className}`.trim();
          }
          if (dvt.Agent.isHighContrast()) {
            shape.addClassName('oj-hicontrast');
          }
        }
        shape.render(stateOptions, width, height);
      }

      return shape;
    }
  };

  /**
   * Rating Gauge component.
   * @class
   * @constructor
   * @extends {DvtGauge}
   */
  class RatingGauge extends DvtGauge {
    constructor(context, callback, callbackObj) {
      super(context, callback, callbackObj);
      this.type = 'rating';
      // Create the defaults object
      this.Defaults = new DvtRatingGaugeDefaults(context);
    }

    /**
     * @override
     */
    SetOptions(options) {
      // NOTE: This extra clone should be removed once we stop supporting the deprecated attrs
      options = dvt.JsonUtils.clone(options);

      if (options['changedState']) {
        if (options['changedState']['className'])
          options['changedState']['svgClassName'] = options['changedState']['className'];

        if (options['changedState']['style'])
          options['changedState']['svgStyle'] = options['changedState']['style'];
      }

      if (options['hoverState']) {
        if (options['hoverState']['className'])
          options['hoverState']['svgClassName'] = options['hoverState']['className'];

        if (options['hoverState']['style'])
          options['hoverState']['svgStyle'] = options['hoverState']['style'];
      }

      if (options['selectedState']) {
        if (options['selectedState']['className'])
          options['selectedState']['svgClassName'] = options['selectedState']['className'];

        if (options['selectedState']['style'])
          options['selectedState']['svgStyle'] = options['selectedState']['style'];
      }

      if (options['unselectedState']) {
        if (options['unselectedState']['className'])
          options['unselectedState']['svgClassName'] = options['unselectedState']['className'];

        if (options['unselectedState']['style'])
          options['unselectedState']['svgStyle'] = options['unselectedState']['style'];
      }

      // Map the custom element readonly attr to the widget readOnly option
      if (this.getCtx().isCustomElement()) {
        options['readOnly'] = options['readonly'];
      }

      var svg = this.getCtx().getSvgDocument();
      if (options['size'] !== 'fit') {
        this.getCtx().removeSizingSvg();
        svg.style.height = options._height + 'px';
        svg.style.width = options._width + 'px';
      } else {
        this.getCtx().addSizingSvg();
        svg.style.height = '';
        svg.style.width = '';
      }

      // Combine the user options with the defaults and store
      super.SetOptions(this.Defaults.calcOptions(options));
    }

    /**
     * @override
     */
    Render(container, width, height) {
      var outerGap = this.Options['__layout']['outerGap'];
      var maxValue = this.Options['max'];
      var size = this.Options['size'];
      var isVert = this.Options['orientation'] == 'vertical';
      var selectedSource = this.Options['selectedState']['source'];
      var preserveAspectRatio = this.Options['preserveAspectRatio'] != 'none';

      if (selectedSource && preserveAspectRatio && size === 'fit') {
        // Show images at the size of the selected shape if defined
        var onLoad = (imageInfo) => {
          // IE11 gives a size of 0x0 for loaded images: https://connect.microsoft.com/IE/feedbackdetail/view/925655/svg-image-has-0x0-size-in-ie11
          if (
            (dvt.Agent.browser === 'ie' || dvt.Agent.browser === 'edge') &&
            dvt.Agent.version == 11 &&
            imageInfo &&
            imageInfo.width == 0 &&
            imageInfo.height == 0
          ) {
            imageInfo.width = 1;
            imageInfo.height = 1;
          }
          if (imageInfo && imageInfo.width && imageInfo.height) {
            var ratio = imageInfo.width / imageInfo.height;
            this.__shapeWidth = isVert
              ? Math.min(width - 2 * outerGap, ((height - 2 * outerGap) * ratio) / maxValue)
              : Math.min((height - 2 * outerGap) * ratio, (width - 2 * outerGap) / maxValue);
            this.__shapeHeight = this.__shapeWidth / ratio;
            this.__bounds = isVert
              ? new dvt.Rectangle(
                  outerGap,
                  (height - this.__shapeHeight * maxValue) / 2.0,
                  width - 2 * outerGap,
                  this.__shapeHeight * maxValue
                )
              : new dvt.Rectangle(
                  (width - this.__shapeWidth * maxValue) / 2.0,
                  outerGap,
                  this.__shapeWidth * maxValue,
                  height - 2 * outerGap
                );
            DvtRatingGaugeRenderer.render(this, container, width, height);
          }
          this.PostRender(this.Options, container);
        };
        dvt.ImageLoader.loadImage(this.Options['selectedState']['source'], onLoad);
        return false;
      }

      outerGap = size === 'fit' ? outerGap : 0;
      if (!preserveAspectRatio) {
        // Divide space evenly
        this.__shapeWidth = isVert ? width - 2 * outerGap : (width - 2 * outerGap) / maxValue;
        this.__shapeHeight = isVert ? (height - 2 * outerGap) / maxValue : height - 2 * outerGap;
      } else {
        // Show square shapes
        this.__shapeWidth = isVert
          ? Math.min(width - 2 * outerGap, (height - 2 * outerGap) / maxValue)
          : Math.min(height - 2 * outerGap, (width - 2 * outerGap) / maxValue);
        this.__shapeHeight = this.__shapeWidth;
      }
      this.__bounds = isVert
        ? new dvt.Rectangle(
            outerGap,
            (height - this.__shapeHeight * maxValue) / 2.0,
            width - 2 * outerGap,
            this.__shapeHeight * maxValue
          )
        : new dvt.Rectangle(
            (width - this.__shapeWidth * maxValue) / 2.0,
            outerGap,
            this.__shapeWidth * maxValue,
            height - 2 * outerGap
          );
      DvtRatingGaugeRenderer.render(this, container, width, height);
      return true;
    }

    /**
     * @override
     */
    __getLogicalObject() {
      var customTooltip = this.Options['tooltip'];
      var tooltipFunc = customTooltip ? customTooltip['renderer'] : null;
      var color = DvtGaugeStyleUtils.getColor(this);
      if (tooltipFunc) {
        var dataContext = {
          component: this.Options['_widgetConstructor'],
          label: DvtGaugeRenderer.getFormattedMetricLabel(this.Options['value'], this),
          color: color
        };
        return new dvt.CustomDatatipPeer(
          this.getCtx().getTooltipManager(),
          tooltipFunc,
          color,
          dataContext
        );
      }
      return new DvtRatingGaugePeer(this);
    }

    /**
     * @override
     */
    GetValueAt(x, y) {
      var size = this.Options['orientation'] == 'vertical' ? this.__shapeHeight : this.__shapeWidth;
      if (DvtGaugeDataUtils.hasData(this)) {
        var val;
        if (this.Options['orientation'] == 'vertical') {
          y = Math.max(Math.min(y, this.__bounds.y + this.__bounds.h), this.__bounds.y);

          val = Math.max((this.__bounds.y + this.__bounds.h - y) / size, this.Options['min']);
        } else {
          x = Math.max(Math.min(x, this.__bounds.x + this.__bounds.w), this.__bounds.x);

          // calculating the val depends on locale, but the rounding doesn't
          val = 0;
          if (!dvt.Agent.isRightToLeft(this.getCtx())) {
            val = Math.max((x - this.__bounds.x) / size, this.Options['min']);
          } else {
            val = Math.max((this.__bounds.x + this.__bounds.w - x) / size, this.Options['min']);
          }
        }

        return DvtGaugeRenderer.adjustForStep(this.Options, val);
      }
      return null;
    }

    /**
     * Handles the end of a hover event due to mouse out at the specified coordinates.
     * @param {number} x The x coordinate of the value change.
     * @param {number} y The y coordinate of the value change.
     */
    __processHoverEnd(x, y) {
      this.__updateClipRects(this.Options['value'], 'render');

      // Fire the value change event to reset to the real value
      this.dispatchEvent(
        dvt.EventFactory.newValueChangeEvent(this.Options['value'], this.Options['value'], false)
      );
    }

    /**
     * @override
     */
    __processValueChangeStart(x, y) {
      this.__processValueChangeMove(x, y);
    }

    /**
     * @override
     */
    __processValueChangeMove(x, y) {
      var value = this.GetValueAt(x, y);
      this.__updateClipRects(value, 'hover');

      // Fire the value change event
      this.dispatchEvent(dvt.EventFactory.newValueChangeEvent(this.Options['value'], value, false));
    }

    /**
     * @override
     */
    __processValueChangeEnd(x, y) {
      // Render again because a click was registerd
      var oldValue = this.Options['value'];
      this.Options['value'] = this.GetValueAt(x, y);
      this.Options['changed'] = true;
      this.render();

      // Fire the both the change and input events on complete
      this.dispatchEvent(
        dvt.EventFactory.newValueChangeEvent(oldValue, this.Options['value'], false)
      );
      this.dispatchEvent(dvt.EventFactory.newValueChangeEvent(oldValue, this.Options['value'], true));
    }

    /**
     * Updates the cliprects used in the rating gauge for hover and the different states.
     * @param {number} value The point at which the clips rects are drawn.
     * @param {string} proc The process being done- "hover" or "render"
     * @param {dvt.Container} container The container that holds this gauge- allowing us to access the three subcontainers with selected/changed, unselected, and hover shapes.
     */
    __updateClipRects(value, proc, container) {
      if (!DvtGaugeDataUtils.hasData(this)) {
        return;
      }

      if (!container) {
        container = this._container;
      }

      var isRTL = dvt.Agent.isRightToLeft(this.getCtx());
      var isVert = this.Options['orientation'] == 'vertical';
      var size = isVert ? this.__shapeHeight : this.__shapeWidth;

      // which  to show and which to hide based on whether we're hovering or not
      value = Math.max(Math.min(value, this.Options['max']), 0); //clipping the data value
      var a = 0;
      var b = value * size;
      var c = value * size;
      if (proc === 'render') {
        a = value * size;
        b = 0;
      }

      var unselContainer;
      var unselClip;
      var selContainer;
      var selClip;
      var hoverContainer;
      var hoverClip;
      if (isVert) {
        // Set the clip rect size.
        unselContainer = container.getChildAt(0);
        unselClip = new dvt.ClipPath();
        unselClip.addRect(this.__bounds.x, this.__bounds.y, this.__bounds.w, this.__bounds.h - c);
        unselContainer.setClipPath(unselClip);

        selContainer = container.getChildAt(1);
        selClip = new dvt.ClipPath();
        selClip.addRect(this.__bounds.x, this.__bounds.y + this.__bounds.h - a, this.__bounds.w, a);
        selContainer.setClipPath(selClip);

        hoverContainer = container.getChildAt(2);
        if (hoverContainer) {
          hoverClip = new dvt.ClipPath();
          hoverClip.addRect(
            this.__bounds.x,
            this.__bounds.y + this.__bounds.h - b,
            this.__bounds.w,
            b
          );
          hoverContainer.setClipPath(hoverClip);
        }
      } else if (!isRTL) {
        // Set the clip rect size.
        unselContainer = container.getChildAt(0);
        unselClip = new dvt.ClipPath();
        unselClip.addRect(this.__bounds.x + c, this.__bounds.y, this.__bounds.w - c, this.__bounds.h);
        unselContainer.setClipPath(unselClip);

        selContainer = container.getChildAt(1);
        selClip = new dvt.ClipPath();
        selClip.addRect(this.__bounds.x, this.__bounds.y, a, this.__bounds.h);
        selContainer.setClipPath(selClip);

        hoverContainer = container.getChildAt(2);
        if (hoverContainer) {
          hoverClip = new dvt.ClipPath();
          hoverClip.addRect(this.__bounds.x, this.__bounds.y, b, this.__bounds.h);
          hoverContainer.setClipPath(hoverClip);
        }
      } else {
        // Set the clip rect size.
        unselContainer = container.getChildAt(0);
        unselClip = new dvt.ClipPath();
        unselClip.addRect(this.__bounds.x, this.__bounds.y, this.__bounds.w - c, this.__bounds.h);
        unselContainer.setClipPath(unselClip);

        selContainer = container.getChildAt(1);
        selClip = new dvt.ClipPath();
        selClip.addRect(this.__bounds.x + this.__bounds.w - c, this.__bounds.y, a, this.__bounds.h);
        selContainer.setClipPath(selClip);

        hoverContainer = container.getChildAt(2);
        if (hoverContainer) {
          hoverClip = new dvt.ClipPath();
          hoverClip.addRect(
            this.__bounds.x + this.__bounds.w - c,
            this.__bounds.y,
            b,
            this.__bounds.h
          );
          hoverContainer.setClipPath(hoverClip);
        }
      }
    }

    /**
     * Return the led gauge drawn at the given index.
     * Internal API used for Automation purposes.
     * @param {Number} index
     * @return {dvt.Displayable}
     */
    __getRatingGaugeItem(index) {
      // Returning the unselected shape at the given index.
      return this._container.getChildAt(0).getChildAt(index);
    }

    /**
     * @override
     */
    CreateEventManager() {
      return new DvtRatingGaugeEventManager(this);
    }

    /**
     * @override
     */
    IsInteractive() {
      if (this.Options.disabled) {
        return false;
      }
      return super.IsInteractive(this);
    }
  }

  /**
   * Default values and utility functions for component versioning.
   * @class
   * @constructor
   * @param {dvt.Context} context The rendering context.
   * @extends {DvtGaugeDefaults}
   */
  class DvtStatusMeterGaugeDefaults extends DvtGaugeDefaults {
    constructor(context) {
      const SKIN_ALTA = {
        angleExtent: 360,
        borderRadius: 'auto',
        color: '#393737',
        indicatorSize: 1,
        innerRadius: 0.7,
        metricLabel: {
          style: new dvt.CSSStyle(dvt.BaseComponentDefaults.FONT_FAMILY_ALTA),
          position: 'auto'
        },
        orientation: 'horizontal',
        plotArea: { color: '#E4E8EA', rendered: 'auto', borderRadius: 'auto' },
        startAngle: 90,
        thresholdDisplay: 'onIndicator'
      };
      super({ alta: SKIN_ALTA }, context);
    }
  }

  /**
   * Calculated axis information and drawable creation.
   * @class
   * @constructor
   * @extends {BaseAxisInfo}
   */
  class DvtGaugeDataAxisInfo extends ojdvtAxis.DataAxisInfoMixin(ojdvtAxis.BaseAxisInfo) {}

  /**
   * Utility functions for StatusMeter.
   * @class
   */
  const DvtStatusMeterGaugeUtils = {
    /**
     * Returns the location of the point on the arc with the specified radius
     * at the specified angle.
     * @param {dvt.Rectangle} bounds
     * @param {number} radius
     * @param {number} angle
     * @return {object} An object with x and y properties.
     * @private
     */
    calcPointOnArc: (bounds, radius, angle) => {
      var x = Math.cos(angle) * radius + bounds.w / 2 + bounds.x;
      var y = Math.sin(angle) * radius + bounds.h / 2 + bounds.y;
      return { x: x, y: y };
    },
    /**
     * Calculates and returns the path command for the circular shape.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {Number} startAngle
     * @param {Number} angleExtent
     * @param {Number} innerRadius
     * @param {Number} outerRadius
     * @return {string} The path command for the shape.
     */
    createCircularPathCmd: (bounds, startAngle, angleExtent, innerRadius, outerRadius) => {
      var cmd;
      var p1, p2, p3, p4;

      if (angleExtent < dvt.Math.TWO_PI) {
        // Calc the 4 points.  We will draw:
        // 1. Arc from p1 to p2
        // 2. Line/Move from p2 to p3
        // 3. Arc from p3 to p4
        // 4. Line from p4 to p1
        p1 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, outerRadius, startAngle);
        p2 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, outerRadius, startAngle + angleExtent);
        p3 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, innerRadius, startAngle + angleExtent);
        p4 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, innerRadius, startAngle);

        // Create the command and feed it into the path
        cmd =
          dvt.PathUtils.moveTo(p1.x, p1.y) +
          dvt.PathUtils.arcTo(outerRadius, outerRadius, angleExtent, 1, p2.x, p2.y) +
          dvt.PathUtils.lineTo(p3.x, p3.y) +
          dvt.PathUtils.arcTo(innerRadius, innerRadius, angleExtent, 0, p4.x, p4.y) +
          dvt.PathUtils.closePath();
      } else {
        // To work around a chrome/safari bug, we draw two segments around each of the outer and inner arcs
        p1 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, outerRadius, startAngle);
        p2 = DvtStatusMeterGaugeUtils.calcPointOnArc(
          bounds,
          outerRadius,
          startAngle + angleExtent / 2
        );
        p3 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, innerRadius, startAngle);
        p4 = DvtStatusMeterGaugeUtils.calcPointOnArc(
          bounds,
          innerRadius,
          startAngle + angleExtent / 2
        );

        // Create the command and return it
        cmd =
          dvt.PathUtils.moveTo(p1.x, p1.y) +
          dvt.PathUtils.arcTo(outerRadius, outerRadius, angleExtent / 2, 1, p2.x, p2.y) +
          dvt.PathUtils.arcTo(outerRadius, outerRadius, angleExtent / 2, 1, p1.x, p1.y);

        // Add the inner segment for a hollow center
        if (innerRadius > 0)
          cmd +=
            dvt.PathUtils.moveTo(p4.x, p4.y) +
            dvt.PathUtils.arcTo(innerRadius, innerRadius, angleExtent / 2, 0, p3.x, p3.y) +
            dvt.PathUtils.arcTo(innerRadius, innerRadius, angleExtent / 2, 0, p4.x, p4.y);

        cmd += dvt.PathUtils.closePath();
      }
      return cmd;
    }
  };

  /**
   * Indicator for the circular DvtStatusMetergauge.
   * @class
   * @constructor
   * @extends {dvt.Path}
   * @param {dvt.Context} context The rendering context
   * @param {dvt.Rectangle} bounds The available bounds for rendering.
   * @param {Number} startAngle
   * @param {Number} angleExtent
   * @param {Number} innerRadius
   * @param {Number} outerRadius
   */
  class DvtStatusMeterGaugeCircularIndicator extends dvt.Path {
    /**
     * Initializes the component.
     * @param {dvt.Context} context The rendering context
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {Number} startAngle
     * @param {Number} angleExtent
     * @param {Number} innerRadius
     * @param {Number} outerRadius
     * @protected
     * */
    constructor(context, bounds, startAngle, angleExtent, innerRadius, outerRadius) {
      super(context);
      this.setPath(bounds, startAngle, angleExtent, innerRadius, outerRadius);
    }

    /**
     * Specifies the coordinates for the indicator.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {Number} startAngle
     * @param {Number} angleExtent
     * @param {Number} innerRadius
     * @param {Number} outerRadius
     */
    setPath(bounds, startAngle, angleExtent, innerRadius, outerRadius) {
      if (bounds && bounds instanceof dvt.Rectangle) this._bounds = bounds;
      else bounds = this._bounds;
      this._startAngle = startAngle;
      this._angleExtent = angleExtent;
      this._innerRadius = innerRadius;
      this._outerRadius = outerRadius;

      this.setCmds(
        DvtStatusMeterGaugeUtils.createCircularPathCmd(
          bounds,
          startAngle,
          angleExtent,
          innerRadius,
          outerRadius
        )
      );
    }

    /**
     * Animation support.
     * @return {array}
     */
    getAnimParams() {
      return [
        this._bounds,
        this._startAngle,
        this._angleExtent,
        this._innerRadius,
        this._outerRadius
      ];
    }

    /**
     * Animation support.
     * @param {array} params
     */
    setAnimParams(params) {
      if (params && params.length == 5)
        this.setPath(params[0], params[1], params[2], params[3], params[4]);
    }
  }

  class DvtStatusMeterGaugeIndicator extends dvt.Path {
    /**
     * Initializes the component.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Context} context The rendering context
     * @param {number} x1
     * @param {number} x2
     * @param {number} y1
     * @param {number} y2
     * @protected
     */
    constructor(gauge, context, x1, x2, y1, y2) {
      super(context);
      this._gauge = gauge;

      // Set the coordinates of the shape based on the params
      this.setCoords(x1, x2, y1, y2);
    }

    /**
     * Specifies the coordinates for the indicator.
     * @param {number} x1
     * @param {number} x2
     * @param {number} y1
     * @param {number} y2
     */
    setCoords(x1, x2, y1, y2) {
      // Store these params
      this._x1 = x1;
      this._x2 = x2;
      this._y1 = y1;
      this._y2 = y2;

      // Convert into rectangle coordinates and set
      var x = Math.min(x1, x2);
      var y = Math.min(y1, y2);
      var width = Math.abs(x1 - x2);
      var height = Math.abs(y2 - y1);
      var options = this._gauge.getOptions();
      var multiplier = options['orientation'] == 'vertical' ? width : height;
      var defaultValue = '15%';

      var cmds = dvt.PathUtils.rectangleWithBorderRadius(
        x,
        y,
        width,
        height,
        options['borderRadius'],
        multiplier,
        defaultValue
      );
      this.setCmds(cmds);
    }

    /**
     * Animation support.
     * @return {array}
     */
    getAnimParams() {
      return [this._x1, this._x2, this._y1, this._y2];
    }

    /**
     * Animation support.
     * @param {array} params
     */
    setAnimParams(params) {
      if (params && params.length === 4) this.setCoords(params[0], params[1], params[2], params[3]);
    }
  }

  /**
   * Renderer for StatusMeterGauge.
   * @class
   */
  const DvtStatusMeterGaugeRenderer = {
    /**
     * Renders the gauge in the specified area.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {number} width The width of the component.
     * @param {number} height The height of the component.
     */
    render: (gauge, container, width, height) => {
      if (DvtGaugeDataUtils.hasData(gauge)) {
        // Allocate the outer gap for the component
        var options = gauge.getOptions();
        var outerGap = options['__layout']['outerGap'];
        var bounds = new dvt.Rectangle(
          outerGap,
          outerGap,
          width - 2 * outerGap,
          height - 2 * outerGap
        );

        if (options['orientation'] == 'horizontal' || options['orientation'] == 'vertical') {
          // Render metric label outside of plot area. Metric labels within the plot area are handled within
          // the renderShape function.
          if (DvtStatusMeterGaugeRenderer._hasMetricLabelOutsidePlotArea(options))
            DvtStatusMeterGaugeRenderer._renderMetricLabelOutsidePlotArea(gauge, container, bounds);

          DvtStatusMeterGaugeRenderer._renderShape(gauge, container, bounds);
        } else if (options['orientation'] == 'circular') {
          DvtStatusMeterGaugeRenderer._renderCircularGauge(gauge, container, bounds);
        }
      } // Render the empty text
      else DvtGaugeRenderer.renderEmptyText(gauge, container, new dvt.Rectangle(0, 0, width, height));
    },

    /**
     * Renders the circular shape into the specified area.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @private
     */
    _renderCircularGauge: (gauge, container, bounds) => {
      var options = gauge.getOptions();
      var containerBounds = bounds.clone();
      var isRTL = dvt.Agent.isRightToLeft(gauge.getCtx());
      var percentFill = 0;
      var metricLabelBounds = null;
      var value = options['value'];
      var innerRadius = options['innerRadius'];
      var thresholds = options['thresholds'];
      var maxDiameter,
        maxInnerDiameter = null;
      var startAngleRads = dvt.Math.TWO_PI - dvt.Math.degreesToRads(options['startAngle']);
      var angleExtentRads = dvt.Math.degreesToRads(options['angleExtent']);
      var endAngle = (startAngleRads + angleExtentRads) % (2 * Math.PI);

      // Store center for editable gauges
      gauge.cx = bounds.w / 2;
      gauge.cy = bounds.h / 2;
      // Determine start quadrant and end quadrent
      if (angleExtentRads != 2 * Math.PI) {
        metricLabelBounds = DvtStatusMeterGaugeRenderer._adjustCenterAndBounds(
          gauge,
          innerRadius,
          startAngleRads,
          angleExtentRads,
          endAngle,
          bounds,
          isRTL
        );
        maxInnerDiameter = gauge.maxInnerDiameter;
      }
      maxDiameter = Math.min(bounds.w, bounds.h);
      var innerRadiusLength = maxDiameter * 0.5 * innerRadius;
      var outerRadius = maxDiameter * 0.5;
      var indicatorSize = options['indicatorSize'];
      if (indicatorSize && indicatorSize > 1) {
        var spaceWidth = ((1 - 1 / indicatorSize) / 2) * (outerRadius - innerRadiusLength);
        innerRadiusLength += spaceWidth;
        outerRadius -= spaceWidth;
      }
      // Add metric label first
      var metricLabelHalign = 'center';
      var metricLabelValign = 'middle';
      if (!metricLabelBounds) {
        maxInnerDiameter = Math.min(bounds.w, bounds.h) * innerRadius;
        // Center label bounds within the space available.
        metricLabelBounds = new dvt.Rectangle(
          bounds.x + bounds.w / 2 - maxInnerDiameter * (3 / 7),
          bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7),
          maxInnerDiameter * (6 / 7),
          maxInnerDiameter * (5 / 7)
        );
      }

      var bLabelRendered = false;
      if (options['label']['text']) {
        var labelValign = 'middle';
        var labelSpace = new dvt.Rectangle(
          metricLabelBounds.x,
          metricLabelBounds.y,
          metricLabelBounds.w,
          metricLabelBounds.h
        );
        // If both the label and metricLabel are rendered 1/3 of the available space is allocated for the label
        if (options['metricLabel']['rendered'] != 'off') {
          labelSpace.y = labelSpace.y + labelSpace.h * 0.6;
          labelSpace.h = labelSpace.h * 0.4;
          labelValign = 'top';
        }
        bLabelRendered = DvtGaugeRenderer.renderLabel(
          gauge,
          container,
          labelSpace,
          null,
          labelValign
        );
        if (bLabelRendered && options['metricLabel']['rendered'] != 'off') {
          metricLabelBounds.h = metricLabelBounds.h * 0.55;
          metricLabelValign = 'bottom';
        }
      }
      DvtGaugeRenderer.renderMetricLabel(
        gauge,
        container,
        metricLabelBounds,
        null,
        metricLabelHalign,
        metricLabelValign,
        options['metricLabel']['rendered'] === 'on'
      );

      var startAngle = startAngleRads;
      var angleExtent = percentFill * angleExtentRads;
      var plotAreaBorderColor = DvtGaugeStyleUtils.getPlotAreaBorderColor(gauge);
      if (
        thresholds &&
        options['plotArea']['rendered'] != 'off' &&
        options['thresholdDisplay'] == 'all'
      ) {
        for (
          var currentThresholdIndex = 0;
          currentThresholdIndex < thresholds.length;
          currentThresholdIndex++
        ) {
          var thresholdColor = DvtGaugeStyleUtils.getThresholdColor(
            gauge,
            thresholds[currentThresholdIndex],
            currentThresholdIndex
          );
          var max =
            thresholds[currentThresholdIndex]['max'] < options['max'] &&
            currentThresholdIndex != thresholds.length - 1
              ? thresholds[currentThresholdIndex]['max']
              : options['max'];
          var min =
            currentThresholdIndex == 0
              ? options['min']
              : thresholds[currentThresholdIndex - 1]['max'];
          startAngle =
            startAngleRads +
            angleExtentRads * DvtGaugeRenderer.getFillPercentage(options, options['min'], max, min);
          percentFill = DvtGaugeRenderer.getFillPercentage(options, min, max, max);
          angleExtent = percentFill * angleExtentRads;
          var thresholdborderColor = thresholds[currentThresholdIndex]['borderColor'];
          DvtStatusMeterGaugeRenderer._drawCircularArc(
            gauge,
            container,
            bounds,
            startAngle,
            angleExtent,
            innerRadiusLength,
            outerRadius,
            thresholdColor,
            true,
            thresholdborderColor ? thresholdborderColor : plotAreaBorderColor
          );
        }
      } else if (options['plotArea']['rendered'] != 'off' && options['thresholdDisplay'] != 'all') {
        var plotAreaColor = DvtGaugeStyleUtils.getPlotAreaColor(gauge);
        DvtStatusMeterGaugeRenderer._drawCircularArc(
          gauge,
          container,
          bounds,
          startAngleRads,
          angleExtentRads,
          innerRadiusLength,
          outerRadius,
          plotAreaColor,
          true,
          plotAreaBorderColor
        );
      }

      innerRadiusLength = maxDiameter * innerRadius * 0.5;
      outerRadius = maxDiameter * 0.5;
      if (indicatorSize && indicatorSize < 1) {
        var totalWidth = ((1 - indicatorSize) / 2) * (outerRadius - innerRadiusLength);
        innerRadiusLength += totalWidth;
        outerRadius -= totalWidth;
      }

      percentFill = DvtGaugeRenderer.getFillPercentage(
        options,
        options['min'],
        options['max'],
        value
      );
      angleExtent = percentFill * angleExtentRads;
      DvtStatusMeterGaugeRenderer._drawCircularArc(
        gauge,
        container,
        bounds,
        startAngleRads,
        angleExtent,
        innerRadiusLength,
        outerRadius,
        DvtGaugeStyleUtils.getColor(gauge),
        false
      );

      // Reference lines
      var referenceObjects = options['referenceLines'];
      if (referenceObjects) {
        for (var i = 0; i < referenceObjects.length; i++) {
          var referenceLineColor = referenceObjects[i]['color']
            ? referenceObjects[i]['color']
            : 'black';
          var referenceLineWidth = referenceObjects[i]['lineWidth']
            ? referenceObjects[i]['lineWidth']
            : 2;
          var referenceLineStyle = referenceObjects[i]['lineStyle'];
          value = referenceObjects[i]['value'];
          var angle =
            startAngleRads +
            DvtGaugeRenderer.getFillPercentage(options, options['min'], options['max'], value) *
              angleExtentRads;
          DvtStatusMeterGaugeRenderer._drawCircularReferenceLine(
            gauge,
            container,
            bounds,
            angle,
            referenceLineColor,
            referenceLineWidth,
            referenceLineStyle
          );
        }
      }
      if (options['center']['renderer'])
        DvtStatusMeterGaugeRenderer._renderCenterContent(
          gauge,
          options,
          bounds,
          containerBounds,
          maxInnerDiameter
        );
    },

    /**
     * Renders the status meter shape into the specified area.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @private
     */
    _renderShape: (gauge, container, bounds) => {
      var options = gauge.getOptions();
      var isRTL = dvt.Agent.isRightToLeft(gauge.getCtx());
      var isVert = options['orientation'] == 'vertical';

      // Create an axis info to find the coords of values.
      var axisOptions = {
        isRTL: isRTL,
        layout: {
          gapRatio: 0
        },
        timeAxisType: 'disabled',
        position: isVert ? 'left' : 'bottom',
        min: options['min'],
        max: options['max'],
        dataMin: options['min'],
        dataMax: options['max'],
        tickLabel: {
          rendered: 'off'
        },
        translations: options.translations
      };
      var axisInfo = new DvtGaugeDataAxisInfo(gauge.getCtx(), axisOptions, bounds);

      // Store the axisInfo on the gauge for editing support
      gauge.__axisInfo = axisInfo;

      // First calculate the baseline coordinate.
      var baseline = 0;
      if (options['max'] <= 0) baseline = options['max'];
      else if (options['min'] >= 0) baseline = options['min'];

      var baselineCoord = axisInfo.getCoordAt(baseline);
      // For statusmeters with plot area on, always draw from min value
      if (
        options['plotArea']['rendered'] != 'off' &&
        !(options['plotArea']['rendered'] == 'auto' && options['thresholdDisplay'] == 'onIndicator')
      )
        baselineCoord = axisInfo.getUnboundedCoordAt(options['min']);

      // Calculate the endCoord.  Adjust to keep within the axis.
      var endCoord = axisInfo.getUnboundedCoordAt(options['value']);
      endCoord = isVert
        ? Math.max(bounds.y, Math.min(bounds.y + bounds.h, endCoord))
        : Math.max(bounds.x, Math.min(bounds.x + bounds.w, endCoord));

      var indicatorSize = options['indicatorSize'];
      var indicatorX1,
        indicatorX2,
        indicatorY1,
        indicatorY2,
        plotX1,
        plotX2,
        plotY1,
        plotY2 = 0;

      // The variables drawnPlotSize and drawnIndicatorSize are used to specifiy the fraction
      // of the possible width that will be used for plotArea and the indicator
      var drawnPlotSize = indicatorSize < 1 ? 1 : indicatorSize;
      var drawnIndicatorSize = indicatorSize > 1 ? 1 : indicatorSize;
      var delta = Math.min(0.5, (Math.abs(endCoord - baselineCoord) - 0.5) / 2); // Indicator should be at least 0.5px
      var sign;
      if (isVert) {
        sign = endCoord > baselineCoord ? -1 : 1;
        indicatorX1 = bounds.x + ((1 - drawnIndicatorSize) / 2) * bounds.w;
        indicatorX2 = bounds.x + (bounds.w * (1 + drawnIndicatorSize)) / 2;
        indicatorY2 = baselineCoord - sign * delta;
        indicatorY1 = endCoord + sign * delta + 0.5;
        plotX1 = bounds.x + ((1 - 1 / drawnPlotSize) / 2) * bounds.w;
        plotX2 = bounds.x + (bounds.w * (1 + 1 / drawnPlotSize)) / 2;
        plotY1 = bounds.y;
        plotY2 = bounds.y + bounds.h;
      } else {
        var isNegative = isRTL ? endCoord > baselineCoord : endCoord < baselineCoord;
        sign = isNegative ? -1 : 1;
        indicatorX1 = isRTL ? baselineCoord - sign * delta + 0.5 : baselineCoord + sign * delta - 0.5;
        indicatorX2 = isRTL ? endCoord + sign * delta : endCoord - sign * delta;
        indicatorY1 = bounds.y + ((1 - drawnIndicatorSize) / 2) * bounds.h;
        indicatorY2 = bounds.y + (bounds.h * (1 + drawnIndicatorSize)) / 2;
        plotX1 = bounds.x;
        plotX2 = bounds.x + bounds.w;
        plotY1 = bounds.y + ((1 - 1 / drawnPlotSize) / 2) * bounds.h;
        plotY2 = bounds.y + (bounds.h * (1 + 1 / drawnPlotSize)) / 2;
      }

      var bRender = true;
      if (options['value'] == options['min']) {
        if (isVert) indicatorY1 = indicatorY2;
        else indicatorX1 = indicatorX2;
        bRender = false; // don't draw an empty bar
      }

      // Create plotArea
      var borderColor = DvtGaugeStyleUtils.getBorderColor(gauge);
      var plotAreaBorderColor = DvtGaugeStyleUtils.getPlotAreaBorderColor(gauge);
      var thresholds = options['thresholds'];
      var gradientAngle = isVert ? 0 : 270;

      // Case for plot area with all thresholds displayed
      var plotArea;
      var i;
      if (
        thresholds &&
        options['plotArea']['rendered'] != 'off' &&
        options['thresholdDisplay'] == 'all'
      ) {
        for (i = thresholds.length - 1; i >= 0; i--) {
          var currentThresholdIndex = i;
          plotArea = DvtStatusMeterGaugeRenderer._createShape(
            gauge,
            gauge.getCtx(),
            plotX1,
            plotX2,
            plotY1,
            plotY2
          );

          var cp = new dvt.ClipPath('pacp' + gauge.getId());

          // For each threshold clip everything above the particular threshold maximum from the plot area shape
          if (i == thresholds.length - 1) {
            if (!isVert && isRTL)
              cp.addRect(
                axisInfo.getUnboundedCoordAt(options['max']) + 1,
                0,
                bounds.w + 2,
                bounds.h + 2,
                0,
                0
              );
            else cp.addRect(0, 0, bounds.w + 2, bounds.h + 2, 0, 0);
          } else {
            if (isVert) {
              var h =
                options['max'] - thresholds[thresholds.length - 2 - currentThresholdIndex]['max'];
              cp.addRect(
                0,
                axisInfo.getUnboundedCoordAt(options['max']),
                bounds.w + 2,
                ((Math.max(0, h) * 1) / Math.abs(options['min'] - options['max'])) * bounds.h,
                0,
                0
              );
            } else {
              if (isRTL) {
                var thresholdMax =
                  thresholds[thresholds.length - 2 - currentThresholdIndex]['max'] == null
                    ? 100
                    : thresholds[thresholds.length - 2 - currentThresholdIndex]['max'];
                cp.addRect(
                  axisInfo.getUnboundedCoordAt(options['max']),
                  0,
                  ((Math.max(0, options['max'] - thresholdMax) * 1) /
                    Math.abs(options['min'] - options['max'])) *
                    bounds.w,
                  bounds.h + 2,
                  0,
                  0
                );
              } else {
                var w = thresholds[currentThresholdIndex]['max'] - options['min'];
                cp.addRect(
                  0,
                  0,
                  ((Math.max(0, w) * 1) / Math.abs(options['min'] - options['max'])) * bounds.w,
                  bounds.h + 2,
                  0,
                  0
                );
              }
            }
          }
          plotArea.setClipPath(cp);

          // Color threshold with defined color, or use the color ramp if possible
          if (isRTL || isVert) currentThresholdIndex = thresholds.length - 1 - i;

          plotArea.setSolidFill(
            DvtGaugeStyleUtils.getThresholdColor(
              gauge,
              thresholds[currentThresholdIndex],
              currentThresholdIndex
            )
          );
          var thresholdBorderColor = thresholds[currentThresholdIndex]['borderColor'];
          plotArea.setSolidStroke(thresholdBorderColor ? thresholdBorderColor : plotAreaBorderColor);
          DvtStatusMeterGaugeRenderer._renderPlotAreaVisualEffects(
            gauge,
            container,
            plotArea,
            DvtGaugeStyleUtils.getThresholdColor(
              gauge,
              thresholds[currentThresholdIndex],
              currentThresholdIndex
            ),
            gradientAngle
          );
        }
      } else if (
        options['plotArea']['rendered'] !== 'off' &&
        !(
          options['plotArea']['rendered'] == 'auto' && options['thresholdDisplay'] == 'onIndicator'
        ) &&
        options['thresholdDisplay'] != 'all'
      ) {
        plotArea = isVert
          ? DvtStatusMeterGaugeRenderer._createShape(
              gauge,
              gauge.getCtx(),
              plotX1,
              plotX2,
              axisInfo.getUnboundedCoordAt(options['max']),
              axisInfo.getUnboundedCoordAt(options['min'])
            )
          : DvtStatusMeterGaugeRenderer._createShape(
              gauge,
              gauge.getCtx(),
              axisInfo.getUnboundedCoordAt(options['min']),
              axisInfo.getUnboundedCoordAt(options['max']),
              plotY1,
              plotY2
            );
        var plotAreaColor = DvtGaugeStyleUtils.getPlotAreaColor(gauge);
        plotArea.setSolidFill(plotAreaColor);
        plotArea.setSolidStroke(plotAreaBorderColor);
        DvtStatusMeterGaugeRenderer._renderPlotAreaVisualEffects(
          gauge,
          container,
          plotArea,
          plotAreaColor,
          gradientAngle
        );
      }

      // Create the indicator.
      var shape = new DvtStatusMeterGaugeIndicator(
        gauge,
        gauge.getCtx(),
        indicatorX1,
        indicatorX2,
        indicatorY1,
        indicatorY2
      );
      gauge.__shapes.push(shape);

      // Apply style properties
      var color = DvtGaugeStyleUtils.getColor(gauge);
      if (gauge.getCtx().getThemeBehavior() === 'redwood' || options['visualEffects'] === 'none') {
        shape.setSolidFill(color);
        shape.setSolidStroke(color);
      } else {
        var arColors = [
          dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04),
          dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05)
        ];
        var arAlphas = [1, 1];
        var arStops = [0, 1];
        var gradient = new dvt.LinearGradientFill(gradientAngle, arColors, arAlphas, arStops);
        shape.setFill(gradient);
      }

      if (borderColor) shape.setSolidStroke(borderColor);

      shape.setClassName(options['svgClassName']);
      shape.setStyle(options['svgStyle']);

      // Add the shape
      if (bRender) container.addChild(shape);

      // Render the visual effects
      DvtStatusMeterGaugeRenderer._createShape(
        gauge,
        gauge.getCtx(),
        indicatorX1,
        indicatorX2,
        indicatorY1,
        indicatorY2
      );

      // Render reference objects
      var xCoord, yCoord;
      var referenceLine, referenceLineSize;
      var referenceObjects = options['referenceLines'];
      if (referenceObjects) {
        for (i = 0; i < referenceObjects.length; i++) {
          var refColor = referenceObjects[i]['color'] ? referenceObjects[i]['color'] : 'white';
          var value = referenceObjects[i]['value'];
          indicatorSize = options['indicatorSize'];
          if (isVert) {
            referenceLineSize = ((1 - indicatorSize) / 2 + indicatorSize) * bounds.w;
            xCoord = bounds.x + ((1 - indicatorSize) / 4) * bounds.w;
            yCoord = axisInfo.getUnboundedCoordAt(value);
            referenceLine = new dvt.Line(
              gauge.getCtx(),
              xCoord,
              yCoord,
              xCoord + referenceLineSize,
              yCoord
            );
          } else {
            referenceLineSize = ((1 - indicatorSize) / 2 + indicatorSize) * bounds.h;
            xCoord = axisInfo.getUnboundedCoordAt(value);
            yCoord = bounds.y + ((1 - indicatorSize) / 4) * bounds.h;
            referenceLine = new dvt.Line(
              gauge.getCtx(),
              xCoord,
              yCoord,
              xCoord,
              yCoord + referenceLineSize
            );
          }
          var lineWidth = referenceObjects[i]['lineWidth'] ? referenceObjects[i]['lineWidth'] : 2;
          var lineStyle = referenceObjects[i]['lineStyle'];
          var stroke = new dvt.Stroke(
            refColor,
            1,
            lineWidth,
            false,
            dvt.Stroke.getDefaultDashProps(lineStyle, lineWidth)
          );
          referenceLine.setStroke(stroke);
          container.addChild(referenceLine);

          // Shadowing effect
          // Fix for : Shadow causes the reference line to disappear in IE11
          if (
            dvt.Agent.browser !== 'ie' &&
            dvt.Agent.browser !== 'edge' &&
            options['visualEffects'] != 'none'
          ) {
            var shadow = new dvt.Shadow(0.5, 0.5, 1, 'rgba(0, 0, 0, 0.8)');
            referenceLine.addDrawEffect(shadow);
          }
        }
      }

      // Render the metric label within the plot area bounds
      var metricLabelPosition = options['metricLabel']['position'];
      if (
        options['metricLabel']['rendered'] == 'on' &&
        !DvtStatusMeterGaugeRenderer._hasMetricLabelOutsidePlotArea(options) &&
        !options['label']['text']
      ) {
        var indicatorPoints = { x1: indicatorX1, x2: indicatorX2, y1: indicatorY1, y2: indicatorY2 };
        var plotAreaPoints = { x1: plotX1, x2: plotX2, y1: plotY1, y2: plotY2 };
        DvtStatusMeterGaugeRenderer._renderMetricLabelInsidePlotArea(
          gauge,
          container,
          bounds,
          color,
          metricLabelPosition,
          indicatorPoints,
          plotAreaPoints
        );
      }

      // Render the label
      else if (options['label']['text']) {
        DvtStatusMeterGaugeRenderer._renderLabel(gauge, container, bounds, metricLabelPosition);
      }
    },

    /**
     * Creates and returns the shape for the statusmeter.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Context} context
     * @param {number} x1
     * @param {number} x2
     * @param {number} y1
     * @param {number} y2
     * @return {dvt.Path}
     * @private
     */
    _createShape: (gauge, context, x1, x2, y1, y2) => {
      var x = Math.min(x1, x2);
      var y = Math.min(y1, y2);
      var width = Math.abs(x1 - x2);
      var height = Math.abs(y2 - y1);
      var options = gauge.getOptions();
      var multiplier = options['orientation'] == 'vertical' ? width : height;
      var defaultValue = '15%';
      var borderRadiusInput =
        options['plotArea']['borderRadius'] != 'auto'
          ? options['plotArea']['borderRadius']
          : options['borderRadius'];
      var cmds = dvt.PathUtils.rectangleWithBorderRadius(
        x,
        y,
        width,
        height,
        borderRadiusInput,
        multiplier,
        defaultValue
      );
      return new dvt.Path(context, cmds);
    },

    /**
     * Renders the visual effects for the plot area.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Shape} shape The plot area.
     * @param {string} color
     * @param {number} gradientAngle
     * @private
     */
    _renderPlotAreaVisualEffects: (gauge, container, shape, color, gradientAngle) => {
      var options = gauge.getOptions();
      shape.setMouseEnabled(false);
      container.addChild(shape);

      if (gauge.getCtx().getThemeBehavior() !== 'redwood' && options['visualEffects'] !== 'none') {
        // Gradient
        var arColors = [
          dvt.ColorUtils.adjustHSL(color, 0, -0.04, -0.05),
          dvt.ColorUtils.adjustHSL(color, 0, -0.09, 0.04)
        ];
        var gradient = new dvt.LinearGradientFill(gradientAngle, arColors, [1, 1], [0, 1]);
        shape.setFill(gradient);
      }
      shape.setClassName(options['plotArea']['svgClassName']);
      shape.setStyle(options['plotArea']['svgStyle']);
    },

    /**
     * Renders the metricLabel into the specified area for vertical/horizontal status meter gauges with the metricLabel outside the plotarea.
     * Updates the bounds after rendering to reserve space for the labels.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @private
     */
    _renderMetricLabelOutsidePlotArea: (gauge, container, bounds) => {
      var options = gauge.getOptions();
      var isRTL = dvt.Agent.isRightToLeft(gauge.getCtx());
      var isVert = options['orientation'] == 'vertical';
      var metricLabel = new dvt.OutputText(gauge.getCtx(), '');
      var metricLabelString = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
      var metricLabelGap = options['__layout']['labelGap'];
      var metricLabelStyle = options['metricLabel']['style'];

      // Backward compatibility
      var metricLabelColor = metricLabelStyle.getStyle('color');
      metricLabelColor = metricLabelColor ? metricLabelColor : '#333333';

      var maxMetricLabelDims = null;
      metricLabel.setCSSStyle(metricLabelStyle);
      metricLabel.setSolidFill(metricLabelColor);

      var size;
      var minMetricLabel;
      var maxMetricLabel;
      var bound;
      var maxValue;
      if (isVert && options['metricLabel']['rendered'] == 'on') {
        bound = options['max'] > 0 ? options['max'] : options['min'];
        maxValue = DvtGaugeRenderer.getFormattedMetricLabel(bound, gauge);
        maxMetricLabel = new dvt.OutputText(gauge.getCtx(), maxValue);
        maxMetricLabel.setCSSStyle(metricLabelStyle);
        var computedMetricLabelBounds = new dvt.Rectangle(
          bounds.x,
          bounds.y + 0.8 * bounds.h,
          bounds.w,
          0.2 * bounds.h
        );
        size =
          metricLabelStyle.getStyle('font-size') ||
          dvt.TextUtils.getOptimalFontSize(
            maxMetricLabel.getCtx(),
            maxMetricLabel.getTextString(),
            maxMetricLabel.getCSSStyle(),
            computedMetricLabelBounds
          );
        maxMetricLabel.setFontSize(size);
        maxMetricLabelDims = maxMetricLabel.getDimensions();
        bounds.h -= maxMetricLabelDims.h;
        //alignCoord = bounds.y - maxMetricLabelDims.h;
        //metricLabelSpace = maxMetricLabelDims.w;
        metricLabel.setFontSize(size);
        metricLabel.setTextString(metricLabelString);
        metricLabel.setX(bounds.x + bounds.w / 2);
        metricLabel.setY(bounds.y + bounds.h);
        bounds.h -= metricLabelGap;
        metricLabel.alignCenter();
        dvt.TextUtils.fitText(metricLabel, bounds.w, bounds.h, container);
      }
      // Allocate space for the horizontal metricLabel
      else if (!isVert && options['metricLabel']['rendered'] == 'on') {
        // Check if the metric label's height will fit
        size = metricLabelStyle.getStyle('font-size');
        minMetricLabel = DvtGaugeRenderer.getFormattedMetricLabel(options['min'], gauge);
        maxMetricLabel = DvtGaugeRenderer.getFormattedMetricLabel(options['max'], gauge);
        if (size === undefined && bounds.h < 18) {
          size = DvtGaugeRenderer.calcLabelFontSize(
            [metricLabelString, minMetricLabel, maxMetricLabel],
            metricLabel,
            bounds
          );
        }
        size = size ? parseInt(size) : 13;
        metricLabel.setFontSize(size);

        var alignCoord; // The horizontal alignment point for the metricLabel
        // Allocate space to the right for positive values and any values with plotArea
        if (
          options['max'] > 0 ||
          options['plotArea']['rendered'] != 'off' ||
          !(options['plotArea']['rendered'] == 'auto' && options['thresholdDisplay'] == 'onIndicator')
        ) {
          bound = options['max'] > 0 ? options['max'] : options['min'];
          maxValue = DvtGaugeRenderer.getFormattedMetricLabel(bound, gauge);
          maxMetricLabel = new dvt.OutputText(gauge.getCtx(), maxValue);
          maxMetricLabel.setCSSStyle(metricLabelStyle);
          maxMetricLabel.setFontSize(size);
          maxMetricLabelDims = maxMetricLabel.getDimensions();
          maxMetricLabelDims.w = Math.min(maxMetricLabelDims.w, bounds.w);
          // Align the metricLabel
          alignCoord = isRTL ? bounds.x + maxMetricLabelDims.w : bounds.x + bounds.w;
          var metricLabelSpace = maxMetricLabelDims.w;

          if (isRTL) {
            // Allocate to the left
            bounds.x += maxMetricLabelDims.w + metricLabelGap;
            bounds.w -= maxMetricLabelDims.w + metricLabelGap;
          } else {
            // Allocate to the right
            bounds.w -= maxMetricLabelDims.w + metricLabelGap;
          }
        }

        // Allocate space to the left for negative values
        if (
          options['min'] < 0 &&
          options['plotArea']['rendered'] != 'on' &&
          !(options['plotArea']['rendered'] == 'auto' && options['thresholdDisplay'] == 'onIndicator')
        ) {
          var minValue = DvtGaugeRenderer.getFormattedMetricLabel(options['min'], gauge);
          minMetricLabel = new dvt.OutputText(gauge.getCtx(), minValue);
          minMetricLabel.setCSSStyle(metricLabelStyle);
          minMetricLabel.setFontSize(size);
          var minMetricLabelDims = minMetricLabel.getDimensions();

          // Align the metricLabel
          if (options['value'] < 0 || options['max'] <= 0) {
            alignCoord = isRTL ? bounds.x + bounds.w : bounds.x + minMetricLabelDims.w;
            metricLabelSpace = minMetricLabelDims.w;
          }

          // Update the allocated space
          if (isRTL)
            // Allocate to the right
            bounds.w -= minMetricLabelDims.w + metricLabelGap;
          else {
            // Allocate to the left
            bounds.x += minMetricLabelDims.w + metricLabelGap;
            bounds.w -= minMetricLabelDims.w + metricLabelGap;
          }
        }
        // Create and position the text
        metricLabel.setTextString(metricLabelString);
        metricLabel.setX(alignCoord);
        dvt.TextUtils.centerTextVertically(metricLabel, bounds.y + bounds.h / 2);
        metricLabel.alignRight();

        // Truncate to fit
        // : fire fox reports a bigger height by 1/2px.
        var maxHeight = dvt.Agent.browser === 'firefox' ? bounds.h + 2 : bounds.h;
        dvt.TextUtils.fitText(metricLabel, metricLabelSpace, maxHeight, container);
      }
    },

    /**
     * Renders the metricLabel into the specified area for vertical/horizontal status meter gauges with the metricLabel inside the plotarea.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {string} color The color of the background
     * @param {string} metricLabelPosition The position of the metricLabel
     * @param {object} indicator An object containing the indicator x1, y1, x2, y2.
     * @param {object} plotArea An object containing the plotArea x1, y1, x2, y2.
     * @param {boolean} repeatedTry Specifies if this is the second try to fit the metricLabel into available space
     * @private
     */
    _renderMetricLabelInsidePlotArea: (
      gauge,
      container,
      bounds,
      color,
      metricLabelPosition,
      indicator,
      plotArea,
      repeatedTry
    ) => {
      var options = gauge.getOptions();
      var isRTL = dvt.Agent.isRightToLeft(gauge.getCtx());
      var isVert = options['orientation'] == 'vertical';
      var plotAreaRendered = options['plotArea']['rendered'] == 'on';
      var hAlignment = 'center';
      var vAlignment = 'middle';

      var metricLabelSpace = new dvt.Rectangle(
        Math.min(indicator.x1, indicator.x2),
        Math.min(indicator.y1, indicator.y2),
        Math.abs(indicator.x2 - indicator.x1),
        Math.abs(indicator.y2 - indicator.y1)
      );
      var metricLabelColor = options['metricLabel']['style'].getStyle('color');
      if (metricLabelPosition == 'center') {
        metricLabelColor = metricLabelColor
          ? metricLabelColor
          : dvt.ColorUtils.getContrastingTextColor(color);
        if (isVert) {
          metricLabelSpace.h -= metricLabelSpace.w;
          metricLabelSpace.y += metricLabelSpace.w / 2;
        } else {
          metricLabelSpace.w -= metricLabelSpace.h;
          metricLabelSpace.x += metricLabelSpace.h / 2;
        }
      } else if (metricLabelPosition == 'insideIndicatorEdge') {
        metricLabelColor = metricLabelColor
          ? metricLabelColor
          : dvt.ColorUtils.getContrastingTextColor(color);
        if (isVert) {
          metricLabelSpace.h -= metricLabelSpace.w;
          metricLabelSpace.y += metricLabelSpace.w / 2;
          if (!plotAreaRendered && indicator.y1 > indicator.y2) {
            vAlignment = 'bottom';
          } else {
            vAlignment = 'top';
          }
        } else {
          metricLabelSpace.w -= metricLabelSpace.h;
          metricLabelSpace.x += metricLabelSpace.h / 2;
          if (isRTL) {
            if (!plotAreaRendered && indicator.x1 < indicator.x2) {
              hAlignment = 'right';
            } else {
              hAlignment = 'left';
            }
          } else {
            if (!plotAreaRendered && indicator.x1 > indicator.x2) {
              hAlignment = 'left';
            } else {
              hAlignment = 'right';
            }
          }
        }
      } else if (metricLabelPosition == 'outsideIndicatorEdge') {
        if (isVert) {
          metricLabelSpace.h = Math.abs(plotArea.y1 - indicator.y1) - metricLabelSpace.w;
          metricLabelSpace.y = plotArea.y1 + metricLabelSpace.w / 2;
          vAlignment = 'bottom';
          if (!plotAreaRendered && indicator.y1 > indicator.y2) {
            metricLabelSpace.h = Math.abs(plotArea.y2 - indicator.y1) - metricLabelSpace.w;
            metricLabelSpace.y = indicator.y1 + metricLabelSpace.w / 2;
            vAlignment = 'top';
          }
        } else {
          if (isRTL) {
            if (!plotAreaRendered && indicator.x1 < indicator.x2) {
              metricLabelSpace.w = Math.abs(plotArea.x2 - indicator.x2) - metricLabelSpace.h;
              metricLabelSpace.x = indicator.x2 + metricLabelSpace.h / 2;
              hAlignment = 'left';
            } else {
              metricLabelSpace.w = Math.abs(plotArea.x1 - indicator.x2) - metricLabelSpace.h;
              metricLabelSpace.x = plotArea.x1 + metricLabelSpace.h / 2;
              hAlignment = 'right';
            }
          } else {
            if (!plotAreaRendered && indicator.x1 > indicator.x2) {
              metricLabelSpace.w = Math.abs(plotArea.x1 - indicator.x2) - metricLabelSpace.h;
              metricLabelSpace.x = plotArea.x1 + metricLabelSpace.h / 2;
              hAlignment = 'right';
            } else {
              metricLabelSpace.w = Math.abs(plotArea.x2 - indicator.x2) - metricLabelSpace.h;
              metricLabelSpace.x = indicator.x2 + metricLabelSpace.h / 2;
              hAlignment = 'left';
            }
          }
        }
      }
      var metricLabelRendered = DvtGaugeRenderer.renderMetricLabel(
        gauge,
        container,
        metricLabelSpace,
        metricLabelColor,
        hAlignment,
        vAlignment
      );
      // If the metricLabel didn't fit, try to fit it into another section
      if (!metricLabelRendered && !repeatedTry) {
        if (metricLabelPosition == 'outsideIndicatorEdge') {
          DvtStatusMeterGaugeRenderer._renderMetricLabelInsidePlotArea(
            gauge,
            container,
            bounds,
            color,
            'insideIndicatorEdge',
            indicator,
            plotArea,
            true
          );
        } else if (metricLabelPosition == 'insideIndicatorEdge' || metricLabelPosition == 'center') {
          DvtStatusMeterGaugeRenderer._renderMetricLabelInsidePlotArea(
            gauge,
            container,
            bounds,
            color,
            'outsideIndicatorEdge',
            indicator,
            plotArea,
            true
          );
        }
      }
    },

    /**
     * Renders the label for vertical/horizontal status meter gauges.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {string} metricLabelPosition The position of the metricLabel
     * @private
     */
    _renderLabel: (gauge, container, bounds, metricLabelPosition) => {
      var isRTL = dvt.Agent.isRightToLeft(gauge.getCtx());
      var options = gauge.getOptions();
      var isVert = options['orientation'] == 'vertical';
      var labelSpace = new dvt.Rectangle(
        bounds.x,
        bounds.y,
        isVert ? bounds.w : bounds.w - bounds.h,
        isVert ? bounds.h - bounds.w : bounds.h
      );
      var labelString = options['label']['text'];
      if (
        !DvtStatusMeterGaugeRenderer._hasMetricLabelOutsidePlotArea(options) &&
        options['metricLabel']['rendered'] == 'on'
      ) {
        var metricLabelString = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
        labelString = dvt.ResourceUtils.format(options.translations.labelAndValue, [
          labelString,
          metricLabelString
        ]);
      }
      var labelStyle = options['label']['style'];
      var fontStyle = labelStyle.clone();
      var size = labelStyle.getStyle('font-size');
      if (!size) {
        // Calculate font size
        var tempLabel = new dvt.OutputText(gauge.getCtx(), labelString, 0, 0);
        tempLabel.setCSSStyle(labelStyle);
        tempLabel.setTextString(labelString);
        // Make size calculations based on the available height not width to have consistent size on same sized gauges
        // for horizontal gauges. For vertical gauges make calculations based on width
        if (isVert)
          size = dvt.TextUtils.getOptimalFontSize(
            tempLabel.getCtx(),
            tempLabel.getTextString(),
            tempLabel.getCSSStyle(),
            new dvt.Rectangle(labelSpace.x, labelSpace.y, labelSpace.w, Number.MAX_VALUE)
          );
        else
          size = dvt.TextUtils.getOptimalFontSize(
            tempLabel.getCtx(),
            tempLabel.getTextString(),
            tempLabel.getCSSStyle(),
            new dvt.Rectangle(labelSpace.x, labelSpace.y, Number.MAX_VALUE, labelSpace.h)
          );
      }
      var label = new dvt.MultilineText(gauge.getCtx(), labelString);
      fontStyle.setFontSize('font-size', size, gauge.getCtx());
      label.setCSSStyle(fontStyle);
      dvt.TextUtils.fitText(label, labelSpace.w, labelSpace.h, gauge);
      if (
        options['label']['position'] == 'center' ||
        (options['label']['position'] == 'auto' && isVert)
      ) {
        dvt.TextUtils.centerTextVertically(label, bounds.y + bounds.h / 2);
        label.setX(bounds.x + bounds.w / 2);
        label.alignCenter();
      } else {
        dvt.TextUtils.centerTextVertically(label, bounds.y + bounds.h / 2);
        if (!isVert && isRTL) {
          label.setX(bounds.x + bounds.w - labelSpace.h / 2);
          label.alignRight();
        } else if (!isVert && !isRTL) {
          label.setX(bounds.x + labelSpace.h / 2);
          label.alignLeft();
        } else if (isVert) {
          label.setY(bounds.y + bounds.h - label.getDimensions().h - labelSpace.w / 2);
          label.setX(bounds.x + bounds.w / 2);
          label.alignCenter();
        }
      }
      container.addChild(label);
    },

    /**
     * Draw specified segment for circular status meter
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {Number} startAngle Start angle.
     * @param {Number} angleExtent Angle from start to end.
     * @param {Number} innerRadius Radius to inner border of arc.
     * @param {Number} outerRadius Radius to outer border of arc..
     * @param {color} color Color of the arc.
     * @param {Boolean} isPlotArea True if arc being drawn is the plot area.
     * @param {color} plotAreaBorderColor Color of the plot area border color
     * @private
     */
    _drawCircularArc: (
      gauge,
      container,
      bounds,
      startAngle,
      angleExtent,
      innerRadius,
      outerRadius,
      color,
      isPlotArea,
      plotAreaBorderColor
    ) => {
      var context = gauge.getCtx();
      var isRTL = dvt.Agent.isRightToLeft(gauge.getCtx());
      if (isRTL) {
        startAngle = Math.PI - startAngle - angleExtent;
        startAngle = startAngle > 0 ? startAngle : startAngle + 2 * Math.PI;
      }

      var shape;
      if (isPlotArea) {
        shape = new dvt.Path(
          context,
          DvtStatusMeterGaugeUtils.createCircularPathCmd(
            bounds,
            startAngle,
            angleExtent,
            innerRadius,
            outerRadius
          )
        );
      } else {
        shape = new DvtStatusMeterGaugeCircularIndicator(
          context,
          bounds,
          startAngle,
          angleExtent,
          innerRadius,
          outerRadius
        );
        gauge.__shapes.push(shape);
      }
      shape.setSolidFill(color);
      var borderColor = DvtGaugeStyleUtils.getBorderColor(gauge);
      if (borderColor && !isPlotArea) {
        shape.setSolidStroke(borderColor);
      } else if (isPlotArea && plotAreaBorderColor) {
        shape.setSolidStroke(plotAreaBorderColor);
      }
      var options = gauge.getOptions();
      shape.setClassName(isPlotArea ? options['plotArea']['svgClassName'] : options['svgClassName']);
      shape.setStyle(isPlotArea ? options['plotArea']['svgStyle'] : options['svgStyle']);
      container.addChild(shape);
    },

    /**
     * Draw reference line
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {dvt.Container} container The container to render into.
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {Number} angle Angle at which line is drawn.
     * @param {string} color Color of the arc.
     * @param {number} lineWidth
     * @param {string} lineStyle
     * @private
     */
    _drawCircularReferenceLine: (gauge, container, bounds, angle, color, lineWidth, lineStyle) => {
      var context = gauge.getCtx();
      var maxDiameter = Math.min(bounds.w, bounds.h);
      var innerRadius = maxDiameter * 0.275;
      var outerRadius = maxDiameter * 0.5;
      if (dvt.Agent.isRightToLeft(gauge.getCtx())) {
        angle = Math.PI - angle;
        angle = angle > 0 ? angle : angle + 2 * Math.PI;
      }
      var p1 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, innerRadius, angle);
      var p2 = DvtStatusMeterGaugeUtils.calcPointOnArc(bounds, outerRadius, angle);
      var shape = new dvt.Line(context, p1.x, p1.y, p2.x, p2.y);
      var stroke = new dvt.Stroke(
        color,
        1,
        lineWidth,
        false,
        dvt.Stroke.getDefaultDashProps(lineStyle, lineWidth)
      );
      shape.setStroke(stroke);
      container.addChild(shape);
    },

    /**
     * Calculates which Quadrant the angle specified belongs to.
     * @param {Number} angle
     * @param {Boolean} bStart Indicates if the angle is a start angle.
     * @return {Number} The quadrant.
     */
    getAngleQuadrant: (angle, bStart) => {
      var quadrant = 1;
      if (bStart) {
        if (angle >= dvt.Math.HALF_PI && angle < Math.PI) quadrant = 2;
        else if (angle >= Math.PI && angle < Math.PI * 1.5) quadrant = 3;
        else if (angle >= Math.PI * 1.5 && angle < dvt.Math.TWO_PI) quadrant = 4;
      } else {
        if (angle > dvt.Math.HALF_PI && angle <= Math.PI) quadrant = 2;
        else if (angle > Math.PI && angle <= Math.PI * 1.5) quadrant = 3;
        else if ((angle > Math.PI * 1.5 && angle < dvt.Math.TWO_PI) || angle == 0) quadrant = 4;
      }
      return quadrant;
    },

    /**
     * Determines if the metric label is rendered outside the plot area
     * @param {object} options The options object
     * @return {Boolean} Returns true if the plotArea is rendered outside the plot area
     * @private
     */
    _hasMetricLabelOutsidePlotArea: (options) => {
      var metricLabelPosition = options['metricLabel']['position'];
      return (
        metricLabelPosition == 'auto' ||
        metricLabelPosition == 'outsidePlotArea' ||
        ((metricLabelPosition == 'withLabel' || metricLabelPosition == 'withTitle') &&
          !options['label']['text'])
      );
    },

    /**
     * Adjust the bounds of the rendered circular gauge shape when the angleExtent is less than 360. Returns the metricLabel bounds.
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {Number} innerRadius
     * @param {Number} startAngleRads
     * @param {Number} angleExtentRads
     * @param {Number} endAngle
     * @param {dvt.Rectangle} bounds The available bounds for rendering.
     * @param {Boolean} isRTL Indicates if the page is right to left.
     * @return {dvt.Rectangle} The bounds of the label.
     * @private
     */
    _adjustCenterAndBounds: (
      gauge,
      innerRadius,
      startAngleRads,
      angleExtentRads,
      endAngle,
      bounds,
      isRTL
    ) => {
      var labelBounds = null;
      var startQuadrant = DvtStatusMeterGaugeRenderer.getAngleQuadrant(startAngleRads, true);
      var endQuadrant = DvtStatusMeterGaugeRenderer.getAngleQuadrant(endAngle, false);
      var width = bounds.w;
      var height = bounds.h;
      var cx = width / 2;
      var cy = height / 2;
      var maxDiameter, maxInnerDiameter;

      // Arc is within one quadrant
      if (startQuadrant == endQuadrant && angleExtentRads <= dvt.Math.HALF_PI) {
        maxDiameter = Math.min(bounds.w, bounds.h) * 2;
        bounds.w = bounds.w + maxDiameter / 2;
        bounds.h = bounds.h + maxDiameter / 2;
        maxInnerDiameter = maxDiameter * innerRadius;

        // Start and end in first quadrant
        if ((!isRTL && startQuadrant == 1) || (isRTL && startQuadrant == 2)) {
          bounds.x -= maxDiameter / 2;
          bounds.y -= maxDiameter / 2;
          cx = width / 2 - maxDiameter / 4 + 1;
          cy = height / 2 - maxDiameter / 4 + 1;
          labelBounds = new dvt.Rectangle(
            bounds.x + bounds.w / 2 - 1,
            bounds.y + bounds.h / 2 - 1,
            maxInnerDiameter * (3 / 7) - 2,
            maxInnerDiameter * (2.5 / 7) - 2
          );
        }

        // Start and end in second quadrant
        else if ((!isRTL && startQuadrant == 2) || (isRTL && startQuadrant == 1)) {
          bounds.y -= maxDiameter / 2;
          cx = width / 2 + maxDiameter / 4 - 1;
          cy = height / 2 - maxDiameter / 4 + 1;
          labelBounds = new dvt.Rectangle(
            bounds.x + bounds.w / 2 - maxInnerDiameter * (3 / 7) + 1,
            bounds.y + bounds.h / 2 - 1,
            maxInnerDiameter * (3 / 7) - 2,
            maxInnerDiameter * (2.5 / 7) - 2
          );
        }

        // Start and end in third quadrant
        else if ((!isRTL && startQuadrant == 3) || (isRTL && startQuadrant == 4)) {
          cx = width / 2 + maxDiameter / 4 - 1;
          cy = height / 2 + maxDiameter / 4 - 1;
          labelBounds = new dvt.Rectangle(
            bounds.x + bounds.w / 2 - maxInnerDiameter * (3 / 7) + 1,
            bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7) + 1,
            maxInnerDiameter * (3 / 7) - 2,
            maxInnerDiameter * (2.5 / 7) - 2
          );
        }

        // Start and end in fourth quadrant
        else if ((!isRTL && startQuadrant == 4) || (isRTL && startQuadrant == 3)) {
          bounds.x -= maxDiameter / 2;
          cx = width / 2 - maxDiameter / 4 + 1;
          cy = height / 2 + maxDiameter / 4 - 1;
          labelBounds = new dvt.Rectangle(
            bounds.x + bounds.w / 2 - 1,
            bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7) + 1,
            maxInnerDiameter * (3 / 7) - 2,
            maxInnerDiameter * (2.5 / 7) - 2
          );
        }
      }

      // Arc spans 2 quadrants
      else if ((startQuadrant % 4) + 1 == endQuadrant && angleExtentRads <= Math.PI) {
        if (startQuadrant == 1 || startQuadrant == 3) {
          maxDiameter = Math.min(bounds.w, bounds.h * 2);
          maxInnerDiameter = maxDiameter * innerRadius;
          if (bounds.w > bounds.h) {
            labelBounds = new dvt.Rectangle(
              bounds.x + bounds.w / 2 - maxInnerDiameter * (3 / 7),
              bounds.y + bounds.h - (bounds.h - maxDiameter / 2) / 2 - maxInnerDiameter * (2.75 / 7),
              maxInnerDiameter * (6 / 7),
              maxInnerDiameter * (2.5 / 7)
            );
            if (startQuadrant == 1) {
              labelBounds.y =
                bounds.y + (bounds.h - maxDiameter / 2) / 2 + maxInnerDiameter * (0.5 / 7);
              bounds.y -= maxDiameter / 2 - (bounds.h - maxDiameter / 2) / 2;
              cy = height / 2 - maxDiameter / 4 + 1;
            } else {
              bounds.y += (bounds.h - maxDiameter / 2) / 2;
              cy = height / 2 + maxDiameter / 4 - 1;
            }
            bounds.h = maxDiameter;
          }
        } else {
          maxDiameter = Math.min(bounds.w * 2, bounds.h);
          maxInnerDiameter = maxDiameter * innerRadius;
          if (bounds.w < bounds.h) {
            labelBounds = new dvt.Rectangle(
              bounds.x + bounds.w - (bounds.w - maxDiameter / 2) / 2 - maxInnerDiameter * (3.25 / 7),
              bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7),
              maxInnerDiameter * (3 / 7),
              maxInnerDiameter * (5 / 7)
            );
            if ((!isRTL && startQuadrant == 4) || (isRTL && startQuadrant == 2)) {
              labelBounds.x =
                bounds.x + (bounds.w - maxDiameter / 2) / 2 + maxInnerDiameter * (0.25 / 7);
              bounds.x -= maxDiameter / 2 - (bounds.w - maxDiameter / 2) / 2;
              cx = width / 2 - maxDiameter / 4 + 1;
            } else {
              bounds.x += (bounds.w - maxDiameter / 2) / 2;
              cx = width / 2 + maxDiameter / 4 - 1;
            }
            bounds.w = maxDiameter;
          }
        }
      }
      // Arc spans 3 quadrants
      else if ((endQuadrant % 4) + 1 == startQuadrant && angleExtentRads > Math.PI) {
        var labelCenterOffset;
        if (startQuadrant == 1 && bounds.h > bounds.w) {
          maxDiameter = Math.min(
            2 * (bounds.w / (Math.cos(startAngleRads) + 1)),
            2 * (bounds.w / (Math.sin(endAngle - Math.PI * 1.5) + 1)),
            bounds.h
          );
          maxInnerDiameter = maxDiameter * innerRadius;
          labelCenterOffset = maxInnerDiameter * (3 / 7) * ((2 * bounds.w) / maxDiameter - 1);
          if (!isRTL) {
            labelBounds = new dvt.Rectangle(
              bounds.x + maxDiameter / 2 - maxInnerDiameter * (3 / 7),
              bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7),
              maxInnerDiameter * (3 / 7) * (1 + ((2 * bounds.w) / maxDiameter - 1)),
              maxInnerDiameter * (5 / 7)
            );
            cx = maxDiameter / 2;
          } else {
            labelBounds = new dvt.Rectangle(
              bounds.x + bounds.w - maxDiameter / 2 - labelCenterOffset,
              bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7),
              maxInnerDiameter * (3 / 7) + labelCenterOffset,
              maxInnerDiameter * (5 / 7)
            );
            bounds.x -= maxDiameter - bounds.w;
            cx = -maxDiameter / 2 + width;
          }
          bounds.w = maxDiameter;
        } else if (startQuadrant == 2 && bounds.h < bounds.w) {
          maxDiameter = Math.min(
            2 * (bounds.h / (Math.cos(startAngleRads - dvt.Math.HALF_PI) + 1)),
            2 * (bounds.h / (Math.sin(endAngle) + 1)),
            bounds.w
          );
          maxInnerDiameter = maxDiameter * innerRadius;
          labelBounds = new dvt.Rectangle(
            bounds.x + bounds.w / 2 - maxInnerDiameter * (3 / 7),
            bounds.y + maxDiameter / 2 - maxInnerDiameter * (2.5 / 7),
            maxInnerDiameter * (6 / 7),
            maxInnerDiameter * (2.5 / 7) * (1 + ((2 * bounds.h) / maxDiameter - 1))
          );
          bounds.h = maxDiameter;
          cy = maxDiameter / 2;
        } else if (startQuadrant == 3 && bounds.h > bounds.w) {
          maxDiameter = Math.min(
            2 * (bounds.w / (Math.cos(startAngleRads - Math.PI) + 1)),
            2 * (bounds.w / (Math.sin(endAngle - dvt.Math.HALF_PI) + 1)),
            bounds.h
          );
          maxInnerDiameter = maxDiameter * innerRadius;
          labelCenterOffset = maxInnerDiameter * (3 / 7) * ((2 * bounds.w) / maxDiameter - 1);
          if (!isRTL) {
            labelBounds = new dvt.Rectangle(
              bounds.x + bounds.w - maxDiameter / 2 - labelCenterOffset,
              bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7),
              maxInnerDiameter * (3 / 7) + labelCenterOffset,
              maxInnerDiameter * (5 / 7)
            );
            bounds.x -= maxDiameter - bounds.w;
            cx = -maxDiameter / 2 + width;
          } else {
            labelBounds = new dvt.Rectangle(
              bounds.x + maxDiameter / 2 - maxInnerDiameter * (3 / 7),
              bounds.y + bounds.h / 2 - maxInnerDiameter * (2.5 / 7),
              maxInnerDiameter * (3 / 7) * (1 + ((2 * bounds.w) / maxDiameter - 1)),
              maxInnerDiameter * (5 / 7)
            );
            cx = maxDiameter / 2;
          }
          bounds.w = maxDiameter;
        } else if (startQuadrant == 4 && bounds.h < bounds.w) {
          maxDiameter = Math.min(
            2 * (bounds.h / (Math.cos(startAngleRads - Math.PI * 1.5) + 1)),
            2 * (bounds.h / (Math.sin(dvt.Math.TWO_PI - endAngle) + 1)),
            bounds.w
          );
          maxInnerDiameter = maxDiameter * innerRadius;
          labelCenterOffset = maxInnerDiameter * (2.5 / 7) * ((2 * bounds.h) / maxDiameter - 1);
          labelBounds = new dvt.Rectangle(
            bounds.x + bounds.w / 2 - maxInnerDiameter * (3 / 7),
            bounds.y + bounds.h - maxDiameter / 2 - labelCenterOffset,
            maxInnerDiameter * (6 / 7),
            maxInnerDiameter * (2.5 / 7) + labelCenterOffset
          );
          bounds.y -= maxDiameter - bounds.h;
          bounds.h = maxDiameter;
          cy = -maxDiameter / 2 + height;
        }
      }
      gauge.cx = cx;
      gauge.cy = cy;
      gauge.maxInnerDiameter = maxInnerDiameter;
      return labelBounds;
    },

    /**
     * Renders the custom center content of circular status meter gauge
     * @param {StatusMeterGauge} gauge The gauge being rendered.
     * @param {object} options The options object.
     * @param {dvt.Rectangle} bounds The bounds of the 360 degree gauge.
     * @param {dvt.Rectangle} containerBounds The available bounds for rendering.
     * @param {number} innerDiameter The inner diameter of the gauge.
     * @private
     */
    _renderCenterContent: (gauge, options, bounds, containerBounds, innerDiameter) => {
      var outerBounds = new dvt.Rectangle(
        bounds.x + (bounds.w - innerDiameter) * 0.5,
        bounds.y + (bounds.h - innerDiameter) * 0.5,
        innerDiameter,
        innerDiameter
      );
      outerBounds = outerBounds.getIntersection(containerBounds);
      var innerBounds = new dvt.Rectangle(
        bounds.x + (bounds.w - innerDiameter / Math.sqrt(2)) * 0.5,
        bounds.y + (bounds.h - innerDiameter / Math.sqrt(2)) * 0.5,
        innerDiameter / Math.sqrt(2),
        innerDiameter / Math.sqrt(2)
      );
      innerBounds = innerBounds.getIntersection(containerBounds);
      var centerRenderer = options['center']['renderer'];
      if (centerRenderer) {
        var dataContext = {
          outerBounds: {
            x: outerBounds.x,
            y: outerBounds.y,
            width: outerBounds.w,
            height: outerBounds.h
          },
          innerBounds: {
            x: innerBounds.x,
            y: innerBounds.y,
            width: innerBounds.w,
            height: innerBounds.h
          },
          metricLabel: DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge),
          component: options['_widgetConstructor']
        };
        var context = gauge.getCtx();
        dataContext = context.fixRendererContext(dataContext);

        var parentDiv = context.getContainer();

        // Remove existing overlay if there is one
        var existingOverlay = gauge.centerDiv;
        if (existingOverlay) parentDiv.removeChild(existingOverlay);

        var customContent = centerRenderer(dataContext);
        if (!customContent) return;
        var newOverlay = context.createOverlayDiv();
        if (Array.isArray(customContent)) {
          customContent.forEach((node) => {
            newOverlay.appendChild(node); // @HTMLUpdateOK
          });
        } else {
          newOverlay.appendChild(customContent); // @HTMLUpdateOK
        }
        gauge.centerDiv = newOverlay;
        parentDiv.appendChild(newOverlay); // @HTMLUpdateOK

        // Invoke the overlay attached callback if one is available.
        var callback = context.getOverlayAttachedCallback();
        if (callback) callback(newOverlay);
      }
    }
  };

  /**
   * Status Meter Gauge component.
   * @class
   * @constructor
   * @extends {DvtGauge}
   */
  class StatusMeterGauge extends DvtGauge {
    constructor(context, callback, callbackObj) {
      super(context, callback, callbackObj);
      this.type = 'statusMeter';
      // Create the defaults object
      this.Defaults = new DvtStatusMeterGaugeDefaults(context);

      /**
       * The axis info of the chart. This will be set during render time and is used for editing support.
       * @type {dvt.AxisInfo}
       */
      this.__axisInfo = null;
    }

    /**
     * @override
     */
    SetOptions(options) {
      // NOTE: This extra clone should be removed once we stop supporting the deprecated attrs
      options = dvt.JsonUtils.clone(options);

      if (options['title']) options['label'] = options['title'];

      if (options['plotArea']) {
        if (options['plotArea']['className'])
          options['plotArea']['svgClassName'] = options['plotArea']['className'];

        if (options['plotArea']['style'])
          options['plotArea']['svgStyle'] = options['plotArea']['style'];
      }

      // Map the custom element readonly attr to the widget readOnly option
      if (this.getCtx().isCustomElement()) options['readOnly'] = options['readonly'];

      // Combine the user options with the defaults and store
      super.SetOptions(this.Defaults.calcOptions(options));
    }

    /**
     * @override
     */
    Render(container, width, height) {
      DvtStatusMeterGaugeRenderer.render(this, container, width, height);
    }

    /**
     * @override
     */
    CreateAnimOnDisplay(objs, animationType, animationDuration) {
      var animatedObjs = [];
      for (var i = 0; i < objs.length; i++) {
        var obj = objs[i];
        var endState = obj.getAnimParams();
        if (this.Options['orientation'] == 'horizontal')
          obj.setAnimParams([endState[0], endState[0], endState[2], endState[3]]);
        else if (this.Options['orientation'] == 'vertical')
          obj.setAnimParams([endState[0], endState[1], endState[3], endState[3]]);
        else if (this.Options['orientation'] == 'circular')
          obj.setAnimParams([endState[0], endState[1], 0, endState[3], endState[4]]);
        var animation = new dvt.CustomAnimation(this.getCtx(), obj, animationDuration);
        animation
          .getAnimator()
          .addProp(
            dvt.Animator.TYPE_NUMBER_ARRAY,
            obj,
            obj.getAnimParams,
            obj.setAnimParams,
            endState
          );
        animation.getAnimator().setEasing(function (progress) {
          return dvt.Easing.backOut(progress, 0.7);
        });
        animatedObjs.push(animation);
      }
      return new dvt.ParallelPlayable(this.getCtx(), animatedObjs);
    }

    /**
     * @override
     */
    GetValueAt(x, y) {
      var options = this.Options;
      var isRTL = dvt.Agent.isRightToLeft(this.getCtx());
      if (options['orientation'] == 'horizontal') {
        return this.__axisInfo.getBoundedValAt(x);
      } else if (options['orientation'] == 'vertical') {
        return this.__axisInfo.getBoundedValAt(y);
      } else if (options['orientation'] == 'circular') {
        var angleExtent = options['angleExtent'];
        var angleRads = Math.atan2(y - this.cy, x - this.cx);
        var angle = isRTL
          ? 180 - (dvt.Math.radsToDegrees(angleRads) - options['startAngle'])
          : dvt.Math.radsToDegrees(angleRads) - (360 - options['startAngle']);
        angle = (angle + 720) % 360;

        // Calculate and adjust ratio to keep in bounds
        var ratio = angle / angleExtent;
        var minValue = options['min'];
        var maxValue = options['max'];
        var value = ratio * (maxValue - minValue) + minValue;
        if (angle > angleExtent) {
          if ((angle - angleExtent) / (360 - angleExtent) > 0.5) value = 0;
          else value = maxValue;
        }
        return value;
      }
      return null;
    }
  }

  exports.LedGauge = LedGauge;
  exports.RatingGauge = RatingGauge;
  exports.StatusMeterGauge = StatusMeterGauge;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojchart',['ojs/ojcore-base', 'ojs/ojdvt-base', 'ojs/ojcomponentcore', 'jquery', 'ojs/ojconverterutils-i18n', 'ojs/ojconverter-number', 'ojs/ojlogger', 'ojs/ojchart-toolkit'], function (oj, DvtAttributeUtils, ojcomponentcore, $, ConverterUtils, NumberConverter, Logger, ojchartToolkit) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  DvtAttributeUtils = DvtAttributeUtils && Object.prototype.hasOwnProperty.call(DvtAttributeUtils, 'default') ? DvtAttributeUtils['default'] : DvtAttributeUtils;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * Object type that defines an axis line.
   * @ojtypedef oj.ojChart.AxisLine
   * @ojimportmembers oj.ojChartAxisLineProperties
   */

  /**
   * Object type that defines a minor tick.
   * @ojtypedef oj.ojChart.MinorTick
   * @ojimportmembers oj.ojChartAxisTickProperties
   */

  /**
   * Object type that defines a major tick.
   * @ojtypedef oj.ojChart.MajorTick
   * @ojimportmembers oj.ojChartAxisTickProperties
   */
  /**
   * The color of the major tick mark at the baseline. Valid values are auto, inherit, or a custom color. If set to inherit, it will follow the lineColor attribute.
   * If baseline value is zero, the axisLine color of the orthogonal axis may override baseline color.
   * @expose
   * @name baselineColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.MajorTick
   * @type {string=}
   * @ojvalue {string=} "inherit" Axis baseline color will be same as lineColor.
   * @ojvalue {string=} "auto" Default value according to theme is used.
   * @default "auto"
   */
  /**
   * The line style of the major tick mark at the baseline. If not specified, it will follow the lineStyle attribute.
   * @expose
   * @name baselineStyle
   * @ojtypedefmember
   * @memberof! oj.ojChart.MajorTick
   * @type {string=}
   * @ojsignature {target: "Type", value: "oj.ojChart.LineStyle", jsdocOverride: true}
   * @default "solid"
   */
  /**
   * The width of the major tick mark at the baseline. If not specified, it will follow the lineWidth attribute.
   * @expose
   * @name baselineWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.MajorTick
   * @type {number=}
   * @default null
   * @ojunits pixels
   * @ojmin 0
   */

  /**
   * Object type that defines a tick label for x-axis.
   * @ojtypedef oj.ojChart.XTickLabel
   * @ojimportmembers oj.ojChartAxisTickLabelProperties
   * @ojsignature [{target: "Type", value: "?(Array.<oj.Converter<T>> | oj.Converter<T>)", for: "converter", jsdocOverride: true},
   *               {target: "Type", value: "<T extends number|string = number|string>", for: "genericTypeParameters"}]
   */
  /**
   * Defines whether the chart will automatically rotate the labels by 90 degrees in order to fit more labels on the axis. The rotation will only be applied to categorical labels for a horizontal axis.
   * @expose
   * @name rotation
   * @ojtypedefmember
   * @memberof! oj.ojChart.XTickLabel
   * @type {string=}
   * @ojvalue {string} "none" Labels will not be rotated in order to fit more labels on the axis.
   * @ojvalue {string} "auto" Labels will automatically rotate by 90 degree in order to fit more labels on the axis if needed.
   * @default "auto"
   */

  /**
   * Object type that defines a tick label for y-axis.
   * @ojtypedef oj.ojChart.YTickLabel
   * @ojimportmembers oj.ojChartAxisTickLabelProperties
   * @ojsignature {target: "Type", value: "?(oj.Converter<number>)", for: "converter", jsdocOverride: true}
   */
  /**
   * Defines the position of the tick labels relative to the plot area. Inside position is not supported for scatter and bubble charts.
   * @expose
   * @name position
   * @ojtypedefmember
   * @memberof! oj.ojChart.YTickLabel
   * @type {string=}
   * @ojvalue {string} "inside" Tick labels will be rendered inside the plot area.
   * @ojvalue {string} "outside" Tick labels will be rendered outside the plot area.
   * @default "outside"
   */

  /**
   * Object type that defines a reference object associated with the x-axis.
   * @ojtypedef oj.ojChart.XReferenceObject
   * @ojimportmembers oj.ojChartAxisReferenceObjectProperties
   * @ojsignature {target: "Type", value: "<T extends number|string = number|string>", for: "genericTypeParameters"}
   */
  /**
   * The value of a line reference object. This property defines a constant value across the entire reference object. For categorical axes, the value represents the group id(string) or group index(number). For example, when using group indices, 0 is the position of the first group, and 1.5 is the position half way between the second and the third group. See <var>type</var> for more details.
   * @expose
   * @name value
   * @ojtypedefmember
   * @memberof! oj.ojChart.XReferenceObject
   * @ojshortdesc The value of a line reference object. This property defines a constant value across the entire reference object. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * The low value of an area reference object. For categorical axes, the value represents the group id(string) or group index(number). For example, when using group indices, 0 is the position of the first group, and 1.5 is the position half way between the second and the third group. See <var>type</var> for more details.
   * @expose
   * @name low
   * @ojtypedefmember
   * @memberof! oj.ojChart.XReferenceObject
   * @ojshortdesc The low value of an area reference object. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * The high value of an area reference object. For categorical axes, the value represents the group id(string) or group index(number). For example, when using group indices, 0 is the position of the first group, and 1.5 is the position half way between the second and the third group. See <var>type</var> for more details.
   * @expose
   * @name high
   * @ojtypedefmember
   * @memberof! oj.ojChart.XReferenceObject
   * @ojshortdesc The high value of an area reference object. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type that defines a reference object associated with the y-axis.
   * @ojtypedef oj.ojChart.YReferenceObject
   * @ojimportmembers oj.ojChartAxisReferenceObjectProperties
   */
  /**
   * The line type of the varying reference object. "centeredStepped" and "centeredSegmented" are not supported for polar, scatter, and bubble charts. See <var>items</var> for more details about varying reference objects.
   * @expose
   * @name lineType
   * @ojtypedefmember
   * @memberof! oj.ojChart.YReferenceObject
   * @ojshortdesc The line type of the varying reference object. See the Help documentation for more information.
   * @type {string=}
   * @ojsignature {target: "Type", value: "oj.ojChart.LineType", jsdocOverride: true}
   * @default "straight"
   */
  /**
   * The value of a line reference object. This property defines a constant value across the entire reference object and is ignored if the <var>items</var> property is specified. See <var>type</var> for more details.
   * @expose
   * @name value
   * @ojtypedefmember
   * @memberof! oj.ojChart.YReferenceObject
   * @ojshortdesc The value of a line reference object. This property defines a constant value across the entire reference object. See the Help documentation for more information.
   * @type {number=}
   * @default null
   */
  /**
   * The low value of an area reference object. This property defines a constant value across the entire reference area and is ignored if the <var>items</var> property is specified. See <var>type</var> for more details.
   * @expose
   * @name low
   * @ojtypedefmember
   * @memberof! oj.ojChart.YReferenceObject
   * @ojshortdesc The low value of an area reference object. This property defines a constant value across the entire reference area. See the Help documentation for more information.
   * @type {number=}
   * @default null
   */
  /**
   * The high value of an area reference object. This property defines a constant value across the entire reference area and is ignored if the <var>items</var> property is specified.  See <var>type</var> for more details.
   * @expose
   * @name high
   * @ojtypedefmember
   * @memberof! oj.ojChart.YReferenceObject
   * @ojshortdesc The high value of an area reference object. This property defines a constant value across the entire reference area. See the Help documentation for more information.
   * @type {number=}
   * @default null
   */
  /**
   * An array of values or an array of objects with the following properties that define the data for a varying reference object. Only supported for y1 and y2 axes for all chart types.
   * @expose
   * @name items
   * @ojtypedefmember
   * @memberof! oj.ojChart.YReferenceObject
   * @ojshortdesc An array of values or an array of objects that define the data for a varying reference object. See the Help documentation for more information.
   * @type {Array.<Object>=}
   * @ojsignature {target: "Type", value: "Array.<oj.ojChart.ReferenceObjectItem>", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type that defines the data for a varying reference object. Only supported for y1 and y2 axes for all chart types.
   * @ojtypedef oj.ojChart.ReferenceObjectItem
   * @ojsignature {target: "Type", value: "<T extends number|string = number|string>", for: "genericTypeParameters"}
   */
  /**
   * The low value of this point of a varying area reference object.
   * @expose
   * @name low
   * @ojtypedefmember
   * @memberof! oj.ojChart.ReferenceObjectItem
   * @type {number=}
   * @default null
   */
  /**
   * The high value of this point of a varying area reference object.
   * @expose
   * @name high
   * @ojtypedefmember
   * @memberof! oj.ojChart.ReferenceObjectItem
   * @type {number=}
   * @default null
   */
  /**
   * The value of this point of a varying line reference object. Null can be specified to skip a data point.
   * @expose
   * @name value
   * @ojtypedefmember
   * @memberof! oj.ojChart.ReferenceObjectItem
   * @type {number=}
   * @default null
   */
  /**
   * The x value of this point. Mainly used for scatter and bubble charts, and to specify the date for mixed-frequency time axis.
   * For categorical axis, if the x value is not specified, it will default to the item index.
   * For regular time axis, if the x value is not specified, it will default to the group name of the item.
   * @expose
   * @name x
   * @ojtypedefmember
   * @memberof! oj.ojChart.ReferenceObjectItem
   * @ojshortdesc The x value of this point. Mainly used for scatter and bubble charts, and to specify the date for mixed-frequency time axis. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type that defines the x-axis.
   * @ojtypedef oj.ojChart.XAxis
   * @ojimportmembers oj.ojChartAxisProperties
   * @ojsignature [{target: "Type", value: "Array.<oj.ojChart.XReferenceObject<T>>", for: "referenceObjects", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.XTickLabel<T>", for: "tickLabel", jsdocOverride: true},
   *               {target: "Type", value: "<T extends number|string = number|string>", for: "genericTypeParameters"}]
   */
  /**
   * The minimum value of the axis. Defaults to null for automatic calculation based on the data. For categorical axes, the value represents the group index. For example, 0 is the position of the first group, and 1.5 is the position half way between the second and the third group.
   * @expose
   * @name min
   * @ojtypedefmember
   * @memberof! oj.ojChart.XAxis
   * @ojshortdesc The minimum value of the axis. Defaults to null for automatic calculation based on the data. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * The maximum value of the axis. Defaults to null for automatic calculation based on the data. For categorical axes, the value represents the group index. For example, 0 is the position of the first group, and 1.5 is the position half way between the second and the third group.
   * @expose
   * @name max
   * @ojtypedefmember
   * @memberof! oj.ojChart.XAxis
   * @ojshortdesc The maximum value of the axis. Defaults to null for automatic calculation based on the data. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * Specifies the minimum x coordinate of the current viewport for zoom and scroll. For group axis, the group index will be treated as the axis coordinate. If both viewportStartGroup and viewportMin are specified, then viewportMin takes precedence. If not specified, this value will be the axis min.
   * @expose
   * @name viewportMin
   * @ojtypedefmember
   * @memberof! oj.ojChart.XAxis
   * @ojshortdesc Specifies the minimum x coordinate of the current viewport for zoom and scroll. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * Specifies the maximum x coordinate of the current viewport for zoom and scroll. For group axis, the group index will be treated as the axis coordinate. If both viewportEndGroup and viewportMax are specified, then viewportMax takes precedence. If not specified, this value will be the axis max.
   * @expose
   * @name viewportMax
   * @ojtypedefmember
   * @memberof! oj.ojChart.XAxis
   * @ojshortdesc Specifies the maximum x coordinate of the current viewport for zoom and scroll. See the Help documentation for more information.
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * Specifies the start group of the current viewport. Only applies to charts with group or time axis. If not specified, the default start group is the first group in the data set. The application should set either the viewportMin or viewportStartGroup and not both at the same time. If both viewportStartGroup and viewportMin are specified, viewportMin takes precedence.
   * @expose
   * @name viewportStartGroup
   * @ojtypedefmember
   * @memberof! oj.ojChart.XAxis
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * Specifies the end group of the current viewport. Only applies to charts with group or time axis. If not specified, the default end group is the last group in the data set. The application should set either the viewportMax or viewportEndGroup and not both at the same time. If both viewportEndGroup and viewportMax are specified, viewportMax takes precedence.
   * @expose
   * @name viewportEndGroup
   * @ojtypedefmember
   * @memberof! oj.ojChart.XAxis
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type that defines the y-axis.
   * @ojtypedef oj.ojChart.YAxis
   * @ojimportmembers oj.ojChartAxisProperties
   * @ojsignature [{target: "Type", value: "Array.<oj.ojChart.YReferenceObject>", for: "referenceObjects", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.YTickLabel", for: "tickLabel", jsdocOverride: true}]
   */
  /**
   * The position of the axis relative to its content. For vertical charts, only start and end apply. For horizontal charts, only top and bottom apply.
   * @expose
   * @name position
   * @ojtypedefmember
   * @memberof! oj.ojChart.YAxis
   * @type {string=}
   * @ojvalue {string} "start" The axis will be placed at start of the chart. Only applies to vertical charts.
   * @ojvalue {string} "end" The axis will be placed at end of the chart. Only applies to vertical charts.
   * @ojvalue {string} "top" The axis will be placed at the top of the chart. Only applies to horizontal charts.
   * @ojvalue {string} "bottom" The axis will be placed at the bottom of the chart. Only applies to horizontal charts.
   * @ojvalue {string} "auto" The axis position will be based on the chart's orientation.
   * @default "auto"
   */
  /**
   * The minimum value of the axis. Defaults to null for automatic calculation based on the data.
   * @expose
   * @name min
   * @ojtypedefmember
   * @memberof! oj.ojChart.YAxis
   * @type {number=}
   * @default null
   */
  /**
   * The maximum value of the axis. Defaults to null for automatic calculation based on the data.
   * @expose
   * @name max
   * @ojtypedefmember
   * @memberof! oj.ojChart.YAxis
   * @type {number=}
   * @default null
   */
  /**
   * Specifies the minimum y coordinate of the current viewport for zoom and scroll. Only applies to bubble and scatter charts. If not specified, this value will be the axis min.
   * @expose
   * @name viewportMin
   * @ojtypedefmember
   * @memberof! oj.ojChart.YAxis
   * @type {number=}
   * @default null
   */
  /**
   * Specifies the maximum y coordinate of the current viewport for zoom and scroll. Only applies to bubble and scatter charts. If not specified, this value will be the axis max.
   * @expose
   * @name viewportMax
   * @ojtypedefmember
   * @memberof! oj.ojChart.YAxis
   * @type {number=}
   * @default null
   */

  /**
   * Object type that defines the y2-axis.
   * @ojtypedef oj.ojChart.Y2Axis
   * @ojimportmembers oj.ojChartAxisProperties
   * @ojsignature [{target: "Type", value: "Array.<oj.ojChart.YReferenceObject>", for: "referenceObjects", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.YTickLabel", for: "tickLabel", jsdocOverride: true}]
   */
  /**
   * The position of the axis relative to its content. For vertical charts, only start and end apply. For horizontal charts, only top and bottom apply.
   * @expose
   * @name position
   * @ojtypedefmember
   * @memberof! oj.ojChart.Y2Axis
   * @type {string=}
   * @ojvalue {string} "start" The axis will be placed at start of the chart. Only applies to vertical charts.
   * @ojvalue {string} "end" The axis will be placed at end of the chart. Only applies to vertical charts.
   * @ojvalue {string} "top" The axis will be placed at the top of the chart. Only applies to horizontal charts.
   * @ojvalue {string} "bottom" The axis will be placed at the bottom of the chart. Only applies to horizontal charts.
   * @ojvalue {string} "auto" The axis position will be based on the chart's orientation.
   * @default "auto"
   */
  /**
   * The minimum value of the axis. Defaults to null for automatic calculation based on the data.
   * @expose
   * @name min
   * @ojtypedefmember
   * @memberof! oj.ojChart.Y2Axis
   * @type {number=}
   * @default null
   */
  /**
   * The maximum value of the axis. Defaults to null for automatic calculation based on the data.
   * @expose
   * @name max
   * @ojtypedefmember
   * @memberof! oj.ojChart.Y2Axis
   * @type {number=}
   * @default null
   */
  /**
   * Defines whether the tick marks of the y1 and y2 axes are aligned. Not supported for logarithmic axes.
   * @expose
   * @name alignTickMarks
   * @ojtypedefmember
   * @memberof! oj.ojChart.Y2Axis
   * @type {string=}
   * @ojvalue {string} "off" Tick marks of y1 and y2 axes may not be aligned.
   * @ojvalue {string} "on" Tick marks of y1 and y2 axes will be aligned.
   * @default "on"
   */

  /**
   * Object type that defines the item belonging to drilled element.
   * @ojtypedef oj.ojChart.DrillItem
   * @ojsignature {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}
   */
  /**
   * The id for the data item.
   * @expose
   * @name id
   * @ojshortdesc The id for the data item.
   * @ojtypedefmember
   * @memberof! oj.ojChart.DrillItem
   * @type {string|number}
   * @ojsignature {target: "Type", value: "K", jsdocOverride:true}
   */
  /**
   * The data object of the drilled item.
   * @expose
   * @name data
   * @ojtypedefmember
   * @ojshortdesc The data object of the drilled item.
   * @memberof! oj.ojChart.DrillItem
   * @type {Object|number}
   * @ojsignature [ {target: "Type", value: "oj.ojChart.Item<K, Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>|number", consumedBy: "js"},
   *                {target: "Type", value: "oj.ojChart.Item<K, I>|number", consumedBy: "ts"}]
   */
  /**
   * The row data object of the drilled item. This will only be set if a DataProvider is being used.
   * @expose
   * @name itemData
   * @ojtypedefmember
   * @ojshortdesc The row data object of the drilled item. This will only be set if a DataProvider is being used.
   * @memberof! oj.ojChart.DrillItem
   * @type {Object}
   * @ojsignature {target: "Type", value: "D", jsdocOverride: true}
   */
  /**
   *  The series id of the data item.
   * @expose
   * @name series
   * @ojtypedefmember
   * @ojshortdesc  The series id of the data item.
   * @memberof! oj.ojChart.DrillItem
   * @type {string}
   */
  /**
   *  The group id of the data item. For hierarchical group, it will be an array of outermost to innermost group related to the object.
   * @expose
   * @name group
   * @ojtypedefmember
   * @ojshortdesc  The group id of the data item. For hierarchical group, it will be an array of outermost to innermost group related to the object.
   * @memberof! oj.ojChart.DrillItem
   * @type {string|Array.<string>}
   */

  /**
   * Object type that allows dragging elements.
   * @ojtypedef oj.ojChart.DndDragConfig
   * @ojsignature {target: "Type", value: "<T>", for: "genericTypeParameters"}
   */
  /**
   * The MIME types to use for the dragged data in the dataTransfer object. This can be a string if there is only one type, or an array of strings if multiple types are needed. For example, if selected employee data items are being dragged, dataTypes could be "application/employees+json". Drop targets can examine the data types and decide whether to accept the data. For each type in the array, dataTransfer.setData will be called with the specified type and the data. The data is an array of the dataContexts of the selected elements. The dataContext is the JSON version of the dataContext that we use for "tooltip" and "dataLabels" properties, excluding componentElement and parentElement. This property is required unless the application calls setData itself in a dragStart callback function.
   * @expose
   * @name dataTypes
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDragConfig
   * @ojshortdesc The MIME types to use for the dragged data in the dataTransfer object. This can be a string if there is only one type, or an array of strings if multiple types are needed.
   * @type {(string|Array.<string>)=}
   * @default null
   */
  /**
   * An optional callback function that receives the "drag" event as argument.
   * @expose
   * @name drag
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDragConfig
   * @type {function(Event)=}
   * @default null
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: T) => void)", jsdocOverride: true}
   */
  /**
   * An optional callback function that receives the "dragend" event as argument.
   * @expose
   * @name dragEnd
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDragConfig
   * @type {function(Event)=}
   * @default null
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: T) => void)", jsdocOverride: true}
   */
  /**
   * An optional callback function that receives the "dragstart" event and context information as arguments. The context information is as follows: <ul> <li> element {Array.(Object)}: An array of dataContexts of the dragged elements. The dataContext is the same as what we use for "tooltip" and "dataLabels" properties. </li> </ul> This function can set its own data and drag image as needed. When this function is called, event.dataTransfer is already populated with the default data and drag image.
   * @expose
   * @name dragStart
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDragConfig
   * @ojshortdesc An optional callback function that receives the "dragstart" event and context information as arguments. See the Help documentation for more information.
   * @type {function(Event, Object)=}
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: T) => void)", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type that describes drag functionality.
   * @ojtypedef oj.ojChart.DndDragConfigs
   * @property {Object=} items Allows dragging of chart data items, including bars, line/area/scatter markers, bubbles, and pie/funnel/pyramid slices.
   * @property {Object=} series Allows dragging of chart series from the legend items.
   * @property {Object=} groups Allows dragging of chart groups from the categorical axis labels.
   * @ojsignature [{target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"},
   *               {target: "Type", value: "oj.ojChart.DndDragConfig<ojChart.DndItem<K, D, I>>", for: "items", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.DndDragConfig<ojChart.DndSeries<K, I>>", for: "series", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.DndDragConfig<ojChart.DndGroup>", for: "groups", jsdocOverride: true}]
   */

  /**
   * Object type that allows dropping on an element.
   * @ojtypedef oj.ojChart.DndDropConfig
   */
  /**
   * An array of MIME data types this element can accept. This property is required unless dragEnter, dragOver, and drop callback functions are specified to handle the corresponding events.
   * @expose
   * @name dataTypes
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDropConfig
   * @type {(string|Array.<string>)=}
   * @default null
   */
  /**
   * An optional callback function that receives the "dragenter" event and context information as arguments. This function should call <code class="prettyprint">event.preventDefault()</code> to indicate the dragged data can be accepted. Otherwise, dataTypes will be matched against the drag data types to determine if the data is acceptable.
   * @expose
   * @name dragEnter
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDropConfig
   * @ojshortdesc An optional callback function that receives the "dragenter" event and context information as arguments. See the Help documentation for more information.
   * @type {function(Event, Object)=}
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: oj.ojChart.DndDrop) => void)", jsdocOverride: true}
   * @default null
   */
  /**
   * An optional callback function that receives the "dragover" event and context information as arguments. This function should call <code class="prettyprint">event.preventDefault()</code> to indicate the dragged data can be accepted. Otherwise, dataTypes will be matched against the drag data types to determine if the data is acceptable.
   * @expose
   * @name dragOver
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDropConfig
   * @ojshortdesc An optional callback function that receives the "dragover" event and context information as arguments. See the Help documentation for more information.
   * @type {function(Event, Object)=}
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: oj.ojChart.DndDrop) => void)", jsdocOverride: true}
   * @default null
   */
  /**
   * An optional callback function that receives the "dragleave" event and context information as arguments.
   * @expose
   * @name dragLeave
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDropConfig
   * @ojshortdesc An optional callback function that receives the "dragleave" event and context information as arguments. See the Help documentation for more information.
   * @type {function(Event, Object)=}
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: oj.ojChart.DndDrop) => void)", jsdocOverride: true}
   * @default null
   */
  /**
   * An optional callback function that receives the "drop" event and context information as arguments. This function should call <code class="prettyprint">event.preventDefault()</code> to indicate the dragged data can be accepted.
   * @expose
   * @name drop
   * @ojtypedefmember
   * @memberof! oj.ojChart.DndDropConfig
   * @ojshortdesc An optional callback function that receives the "drop" event and context information as arguments. See the Help documentation for more information.
   * @type {function(Event, Object)=}
   * @ojsignature {target: "Type", value: "((event: DragEvent, context: oj.ojChart.DndDrop) => void)", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type that describes drop functionality.
   * @ojtypedef oj.ojChart.DndDropConfigs
   * @property {Object=} plotArea Allows dropping on the plot area.
   * @property {Object=} xAxis Allows dropping on the X axis.
   * @property {Object=} yAxis Allows dropping on the Y axis.
   * @property {Object=} y2Axis Allows dropping on the Y2 axis.
   * @property {Object=} legend Allows dropping on the legend.
   * @ojsignature [{target: "Type", value: "oj.ojChart.DndDropConfig", for: "plotArea", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.DndDropConfig", for: "xAxis", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.DndDropConfig", for: "yAxis", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.DndDropConfig", for: "y2Axis", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.DndDropConfig", for: "legend", jsdocOverride: true}]
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="5">Data Item</td>
   *       <td rowspan="2"><kbd>Tap</kbd></td>
   *       <td>Select when <code class="prettyprint">selectionMode</code> is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td>Drill when <code class="prettyprint">drilling</code> is enabled and <code class="prettyprint">selectionMode</code> is <code class="prettyprint">none</code>.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Double Tap</kbd></td>
   *       <td>Drill when <code class="prettyprint">drilling</code> is enabled and <code class="prettyprint">selectionMode</code> is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td rowspan="2"><kbd>Press & Hold</kbd></td>
   *       <td>Display tooltip.</td>
   *     </tr>
   *     <tr>
   *       <td>Display context menu on release.</td>
   *     </tr>
   *     <tr>
   *       <td>Categorical Axis Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Drill when <code class="prettyprint">drilling</code> is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td rowspan="2">Legend Item</td>
   *       <td rowspan="2"><kbd>Tap</kbd></td>
   *       <td>Drill when <code class="prettyprint">drilling</code> is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td>Filter when <code class="prettyprint">hideAndShowBehavior</code> is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td rowspan="4">Plot Area</td>
   *       <td rowspan="2"><kbd>Drag</kbd></td>
   *       <td>Pan when panning is enabled and toggled into that mode.</td>
   *     </tr>
   *     <tr>
   *       <td>Marquee select when <code class="prettyprint">selectionMode</code> is <code class="prettyprint">multiple</code> and toggled into that mode.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Pinch-close</kbd></td>
   *       <td>Zoom out when zooming is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Spread-open</kbd></td>
   *       <td>Zoom in when zooming is enabled.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojChart
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Move focus to next element. For pie charts, the focus will move to center content if center content is focusable.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + Tab</kbd></td>
   *       <td>Move focus to previous element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Move focus and selection to previous data item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Move focus and selection to next data item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>Move focus and selection to previous data item (on left).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>Move focus and selection to next data item (on right).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + UpArrow</kbd></td>
   *       <td>Move focus and multi-select previous data item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + DownArrow</kbd></td>
   *       <td>Move focus and multi-select next data item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + LeftArrow</kbd></td>
   *       <td>Move focus and multi-select previous data item (on left).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + RightArrow</kbd></td>
   *       <td>Move focus and multi-select next data item (on right).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl + UpArrow / CMD + UpArrow</kbd></td>
   *       <td>Move focus to previous data item, without changing the current selection.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl + DownArrow / CMD + DownArrow</kbd></td>
   *       <td>Move focus to next data item, without changing the current selection.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl + LeftArrow / CMD + LeftArrow</kbd></td>
   *       <td>Move focus to previous data item (on left), without changing the current selection.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl + RightArrow / CMD + RightArrow</kbd></td>
   *       <td>Move focus to next data item (on right), without changing the current selection.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl + Spacebar / CMD + Spacebar</kbd></td>
   *       <td>Multi-select data item with focus.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>=</kbd> or <kbd>+</kbd></td>
   *       <td>Zoom in one level if zooming is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>-</kbd> or <kbd>_</kbd></td>
   *       <td>Zoom out one level if zooming is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>PageUp</kbd></td>
   *       <td>Pan up if scrolling is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>PageDown</kbd></td>
   *       <td>Pan down if scrolling is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + PageUp</kbd></td>
   *       <td>Pan left in left-to-right locales. Pan right in right-to-left locales.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + PageDown</kbd></td>
   *       <td>Pan right in left-to-right locales. Pan left in right-to-left locales.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Drill on data item, categorical axis label, or legend item when <code class="prettyprint">drilling</code> is enabled.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojChart
   */

  /**
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * oj-chart is being broken down into multiple core pack chart components (oj-c-line-chart, oj-c-area-chart, oj-c-bar-chart, etc) according to the type of the chart. To migrate from oj-chart to new core pack chart components (oj-c-area-chart, oj-c-line-chart), you need to revise the import statement and references of oj-chart in your app. JET 16.0.0 core pack has support for only oj-c-line-chart and oj-c-area-chart. Oj-c-line-chart is analogous to oj-chart with type set to line, and oj-c-area-chart is analogous to oj-chart with type set to area. Support for other chart types will be added in upcoming versions of JET. Please note the changes below.
   * <h5 id="dataprovider-key-type-migration"></h5>
   * <h5>Default component height</h5>
   * <p>
   * The default height of the component will now respond to scaling with the current height equal to when scaling equals 'lg'.
   * </p>
   * <h5>Drag mode icons</h5>
   * <p>
   * Corepack chart components (oj-c-line-chart, oj-c-area-chart) will use Redwood icons and JET buttons instead of the custom SVG buttons in oj-chart.
   * </p>
   * <h5> track-resize </h5>
   * <p> For the initial version of oj-c-line-chart and oj-c-area-chart, track-resize attribute is not supported. The component will itself resize on change in dimension. </p>
   * <h5 id="context-menu-migration"></h5>
   * <h5> Context menu affordance </h5>
   * <p> Corepack chart components (oj-c-line-chart, oj-c-area-chart) will have visual interaction affordance and keyboard support for context menus which does not exist in oj-chart. </p>
   * <h5>animation-on-data-change</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, animaton-on-data-change attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>animation-on-display</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, animaton-on-display attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>style-defaults.animation-duration attribute</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, animation-duration attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>coordinate-system</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, coordinate-system attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>data-label</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, data-label attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>dnd</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, dnd attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>initial-zooming</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, initial-zooming attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>overview</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, overview attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> polar-grid-shape </h5>
   * <p> For the initial version of oj-c-line-chart and oj-c-area-chart, polar-grid-shape attribute is not supported. We plan on supporting this use case in a future release. </p>
   * <h5>sorting</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, sorting attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5>zoom-direction</h5>
   * <p>
   * For the initial version of oj-c-line-chart and oj-c-area-chart, zoom-direction attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> tooltip attribute and tooltipTemplate slot </h5>
   * <p> For the initial version of oj-c-line-chart and oj-c-area-chart, tooltip attribute and the tooltipTemplate slot are not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> ojSelectInput event </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, ojSelectInput event is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> ojViewportChangeInput event </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, ojViewportChangeInput event is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getLegend method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getLegend method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getPlotArea method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getPlotArea method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getValuesAt method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getValuesAt method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getXAxis method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getXAxis method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getY2Axis method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getY2Axis method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getYAxis method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getYAxis method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * <h5> getContextByNode method </h5>
   * <p>For the initial version of oj-c-line-chart and oj-c-area-chart, getContextByNode method is not supported. We plan on supporting this use case in a future release.
   * </p>
   * @ojfragment migrationDoc
   * @memberof oj.ojChart
   */

  /**
   * Enum type that defines a line style.
   * @export
   * @typedef {string} LineStyle
   * @memberof oj.ojChart
   * @ojvalue {string} "dotted" Line will have dotted strokes.
   * @ojvalue {string} "dashed" Line will have dashed strokes.
   * @ojvalue {string} "solid" Line will have a solid stroke.
   */
  /**
   * Enum type that defines a line type.
   * @export
   * @typedef {string} LineType
   * @memberof oj.ojChart
   * @ojvalue {string} "curved" Data points will be connected with a curved line.
   * @ojvalue {string} "stepped" Data points will be connected with a stepped line.
   * @ojvalue {string} "centeredStepped" Data points will be connected with a centered stepped line.
   * @ojvalue {string} "segmented" Data points will be connected with a segmented line.
   * @ojvalue {string} "centeredSegmented" Data points will be connected with a centered segmented line.
   * @ojvalue {string} "straight" Data points will be connected with a straight line.
   */
  /**
   * Enum type that defines the chart type. By default, the first three series of "combo" chart are assigned '<i>bar'</i>, <i>'line'</i>, and <i>'area'</i> type respectively and then the type repeats, i.e sucessive series will be of types '<i>bar'</i>, <i>'line'</i>, and <i>'area'</i> and so on. To customize individual series, see <a href="oj.ojChartSeries.html#type"> oj-chart-series </a> for more details.
   * @export
   * @typedef {string} ChartType
   * @memberof oj.ojChart
   * @ojshortdesc Specifies the chart type. See the Help documentation for more information.
   * @ojvalue {string} "line" Series will be represented by a line.
   * @ojvalue {string} "area" Series will be represented by an area. Use lineWithArea to prevent values from being obscured.
   * @ojvalue {string} "lineWithArea" Series will be presented by a line and area.
   * @ojvalue {string} "bar"  Data items will be represented by bars.
   * @ojvalue {string} "stock" Series will be represented by candlestick markers. There are other representations available like area, bar, line and line with area.
   * @ojvalue {string} "boxPlot" Series will be represented by box plot markers.
   * @ojvalue {string} "combo" Multiple series can be represented with multiple types of markers:  bar, line and area.
   * @ojvalue {string} "pie" Data items are represented as pie slices.
   * @ojvalue {string} "scatter" Data items will be represented as markers with x and y values.
   * @ojvalue {string} "bubble" Data items will be represented as bubble markers with x, y, and z values. z value defines the relative size of the bubbles.
   * @ojvalue {string} "funnel" Data items are represented as funnel slices.
   * @ojvalue {string} "pyramid" Data items are represented as pyramid slices.
   */

  /**
   * Object type that specifies the position of the data cursor. Used for synchronizing data cursors across multiple charts.
   * @ojtypedef oj.ojChart.DataCursorPosition
   * @ojsignature {target: "Type", value: "<T extends number|string = number|string>", for: "genericTypeParameters"}
   */
  /**
   * The x value of the data cursor.
   * @expose
   * @name x
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorPosition
   * @type {(number|string)=}
   * @ojsignature {target: "Type", value: "T", jsdocOverride: true}
   * @default null
   */
  /**
   * The y value of the data cursor. If both y and y2 are defined, y will take precedence.
   * @expose
   * @name y
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorPosition
   * @type {number=}
   * @default null
   */
  /**
   * The y2 value of the data cursor. If both y and y2 are defined, y will take precedence.
   * @expose
   * @name y2
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorPosition
   * @type {number=}
   * @default null
   */

  /**
   * Object type defining the overview scrollbar. Only applies if zoomAndScroll is not off. Currently only supported for vertical bar, line, area, stock, and combo charts.
   * @ojtypedef oj.ojChart.Overview
   * @ojsignature {target: "Type", value: "<C>", for: "genericTypeParameters"}
   */
  /**
   * Specifies whether the overview scrollbar is rendered. If not, simple scrollbar will be used.
   * @expose
   * @name rendered
   * @ojtypedefmember
   * @memberof! oj.ojChart.Overview
   * @type {string=}
   * @ojvalue {string} "on" Overview scrollbar will be rendered.
   * @ojvalue {string} "off" Overview scrollbar will not be rendered.
   * @default "off"
   */
  /**
   * Specifies the height of the overview scrollbar in pixels (e.g. '50px') or percent (e.g. '15%').
   * @expose
   * @name height
   * @ojtypedefmember
   * @memberof! oj.ojChart.Overview
   * @type {string=}
   * @default null
   */
  /**
   * An object containing the property override for the overview chart. The API is the same as the chart property API, and the property provided here will be merged on top of the default property of the overview chart. This can be used to customize the style or the type of the overview chart.
   * @expose
   * @name content
   * @ojtypedefmember
   * @memberof! oj.ojChart.Overview
   * @ojshortdesc An object containing the property override for the overview chart. See the Help documentation for more information.
   * @type {Object=}
   * @ojsignature {target: "Type", value: "C", jsdocOverride: false}
   * @default {}
   */

  /**
   * Object type defining the center content of a pie chart. Either a label can be displayed at the center of the pie chart or custom HTML content.
   * @ojtypedef oj.ojChart.PieCenter
   */
  /**
   * The converter (an instance that duck types <a href="oj.Converter.html">oj.Converter</a>) used to format the label if it is numeric. When using a converter, scaling should be set to none, as the formatted result may not be compatible with the scaling suffixes.
   * @expose
   * @name converter
   * @ojtypedefmember
   * @memberof! oj.ojChart.PieCenter
   * @ojshortdesc The converter to format the label if it is numeric. See the Help documentation for more information.
   * @type {?Object}
   * @ojsignature {target: "Type", value: "?(oj.Converter<number>)", jsdocOverride: true}
   * @default null
   */
  /**
   * The scaling behavior of the label if it is numeric. When using a converter, scaling should be set to none, as the formatted result may not be compatible with the scaling suffixes.
   * @expose
   * @name scaling
   * @ojtypedefmember
   * @memberof! oj.ojChart.PieCenter
   * @type {string=}
   * @ojvalue {string} "none" Values will not be scaled with any suffix.
   * @ojvalue {string} "thousand" Values will be scaled with suffix corresponding to thousand based on locale.
   * @ojvalue {string} "million" Values will be scaled with suffix corresponding to million based on locale.
   * @ojvalue {string} "billion" Values will be scaled with suffix corresponding to billion based on locale.
   * @ojvalue {string} "trillion" Values will be scaled with suffix corresponding to trillion based on locale.
   * @ojvalue {string} "quadrillion" Values will be scaled with suffix corresponding to quadrillion based on locale.
   * @ojvalue {string} "auto" Chart chooses the scaling based on the data.
   * @default "auto"
   */
  /**
   * Specifies the text for the label. When a innerRadius is specified, the label will automatically be scaled to fit within the inner circle. If the innerRadius is 0, the default font size will be used.
   * @expose
   * @name label
   * @ojtypedefmember
   * @memberof! oj.ojChart.PieCenter
   * @type {(number|string)=}
   * @default null
   * @ojtranslatable
   */
  /**
   * The CSS style object defining the style of the label.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @expose
   * @name labelStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the label.
   * @memberof! oj.ojChart.PieCenter
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * A function that returns custom center content. The function takes a <a href="#PieCenterRendererContext">PieCenterRendererContext</a> argument,
   * provided by the chart, and returns an object with the following properties:
   * <ul>
   *   <li>insert: HTMLElement | string - HTML content, which will be overlaid on top of the pie chart.
   *   The HTML content will block interactivity of the chart by default, but the CSS pointer-events property
   *   can be set to 'none' on this content if the chart's interactivity is desired.
   *   </li>
   *   <li>preventDefault: <code>true</code> - Indicates that the tooltip should not be displayed. It is not necessary
   *   to return {preventDefault:false} to display tooltip, since this is a default behavior.
   *   </li>
   * </ul>
   * @expose
   * @name renderer
   * @ojtypedefmember
   * @memberof! oj.ojChart.PieCenter
   * @ojshortdesc A function that returns custom center content. The function takes a context argument, provided by the chart. See the Help documentation for more information.
   * @type {(function(Object):Object|null)=}
   * @ojsignature {target: "Type", value: "oj.dvtBaseComponent.PreventableDOMRendererFunction<oj.ojChart.PieCenterRendererContext>", jsdocOverride: true}
   * @default null
   */

  /**
   * Object type defining the style of the plot area.
   * @ojtypedef oj.ojChart.PlotArea
   */
  /**
   * The border color to be set on the chart's plot area.
   * @expose
   * @name borderColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.PlotArea
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The border width to be set on the chart's plot area.
   * @expose
   * @name borderWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.PlotArea
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * The color of the plot area background.
   * @expose
   * @name backgroundColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.PlotArea
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * Specifies whether the plot area is rendered.
   * @expose
   * @name rendered
   * @ojtypedefmember
   * @memberof! oj.ojChart.PlotArea
   * @type {string=}
   * @ojvalue {string} "off" The chart's plot area will not be rendered.
   * @ojvalue {string} "on" The chart's plot area will be rendered.
   * @default "on"
   */

  /**
   * Object type that defines a chart series.
   * @typedef {Object} oj.ojChart.Series
   * @ojimportmembers oj.ojChartSeriesProperties
   * @property {(string|number)=} id The id of the series. Defaults to the name or the series index if not specified.
   * @property {Array.<Object>=} items An array of values or an array of objects that defines the data items for the series.
   * @ojsignature [{target: "Type", value: "(Array<oj.ojChart.Item<K, Array<oj.ojChart.Item<any, null>>|Array<number>|null>>|Array<number>)=", for: "items", consumedBy: "js"},
   *                {target: "Type", value: "(Array<oj.ojChart.Item<K, I>|Array<number>|null>>|Array<number>)=", for: "items", consumedBy: "ts"},
   *                {target: "Type", value: "<K, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   */

  /**
   * Object type that defines a chart group.
   * @typedef {Object} oj.ojChart.Group
   * @ojimportmembers oj.ojChartGroupProperties
   * @property {(string|number)=} id The id of the group. Defaults to the name if not specified. This is also used to specify the date for non mixed frequency time axes. The specified date for non mixed frequency time axes must be an ISO string.
   * @property {Array.<Object>=} groups An array of nested group objects.
   * @ojsignature {target: "Type", value: "Array<oj.ojChart.Group>=", for: "groups", jsdocOverride: true}
   */

  /**
   * Object type that defines a chart data item.
   * @typedef {Object} oj.ojChart.Item
   * @ojimportmembers oj.ojChartItemProperties
   * @property {any} id The id of the chart item. This id will be provided as part of the context for events on the chart.
   * @property {(Array.<Object>|Array.<number>)=} items An array of nested data items to be used for defining the markers for outliers or additional data items of a box plot.
   * @ojsignature [{target: "Type", value: "K", for: "id"},
   *              {target: "Type", value: "I", for: "items"},
   *              {target: "Type", value: "<K, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null,D=any>", for: "genericTypeParameters"}]
   */

  /**
   * Object type that defines a chart data item for the no template case.
   * @typedef {Object} oj.ojChart.DataItem
   * @ojimportmembers oj.ojChartItemProperties
   * @property {Array<string|number>} groupId The id of the group item. This id will be provided as part of the context for events on the chart.
   * @property {string|number} seriesId The id of the series item. This id will be provided as part of the context for events on the chart.
   * @ojsignature [{target: "Type", value: "I", for: "items"},
   *               {target: "Type", value: "<I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null,K=any,D=any>", for: "genericTypeParameters"}]
   */

  /**
   * Object type that defines box plot style properties.
   * @typedef {Object} oj.ojChart.BoxPlotStyle
   * @ojimportmembers oj.ojChartBoxPlotStyleProperties
   */

  /**
   * @typedef {Object} oj.ojChart.TooltipContext
   * @property {Element} parentElement The tooltip element. This can be used to change the tooltip border or background color.
   * @property {any} id The id of the hovered item.
   * @property {string} series The id of the series the hovered item belongs to.
   * @property {string|Array.<string>} group The ids or an array of ids of the group(s) the hovered item belongs to. For hierarchical groups, it will be an array of outermost to innermost group ids.
   * @property {string} label The data label of the hovered item.
   * @property {number} totalValue The total of all values in the chart. This will only be included for pie charts.
   * @property {number} value The value of the hovered item.
   * @property {number|string} x The x value of the hovered item.
   * @property {number} y The y value of the hovered item.
   * @property {number} z The z value of the hovered item.
   * @property {number} q1 The first quartile value of the hovered the box plot item.
   * @property {number} q2 The second quartile (median) value of the hovered box plot item.
   * @property {number} q3 The third quartile value of the hovered box plot item.
   * @property {number} low The low value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} high The high value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} open The open value of the hovered stock chart item.
   * @property {number} close The close value of the hovered stock chart item.
   * @property {number} volume The volume value of the hovered stock chart item.
   * @property {number} targetValue The target value of the hovered funnel item.
   * @property {Object|null} data The data object of the hovered item. For nested items, it will be an array containing the parent item data and nested item data.
   * @property {Object|null} itemData The row data object for the hovered item. This will only be set if a DataProvider is being used.
   * @property {Object|null} seriesData The data for the series the hovered item belongs to.
   * @property {Array.<Object>|null} groupData An array of data for the group the hovered item belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the hovered item.
   * @property {Element} componentElement The chart element.
   * @property {string} color The color of the hovered item.
   * @ojsignature [{target: "Type", value: "D", for: "itemData"},
   *               {target: "Type", value: "oj.ojChart.Item<K, Array<oj.ojChart.Item<any, null>>|Array<number>|null>|number|null", for: "data", consumedBy: "js"},
   *               {target: "Type", value: "oj.ojChart.Item<K, I>|Array<number>|null>|number|null", for: "data", consumedBy: "ts"},
   *               {target: "Type", value: "oj.ojChart.Series<K, I>|null", for: "seriesData", jsdocOverride: true},
   *               {target: "Type", value: "Array<oj.ojChart.Group>|null", for: "groupData", jsdocOverride: true},
   *               {target: "Type", value: "<K, D, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  /**
   * @typedef {Object} oj.ojChart.TooltipRendererContext
   * @property {Element} parentElement The tooltip element. This can be used to change the tooltip border or background color.
   * @property {any} id The id of the hovered item.
   * @property {string} series The id of the series the hovered item belongs to.
   * @property {string|Array.<string>} group The ids or an array of ids of the group(s) the hovered item belongs to. For hierarchical groups, it will be an array of outermost to innermost group ids.
   * @property {string} label The data label of the hovered item.
   * @property {number} totalValue The total of all values in the chart. This will only be included for pie charts.
   * @property {number} value The value of the hovered item.
   * @property {number|string} x The x value of the hovered item.
   * @property {number} y The y value of the hovered item.
   * @property {number} z The z value of the hovered item.
   * @property {number} q1 The first quartile value of the hovered the box plot item.
   * @property {number} q2 The second quartile (median) value of the hovered box plot item.
   * @property {number} q3 The third quartile value of the hovered box plot item.
   * @property {number} low The low value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} high The high value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} open The open value of the hovered stock chart item.
   * @property {number} close The close value of the hovered stock chart item.
   * @property {number} volume The volume value of the hovered stock chart item.
   * @property {number} targetValue The target value of the hovered funnel item.
   * @property {Object|null} data The data object of the hovered item. For nested items, it will be an array containing the parent item data and nested item data.
   * @property {Object|null} itemData The row data object for the hovered item. This will only be set if a DataProvider is being used.
   * @property {Object|null} seriesData The data for the series the hovered item belongs to.
   * @property {Array.<Object>|null} groupData An array of data for the group the hovered item belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the hovered item.
   * @property {Element} componentElement The chart element.
   * @property {string} color The color of the hovered item.
   * @ojsignature [{target: "Type", value: "D", for: "itemData"},
   *               {target: "Type", value: "oj.ojChart.Item<K, Array<oj.ojChart.Item<any, null>>|Array<number>|null>|number|null", for: "data", consumedBy: "js"},
   *               {target: "Type", value: "oj.ojChart.Item<K, I>|Array<number>|null>|number|null", for: "data", consumedBy: "ts"},
   *               {target: "Type", value: "oj.ojChart.Series<K, I>|null", for: "seriesData", jsdocOverride: true},
   *               {target: "Type", value: "Array<oj.ojChart.Group>|null", for: "groupData", jsdocOverride: true},
   *               {target: "Type", value: "<K, D, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   */
  /**
   * @typedef {Object} oj.ojChart.ItemShortDescContext
   * @property {any} id The id of the hovered item.
   * @property {string} series The id of the series the hovered item belongs to.
   * @property {string|Array.<string>} group The ids or an array of ids of the group(s) the hovered item belongs to. For hierarchical groups, it will be an array of outermost to innermost group ids.
   * @property {string} label The data label of the hovered item.
   * @property {number} totalValue The total of all values in the chart. This will only be included for pie charts.
   * @property {number} value The value of the hovered item.
   * @property {number|string} x The x value of the hovered item.
   * @property {number} y The y value of the hovered item.
   * @property {number} z The z value of the hovered item.
   * @property {number} q1 The first quartile value of the hovered the box plot item.
   * @property {number} q2 The second quartile (median) value of the hovered box plot item.
   * @property {number} q3 The third quartile value of the hovered box plot item.
   * @property {number} low The low value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} high The high value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} open The open value of the hovered stock chart item.
   * @property {number} close The close value of the hovered stock chart item.
   * @property {number} volume The volume value of the hovered stock chart item.
   * @property {number} targetValue The target value of the hovered funnel item.
   * @property {Object|null} data The data object of the hovered item. For nested items, it will be an array containing the parent item data and nested item data.
   * @property {Object|null} itemData The row data object for the hovered item. This will only be set if a DataProvider is being used.
   * @property {Object|null} seriesData The data for the series the hovered item belongs to.
   * @property {Array.<Object>|null} groupData An array of data for the group the hovered item belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the hovered item.
   * @ojsignature [{target: "Type", value: "D", for: "itemData"},
   *               {target: "Type", value: "oj.ojChart.Item<K, Array<oj.ojChart.Item<any, null>>|Array<number>|null>|number|null", for: "data", consumedBy: "js"},
   *               {target: "Type", value: "oj.ojChart.Item<K, I>|Array<number>|null>|number|null", for: "data", consumedBy: "ts"},
   *               {target: "Type", value: "oj.ojChart.Series<K, I>|null", for: "seriesData", jsdocOverride: true},
   *               {target: "Type", value: "Array<oj.ojChart.Group>|null", for: "groupData", jsdocOverride: true},
   *               {target: "Type", value: "<K, D, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   */
  /**
   * @typedef {Object} oj.ojChart.PieCenterContext
   * @property {Object} outerBounds Object containing (x, y, width, height) of the rectangle circumscribing the center area. The x and y coordinates are relative to the top, left corner of the element.
   * @property {number} outerBounds.x The x coordinate of the rectangle circumscribing the center area, relative to the top, left corner of the element.
   * @property {number} outerBounds.y The y coordinate of the rectangle circumscribing the center area, relative to the top, left corner of the element.
   * @property {number} outerBounds.width The width of the rectangle circumscribing the center area.
   * @property {number} outerBounds.height The height of the rectangle circumscribing the center area.
   * @property {Object} innerBounds Object containing (x, y, width, height) of the rectangle inscribed in the center area. The x and y coordinates are relative to the top, left corner of the element.
   * @property {number} innerBounds.x The x coordinate of the rectangle inscribed in the center area, relative to the top, left corner of the element.
   * @property {number} innerBounds.y The y coordinate of the rectangle inscribed in the center area, relative to the top, left corner of the element.
   * @property {number} innerBounds.width The width of the rectangle inscribed in the center area.
   * @property {number} innerBounds.height The height of the rectangle inscribed in the center area.
   * @property {Object} labelStyle The CSS style object defining the style of the label. The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @property {string} label The pieCenter label.
   * @property {number} totalValue The total of all values in the pie chart.
   * @property {Element} componentElement The chart element.
   * @ojsignature [{target: "Type", value: "Partial<CSSStyleDeclaration>=", for: "labelStyle", jsdocOverride: true}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  /**
   * @typedef {Object} oj.ojChart.PieCenterRendererContext
   * @property {Object} outerBounds Object containing (x, y, width, height) of the rectangle circumscribing the center area. The x and y coordinates are relative to the top, left corner of the element.
   * @property {number} outerBounds.x The x coordinate of the rectangle circumscribing the center area, relative to the top, left corner of the element.
   * @property {number} outerBounds.y The y coordinate of the rectangle circumscribing the center area, relative to the top, left corner of the element.
   * @property {number} outerBounds.width The width of the rectangle circumscribing the center area.
   * @property {number} outerBounds.height The height of the rectangle circumscribing the center area.
   * @property {Object} innerBounds Object containing (x, y, width, height) of the rectangle inscribed in the center area. The x and y coordinates are relative to the top, left corner of the element.
   * @property {number} innerBounds.x The x coordinate of the rectangle inscribed in the center area, relative to the top, left corner of the element.
   * @property {number} innerBounds.y The y coordinate of the rectangle inscribed in the center area, relative to the top, left corner of the element.
   * @property {number} innerBounds.width The width of the rectangle inscribed in the center area.
   * @property {number} innerBounds.height The height of the rectangle inscribed in the center area.
   * @property {Object} labelStyle The CSS style object defining the style of the label. The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @property {string} label The pieCenter label.
   * @property {number} totalValue The total of all values in the pie chart.
   * @property {Element} componentElement The chart element.
   * @ojsignature [{target: "Type", value: "Partial<CSSStyleDeclaration>=", for: "labelStyle", jsdocOverride: true}]
   */

  /**
   * @typedef {Object} oj.ojChart.PieCenterLabelContext
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.AxisTitleContext
   * @property {"xAxis"|"yAxis"|"y2Axis"} axis
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.ReferenceObject
   * @property {"xAxis"|"yAxis"|"y2Axis"} axis
   * @property {number} index The index of the reference object for the specified axis.
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.LegendItemContext
   * @property {Array} sectionIndexPath The array of numerical indices for the section.
   * @property {number} itemIndex The index of the item within the specified section.
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.GroupContext
   * @property {Array} indexPath The array of indices corresponding to the position of the group in the properties array. The array of numerical indices for the section.
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.ItemContext
   * @property {number} seriesIndex The index of the series within the specified section.
   * @property {number} itemIndex The index of the item within the specified section.
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.SeriesContext Context for a legend item that represents the series with the specified index.
   * @property {number} itemIndex The index of the item within the specified section.
   * @property {string} subId Sub-id string to identify a particular dom node.
   */

  /**
   * @typedef {Object} oj.ojChart.DataLabelContext
   * @property {any} id The id of the data item.
   * @property {string} series The id of the series the data item belongs to.
   * @property {string|Array.<string>} group The id or an array of ids of the group(s) the data item belongs to. For hierarchical groups, it will be an array of outermost to innermost group ids.
   * @property {number} value The value of the data item.
   * @property {number} targetValue The targetValue of the funnel data item.
   * @property {number|string} x The x value of the data item.
   * @property {number} y The y value of the data item.
   * @property {number} z The z value of the data item.
   * @property {number} q1 The first quartile value of the boxplot data item.
   * @property {number} q2 The second quartile (median) value of the boxplot data item.
   * @property {number} q3 The third quartile value of the boxplot data item.
   * @property {number} low The low value of the data item present in range bar/area, stock candlestick, or box plot item.
   * @property {number} high The high value of the data item present in range bar/area, stock candlestick, or box plot item
   * @property {number} open The open value of the stock chart data item.
   * @property {number} close The close value of the stock chart data item.
   * @property {number} volume The volume value of the stock chart data item.
   * @property {string} label The label for the data item if the dataLabel callback is ignored. The dataLabel callback can concatenate this with another string to easily enhance the default label.
   * @property {number} totalValue The total of all values in the chart. This will only be included for pie charts.
   * @property {Object|null} data The data object of the data item. For nested items, it will be an array containing the parent item data and nested item data.
   * @property {Object} itemData The row data object for the data item. This will only be set if a DataProvider is being used.
   * @property {Object|null} seriesData The data for the series the data item belongs to.
   * @property {Array.<Object>|null} groupData An array of data for the group the data item belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the data item.
   * @property {Object|null} dimensions The height and width of the data item. This will only be set for bar series types.
   * @property {number} dimensions.width The width of the data item.
   * @property {number} dimensions.height The height of the data item.
   * @property {Element} componentElement The chart element.
   * @ojsignature [{target: "Type", value: "D", for: "itemData"},
   *               {target: "Type", value: "oj.ojChart.Item<K, Array<oj.ojChart.Item<any, null>>|Array<number>|null>|number|null", for: "data", consumedBy: "js"},
   *               {target: "Type", value: "oj.ojChart.Item<K, I>|Array<number>|null>|number|null", for: "data", consumedBy: "ts"},
   *               {target: "Type", value: "oj.ojChart.Series<K, I>|null", for: "seriesData", jsdocOverride: true},
   *               {target: "Type", value: "Array<oj.ojChart.Group>|null", for: "groupData", jsdocOverride: true},
   *                {target: "Type", value: "<K, D, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   */

  /**
   * @typedef {Object} oj.ojChart.StackLabelContext
   * @property {string|Array.<string>} groups The id or an array of ids of the group(s) the data items belong to that are being stacked. For hierarchical groups, it will be an array of outermost to innermost group ids.
   * @property {Array.<Object>} data The array of data for the individual bars being stacked.
   * @property {Array.<Object>} groupData An array of data for the group the data item belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the data item.
   * @property {Array.<Object>} itemData The array of itemData for the individual bars being stacked.
   * @property {number} value The sum of the values of the individual bars being stacked.
   * @ojsignature [{target: "Type", value: "string|Array.<string>", for: "groups", jsdocOverride: true},
   *               {target: "Type", value: "Array.<oj.ojChart.Item<K, Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>|number|null>", for: "data", consumedBy: "js"},
   *               {target: "Type", value: "Array.<oj.ojChart.Item<K, I>|number|null>", for: "data", consumedBy: "ts"},
   *               {target: "Type", value: "Array.<oj.ojChart.Group>|null", for: "groupData", jsdocOverride: true},
   *               {target: "Type", value: "Array<D>", for: "itemData"},
   *               {target: "Type", value: "number", for: "value"},
   *               {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
   */

  /**
   * @typedef {Object} oj.ojChart.DndItem
   * @property {Array.<Object>} item An array of dataContexts of the dragged data items. The dataContext is the same as what we use for "tooltip" and "dataLabels" properties.
   * @ojsignature [{target: "Type", value: "Array<oj.ojChart.DataLabelContext<K, D, I>>", for: "item", jsdocOverride: true},
   *                {target: "Type", value: "<K, D, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   */

  /**
   * @typedef {Object} oj.ojChart.DndGroup
   * @property {string|number|Array.<string|number>} id The id of the group.
   * @property {string|number|Array.<string|number>} group The id of the group.
   * @property {string} label The label for the group.
   */

  /**
   * @typedef {Object} oj.ojChart.DndSeries
   * @property {string|number} id The id of the series.
   * @property {string} color The color of the series.
   * @property {any} componentElement The chart element.
   * @property {string|number} series The id of the series.
   * @property {Object} seriesData The data for the series.
   * @ojsignature [{target: "Type", value: "oj.ojChart.Series<K, I>", for: "seriesData", jsdocOverride: true},
   *                {target: "Type", value: "<K, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null>", for: "genericTypeParameters"}]
   */

  /**
   * @typedef {Object} oj.ojChart.DndDrop
   * @property {number|null} x The X axis value at the event position. This is populated for plot area and x axis "drops".
   * @property {number|null} y The Y axis value at the event position. This is populated for plot area and y axis "drops".
   * @property {number|null} y2 The Y2 axis value at the event position. This is populated for plot area and y2 axis "drops".
   */

  /**
   * @typedef {Object} oj.ojChart.SeriesTemplateContext
   * @property {Element} componentElement The &lt;oj-chart> custom element
   * @property {number} index The series index
   * @property {string} id The series id
   * @property {Array<Object>} items The array of objects which are chart items that belong to this series. The objects will have the following properties
   * @property {Object} items.data The data object for the item
   * @property {number} items.index The zero-based index of the item
   * @property {any} items.key The key of the current item
   * @ojsignature [{target: "Type", value: "D", for: "items.data"},
   *               {target: "Type", value: "<D>", for: "genericTypeParameters"}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  /**
   * @typedef {Object} oj.ojChart.GroupTemplateContext
   * @property {Element} componentElement The &lt;oj-chart> custom element
   * @property {number} index The group index
   * @property {Array<string>} ids An array of group IDs, from the outermost group to the current group. For non-hierarchical group, the array will contain only one id.
   * @property {number} depth The depth of the group. The depth of the outermost group under the invisible root is 1.
   * @property {boolean} leaf True if the group is a leaf group.
   * @property {Array<Object>} items The array of objects which are chart items that belong to this group. The objects will have the following properties:
   * @property {Object} items.data The data object for the item
   * @property {number} items.index The zero-based index of the item
   * @property {any} items.key The key of the current item
   * @ojsignature [{target: "Type", value: "D", for: "items.data"},
   *               {target: "Type", value: "<D>", for: "genericTypeParameters"}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  /**
   * @typedef {Object} oj.ojChart.ItemTemplateContext
   * @property {Element} componentElement The &lt;oj-chart> custom element
   * @property {number} index The zero-based index of the current item
   * @property {Object} data The data object for the current item
   * @property {any} key The key of the current item
   * @ojsignature [{target:"Type", value:"<K = any,D = any>", for:"genericTypeParameters"},
   * {target:"Type", value:"D", for:"data", jsdocOverride: true},
   * {target:"Type", value:"K", for:"key", jsdocOverride: true}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  // Slots
  /**
   * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for creating each item of the chart. The slot content must be a &lt;template> element.
   * The content of the template should only be one &lt;oj-chart-item> element. See the [oj-chart-item]{@link oj.ojChartItem} doc for more details. A <b>series-id</b> and <b>group-id</b> must be specified.</p>
   * <p>When the template is executed for each item, it will have access to the chart's binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojChart.ItemTemplateContext]{@link oj.ojChart.ItemTemplateContext} or the table below for a list of properties available on $current) </li>
   *   <li>alias - if data-oj-as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   * @ojslot itemTemplate
   * @ojshortdesc The itemTemplate slot is used to specify the template for creating each item of the chart. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojChart.ItemTemplateContext
   * @ojmaxitems 1
   * @memberof oj.ojChart
   * @ojpreferredcontent ["ChartItemElement"]
   *
   * @example <caption>Initialize the Chart with an inline item template specified:</caption>
   * &lt;oj-chart data="[[dataProvider]]">
   *  &lt;template slot='itemTemplate'>
   *    &lt;oj-chart-item
   *      value="[[$current.data.value]]"
   *      series-id="[[$current.data.productName]]"
   *      group-id="[[ [$current.data.year] ]]">
   *    &lt;/oj-chart-item>
   *  &lt;/template>
   * &lt;/oj-chart>
   */

  /**
   * <p>The <code class="prettyprint">seriesTemplate</code> slot is used to specify the template for generating the series properties of the chart. The slot content must be a single &lt;template> element.
   * The content of the template should only be one &lt;oj-chart-series> element.See the [oj-chart-series]{@link oj.ojChartSeries} doc for more details.</p>
   * <p>When the template is executed for each series, it will have access to the chart's binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojChart.SeriesTemplateContext]{@link oj.ojChart.SeriesTemplateContext} or the table below for a list of properties available on $current) </li>
   *   <li>alias - if data-oj-as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   *
   * @ojslot seriesTemplate
   * @ojshortdesc The seriesTemplate slot is used to specify the template for generating the series properties of the chart. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojChart.SeriesTemplateContext
   * @ojmaxitems 1
   * @memberof oj.ojChart
   * @ojpreferredcontent ["ChartSeriesElement"]
   *
   * @example <caption>Initialize the Chart with an inline series template specified:</caption>
   * &lt;oj-chart data="[[dataProvider]]">
   *  &lt;template slot='seriesTemplate'>
   *    &lt;oj-chart-series
   *      drilling='on'
   *      marker-shape='[[ $current.id == "Series 1" ? "square" : "circle" ]]'>
   *    &lt;/oj-chart-series>
   *  &lt;/template>
   * &lt;/oj-chart>
   */

  /**
   * <p>The <code class="prettyprint">groupTemplate</code> slot is used to specify the template for generating the group properties of the chart. The slot content must be a single &lt;template> element.
   * The content of the template should only be one &lt;oj-chart-group> element. See the [oj-chart-group]{@link oj.ojChartGroup} doc for more details.</p>
   * <p>When the template is executed for each group, it will have access to the chart's binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojChart.GroupTemplateContext]{@link oj.ojChart.GroupTemplateContext} or the table below for a list of properties available on $current) </li>
   *   <li>alias - if data-oj-as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   *
   * @ojslot groupTemplate
   * @ojshortdesc The groupTemplate slot is used to specify the template for generating the group properties of the chart. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojChart.GroupTemplateContext
   * @ojmaxitems 1
   * @memberof oj.ojChart
   * @ojpreferredcontent ["ChartGroupElement"]
   *
   * @example <caption>Initialize the Chart with an inline group template specified:</caption>
   * &lt;oj-chart data="[[dataProvider]]">
   *  &lt;template slot='groupTemplate'>
   *    &lt;oj-chart-group
   *      drilling='on'
   *      label-style='[[$current.depth == 1 ? {"fontWeight":"bold"} : {"fontStyle":"italic"}]]'>
   *    &lt;/oj-chart-group>
   *  &lt;/template>
   * &lt;/oj-chart>
   */

  /**
   * <p>The <code class="prettyprint">pieCenterTemplate</code> slot is used to specify custom center content
   * for a pie chart. The slot content must be a single &lt;template> element.
   * This slot takes precedence over the pieCenter.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the pie center. (See [oj.ojChart.PieCenterContext]{@link oj.ojChart.PieCenterContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot pieCenterTemplate
   * @ojmaxitems 1
   * @ojshortdesc The pieCenterTemplate slot is used to specify custom center content for a pie chart. This slot takes precedence over the pieCenter.renderer property if specified. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojChart.PieCenterContext
   * @memberof oj.ojChart
   *
   * @example <caption>Initialize the Chart with a pie center template specified:</caption>
   * &lt;oj-chart type="pie">
   *  &lt;template slot="pieCenterTemplate">
   *    &lt;div :style="[[{position: 'absolute',
   *                       top: $current.innerBounds.y + 'px',
   *                       left: $current.innerBounds.x + 'px',
   *                       height: $current.innerBounds.height + 'px',
   *                       width: $current.innerBounds.width + 'px'}]]">
   *      &lt;span>&lt;oj-bind-text value="[[$current.label]]">&lt;/oj-bind-text>&lt;/span><br/>
   *      &lt;span>&lt;oj-bind-text value="[['Total Value: ' + $current.totalValue]]">&lt;/oj-bind-text>&lt;/span>
   *    &lt;/div>
   *  &lt;/template>
   * &lt;/oj-chart>
   */

  /**
   * <p>The <code class="prettyprint">tooltipTemplate</code> slot is used to specify custom tooltip content. The slot content must be a single &lt;template> element.
   * This slot takes precedence over the tooltip.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojChart.TooltipContext]{@link oj.ojChart.TooltipContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot tooltipTemplate
   * @ojmaxitems 1
   * @ojshortdesc The tooltipTemplate slot is used to specify custom tooltip content. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojChart.TooltipContext
   * @memberof oj.ojChart
   *
   * @example <caption>Initialize the Chart with a tooltip template specified:</caption>
   * &lt;oj-chart>
   *  &lt;template slot="tooltipTemplate">
   *    &lt;span>&lt;oj-bind-text value="[[$current.data.label]]">&lt;/oj-bind-text>&lt;/span><br/>
   *    &lt;span>&lt;oj-bind-text value="[[$current.data.value]]">&lt;/oj-bind-text>&lt;/span>
   *  &lt;/template>
   * &lt;/oj-chart>
   */

  // SubId Locators **************************************************************

  /**
   * <p>Sub-ID for chart data items indexed by series and group indices. The group index is not required for pie and
   * funnel charts.</p>
   *
   * @property {number} seriesIndex
   * @property {number} itemIndex
   *
   * @ojsubid oj-chart-item
   * @memberof oj.ojChart
   *
   * @example <caption>Get the data item from the first series and second group:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-chart-item', 'seriesIndex': 0, 'itemIndex': 1});
   */

  /**
   * <p>Sub-ID for a legend item that represents the series with the specified index.</p>
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.</p>
   *
   * @property {number} index
   *
   * @ojsubid oj-chart-series
   * @memberof oj.ojChart
   *
   * @example <caption>Get the legend item that represents the first series:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-chart-series', 'index': 0});
   */

  /**
   * <p>Sub-ID for a categorical axis label that represents the group with the specified index.</p>
   *
   * @property {Array} indexPath The array of indices corresponding to the position of the group in the properties array.
   *
   * @ojsubid oj-chart-group
   * @memberof oj.ojChart
   * @instance
   *
   * @example <caption>Get the categorical axis label that represents the first group:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-chart-group', 'indexPath': [0]});
   */

  /**
   * <p>Sub-ID for the title of the specified axis.</p>
   *
   * @property {string} axis <code class="prettyprint">xAxis</code>, <code class="prettyprint">yAxis</code>, or <code class="prettyprint">y2Axis</code>
   *
   * @ojsubid oj-chart-axis-title
   * @memberof oj.ojChart
   *
   * @example <caption>Get the title for the x-axis:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-chart-axis-title', 'axis': 'xAxis'});
   */

  /**
   * <p>Sub-ID for the reference object of the specified axis with the given index.</p>
   *
   * @property {string} axis <code class="prettyprint">xAxis</code>, <code class="prettyprint">yAxis</code>, or <code class="prettyprint">y2Axis</code>
   * @property {number} index The index of the reference object for the specified axis.
   *
   * @ojsubid oj-chart-reference-object
   * @memberof oj.ojChart
   *
   * @example <caption>Get the first reference object of the y-axis:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-chart-reference-object', 'axis': 'yAxis', 'index': 0});
   */

  /**
   * <p>Sub-ID for the the chart tooltip.</p>
   *
   * @ojsubid oj-chart-tooltip
   * @memberof oj.ojChart
   *
   * @example <caption>Get the tooltip object of the chart, if displayed:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-chart-tooltip'});
   */

  /**
   * <p>Sub-ID for a legend item indexed by its position in its parent section's
   * item array and its parent's sectionIndex.</p>
   *
   * @property {Array} sectionIndexPath The array of numerical indices for the section.
   * @property {number} itemIndex The index of the item within the specified section.
   *
   * @ojsubid oj-legend-item
   * @memberof oj.ojChart
   *
   * @example <caption>Get the first legend item from the first legend section:</caption>
   * var nodes = myChart.getNodeBySubId({'subId': 'oj-legend-item', sectionIndexPath: [0], itemIndex: 1});
   */

  // Node Context Objects ********************************************************

  /**
   * <p>Context for chart data items indexed by series and group indices.</p>
   *
   * @property {number} seriesIndex
   * @property {number} itemIndex
   *
   * @ojnodecontext oj-chart-item
   * @memberof oj.ojChart
   */

  /**
   * <p>Context for a legend item that represents the series with the specified index.</p>
   *
   * @property {number} index
   *
   * @ojnodecontext oj-chart-series
   * @memberof oj.ojChart
   */

  /**
   * <p>Context for a categorical axis label that represents the group with the specified index.</p>
   *
   * @property {Array} indexPath The array of indices corresponding to the position of the group in the properties array.
   *
   * @ojnodecontext oj-chart-group
   * @memberof oj.ojChart
   */

  /**
   * <p>Context for the title of the specified axis.</p>
   *
   * @property {string} axis <code class="prettyprint">xAxis</code>, <code class="prettyprint">yAxis</code>, or <code class="prettyprint">y2Axis</code>
   *
   * @ojnodecontext oj-chart-axis-title
   * @memberof oj.ojChart
   */

  /**
   * <p>Context for the center label of a pie chart.</p>
   *
   * @ojnodecontext oj-chart-pie-center-label
   * @memberof oj.ojChart
   */

  /**
   * <p>Context for the reference object of the specified axis with the given index.</p>
   *
   * @property {string} axis <code class="prettyprint">xAxis</code>, <code class="prettyprint">yAxis</code>, or <code class="prettyprint">y2Axis</code>
   * @property {number} index The index of the reference object for the specified axis.
   *
   * @ojnodecontext oj-chart-reference-object
   * @memberof oj.ojChart
   */

  /**
   * <p>Context for a legend item indexed by its position in its parent section's
   * item array and its parent's sectionIndex.</p>
   *
   * @property {Array} sectionIndexPath The array of numerical indices for the section.
   * @property {number} itemIndex The index of the item within the specified section.
   *
   * @ojnodecontext oj-legend-item
   * @memberof oj.ojChart
   */
  /**
   * Specifies whether drilling on chart objects representing multiple series (e.g. other slice and legend item in pie charts) is enabled or not. Multiseries drill event is fired from the <i>other</i> slice and legend item of pieChart.
   * @expose
   * @name multiSeriesDrilling
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "on" Drill action for Other slice and legend item in pie chart will be enabled.
   * @ojvalue {string} "off" Drill action for Other slice and legend item in pie chart will be disabled.
   * @default 'off'
   */
  /**
   * Defines whether the plot area is split into two sections, so that sets of data assigned to the different Y-axes appear in different parts of the plot area. Stock charts do not support "off".
   * @expose
   * @name splitDualY
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "on" Plot area will be split into two sections corresponding to datasets assigned to the different Y-axes.
   * @ojvalue {string} "off" Plot area will not be split into two sections.
   * @ojvalue {string} "auto" Plot area will not be split into two sections except for the stock charts.
   * @default "auto"
   */
  /**
   * In a split dual-Y chart, specifies the fraction of the space that is given to the Y-axis subchart. Valid values are numbers from 0 to 1.
   * @expose
   * @name splitterPosition
   * @memberof oj.ojChart
   * @instance
   * @type {number=}
   * @default 0.5
   * @ojmin 0
   * @ojmax 1
   */
  /**
   * The type of time axis to display in the chart. Time axis is only supported for Cartesian bar, line, area, stock, box plot, and combo charts. If the value is "enabled" or "skipGaps", the time values must be provided through the "group-id" attribute of the oj-chart-item element. In this case stacking is supported. If the value is "skipGaps", the groups will be rendered at a regular interval regardless of any time gaps that may exist in the data. If the value is "mixedFrequency", the time values must be provided through the "x" attribute of the oj-chart-item element. In this case stacking is not supported.
   * The time values provided through "group-id" or "x" attribute of the oj-chart-item must be an ISO string.
   * @expose
   * @name timeAxisType
   * @memberof oj.ojChart
   * @ojshortdesc The type of time axis to display in the chart. Time axis is only supported for Cartesian bar, line, area, stock, box plot, and combo charts. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "enabled" The time value for each data item is passed using the group-id attribute of oj-chart-item. The time intervals do not have to be uniform. Data items from the same group should have the same time value.
   * @ojvalue {string} "mixedFrequency" The time value for each data item is passed using the x attribute of oj-chart-item. The time intervals do not have to be uniform. Data item from the same group can have different time values.
   * @ojvalue {string} "skipGaps" The time value for each data item is passed using the group-id attribute of oj-chart-item. The times will always be drawn uniformly ignoring gaps. Data items from the same group should have the same time value.
   * @ojvalue {string} "disabled" Time axis is disabled.
   * @ojvalue {string} "auto" Time axis is disabled unless it is a stock chart, for which the timeAxisType is mixedFrequency.
   * @default "auto"
   */
  /**
   * <p>The type of selection behavior that is enabled on the chart. This attribute controls the number of selections that can be made via selection gestures at any given time.
   *
   * <p>If <code class="prettyprint">single</code> or <code class="prettyprint">multiple</code> is specified, selection gestures will be enabled, and the chart's selection styling will be applied to all items specified by the <a href="#selection">selection</a> attribute.
   * If <code class="prettyprint">none</code> is specified, selection gestures will be disabled, and the chart's selection styling will not be applied to any items specified by the <a href="#selection">selection</a> attribute.
   *
   * <p>Changing the value of this attribute will not affect the value of the <a href="#selection">selection</a> attribute.
   *
   * @expose
   * @name selectionMode
   * @memberof oj.ojChart
   * @ojshortdesc The type of selection behavior that is enabled on the chart. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "none" Selection is disabled.
   * @ojvalue {string} "single" Only a single item can be selected at a time.
   * @ojvalue {string} "multiple" Multiple items can be selected at the same time.
   * @default "none"
   */
  /**
   * The action that is performed when a drag occurs on the chart. Pan and marquee zoom are only available if zoom and scroll is turned on. Marquee select is only available if multiple selection is turned on. If the value is set to "user" and multiple actions are available, buttons will be displayed on the plot area to let users switch between modes.
   * @expose
   * @name dragMode
   * @memberof oj.ojChart
   * @ojshortdesc The action that is performed when a drag occurs on the chart. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "pan" Pan action is performed when a drag occurs on the chart.
   * @ojvalue {string} "zoom" Zoom action is performed when a drag occurs on the chart.
   * @ojvalue {string} "select" Marquee selection is performed when a drag occurs on the chart.
   * @ojvalue {string} "off" Drag is disabled.
   * @ojvalue {string} "user" User can switch between different mode. Buttons will be displayed on the plot area to let users switch between modes.
   * @default "user"
   */
  /**
   * The chart type. By default, the first three series of "combo" chart are assigned '<i>bar'</i>, <i>'line'</i>, and <i>'area'</i> type respectively and then the type repeats, i.e sucessive series will be of types '<i>bar'</i>, <i>'line'</i>, and <i>'area'</i> and so on. To customize individual series, see <a href="oj.ojChartSeries.html#type"> oj-chart-series </a> for more details.
   * @expose
   * @name type
   * @memberof oj.ojChart
   * @ojshortdesc Specifies the chart type. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojsignature {target: "Type", value: "oj.ojChart.ChartType", jsdocOverride: true}
   * @default "bar"
   */
  /**
   * Defines whether the data items are stacked. Only applies to bar, line, area, and combo charts. Does not apply to range series.
   * @expose
   * @name stack
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "on" Data items belonging to same group will be stacked.
   * @ojvalue {string} "off" Data items will not be stacked.
   * @default "off"
   */
  /**
   * Defines whether the total values of stacked data items should be displayed. Only applies to bar charts. It can be formatted by the valueFormat of the type 'label'.
   * @expose
   * @name stackLabel
   * @ojshortdesc Defines whether the total values of stacked data items should be displayed. Only applies to bar charts. See the Help documentation for more information.
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "on" The total value of the stacked data items will be displayed.
   * @ojvalue {string} "off" The total value of the stacked data items will not be displayed.
   * @default "off"
   */
  /**
   * The chart orientation. Only applies to bar, line, area, combo, box plot, and funnel charts.
   * @expose
   * @name orientation
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "horizontal" Chart will be horizontally oriented.
   * @ojvalue {string} "vertical" Chart will be vertically oriented.
   * @default "vertical"
   */
  /**
   * Defines whether the grid shape of the polar chart is circle or polygon. Only applies to polar line and area charts.
   * @expose
   * @name polarGridShape
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "polygon" The grid shape of polar chart will be a polygonal with number of side of the polygon equal to number of groups in chart.
   * @ojvalue {string} "circle" The grid shape of polar chart will be circular.
   * @default "circle"
   */
  /**
   * The coordinate system of the chart. Only applies to bar, line, area, combo, scatter, and bubble charts.
   * @expose
   * @name coordinateSystem
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "polar" Polar coordinate system is used to plot the chart.
   * @ojvalue {string} "cartesian" Cartesian coordinate system is used to plot the chart.
   * @default "cartesian"
   */
  /**
   * Defines the hide and show behavior that is performed when clicking on a legend item. When data items are hidden, the y axes can be optionally rescaled to fit to the remaining data.
   * @expose
   * @name hideAndShowBehavior
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "withRescale" Y axes rescales when data items are hidden or showed by clicking on a legend item.
   * @ojvalue {string} "withoutRescale" Y axes does not rescale when data items are hidden or showed by clicking on a legend item.
   * @ojvalue {string} "none" Hide and show behavior is disabled.
   * @default "none"
   */
  /**
   * An array of category strings used for filtering. Series or data items with any category matching an item in this array will be filtered.
   * @expose
   * @name hiddenCategories
   * @memberof oj.ojChart
   * @instance
   * @type {(Array.<string>)=}
   * @default []
   * @ojwriteback
   */
  /**
   * Defines the behavior applied when hovering over data items.
   * @expose
   * @name hoverBehavior
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "dim" Dimming hover behavior is applied.
   * @ojvalue {string} "none" No hover behavior will be applied.
   * @default "none"
   */
  /**
   * An array of category strings used for highlighting. Series or data items matching categories in this array will be highlighted.
   * @expose
   * @name highlightedCategories
   * @memberof oj.ojChart
   * @instance
   * @type {(Array.<string>)=}
   * @default []
   * @ojwriteback
   */
  /**
   * The matching condition for the highlightedCategories property. By default, highlightMatch is 'all' and only items whose categories match all of the values specified in the highlightedCategories array will be highlighted. If highlightMatch is 'any', then items that match at least one of the highlightedCategories values will be highlighted.
   * @expose
   * @name highlightMatch
   * @memberof oj.ojChart
   * @ojshortdesc The matching condition for the highlightedCategories property. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "any" Only data items that match at least one of the highlightedCategories values will be highlighted.
   * @ojvalue {string} "all" Only data items that match all of the highlightedCategories values will be highlighted.
   * @default "all"
   */
  /**
   * Defines the animation that is applied on data changes. Animation is automatically disabled when there are a large number of data items.
   * @expose
   * @name animationOnDataChange
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "slideToLeft" Data changes will have a sliding animation to the left.
   * @ojvalue {string} "slideToRight" Data changes will have a sliding animation to the right.
   * @ojvalue {string} "auto" Default non-sliding animation.
   * @ojvalue {string} "none" No animation is applied on data change.
   * @default "none"
   */
  /**
   * Defines the animation that is shown on initial display. Animation is automatically disabled when there are a large number of data items.
   * @expose
   * @name animationOnDisplay
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "alphaFade" Chart uses an alpha fade animation on initial display.
   * @ojvalue {string} "zoom" Chart zooms into view on initial display.
   * @ojvalue {string} "auto" Default animation on initial display.
   * @ojvalue {string} "none" No animation is applied on initial display.
   * @default "none"
   */
  /**
   * An alias for the $current context variable when referenced inside the item, series, or group templates when using a DataProvider.
   * @expose
   * @name as
   * @memberof oj.ojChart
   * @ojshortdesc An alias for the '$current' context variable passed to slot content for the itemTemplate, seriesTemplate, or groupTemplate slots.
   * @instance
   * @type {string=}
   * @default ""
   * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
   */
  /**
   * A comparator function that determines the ordering of the chart series when using a DataProvider. If undefined, the series will follow the order in which they are found in the data. The series objects will have the same properties as the context for <a href="#seriesTemplate">seriesTemplate's $current</a>.
   * @expose
   * @name seriesComparator
   * @memberof oj.ojChart
   * @ojshortdesc A comparator function that determines the ordering of the chart series when using a DataProvider. If undefined, the series will follow the order in which they are found in the data.
   * @instance
   * @type {?(function(Object, Object):number)=}
   * @return {number} Returns a number less than zero, zero or greater than zero to determine the order.
   * If seriesComparator(a, b) is less than 0, chart series a comes before chart series b.
   * If seriesComparator(a, b) is 0, the original order is preserved.
   * If seriesComparator(a, b) is greater than 0, chart series b comes before chart series a.
   * @ojsignature {target: "Type", value: "((context1: oj.ojChart.SeriesTemplateContext<D>, context2:  oj.ojChart.SeriesTemplateContext<D>) => number)", jsdocOverride: true}
   * @default null
   */
  /**
   * A comparator function that determines the ordering of the chart groups when using a DataProvider. If undefined, the group will follow the order in which they are found in the data. The group objects will have the same properties as the context for <a href="#groupTemplate">groupTemplate's $current</a>.
   * @expose
   * @name groupComparator
   * @memberof oj.ojChart
   * @ojshortdesc A comparator function that determines the ordering of the chart groups when using a DataProvider. If undefined, the group will follow the order in which they are found in the data.
   * @instance
   * @type {?(function(Object, Object):number)=}
   * @return {number} Returns a number less than zero, zero or greater than zero to determine the order.
   * If groupComparator(a, b) is less than 0, chart group a comes before chart group b.
   * If groupComparator(a, b) is 0, the original order is preserved.
   * If groupComparator(a, b) is greater than 0, chart group b comes before chart group a.
   * @ojsignature {target: "Type", value: "((context1: oj.ojChart.GroupTemplateContext<D>, context2:  oj.ojChart.GroupTemplateContext<D>) => number)", jsdocOverride: true}
   * @default null
   */
  /**
   * Defines whether the data cursor is enabled. If set to "auto", the data cursor is shown only for line or area charts on touch devices. The data cursor is not shown when the tooltip is null and it is not supported on polar charts.
   * @expose
   * @name dataCursor
   * @memberof oj.ojChart
   * @ojshortdesc Defines whether the data cursor is enabled. The data cursor is not supported for polar charts. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "off" Data cursor is disabled.
   * @ojvalue {string} "on" Data cursor is enabled. Not supported by polar charts.
   * @ojvalue {string} "auto" The data cursor is shown only for line or area charts on touch devices.
   * @default "auto"
   */
  /**
   * Defines the behavior of the data cursor when moving between data items.
   * @expose
   * @name dataCursorBehavior
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "smooth" Data cursor follows the mouse cursor smoothly between data items.
   * @ojvalue {string} "snap" Data cursor snaps between data items.
   * @ojvalue {string} "auto" The data cursor exhibits the snap behavior except for line and area chart which exhibit the smooth behavior.
   * @default "auto"
   */
  /**
   * Specifies the position of the data cursor. Used for synchronizing data cursors across multiple charts. Null if the data cursor is not displayed.
   * @expose
   * @name dataCursorPosition
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.DataCursorPosition", jsdocOverride: true}
   * @ojwriteback
   */
  /**
   * Specifies the sorting of the data. It should only be used for pie charts, bar/line/area charts with one series, or stacked bar/area charts. Sorting will not apply when using a hierarchical group axis.
   * @expose
   * @name sorting
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "ascending" Data items are sorted in ascending order.
   * @ojvalue {string} "descending" Data items are sorted in descending order.
   * @ojvalue {string} "off" Groups are sorted in the order they are discovered in the data.
   * @default "off"
   */
  /**
   * Specifies the fraction of the whole pie under which a slice would be aggregated into an "Other" slice. Valid values range from 0 (default) to 1. For example, a value of 0.1 would cause all slices which are less than 10% of the pie to be aggregated into the "Other" slice. Only applies to pie chart.
   * @expose
   * @name otherThreshold
   * @memberof oj.ojChart
   * @instance
   * @type {number=}
   * @default 0
   * @ojmin 0
   * @ojmax 1
   */

  /**
   * An array used to define the ids of the initially selected objects.
   * When the selection is changed, the <code class="prettyprint">event.detail</code> of the <code class="prettyprint">selectionChanged</code> event will contain the following additional properties:<br><br>
   * <table class="props">
   *   <thead>
   *     <tr>
   *       <th>Name</th>
   *       <th>Type</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>selectionData</code></td>
   *       <td class="type">Object</td>
   *       <td class="description">an array containing objects describing the selected data items
   *         <h6>Properties</h6>
   *         <table class="props">
   *           <thead>
   *             <tr>
   *               <th>Name</th>
   *               <th>Type</th>
   *               <th>Description</th>
   *             </tr>
   *           </thead>
   *           <tbody>
   *             <tr>
   *               <td class="name"><code>data</code></td>
   *               <td class="type">object</td>
   *               <td class="description">the data of the item, if one was specified</td>
   *             </tr>
   *             <tr>
   *               <td class="name"><code>itemData</code></td>
   *               <td class="type">object</td>
   *               <td class="description">the row data of the item, if one was specified. This will only be set if a DataProvider is used.</td>
   *             </tr>
   *             <tr>
   *               <td class="name"><code>groupData</code></td>
   *               <td class="type">Array</td>
   *               <td class="description">the group data of the item</td>
   *             </tr>
   *             <tr>
   *               <td class="name"><code>seriesData</code></td>
   *               <td class="type">object</td>
   *               <td class="description">the series data of the item</td>
   *             </tr>
   *           </tbody>
   *         </table>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td class="name"><code>endGroup</code></td>
   *       <td class="type">string</td>
   *       <td class="description">the end group of a marquee selection on a chart with categorical axis</td>
   *     </tr>
   *     <tr>
   *       <td class="name"><code>startGroup</code></td>
   *       <td class="type">string</td>
   *       <td class="description">the start group of a marquee selection on a chart with categorical axis</td>
   *     </tr>
   *     <tr>
   *       <td class="name"><code>xMax</code></td>
   *       <td class="type">number</td>
   *       <td class="description">the maximum x value of a marquee selection</td>
   *     </tr>
   *     <tr>
   *       <td class="name"><code>xMin</code></td>
   *       <td class="type">number</td>
   *       <td class="description">the minimum x value of a marquee selection</td>
   *     </tr>
   *     <tr>
   *       <td class="name"><code>yMax</code></td>
   *       <td class="type">number</td>
   *       <td class="description">the maximum y value of a marquee selection</td>
   *     </tr>
   *     <tr>
   *       <td class="name"><code>yMin</code></td>
   *       <td class="type">number</td>
   *       <td class="description">the minimum y value of a marquee selection</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @expose
   * @name selection
   * @memberof oj.ojChart
   * @ojshortdesc An array used to define the ids of the initially selected objects. See the Help documentation for more information.
   * @instance
   * @type {(Array.<any>)=}
   * @ojsignature {target:"Type", value:"Array<K>"}
   * @default []
   * @ojwriteback
   * @ojeventgroup common
   */
  /**
   * An object defining the center content of a pie chart. Either a label can be displayed at the center of the pie chart or custom HTML content.
   * @expose
   * @name pieCenter
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.PieCenter", jsdocOverride: true}
   */
  /**
   * An object defining properties for the axis, tick marks, tick labels, and axis titles.
   * @expose
   * @name xAxis
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.XAxis", jsdocOverride: true}
   */
  /**
   * An object defining properties for the axis, tick marks, tick labels, and axis titles.
   * @expose
   * @name yAxis
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.YAxis", jsdocOverride: true}
   */
  /**
   * An object defining properties for the axis, tick marks, tick labels, and axis titles. Y2 axis is only supported for Cartesian bar, line, area, and combo charts.
   * @expose
   * @name y2Axis
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.Y2Axis", jsdocOverride: true}
   */
  /**
   * An object defining the overview scrollbar. Only applies if zoomAndScroll is not off. Currently only supported for vertical bar, line, area, stock, and combo charts.
   * @expose
   * @name overview
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.Overview<C>", jsdocOverride: true}
   */
  /**
   * An object defining the style of the plot area.
   * @expose
   * @name plotArea
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.PlotArea", jsdocOverride: true}
   */
  /**
   * An object defining the style, positioning, and behavior of the legend.
   * @expose
   * @name legend
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.Legend", jsdocOverride: true}
   */
  /**
   * An object defining the default styles for series colors, marker shapes, and other style attributes. Properties specified on this object may be overridden by specifications on the data object.
   * @expose
   * @name styleDefaults
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.StyleDefaults", jsdocOverride: true}
   */
  /**
   * An object specifying value formatting and tooltip behavior, whose keys generally correspond to the attribute names on the data items.
   * @name valueFormats
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.ValueFormats", jsdocOverride: true}
   */
  /**
   * Specifies the zoom and scroll behavior of the chart. "Live" behavior means that the chart will be updated continuously as it is being manipulated, while "delayed" means that the update will wait until the zoom/scroll action is done. While "live" zoom and scroll provides the best end user experience, no guarantess are made about the rendering performance or usability for large data sets or slow client environments. If performance is an issue, "delayed" zoom and scroll should be used instead.
   * @expose
   * @name zoomAndScroll
   * @memberof oj.ojChart
   * @ojshortdesc Specifies the zoom and scroll behavior of the chart. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "delayedScrollOnly" Zooming is disabled and chart will wait to update until scroll action is done.
   * @ojvalue {string} "liveScrollOnly" Zooming is disabled and chart is updated continuously when scrolled.
   * @ojvalue {string} "delayed" When zooming or scrolling, chart will wait to update until the zoom/scroll action is done.
   * @ojvalue {string} "live" When zooming or scrolling, chart will be updated continuously as it is being manipulated.
   * @ojvalue {string} "off" Zoom and scroll will be disabled.
   * @default "off"
   */
  /**
   * Specifies the zoom direction of bubble and scatter charts. "Auto" zooms in both x and y direction. Use "x" or "y" for single direction zooming.
   * @expose
   * @name zoomDirection
   * @memberof oj.ojChart
   * @instance
   * @type {string=}
   * @ojvalue {string} "x" Chart will only zoom in x direction.
   * @ojvalue {string} "y" Chart will only zoom in y direction.
   * @ojvalue {string} "auto" Chart will zoom in both x and y direction.
   * @default "auto"
   */
  /**
   * Whether automatic initial zooming is enabled. The valid values are "first" to initially zoom to the first data points (after the viewportMin) that can fit in the plot area, "last" to initially zoom to the last data points (before the viewportMax), and "none" to disable initial zooming. Only applies to bar, line, area, and combo charts with zoomAndScroll turned on.
   * @expose
   * @name initialZooming
   * @memberof oj.ojChart
   * @ojshortdesc Specifies whether automatic initial zooming is enabled. Only applies to bar, line, area, and combo charts with zoomAndScroll turned on. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "first" Zoom to first data points (after the viewportMin) that can fit in the plot area on initial render.
   * @ojvalue {string} "last" Zoom to last data points (before the viewportMax) that can fit in the plot area on initial render.
   * @ojvalue {string} "none" No initial zooming.
   * @default "none"
   */
  /**
   * Whether drilling is enabled. Drillable objects will show a pointer cursor on hover and fire an <code class="prettyprint">ojDrill</code> event on click (double click if selection is enabled). Use "on" to enable drilling for all series objects (legend items), group objects (x-axis labels), and data items. Use "seriesOnly" or "groupsOnly" to enable drilling for series objects or group objects only. To enable or disable drilling on individual series, group, or data item, use the drilling attribute in each series, group, or data item.
   * See multiSeriesDrilling documentation for details on drilling on the legend item for Other.
   * @expose
   * @name drilling
   * @memberof oj.ojChart
   * @ojshortdesc Specifies whether drilling is enabled. Drillable objects will show a pointer cursor on hover and fire an ojDrill event on click (double click if selection is enabled). See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "on" Drilling is enabled on data items, axis labels and legend items.
   * @ojvalue {string} "seriesOnly" Drilling is enabled only on legend items. Use multiSeriesDrilling attribute to enable drilling on the legend item for Other.
   * @ojvalue {string} "groupsOnly" Drilling is enabled only on axis labels.
   * @ojvalue {string} "off" Drilling is not enabled.
   * @default "off"
   */
  /**
   * Data visualizations require a press and hold delay before triggering tooltips, marquee selection, and rollover effects on mobile devices to avoid interfering with page panning, but these hold delays can make applications seem slower and less responsive.For a better user experience,
   * the application can remove the touch and hold delay when data visualizations are used within a non scrolling container or if there is sufficient space outside of the visualization for panning. If touchResponse is touchStart the element will instantly trigger the touch gesture and
   * consume the page pan events if the element does not require an internal feature that requires a touch start gesture like panning, zooming, or when marquee selection is initiated. If touchResponse is auto, the element will behave like touchStart if it determines that it is not rendered within scrolling content
   * and if panning is not available for those elements that support the feature.
   * @expose
   * @name touchResponse
   * @memberof oj.ojChart
   * @ojshortdesc Specifies configuration options for touch and hold delays on mobile devices. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "touchStart"  Chart will instantly trigger the touch gesture and consume the page pan events if it does not require an internal feature that requires a touch start gesture like panning, zooming, or when marquee selection is initiated.
   * @ojvalue {string} "auto" Chart will behave like touchStart if it determines that it is not rendered within scrolling content and if panning is not available for those elements that support the feature.
   * @default "auto"
   * @ojdeprecated {since: '18.0.0', description: 'This attribute is deprecated and no longer recommended in the Redwood Design system. The "auto" value behavior will be applied instead.'}

   */
  /**
   * A function that returns a custom data label. The function takes a <a href="#DataLabelContext">DataLabelContext</a> argument,
   * provided by the chart. The function may return a number or a string or in the case of range charts, an array of numbers or strings. If any label is a number, it will be formatted by the valueFormat of the type 'label' before being used as a label.
   * @expose
   * @name dataLabel
   * @memberof oj.ojChart
   * @ojshortdesc A function that returns a custom data label. The function takes a context argument, provided by the chart. See the Help documentation for more information.
   * @instance
   * @type {?(function(Object):Object)=}
   * @ojsignature {target: "Type", value: "((context: oj.ojChart.DataLabelContext<K, D, I>) => (Array<string>|string|Array<number>|number))", jsdocOverride: true}
   * @default null
   */
  /**
   * A function that returns a custom data label for stacks in bar charts with stacking enabled. The function takes a <a href="#StackLabelContext">StackLabelContext</a> argument,
   * provided by the chart. The function returns a string.
   * @expose
   * @name stackLabelProvider
   * @memberof oj.ojChart
   * @ojshortdesc A function that returns a custom stack label. The function takes a context argument, provided by the chart. See the Help documentation for more information.
   * @instance
   * @type {(function(Object):String)=}
   * @ojsignature {target: "Type", value: "((context: oj.ojChart.StackLabelContext<K, D, I>) => (string))", jsdocOverride: true}
   * @default null
   */
  /**
   * Provides support for HTML5 Drag and Drop events. Please refer to <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop">third party documentation</a> on HTML5 Drag and Drop to learn how to use it.
   * @expose
   * @name dnd
   * @ojshortdesc Provides support for HTML5 Drag and Drop events. See the Help documentation for more information.
   * @memberof oj.ojChart
   * @instance
   * @type {Object=}
   */
  /**
   * An object that describes drag functionality.
   * @expose
   * @name dnd.drag
   * @memberof! oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.DndDragConfigs<K, D, I>", jsdocOverride: true}
   */
  /**
   * An object that describes drop functionality.
   * @expose
   * @name dnd.drop
   * @memberof! oj.ojChart
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.DndDropConfigs", jsdocOverride: true}
   */
  //-----------------------------------------------------
  //                   Styling
  //-----------------------------------------------------
  /**
   * @ojstylevariableset oj-chart-css-set1
   * @ojstylevariable oj-chart-axis-title-text-color {description: "Chart axis title text color", formats: ["color"], help: "#css-variables"}
   * @ojstylevariable oj-chart-axis-tick-label-text-color {description: "Chart axis tick label text color",formats: ["color"], help: "#css-variables"}
   * @ojstylevariable oj-chart-animation-rising-icon-color {description: "Chart rising animation icon color", formats: ["color"], help: "#css-variables"}
   * @ojstylevariable oj-chart-animation-falling-icon-color {description: "Chart falling animation icon color", formats: ["color"], help: "#css-variables"}
   * @ojstylevariable oj-chart-animation-marker-color {description: "Chart animation marker color",formats: ["color"], help: "#css-variables"}
   * @ojstylevariable oj-chart-data-cursor-line-color {description: "Chart data cursor line color", formats: ["color"], help: "#css-variables"}
   * @memberof oj.ojChart
   */
  /**
   * @ojstylevariableset oj-chart-css-set2
   * @ojdisplayname Polar chart
   * @ojstylevariable oj-chart-polar-axis-tick-label-inside-bg-color {description: "Polar chart inside tick label background color", formats: ["color"], help: "#oj-chart-css-set2"}
   * @ojstylevariable oj-chart-polar-axis-tick-label-outside-bg-color {description: "Polar chart outside tick label background color", formats: ["color"], help: "#oj-chart-css-set2"}
   * @memberof oj.ojChart
   */
  /**
   * @ojstylevariableset oj-chart-css-set3
   * @ojdisplayname Stock Chart
   * @ojstylevariable oj-chart-stock-falling-bg-color {description: "Stock chart falling stock background color", formats: ["color"], help: "#oj-chart-css-set3"}
   * @ojstylevariable oj-chart-stock-range-bg-color {description: "Stock chart stock range background color", formats: ["color"], help: "oj-chart-css-set3"}
   * @ojstylevariable oj-chart-stock-rising-bg-color {description: "Stock chart rising stock background color", formats: ["color"], help: "oj-chart-css-set3"}
   * @memberof oj.ojChart
   */

  /**
   * Object type that defines a chart data item.
   * @typedef {Object} oj.ojChart.LegendItem
   * @property {string=} borderColor The border color of the marker. Only applies if symbolType is "marker" or "lineWithMarker".
   * @property {Array.<string>=} categories An array of categories for the legend item. Legend items currently only support a single category. If no category is specified, this defaults to the id or text of the legend item.
   * @property {"hidden"|"visible"} [categoryVisibility="visible"] Defines whether the legend item corresponds to visible data items. A hollow symbol is shown if the value is "hidden".
   * @property {string=} color The color of the legend symbol (line or marker). When symbolType is "lineWithMarker", this attribute defines the line color and the markerColor attribute defines the marker color.
   * @property {string=} id The id of the legend item, which is provided as part of the context for events fired by the legend. If not specified, the default depends upon whether a DataProvider is being used.<br><br>For the DataProvider case, the key for the node will be used as the default id. Otherwise, the id defaults to the text of the legend item.
   * @property {"dashed"|"dotted"|"solid"} [lineStyle="solid"] The line style. Only applies when the symbolType is "line" or "lineWithMarker".
   * @property {number=} lineWidth The line width in pixels. Only applies when the symbolType is "line" or "lineWithMarker".
   * @property {string=} markerColor The color of the marker, if different than the line color. Only applies if the symbolType is "lineWithMarker".
   * @property {"circle"|"diamond"|"ellipse"|"human"|"plus"|"rectangle"|"square"|"star"|"triangleDown"|"triangleUp"|string} [markerShape="square"] The shape of the marker. Only applies if symbolType is "marker" or "lineWithMarker". Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
   * @property {"largeChecker"|"largeCrosshatch"|"largeDiagonalLeft"|"largeDiagonalRight"|"largeDiamond"|"largeTriangle"|"none"|"smallChecker"|"smallCrosshatch"|"smallDiagonalLeft"|"smallDiagonalRight"|"smallDiamond"|"smallTriangle"} [pattern="none"] The pattern used to fill the marker. Only applies if symbolType is "marker" or "lineWithMarker".
   * @property {string=} shortDesc The description of this legend item. This is used for accessibility and for customizing the tooltip text.
   * @property {string=} source The URI of the image of the legend symbol.
   * @property {"image"|"line"|"lineWithMarker"|"marker"} [symbolType="marker"] The type of legend symbol to display.
   * @property {string} text The legend item text.
   * @ojdeprecated {since: '14.1.0', description: 'Use hidden-categories attribute of oj-chart instead.', for:'categoryVisibility', target: 'property' }
   */

  /**
   * Object type that specifies the properties for a legend section.
   * @ojtypedef oj.ojChart.LegendSection
   * @ojimportmembers oj.ojChartLegendSectionProperties
   * @ojdeprecated [{target:"property", for: "titleHalign", since: "15.1.0", description: "Individual section title alignment is no longer supported. Use section-title-halign in legend to align all section titles." },
   * {target:"property", for: "titleStyle", since: "15.1.0", description: "Individual section title style is no longer supported. Use section-title-style in legend to style all section titles." }]
   */
  /**
   * An array of objects with the following properties defining the legend items. Also accepts a Promise for deferred data rendering. No data will be rendered if the Promise is rejected.
   * @expose
   * @name items
   * @ojtypedefmember
   * @memberof! oj.ojChart.LegendSection
   * @type {Array.<Object>=}
   * @ojsignature {target: "Type", value: "Array.<oj.ojChart.LegendItem>", jsdocOverride: true}
   */
  /**
   * An array of nested legend sections.
   * @expose
   * @name sections
   * @ojtypedefmember
   * @memberof! oj.ojChart.LegendSection
   * @type {Array.<Object>=}
   * @ojdeprecated {since: "18.0.0", description: "Use of nested legend sections is not recommended in Redwood theme. As such, this attribute is deprecated." }
   * @ojsignature {target: "Type", value: "Array.<oj.ojChart.LegendSection>", jsdocOverride: true}
   */
  /**
   * Object type that specifies the properties for the series section in the legend.
   * @ojtypedef oj.ojChart.LegendSeriesSection
   * @ojimportmembers oj.ojChartLegendSectionProperties
   * @ojdeprecated [{target:"property", for: "titleHalign", since: "15.1.0", description: "Individual section title alignment is no longer supported. Use section-title-halign in legend to align all section titles." },
   * {target:"property", for: "titleStyle", since: "15.1.0", description: "Individual section title style is no longer supported. Use section-title-style in legend to style all section titles." }]
   */
  /**
   * Object type that specifies the properties for the reference object section in the legend.
   * @ojtypedef oj.ojChart.LegendReferenceObjectSection
   * @ojimportmembers oj.ojChartLegendSectionProperties
   * @ojdeprecated [{target:"property", for: "titleHalign", since: "15.1.0", description: "Individual section title alignment is no longer supported. Use section-title-halign in legend to align all section titles." },
   * {target:"property", for: "titleStyle", since: "15.1.0", description: "Individual section title style is no longer supported. Use section-title-style in legend to style all section titles." }]
   */

  /**
   * Object type that specifies the style, positioning, and behavior of the legend.
   * @ojtypedef oj.ojChart.Legend
   */
  /**
   * The legend title.
   * @expose
   * @name title
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @default null
   * @ojtranslatable
   */
  /**
   * An array of objects with the following properties defining the additional legend sections, other than the default series and reference object sections.
   * @expose
   * @name sections
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @ojshortdesc An array of objects defining the additional legend sections, other than the default series and reference object sections.
   * @type {Array.<Object>=}
   * @ojsignature {target: "Type", value: "Array.<oj.ojChart.LegendSection>", jsdocOverride: true}
   * @default []
   */
  /**
   * An object that specifies the properties for the series section in the legend.
   * @expose
   * @name seriesSection
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @ojshortdesc An object defining the series section in the legend.
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.LegendSeriesSection", jsdocOverride: true}
   */
  /**
   * An object with the following properties for the reference object section in the legend.
   * @expose
   * @name referenceObjectSection
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @ojshortdesc An object defining the reference object section in the legend.
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.LegendReferenceObjectSection", jsdocOverride: true}
   */
  /**
   * The position of the legend within the chart. By default, the legend will be placed on the side or bottom, based on the size of the chart and the legend contents.
   * @expose
   * @name position
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @ojvalue {string} "start" The legend will be placed at the start of the chart.
   * @ojvalue {string} "end" The legend will be placed at the end of the chart.
   * @ojvalue {string} "bottom" The legend will be placed at the bottom of the chart..
   * @ojvalue {string} "top" The legend will be placed at the top of the chart.
   * @ojvalue {string} "auto" The legend will be placed on the side or bottom, based on the size of the chart and the legend contents.
   * @default "auto"
   */
  /**
   * Defines whether the legend is displayed. If set to auto, the legend will be hidden for charts with a large number of series. To ensure that the legend is always displayed, set this attribute to 'on'. To turn on legend for stock, funnel and pyramid charts, set the displayInLegend property for the series items to 'on'.
   * @expose
   * @name rendered
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @ojshortdesc Defines whether the legend is displayed. If set to auto, the legend will be hidden for charts with a large number of series. See the Help documentation for more information.
   * @type {string=}
   * @ojvalue {string} "on" Legend will be displayed in the chart.
   * @ojvalue {string} "off" Legend will not be displayed in the chart.
   * @ojvalue {string} "auto" Legend will be hidden for charts with a large number of series.
   * @default "auto"
   */
  /**
   * Defines the size of the legend in pixels (e.g. '50px') or percent (e.g. '15%').
   * @expose
   * @name size
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @default null
   */
  /**
   * Defines the maximum size of the legend in pixels (e.g. '50px') or percent (e.g. '15%').
   * @expose
   * @name maxSize
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @default null
   */
  /**
   * The color of the legend background.
   * @expose
   * @name backgroundColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The border color of the legend.
   * @expose
   * @name borderColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The CSS style object defining the style of the legend text.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight and textDecoration.
   * @expose
   * @name textStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the legend text.
   * @memberof! oj.ojChart.Legend
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * The width of the legend symbol (line or marker) in pixels.
   * @expose
   * @name symbolWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * The height of the legend symbol (line or marker) in pixels.
   * @expose
   * @name symbolHeight
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * The horizontal alignment of the title.
   * @expose
   * @name titleHalign
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @ojdeprecated {since: '15.1.0', description: 'Individual section title alignment is no longer supported. Use section-title-halign in legend to align all section titles'}
   * @ojvalue {string} "center" The title will be center-aligned within the legend.
   * @ojvalue {string} "end" The title will be end-aligned within the legend.
   * @ojvalue {string} "start" The title will be start-aligned within the legend.
   */
  /**
   * The CSS style object defining the style of the title.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight and textDecoration.
   * @expose
   * @name titleStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the title.
   * @memberof! oj.ojChart.Legend
   * @type {Object=}
   * @ojdeprecated {since: '15.1.0', description: 'Individual section title style is no longer supported. Use section-title-style in legend to style all section titles'}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * Defines whether scrolling is enabled for the legend.
   * @expose
   * @name scrolling
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @ojdeprecated {since: '12.1.0', description: 'Setting scrolling to off is not supported in the Redwood theme and it is not recommended.'}
   * @ojvalue {string} "off" The legend will not be scrollable.
   * @ojvalue {string} "asNeeded" The legend will be scrollable if items do not fit in the specified space.
   * @default "asNeeded"
   */
  /**
   * The horizontal alignment of the section titles.
   * @expose
   * @name sectionTitleHalign
   * @ojtypedefmember
   * @memberof! oj.ojChart.Legend
   * @type {string=}
   * @ojvalue {string} "center" The title will be center-aligned within the legend.
   * @ojvalue {string} "end" The title will be end-aligned within the legend.
   * @ojvalue {string} "start" The title will be start-aligned within the legend.
   * @default "start"
   */
  /**
   * The CSS style object defining the style of the section titles' text. The following style properties are supported: color, fontFamily, fontSize, fontStyle, fontWeight and textDecoration.
   * @expose
   * @name sectionTitleStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the section titles' text. The following style properties are supported: color, fontFamily, fontSize, fontStyle, fontWeight and textDecoration.
   * @memberof! oj.ojChart.Legend
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */

  /**
   * Object type defining the data cursor style.
   * @ojtypedef oj.ojChart.DataCursorDefaults
   */
  /**
   * The width of the data cursor line in pixels.
   * @expose
   * @name lineWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorDefaults
   * @type {number=}
   * @default null
   * @ojunits pixels
   * @ojmin 0
   */
  /**
   * The color of the data cursor line.
   * @expose
   * @name lineColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The line style of the data cursor line.
   * @expose
   * @name lineStyle
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorDefaults
   * @type {string=}
   * @ojsignature {target: "Type", value: "oj.ojChart.LineStyle", jsdocOverride: true}
   * @default "solid"
   */
  /**
   * The color of the data cursor marker. Defaults to the data series color.
   * @expose
   * @name markerColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The size of the data cursor marker in pixels.
   * @expose
   * @name markerSize
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorDefaults
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * Whether the data cursor marker is displayed. Marker should only be hidden if the data cursor is displaying information for the entire group.
   * @expose
   * @name markerDisplayed
   * @ojtypedefmember
   * @memberof! oj.ojChart.DataCursorDefaults
   * @type {string=}
   * @ojvalue {string} "off"  Data cursor marker will not be displayed.
   * @ojvalue {string} "on" Data cursor marker will be displayed.
   * @default "on"
   */

  /**
   * Object type defining the style for hierarchical label separators.
   * @ojtypedef oj.ojChart.GroupSeparatorDefaults
   */
  /**
   * Defines whether the group separators are displayed.
   * @expose
   * @name rendered
   * @ojtypedefmember
   * @memberof! oj.ojChart.GroupSeparatorDefaults
   * @type {string=}
   * @ojvalue {string} "off" Group separators in hierarchical axis will not be displayed.
   * @ojvalue {string} "auto" Group separators in hierarchical axis will be displayed.
   * @default "auto"
   */
  /**
   * The color of the separators lines.
   * @expose
   * @name color
   * @ojtypedefmember
   * @memberof! oj.ojChart.GroupSeparatorDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */

  /**
   * Object type containing the style properties of the box plot items.
   * @ojtypedef oj.ojChart.BoxPlotDefaults
   */
  /**
   * The CSS style class to apply to the whisker stems.
   * @expose
   * @name whiskerSvgClassName
   * @ojtypedefmember
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {string=}
   * @default ""
   */
  /**
   * The CSS inline style to apply to the whisker stems.
   * Only SVG CSS style properties are supported.
   * @expose
   * @name whiskerSvgStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS inline style to apply to the whisker stems.
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * The CSS style class to apply to the whisker ends.
   * @expose
   * @name whiskerEndSvgClassName
   * @ojtypedefmember
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {string=}
   * @default ""
   */
  /**
   * The CSS inline style to apply to the whisker ends.
   * Only SVG CSS style properties are supported.
   * @expose
   * @ojshortdesc The CSS inline style to apply to the whisker ends.
   * @name whiskerEndSvgStyle
   * @ojtypedefmember
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * Specifies the length of the whisker ends in pixels (e.g. '9px') or as a percentage of the box width (e.g. '50%').
   * @expose
   * @name whiskerEndLength
   * @ojtypedefmember
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {string=}
   * @default null
   */
  /**
   * The CSS style class to apply to the median line.
   * @expose
   * @name medianSvgClassName
   * @ojtypedefmember
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {string=}
   * @default ""
   */
  /**
   * The CSS inline style to apply to the median line.
   * Only SVG CSS style properties are supported.
   * @expose
   * @name medianSvgStyle
   * @ojtypedefmember
   * @memberof! oj.ojChart.BoxPlotDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */

  /**
   * Object type defining the default styles for series colors, marker shapes, and other style attributes. Properties specified on this object may be overridden by specifications on the data object.
   * @ojtypedef oj.ojChart.StyleDefaults
   */
  /**
   * Defines the fill effect for the data items.
   * @expose
   * @name seriesEffect
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "color" Data items will be filled with solid colors.
   * @ojvalue {string} "pattern" Data items will be filled with colored patterns.
   * @ojvalue {string} "gradient" Data items will have a gradient.
   * @default "color"
   */
  /**
   * The array defining the default color ramp for the series.
   * @expose
   * @name colors
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Array.<string>=}
   * @default null
   */
  /**
   * The array defining the default pattern ramp for the series. This is used only when seriesEffect is 'pattern'.
   * @expose
   * @name patterns
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Array.<string>=}
   * @default null
   */
  /**
   * Specifies the color of the "Other" slice. Only applies to pie chart.
   * @expose
   * @name otherColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The array defining the default shape ramp for the series. Valid values are defined in the markerShape attribute.
   * @expose
   * @name shapes
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Array.<string>=}
   * @default null
   */
  /**
   * The default border color for the data items. For funnel and pyramid charts, it is used for the slice border.
   * @expose
   * @name borderColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The default border width for the data items. For funnel and pyramid charts, it is used for the slice border.
   * @expose
   * @name borderWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * The default background color of funnel slices that show actual/target values.
   * @expose
   * @name funnelBackgroundColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * Defines whether the chart is displayed with a 3D effect. Only applies to pie, funnel and pyramid charts.
   * @expose
   * @name threeDEffect
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "on" Chart will be displayed with a 3D effect.
   * @ojvalue {string} "off" Chart will not be displayed with a 3D effect.
   * @ojdeprecated {since: '18.0.0', description: '3D effect is not supported in Redwood theme and is not recommended. As such, this attribute is deprecated.'}
   * @default "off"
   */
  /**
   * The selection effect that is applied to selected items. The values explode and highlightAndExplode only apply to pie charts.
   * @expose
   * @name selectionEffect
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "explode" Selected data items will have an explode effect.
   * @ojvalue {string} "highlightAndExplode" Selected data items will have both the highligt and explode effect.
   * @ojvalue {string} "highlight" Selected data items will be highlighted.
   * @default "highlight"
   */
  /**
   * The duration of the animations in milliseconds.
   * @expose
   * @name animationDuration
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojunits milliseconds
   * @ojmin 0
   */
  /**
   * Defines whether data change indicators are displayed during animation.
   * @expose
   * @name animationIndicators
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "none" Data change indicators will be disabled.
   * @ojvalue {string} "all" Data change indicators will be enabled.
   * @default "all"
   */
  /**
   * The color of the indicator shown for an increasing data change animation.
   * @expose
   * @name animationUpColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The color of the indicator shown for a decreasing data change animation.
   * @expose
   * @name animationDownColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The fill color of the marquee. Applies to marquee selection and marquee zoom.
   * @expose
   * @name marqueeColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The border color of the marquee. Applies to marquee selection and marquee zoom.
   * @expose
   * @name marqueeBorderColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * Specifies the radius of the inner circle that can be used to create a donut chart. Valid values range from 0 (default) to 1. Not supported if 3D effect is on.
   * @expose
   * @name pieInnerRadius
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default 0
   * @ojmin 0
   * @ojmax 1
   */
  /**
   * The width of the data line. Only applies to line, lineWithArea, scatter, and bubble series.
   * @expose
   * @name lineWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojunits pixels
   * @ojmin 0
   */
  /**
   * The line type of the data line or area. Only applies to line, area, scatter, and bubble series. centeredStepped and centeredSegmented are not supported for polar, scatter, and bubble charts.
   * @expose
   * @name lineType
   * @ojtypedefmember
   * @ojshortdesc The line type of the data line or area. Only applies to line, area, scatter, and bubble series. See the Help documentation for more information.
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "curved" Data points will be connected with a curved line.
   * @ojvalue {string} "stepped" Data points will be connected with a stepped line.
   * @ojvalue {string} "centeredStepped" Data points will be connected with a centered stepped line.
   * @ojvalue {string} "segmented" Data points will be connected with a segmented line.
   * @ojvalue {string} "centeredSegmented" Data points will be connected with a centered segmented line.
   * @ojvalue {string} "straight" Data points will be connected with a straight line.
   * @ojvalue {string} "none" Data points will not be connected.
   * @ojvalue {string} "auto" Defaults to none for scatter and bubble charts otherwise line type is straight.
   * @default "auto"

   */
  /**
   * The line style of the data line. Only applies to line, lineWithArea, scatter, and bubble series.
   * @expose
   * @name lineStyle
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojsignature {target: "Type", value: "oj.ojChart.LineStyle", jsdocOverride: true}
   * @default "solid"
   */
  /**
   * The color of the data markers, if different from the series color.
   * @expose
   * @name markerColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * Defines whether the data markers should be displayed. Only applies to line, area, scatter, and bubble series. If auto, the markers will be displayed for combo chart and whenever the data points are not connected by a line.
   * @expose
   * @name markerDisplayed
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "on" Data markers will be displayed.
   * @ojvalue {string} "off" Data markers will not be displayed.
   * @ojvalue {string} "auto" Data markers will be displayed for combo chart and whenever the data points are not connected by a line.
   * @default "auto"
   */
  /**
   * The shape of the data markers. In addition to the built-in shapes, it may also take SVG path commands to specify a custom shape. The chart will style the custom shapes the same way as built-in shapes, supporting properties like color and borderColor and applying hover and selection effects. Only 'auto' is supported for range series.
   * @expose
   * @name markerShape
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @ojshortdesc The shape of the data markers. In addition to the built-in shapes, it may also take SVG path commands to specify a custom shape. See the Help documentation for more information.
   * @type {string=}
   * @ojvalue {string=} "circle" Data markers will be circular in shape.
   * @ojvalue {string=} "diamond" Data markers will be diamond in shape.
   * @ojvalue {string=} "human" Data markers will be human in shape.
   * @ojvalue {string=} "plus" Data markers will be plus in shape.
   * @ojvalue {string=} "square" Data markers will be square in shape.
   * @ojvalue {string=} "star" Data markers will be star in shape.
   * @ojvalue {string=} "triangleDown"  Data markers will be of a triangular shape facing down.
   * @ojvalue {string=} "triangleUp"  Data markers will be of a triangular shape facing up.
   * @ojvalue {string=} "auto" Data marker shape will be based on chart type.
   * @default "auto"
   */
  /**
   * The size of the data markers in pixels.
   * @expose
   * @name markerSize
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * The color of the line extending from the pie slice to the slice label.
   * @expose
   * @name pieFeelerColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * Specifies the presence and size of the gaps between data items, such as bars, markers, and areas. Valid values are a percentage string from 0% to 100%, where 100% produces the maximum supported gaps.
   * @expose
   * @name dataItemGaps
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @default null
   */
  /**
   * In stock charts, the color of the candlestick when the 'close' value is greater than the 'open' value.
   * @expose
   * @name stockRisingColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * In stock charts, the color of the candlestick when the 'open' value is greater than the 'close' value.
   * @expose
   * @name stockFallingColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * In stock charts, the color of the range bars for candlestick.
   * @expose
   * @name stockRangeColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * In stock charts, the color of the volume bars. If specified, overrides the default rising and falling colors used by the volume bars.
   * @expose
   * @name stockVolumeColor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojformat color
   * @default null
   */
  /**
   * The position of the data label. For range series, if an array of two values is provided, the first and second value will apply to the low and high point respectively. The 'outsideSlice' value only applies to pie charts.
   * The 'aboveMarker', 'belowMarker', 'beforeMarker', and 'afterMarker' values only apply to line, area, scatter, and bubble series. The 'insideBarEdge' and 'outsideBarEdge' values only apply to non-polar bar series. Stacked bars do not support 'outsideBarEdge'.
   * The chart does not currently adjust layout to fit labels within the plot area or deal with any overlaps between labels.
   * @expose
   * @name dataLabelPosition
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @ojshortdesc The position of the data label. For range series, if an array of two values is provided, the first and second value will apply to the low and high point respectively. See the Help documentation for more information.
   * @type {(string|Array.<string>)=}
   * @ojvalue {string} "center" Label will be placed in the center of the data marker.
   * @ojvalue {string} "outsideSlice" Label will be placed outside the chart. Only applies to pie chart.
   * @ojvalue {string} "aboveMarker" Label will be placed above the data marker. Only applies to line, area, scatter, and bubble series.
   * @ojvalue {string} "belowMarker" Label will be placed below the data marker. Only applies to line, area, scatter, and bubble series.
   * @ojvalue {string} "beforeMarker" Label will be placed before the data marker. Only applies to line, area, scatter, and bubble series.
   * @ojvalue {string} "afterMarker" Label will be placed after the data marker. Only applies to line, area, scatter, and bubble series.
   * @ojvalue {string} "insideBarEdge" Label will be placed inside the bar edge. Only applies to non polar bar series.
   * @ojvalue {string} "outsideBarEdge" Label will be placed outside the bar edge. Only applies to non polar bar series.
   * @ojvalue {string} "none" No data label is shown.
   * @ojvalue {string} "auto" For un-stacked bar charts, 'auto' will act as 'insideBarEdge'. For other chart types, 'auto' will act as 'center'.
   * @default "auto"
   */
  /**
   * The CSS style object defining the style of the data label text. For range series, if an array of two values are provided, the first and second value will apply to the low and high point respectively.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @expose
   * @name dataLabelStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the data label. See the Help documentation for more information.
   * @memberof! oj.ojChart.StyleDefaults
   * @type {(Object|Array.<Object>)=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>|Array.<Partial<CSSStyleDeclaration>>", jsdocOverride: true}
   * @default null
   */
  /**
   * Rule for adjusting data label layout. If set to fitInBounds, data label positions will be adjusted if they overlap with the chart's major axes or the legend, or go outside the bounds of the chart's plot area.
   * @expose
   * @name dataLabelCollision
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @ojshortdesc Rule for adjusting data label layout. See the Help documentation for more information.
   * @type {string=}
   * @ojvalue {string} "fitInBounds" Data label positions will be adjusted in order to fit in the plot area.
   * @ojvalue {string} "none" No data label positions will be adjusted to fit in the plot area. Labels may flow outside the plot area.
   * @default "none"
   */
  /**
   * The CSS style object defining the style of the stack label. Only applies to stacked bar charts.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @expose
   * @name stackLabelStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the stack label.
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * Specifies the width of the bar group gap as a ratio of the group width. The valid value is a number from 0 to 1.
   * @expose
   * @name barGapRatio
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojmin 0
   * @ojmax 1
   */
  /**
   * Specifies the maximum width of each bar in pixels.
   * @expose
   * @name maxBarWidth
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojunits pixels
   */
  /**
   * Specifies initial hover delay in milliseconds for highlighting items in chart.
   * @expose
   * @name hoverBehaviorDelay
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {number=}
   * @default null
   * @ojunits milliseconds
   * @ojmin 0
   */
  /**
   * The CSS style object defining the style of the labels in the tooltip.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @expose
   * @name tooltipLabelStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the labels in the tooltip.
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * The CSS style object defining the style of the values in the tooltip.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @expose
   * @name tooltipValueStyle
   * @ojtypedefmember
   * @ojshortdesc The CSS style object defining the style of the values in the tooltip.
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * An object defining the data cursor style.
   * @expose
   * @name dataCursor
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.DataCursorDefaults", jsdocOverride: true}
   */
  /**
   * An object defining the style for hierarchical label separators.
   * @expose
   * @name groupSeparators
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.GroupSeparatorDefaults", jsdocOverride: true}
   */
  /**
   * An object containing the style properties of the box plot items.
   * @expose
   * @name boxPlot
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {Object=}
   * @ojsignature {target: "Type", value: "oj.ojChart.BoxPlotDefaults", jsdocOverride: true}
   */

  /**
   * Defines whether the data label has a contrast outline. When set to 'auto', only the area, line, lineWithArea, scatter and bubble chart series will have data label contrast outline.
   * If applications turn it off they should make sure that the color meets the <a href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast ratio</a> against all possible data label background colors like series colors, plot area background color, or chart background color.
   * @expose
   * @name dataLabelOutline
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "auto" Data label outline will be displayed.
   * @ojvalue {string} "off" Data label outline will not be displayed.
   * @default "auto"
   */

  /**
   * If set to "on", the chart will attempt to reposition labels to reduce visual overlap. If set to "off", labels will remain in their specified data label position and may overlap. Only applies to scatter chart.
   * @expose
   * @name resolveLabelOverlap
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "on" Chart will try to rearrange the labels to reduce visual overlap.
   * @ojvalue {string} "off" Labels will remain in their specified data label position and may overlap.
   * @default "off"
   */

  /**
   * Specifies whether labels will be hidden to avoid overlap. Only applies to scatter chart.
   * @expose
   * @name hideOverlappingLabels
   * @ojtypedefmember
   * @memberof! oj.ojChart.StyleDefaults
   * @type {string=}
   * @ojvalue {string} "on" Chart will hide the overlapped label.
   * @ojvalue {string} "off" Labels might overlap and wont be hidden.
   * @default "off"
   */

  /**
   * Object type that specifies tooltip behavior for the series.
   * @ojtypedef oj.ojChart.SeriesValueFormat
   * @ojimportmembers oj.ojChartTooltipBehaviorProperties
   */
  /**
   * Object type that specifies tooltip behavior for the groups.
   * @ojtypedef oj.ojChart.GroupValueFormat
   */
  /**
   * A string representing the label that is displayed before the value in the tooltip. This value can also take an array of strings to be applied to hierarchical group names, from outermost to innermost.
   * @expose
   * @name tooltipLabel
   * @ojtypedefmember
   * @memberof! oj.ojChart.GroupValueFormat
   * @type {(string|Array.<string>)=}
   * @default null
   * @ojtranslatable
   */
  /**
   * Whether the value is displayed in the tooltip.
   * @expose
   * @name tooltipDisplay
   * @ojtypedefmember
   * @memberof! oj.ojChart.GroupValueFormat
   * @type {string=}
   * @ojvalue {string} "off"  Value will not be displayed in the tooltip.
   * @ojvalue {string} "auto" Value will be displayed in the tooltip.
   * @default "auto"
   */
  /**
   * Object type that specifies the value formatting and tooltip behavior for the x values.
   * @ojtypedef oj.ojChart.CategoricalValueFormat
   * @ojimportmembers oj.ojChartValueFormatsProperties
   * @ojimportmembers oj.ojChartTooltipBehaviorProperties
   * @ojsignature [{target: "Type", value: "?(oj.Converter<T>)", for: "converter", jsdocOverride: true},
   *               {target: "Type", value: "<T extends string|number = string|number>", for: "genericTypeParameters"}]
   */
  /**
   * Object type that specifies the value formatting and tooltip behavior for the y values.
   * @ojtypedef oj.ojChart.NumericValueFormat
   * @ojimportmembers oj.ojChartValueFormatsProperties
   * @ojimportmembers oj.ojChartTooltipBehaviorProperties
   * @ojsignature {target: "Type", value: "?(oj.Converter<number>)", for: "converter", jsdocOverride: true}
   */
  /**
   * Object type that specifies the value formatting for the data item labels.
   * @ojtypedef oj.ojChart.LabelValueFormat
   * @ojimportmembers oj.ojChartValueFormatsProperties
   * @ojsignature {target: "Type", value: "?(oj.Converter<string>)", for: "converter", jsdocOverride: true}
   */

  /**
   * A string representing the label that is displayed before the value in the tooltip. Only applies to scatter chart.
   * @expose
   * @name tooltipLabel
   * @ojtypedefmember
   * @memberof! oj.ojChart.LabelValueFormat
   * @type {(string)=}
   * @default null
   * @ojtranslatable
   */

  /**
   * Whether the label is displayed in the tooltip. Only applies to scatter chart.
   * @expose
   * @name tooltipDisplay
   * @ojtypedefmember
   * @memberof! oj.ojChart.LabelValueFormat
   * @type {string=}
   * @ojvalue {string} "off" Label will not be displayed in the tooltip.
   * @ojvalue {string} "on" Label will be displayed in the tooltip if provided.
   * @default "on"
   */

  /**
   * Object type specifying value formatting and tooltip behavior, whose keys generally correspond to the attribute names on the data items.
   * @ojtypedef oj.ojChart.ValueFormats
   * @property {Object=} series Specifies tooltip behavior for the series.
   * @property {Object=} group Specifies tooltip behavior for the groups.
   * @property {Object=} x Specifies the value formatting and tooltip behavior for the x values.
   * @property {Object=} y Specifies the value formatting and tooltip behavior for the y values.
   * @property {Object=} y2 Specifies the value formatting and tooltip behavior for the y2 values.
   * @property {Object=} z Specifies the value formatting and tooltip behavior for the z values.
   * @property {Object=} value Specifies the value formatting and tooltip behavior for the values.
   * @property {Object=} targetValue Specifies the value formatting and tooltip behavior for the target values of a funnel chart.
   * @property {Object=} low Specifies the value formatting and tooltip behavior for the low values.
   * @property {Object=} high Specifies the value formatting and tooltip behavior for the high values.
   * @property {Object=} open Specifies the value formatting and tooltip behavior for the open values of a stock chart.
   * @property {Object=} close Specifies the value formatting and tooltip behavior for the close values of a stock chart.
   * @property {Object=} volume Specifies the value formatting and tooltip behavior for the volume values of a stock chart.
   * @property {Object=} q1 Specifies the value formatting and tooltip behavior for the q1 values of a box plot.
   * @property {Object=} q2 Specifies the value formatting and tooltip behavior for the q2 values of a box plot.
   * @property {Object=} q3 Specifies the value formatting and tooltip behavior for the q3 values of a box plot.
   * @property {Object=} label Specifies the value formatting for the data item labels.
   * @ojsignature [{target: "Type", value: "oj.ojChart.SeriesValueFormat", for: "series", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.GroupValueFormat", for: "group", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.CategoricalValueFormat", for: "x", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "y", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "y2", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "z", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "value", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "targetValue", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "low", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "high", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "open", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "close", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "volume", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "q1", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "q2", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.NumericValueFormat", for: "q3", jsdocOverride: true},
   *               {target: "Type", value: "oj.ojChart.LabelValueFormat", for: "label", jsdocOverride: true}]
   */

  /**
   * @ojcomponent oj.ojChartGroup
   * @ojshortdesc The oj-chart-group element is used to declare group properties. See the Help documentation for more information.
   * @ojimportmembers oj.ojChartGroupProperties
   * @ojslotcomponent
   * @ojsubcomponenttype data
   * @ojsignature {target: "Type", value:"class ojChartGroup extends JetElement<ojChartGroupSettableProperties>"}
   * @since 5.1.0
   *
   *
   * @classdesc
   * <h3 id="chartGroupOverview-section">
   *   JET Chart Group
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartGroupOverview-section"></a>
   * </h3>
   *
   * <p>The oj-chart-group element is used to declare group properties in the groupTemplate slot of [oj-chart]{@link oj.ojChart#groupTemplate}.</p>
   *
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-chart data="[[dataProvider]]">
   *  &lt;template slot='groupTemplate'>
   *    &lt;oj-chart-group
   *      drilling='on'
   *      label-style='[[$current.depth == 1 ? {"fontWeight":"bold"} : {"fontStyle":"italic"}]]'>
   *    &lt;/oj-chart-group>
   *  &lt;/template>
   * &lt;/oj-chart>
   * </code>
   * </pre>
   */

  /**
   * @ojcomponent oj.ojChartItem
   * @ojshortdesc The oj-chart-item element is used to declare item properties. See the Help documentation for more information.
   * @ojimportmembers oj.ojChartItemProperties
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojChartItem<K=any,  D=any, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null = Array<oj.ojChart.Item<any, null>>|Array<number>|null> extends dvtBaseComponent<ojChartItemSettableProperties<K, D, I>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"},
   *                                    {"name": "D", "description": "Type of data from the dataprovider"},
   *                                     {"name": "I", "description": "Type of nested boxplot items"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojChartItemSettableProperties<K=any, D=any, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null = Array<oj.ojChart.Item<any, null>>|Array<number>|null> extends dvtBaseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @ojslotcomponent
   * @ojsubcomponenttype data
   * @since 5.1.0
   *
   *
   * @classdesc
   * <h3 id="chartItemOverview-section">
   *   JET Chart Item
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartItemOverview-section"></a>
   * </h3>
   *
   * <p>The oj-chart-item element is used to declare item properties in the itemTemplate slot of [oj-chart]{@link oj.ojChart#itemTemplate}.</p>
   *
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-chart data="[[dataProvider]]">
   *  &lt;template slot='itemTemplate'>
   *    &lt;oj-chart-item
   *      value="[[$current.data.value]]"
   *      series-id="[[$current.data.productName]]"
   *      group-id="[[ [$current.data.year] ]]">
   *    &lt;/oj-chart-item>
   *  &lt;/template>
   * &lt;/oj-chart>
   * </code>
   * </pre>
   */

  /**
   * The id for the series the item belongs to.
   * @expose
   * @ojrequired
   * @name seriesId
   * @memberof! oj.ojChartItem
   * @instance
   * @type {string|number}
   *
   */
  /**
   * The array of id(s) for the group(s) the item belongs to. For hierarchical groups, it will be an array of outermost to innermost group ids. This is also used to specify the date for non mixed frequency time axes.
   * The specified date for non mixed frequency time axes must be an ISO string.
   * @expose
   * @ojrequired
   * @name groupId
   * @memberof! oj.ojChartItem
   * @instance
   * @type {Array.<string|number>}
   *
   */
  /**
   * An array of nested data items to be used for defining the markers for outliers or additional data items of a box plot.
   * @expose
   * @name items
   * @memberof! oj.ojChartItem
   * @instance
   * @type {(Array.<Object>|Array.<number>)=}
   * @ojsignature {target: "Type", value: "(Array.<oj.ojChart.Item<any, null>>|Array.<number>)=", jsdocOverride: true}
   *
   */

  /**
   * @ojcomponent oj.ojChartSeries
   * @ojshortdesc The oj-chart-series element is used to declare series properties. See the Help documentation for more information.
   * @ojimportmembers oj.ojChartSeriesProperties
   * @ojslotcomponent
   * @ojsubcomponenttype data
   * @ojsignature {target: "Type", value:"class ojChartSeries extends JetElement<ojChartSeriesSettableProperties>"}
   * @since 5.1.0
   *
   *
   * @classdesc
   * <h3 id="chartSeriesOverview-section">
   *   JET Chart Series
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartSeriesOverview-section"></a>
   * </h3>
   *
   * <p>The oj-chart-series element is used to declare series properties in the seriesTemplate slot of [oj-chart]{@link oj.ojChart#seriesTemplate}.</p>
   *
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-chart data="[[dataProvider]]">
   *  &lt;template slot='seriesTemplate'>
   *    &lt;oj-chart-series
   *      drilling='on'
   *      marker-shape='[[ $current.id == "Series 1" ? "square" : "circle" ]]'>
   *    &lt;/oj-chart-series>
   *  &lt;/template>
   * &lt;/oj-chart>
   * </code>
   * </pre>
   */

  /**
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>The application is responsible for providing a meaningful tooltip using <i>tooltip.renderer</i> function on the element as the oj-spark-chart element does not provide a default tooltip and also ensuring that an accessible label is included that matches the tooltip's content.</p>
   *
   * @ojfragment a11y
   * @memberof oj.ojSparkChart
   */

  /**
   * <p>This element has no touch interaction.  </p>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojSparkChart
   */

  /**
   * <p>This element has no keyboard interaction.  </p>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojSparkChart
   */

  // PROPERTY TYPEDEFS

  /**
   * @typedef {Object} oj.ojSparkChart.Item
   * @property {string=} borderColor The default border color for the data items.
   * @property {string=} color The color of the bar or marker for the data item. This override can be used to highlight important values or thresholds.
   * @property {Date=} date The date for the data item. The date should only be specified if the interval between data items is irregular.
   * @property {number=} high The high value for range bar/area. Define 'low' and 'high' instead of 'value' to create a range bar/area spark chart.
   * @property {number=} low The low value for range bar/area. Define 'low' and 'high' instead of 'value' to create a range bar/area spark chart.
   * @property {("on"|"off")=} markerDisplayed="off" Defines whether a marker should be displayed for the data item. Only applies to line and area spark charts.
   * @property {("square"|"circle"|"diamond"|"plus"|"triangleDown"|"triangleUp"|"human"|"star"|"auto"|string)=} markerShape="auto" The shape of the data markers. Can take the name of a built-in shape or the SVG path commands for a custom shape. Only applies to line and area spark charts.
   * @property {number=} markerSize The size of the data markers in pixels. Only applies to line and area spark charts.
   * @property {string=} svgClassName The CSS style class to apply to the data item. The style class and inline style will override any other styling specified through the properties. For tooltips and hover interactivity, it's recommended to also pass a representative color to the item color attribute.
   * @property {Object=} svgStyle The inline style to apply to the data item. The style class and inline style will override any other styling specified through the properties. For tooltips and hover interactivity, it's recommended to also pass a representative color to the item color attribute. Only SVG CSS style properties are supported.
   * @property {number=} value The value of the data item.
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", for: "svgStyle", jsdocOverride: true}
   * @ojdeprecated {target:"property", for: "svgStyle", since: "18.1.0", description: "The svgStyle property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
   * @ojdeprecated {target:"property", for: "svgClassName", since: "18.1.0", description: "The svgClassName property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
   */

  // Slots

  /**
   * <p> The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for creating each item of the spark chart when a DataProvider has been specified with the data attribute. The slot content must be a &lt;template> element.
   * <p>When the template is executed for each item, it will have access to the spark chart's binding context and the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojSparkChart.ItemTemplateContext]{@link oj.ojSparkChart.ItemTemplateContext} or the table below for a list of properties available on $current) </li>
   * </li>
   * <li>alias - if data-oj-as attribute was specified, the value will be used to provide an application-named alias for $current.
   * </li>
   * </ul>
   *
   * <p>The content of the template should only be one &lt;oj-spark-chart-item> element. See the [oj-spark-chart-item]{@link oj.ojSparkChartItem} doc for more details.</p>
   *
   *
   * @ojslot itemTemplate
   * @ojshortdesc The itemTemplate slot is used to specify the template for creating each item of the spark chart. See the Help documentation for more information.
   * @ojmaxitems 1
   * @memberof oj.ojSparkChart
   * @ojtemplateslotprops oj.ojSparkChart.ItemTemplateContext
   * @ojpreferredcontent ["SparkChartItemElement"]
   *
   * @example <caption>Initialize the spark chart with an inline item template specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='item'>
   *    &lt;oj-spark-chart-item
   *      high='[[$current.data.high]]'
   *      low='[[$current.data.low]]'>
   *    &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */

  /**
   * <p>The <code class="prettyprint">tooltipTemplate</code> slot is used to specify custom tooltip content.
   * This slot takes precedence over the tooltip.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the spark chart. (See [oj.ojSparkChart.TooltipContext]{@link oj.ojSparkChart.TooltipContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot tooltipTemplate
   * @ojshortdesc The tooltipTemplate slot is used to specify custom tooltip content. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojSparkChart.TooltipContext
   * @memberof oj.ojSparkChart
   *
   * @example <caption>Initialize the SparkChart with a tooltip template specified:</caption>
   * &lt;oj-spark-chart>
   *  &lt;template slot="tooltipTemplate">
   *    &lt;span>Custom>&lt;/span><br/>
   *    &lt;span>Tooltip Content&lt;/span>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */

  /**
   * @typedef {Object} oj.ojSparkChart.ReferenceObject
   * @property {string=} color The color of the reference object.
   * @property {number=} high The high value of a reference area.
   * @property {number=} lineWidth The width of a reference line.
   * @property {("dotted"|"dashed"|"solid")=} lineStyle="solid" The line style of a reference line.
   * @property {("front"|"back")=} location="back"  The location of the reference object relative to the data items.
   * @property {number=} low The low value of a reference area.
   * @property {string=} svgClassName The CSS style class to apply to the reference object. The style class and inline style will override any other styling specified through the properties.
   * @property {Object=} svgStyle The inline style to apply to the reference object. The style class and inline style will override any other styling specified through the properties. Only SVG CSS style properties are supported.
   * @property {("area"|"line")=} type="line" The type of reference object being shown.
   * @property {number=} value The value of a reference line.
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", for: "svgStyle", jsdocOverride: true}
   * @ojdeprecated {target:"property", for: "svgStyle", since: "18.1.0", description: "The svgStyle property is deprecated. This deprecation is in support of moving away from technology specific APIs for future Corepack and Preact components." }
   * @ojdeprecated {target:"property", for: "svgClassName", since: "18.1.0", description: "The svgClassName property is deprecated. This deprecation is in support of moving away from technology specific APIs for future Corepack and Preact components." }
   */

  /**
   * @typedef {Object} oj.ojSparkChart.TooltipContext
   * @property {string} color The color of the chart.
   * @property {Element} componentElement The spark chart element.
   * @property {Element} parentElement The tooltip element. The function can directly modify or append content to this element.
   */

  /**
   * @typedef {Object} oj.ojSparkChart.ItemTemplateContext
   * @property {Element} componentElement The &lt;oj-spark-chart> custom element.
   * @property {Object} data The data object for the current item.
   * @property {number} index The zero-based index of the current item.
   * @property {any} key The key of the current item.
   * @ojsignature [{target:"Type", value:"<K = any,D = any>", for:"genericTypeParameters"},
   * {target:"Type", value:"D", for:"data", jsdocOverride: true},
   * {target:"Type", value:"K", for:"key", jsdocOverride: true}]
   */

  // METHOD TYPEDEFS

  /**
   * @typedef {Object} oj.ojSparkChart.ItemContext
   * @property {string} borderColor The border color of the item
   * @property {string} color The color of the item
   * @property {Date} date The date (x value) of the item
   * @property {number} high The high value for a range item
   * @property {number} low The low value for a range item
   * @property {number} value The value of the item
   */

  /**
   * @ojcomponent oj.ojSparkChartItem
   * @ojshortdesc The oj-spark-chart-item element is used to declare properties for spark chart items. See the Help documentation for more information.
   * @ojsignature {target: "Type", value:"class ojSparkChartItem extends JetElement<ojSparkChartItemSettableProperties>"}
   * @ojslotcomponent
   * @ojsubcomponenttype data
   * @since 5.2.0
   *
   *
   * @classdesc
   * <h3 id="sparkChartItemOverview-section">
   *   JET Spark Chart Item
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sparkChartItemOverview-section"></a>
   * </h3>
   *
   * <p>The oj-spark-chart-item element is used to declare properties for spark chart items and is only valid as the
   *  child of a template element for the [itemTemplate]{@link oj.ojSparkChart#itemTemplate} slot of oj-spark-chart.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item  high='[[item.data.high]]' value='[[item.data.total]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   * </code>
   * </pre>
   */
  /**
   * The default border color for the data items.
   * @expose
   * @name borderColor
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @type {string=}
   * @ojformat color
   * @default ''
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">border-color</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item border-color='[[item.data.borderColor]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The color of the bar or marker for the data item. This override can be used to highlight important values or thresholds.
   * @expose
   * @name color
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @type {string=}
   * @ojformat color
   * @default ''
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">color</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item color='[[item.data.color]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The date for the data item. The date should only be specified if the interval between data items is irregular.
   * @expose
   * @name date
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @default ''
   * @type {string=}
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">date</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item date='[[item.data.date]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The high value for range bar/area. Define 'low' and 'high' instead of 'value' to create a range bar/area spark chart.
   * @expose
   * @name high
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @type {(number|null)=}
   * @default null
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">high</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item high='[[item.data.high]]' low='[[item.data.low]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The low value for range bar/area. Define 'low' and 'high' instead of 'value' to create a range bar/area spark chart.
   * @expose
   * @name low
   * @type {(number|null)=}
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @default null
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">low</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item low='[[item.data.low]]' high='[[item.data.high]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * Defines whether a marker should be displayed for the data item. Only applies to line and area spark charts
   * @expose
   * @name markerDisplayed
   * @type {string=}
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @ojvalue {string} "off" Marker will not be displayed.
   * @ojvalue {string} "on" Marker will be displayed.
   * @default "off"
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">marker-displayed</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item marker-displayed='[[item.data.markerDisplayed]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The shape of the data markers. Can take the name of a built-in shape or the SVG path commands for a custom shape. Only applies to line and area spark charts.
   * @expose
   * @name markerShape
   * @ojshortdesc The shape of the data markers. In addition to the built-in shapes, it may also take SVG path commands to specify a custom shape. See the Help documentation for more information.
   * @type {("auto"|"circle"|"diamond"|"human"|"plus"|"square"|"star"|"triangleDown"|"triangleUp"|string)=}
   * @memberof! oj.ojSparkChartItem
   * @instance
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">marker-shape</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item marker-shape='[[item.data.markerShape]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The size of the data markers in pixels. Only applies to line and area spark charts.
   * @expose
   * @name markerSize
   * @type {number=}
   * @memberof! oj.ojSparkChartItem
   * @instance
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">marker-size</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item marker-size='[[item.data.markerSize]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The inline style to apply to the data item. The style class and inline style will override any other styling specified through the properties. For tooltips and hover interactivity, it's recommended to also pass a representative color to the item color attribute.
   * Only SVG CSS style properties are supported.
   * @expose
   * @name svgStyle
   * @ojshortdesc The inline style to apply to the data item. See the Help documentation for more information.
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   * @ojdeprecated {since: "18.1.0", description: "The svgStyle property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate."}
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">svg-style</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item svg-style='[[item.data.svgStyle]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The CSS style class to apply to the data item. The style class and inline style will override any other styling specified through the properties. For tooltips and hover interactivity, it's recommended to also pass a representative color to the item color attribute.
   * @expose
   * @name svgClassName
   * @ojshortdesc The CSS style class to apply to the data item. See the Help documentation for more information.
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @type {string=}
   * @default ''
   * @ojdeprecated {since: "18.1.0", description: "The svgClassName property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">svg-class-name</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item svg-class-name='[[item.data.svgClassName]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */
  /**
   * The value of the data item.
   * @expose
   * @name value
   * @memberof! oj.ojSparkChartItem
   * @instance
   * @type {(number|null)=}
   * @default null
   *
   * @example <caption>Initialize the spark chart item with the
   * <code class="prettyprint">value</code> attribute specified:</caption>
   * &lt;oj-spark-chart data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate' data-oj-as='item'>
   *    &lt;oj-spark-chart-item value='[[item.data.value]]'> &lt;/oj-spark-chart-item>
   *  &lt;/template>
   * &lt;/oj-spark-chart>
   */

var __oj_chart_metadata = 
{
  "properties": {
    "animationOnDataChange": {
      "type": "string",
      "enumValues": [
        "auto",
        "none",
        "slideToLeft",
        "slideToRight"
      ],
      "value": "none"
    },
    "animationOnDisplay": {
      "type": "string",
      "enumValues": [
        "alphaFade",
        "auto",
        "none",
        "zoom"
      ],
      "value": "none"
    },
    "as": {
      "type": "string",
      "value": ""
    },
    "comboSeriesOrder": {
      "type": "string",
      "enumValues": [
        "data",
        "seriesType"
      ],
      "value": "seriesType"
    },
    "coordinateSystem": {
      "type": "string",
      "enumValues": [
        "cartesian",
        "polar"
      ],
      "value": "cartesian"
    },
    "data": {
      "type": "DataProvider",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "unsupported",
              "since": "13.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "dataCursor": {
      "type": "string",
      "enumValues": [
        "auto",
        "off",
        "on"
      ],
      "value": "auto"
    },
    "dataCursorBehavior": {
      "type": "string",
      "enumValues": [
        "auto",
        "smooth",
        "snap"
      ],
      "value": "auto"
    },
    "dataCursorPosition": {
      "type": "object",
      "writeback": true,
      "properties": {
        "x": {
          "type": "number|string"
        },
        "y": {
          "type": "number"
        },
        "y2": {
          "type": "number"
        }
      }
    },
    "dataLabel": {
      "type": "function"
    },
    "dnd": {
      "type": "object",
      "properties": {
        "drag": {
          "type": "object",
          "properties": {
            "groups": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "drag": {
                  "type": "function"
                },
                "dragEnd": {
                  "type": "function"
                },
                "dragStart": {
                  "type": "function"
                }
              }
            },
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "drag": {
                  "type": "function"
                },
                "dragEnd": {
                  "type": "function"
                },
                "dragStart": {
                  "type": "function"
                }
              }
            },
            "series": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "drag": {
                  "type": "function"
                },
                "dragEnd": {
                  "type": "function"
                },
                "dragStart": {
                  "type": "function"
                }
              }
            }
          }
        },
        "drop": {
          "type": "object",
          "properties": {
            "legend": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            },
            "plotArea": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            },
            "xAxis": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            },
            "y2Axis": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            },
            "yAxis": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            }
          }
        }
      }
    },
    "dragMode": {
      "type": "string",
      "enumValues": [
        "off",
        "pan",
        "select",
        "user",
        "zoom"
      ],
      "value": "user"
    },
    "drilling": {
      "type": "string",
      "enumValues": [
        "groupsOnly",
        "off",
        "on",
        "seriesOnly"
      ],
      "value": "off"
    },
    "groupComparator": {
      "type": "function"
    },
    "groups": {
      "type": "Array<string>|Array<Object>|Promise"
    },
    "hiddenCategories": {
      "type": "Array<string>",
      "writeback": true,
      "value": []
    },
    "hideAndShowBehavior": {
      "type": "string",
      "enumValues": [
        "none",
        "withRescale",
        "withoutRescale"
      ],
      "value": "none"
    },
    "highlightMatch": {
      "type": "string",
      "enumValues": [
        "all",
        "any"
      ],
      "value": "all"
    },
    "highlightedCategories": {
      "type": "Array<string>",
      "writeback": true,
      "value": []
    },
    "hoverBehavior": {
      "type": "string",
      "enumValues": [
        "dim",
        "none"
      ],
      "value": "none"
    },
    "initialZooming": {
      "type": "string",
      "enumValues": [
        "first",
        "last",
        "none"
      ],
      "value": "none"
    },
    "legend": {
      "type": "object",
      "properties": {
        "backgroundColor": {
          "type": "string"
        },
        "borderColor": {
          "type": "string"
        },
        "maxSize": {
          "type": "string"
        },
        "position": {
          "type": "string",
          "enumValues": [
            "auto",
            "bottom",
            "end",
            "start",
            "top"
          ],
          "value": "auto"
        },
        "referenceObjectSection": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "titleHalign": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "start"
              ],
              "value": "start"
            },
            "titleStyle": {
              "type": "object",
              "value": {}
            }
          }
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "auto",
            "off",
            "on"
          ],
          "value": "auto"
        },
        "scrolling": {
          "type": "string",
          "enumValues": [
            "asNeeded",
            "off"
          ],
          "value": "asNeeded"
        },
        "sectionTitleHalign": {
          "type": "string",
          "enumValues": [
            "center",
            "end",
            "start"
          ],
          "value": "start"
        },
        "sectionTitleStyle": {
          "type": "object",
          "value": {}
        },
        "sections": {
          "type": "Array<Object>",
          "value": []
        },
        "seriesSection": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "titleHalign": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "start"
              ],
              "value": "start"
            },
            "titleStyle": {
              "type": "object",
              "value": {}
            }
          }
        },
        "size": {
          "type": "string"
        },
        "symbolHeight": {
          "type": "number"
        },
        "symbolWidth": {
          "type": "number"
        },
        "textStyle": {
          "type": "object",
          "value": {}
        },
        "title": {
          "type": "string"
        },
        "titleHalign": {
          "type": "string",
          "enumValues": [
            "center",
            "end",
            "start"
          ]
        },
        "titleStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "multiSeriesDrilling": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "vertical"
    },
    "otherThreshold": {
      "type": "number",
      "value": 0
    },
    "overview": {
      "type": "object",
      "properties": {
        "content": {
          "type": "object",
          "value": {}
        },
        "height": {
          "type": "string"
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "off"
        }
      }
    },
    "pieCenter": {
      "type": "object",
      "properties": {
        "converter": {
          "type": "object"
        },
        "label": {
          "type": "number|string"
        },
        "labelStyle": {
          "type": "object",
          "value": {}
        },
        "renderer": {
          "type": "function"
        },
        "scaling": {
          "type": "string",
          "enumValues": [
            "auto",
            "billion",
            "million",
            "none",
            "quadrillion",
            "thousand",
            "trillion"
          ],
          "value": "auto"
        }
      }
    },
    "plotArea": {
      "type": "object",
      "properties": {
        "backgroundColor": {
          "type": "string"
        },
        "borderColor": {
          "type": "string"
        },
        "borderWidth": {
          "type": "number"
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "on"
        }
      }
    },
    "polarGridShape": {
      "type": "string",
      "enumValues": [
        "circle",
        "polygon"
      ],
      "value": "circle"
    },
    "selection": {
      "type": "Array<any>",
      "writeback": true,
      "value": []
    },
    "selectionMode": {
      "type": "string",
      "enumValues": [
        "multiple",
        "none",
        "single"
      ],
      "value": "none"
    },
    "series": {
      "type": "Array<Object>|Promise"
    },
    "seriesComparator": {
      "type": "function"
    },
    "sorting": {
      "type": "string",
      "enumValues": [
        "ascending",
        "descending",
        "off"
      ],
      "value": "off"
    },
    "splitDualY": {
      "type": "string",
      "enumValues": [
        "auto",
        "off",
        "on"
      ],
      "value": "auto"
    },
    "splitterPosition": {
      "type": "number",
      "value": 0.5
    },
    "stack": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "stackLabel": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "stackLabelProvider": {
      "type": "function"
    },
    "styleDefaults": {
      "type": "object",
      "properties": {
        "animationDownColor": {
          "type": "string"
        },
        "animationDuration": {
          "type": "number"
        },
        "animationIndicators": {
          "type": "string",
          "enumValues": [
            "all",
            "none"
          ],
          "value": "all"
        },
        "animationUpColor": {
          "type": "string"
        },
        "barGapRatio": {
          "type": "number"
        },
        "borderColor": {
          "type": "string"
        },
        "borderWidth": {
          "type": "number"
        },
        "boxPlot": {
          "type": "object",
          "properties": {
            "medianSvgClassName": {
              "type": "string",
              "value": ""
            },
            "medianSvgStyle": {
              "type": "object",
              "value": {}
            },
            "whiskerEndLength": {
              "type": "string"
            },
            "whiskerEndSvgClassName": {
              "type": "string",
              "value": ""
            },
            "whiskerEndSvgStyle": {
              "type": "object",
              "value": {}
            },
            "whiskerSvgClassName": {
              "type": "string",
              "value": ""
            },
            "whiskerSvgStyle": {
              "type": "object",
              "value": {}
            }
          }
        },
        "colors": {
          "type": "Array<string>"
        },
        "dataCursor": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "markerColor": {
              "type": "string"
            },
            "markerDisplayed": {
              "type": "string",
              "enumValues": [
                "off",
                "on"
              ],
              "value": "on"
            },
            "markerSize": {
              "type": "number"
            }
          }
        },
        "dataItemGaps": {
          "type": "string"
        },
        "dataLabelCollision": {
          "type": "string",
          "enumValues": [
            "fitInBounds",
            "none"
          ],
          "value": "none"
        },
        "dataLabelOutline": {
          "type": "string",
          "enumValues": [
            "auto",
            "off"
          ],
          "value": "auto"
        },
        "dataLabelPosition": {
          "type": "string|Array<string>",
          "enumValues": [
            "aboveMarker",
            "afterMarker",
            "auto",
            "beforeMarker",
            "belowMarker",
            "center",
            "insideBarEdge",
            "none",
            "outsideBarEdge",
            "outsideSlice"
          ],
          "value": "auto"
        },
        "dataLabelStyle": {
          "type": "object|Array<Object>"
        },
        "funnelBackgroundColor": {
          "type": "string"
        },
        "groupSeparators": {
          "type": "object",
          "properties": {
            "color": {
              "type": "string"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            }
          }
        },
        "hideOverlappingLabels": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "off"
        },
        "hoverBehaviorDelay": {
          "type": "number"
        },
        "lineStyle": {
          "type": "string",
          "enumValues": [
            "dashed",
            "dotted",
            "solid"
          ],
          "value": "solid"
        },
        "lineType": {
          "type": "string",
          "enumValues": [
            "auto",
            "centeredSegmented",
            "centeredStepped",
            "curved",
            "none",
            "segmented",
            "stepped",
            "straight"
          ],
          "value": "auto"
        },
        "lineWidth": {
          "type": "number"
        },
        "markerColor": {
          "type": "string"
        },
        "markerDisplayed": {
          "type": "string",
          "enumValues": [
            "auto",
            "off",
            "on"
          ],
          "value": "auto"
        },
        "markerShape": {
          "type": "string",
          "value": "auto"
        },
        "markerSize": {
          "type": "number"
        },
        "marqueeBorderColor": {
          "type": "string"
        },
        "marqueeColor": {
          "type": "string"
        },
        "maxBarWidth": {
          "type": "number"
        },
        "otherColor": {
          "type": "string"
        },
        "patterns": {
          "type": "Array<string>"
        },
        "pieFeelerColor": {
          "type": "string"
        },
        "pieInnerRadius": {
          "type": "number",
          "value": 0
        },
        "resolveLabelOverlap": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "off"
        },
        "selectionEffect": {
          "type": "string",
          "enumValues": [
            "explode",
            "highlight",
            "highlightAndExplode"
          ],
          "value": "highlight"
        },
        "seriesEffect": {
          "type": "string",
          "enumValues": [
            "color",
            "gradient",
            "pattern"
          ],
          "value": "color"
        },
        "shapes": {
          "type": "Array<string>"
        },
        "stackLabelStyle": {
          "type": "object",
          "value": {}
        },
        "stockFallingColor": {
          "type": "string"
        },
        "stockRangeColor": {
          "type": "string"
        },
        "stockRisingColor": {
          "type": "string"
        },
        "stockVolumeColor": {
          "type": "string"
        },
        "threeDEffect": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "off"
        },
        "tooltipLabelStyle": {
          "type": "object",
          "value": {}
        },
        "tooltipValueStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "timeAxisType": {
      "type": "string",
      "enumValues": [
        "auto",
        "disabled",
        "enabled",
        "mixedFrequency",
        "skipGaps"
      ],
      "value": "auto"
    },
    "tooltip": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        }
      }
    },
    "touchResponse": {
      "type": "string",
      "enumValues": [
        "auto",
        "touchStart"
      ],
      "value": "auto"
    },
    "trackResize": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "on"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleContainsControls": {
          "type": "string"
        },
        "componentName": {
          "type": "string"
        },
        "labelAndValue": {
          "type": "string"
        },
        "labelClearSelection": {
          "type": "string"
        },
        "labelClose": {
          "type": "string"
        },
        "labelCountWithTotal": {
          "type": "string"
        },
        "labelDataLabel": {
          "type": "string"
        },
        "labelDataVisualization": {
          "type": "string"
        },
        "labelDate": {
          "type": "string"
        },
        "labelDefaultGroupName": {
          "type": "string"
        },
        "labelGroup": {
          "type": "string"
        },
        "labelHigh": {
          "type": "string"
        },
        "labelInvalidData": {
          "type": "string"
        },
        "labelLow": {
          "type": "string"
        },
        "labelNoData": {
          "type": "string"
        },
        "labelOpen": {
          "type": "string"
        },
        "labelOther": {
          "type": "string"
        },
        "labelPercentage": {
          "type": "string"
        },
        "labelQ1": {
          "type": "string"
        },
        "labelQ2": {
          "type": "string"
        },
        "labelQ3": {
          "type": "string"
        },
        "labelSeries": {
          "type": "string"
        },
        "labelTargetValue": {
          "type": "string"
        },
        "labelValue": {
          "type": "string"
        },
        "labelVolume": {
          "type": "string"
        },
        "labelX": {
          "type": "string"
        },
        "labelY": {
          "type": "string"
        },
        "labelZ": {
          "type": "string"
        },
        "stateCollapsed": {
          "type": "string"
        },
        "stateDrillable": {
          "type": "string"
        },
        "stateExpanded": {
          "type": "string"
        },
        "stateHidden": {
          "type": "string"
        },
        "stateIsolated": {
          "type": "string"
        },
        "stateLoaded": {
          "type": "string"
        },
        "stateLoading": {
          "type": "string"
        },
        "stateMaximized": {
          "type": "string"
        },
        "stateMinimized": {
          "type": "string"
        },
        "stateSelected": {
          "type": "string"
        },
        "stateUnselected": {
          "type": "string"
        },
        "stateVisible": {
          "type": "string"
        },
        "tooltipPan": {
          "type": "string"
        },
        "tooltipSelect": {
          "type": "string"
        },
        "tooltipZoom": {
          "type": "string"
        }
      }
    },
    "type": {
      "type": "string",
      "enumValues": [
        "area",
        "bar",
        "boxPlot",
        "bubble",
        "combo",
        "funnel",
        "line",
        "lineWithArea",
        "pie",
        "pyramid",
        "scatter",
        "stock"
      ],
      "value": "bar"
    },
    "valueFormats": {
      "type": "object",
      "properties": {
        "close": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "group": {
          "type": "object",
          "properties": {
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string|Array<string>"
            }
          }
        },
        "high": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "label": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "off",
                "on"
              ],
              "value": "on"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "low": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "open": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "q1": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "q2": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "q3": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "series": {
          "type": "object",
          "properties": {
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "targetValue": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "value": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "volume": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "x": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "y": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "y2": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        },
        "z": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "tooltipDisplay": {
              "type": "string",
              "enumValues": [
                "auto",
                "off"
              ],
              "value": "auto"
            },
            "tooltipLabel": {
              "type": "string"
            }
          }
        }
      }
    },
    "xAxis": {
      "type": "object",
      "properties": {
        "axisLine": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "baselineScaling": {
          "type": "string",
          "enumValues": [
            "min",
            "zero"
          ],
          "value": "zero"
        },
        "dataMax": {
          "type": "number"
        },
        "dataMin": {
          "type": "number"
        },
        "majorTick": {
          "type": "object",
          "properties": {
            "baselineColor": {
              "type": "string",
              "value": "auto"
            },
            "baselineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "baselineWidth": {
              "type": "number"
            },
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "max": {
          "type": "number|string"
        },
        "maxSize": {
          "type": "string"
        },
        "min": {
          "type": "number|string"
        },
        "minStep": {
          "type": "number"
        },
        "minorStep": {
          "type": "number"
        },
        "minorTick": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "referenceObjects": {
          "type": "Array<Object>",
          "value": []
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "on"
        },
        "scale": {
          "type": "string",
          "enumValues": [
            "linear",
            "log"
          ],
          "value": "linear"
        },
        "size": {
          "type": "string"
        },
        "step": {
          "type": "number"
        },
        "tickLabel": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "off",
                "on"
              ],
              "value": "on"
            },
            "rotation": {
              "type": "string",
              "enumValues": [
                "auto",
                "none"
              ],
              "value": "auto"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "style": {
              "type": "object",
              "value": {}
            }
          }
        },
        "title": {
          "type": "string"
        },
        "titleStyle": {
          "type": "object",
          "value": {}
        },
        "viewportEndGroup": {
          "type": "number|string"
        },
        "viewportMax": {
          "type": "number|string"
        },
        "viewportMin": {
          "type": "number|string"
        },
        "viewportStartGroup": {
          "type": "number|string"
        }
      }
    },
    "y2Axis": {
      "type": "object",
      "properties": {
        "alignTickMarks": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "on"
        },
        "axisLine": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "baselineScaling": {
          "type": "string",
          "enumValues": [
            "min",
            "zero"
          ],
          "value": "zero"
        },
        "dataMax": {
          "type": "number"
        },
        "dataMin": {
          "type": "number"
        },
        "majorTick": {
          "type": "object",
          "properties": {
            "baselineColor": {
              "type": "string",
              "value": "auto"
            },
            "baselineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "baselineWidth": {
              "type": "number"
            },
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "max": {
          "type": "number"
        },
        "maxSize": {
          "type": "string"
        },
        "min": {
          "type": "number"
        },
        "minStep": {
          "type": "number"
        },
        "minorStep": {
          "type": "number"
        },
        "minorTick": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "position": {
          "type": "string",
          "enumValues": [
            "auto",
            "bottom",
            "end",
            "start",
            "top"
          ],
          "value": "auto"
        },
        "referenceObjects": {
          "type": "Array<Object>",
          "value": []
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "on"
        },
        "scale": {
          "type": "string",
          "enumValues": [
            "linear",
            "log"
          ],
          "value": "linear"
        },
        "size": {
          "type": "string"
        },
        "step": {
          "type": "number"
        },
        "tickLabel": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "position": {
              "type": "string",
              "enumValues": [
                "inside",
                "outside"
              ],
              "value": "outside"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "off",
                "on"
              ],
              "value": "on"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "style": {
              "type": "object",
              "value": {}
            }
          }
        },
        "title": {
          "type": "string"
        },
        "titleStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "yAxis": {
      "type": "object",
      "properties": {
        "axisLine": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "baselineScaling": {
          "type": "string",
          "enumValues": [
            "min",
            "zero"
          ],
          "value": "zero"
        },
        "dataMax": {
          "type": "number"
        },
        "dataMin": {
          "type": "number"
        },
        "majorTick": {
          "type": "object",
          "properties": {
            "baselineColor": {
              "type": "string",
              "value": "auto"
            },
            "baselineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "baselineWidth": {
              "type": "number"
            },
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "max": {
          "type": "number"
        },
        "maxSize": {
          "type": "string"
        },
        "min": {
          "type": "number"
        },
        "minStep": {
          "type": "number"
        },
        "minorStep": {
          "type": "number"
        },
        "minorTick": {
          "type": "object",
          "properties": {
            "lineColor": {
              "type": "string"
            },
            "lineStyle": {
              "type": "string",
              "enumValues": [
                "dashed",
                "dotted",
                "solid"
              ],
              "value": "solid"
            },
            "lineWidth": {
              "type": "number"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "auto",
                "off",
                "on"
              ],
              "value": "auto"
            }
          }
        },
        "position": {
          "type": "string",
          "enumValues": [
            "auto",
            "bottom",
            "end",
            "start",
            "top"
          ],
          "value": "auto"
        },
        "referenceObjects": {
          "type": "Array<Object>",
          "value": []
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "on"
        },
        "scale": {
          "type": "string",
          "enumValues": [
            "linear",
            "log"
          ],
          "value": "linear"
        },
        "size": {
          "type": "string"
        },
        "step": {
          "type": "number"
        },
        "tickLabel": {
          "type": "object",
          "properties": {
            "converter": {
              "type": "object"
            },
            "position": {
              "type": "string",
              "enumValues": [
                "inside",
                "outside"
              ],
              "value": "outside"
            },
            "rendered": {
              "type": "string",
              "enumValues": [
                "off",
                "on"
              ],
              "value": "on"
            },
            "scaling": {
              "type": "string",
              "enumValues": [
                "auto",
                "billion",
                "million",
                "none",
                "quadrillion",
                "thousand",
                "trillion"
              ],
              "value": "auto"
            },
            "style": {
              "type": "object",
              "value": {}
            }
          }
        },
        "title": {
          "type": "string"
        },
        "titleStyle": {
          "type": "object",
          "value": {}
        },
        "viewportMax": {
          "type": "number"
        },
        "viewportMin": {
          "type": "number"
        }
      }
    },
    "zoomAndScroll": {
      "type": "string",
      "enumValues": [
        "delayed",
        "delayedScrollOnly",
        "live",
        "liveScrollOnly",
        "off"
      ],
      "value": "off"
    },
    "zoomDirection": {
      "type": "string",
      "enumValues": [
        "auto",
        "x",
        "y"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getAutomation": {},
    "getContextByNode": {},
    "getDataItem": {},
    "getGroup": {},
    "getGroupCount": {},
    "getLegend": {},
    "getPlotArea": {},
    "getProperty": {},
    "getSeries": {},
    "getSeriesCount": {},
    "getValuesAt": {},
    "getXAxis": {},
    "getY2Axis": {},
    "getYAxis": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojDrill": {},
    "ojGroupDrill": {},
    "ojItemDrill": {},
    "ojMultiSeriesDrill": {},
    "ojSelectInput": {},
    "ojSeriesDrill": {},
    "ojViewportChange": {},
    "ojViewportChangeInput": {}
  },
  "extension": {}
};
  /* global __oj_chart_metadata */
  (function () {
    __oj_chart_metadata.extension._WIDGET_NAME = 'ojChart';
    var _CHART_SHAPE_ENUMS = {
      square: true,
      circle: true,
      diamond: true,
      plus: true,
      triangleDown: true,
      triangleUp: true,
      human: true,
      star: true,
      auto: true
    };
    var chartShapeParser = DvtAttributeUtils.shapeParseFunction(
      { 'style-defaults.marker-shape': true },
      _CHART_SHAPE_ENUMS
    );
    var chartParseFunction = function (value, name, metadata, defaultParseFunction) {
      if (metadata.type === 'number|string') {
        return isNaN(value) ? value : Number(value);
      } else if (name === 'style-defaults.data-label-style') {
        return JSON.parse(value);
      }
      return chartShapeParser(value, name, metadata, defaultParseFunction);
    };
    oj.CustomElementBridge.register('oj-chart', {
      metadata: __oj_chart_metadata,
      parseFunction: chartParseFunction
    });
  })();

var __oj_chart_item_metadata = 
{
  "properties": {
    "borderColor": {
      "type": "string"
    },
    "borderWidth": {
      "type": "number"
    },
    "boxPlot": {
      "type": "object",
      "properties": {
        "medianSvgClassName": {
          "type": "string"
        },
        "medianSvgStyle": {
          "type": "object"
        },
        "q2Color": {
          "type": "string"
        },
        "q2SvgClassName": {
          "type": "string"
        },
        "q2SvgStyle": {
          "type": "object"
        },
        "q3Color": {
          "type": "string"
        },
        "q3SvgClassName": {
          "type": "string"
        },
        "q3SvgStyle": {
          "type": "object"
        },
        "whiskerEndLength": {
          "type": "string"
        },
        "whiskerEndSvgClassName": {
          "type": "string"
        },
        "whiskerEndSvgStyle": {
          "type": "object"
        },
        "whiskerSvgClassName": {
          "type": "string"
        },
        "whiskerSvgStyle": {
          "type": "object"
        }
      }
    },
    "categories": {
      "type": "Array<string>"
    },
    "close": {
      "type": "number"
    },
    "color": {
      "type": "string"
    },
    "drilling": {
      "type": "string",
      "enumValues": [
        "inherit",
        "off",
        "on"
      ],
      "value": "inherit"
    },
    "groupId": {
      "type": "Array<(string|number)>"
    },
    "high": {
      "type": "number"
    },
    "items": {
      "type": "Array<Object>|Array<number>"
    },
    "label": {
      "type": "string|Array<string>"
    },
    "labelPosition": {
      "type": "string|Array<string>",
      "enumValues": [
        "aboveMarker",
        "afterMarker",
        "auto",
        "beforeMarker",
        "belowMarker",
        "center",
        "insideBarEdge",
        "none",
        "outsideBarEdge",
        "outsideSlice"
      ]
    },
    "labelStyle": {
      "type": "object|Array<Object>"
    },
    "low": {
      "type": "number"
    },
    "markerDisplayed": {
      "type": "string",
      "enumValues": [
        "auto",
        "off",
        "on"
      ]
    },
    "markerShape": {
      "type": "string"
    },
    "markerSize": {
      "type": "number"
    },
    "open": {
      "type": "number"
    },
    "pattern": {
      "type": "string",
      "enumValues": [
        "auto",
        "largeChecker",
        "largeCrosshatch",
        "largeDiagonalLeft",
        "largeDiagonalRight",
        "largeDiamond",
        "largeTriangle",
        "smallChecker",
        "smallCrosshatch",
        "smallDiagonalLeft",
        "smallDiagonalRight",
        "smallDiamond",
        "smallTriangle"
      ],
      "value": "auto"
    },
    "q1": {
      "type": "number"
    },
    "q2": {
      "type": "number"
    },
    "q3": {
      "type": "number"
    },
    "seriesId": {
      "type": "string|number"
    },
    "shortDesc": {
      "type": "string|function"
    },
    "source": {
      "type": "string"
    },
    "sourceHover": {
      "type": "string"
    },
    "sourceHoverSelected": {
      "type": "string"
    },
    "sourceSelected": {
      "type": "string"
    },
    "svgClassName": {
      "type": "string"
    },
    "svgStyle": {
      "type": "object"
    },
    "targetValue": {
      "type": "number"
    },
    "value": {
      "type": "number"
    },
    "volume": {
      "type": "number"
    },
    "x": {
      "type": "number|string"
    },
    "y": {
      "type": "number"
    },
    "z": {
      "type": "number"
    }
  },
  "extension": {}
};
  /* global __oj_chart_item_metadata */
  (function () {
    __oj_chart_item_metadata.extension._CONSTRUCTOR = function () {};
    var _CHART_ITEM_SHAPE_ENUMS = {
      square: true,
      circle: true,
      diamond: true,
      plus: true,
      triangleDown: true,
      triangleUp: true,
      human: true,
      star: true,
      auto: true
    };
    oj.CustomElementBridge.register('oj-chart-item', {
      metadata: __oj_chart_item_metadata,
      parseFunction: DvtAttributeUtils.shapeParseFunction(
        { 'marker-shape': true },
        _CHART_ITEM_SHAPE_ENUMS
      )
    });
  })();

var __oj_chart_series_metadata = 
{
  "properties": {
    "areaColor": {
      "type": "string"
    },
    "areaSvgClassName": {
      "type": "string"
    },
    "areaSvgStyle": {
      "type": "object"
    },
    "assignedToY2": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "borderColor": {
      "type": "string"
    },
    "borderWidth": {
      "type": "number"
    },
    "boxPlot": {
      "type": "object",
      "properties": {
        "medianSvgClassName": {
          "type": "string"
        },
        "medianSvgStyle": {
          "type": "object"
        },
        "q2Color": {
          "type": "string"
        },
        "q2SvgClassName": {
          "type": "string"
        },
        "q2SvgStyle": {
          "type": "object"
        },
        "q3Color": {
          "type": "string"
        },
        "q3SvgClassName": {
          "type": "string"
        },
        "q3SvgStyle": {
          "type": "object"
        },
        "whiskerEndLength": {
          "type": "string"
        },
        "whiskerEndSvgClassName": {
          "type": "string"
        },
        "whiskerEndSvgStyle": {
          "type": "object"
        },
        "whiskerSvgClassName": {
          "type": "string"
        },
        "whiskerSvgStyle": {
          "type": "object"
        }
      }
    },
    "categories": {
      "type": "Array<string>"
    },
    "color": {
      "type": "string"
    },
    "displayInLegend": {
      "type": "string",
      "enumValues": [
        "auto",
        "off",
        "on"
      ],
      "value": "auto"
    },
    "drilling": {
      "type": "string",
      "enumValues": [
        "inherit",
        "off",
        "on"
      ],
      "value": "inherit"
    },
    "lineStyle": {
      "type": "string",
      "enumValues": [
        "dashed",
        "dotted",
        "solid"
      ]
    },
    "lineType": {
      "type": "string",
      "enumValues": [
        "auto",
        "centeredSegmented",
        "centeredStepped",
        "curved",
        "none",
        "segmented",
        "stepped",
        "straight"
      ]
    },
    "lineWidth": {
      "type": "number"
    },
    "markerColor": {
      "type": "string"
    },
    "markerDisplayed": {
      "type": "string",
      "enumValues": [
        "auto",
        "off",
        "on"
      ]
    },
    "markerShape": {
      "type": "string"
    },
    "markerSize": {
      "type": "number"
    },
    "markerSvgClassName": {
      "type": "string"
    },
    "markerSvgStyle": {
      "type": "object"
    },
    "name": {
      "type": "string"
    },
    "pattern": {
      "type": "string",
      "enumValues": [
        "auto",
        "largeChecker",
        "largeCrosshatch",
        "largeDiagonalLeft",
        "largeDiagonalRight",
        "largeDiamond",
        "largeTriangle",
        "smallChecker",
        "smallCrosshatch",
        "smallDiagonalLeft",
        "smallDiagonalRight",
        "smallDiamond",
        "smallTriangle"
      ],
      "value": "auto"
    },
    "pieSliceExplode": {
      "type": "number",
      "value": 0
    },
    "shortDesc": {
      "type": "string"
    },
    "source": {
      "type": "string"
    },
    "sourceHover": {
      "type": "string"
    },
    "sourceHoverSelected": {
      "type": "string"
    },
    "sourceSelected": {
      "type": "string"
    },
    "stackCategory": {
      "type": "string"
    },
    "svgClassName": {
      "type": "string"
    },
    "svgStyle": {
      "type": "object"
    },
    "type": {
      "type": "string",
      "enumValues": [
        "area",
        "auto",
        "bar",
        "boxPlot",
        "candlestick",
        "line",
        "lineWithArea"
      ],
      "value": "auto"
    }
  },
  "extension": {}
};
  /* global __oj_chart_series_metadata */
  (function () {
    __oj_chart_series_metadata.extension._CONSTRUCTOR = function () {};
    var _CHART_SERIES_SHAPE_ENUMS = {
      square: true,
      circle: true,
      diamond: true,
      plus: true,
      triangleDown: true,
      triangleUp: true,
      human: true,
      star: true,
      auto: true
    };
    oj.CustomElementBridge.register('oj-chart-series', {
      metadata: __oj_chart_series_metadata,
      parseFunction: DvtAttributeUtils.shapeParseFunction(
        { 'marker-shape': true },
        _CHART_SERIES_SHAPE_ENUMS
      )
    });
  })();

var __oj_chart_group_metadata = 
{
  "properties": {
    "drilling": {
      "type": "string",
      "enumValues": [
        "inherit",
        "off",
        "on"
      ],
      "value": "inherit"
    },
    "labelStyle": {
      "type": "object"
    },
    "name": {
      "type": "string"
    },
    "shortDesc": {
      "type": "string"
    }
  },
  "extension": {}
};
  /* global __oj_chart_group_metadata */
  (function () {
    __oj_chart_group_metadata.extension._CONSTRUCTOR = function () {};
    oj.CustomElementBridge.register('oj-chart-group', {
      metadata: __oj_chart_group_metadata
    });
  })();

var __oj_spark_chart_metadata = 
{
  "properties": {
    "animationDuration": {
      "type": "number"
    },
    "animationOnDataChange": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "none"
    },
    "animationOnDisplay": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "none"
    },
    "areaColor": {
      "type": "string",
      "value": ""
    },
    "areaSvgClassName": {
      "type": "string",
      "value": ""
    },
    "areaSvgStyle": {
      "type": "object",
      "value": {}
    },
    "as": {
      "type": "string",
      "value": ""
    },
    "barGapRatio": {
      "type": "number",
      "value": 0.25
    },
    "baselineScaling": {
      "type": "string",
      "enumValues": [
        "min",
        "zero"
      ],
      "value": "min"
    },
    "color": {
      "type": "string"
    },
    "data": {
      "type": "DataProvider",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "unsupported",
              "since": "13.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "firstColor": {
      "type": "string",
      "value": ""
    },
    "highColor": {
      "type": "string",
      "value": ""
    },
    "items": {
      "type": "Array<Object>|Array<number>|Promise"
    },
    "lastColor": {
      "type": "string",
      "value": ""
    },
    "lineStyle": {
      "type": "string",
      "enumValues": [
        "dashed",
        "dotted",
        "solid"
      ],
      "value": "solid"
    },
    "lineType": {
      "type": "string",
      "enumValues": [
        "centeredSegmented",
        "centeredStepped",
        "curved",
        "none",
        "segmented",
        "stepped",
        "straight"
      ],
      "value": "straight"
    },
    "lineWidth": {
      "type": "number",
      "value": 1
    },
    "lowColor": {
      "type": "string",
      "value": ""
    },
    "markerShape": {
      "type": "string",
      "value": "auto"
    },
    "markerSize": {
      "type": "number",
      "value": 5
    },
    "referenceObjects": {
      "type": "Array<Object>",
      "value": []
    },
    "svgClassName": {
      "type": "string",
      "value": ""
    },
    "svgStyle": {
      "type": "object",
      "value": {}
    },
    "tooltip": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        }
      }
    },
    "trackResize": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "on"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleContainsControls": {
          "type": "string"
        },
        "componentName": {
          "type": "string"
        },
        "labelAndValue": {
          "type": "string"
        },
        "labelClearSelection": {
          "type": "string"
        },
        "labelCountWithTotal": {
          "type": "string"
        },
        "labelDataVisualization": {
          "type": "string"
        },
        "labelInvalidData": {
          "type": "string"
        },
        "labelNoData": {
          "type": "string"
        },
        "stateCollapsed": {
          "type": "string"
        },
        "stateDrillable": {
          "type": "string"
        },
        "stateExpanded": {
          "type": "string"
        },
        "stateHidden": {
          "type": "string"
        },
        "stateIsolated": {
          "type": "string"
        },
        "stateMaximized": {
          "type": "string"
        },
        "stateMinimized": {
          "type": "string"
        },
        "stateSelected": {
          "type": "string"
        },
        "stateUnselected": {
          "type": "string"
        },
        "stateVisible": {
          "type": "string"
        }
      }
    },
    "type": {
      "type": "string",
      "enumValues": [
        "area",
        "bar",
        "line",
        "lineWithArea"
      ],
      "value": "line"
    },
    "visualEffects": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getDataItem": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_spark_chart_metadata */
  (function () {
    __oj_spark_chart_metadata.extension._WIDGET_NAME = 'ojSparkChart';
    var _SPARK_SHAPE_ENUMS = {
      square: true,
      circle: true,
      diamond: true,
      plus: true,
      triangleDown: true,
      triangleUp: true,
      human: true,
      star: true,
      auto: true
    };
    oj.CustomElementBridge.register('oj-spark-chart', {
      metadata: __oj_spark_chart_metadata,
      parseFunction: DvtAttributeUtils.shapeParseFunction(
        { 'marker-shape': true },
        _SPARK_SHAPE_ENUMS
      )
    });
  })();

var __oj_spark_chart_item_metadata = 
{
  "properties": {
    "borderColor": {
      "type": "string",
      "value": ""
    },
    "color": {
      "type": "string",
      "value": ""
    },
    "date": {
      "type": "string",
      "value": ""
    },
    "high": {
      "type": "number"
    },
    "low": {
      "type": "number"
    },
    "markerDisplayed": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "markerShape": {
      "type": "string"
    },
    "markerSize": {
      "type": "number"
    },
    "svgClassName": {
      "type": "string",
      "value": ""
    },
    "svgStyle": {
      "type": "object",
      "value": {}
    },
    "value": {
      "type": "number"
    }
  },
  "extension": {}
};
  /* global __oj_spark_chart_item_metadata */
  (function () {
    __oj_spark_chart_item_metadata.extension._CONSTRUCTOR = function () {};
    oj.CustomElementBridge.register('oj-spark-chart-item', {
      metadata: __oj_spark_chart_item_metadata
    });
  })();

  /**
   * @ignore
   * @param {*} component
   * @param {*} templateEngine
   * @param {*} items
   * @param {*} dataProperty
   */
  const createGroupsAndSeries = (component, templateEngine, items, dataProperty) => {
    const parentElement = component.element[0];
    const templateHandler = component._TemplateHandler;
    const templates = templateHandler.getTemplates();
    const seriesTemplate = templates.seriesTemplate ? templates.seriesTemplate[0] : null;
    const groupTemplate = templates.groupTemplate ? templates.groupTemplate[0] : null;
    const seriesComparator = component.options.seriesComparator;
    const groupComparator = component.options.groupComparator;

    // Hierarchical Map of the group tree containing unique Symbols for each group
    const groupMap = new Map();
    // Map for each group Symbol containing indices of belonging items
    // Only populated if groupTemplate or groupComparator is specified
    const groupItemMap = groupTemplate || groupComparator ? new Map() : null;
    // 2-D map keyed by seriesId, groupSymbol containing item indices
    const seriesMap = new Map();

    const addGroup = (groupId) => {
      let currentMap = groupMap;
      const symbols = [];
      for (let i = 0; i < groupId.length; i++) {
        const gid = groupId[i];
        let group = currentMap.get(gid);
        if (!group) {
          // gid isn't necessarily globally unique, but still helpful for debugging
          group = { value: Symbol(gid) };
          if (i !== groupId.length - 1) {
            group.groups = new Map();
          }
          currentMap.set(gid, group);
        }
        symbols.push(group.value);
        currentMap = group.groups;
      }
      return symbols;
    };

    const addItemIfUnique = (seriesId, groupSymbols, itemIndex) => {
      let itemMap = seriesMap.get(seriesId);
      if (!itemMap) {
        itemMap = new Map();
        seriesMap.set(seriesId, itemMap);
      }
      const leafSymbol = groupSymbols[groupSymbols.length - 1];
      if (itemMap.get(leafSymbol) === undefined) {
        itemMap.set(leafSymbol, itemIndex);
        // add the itemIndex to all groups if the groupItemMap was passed
        if (groupItemMap) {
          groupSymbols.forEach((groupSymbol) => {
            let groupItems = groupItemMap.get(groupSymbol);
            if (!groupItems) {
              groupItems = [];
              groupItemMap.set(groupSymbol, groupItems);
            }
            groupItems.push(itemIndex);
          });
        }
      }
    };

    const processItems = () => {
      items.forEach((item, index) => {
        const groupSymbols = addGroup(item.groupId);
        addItemIfUnique(item.seriesId, groupSymbols, index);
      });
    };

    const createGroupContext = (groupSymbol, groupIds, index, leaf) => {
      const context = {
        ids: groupIds,
        componentElement: parentElement,
        depth: groupIds.length,
        leaf: leaf,
        index: index
      };
      Object.defineProperty(context, 'items', {
        get: () => {
          return groupItemMap.get(groupSymbol).map((itemIndex) => {
            const item = items[itemIndex];
            return {
              data: item._itemData,
              key: item.id,
              index: itemIndex
            };
          });
        }
      });
      return context;
    };

    const createGroupLevel = (mapLevel, prefix) => {
      const gids = [...mapLevel.keys()];
      const groupContexts = new Map();
      const groups = gids.map((gid, index) => {
        let group;
        const value = mapLevel.get(gid);
        const groupSymbol = value.value;
        const subGroups = value.groups;
        let groupContext;
        if (groupTemplate || groupComparator) {
          groupContext = createGroupContext(groupSymbol, [...prefix, gid], index, !subGroups);
          groupContexts.set(gid, groupContext);
        }
        if (groupTemplate) {
          group = templateHandler.processNodeTemplate(
            dataProperty,
            templateEngine,
            groupTemplate,
            'oj-chart-group',
            groupContext,
            groupSymbol
          );
        } else {
          group = {};
        }
        group.id = gid;
        group.name = group.name == null ? gid : group.name;
        if (subGroups) {
          group.groups = createGroupLevel(subGroups, [...prefix, gid]);
        } else {
          Object.defineProperty(group, 'symbol', {
            value: groupSymbol,
            enumerable: false
          });
        }
        return group;
      });
      if (groupComparator) {
        groups.sort((a, b) => groupComparator(groupContexts.get(a.id), groupContexts.get(b.id)));
      }
      return groups;
    };

    const createGroups = () => {
      try {
        return createGroupLevel(groupMap, []);
      } catch (error) {
        Logger.error(error);
        return [];
      }
    };

    const createSeriesContext = (seriesId, index, groupSymbols, itemMap) => {
      const context = {
        componentElement: parentElement,
        id: seriesId,
        index: index
      };
      Object.defineProperty(context, 'items', {
        get: () => {
          const itemContexts = [];
          groupSymbols.forEach((symbol) => {
            const itemIndex = itemMap.get(symbol);
            if (itemIndex != null) {
              const item = items[itemIndex];
              itemContexts.push({
                data: item._itemData,
                key: item.id,
                index: itemIndex
              });
            }
            return undefined;
          });
          return itemContexts;
        }
      });
      return context;
    };

    const getGroupSymbols = (groups) => {
      const symbols = [];
      groups.forEach((group) => {
        if (group.groups) {
          symbols.push(...getGroupSymbols(group.groups));
        } else {
          symbols.push(group.symbol);
        }
      });
      return symbols;
    };

    const createSeries = (groups) => {
      let arSeries;
      try {
        const seriesContexts = new Map();
        const groupSymbols = getGroupSymbols(groups);
        const sids = [...seriesMap.keys()];
        arSeries = sids.map((sid, index) => {
          const itemMap = seriesMap.get(sid);
          let seriesContext;
          if (seriesTemplate || seriesComparator) {
            seriesContext = createSeriesContext(sid, index, groupSymbols, itemMap);
            seriesContexts.set(sid, seriesContext);
          }
          let series;
          if (seriesTemplate) {
            series = templateHandler.processNodeTemplate(
              dataProperty,
              templateEngine,
              seriesTemplate,
              'oj-chart-series',
              seriesContext,
              sid
            );
          } else {
            series = {};
          }
          series.id = sid;
          series.name = series.name == null ? String(sid) : series.name;
          series.items = groupSymbols.map((symbol) => {
            let item = null;
            const itemIndex = itemMap.get(symbol);
            if (itemIndex != null) {
              item = items[itemIndex];
            }
            return item;
          });
          return series;
        });
        if (seriesComparator) {
          arSeries.sort((a, b) =>
            seriesComparator(seriesContexts.get(a.id), seriesContexts.get(b.id))
          );
        }
      } catch (error) {
        Logger.error(error);
        arSeries = [];
      }
      return arSeries;
    };

    processItems();
    const groups = createGroups();
    const series = createSeries(groups);

    return { groups, series };
  };

  /**
   * @ojcomponent oj.ojChart
   * @ojimportmembers oj.ojSharedContextMenu
   * @augments oj.dvtBaseComponent
   * @since 0.7.0
   *
   * @ojshortdesc A chart displays information graphically, making relationships among the data easier to understand.
   * @ojrole application
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
   * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojChart<K,  D extends oj.ojChart.DataItem<I>|any, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null, C extends ojChart<K, D, I, null>|null> extends dvtBaseComponent<ojChartSettableProperties<K, D, I, C>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}, {"name": "I", "description": "Type of nested boxplot items"}, {"name": "C", "description": "Type of chart for overview property"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojChartSettableProperties<K, D extends oj.ojChart.DataItem<I>|any, I extends Array<oj.ojChart.Item<any, null>>|Array<number>|null, C extends ojChart<K, D, I, null>|null> extends dvtBaseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["type", "orientation", "legend.title", "legend.position", "legend.rendered",
   *                                                     "styleDefaults.lineType", "styleDefaults.markerDisplayed", "styleDefaults.markerShape", "styleDefaults.threeDEffect",
   *                                                     "stack", "pieCenter.label", "xAxis.title", "yAxis.title", "animationOnDataChange", "animationOnDisplay",
   *                                                     "styleDefaults.pieInnerRadius", "coordinateSystem", "style"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-chart'
   * @ojuxspecs ['dvtChart_BarLineAreaCombo', 'range-chart', 'pie-chart', 'polar-chart', 'funnel-chart', 'pyramid-chart', 'stock-chart', 'data-visualization-common']
   *
   * @classdesc
   * <h3 id="chartOverview-section">
   *   JET Chart
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartOverview-section"></a>
   * </h3>
   *
   * <p>JET Chart with support for bar, line, area, combination, pie, scatter, bubble, funnel, box plot, and stock
   * chart types.</p>
   *
   * {@ojinclude "name":"warning"}
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-chart
   *   type='bar'
   *   data='[[dataProvider]]'
   * >
   * &lt;/oj-chart>
   * </code>
   * </pre>
   *
   * {@ojinclude "name":"a11yKeyboard"}
   *
   * <p>
   * If style-defaults.data-label-outline is set to 'off', the application is also responsible for ensuring that the data label color meets the <a href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast ratio</a> against all possible data label background colors like series colors, plot area background color, or chart background color.
   * </p>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * {@ojinclude "name":"migrationDoc"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Animation</h4>
   * <p>Animation should only be enabled for visualizations of small to medium data sets. When animating changes to larger
   *    data sets or when animating between data sets, it's recommended to turn off the
   *    <code class="prettyprint">styleDefaults.animationIndicators</code>, since they effectively double the amount of
   *    work required for the animation.
   * </p>
   *
   * <h4>Data Set Size</h4>
   * <p>As a rule of thumb, it's recommended that applications only set usable data densities on the chart. For example,
   *    it's not recommended to show more than 500 bars on a 500 pixel wide chart, since the  bars will be unusably thin.
   *    While there are several optimizations within the chart to deal with large data sets, it's always more efficient to
   *    reduce the data set size as early as possible. Future optimizations will focus on improving end user experience as
   *    well as developer productivity for common use cases.
   * </p>
   *
   * <h4>Styling</h4>
   * <p>Use the highest level property available. For example, consider setting styling properties on
   *    <code class="prettyprint">styleDefaults</code> or <code class="prettyprint">series</code>, instead of styling properties
   *    on the individual data items. The chart can take advantage of these higher level properties to apply the style properties on
   *    containers, saving expensive DOM calls.
   * </p>
   *
   * {@ojinclude "name":"fragment_trackResize"}
   *
   * {@ojinclude "name":"rtl"}
   */
  oj.__registerWidget('oj.ojChart', $.oj.dvtBaseComponent, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * An object defining the series and groups, when using a DataProvider to provide data to the chart.
       * The DataProvider can either have an arbitrary data shape, in which case an <oj-chart-item>
       * element must be specified in the itemTemplate slot or it can have <a href="#DataItem">ojChart.DataItem</a>
       * as its data shape, in which case no template is required.
       *
       * A progressive loading indicator is shown by the component when the data provider fetch takes longer than a certain time.
       * @name data
       * @memberof oj.ojChart
       * @ojshortdesc An object defining the series and groups, when using a DataProvider to populate the chart data. Also accepts a Promise for deferred data rendering.
       * @instance
       * @type {DataProvider|null}
       * @ojsignature {target: "Type", value: "DataProvider<K, D>|null", jsdocOverride:true}
       * @default null
       * @ojwebelementstatus {type: "unsupported", since: "13.0.0",
       *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
       */
      data: null,

      /**
       * An array of <a href="#Series">Series</a> objects, used to define series labels and override series styles.
       * Only a single series is supported for stock charts. Also accepts a Promise for deferred data rendering.
       * @expose
       * @ojtsignore
       * @name series
       * @memberof oj.ojChart
       * @ojshortdesc An array of objects defining series labels and override series styles. See the Help documentation for more information.
       * @instance
       * @type {Array.<Object>|Promise|null}
       * @ojsignature {target: "Type", value: "Array<oj.ojChart.Series>|Promise<Array<oj.ojChart.Series>>|null", jsdocOverride: true}
       * @default null
       */
      series: null,

      /**
       * An array of strings identifying the group labels, or an array of <a href="#Group">Group</a> objects specifying group labels and styles. Also accepts a Promise for deferred data rendering.
       *
       * @expose
       * @ojtsignore
       * @name groups
       * @memberof oj.ojChart
       * @ojshortdesc An array of strings identifying the group labels, or an array of objects specifying group labels and styles. See the Help documentation for more information.
       * @instance
       * @type {Array.<string>|Array.<Object>|Promise|null}
       * @ojsignature {target: "Type", value: "Array<string>|Promise<Array<string>>|Array<oj.ojChart.Group>|Promise<Array<oj.ojChart.Group>>|null", jsdocOverride: true}
       * @default null
       */
      groups: null,

      /**
       * Triggered during a selection gesture, such as a change in the marquee selection rectangle.
       *
       * @property {Array<string>} items an array containing the string ids of the selected data items
       * @property {Array<Object>} selectionData an array containing objects describing the selected data items
       * @property {Object} selectionData.data the data of the item, if one was specified
       * @property {Object} selectionData.itemData the row data of the item, if one was specified. This will only be set if a DataProvider is used.
       * @property {Array.<Object>} selectionData.groupData the group data of the item
       * @property {Object} selectionData.seriesData the series data of the item
       * @property {string} endGroup the end group of a marquee selection on a chart with categorical axis
       * @property {string} startGroup the start group of a marquee selection on a chart with categorical axis
       * @property {number} xMax the maximum x value of a marquee selection
       * @property {number} xMin the minimum x value of a marquee selection
       * @property {number} yMax the maximum y value of a marquee selection
       * @property {number} yMin the minimum y value of a marquee selection
       *
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       * @ojsignature [{target: "Type", value: "D", for: "selectionData.itemData"},
       *                {target: "Type", value: "oj.ojChart.Item<K, Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>|number", for: "selectionData.data", consumedBy: "js"},
       *                {target: "Type", value: "oj.ojChart.Item<K, I>|number", for: "selectionData.data", consumedBy: "ts"},
       *                {target: "Type", value: "Array.<oj.ojChart.Group>", for: "selectionData.groupData", jsdocOverride: true},
       *                {target: "Type", value: "oj.ojChart.Series<K, I>", for: "selectionData.seriesData", jsdocOverride: true},
       *                {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
       */
      selectInput: null,

      /**
       * An object containing an optional callback function for tooltip customization.
       * @expose
       * @name tooltip
       * @memberof oj.ojChart
       * @instance
       * @type {Object=}
       *
       * @example <caption>Initialize the Chart with the <code class="prettyprint">tooltip</code> attribute specified:</caption>
       * &lt;oj-chart tooltip.renderer='[[tooltipFun]]'>&lt;/oj-chart>
       *
       * &lt;oj-chart tooltip='[[{"renderer": tooltipFun}]]'>&lt;/oj-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">tooltip</code> property after initialization:</caption>
       * // Get one
       * var value = myChart.tooltip.renderer;
       *
       * // Set one, leaving the others intact.
       * myChart.setProperty('tooltip.renderer', tooltipFun);
       *
       * // Get all
       * var values = myChart.tooltip;
       *
       * // Set all. Must list every resource key, as those not listed are lost.
       * myChart.tooltip = {'renderer': tooltipFun};
       */
      tooltip: {
        /**
         * A function that returns a custom tooltip for chart. The function takes a <a href="#TooltipRendererContext">TooltipRendererContext</a> argument,
         * provided by the chart, and returns an object with the following properties:
         *  <ul>
         *    <li>insert: HTMLElement | string - An HTML element, which will be appended to the tooltip, or a tooltip string.</li>
         *    <li>preventDefault: <code>true</code> - Indicates that the tooltip should not be displayed. It is not necessary to return {preventDefault:false} to display tooltip, since this is a default behavior.</li>
         *  </ul>
         * @expose
         * @name tooltip.renderer
         * @memberof! oj.ojChart
         * @ojshortdesc A function that returns a custom tooltip for chart. The function takes a context argument, provided by the chart. See the Help documentation for more information.
         * @instance
         * @type {?(function(Object):Object)}
         * @ojsignature {target: "Type", value: "oj.dvtBaseComponent.PreventableDOMRendererFunction<oj.ojChart.TooltipRendererContext<K, D, I>>", jsdocOverride: true}
         * @default null
         */
        renderer: null
      },

      /**
       * Triggered after the viewport is changed due to a zoom or scroll operation.
       *
       * @property {string} endGroup the end group of the new viewport on a chart with categorical axis
       * @property {string} startGroup the start group of the new viewport on a chart with categorical axis
       * @property {number} xMax the maximum x value of the new viewport
       * @property {number} xMin the minimum x value of the new viewport
       * @property {number} yMax the maximum y value of the new viewport
       * @property {number} yMin the minimum y value of the new viewport
       *
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       */
      viewportChange: null,

      /**
       * Triggered during a viewport change gesture, such as a drag operation on the overview window. Note: There are
       * situations where the chart cannot determine whether the viewport change gesture is still in progress, such
       * as with mouse wheel zoom interactions. Standard viewportChange events are fired in these cases.
       *
       * @property {string} endGroup the end group of the new viewport on a chart with categorical axis
       * @property {string} startGroup the start group of the new viewport on a chart with categorical axis
       * @property {number} xMax the maximum x value of the new viewport
       * @property {number} xMin the minimum x value of the new viewport
       * @property {number} yMax the maximum y value of the new viewport
       * @property {number} yMin the minimum y value of the new viewport
       *
       * @expose
       * @event
       * @memberof oj.ojChart
       * @ojshortdesc Triggered during a viewport change gesture, such as a drag operation on the overview window. See the Help documentation for more information.
       * @instance
       * @ojbubbles
       */
      viewportChangeInput: null,

      /**
       * Triggered during a drill gesture (double click if selection is enabled, single click otherwise).
       *
       * @property {string} id the id of the drilled object
       * @property {string} series the series id of the drilled object, if applicable
       * @property {string} group the group id of the drilled object, if applicable
       * @property {Object|null} data  the data object of the drilled item
       * @property {Object} itemData  the row data object of the drilled item. This will only be set if a DataProvider is being used.
       * @property {Object|null} seriesData the data for the series of the drilled object
       * @property {Array.<Object>|null} groupData an array of data for the group the drilled object belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the drilled object
       * @ojdeprecated {since: '10.0.0', description: 'No longer recommended. Use separate drill listeners instead - ojItemDrill, ojGroupDrill, ojSeriesDrill, and ojMultiSeriesDrill.'}
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       * @ojsignature [{target: "Type", value: "D", for: "itemData"},
       *                {target: "Type", value: "oj.ojChart.Item<K, Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>|number|null", for: "data", consumedBy: "js"},
       *                {target: "Type", value: "oj.ojChart.Item<K, I>|number|null", for: "data", consumedBy: "ts"},
       *                {target: "Type", value: "oj.ojChart.Series<K, I>|null", for: "seriesData", jsdocOverride: true},
       *                {target: "Type", value: "Array.<oj.ojChart.Group>|null", for: "groupData", jsdocOverride: true},
       *                {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
       */
      drill: null,

      /**
       * Triggered on a chart item (double click if selection is enabled, single click otherwise).
       *
       * @property {string} id the id of the drilled object
       * @property {string} series the series id of the drilled object
       * @property {string|Array.<string>} group the group id of the drilled object. For hierarchical groups, it will be an array of outermost to innermost group id related to the drilled object
       * @property {Object} data  the data object of the drilled item
       * @property {Object} itemData  the row data object of the drilled item. This will only be set if a DataProvider is being used.
       * @property {Object} seriesData the data for the series of the drilled object
       * @property {Array.<Object>} groupData an array of data for the group the drilled object belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the drilled object
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       * @ojsignature [{target: "Type", value: "D", for: "itemData"},
       *                {target: "Type", value: "oj.ojChart.Item<K, Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>|number", for: "data", consumedBy: "js"},
       *                {target: "Type", value: "oj.ojChart.Item<K, I>|number", for: "data", consumedBy: "ts"},
       *                {target: "Type", value: "oj.ojChart.Series<K, I>", for: "seriesData", jsdocOverride: true},
       *                {target: "Type", value: "Array.<oj.ojChart.Group>", for: "groupData", jsdocOverride: true},
       *                {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
       */
      itemDrill: null,
      /**
       * Triggered on a chart group drill gesture (double click if selection is enabled, single click otherwise).
       *
       * @property {string} id the id of the drilled object
       * @property {string|Array.<string>} group the group id of the drilled object. For hierarchical groups, it will be an array of outermost to innermost group id related to the drilled object
       * @property {Array.<Object>} groupData an array of data for the group the drilled object belongs to. For hierarchical groups, it will be an array of outermost to innermost group data related to the drilled object
       * @property {Array.<Object>} items an array containing objects describing the data items belonging to the drilled group
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       * @ojsignature [ {target: "Type", value: "Array.<oj.ojChart.Group>", for: "groupData", jsdocOverride: true},
       *                {target: "Type", value: "Array.<oj.ojChart.DrillItem<K, D, I>>", for: "items", jsdocOverride: true},
       *                {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
       */
      groupDrill: null,

      /**
       * Triggered on a chart series drill gesture (double click if selection is enabled, single click otherwise).
       * @property {string} id the id of the drilled object
       * @property {string} series the series id of the drilled object
       * @property {Object} seriesData the data for the series of the drilled object
       * @property {Array.<Object>} items an array containing objects describing the data items belonging to the drilled group
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       * @ojsignature [{target: "Type", value: "oj.ojChart.Series<K, I>", for: "seriesData", jsdocOverride: true},
       *               {target: "Type", value: "Array.<oj.ojChart.DrillItem<K, D, I>>", for: "items", jsdocOverride: true},
       *               {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
       */
      seriesDrill: null,

      /**
       * Triggered on the drill gesture on chart object representing multiple series (e.g. other slice and legend item in pie charts). (double click if selection is enabled, single click otherwise). Multi series drilling is
       * enabled when <i>multi-series-drilling</i> is set to on.
       * @property {Array.<string>} series an array of series id of all the series belonging to the drill event
       * @property {Array.<Object>} seriesData an array of series data of all the series belonging to the drill event
       * @property {Array.<Object>} items an array containing objects describing the data items belonging to the drilled group
       * @expose
       * @event
       * @memberof oj.ojChart
       * @instance
       * @ojbubbles
       * @ojsignature [{target: "Type", value: "oj.ojChart.Series<K, I>", for: "seriesData", jsdocOverride: true},
       *               {target: "Type", value: "Array.<oj.ojChart.DrillItem<K, D, I>>", for: "items", jsdocOverride: true},
       *               {target: "Type", value: "<K, D, I extends Array.<oj.ojChart.Item<any, null>>|Array.<number>|null>", for: "genericTypeParameters"}]
       */
      multiSeriesDrill: null,

      /**
       * Specifies the series render order for combo charts.
       * If set to 'seriesType', the combo chart rendering order between series types will follow a set z-ordering aimed at minimizing overlap:  area and line with area series type in the background, then bar series, then line series in the foreground. Series within the same type are rendered in the order presented in the data. If set to 'data', series z-order follows the series order in the data. Note that, series-comparator can be used to change the series order in the data.
       * @expose
       * @name comboSeriesOrder
       * @memberof oj.ojChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "data" Series z order follows the series order in the data.
       * @ojvalue {string} "seriesType" The combo chart rendering order between series types will follow a set z-ordering aimed at minimizing overlap:  area and line with area series type in the background, then bar series, then line series in the foreground. Series within the same type are rendered in the order presented in the data.
       * @default "seriesType"
       */
      comboSeriesOrder: 'seriesType'
    },
    /**
     * @override
     * @memberof oj.ojChart
     * @protected
     */
    _ComponentCreate: function () {
      this._super();
      this._SetLocaleHelpers(NumberConverter, ConverterUtils);
    },

    _CreateDvtComponent: function (context, callback, callbackObj) {
      return new ojchartToolkit.Chart(context, callback, callbackObj);
    },

    _ConvertLocatorToSubId: function (locator) {
      var subId = locator.subId;

      // Convert the supported locators
      if (subId === 'oj-chart-item') {
        // dataItem[seriesIndex][itemIndex]
        subId = 'dataItem[' + locator.seriesIndex + '][' + locator.itemIndex + ']';
      } else if (subId === 'oj-chart-group') {
        // group[index1][index2]...[indexN]
        subId = 'group' + this._GetStringFromIndexPath(locator.indexPath);
      } else if (subId === 'oj-chart-series') {
        // series[index]
        subId = 'series[' + locator.index + ']';
      } else if (subId === 'oj-chart-axis-title') {
        // xAxis/yAxis/y2Axis:title
        subId = locator.axis + ':title';
      } else if (subId === 'oj-chart-reference-object') {
        // xAxis/yAxis/y2Axis:referenceObject[index]
        subId = locator.axis + ':referenceObject[' + locator.index + ']';
      } else if (subId === 'oj-legend-item') {
        // legend:section[sectionIndex0][sectionIndex1]...[sectionIndexN]:item[itemIndex]
        subId = 'legend:section' + this._GetStringFromIndexPath(locator.sectionIndexPath);
        subId += ':item[' + locator.itemIndex + ']';
      } else if (subId === 'oj-chart-tooltip') {
        subId = 'tooltip';
      } else if (subId === 'oj-chart-pie-center-label') {
        subId = 'pieCenterLabel';
      }

      // Return the converted result or the original subId if a supported locator wasn't recognized. We will remove
      // support for the old subId syntax in 1.2.0.
      return subId;
    },

    _IsLoadingSkeletonSupported: function () {
      return true;
    },

    _GetLoadingSkeletonMaskStyleClass: function () {
      const typeClassMap = {
        bar: 'oj-chart-bar-skeleton-container',
        boxPlot: 'oj-chart-boxplot-skeleton-container',
        stock: 'oj-chart-boxplot-skeleton-container',
        bubble: 'oj-chart-bubble-skeleton-container',
        scatter: 'oj-chart-bubble-skeleton-container',
        area: 'oj-chart-area-skeleton-container',
        lineWithArea: 'oj-chart-area-skeleton-container',
        line: 'oj-chart-line-skeleton-container',
        combo: 'oj-chart-combo-skeleton-container',
        pie: 'oj-chart-pie-skeleton-container',
        polar: 'oj-chart-pie-skeleton-container',
        funnel: 'oj-chart-funnel-skeleton-container',
        pyramid: 'oj-chart-pyramid-skeleton-container'
      };
      const type = this.options.coordinateSystem !== 'polar' ? this.options.type || 'bar' : 'polar';
      return typeClassMap[type];
    },

    _ProcessTemplates: function (
      dataProperty,
      data,
      templateEngine,
      isTreeData,
      parentKey,
      isRoot,
      updateChildren
    ) {
      var results = isRoot ? this._TemplateHandler.getComponentResults(dataProperty) : null;

      if (!results) {
        // Support for dataprovider and chart templates
        var items = this._super(
          dataProperty,
          data,
          templateEngine,
          isTreeData,
          parentKey,
          isRoot,
          updateChildren
        );
        var groupsAndSeries = createGroupsAndSeries(
          this,
          templateEngine,
          items.values[0],
          dataProperty
        );
        results = {
          paths: ['series', 'groups'],
          values: [groupsAndSeries.series, groupsAndSeries.groups]
        };
        if (isRoot) {
          this._TemplateHandler.setComponentResults(dataProperty, results);
        }
      }
      return results;
    },

    _GetSimpleDataProviderConfigs: function () {
      return {
        data: {
          templateName: 'itemTemplate',
          templateElementName: 'oj-chart-item',
          resultPath: '_item',
          derivedTemplates: ['seriesTemplate', 'groupTemplate']
        }
      };
    },

    _UseObjectAssignForShapedData: function () {
      return true;
    },

    _ProcessOptions: function () {
      this._super();

      var center = this.options.pieCenter;
      if (center && center._renderer) {
        center.renderer = this._GetTemplateRenderer(center._renderer, 'center');
      }

      var selection = this.options.selection;
      // The array<Object> type is deprecated since 2.1.0 so for custom elements and only supported for the data provider use case starting 5.1.0
      // we are breaking selection in order to push developers to use the correct syntax
      if (
        this._IsCustomElement() &&
        selection &&
        typeof selection[0] === 'object' &&
        !this.options.data
      ) {
        this.options.selection = null;
      }
    },

    _ConvertSubIdToLocator: function (subId) {
      var locator = {};

      if (subId.indexOf('dataItem') === 0) {
        // dataItem[seriesIndex][itemIndex]
        var indexPath = this._GetIndexPath(subId);

        locator.subId = 'oj-chart-item';
        locator.seriesIndex = indexPath[0];
        locator.itemIndex = indexPath[1];
      } else if (subId.indexOf('group') === 0) {
        // group[index1][index2]...[indexN]
        locator.subId = 'oj-chart-group';
        locator.indexPath = this._GetIndexPath(subId);
      } else if (subId.indexOf('series') === 0) {
        // series[index]
        locator.subId = 'oj-chart-series';
        locator.index = this._GetFirstIndex(subId);
      } else if (subId.indexOf('Axis:title') > 0) {
        // xAxis/yAxis/y2Axis:title
        locator.subId = 'oj-chart-axis-title';
        locator.axis = subId.substring(0, subId.indexOf(':'));
      } else if (subId.indexOf('Axis:referenceObject') > 0) {
        // xAxis/yAxis/y2Axis:referenceObject[index]
        locator.subId = 'oj-chart-reference-object';
        locator.axis = subId.substring(0, subId.indexOf(':'));
        locator.index = this._GetFirstIndex(subId);
      } else if (subId.indexOf('legend') === 0) {
        if (subId.indexOf(':item') > 0) {
          // legend:section[sectionIndex0][sectionIndex1]...[sectionIndexN]:item[itemIndex]
          var itemStartIndex = subId.indexOf(':item');
          var sectionSubstr = subId.substring(0, itemStartIndex);
          var itemSubstr = subId.substring(itemStartIndex);

          locator.subId = 'oj-legend-item';
          locator.sectionIndexPath = this._GetIndexPath(sectionSubstr);
          locator.itemIndex = this._GetFirstIndex(itemSubstr);
        }
      } else if (subId === 'tooltip') {
        locator.subId = 'oj-chart-tooltip';
      } else if (subId === 'pieCenterLabel') {
        locator.subId = 'oj-chart-pie-center-label';
      }

      return locator;
    },

    _GetComponentRendererOptions: function () {
      return [
        { path: 'tooltip/renderer', slot: 'tooltipTemplate' },
        { path: 'pieCenter/renderer', slot: 'pieCenterTemplate' }
      ];
    },

    _GetComponentStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses.push('oj-chart');
      return styleClasses;
    },

    _GetChildStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses['oj-chart-data-label'] = {
        path: 'styleDefaults/_dataLabelStyle',
        property: 'TEXT'
      };
      styleClasses['oj-chart-data-cursor-line'] = [
        { path: 'styleDefaults/dataCursor/lineColor', property: 'color' },
        { path: 'styleDefaults/dataCursor/lineWidth', property: 'width' }
      ];
      styleClasses['oj-chart-stack-label'] = {
        path: 'styleDefaults/stackLabelStyle',
        property: 'TEXT'
      };
      styleClasses['oj-chart-pie-center-label'] = { path: 'pieCenter/labelStyle', property: 'TEXT' };
      styleClasses['oj-chart-slice-label'] = {
        path: 'styleDefaults/sliceLabelStyle',
        property: 'TEXT'
      };
      styleClasses['oj-chart-stock-falling'] = {
        path: 'styleDefaults/stockFallingColor',
        property: 'background-color'
      };
      styleClasses['oj-chart-stock-range'] = {
        path: 'styleDefaults/stockRangeColor',
        property: 'background-color'
      };
      styleClasses['oj-chart-stock-rising'] = {
        path: 'styleDefaults/stockRisingColor',
        property: 'background-color'
      };
      styleClasses['oj-chart-xaxis-tick-label'] = { path: 'xAxis/tickLabel/style', property: 'TEXT' };
      styleClasses['oj-chart-xaxis-title'] = { path: 'xAxis/titleStyle', property: 'TEXT' };
      styleClasses['oj-chart-yaxis-tick-label'] = { path: 'yAxis/tickLabel/style', property: 'TEXT' };
      styleClasses['oj-chart-yaxis-title'] = { path: 'yAxis/titleStyle', property: 'TEXT' };
      styleClasses['oj-chart-y2axis-tick-label'] = {
        path: 'y2Axis/tickLabel/style',
        property: 'TEXT'
      };
      styleClasses['oj-chart-y2axis-title'] = { path: 'y2Axis/titleStyle', property: 'TEXT' };
      styleClasses['oj-chart-reference-object-line'] = [
        { path: '_defaultReferenceObjectLineColor', property: 'color' },
        { path: '_defaultReferenceObjectLineWidth', property: 'width' }
      ];
      styleClasses['oj-chart-reference-object-area'] = {
        path: '_defaultReferenceObjectAreaColor',
        property: 'color'
      };
      styleClasses['oj-chart-overview-filter-panel'] = {
        path: '_overviewFilterPanelBackgroundColor',
        property: 'background-color'
      };

      // Legend, should be kept in sync with oj-legend
      styleClasses['oj-legend'] = { path: 'legend/textStyle', property: 'TEXT' };
      styleClasses['oj-legend-title'] = { path: 'legend/titleStyle', property: 'TEXT' };
      styleClasses['oj-legend-section-title'] = [
        {
          path: 'legend/_sectionTitleStyle',
          property: 'TEXT'
        },
        {
          path: 'legend/sectionTitleStyle',
          property: 'TEXT'
        }
      ];
      styleClasses['oj-legend-hover'] = {
        path: 'legend/_hoverBorderRadius',
        property: 'border-radius'
      };

      // Color Ramp
      styleClasses['oj-dvt-color-ramp'] = { path: 'styleDefaults/colors', property: 'COLOR' };
      return styleClasses;
    },

    _GetEventTypes: function () {
      return [
        'drill',
        'groupDrill',
        'itemDrill',
        'seriesDrill',
        'multiSeriesDrill',
        'optionChange',
        'selectInput',
        'viewportChange',
        'viewportChangeInput'
      ];
    },

    _HandleEvent: function (event) {
      var type = event.type;
      if (type === 'selection') {
        var selection = event.selection;
        if (selection) {
          // Convert the graph selection context into the JET context
          var selectedItems = [];
          var selectionData = [];
          for (var i = 0; i < selection.length; i++) {
            var selectedItem;
            if (this._IsCustomElement()) {
              selectedItem = selection[i].id;
            } else {
              selectedItem = {
                id: selection[i].id,
                series: selection[i].series,
                group: selection[i].group
              };
            }
            var selectedItemData = {
              data: selection[i].data,
              seriesData: selection[i].seriesData,
              groupData: selection[i].groupData,
              itemData: selection[i].itemData
            };
            selectedItems.push(selectedItem);
            selectionData.push(selectedItemData);
          }

          var selectPayload = {
            endGroup: event.endGroup,
            startGroup: event.startGroup,
            xMax: event.xMax,
            xMin: event.xMin,
            yMax: event.yMax,
            yMin: event.yMin,
            y2Max: event.y2Max,
            y2Min: event.y2Min,
            selectionData: selectionData
          };

          if (!this._IsCustomElement()) {
            selectPayload.component = event.component;
          }

          // Update the options selection state if the user interaction is complete
          if (event.complete) {
            this._UserOptionChange('selection', selectedItems, selectPayload);
          } else {
            selectPayload.items = selectedItems;
            this._trigger('selectInput', null, selectPayload);
          }
        }
      } else if (type === 'viewportChange') {
        var viewportChangePayload = {
          endGroup: event.endGroup,
          startGroup: event.startGroup,
          xMax: event.xMax,
          xMin: event.xMin,
          yMax: event.yMax,
          yMin: event.yMin
        };

        // Maintain the viewport state
        // TODO we should be firing option change event for this, but it doesn't support nested props yet.
        if (event.complete) {
          // Ensure the axis options both exist
          if (!this.options.xAxis) {
            this.options.xAxis = {};
          }

          if (!this.options.yAxis) {
            this.options.yAxis = {};
          }

          // X-Axis: Clear the start and end group because min/max more accurate.
          this.options.xAxis.viewportStartGroup = null;
          this.options.xAxis.viewportEndGroup = null;
          if (event.xMin != null && event.xMax != null) {
            this.options.xAxis.viewportMin = event.xMin;
            this.options.xAxis.viewportMax = event.xMax;
          }

          // Y-Axis
          if (event.yMin != null && event.yMax != null) {
            this.options.yAxis.viewportMin = event.yMin;
            this.options.yAxis.viewportMax = event.yMax;
          }
        }

        this._trigger(
          event.complete ? 'viewportChange' : 'viewportChangeInput',
          null,
          viewportChangePayload
        );
      } else if (type === 'drill') {
        if (!event.subType) {
          this._trigger('drill', null, {
            id: event.id,
            series: event.series,
            group: event.group,
            data: event.data,
            seriesData: event.seriesData,
            groupData: event.groupData,
            itemData: event.itemData,
            component: event.component
          });
        } else if (this._IsCustomElement()) {
          var subType = event.subType;
          if (subType === 'item') {
            this._trigger('itemDrill', null, {
              id: event.id,
              series: event.series,
              group: event.group,
              data: event.data,
              itemData: event.itemData,
              seriesData: event.seriesData,
              groupData: event.groupData
            });
          } else if (subType === 'group') {
            this._trigger('groupDrill', null, {
              group: event.group,
              groupData: event.groupData,
              id: event.id,
              items: event.items
            });
          } else if (subType === 'series') {
            this._trigger('seriesDrill', null, {
              id: event.id,
              items: event.items,
              series: event.series,
              seriesData: event.seriesData
            });
          } else if (subType === 'multiSeries') {
            this._trigger('multiSeriesDrill', null, {
              items: event.items,
              series: event.series,
              seriesData: event.seriesData
            });
          }
        }
      } else {
        this._super(event);
      }
    },

    _LoadResources: function () {
      // Ensure the resources object exists
      if (this.options._resources == null) {
        this.options._resources = {};
      }

      var resources = this.options._resources;

      // Add images
      resources.overviewGrippy = 'oj-fwk-icon oj-fwk-icon-drag-horizontal';

      // Drag button icons
      resources.pan = 'oj-fwk-icon oj-fwk-icon-pan';
      resources.select = 'oj-fwk-icon oj-fwk-icon-marquee';
      resources.zoom = 'oj-fwk-icon oj-fwk-icon-magnifier';
    },

    /**
     * Returns the chart title.
     * @ignore
     * @return {string} The chart title
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojChart
     */
    getTitle: function () {
      var auto = this._component.getAutomation();
      return auto.getTitle();
    },

    /**
     * Returns the group corresponding to the given index
     * @param {string} groupIndex the group index
     * @return {string} The group name corresponding to the given group index
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojChart
     */
    getGroup: function (groupIndex) {
      var auto = this._component.getAutomation();
      return auto.getGroup(groupIndex);
    },

    /**
     * Returns the series corresponding to the given index
     * @param {string} seriesIndex the series index
     * @return {string} The series name corresponding to the given series index
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojChart
     */
    getSeries: function (seriesIndex) {
      var auto = this._component.getAutomation();
      return auto.getSeries(seriesIndex);
    },

    /**
     * Returns number of groups in the chart data
     * @return {number} The number of groups
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojChart
     */
    getGroupCount: function () {
      var auto = this._component.getAutomation();
      return auto.getGroupCount();
    },

    /**
     * Returns number of series in the chart data
     * @return {number} The number of series
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojChart
     */
    getSeriesCount: function () {
      var auto = this._component.getAutomation();
      return auto.getSeriesCount();
    },

    /**
     * Returns an object with the following properties for automation testing verification of the data item with
     * the specified series and group indices.
     *
     * @param {number} seriesIndex
     * @param {number} groupIndex
     * @property {string} borderColor
     * @property {string} color
     * @property {number} close The closing value for a stock item
     * @property {string} group The group id.
     * @property {number} high The high value for a range or stock item
     * @property {string} label
     * @property {number} low  The low value for a range or stock item
     * @property {number} open The opening value for a stock item
     * @property {boolean} selected
     * @property {string} series The series id.
     * @property {number} targetValue The target value for a funnel slice.
     * @property {string} tooltip
     * @property {number} value
     * @property {number} volume  The volume of a stock item
     * @property {number} x
     * @property {number} y
     * @property {number} z
     * @return {Object|null} An object containing properties for the data item, or null if none exists.
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojChart
     * @ojshortdesc Returns information for automation testing verification of a specified data item.
     */
    getDataItem: function (seriesIndex, groupIndex) {
      return this._component.getAutomation().getDataItem(seriesIndex, groupIndex);
    },

    /**
     * Returns an object that contains sizing information for the chart legend.
     *
     * @property {Object} bounds An object containing the bounds of the legend.
     * @property {number} bounds.x
     * @property {number} bounds.y
     * @property {number} bounds.width
     * @property {number} bounds.height
     * @property {string} title
     * @return {Object} An object containing properties for the chart legend.
     * @ojdeprecated {since: '7.0.0', description: 'The use of this property is no longer recommended.', target:'property', for: 'title' }
     * @instance
     * @memberof oj.ojChart
     * @ojsignature [{target: "Type", value: "{bounds: {x: number, y: number, width: number, height: number}}", for: "returns"}]
     */
    getLegend: function () {
      return this._component.getAutomation().getLegend();
    },

    /**
     * Returns an object that contains sizing information for the chart plot area.
     *
     * @property {Object} bounds An object containing the bounds of the plot area.
     * @property {number} bounds.x
     * @property {number} bounds.y
     * @property {number} bounds.width
     * @property {number} bounds.height
     * @return {Object} An object containing properties for the chart plot area.
     * @instance
     * @memberof oj.ojChart
     * @ojsignature [{target: "Type", value: "{bounds: {x: number, y: number, width: number, height: number}}", for: "returns"}]
     */
    getPlotArea: function () {
      return this._component.getAutomation().getPlotArea();
    },

    /**
     * Returns an object that contains sizing information for the chart X-Axis.
     *
     * @property {Object} bounds An object containing the bounds of the x axis.
     * @property {number} bounds.x
     * @property {number} bounds.y
     * @property {number} bounds.width
     * @property {number} bounds.height
     * @property {string} title
     * @property {Function(number, number)} getPreferredSize Returns the preferred size of the axis, given the available
     *   width and height. This value can be passed into the <code class="prettyprint">size</code> and
     *   <code class="prettyprint">maxSize</code> options of the axis. A re-render must be triggered by calling
     *   <code class="prettyprint">refresh</code> after invoking this function.
     * @property {number} getPreferredSize.width
     * @property {number} getPreferredSize.height
     * @return {Object} An object containing properties for the x axis.
     * @ojdeprecated {since: '7.0.0', description: 'The use of this property is no longer recommended.', target:'property', for: 'title' }
     * @instance
     * @memberof oj.ojChart
     * @ojsignature [{target: "Type", value: "{bounds: {x: number, y: number, width: number, height: number}, getPreferredSize(width: number, height: number): {width: number, height: number}}", for: "returns"}]
     */
    getXAxis: function () {
      return this._component.getAutomation().getXAxis();
    },

    /**
     * Returns an object that contains sizing information for the chart Y-Axis.
     *
     * @property {Object} bounds An object containing the bounds of the y axis.
     * @property {number} bounds.x
     * @property {number} bounds.y
     * @property {number} bounds.width
     * @property {number} bounds.height
     * @property {string} title
     * @property {Function(number, number)} getPreferredSize Returns the preferred size of the axis, given the available
     *   width and height. This value can be passed into the <code class="prettyprint">size</code> and
     *   <code class="prettyprint">maxSize</code> options of the axis. A re-render must be triggered by calling
     *   <code class="prettyprint">refresh</code> after invoking this function.
     * @property {number} getPreferredSize.width
     * @property {number} getPreferredSize.height
     * @return {Object} An object containing properties for the y axis.
     * @instance
     * @ojdeprecated {since: '7.0.0', description: 'The use of this property is no longer recommended.', target: 'property', for: 'title' }
     * @memberof oj.ojChart
     * @ojsignature [{target: "Type", value: "{bounds: {x: number, y: number, width: number, height: number}, getPreferredSize(width: number, height: number): {width: number, height: number}}", for: "returns"}]
     */
    getYAxis: function () {
      return this._component.getAutomation().getYAxis();
    },

    /**
     * Returns an object that contains sizing information for the chart Y2-Axis.
     *
     * @property {Object} bounds An object containing the bounds of the y2 axis.
     * @property {number} bounds.x
     * @property {number} bounds.y
     * @property {number} bounds.width
     * @property {number} bounds.height
     * @property {string} title
     * @property {Function(number, number)} getPreferredSize Returns the preferred size of the axis, given the available
     *   width and height. This value can be passed into the <code class="prettyprint">size</code> and
     *   <code class="prettyprint">maxSize</code> options of the axis. A re-render must be triggered by calling
     *   <code class="prettyprint">refresh</code> after invoking this function.
     * @property {number} getPreferredSize.width
     * @property {number} getPreferredSize.height
     * @return {Object} An object containing properties for the y2 axis.
     * @instance
     * @ojdeprecated {since: '7.0.0', description: 'The use of this property is no longer recommended.', target: 'property', for: 'title' }
     * @memberof oj.ojChart
     * @ojsignature [{target: "Type", value: "{bounds: {x: number, y: number, width: number, height: number}, getPreferredSize(width: number, height: number): {width: number, height: number}}", for: "returns"}]
     */
    getY2Axis: function () {
      return this._component.getAutomation().getY2Axis();
    },

    /**
     * Returns the x, y, and y2 axis values at the specified X and Y coordinate.
     * @param {number} x The X coordinate relative to the component.
     * @param {number} y The Y coordinate relative to the component.
     * @return {Object} An object containing the "x", "y", and "y2" axis values.
     * @ojsignature {target: "Type", value: "{x: number|string|null, y: number|null, y2:number|null}", for: "returns"}
     * @instance
     * @memberof oj.ojChart
     */
    getValuesAt: function (x, y) {
      return this._component.getValsAt(x, y);
    },

    /**
     * {@ojinclude "name":"nodeContextDoc"}
     * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
     * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
     * @ojsignature {target: "Type", value: "oj.ojChart.PieCenterLabelContext|oj.ojChart.LegendItemContext|oj.ojChart.ReferenceObject|oj.ojChart.GroupContext|oj.ojChart.AxisTitleContext|oj.ojChart.ItemContext|oj.ojChart.SeriesContext", jsdocOverride: true, for: "returns"}
     * @example {@ojinclude "name":"nodeContextExample"}
     *
     * @expose
     * @instance
     * @memberof oj.ojChart
     * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
     */
    getContextByNode: function (node) {
      // context objects are documented with @ojnodecontext
      var context = this.getSubIdByNode(node);
      if (context && context.subId !== 'oj-chart-tooltip') {
        return context;
      }

      return null;
    },

    /**
     * Returns the chart automation component used by webdriver.
     * @memberof oj.ojChart
     * @instance
     * @ojhidden
     */
    getAutomation: function () {
      return this._component.getAutomation();
    },

    // @inheritdoc
    _GetComponentNoClonePaths: function () {
      var noClonePaths = this._super();

      // Don't clone areas where app may pass in an instance of Converter
      // If the instance is a class, class methods may not be cloned for some reason.
      noClonePaths.pieCenter = { converter: true };
      noClonePaths.xAxis = {
        tickLabel: { converter: true }
      };
      noClonePaths.yAxis = {
        tickLabel: { converter: true }
      };
      noClonePaths.y2Axis = {
        tickLabel: { converter: true }
      };
      noClonePaths.valueFormats = {
        close: { converter: true },
        high: { converter: true },
        label: { converter: true },
        low: { converter: true },
        open: { converter: true },
        q1: { converter: true },
        q2: { converter: true },
        q3: { converter: true },
        targetValue: { converter: true },
        value: { converter: true },
        volume: { converter: true },
        x: { converter: true },
        y: { converter: true },
        y2: { converter: true },
        z: { converter: true }
      };

      return noClonePaths;
    },

    _GetComponentDeferredDataPaths: function () {
      return { root: ['groups', 'series', 'data'] };
    },

    _CompareOptionValues: function (option, value1, value2) {
      if (option === 'dataCursorPosition') {
        return oj.Object.compareValues(value1, value2);
      }
      return this._super(option, value1, value2);
    }
  });

  /**
   * @ojcomponent oj.ojSparkChart
   * @augments oj.dvtBaseComponent
   * @since 0.7.0
   * @ojshortdesc A spark chart displays information graphically, typically highlighting the trend of a data set in a compact form factor.
   *
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
   * @ojrole application
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojSparkChart<K, D extends oj.ojSparkChart.Item|any> extends dvtBaseComponent<ojSparkChartSettableProperties<K, D>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojSparkChartSettableProperties<K, D extends oj.ojSparkChart.Item|any> extends dvtBaseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["type", "title", "barGapRatio", "lineStyle", "lineType", "lineWidth", "animationOnDataChange", "animationOnDisplay", "style"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data", "items"]}
   * @ojvbdefaultcolumns 2
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-chart-spark'
   *
   * @classdesc
   * <h3 id="sparkChartOverview-section">
   *   JET Spark Chart
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sparkChartOverview-section"></a>
   * </h3>
   *
   * <p>Spark Chart component for JET with support for bar, line, area, and floating bar subtypes.  Spark Charts are
   * designed to visualize the trend of a data set in a compact form factor.</p>
   *
   * {@ojinclude "name":"warning"}
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-spark-chart
   *   type='line'
   *   items='[5, 8, 2, 7, 0, 9]'
   * >
   * &lt;/oj-spark-chart>
   * </code>
   * </pre>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"fragment_trackResize"}
   *
   * {@ojinclude "name":"a11y"}
   *
   * {@ojinclude "name":"rtl"}
   */
  oj.__registerWidget('oj.ojSparkChart', $.oj.dvtBaseComponent, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * An alias for the $current context variable when referenced inside itemTemplate when using a DataProvider.
       * @expose
       * @name as
       * @ojshortdesc An alias for the '$current' context variable passed to slot content for the itemTemplate slot.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @default ''
       * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
       */
      as: '',
      /**
       * The DataProvider for the spark chart. It should provide rows where each row corresponds to a single spark chart item.
       * The DataProvider can either have an arbitrary data shape, in which case an <oj-spark-chart-item> element must be specified in the itemTemplate slot or it can have [oj.ojSparkChart.Item]{@link oj.ojSparkChart.Item} as its data shape, in which case no template is required.
       * @expose
       * @name data
       * @ojshortdesc Specifies the data for the spark chart. See the Help documentation for more information.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {DataProvider|null}
       * @ojsignature {target: "Type", value: "DataProvider<K, D>|null", jsdocOverride:true}
       * @default null
       * @ojwebelementstatus {type: "unsupported", since: "13.0.0",
       *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
       *
       * @example <caption>Initialize the spark chart with the
       * <code class="prettyprint">data</code> attribute specified:</caption>
       * &lt;oj-spark-chart data='[[dataProvider]]'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">data</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.data;
       *
       * // setter
       * mySparkChart.data = dataProvider;
       */
      data: null,
      /**
       * An array of objects with the following properties that define the data for the spark chart. Also accepts a Promise for deferred data rendering.</ul>
       * @name items
       * @ojshortdesc An array of objects that define the data for the spark chart. See the Help documentation for more information.
       * @memberof oj.ojSparkChart
       * @instance
       * @ojtsignore
       * @ojsignature {target: "Accessor", value: {GetterType: "Promise<Array<oj.ojSparkChart.Item>>|Promise<Array<number>>|null", SetterType: "Array<oj.ojSparkChart.Item>|Array<number>|Promise<Array<oj.ojSparkChart.Item>>|Promise<Array<number>>|null"}, jsdocOverride: true}
       * @type {(Array.<Object>|Array.<number>|Promise|null)=}
       * @default null
       *
       * @example <caption>Initialize the spark chart with the
       * <code class="prettyprint">items</code> attribute specified:</caption>
       * &lt;oj-spark-chart type="bar" items='[{"low": 4, "high": 20, "color": "red"},
       *                                    {"low": 9, "high": 20, "color": "yellow"},
       *                                    {"low": 0, "high": 7, "color": "green"}]'>
       * &lt;/oj-spark-chart>
       *
       * &lt;oj-spark-chart items='[[itemsPromise]]'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">items</code>
       * property after initialization:</caption>
       * // Get one
       * var value = mySparkChart.items[0];
       *
       * // Get all (The items getter always returns a Promise so there is no "get one" syntax)
       * var values = mySparkChart.items;
       *
       * // Set all (There is no permissible "set one" syntax.)
       * mySparkChart.items = [{"low": 4, "high": 20, "color": "red"},
       *                       {"low": 9, "high": 20, "color": "yellow"},
       *                       {"low": 0, "high": 7, "color": "green"}];
       */
      items: null,
      /**
       * An array of objects with the following properties defining the reference objects associated with the y axis of the spark chart.
       * @expose
       * @name referenceObjects
       * @ojshortdesc An array of reference objects associated with the y axis of the spark chart.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {Array.<Object>=}
       * @ojsignature {target: "type", value: "Array<oj.ojSparkChart.ReferenceObject>", jsdocOverride: true}
       * @default []
       *
       * @example <caption>Initialize the spark chart with the
       * <code class="prettyprint">reference-objects</code> attribute specified:</caption>
       * &lt;oj-spark-chart reference-objects='[{"type": "area", "high": 10, "low": 2, "location": "front", "color": "red"},
       *                                     {"type": "line", "value": 9, "location": "front", "color": "yellow"},
       *                                     {"type": "area", "high": 10, "low": 0, "location": "back", "color": "green"}]'>&lt;/oj-spark-chart>
       *
       *
       * &lt;oj-spark-chart reference-objects='[[referencePromise]]'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">referenceObjects</code>
       * property after initialization:</caption>
       * // Get one
       * var value = mySparkChart.referenceObjects[0];
       *
       * // Get all (The items getter always returns a Promise so there is no "get one" syntax)
       * var values = mySparkChart.referenceObjects;
       *
       * // Set all (There is no permissible "set one" syntax.)
       * mySparkChart.referenceObjects=[{"type": "area", "high": 10, "low": 2, "location": "front", "color": "red"},
       *                                {"type": "line", "value": 9, "location": "front", "color": "yellow"},
       *                                {"type": "area", "high": 10, "low": 0, "location": "back", "color": "green"}];
       */
      referenceObjects: [],
      /**
       * An object containing an optional callback function for tooltip customization.
       * @expose
       * @name tooltip
       * @memberof oj.ojSparkChart
       * @instance
       * @type {Object=}
       *
       * @example <caption>Initialize the spark chart with the
       * <code class="prettyprint">tooltip</code> attribute specified:</caption>
       * <!-- Using dot notation -->
       * &lt;oj-spark-chart tooltip.renderer='[[tooltipFun]]'>&lt;/oj-spark-chart>
       *
       * &lt;oj-spark-chart tooltip='[[{"renderer": tooltipFun}]]'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">tooltip</code>
       * property after initialization:</caption>
       * // Get one
       * var value = mySparkChart.tooltip.renderer;
       *
       * // Get all
       * var values = mySparkChart.tooltip;
       *
       * // Set one, leaving the others intact. Always use the setProperty API for
       * // subproperties rather than setting a subproperty directly.
       * mySparkChart.setProperty('tooltip.renderer', tooltipFun);
       *
       * // Set all. Must list every resource key, as those not listed are lost.
       * mySparkChart.tooltip={'renderer': tooltipFun};
       */
      tooltip: {
        /**
         *  A function that returns a custom tooltip. The function takes a dataContext argument,
         *  provided by the chart, with the following properties:
         *  <ul>
         *   <li>parentElement: The tooltip element. The function can directly modify or append content to this element.</li>
         *   <li>color: The color of the chart.</li>
         *   <li>componentElement: The spark chart element.</li>
         *  </ul>
         *  The function should return an Object that contains only one of the two properties:
         *  <ul>
         *    <li>insert: HTMLElement | string - An HTML element, which will be appended to the tooltip, or a tooltip string.</li>
         *    <li>preventDefault: <code>true</code> - Indicates that the tooltip should not be displayed. It is not necessary to return {preventDefault:false} to display tooltip, since this is a default behavior.</li>
         *  </ul>
         * @expose
         * @name tooltip.renderer
         * @ojshortdesc A function that returns a custom tooltip. The function takes a context argument, provided by the spark chart. See the Help documentation for more information.
         * @memberof! oj.ojSparkChart
         * @instance
         * @type {function(Object):Object|null}
         * @default null
         * @ojsignature {target: "Type", value: "((context: oj.ojSparkChart.TooltipContext) => ({insert: Element|string}|{preventDefault: boolean}))|null", jsdocOverride: true}
         * @example <caption>See the <a href="#tooltip">tooltip</a> attribute for usage examples.</caption>
         */
        renderer: null
      },
      /**
       * The chart type.
       * @expose
       * @name type
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "area" Series will be represented by an area. Use lineWithArea to prevent values from being obscured.
       * @ojvalue {string} "lineWithArea" Series will be presented by a line and area.
       * @ojvalue {string} "bar"  Data items will be represented by bars.
       * @ojvalue {string} "line" Series will be represented by a line.
       * @default "line"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">type</code> attribute specified:</caption>
       * &lt;oj-spark-chart type='area'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">type</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.type;
       *
       * // setter
       * mySparkChart.type="area";
       */
      type: 'line',
      /**
       * The color of the data items. The default value varies based on theme.
       * @expose
       * @name color
       * @ojshortdesc The color of the data items.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojformat color
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">color</code> attribute specified:</caption>
       * &lt;oj-spark-chart color='rgb(35, 123, 177)'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">color</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.color;
       *
       * // setter
       * mySparkChart.color="rgb(35, 123, 177)";
       */
      color: '',
      /**
       * The color of the area in area or lineWithArea spark chart.
       * @expose
       * @name areaColor
       * @ojshortdesc The color of the area. Only applies if type is "area" or "lineWithArea".
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojformat color
       * @default ""
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">area-color</code> attribute specified:</caption>
       * &lt;oj-spark-chart type='area' area-color='red'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">areaColor</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.areaColor;
       *
       * // setter
       * mySparkChart.areaColor="red";
       */
      areaColor: '',
      /**
       * The CSS style class to apply if the type is area or lineWithArea. The style class and inline style will override any other styling specified through the properties. For tooltips and hover interactivity, it's recommended to also pass a representative color to the color attribute.
       * @expose
       * @name areaSvgClassName
       * @ojshortdesc The CSS style class to apply if type is "area" or "lineWithArea".
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @default ""
       * @ojdeprecated {since: "18.1.0", description: "The areaSvgClassName property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">area-svg-class-name</code> attribute specified:</caption>
       * &lt;oj-spark-chart type='lineWithArea' area-svg-class-name='svgClassName'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">areaSvgClassName</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.areaSvgClassName;
       *
       * // setter
       * mySparkChart.areaSvgClassName = "svgClassName";
       */
      areaSvgClassName: '',
      /**
       * The inline style to apply if the type is area or lineWithArea. The style class and inline style will override any other styling specified through the properties. For tooltips and hover interactivity, it's recommended to also pass a representative color to the color attribute.
       * Only SVG CSS style properties are supported.
       * @expose
       * @name areaSvgStyle
       * @ojshortdesc The inline style to apply if type is "area" or "lineWithArea".
       * @memberof oj.ojSparkChart
       * @instance
       * @type {Object=}
       * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
       * @default {}
       * @ojdeprecated {since: "18.1.0", description: "The areaSvgStyle property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">area-svg-style</code> attribute specified:</caption>
       * &lt;oj-spark-chart type='lineWithArea' area-svg-style='{"fill":"url(someURL#filterId)"}'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">areaSvgStyle</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.areaSvgStyle;
       *
       * // setter
       * mySparkChart.areaSvgStyle = {"fill":"url(someURL#filterId)"};
       */
      areaSvgStyle: {},
      /**
       * The CSS style class to apply to the data items. For type lineWithArea, this style will only be applied to the line if areaSvgClassName is also specified. The style class and inline style will override any other styling specified through the properties. For tooltips, it's recommended to also pass a representative color to the color attribute.
       * @expose
       * @name svgClassName
       * @ojshortdesc The CSS style class to apply to the data items. If type is "lineWithArea", this style will only be applied to the line if areaSvgClassName is also specified. See the Help documentation for more information.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojdeprecated {since: "19.0.0", description: "The svgClassName property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
       * @default ""
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">svg-class-name</code> attribute specified:</caption>
       * &lt;oj-spark-chart svg-class-name='className'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">svgClassName</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.svgClassName;
       *
       * // setter
       * mySparkChart.svgClassName = "className";
       */
      svgClassName: '',
      /**
       * The inline style to apply to the data items. For type lineWithArea, this style will only be applied to the line if areaSvgStyle is also specified. The style class and inline style will override any other styling specified through the properties. For tooltips, it's recommended to also pass a representative color to the color attribute.
       * Only SVG CSS style properties are supported.
       * @expose
       * @name svgStyle
       * @ojshortdesc The inline style to apply to the data items. If type is "lineWithArea", this style will only be applied to the line if areaSvgStyle is also specified. See the Help documentation for more information.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {Object=}
       * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
       * @default {}
       * @ojdeprecated {since: "19.0.0", description: "The svgStyle property is deprecated. This API is not recommended in Redwood theme. Use other customization APIs where appropriate." }
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">svg-style</code> attribute specified:</caption>
       * &lt;oj-spark-chart svg-style='{"fill":"url(someURL#filterId)"}'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">svgStyle</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.svgStyle;
       *
       * // setter
       * mySparkChart.svgStyle = {"fill":"url(someURL#filterId)"};
       */
      svgStyle: {},
      /**
       * The color of the first data item.
       * @expose
       * @name firstColor
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojformat color
       * @default ""
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">first-color</code> attribute specified:</caption>
       * &lt;oj-spark-chart first-color='yellow'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">firstColor</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.firstColor;
       *
       * // setter
       * mySparkChart.firstColor = "yellow";
       */
      firstColor: '',
      /**
       * The color of the last data item.
       * @expose
       * @name lastColor
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojformat color
       * @default ""
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">last-color</code> attribute specified:</caption>
       * &lt;oj-spark-chart last-color='red'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">lastColor</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.lastColor;
       *
       * // setter
       * mySparkChart.lastColor = "red";
       */
      lastColor: '',
      /**
       * The color of the data item with the greatest value.
       * @expose
       * @name highColor
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojformat color
       * @default ""
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">high-color</code> attribute specified:</caption>
       * &lt;oj-spark-chart high-color='blue'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">highColor</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.highColor;
       *
       * // setter
       * mySparkChart.highColor = "blue";
       */
      highColor: '',
      /**
       * The color of the data item with the lowest value.
       * @expose
       * @name lowColor
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojformat color
       * @default ""
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">low-color</code> attribute specified:</caption>
       * &lt;oj-spark-chart low-color='blue'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">lowColor</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.lowColor;
       *
       * // setter
       * mySparkChart.lowColor = "blue";
       */
      lowColor: '',
      /**
       * The duration of the animations in milliseconds. The default value comes from the CSS and varies based on theme.
       * @expose
       * @name animationDuration
       * @ojshortdesc The duration of the animations in milliseconds.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {?number=}
       * @ojunits milliseconds
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">animation-duration</code> attribute specified:</caption>
       * &lt;oj-spark-chart animation-duration='50'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">animationDuration</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.animationDuration;
       *
       * // setter
       * mySparkChart.animationDuration = 50;
       */
      animationDuration: undefined,

      /**
       * Defines the animation that is applied on data changes.
       * @expose
       * @name animationOnDataChange
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "auto" Animation on data change will be enabled.
       * @ojvalue {string} "none" Animation on data change will be disabled.
       * @default "none"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">animation-on-data-change</code> attribute specified:</caption>
       * &lt;oj-spark-chart animation-on-data-change='auto'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">animationOnDataChange</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.animationOnDataChange;
       *
       * // setter
       * mySparkChart.animationOnDataChange = "auto";
       */
      animationOnDataChange: 'none',
      /**
       * Defines the animation that is shown on initial display.
       * @expose
       * @name animationOnDisplay
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "auto" Animation on display will be enabled.
       * @ojvalue {string} "none" Animation on display will be disabled.
       * @default "none"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">animation-on-display</code> attribute specified:</caption>
       * &lt;oj-spark-chart animation-on-display='auto'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">animationOnDisplay</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.animationOnDisplay;
       *
       * // setter
       * mySparkChart.animationOnDisplay = "auto";
       */
      animationOnDisplay: 'none',
      /**
       * Defines whether visual effects such as overlays are applied to the spark chart.
       * @expose
       * @name visualEffects
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "none" No overlays are applied to the spark chart.
       * @ojvalue {string} "auto" Overlays and gradients could be applied to the spark chart.
       * @default "auto"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">visual-effects</code> attribute specified:</caption>
       * &lt;oj-spark-chart visual-effects='none'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">visualEffects</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.visualEffects;
       *
       * // setter
       * mySparkChart.visualEffects = "none";
       */
      visualEffects: 'auto',
      /**
       * Defines whether the axis baseline starts at the minimum value of the data or at zero.
       * @expose
       * @name baselineScaling
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "zero" Axis baseline will start at zero.
       * @ojvalue {string} "min" Axis baseline will start at the minimum value of the data.
       * @default "min"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">baseline-scaling</code> attribute specified:</caption>
       * &lt;oj-spark-chart baseline-scaling='zero'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">baselineScaling</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.baselineScaling;
       *
       * // setter
       * mySparkChart.baselineScaling = "zero";
       */
      baselineScaling: 'min',
      /**
       * The width of the data line in pixels. Only applies to line spark charts.
       * @expose
       * @name lineWidth
       * @memberof oj.ojSparkChart
       * @instance
       * @type {number=}
       * @default 1
       * @ojunits pixels
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">line-width</code> attribute specified:</caption>
       * &lt;oj-spark-chart line-width='4'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">lineWidth</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.lineWidth;
       *
       * // setter
       * mySparkChart.lineWidth = 4;
       */
      lineWidth: 1,
      /**
       * The line style of the data line. Only applies to line spark charts.
       * @expose
       * @name lineStyle
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "dotted" Line will have dotted strokes.
       * @ojvalue {string} "dashed" Line will have dashed strokes.
       * @ojvalue {string} "solid" Line will have a solid stroke.
       * @default "solid"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">line-style</code> attribute specified:</caption>
       * &lt;oj-spark-chart type="line" line-style='dotted'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">lineStyle</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.lineStyle;
       *
       * // setter
       * mySparkChart.lineStyle = "dotted";
       */
      lineStyle: 'solid',
      /**
       * The line type of the data line or area. Only applies to line and area spark charts.
       * @expose
       * @name lineType
       * @memberof oj.ojSparkChart
       * @instance
       * @type {string=}
       * @ojvalue {string} "curved" Data points will be connected with a curved line.
       * @ojvalue {string} "stepped" Data points will be connected with a stepped line.
       * @ojvalue {string} "centeredStepped" Data points will be connected with a centered stepped line.
       * @ojvalue {string} "segmented" Data points will be connected with a segmented line.
       * @ojvalue {string} "centeredSegmented" Data points will be connected with a centered segmented line.
       * @ojvalue {string} "none" Data points will not be connected.
       * @ojvalue {string} "straight" Data points will be connected with a straight line.
       * @default "straight"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">line-type</code> attribute specified:</caption>
       * &lt;oj-spark-chart type="line" line-type='curved'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">lineType</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.lineType;
       *
       * // setter
       * mySparkChart.lineType = "curved";
       */
      lineType: 'straight',
      /**
       * The shape of the data markers. Can take the name of a built-in shape or the SVG path commands for a custom shape. Only applies to line and area spark charts.
       * @expose
       * @name markerShape
       * @ojshortdesc The shape of the data markers. See the Help documentation for more information.
       * @memberof oj.ojSparkChart
       * @instance
       * @type {("auto"|"circle"|"diamond"|"human"|"plus"|"square"|"star"|"triangleDown"|"triangleUp"|string)=}
       * @default "auto"
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">marker-shape</code> attribute specified:</caption>
       * &lt;oj-spark-chart type="area" marker-shape="triangleUp">&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">markerShape</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.markerShape;
       *
       * // setter
       * mySparkChart.markerShape = "triangleUp";
       */
      markerShape: 'auto',
      /**
       * The size of the data markers in pixels. Only applies to line and area spark charts.
       * @expose
       * @name markerSize
       * @memberof oj.ojSparkChart
       * @instance
       * @type {number=}
       * @default 5
       * @ojunits pixels
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">marker-size</code> attribute specified:</caption>
       * &lt;oj-spark-chart type="area" marker-size='15'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">markerSize</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.markerSize;
       *
       * // setter
       * mySparkChart.markerSize = 15;
       */
      markerSize: 5,
      /**
       * Specifies the width of the bar gap as a ratio of the item width. The valid value is a number from 0 to 1.
       * @expose
       * @name barGapRatio
       * @memberof oj.ojSparkChart
       * @instance
       * @type {number=}
       * @default 0.25
       *
       * @example <caption>Initialize the spark chart with the <code class="prettyprint">bar-gap-ratio</code> attribute specified:</caption>
       * &lt;oj-spark-chart type="bar" bar-gap-ratio='0.12'>&lt;/oj-spark-chart>
       *
       * @example <caption>Get or set the <code class="prettyprint">barGapRatio</code>
       * property after initialization:</caption>
       * // getter
       * var value = mySparkChart.barGapRatio;
       *
       * // setter
       * mySparkChart.barGapRatio = 0.12;
       */
      barGapRatio: 0.25
    },

    _CreateDvtComponent: function (context, callback, callbackObj) {
      this._focusable({ element: this.element, applyHighlight: true });
      return new ojchartToolkit.SparkChart(context, callback, callbackObj);
    },

    _GetComponentStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses.push('oj-sparkchart');
      return styleClasses;
    },

    _GetChildStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses['oj-dvtbase oj-sparkchart'] = { path: 'animationDuration', property: 'ANIM_DUR' };
      styleClasses['oj-spark-chart-item'] = { path: 'color', property: 'color' };
      return styleClasses;
    },

    _Render: function () {
      // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
      if (this.element.attr('title')) {
        this.options.shortDesc = this.element.attr('title');
        this.element.data(this.element, 'title', this.element.attr('title'));
        this.element.removeAttr('title');
      } else if (this.element.data('title')) {
        this.options.shortDesc = this.element.data('title');
      }

      // Call the super to render
      this._super();
    },

    /**
     * Returns an object with the following properties for automation testing verification of the data item with
     * the specified item index.
     * @param {number} itemIndex The item index
     * @property {string} borderColor The border color of the item
     * @property {string} color The color of the item
     * @property {Date} date The date (x value) of the item
     * @property {number} high The high value for a range item
     * @property {number} low  The low value for a range item
     * @property {number} value The value of the item
     * @return {Object|null} An object containing properties for the data item, or null if none exists.
     * @ojsignature {target: "Type", value: "oj.ojSparkChart.ItemContext|null", jsdocOverride: true, for: "returns"}
     * @expose
     * @instance
     * @memberof oj.ojSparkChart
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @ojshortdesc Returns information for automation testing verification of a specified data item.
     */
    getDataItem: function (itemIndex) {
      var ret = this._component.getAutomation().getDataItem(itemIndex);

      // : Provide backwards compatibility for getters until 1.2.0.
      this._AddAutomationGetters(ret);
      if (ret) {
        ret.getFloatValue = ret.getLow;
      }

      return ret;
    },

    _GetComponentDeferredDataPaths: function () {
      return { root: ['items', 'data'] };
    },

    _GetSimpleDataProviderConfigs: function () {
      return {
        data: {
          templateName: 'itemTemplate',
          templateElementName: 'oj-spark-chart-item',
          resultPath: 'items'
        }
      };
    },

    /**
     * Adds getters for the properties on the specified map.
     * @param {Object|null} map
     * @memberof oj.ojSparkChart
     * @instance
     * @protected
     */
    _AddAutomationGetters: function (map) {
      if (!map) {
        return;
      }

      // These getters are deprecated in 3.0.0
      var props = {};
      var keys = Object.keys(map);
      for (var i = 0; i < keys.length; i++) {
        this._addGetter(map, keys[i], props);
      }
      Object.defineProperties(map, props);
    },

    /**
     * Adds getter for the specified property on the specified properties map.
     * @param {Object} map
     * @param {string} key
     * @param {Object} props The properties map onto which the getter will be added.
     * @memberof oj.ojSparkChart
     * @instance
     * @private
     */
    _addGetter: function (map, key, props) {
      var prefix = key === 'selected' ? 'is' : 'get';
      var getterName = prefix + key.charAt(0).toUpperCase() + key.slice(1);
      // eslint-disable-next-line no-param-reassign
      props[getterName] = {
        value: function () {
          return map[key];
        }
      };
    }
  });

});


define('ojs/ojlegend',['ojs/ojcore-base', 'ojs/ojcomponentcore', 'ojs/ojdvt-base', 'jquery', 'ojs/ojlegend-toolkit', 'ojs/ojkeyset'], function (oj, Components, DvtAttributeUtils, $, ojlegendToolkit, ojkeyset) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  DvtAttributeUtils = DvtAttributeUtils && Object.prototype.hasOwnProperty.call(DvtAttributeUtils, 'default') ? DvtAttributeUtils['default'] : DvtAttributeUtils;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

var __oj_legend_metadata = 
{
  "properties": {
    "as": {
      "type": "string",
      "value": ""
    },
    "data": {
      "type": "DataProvider",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "unsupported",
              "since": "13.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "drilling": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "expanded": {
      "type": "KeySet",
      "writeback": true
    },
    "halign": {
      "type": "string",
      "enumValues": [
        "center",
        "end",
        "start"
      ],
      "value": "start"
    },
    "hiddenCategories": {
      "type": "Array<string>",
      "writeback": true,
      "value": []
    },
    "hideAndShowBehavior": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "highlightedCategories": {
      "type": "Array<string>",
      "writeback": true,
      "value": []
    },
    "hoverBehavior": {
      "type": "string",
      "enumValues": [
        "dim",
        "none"
      ],
      "value": "none"
    },
    "hoverBehaviorDelay": {
      "type": "number",
      "value": 200
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "vertical"
    },
    "scrolling": {
      "type": "string",
      "enumValues": [
        "asNeeded",
        "off"
      ],
      "value": "asNeeded"
    },
    "sectionTitleHalign": {
      "type": "string",
      "enumValues": [
        "center",
        "end",
        "start"
      ]
    },
    "sectionTitleStyle": {
      "type": "object",
      "value": {}
    },
    "sections": {
      "type": "Array<Object>"
    },
    "symbolHeight": {
      "type": "number",
      "value": 0
    },
    "symbolWidth": {
      "type": "number",
      "value": 0
    },
    "textStyle": {
      "type": "object",
      "value": {}
    },
    "trackResize": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "on"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleContainsControls": {
          "type": "string"
        },
        "componentName": {
          "type": "string"
        },
        "labelAndValue": {
          "type": "string"
        },
        "labelClearSelection": {
          "type": "string"
        },
        "labelCountWithTotal": {
          "type": "string"
        },
        "labelDataVisualization": {
          "type": "string"
        },
        "labelInvalidData": {
          "type": "string"
        },
        "labelNoData": {
          "type": "string"
        },
        "stateCollapsed": {
          "type": "string"
        },
        "stateDrillable": {
          "type": "string"
        },
        "stateExpanded": {
          "type": "string"
        },
        "stateHidden": {
          "type": "string"
        },
        "stateIsolated": {
          "type": "string"
        },
        "stateMaximized": {
          "type": "string"
        },
        "stateMinimized": {
          "type": "string"
        },
        "stateSelected": {
          "type": "string"
        },
        "stateUnselected": {
          "type": "string"
        },
        "stateVisible": {
          "type": "string"
        },
        "tooltipCollapse": {
          "type": "string"
        },
        "tooltipExpand": {
          "type": "string"
        }
      }
    },
    "valign": {
      "type": "string",
      "enumValues": [
        "bottom",
        "middle",
        "top"
      ],
      "value": "top"
    }
  },
  "methods": {
    "getContextByNode": {},
    "getItem": {},
    "getPreferredSize": {},
    "getProperty": {},
    "getSection": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojDrill": {}
  },
  "extension": {}
};
  /* global __oj_legend_metadata:false */
  /**
   * Ignore tag only needed for DVTs that have jsDoc in separate _doc.js files.
   * @ignore
   */
  (function () {
    __oj_legend_metadata.extension._WIDGET_NAME = 'ojLegend';
    oj.CustomElementBridge.register('oj-legend', { metadata: __oj_legend_metadata });
  })();

var __oj_legend_item_metadata = 
{
  "properties": {
    "borderColor": {
      "type": "string",
      "value": ""
    },
    "categories": {
      "type": "Array<string>",
      "value": []
    },
    "categoryVisibility": {
      "type": "string",
      "enumValues": [
        "hidden",
        "visible"
      ],
      "value": "visible"
    },
    "color": {
      "type": "string"
    },
    "drilling": {
      "type": "string",
      "enumValues": [
        "inherit",
        "off",
        "on"
      ],
      "value": "inherit"
    },
    "lineStyle": {
      "type": "string",
      "enumValues": [
        "dashed",
        "dotted",
        "solid"
      ],
      "value": "solid"
    },
    "lineWidth": {
      "type": "number"
    },
    "markerColor": {
      "type": "string"
    },
    "markerShape": {
      "type": "string",
      "value": "square"
    },
    "markerSvgClassName": {
      "type": "string",
      "value": ""
    },
    "markerSvgStyle": {
      "type": "object"
    },
    "pattern": {
      "type": "string",
      "enumValues": [
        "largeChecker",
        "largeCrosshatch",
        "largeDiagonalLeft",
        "largeDiagonalRight",
        "largeDiamond",
        "largeTriangle",
        "none",
        "smallChecker",
        "smallCrosshatch",
        "smallDiagonalLeft",
        "smallDiagonalRight",
        "smallDiamond",
        "smallTriangle"
      ],
      "value": "none"
    },
    "shortDesc": {
      "type": "string",
      "value": ""
    },
    "source": {
      "type": "string",
      "value": ""
    },
    "svgClassName": {
      "type": "string",
      "value": ""
    },
    "svgStyle": {
      "type": "object"
    },
    "symbolType": {
      "type": "string",
      "enumValues": [
        "image",
        "line",
        "lineWithMarker",
        "marker"
      ],
      "value": "marker"
    },
    "text": {
      "type": "string",
      "value": ""
    }
  },
  "extension": {}
};
  /* global __oj_legend_item_metadata:false */
  (function () {
    __oj_legend_item_metadata.extension._CONSTRUCTOR = function () {};
    var _LEGEND_ITEM_SHAPE_ENUMS = {
      circle: true,
      ellipse: true,
      diamond: true,
      triangleUp: true,
      triangleDown: true,
      plus: true,
      human: true,
      rectangle: true,
      star: true,
      square: true
    };
    oj.CustomElementBridge.register('oj-legend-item', {
      metadata: __oj_legend_item_metadata,
      parseFunction: DvtAttributeUtils.shapeParseFunction(
        { 'marker-shape': true },
        _LEGEND_ITEM_SHAPE_ENUMS
      )
    });
  })();

var __oj_legend_section_metadata = 
{
  "properties": {
    "collapsible": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "off"
    },
    "text": {
      "type": "string",
      "value": ""
    },
    "textHalign": {
      "type": "string",
      "enumValues": [
        "center",
        "end",
        "start"
      ]
    },
    "textStyle": {
      "type": "object",
      "value": {}
    }
  },
  "extension": {}
};
  /* global __oj_legend_section_metadata:false */
  (function () {
    __oj_legend_section_metadata.extension._CONSTRUCTOR = function () {};
    oj.CustomElementBridge.register('oj-legend-section', {
      metadata: __oj_legend_section_metadata
    });
  })();

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="2">Legend Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Filter when <code class="prettyprint">hideAndShowBehavior</code> is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Highlight when <code class="prettyprint">hoverBehavior</code> is enabled.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojLegend
   */

  /**
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * To migrate from oj-legend to oj-c-legend, you need to revise the import statement and references to oj-legend in your app. Please note the changes between the two components below.
   * <h5>Default component width</h5>
   * <p>
   * The default width of oj-c-legend is 100% while in oj-legend there is no explicit width set but it is driven by SVG default dimensions.
   * </p>
   * <h5>Keyboard navigation</h5>
   * <p>
   * In oj-c-legend, keyboard navigation of items is 1-dimension direction whereas in legacy it is 2-dimension direction. In oj-c-legend, up and right keys go in the same direction and down and left keys also go in the same direction.
   * </p>
   * <h5>Sectional legend horizontal layout</h5>
   * <p>
   * In oj-c-legend, sectional legends in horizontal orientation are laid out in a flowing manner whereas legend might have some gaps.
   * </p>
   * <h5 id="dataprovider-key-type-migration"></h5>
   * <h5 id="context-menu-migration"></h5>
   * <h5>text-style</h5>
   * <p>
   * For the initial version of oj-c-legend, the cursor property will not be supported in the text-style CSS style object.
   * </p>
   * <h5> getPreferredSize </h5>
   * <p> For oj-c-legend, getPreferredSize method is not supported. Use the <a target="_blank" href="legend-utils.html#getPreferredSize">getPrferredSize</a> utility instead. </p>
   * <h5>getContextByNode method</h5>
   * <p>
   * For the initial version of oj-c-legend, getContextByNode method is not supported. We plan on supporting this use case in future releases.
   * </p>
   * <h5>pattern attribute</h5>
   * <p>
   * For the inital versions of oj-c-legend and oj-c-legend-item, patterns are not supported. We plan on supporting it in future releases.
   * </p>
   * <h5>sectionTemplate</h5>
   * <p>
   * For the initial version of oj-c-legend, nested section is not supported. $current of sectionTemplate context will not contain parentKey and parentData properties.
   * </p>
   *
   * @ojfragment migrationDoc
   * @memberof oj.ojLegend
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Move focus to next element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + Tab</kbd></td>
   *       <td>Move focus to previous element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Move focus to previous item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Move focus to next item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>Move focus to previous item (on left).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>Move focus to next item (on right).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Enter or Space</kbd></td>
   *       <td>Hides or unhides the data associated with the current item or a collapsible section.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojLegend
   */

  /**
   * Object type that defines a legend section.
   * @typedef {Object} oj.ojLegend.Section
   * @property {"on"|"off"} [collapsible="off"] Whether the section is collapsible. Only applies if the legend orientation is vertical.
   * @property {"off"|"on"} [expanded="on"] Whether the section is initially expanded. Only applies if the section is collapsible.
   * @property {string=} id The id of the legend section. For the DataProvider case, the key for the node will be used as the id.
   * @property {Array.<Object>=} items An array of objects with the following properties defining the legend items. Also accepts a Promise for deferred data rendering. No data will be rendered if the Promise is rejected.
   * @property {Array.<Object>=} sections An array of nested legend sections.
   * @property {string=} title The title of the legend section.
   * @property {"center"|"end"|"start"} [titleHalign="start"] The horizontal alignment of the section title. If the section is collapsible or nested, only start alignment is supported.
   * @property {Object=} titleStyle The CSS style object defining the style of the section title. The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @ojdeprecated {since: '14.1.0', description: 'Applications should use the expanded API on oj-legend instead.', target: 'property', for: 'expanded' }
   * @ojdeprecated {since: '15.1.0', description: 'Individual section title alignment is no longer supported. Use section-title-halign in oj-legend to align all section titles.', target: 'property', for: 'titleHalign' }
   * @ojdeprecated {since: '15.1.0', description: 'Individual section title style is no longer supported. Use section-title-style in oj-legend to style all section titles.', target: 'property', for: 'titleStyle' }
   * @ojdeprecated {since: '16.0.0', description: 'Collapsible legend sections are not recommended in the Redwood theme.', target: 'property', for: 'collapsible' }
   * @ojdeprecated {since: '18.0.0', description: 'Use of nested legend sections is not recommended in Redwood theme. As such, this attribute is deprecated.', target: 'property', for: 'sections' }
   * @ojsignature [{target: "Type", value: "K", for: "id"},
   *               {target: "Type", value: "Array.<oj.ojLegend.Item<K>>", for: "items", jsdocOverride: true},
   *               {target: "Type", value: "Array.<oj.ojLegend.Section<K>>", for: "sections", jsdocOverride: true},
   *               {target: "Type", value: "Partial<CSSStyleDeclaration>", for: "titleStyle", jsdocOverride: true},
   *               {target: "Type", value: "<K>", for: "genericTypeParameters"}]
   */

  /**
   * Object type that defines a chart data item.
   * @typedef {Object} oj.ojLegend.Item
   * @property {string=} borderColor The border color of the marker. Only applies if symbolType is "marker" or "lineWithMarker".
   * @property {Array.<string>=} categories An array of categories for the legend item. Legend items currently only support a single category. If no category is specified, this defaults to the id or text of the legend item.
   * @property {"hidden"|"visible"} [categoryVisibility="visible"] Defines whether the legend item corresponds to visible data items. A hollow symbol is shown if the value is "hidden".
   * @property {string=} color The color of the legend symbol (line or marker). When symbolType is "lineWithMarker", this attribute defines the line color and the markerColor attribute defines the marker color.
   * @property {"off"|"on"|"inherit"} [drilling="inherit"] Whether drilling is enabled on the legend item. Drillable objects will show a pointer cursor on hover and fire ojDrill event on click. To enable drilling for all legend items at once, use the drilling attribute in the top level.
   * @property {any=} id The id of the legend item, which is provided as part of the context for events fired by the legend. If not specified, the id defaults to the text of the legend item if a DataProvider is not being used. For the DataProvider case, the key for the node will be used as the id.
   * @property {"dashed"|"dotted"|"solid"} [lineStyle="solid"] The line style. Only applies when the symbolType is "line" or "lineWithMarker".
   * @property {number=} lineWidth The line width in pixels. Only applies when the symbolType is "line" or "lineWithMarker".
   * @property {string=} markerColor The color of the marker, if different than the line color. Only applies if the symbolType is "lineWithMarker".
   * @property {"circle"|"diamond"|"ellipse"|"human"|"plus"|"rectangle"|"square"|"star"|"triangleDown"|"triangleUp"|string} [markerShape="square"] The shape of the marker. Only applies if symbolType is "marker" or "lineWithMarker". Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
   * @property {string=} markerSvgClassName The CSS style class to apply to the marker. The style class and inline style will override any other styling specified through the options. For tooltips and hover interactivity, it's recommended to also pass a representative color to the markerColor attribute.
   * @property {Object=} markerSvgStyle The inline style to apply to the marker. The style class and inline style will override any other styling specified through the options. For tooltips and hover interactivity, it's recommended to also pass a representative color to the markerColor attribute. Only SVG CSS style properties are supported.
   * @property {"largeChecker"|"largeCrosshatch"|"largeDiagonalLeft"|"largeDiagonalRight"|"largeDiamond"|"largeTriangle"|"none"|"smallChecker"|"smallCrosshatch"|"smallDiagonalLeft"|"smallDiagonalRight"|"smallDiamond"|"smallTriangle"} [pattern="none"] The pattern used to fill the marker. Only applies if symbolType is "marker" or "lineWithMarker".
   * @property {string=} shortDesc The description of this legend item. This is used for accessibility and for customizing the tooltip text.
   * @property {string=} source The URI of the image of the legend symbol.
   * @property {string=} svgClassName The CSS style class to apply to the legend item. The style class and inline style will override any other styling specified through the options. For tooltips and hover interactivity, it's recommended to also pass a representative color to the color attribute.
   * @property {Object=} svgStyle The inline style to apply to the legend item. The style class and inline style will override any other styling specified through the options. For tooltips and hover interactivity, it's recommended to also pass a representative color to the color attribute. Only SVG CSS style properties are supported.
   * @property {"image"|"line"|"lineWithMarker"|"marker"} [symbolType="marker"] The type of legend symbol to display.
   * @property {string} text The legend item text.
   * @ojdeprecated [{since: '14.1.0', description: 'This is not recommended in the Redwood design system.', target: 'property', for: 'svgStyle'},
   *                {since: '14.1.0', description: 'This is not recommended in the Redwood design system.', target: 'property', for: 'svgClassName'},
   *                {since: '14.1.0', description: 'This is not recommended in the Redwood design system.', target: 'property', for: 'markerSvgClassName'},
   *                {since: '14.1.0', description: 'This is not recommended in the Redwood design system.', target: 'property', for: 'markerSvgStyle'},
   *                {since: '14.1.0', description: 'Use hidden-categories attribute of oj-legend instead.', target: 'property', for: 'categoryVisibility'}]
   * @ojsignature [{target: "Type", value: "K", for: "id"},
   *               {target: "Type", value: "Partial<CSSStyleDeclaration>", for: "svgStyle", jsdocOverride: true},
   *               {target: "Type", value: "Partial<CSSStyleDeclaration>", for: "markerSvgStyle", jsdocOverride: true},
   *               {target: "Type", value: "<K>", for: "genericTypeParameters"}]
   */

  // METHOD TYPEDEFS
  /**
   * @typedef {Object} oj.ojLegend.SectionContext
   * @ojtsignore
   * @property {string} title The title of the legend section.
   * @property {Array.<object>} sections Array of legend sections.
   * @property {Array.<object>} items Array of legend items.
   * @property {Function(number)} getSection Returns the section with the specified index.
   * @property {string} getSection.title The title of the legend section.
   * @property {string} getSection.sections Array of legend sections.
   * @property {boolean} getSection.items Array of legend items.
   * @property {Function(number)} getItems Returns the item with the specified index.
   * @property {string} getItems.text The text of the legend item.
   */

  /**
   * @typedef {Object} oj.ojLegend.ItemContext
   * @ojtsignore
   * @property {string} text The text of the legend item.
   */

  /**
   * @typedef {Object} oj.ojLegend.NodeContext
   * @property {number} itemIndex The index of the item within the specified section.
   * @property {Array.<number>} sectionIndexPath The array of numerical indices for the section.
   * @property {string} subId Sub-id string to identify this dom node.
   */

  /**
   * @typedef {Object} oj.ojLegend.PreferredSize
   * @property {number} width The available width.
   * @property {number} height The available height.
   */

  // Slots
  /**
   * <p>
   *  The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for
   *  creating items of the legend. The slot content must be wrapped in a &lt;template>
   *  element. The content of the template should be a single &lt;oj-legend-item> element.
   *  See the [oj-legend-item]{@link oj.ojLegendItem} doc for more details.
   * </p>
   * <p>
   *  When the template is executed for each area, it will have access to the components's
   *  binding context containing the following properties:
   * </p>
   * <ul>
   *   <li>
   *      $current - an object that contains information for the current node. (See [oj.ojLegend.ItemTemplateContext]{@link oj.ojLegend.ItemTemplateContext} or the table below for a list of properties available on $current)
   *   </li>
   *   <li>
   *      alias - if data-oj-as attribute was specified, the value will be used to provide an
   *      application-named alias for $current.
   *   </li>
   * </ul>
   *
   * @ojslot itemTemplate
   * @ojmaxitems 1
   * @memberof oj.ojLegend
   * @ojshortdesc The itemTemplate slot is used to specify the template for creating each legend item. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojLegend.ItemTemplateContext
   * @ojpreferredcontent ["LegendItemElement"]
   *
   * @example <caption>Initialize the legend with an inline item template specified:</caption>
   * &lt;oj-legend data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate'>
   *    &lt;oj-legend-item text='[[$current.data.text]]' color='[[$current.data.color]]'>
   *    &lt;/oj-legend-item>
   *  &lt;/template>
   * &lt;/oj-legend>
   */

  /**
   * @typedef {Object} oj.ojLegend.ItemTemplateContext
   * @property {Element} componentElement The &lt;oj-legend> custom element
   * @property {Object} data The data object of the node
   * @property {number} index The zero-based index of the current node
   * @property {any} key The key of the current node
   * @property {Array} parentData  An array of data objects of the outermost to innermost parents of the node
   * @property {any} parentKey  The key of the parent node
   * @ojsignature [{target:"Type", value:"<K = any, D = any>", for:"genericTypeParameters"},
   * {target:"Type", value:"D", for:"data", jsdocOverride: true},
   * {target:"Type", value:"K", for:"key", jsdocOverride: true},
   * {target:"Type", value:"K", for:"parentKey", jsdocOverride: true},
   * {target:"Type", value:"Array<D>", for:"parentData", jsdocOverride: true}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  /**
   * @typedef {Object} oj.ojLegend.SectionTemplateContext
   * @property {Element} componentElement The &lt;oj-legend> custom element
   * @property {Object} data The data object of the section node
   * @property {number} index The zero-based index of the current section node
   * @property {any} key The key of the current section node
   * @property {Array} parentData  An array of data objects of the outermost to innermost parents of the section node
   * @property {any} parentKey  The key of the parent section node
   * @ojsignature [{target:"Type", value:"<K = any, D = any>", for:"genericTypeParameters"},
   * {target:"Type", value:"D", for:"data", jsdocOverride: true},
   * {target:"Type", value:"K", for:"key", jsdocOverride: true},
   * {target:"Type", value:"K", for:"parentKey", jsdocOverride: true},
   * {target:"Type", value:"Array<D>", for:"parentData", jsdocOverride: true}]
   * @ojdeprecated {target:"property", for: "componentElement", since: "16.0.0", description: "The componentElement property is deprecated. This shouldn't be needed, as the component template with access to this context is unique to the component." }
   */

  /**
   * <p>
   *  The <code class="prettyprint">sectionTemplate</code> slot is used to specify the template for
   *  creating sections of the legend. The slot content must be wrapped in a &lt;template>
   *  element. The content of the template should be a single &lt;oj-legend-section> element.
   *  See the [oj-legend-section]{@link oj.ojLegendSection} doc for more details.
   * </p>
   * <p>
   *  When the template is executed for each area, it will have access to the components's
   *  binding context containing the following properties:
   * </p>
   * <ul>
   *   <li>
   *      $current - an object that contains information for the current node.
   *      (See the table below for a list of properties available on $current)
   *   </li>
   *   <li>
   *      alias - if data-oj-as attribute was specified, the value will be used to provide an
   *      application-named alias for $current.
   *   </li>
   * </ul>
   *
   * @ojslot sectionTemplate
   * @ojmaxitems 1
   * @memberof oj.ojLegend
   * @ojshortdesc The sectionTemplate slot is used to specify the template for creating each legend section. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojLegend.SectionTemplateContext
   * @ojpreferredcontent ["LegendSectionElement"]
   *
   * @example <caption>Initialize the legend with an inline item template specified:</caption>
   * &lt;oj-legend data='[[dataProvider]]'>
   *  &lt;template slot='sectionTemplate'>
   *    &lt;oj-legend-section  collapsible='on' expanded='[[$current.index == 0 ? "on" : "off"]]'>
   *    &lt;/oj-legend-section>
   *  &lt;/template>
   * &lt;/oj-legend>
   */

  // SubId Locators **************************************************************

  /**
   * <p>Sub-ID for legend items indexed by their section and item indices.</p>
   *
   * @property {Array} sectionIndexPath The array of numerical indices for the section.
   * @property {number} itemIndex The index of the item within the specified section.
   *
   * @ojsubid oj-legend-item
   * @memberof oj.ojLegend
   *
   * @example <caption>Get the second item in the first section:</caption>
   * var nodes = $( ".selector" ).ojLegend( "getNodeBySubId", {'subId': 'oj-legend-item', sectionIndexPath: [0], itemIndex: 1} );
   */

  /**
   * <p>Sub-ID for the the legend tooltip.</p>
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.</p>
   *
   * @ojsubid
   * @member
   * @name oj-legend-tooltip
   * @memberof oj.ojLegend
   * @instance
   *
   * @example <caption>Get the tooltip object of the legend, if displayed:</caption>
   * var nodes = $( ".selector" ).ojLegend( "getNodeBySubId", {'subId': 'oj-legend-tooltip'} );
   */
  // Node Context Objects ********************************************************

  /**
   * <p>Context for legend items indexed by their section and item indices.</p>
   *
   * @property {Array} sectionIndexPath The array of numerical indices for the section.
   * @property {number} itemIndex The index of the item within the specified section.
   *
   * @ojnodecontext oj-legend-item
   * @memberof oj.ojLegend
   */

  /**
   * @ojcomponent oj.ojLegend
   * @augments oj.dvtBaseComponent
   * @since 0.7.0
   * @ojimportmembers oj.ojSharedContextMenu
   * @ojshortdesc A legend displays an interactive description of symbols, colors, etc., used in graphical information representations.
   * @ojrole application
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
   * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["KeySet"]}
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojLegend<K, D extends oj.ojLegend.Item<K>|oj.ojLegend.Section<K>|any> extends dvtBaseComponent<ojLegendSettableProperties<K, D>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojLegendSettableProperties<K,  D extends oj.ojLegend.Item<K>|oj.ojLegend.Section<K>|any> extends dvtBaseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["orientation", "halign", "valign", "hoverBehavior", "style"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data"]}
   * @ojvbdefaultcolumns 2
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-legend'
   * @ojuxspecs ['legend']
   *
   * @classdesc
   * <h3 id="legendOverview-section">
   *   JET Legend
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#legendOverview-section"></a>
   * </h3>
   *
   * <p>A themable, WAI-ARIA compliant legend for JET.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-legend
   *  orientation='vertical'
   *  data='[[dataProvider]]'
   * >
   * &lt;/oj-legend>
   * </code>
   * </pre>
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * To make your component accessible, the application is required to include contextual information for screender readers using one or more the following methods as appropriate:
   *  <ul>
   *   <li>aria-describedby</li>
   *   <li>aria-labelledby</li>
   *   <li>aria-label</li>
   *   <li>short-desc property of your items</li>
   *  </ul>
   * <p>
   *  When setting color, applications are responsible for making sure that the color meets the
   * <a href="https://www.w3.org/TR/WCAG21/#non-text-contrast">minimum contrast ratio</a>.
   * </p>
   * <p>
   *  If your application has custom keyboard and touch shortcuts implemented for the component, these shortcuts can conflict with those of the component. It is the application's responsibility to disclose these custom shortcuts, possibly via a datatip or help popup.
   * </p>
   * <p>
   *  In the case of the text truncating, applications should provide the untruncated string or contextual text to the datatip to make the component accessible.
   * </p>
   *
   * {@ojinclude "name":"migrationDoc"}
   * To migrate from oj-legend-item to oj-c-legend-item, you need to revise the import statement and references to oj-legend-item in your app. Please note the changes between the two components below.
   * <h5> oj-legend-item's marker-shape attribute</h5>
   * <p>
   * marker-shape attribute only supports the built in shape enums. It does not support custom SVG path commands for a custom shape yet.
   * </p>
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * {@ojinclude "name":"rtl"}
   */

  oj.__registerWidget('oj.ojLegend', $.oj.dvtBaseComponent, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * An alias for the $current context variable passed to slot content for the nodeTemplate slot.
       * @expose
       * @name as
       * @memberof oj.ojLegend
       * @ojshortdesc An alias for the '$current' context variable passed to slot content for the nodeTemplate slot.
       * @instance
       * @type {string=}
       * @default ""
       * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
       */
      as: '',

      /**
       * The DataProvider for the sections and items of the legend. It should provide a data tree where each node in the data tree corresponds to a section or item in the legend.
       * Nodes that are leaves will be treated as items. The row key will be used as the id for legend sections and items. Note that when
       * using this attribute, a template for the <a href="#itemTemplate">itemTemplate</a> and optionally <a href="#sectionTemplate">sectionTemplate</a> slots should be provided.
       * The DataProvider can either have an arbitrary data shape, in which case an <oj-legend-item> element (and an <oj-legend-section> element for hierarchical
       * data) must be specified in the itemTemplate (and sectionTemplate) slot or it can have oj.ojLegend.Item{@link oj.ojLegend.Item}
       * (and oj.ojLegend.Section{@link oj.ojLegend.Section}) as its data shape, in which case no template is required.
       * @expose
       * @name data
       * @memberof oj.ojLegend
       * @ojshortdesc Specifies the DataProvider for the sections and items of the legend. See the Help documentation for more information.
       * @instance
       * @type {DataProvider|null}
       * @ojsignature {target: "Type", value: "DataProvider<K, D>|null", jsdocOverride:true}
       * @default null
       * @ojwebelementstatus {type: "unsupported", since: "13.0.0",
       *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
       *
       * @example <caption>Initialize the legend with the
       * <code class="prettyprint">data</code> attribute specified:</caption>
       * &lt;oj-legend data='[[dataProvider]]'>&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">data</code>
       * property after initialization:</caption>
       * // getter
       * var value = myLegend.data;
       *
       * // setter
       * myLegend.data = dataProvider;
       */
      data: null,

      /**
       * Whether drilling is enabled on all legend items. Drillable objects will show a pointer cursor on hover and fire <code class="prettyprint">ojDrill</code> event on click. To enable or disable drilling on individual legend item, use the drilling attribute in each legend item.
       * @expose
       * @name drilling
       * @memberof oj.ojLegend
       * @ojshortdesc Specifies whether drilling is enabled. Drillable objects will show a pointer cursor on hover and fire an ojDrill event on click. See the Help documentation for more information.
       * @instance
       * @type {string=}
       * @ojvalue {string} "on" Legend items will be drillable.
       * @ojvalue {string} "off" Legend items will not be drillable.
       * @default "off"
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">drilling</code> attribute specified:</caption>
       * &lt;oj-legend drilling="on">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">drilling</code> property after initialization:</caption>
       * // getter
       * var drillingValue = myLegend.drilling;
       *
       * // setter
       * myLegend.drilling = 'on';
       */
      drilling: 'off',

      /**
       * Specifies the key set containing the ids of sections that should be expanded on initial render.
       * Use the <a href="KeySetImpl.html">KeySetImpl</a> class to specify sections to expand.
       * Use the <a href="AllKeySetImpl.html">AllKeySetImpl</a> class to expand all sections.
       * By default, all sections are expanded.
       * @expose
       * @name expanded
       * @memberof oj.ojLegend
       * @ojshortdesc Specifies the key set containing the ids of sections that should be expanded on initial render. See the Help documentation for more information.
       * @ojdeprecated {since: '16.0.0', description: 'Collapsible legend sections are not recommended in the Redwood theme.'}
       * @instance
       * @type {(KeySet|null)=}
       * @ojsignature {target:"Type", value:"oj.KeySet<K>|null"}
       * @ojwriteback
       */
      /**
       * Defines the horizontal alignment of the legend contents.
       * @expose
       * @name halign
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "center" Legend contents will be center aligned.
       * @ojvalue {string} "end" Legend contents will be end aligned.
       * @ojvalue {string} "start" Legend contents will be start aligned.
       * @default "start"
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">halign</code> attribute specified:</caption>
       * &lt;oj-legend halign="center">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">halign</code> property after initialization:</caption>
       * // getter
       * var halignValue = myLegend.halign;
       *
       * // setter
       * myLegend.halign = "center";
       *
       */
      halign: 'start',

      /**
       * An array of categories that will be hidden.
       * @expose
       * @name hiddenCategories
       * @memberof oj.ojLegend
       * @instance
       * @type {Array.<string>=}
       * @default []
       * @ojwriteback
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">hidden-categories</code> attribute specified:</caption>
       * &lt;oj-legend hidden-categories='["Apples", "Bananas"]'>&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">hiddenCategories</code> property after initialization:</caption>
       * // Get one
       * var value = myLegend.hiddenCategories[0];
       *
       * // Get all
       * var hiddenCategoriesValue = myLegend.hiddenCategories;
       *
       * // setter
       * myLegend.hiddenCategories = ["Apples", "Bananas"];
       */
      hiddenCategories: [],

      /**
       * Defines whether the legend can be used to initiate hide and show behavior on referenced data items.
       * @expose
       * @name hideAndShowBehavior
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "on" Legend can be used to initiate hide and show behavior on referenced data items.
       * @ojvalue {string} "off" legend cannot be used to initiate hide and show behavior on referenced data items
       * @default "off"
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">hide-and-show-behavior</code> attribute specified:</caption>
       * &lt;oj-legend hide-and-show-behavior="on">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">hideAndShowBehavior</code> property after initialization:</caption>
       * // getter
       * var hideAndShowValue = myLegend.hideAndShowBehavior;
       *
       * // setter
       * myLegend.hideAndShowBehavior = 'on';
       */
      hideAndShowBehavior: 'off',

      /**
       * An array of categories that will be highlighted.
       * @expose
       * @name highlightedCategories
       * @memberof oj.ojLegend
       * @instance
       * @type {Array.<string>=}
       * @default []
       * @ojwriteback
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">highlighted-categories</code> attribute specified:</caption>
       * &lt;oj-legend highlighted-categories='["Bananas", "Apples"]'>&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">highlightedCategories</code> property after initialization:</caption>
       * // Get one
       * var value = myLegend.highlightedCategories[0];
       *
       * // getter
       * var highlightedCategoriesValue = myLegend.highlightedCategories;
       *
       * // setter
       * myLegend.highlightedCategories = ["Bananas", "Apples"];
       */
      highlightedCategories: [],

      /**
       * Defines the behavior applied when hovering over a legend item.
       * @expose
       * @name hoverBehavior
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "dim" Dimming hover behavior is applied.
       * @ojvalue {string} "none" No hover behavior will be applied.
       * @default "none"
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">hover-behavior</code> attribute specified:</caption>
       * &lt;oj-legend hover-behavior="dim">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">hoverBehavior</code> property after initialization:</caption>
       * // getter
       * var hoverBehaviorValue = myLegend.hoverBehavior;
       *
       * // setter
       * myLegend.hoverBehavior = 'dim';
       */
      hoverBehavior: 'none',

      /**
       * Specifies initial hover delay in ms for highlighting items in legend.
       * @expose
       * @name hoverBehaviorDelay
       * @memberof oj.ojLegend
       * @ojshortdesc Specifies initial hover delay in milliseconds for highlighting items in legend.
       * @instance
       * @type {number=}
       * @ojunits milliseconds
       * @ojmin 0
       * @default 200
       * @ojdeprecated {since: '14.1.0', description: 'This is not recommended in the Redwood design system.'}
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">hover-behavior-delay</code> attribute specified:</caption>
       * &lt;oj-legend hover-behavior-delay="150">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">hoverBehaviorDelay</code> property after initialization:</caption>
       * // getter
       * var delayValue = myLegend.hoverBehaviorDelay;
       *
       * // setter
       * myLegend.hoverBehaviorDelay = 150;
       */
      hoverBehaviorDelay: 200,

      /**
       * Defines the orientation of the legend, which determines the direction in which the legend items are laid out.
       * @expose
       * @name orientation
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "horizontal" Legend items will be horizontally placed in available space.
       * @ojvalue {string} "vertical" Legend items will be vertically stacked.
       * @default "vertical"
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">orientation</code> attribute specified:</caption>
       * &lt;oj-legend orientation="horizontal">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">orientation</code> property after initialization:</caption>
       * // getter
       * var orientationValue = myLegend.orientation;
       *
       * // setter
       * myLegend.orientation = "horizontal";
       */
      orientation: 'vertical',

      /**
       * Defines whether scrolling is enabled for the legend.
       * @expose
       * @name scrolling
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "off" The legend will not be scrollable.
       * @ojvalue {string} "asNeeded" The legend will be scrollable if legend items cannot fit in the available space.
       * @default "asNeeded"
       * @ojdeprecated {since: '12.1.0', description: 'Setting scrolling to off is not supported in the Redwood theme and it is not recommended.'}
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">scrolling</code> attribute specified:</caption>
       * &lt;oj-legend scrolling="off">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">scrolling</code> property after initialization:</caption>
       * // getter
       * var scrollingValue = myLegend.scrolling;
       *
       * // setter
       * myLegend.scrolling = 'off';
       *
       */
      scrolling: 'asNeeded',

      /**
       * An array of objects with the following properties defining the legend sections.
       * @expose
       * @ojtsignore
       * @name sections
       * @memberof oj.ojLegend
       * @ojshortdesc An array of objects specifying the legend sections.
       * @instance
       * @type {(Array.<Object>|null)=}
       * @ojsignature {target: "Accessor", value: {GetterType: "Promise<Array<oj.ojLegend.Section<K>>>|null",
       *                                           SetterType: "Array<oj.ojLegend.Section<K>>|Promise<Array<oj.ojLegend.Section<K>>>|null"},
       *                                           jsdocOverride: true}
       * @default null
       *
       * @example <caption>Initialize the legend with the
       * <code class="prettyprint">sections</code> attribute specified:</caption>
       * &lt;oj-legend sections='[{"title": "Brand", "expanded": "on", "collapsible": "on",
       *                        items: [{"color": "red", "text": "Coke", "id": "Coke"},
       *                                {"color": "blue", "text": "Pepsi", "id": "Pepsi"},
       *                                {"color": "yellow", "text": "Snapple", "id": "Snapple"},
       *                                {"color": "brown", "text": "Nestle", "id": "Nestle"}]}]'>
       * &lt;/oj-legend>
       *
       * &lt;oj-legend sections='[[sectionsPromise]]'>&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">sections</code>
       * property after initialization:</caption>
       * // Get one
       * var value = myLegend.sections[0];
       *
       * // Get all (The items getter always returns a Promise so there is no "get one" syntax)
       * var values = myLegend.sections;
       *
       * // Set all (There is no permissible "set one" syntax.)
       * myLegend.sections=[{title: "Brand", expanded: "on", collapsible: "on",
       *                     items: [{color: "red", text: "Coke", id: "Coke"},
       *                             {color: "blue", text: "Pepsi", id: "Pepsi"},
       *                             {color: "yellow", text: "Snapple", id: "Snapple"},
       *                             {color: "brown", text: "Nestle", id: "Nestle"}]}];
       */
      sections: null,

      /**
       * The height of the legend symbol (line or marker) in pixels. If the value is 0, it will take the same value as symbolWidth. If both symbolWidth and symbolHeight are 0, then it will use a default value that may vary based on theme.
       * @expose
       * @name symbolHeight
       * @memberof oj.ojLegend
       * @ojshortdesc The height of the legend symbol in pixels. See the Help documentation for more information.
       * @instance
       * @type {number=}
       * @ojunits pixels
       * @default 0
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">symbol-height</code> attribute specified:</caption>
       * &lt;oj-legend symbol-height="20">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">symbolHeight</code> property after initialization:</caption>
       * // getter
       * var symbolHeightValue = myLegend.symbolHeight;
       *
       * // setter
       * myLegend.symbolHeight = 20;
       */
      symbolHeight: 0,

      /**
       * The width of the legend symbol (line or marker) in pixels. If the value is 0, it will take the same value as symbolWidth. If both symbolWidth and symbolHeight are 0, then it will use a default value that may vary based on theme.
       * @expose
       * @name symbolWidth
       * @memberof oj.ojLegend
       * @ojshortdesc The width of the legend symbol in pixels. See the Help documentation for more information.
       * @instance
       * @type {number=}
       * @ojunits pixels
       * @default 0
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">symbol-width</code> attribute specified:</caption>
       * &lt;oj-legend symbol-width="15">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">symbolWidth</code> property after initialization:</caption>
       * // getter
       * var symbolWidthValue = myLegend.symbolWidth;
       *
       * // setter
       * myLegend.symbolWidth = 15;
       */
      symbolWidth: 0,

      /**
       * The CSS style object defining the style of the legend item text.
       * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
       * @expose
       * @name textStyle
       * @ojshortdesc The CSS style object defining the style of the legend item text.
       * @memberof oj.ojLegend
       * @instance
       * @type {Object=}
       * @default  {}
       * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">text-style</code> attribute specified:</caption>
       * &lt;oj-legend text-style='{"fontSize":"12px"}'>&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">textStyle</code> property after initialization:</caption>
       * // getter
       * var textStyleValue = myLegend.textStyle;
       *
       * // setter
       * myLegend.textStyle = {"fontSize" : "12px"};
       */
      textStyle: {},

      /**
       * Defines the vertical alignment of the legend contents.
       * @expose
       * @name valign
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "middle" The legend items will be middle aligned.
       * @ojvalue {string} "bottom" The legend items will be bottom aligned.
       * @ojvalue {string} "top" The legend items will be top aligned.
       * @default "top"
       *
       * @example <caption>Initialize the Legend with the <code class="prettyprint">valign</code> attribute specified:</caption>
       * &lt;oj-legend valign="middle">&lt;/oj-legend>
       *
       * @example <caption>Get or set the <code class="prettyprint">valign</code> property after initialization:</caption>
       * // getter
       * var valignValue = myLegend.valign;
       *
       * // setter
       * myLegend.valign = "middle";
       */
      valign: 'top',

      // EVENTS

      /**
       * Triggered during a drill gesture (single click on the legend item).
       * @property {any} id the id of the drilled object
       *
       * @expose
       * @event
       * @memberof oj.ojLegend
       * @instance
       */
      drill: null,

      /**
       * Defines whether the element will automatically render in response to
       * changes in size. If set to <code class="prettyprint">off</code>, then the
       * application is responsible for calling <code class="prettyprint">refresh</code>
       * to render the element at the new size.
       * @expose
       * @name trackResize
       * @ojshortdesc Defines whether the element will automatically render in response to changes in size. See the Help documentation for more information.
       * @memberof oj.ojLegend
       * @instance
       * @type {string}
       * @ojvalue {string} "on"
       * @ojvalue {string} "off"
       * @default "on"
       * @ojdeprecated {since: '15.0.0', description: 'This is no longer needed due to performance enhancements. The default behavior will be used.'}
       * @example <caption>Initialize the data visualization element with the
       * <code class="prettyprint">track-resize</code> attribute specified:</caption>
       * &lt;oj-some-dvt track-resize='off'>&lt;/oj-some-dvt>
       *
       * @example <caption>Get or set the <code class="prettyprint">trackResize</code>
       * property after initialization:</caption>
       * // getter
       * var value = myComponent.trackResize;
       *
       * // setter
       * myComponent.trackResize="off";
       */
      trackResize: 'on',

      /**
       * The CSS style object defining the style of the section titles' text.
       * The following style properties are supported: color, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
       * @expose
       * @name sectionTitleStyle
       * @ojshortdesc The CSS style object defining the style of the section titles' text.
       * @memberof oj.ojLegend
       * @instance
       * @type {Object=}
       * @default  {}
       * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
       */
      sectionTitleStyle: {},

      /**
       * The horizontal alignment of the section titles.
       * @expose
       * @name sectionTitleHalign
       * @ojshortdesc The horizontal alignment of the section titles.
       * @memberof oj.ojLegend
       * @instance
       * @type {string=}
       * @ojvalue {string} "center" The section title will be center aligned.
       * @ojvalue {string} "end" The section title will be end aligned.
       * @ojvalue {string} "start" The section title will be start aligned.
       */
      sectionTitleHalign: 'start'
    },

    _CreateDvtComponent: function (context, callback, callbackObj) {
      return new ojlegendToolkit.Legend(context, callback, callbackObj);
    },

    _InitOptions: function (originalDefaults, constructorOptions) {
      this._super(originalDefaults, constructorOptions);

      // expanded property is dynamically generated
      // so we need to retrieve it here and override the dynamic getter by
      // setting the returned object as the new value.
      var expanded = this.options.expanded;
      this.options.expanded = expanded;
    },

    _ConvertLocatorToSubId: function (locator) {
      var subId = locator.subId;

      if (subId === 'oj-legend-item') {
        // section[sectionIndex0][sectionIndex1]...[sectionIndexN]:item[itemIndex]
        subId = 'section' + this._GetStringFromIndexPath(locator.sectionIndexPath);
        subId += ':item[' + locator.itemIndex + ']';
      } else if (subId === 'oj-legend-tooltip') {
        subId = 'tooltip';
      }
      // Return the converted result or the original subId if a supported locator wasn't recognized. We will remove
      // support for the old subId syntax in 1.2.0.
      return subId;
    },

    _ConvertSubIdToLocator: function (subId) {
      var locator = {};

      if (subId.indexOf(':item') > 0) {
        // section[sectionIndex0][sectionIndex1]...[sectionIndexN]:item[itemIndex]
        var itemStartIndex = subId.indexOf(':item');
        var sectionSubstr = subId.substring(0, itemStartIndex);
        var itemSubstr = subId.substring(itemStartIndex);

        locator.subId = 'oj-legend-item';
        locator.sectionIndexPath = this._GetIndexPath(sectionSubstr);
        locator.itemIndex = this._GetFirstIndex(itemSubstr);
      } else if (subId === 'tooltip') {
        locator.subId = 'oj-legend-tooltip';
      }
      return locator;
    },

    _GetComponentStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses.push('oj-legend');
      return styleClasses;
    },

    _GetChildStyleClasses: function () {
      var styleClasses = this._super();

      // Should be kept in sync with chart DvtLegend
      styleClasses['oj-legend'] = { path: 'textStyle', property: 'TEXT' };
      styleClasses['oj-legend-section-title'] = { path: '_sectionTitleStyle', property: 'TEXT' };
      styleClasses['oj-legend-hover'] = { path: '_hoverBorderRadius', property: 'border-radius' };
      return styleClasses;
    },

    _GetEventTypes: function () {
      return ['drill', 'expand', 'collapse'];
    },

    _HandleEvent: function (event) {
      var type = event.type;
      if (type === 'drill') {
        this._trigger('drill', null, { id: event.id });
      } else if (type === 'expand' || type === 'collapse') {
        this._UserOptionChange('expanded', event.expanded);
      } else {
        this._super(event);
      }
    },

    _RemoveKeys: function (removedKeys) {
      this._super(removedKeys);
      var expandedChanged;
      var expanded = this.options.expanded;
      if (expanded && !expanded.isAddAll()) {
        removedKeys.forEach(function (keyValue) {
          if (expanded.has(keyValue)) {
            expanded = expanded.delete([keyValue]);
            expandedChanged = true;
          }
        });
        if (expandedChanged) {
          this._UserOptionChange('expanded', expanded);
        }
      }
    },

    _LoadResources: function () {
      // Ensure the resources object exists
      if (this.options._resources == null) {
        this.options._resources = {};
      }

      var resources = this.options._resources;

      // Add images
      var rtl = this._GetReadingDirection() === 'rtl';
      resources.closed = `oj-fwk-icon oj-fwk-icon-arrow-${rtl ? 'w' : 'e'}`;
      resources.open = `oj-fwk-icon oj-fwk-icon-arrow-${rtl ? 'sw' : 'se'}`;
    },

    _GetSimpleDataProviderConfigs: function () {
      var templateName = function (data) {
        if (data && data.children) {
          return 'sectionTemplate';
        }
        return 'itemTemplate';
      };
      var templateElementName = function (data) {
        if (data && data.children) {
          return 'oj-legend-section';
        }
        return 'oj-legend-item';
      };
      var processChildrenData = function (processedParentData, parentData, childrenData) {
        // eslint-disable-next-line no-param-reassign
        processedParentData.sections = [];
        // eslint-disable-next-line no-param-reassign
        processedParentData.items = [];
        for (var j = 0; j < childrenData.length; j++) {
          var childData = childrenData[j];
          var nodeData = parentData.children[j];
          if (nodeData.children) {
            processedParentData.sections.push(childData);
          } else {
            processedParentData.items.push(childData);
          }
        }
      };
      var getAliasedPropertyNames = function (elementName) {
        if (elementName === 'oj-legend-section') {
          return { text: 'title', textHalign: 'titleHalign', textStyle: 'titleStyle' };
        }
        return {};
      };
      var processOptionData = function (optionData) {
        var result = { sections: [], items: [] };
        for (var i = 0; i < optionData.length; i++) {
          if (optionData[i].items || optionData[i].sections) {
            result.sections.push(optionData[i]);
          } else {
            result.items.push(optionData[i]);
          }
        }
        return result.items.length > 0 ? [result] : optionData;
      };

      return {
        data: {
          templateName: templateName,
          templateElementName: templateElementName,
          resultPath: 'sections',
          getAliasedPropertyNames: getAliasedPropertyNames,
          processChildrenData: processChildrenData,
          expandedKeySet: new ojkeyset.AllKeySetImpl(), // if this becomes dynamic see example in ojsunburst
          processOptionData: processOptionData
        }
      };
    },

    _Render: function () {
      this._super();
    },

    /**
     * Returns the legend title for automation testing verification.
     * @return {String} The legend title
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @instance
     * @memberof oj.ojLegend
     * @ignore
     */
    getTitle: function () {
      var auto = this._component.getAutomation();
      return auto.getTitle();
    },

    /**
       * Returns an object with the following properties for automation testing verification of the legend section with
       * the specified subid path.
       *
       * @param {Array} subIdPath The array of indices in the subId for the desired legend section.
       * @ojsignature {target: "Type", value: "oj.ojLegend.SectionContext|null", jsdocOverride: true, for: "returns"}
       * @return {Object|null} An object containing properties for the legend section at the given subIdPath, or null if
       *   none exists.
       * @example <caption>Initialize Legend and get items using the <code class="prettyprint">getItem(index)</code> method:</caption>
       * // Returns {title: null, items: [{text: "line"}, {text: "lineWithMarker"}, {text: "marker"}, {text: "marker with pattern fill"}, {text: "image"}], sections: null, getSection: function, getItem: function}
       * &lt;oj-legend id="legend1" sections='[{items: [{"text": "line", "symbolType": "line", "color": "#267db3"},
       {"text": "lineWithMarker", "symbolType": "lineWithMarker", "markerShape": "diamond", "color": "#68c182", "markerColor": "#efdd14", "borderColor": "#68c182"},
       {"text": "marker", "symbolType": "marker", "markerShape": "human", color: "#fad55c"},
       {"text": "marker with pattern fill", "symbolType": "marker", "markerShape": "circle", "color": "#ed6647", "pattern": "smallDiamond"},
       {"text": "image", "symbolType": "image", "source": "css/samples/cookbook/images/dvt/appServer.png"}]}]'>&lt;/oj-legend>
       *  var legend = document.getElementById('legend1');
       *  var section = legend.getSection([0]);
       * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
       * @ojtsignore
       * @instance
       * @memberof oj.ojLegend
       * @ojshortdesc Returns information for automation testing verification of a specified legend section.
       */
    getSection: function (subIdPath) {
      var ret = this._component.getAutomation().getSection(subIdPath);
      if (ret) {
        // Support for getSection(sectionIndex)
        ret.getSection = function (sectionIndex) {
          return ret.sections ? ret.sections[sectionIndex] : null;
        };

        // Support for getSection(itemIndex)
        ret.getItem = function (itemIndex) {
          return ret.items ? ret.items[itemIndex] : null;
        };
      }
      return ret;
    },

    /**
       * Returns an object with the following properties for automation testing verification of the legend item with
       * the specified subid path.
       *
       * @param {Array} subIdPath The array of indices in the subId for the desired legend item.
       * @ojsignature {target: "Type", value: "oj.ojLegend.ItemContext|null", jsdocOverride: true, for: "returns"}
       * @return {Object|null} An object containing properties for the legend item at the given subIdPath, or null if
       *   none exists.
       * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
       * @ojtsignore
       * @instance
       * @example <caption>Initialize Legend and get items using the <code class="prettyprint">getItem(index)</code> method:</caption>
       * // Returns {text: "line"}
       * &lt;oj-legend id="legend1" sections='[{items: [{"text": "line", "symbolType": "line", "color": "#267db3"},
       {"text": "lineWithMarker", "symbolType": "lineWithMarker", "markerShape": "diamond", "color": "#68c182", "markerColor": "#efdd14", "borderColor": "#68c182"},
       {"text": "marker", "symbolType": "marker", "markerShape": "human", color: "#fad55c"},
       {"text": "marker with pattern fill", "symbolType": "marker", "markerShape": "circle", "color": "#ed6647", "pattern": "smallDiamond"},
       {"text": "image", "symbolType": "image", "source": "css/samples/cookbook/images/dvt/appServer.png"}]}]'>&lt;/oj-legend>
       *  var legend = document.getElementById('legend1');
       *  var item = legend.getItem([0, 0]);
       * @memberof oj.ojLegend
       * @ojshortdesc Returns information for automation testing verification of a specified legend item.
       */
    getItem: function (subIdPath) {
      return this._component.getAutomation().getItem(subIdPath);
    },

    /**
     * Returns the preferred size of the legend, given the available width and height.
     * @param {number} width The available width for the legend to render within.
     * @param {number} height The available height for the legend to render within.
     * @ojsignature {target: "Type", value: "oj.ojLegend.PreferredSize|null", jsdocOverride: true, for: "returns"}
     * @return {Object} An object containing the preferred width and height.
     * @expose
     * @instance
     * @memberof oj.ojLegend
     */
    getPreferredSize: function (width, height) {
      // Check if the options has a promise.
      var hasPromise = false;
      if (this.options.data && this._DataProviderHandler.isDataProvider(this.options.data)) {
        hasPromise = true;
      } else {
        var legendSections = this.options.sections ? this.options.sections : [];
        for (var i = 0; i < legendSections.length; i++) {
          var items = legendSections[i].items;
          if (items && items.then) {
            hasPromise = true;
          }
        }
      }

      // If the options has a promise, then use the last options to be rendered rather
      // than passing in a promise that can't be dealt with here. This won't work if the
      // data is provided via a promise and not yet rendered, but this problem will go
      // away once we have flowing layout.
      var options = hasPromise ? null : this.options;
      var dims = this._component.getPreferredSize(options, width, height);
      return { width: dims.w, height: dims.h };
    },

    /**
     * {@ojinclude "name":"nodeContextDoc"}
     * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
     * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
     * @ojsignature {target: "Type", value: "oj.ojLegend.NodeContext|null", jsdocOverride: true, for: "returns"}
     *
     * @example {@ojinclude "name":"nodeContextExample"}
     *
     * @expose
     * @instance
     * @memberof oj.ojLegend
     * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
     */
    getContextByNode: function (node) {
      // context objects are documented with @ojnodecontext
      var context = this.getSubIdByNode(node);
      if (context && context.subId !== 'oj-legend-tooltip') {
        return context;
      }

      return null;
    },

    _GetComponentDeferredDataPaths: function () {
      return { sections: ['items'], root: ['data'] };
    },

    _GetComponentNoClonePaths: function () {
      var noClonePaths = this._super();
      noClonePaths.sections = { items: true };
      return noClonePaths;
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojLegend
     */
    _GetTranslationsSectionName: function () {
      return 'oj-ojLegend';
    }
  });

  // Conditionally set the defaults for custom element vs widget syntax since we expose different APIs
  Components.setDefaultOptions({
    ojLegend: {
      expanded: Components.createDynamicPropertyGetter(function (context) {
        if (context.isCustomElement && context.element.getAttribute('data')) {
          return new ojkeyset.AllKeySetImpl();
        }
        return null;
      })
    }
  });

  /**
   * @ojcomponent oj.ojLegendItem
   * @ojshortdesc The oj-legend-item element is used to declare properties for legend items. See the Help documentation for more information.
   * @ojsignature {target: "Type", value:"class ojLegendItem extends JetElement<ojLegendItemSettableProperties>"}
   * @ojslotcomponent
   * @ojsubcomponenttype data
   * @since 6.0.0
   *
   *
   * @classdesc
   * <h3 id="overview">
   *   JET Legend Item
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h3>
   *
   * <p>
   *  The oj-legend-item element is used to declare properties for legend items and is only valid as the
   *  child of a template element for the [itemTemplate]{@link oj.ojLegend#itemTemplate}
   *  slot of oj-legend.
   * </p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-legend data='[[dataProvider]]'>
   *  &lt;template slot='itemTemplate'>
   *    &lt;oj-legend-item  text='[[$current.data.text]]' color='[[$current.data.color]]'>
   *    &lt;/oj-legend-item>
   *  &lt;/template>
   * &lt;/oj-legend>
   * </code>
   * </pre>
   *
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * To migrate from oj-legend-item to oj-c-legend-item, you need to revise the import statement and references to oj-legend-item in your app. Please note the changes between the two components below.
   * <h5>pattern attribute</h5>
   * <p>
   * For the inital versions of oj-c-legend and oj-c-legend-item, pattern is not supported. We plan on supporting it in future releases.
   * </p>
   * <h5>drilling attribute</h5>
   * <p>
   * For the initial version of oj-c-legend-item, drilling is not supported. We plan on supporting it in future releases.
   * </p>
   * <h5> marker-shape attribute</h5>
   * <p>
   * marker-shape attribute only supports the built in shape enums. It does not support custom SVG path commands for a custom shape yet.
   * </p>
   */

  /**
   * The legend item text.
   * @expose
   * @name text
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string}
   * @default ""
   */
  /**
   * An array of categories for the legend item. Legend items currently only support a single category.
   * @expose
   * @name categories
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {Array.<string>=}
   * @default []
   */
  /**
   * The type of legend symbol to display.
   * @expose
   * @name symbolType
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojvalue {string} "line" The legend symbol will be a line.
   * @ojvalue {string} "lineWithMarker" The legend symbol will be a line and a marker.
   * @ojvalue {string} "image" The legend symbol will be an image.
   * @ojvalue {string} "marker" The legend symbol will be a marker.
   * @default "marker"
   */
  /**
   * The URI of the image of the legend symbol.
   * @expose
   * @name source
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @default ""
   */
  /**
   * The color of the legend symbol (line or marker). When symbolType is "lineWithMarker", this attribute defines the line color and the markerColor attribute defines the marker color.
   * @expose
   * @name color
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojformat color
   */
  /**
   * The border color of the marker. Only applies if symbolType is "marker" or "lineWithMarker".
   * @expose
   * @name borderColor
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojformat color
   * @default ""
   */
  /**
   * The pattern used to fill the marker. Only applies if symbolType is "marker" or "lineWithMarker".
   * @expose
   * @name pattern
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojvalue {string} "smallChecker" Small checker pattern is applied to the data item.
   * @ojvalue {string} "smallCrosshatch" Small cross hatch pattern is applied to the data item.
   * @ojvalue {string} "smallDiagonalLeft" Small diagonal left pattern is applied to the data item.
   * @ojvalue {string} "smallDiagonalRight" Small diagonal right pattern is applied to the data item.
   * @ojvalue {string} "smallDiamond" Small diamond pattern is applied to the data item.
   * @ojvalue {string} "smallTriangle" Small triangle pattern is applied to the data item.
   * @ojvalue {string} "largeChecker" Large checker pattern is applied to the data item.
   * @ojvalue {string} "largeCrosshatch" Large cross hatch pattern is applied to the data item.
   * @ojvalue {string} "largeDiagonalLeft" Large diagonal left pattern is applied to the data item.
   * @ojvalue {string} "largeDiagonalRight" Large diagonal right pattern is applied to the data item.
   * @ojvalue {string} "largeDiamond" Large diamond pattern is applied to the data item.
   * @ojvalue {string} "largeTriangle" Large triangle pattern is applied to the data item.
   * @ojvalue {string} "none" No pattern is applied to data item fill.
   * @default "none"
   */
  /**
   * The line style. Only applies when the symbolType is "line" or "lineWithMarker".
   * @expose
   * @name lineStyle
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojvalue {string} "dotted" Line will have dotted strokes.
   * @ojvalue {string} "dashed" Line will have dashed strokes.
   * @ojvalue {string} "solid" Line will have a solid stroke.
   * @default "solid"
   */
  /**
   * The line width in pixels. Only applies when the symbolType is "line" or "lineWithMarker".
   * @expose
   * @name lineWidth
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {number=}
   */
  /**
   * The CSS style class to apply to the legend item symbol. This style class and <code> svg-style </code> will override any other styling specified through the options except for <code>marker-svg-style</code> and <code>marker-svg-class-name</code>.
   * For tooltips and hover interactivity, it's recommended to also pass a representative color to the color attribute.
   * @expose
   * @name svgClassName
   * @memberof! oj.ojLegendItem
   * @ojshortdesc The CSS style class to apply to the legend item. The style class and inline style will override any other styling specified through the options. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @default ""
   * @ojdeprecated {since: '14.1.0', description: 'This is not recommended in the Redwood design system.'}
   */
  /**
   * The inline style to apply to the legend item symbol. This inline style and <code> svg-class-name </code> will override any other styling specified through the options except for <code>marker-svg-style</code> and <code>marker-svg-class-name</code>.
   * For tooltips and hover interactivity, it's recommended to also pass a representative color to the color attribute.
   * Only SVG CSS style properties are supported.
   * @expose
   * @name svgStyle
   * @memberof! oj.ojLegendItem
   * @ojshortdesc The inline style to apply to the legend item. The style class and inline style will override any other styling specified through the options. See the Help documentation for more information.
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @ojdeprecated {since: '14.1.0', description: 'This is not recommended in the Redwood design system.'}
   */
  /**
   * The CSS style class to apply to the marker of the legend item symbol. This style class and <code> marker-svg-style </code> will override any other styling specified for the marker. For tooltips and hover interactivity, it's recommended to also pass a representative color to the markerColor attribute.
   * @expose
   * @name markerSvgClassName
   * @memberof! oj.ojLegendItem
   * @ojshortdesc The CSS style class to apply to the marker. The style class and inline style will override any other styling specified through the options. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @default ""
   * @ojdeprecated {since: '14.1.0', description: 'This is not recommended in the Redwood design system.'}
   */
  /**
   * The inline style to apply to the marker of the legend item symbol. This inline style and <code> marker-svg-class-name </code> will override any other styling specified for the marker. For tooltips and hover interactivity, it's recommended to also pass a representative color to the markerColor attribute.
   * Only SVG CSS style properties are supported.
   * @expose
   * @name markerSvgStyle
   * @memberof! oj.ojLegendItem
   * @ojshortdesc The inline style to apply to the marker. The style class and inline style will override any other styling specified through the options. See the Help documentation for more information.
   * @instance
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @ojdeprecated {since: '14.1.0', description: 'This is not recommended in the Redwood design system.'}
   */
  /**
   * The shape of the marker. Only applies if symbolType is "marker" or "lineWithMarker". Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
   * @expose
   * @name markerShape
   * @memberof! oj.ojLegendItem
   * @ojshortdesc The shape of the marker. Only applies if symbolType is "marker" or "lineWithMarker". See the Help documentation for more information.
   * @instance
   * @type {("circle"|"diamond"|"ellipse"|"human"|"plus"|"rectangle"|"square"|"star"|"triangleDown"|"triangleUp"|string)=}
   * @default "square"
   */
  /**
   * The color of the marker, if different than the line color. Only applies if the symbolType is "lineWithMarker".
   * @expose
   * @name markerColor
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojformat color
   */
  /**
   * Defines whether the legend item corresponds to visible data items. A hollow symbol is shown if the value is "hidden".
   * @expose
   * @name categoryVisibility
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @ojvalue {string} "hidden" Legend item will have a hollow symbol.
   * @ojvalue {string} "visible" Legend item will be filled.
   * @default "visible"
   * @ojdeprecated {since: '14.1.0', description: 'Use hidden-categories on oj-legend instead'}
   */
  /**
   *  Whether drilling is enabled on the legend item. Drillable objects will show a pointer cursor on hover and fire <code class="prettyprint">ojDrill</code> event on click. To enable drilling for all legend items at once, use the drilling attribute in the top level.
   * @expose
   * @name drilling
   * @memberof! oj.ojLegendItem
   * @ojshortdesc Specifies whether drilling is enabled on the legend item. See the Help documentation for more information.
   * @instance
   * @type {string=}
   * @ojvalue {string} "on" The legend item will be drillable.
   * @ojvalue {string} "off" The legend item will not be drillable.
   * @ojvalue {string} "inherit" The drilling behavior is inherited from legend.
   * @default "inherit"
   */
  /**
   * The description of this legend item. This is used for accessibility and for customizing the tooltip text.
   * @expose
   * @name shortDesc
   * @memberof! oj.ojLegendItem
   * @instance
   * @type {string=}
   * @default ""
   */

  /**
   * @ojcomponent oj.ojLegendSection
   * @ojshortdesc The oj-legend-section element is used to declare properties for legend sections. See the Help documentation for more information.
   * @ojsignature {target: "Type", value:"class ojLegendSection extends JetElement<ojLegendSectionSettableProperties>"}
   * @ojslotcomponent
   * @ojsubcomponenttype data
   * @since 6.0.0
   *
   *
   * @classdesc
   * <h3 id="overview">
   *   JET Legend Section
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
   * </h3>
   *
   * <p>
   *  The oj-legend-section element is used to declare properties for legend sections and is only valid as the
   *  child of a template element for the [sectionTemplate]{@link oj.ojLegend#sectionTemplate}
   *  slot of oj-legend.
   * </p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-legend data='[[dataProvider]]'>
   *  &lt;template slot='sectionTemplate'>
   *    &lt;oj-legend-section  collapsible='on' expanded='[[$current.index == 0 ? "on" : "off"]]'>
   *    &lt;/oj-legend-section>
   *  &lt;/template>
   * &lt;/oj-legend>
   * </code>
   * </pre>
   *
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * To migrate from oj-legend-section to oj-c-legend-section, you need to revise the import statement and references to oj-legend-section in your app. Please note the changes between the two components below.
   * <h5>collapsible attribute</h5>
   * <p>
   * For the initial versions of oj-c-legend and oj-c-legend-section, collapsible attribute is not supported.
   * </p>
   * <h5>sectionTemplate slot</h5>
   * <p>
   * For the initial version of oj-c-legend, nested section is not supported. $current of sectionTemplate context will not contain parentKey and parentData properties.
   * </p>
   */

  /**
   * The title of the legend section.
   * @expose
   * @name text
   * @memberof! oj.ojLegendSection
   * @instance
   * @type {string=}
   * @default ""
   */
  /**
   * The horizontal alignment of the section title. If the section is collapsible or nested, only start alignment is supported.
   * @expose
   * @name textHalign
   * @memberof! oj.ojLegendSection
   * @instance
   * @ojdeprecated {since: '15.1.0', description: 'Individual section title alignment is no longer supported. Use section-title-halign in oj-legend to align all section titles'}
   * @type {string=}
   * @ojvalue {string} "center" The section title will be center aligned.
   * @ojvalue {string} "end" The section title will be end aligned.
   * @ojvalue {string} "start" The section title will be start aligned.
   */
  /**
   * The CSS style object defining the style of the section title.
   * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
   * @expose
   * @name textStyle
   * @memberof! oj.ojLegendSection
   * @instance
   * @ojdeprecated {since: '15.1.0', description: 'Individual section title style is no longer supported. Use section-title-style in oj-legend to style all section titles'}
   * @type {Object=}
   * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
   * @default {}
   */
  /**
   * Whether the section is collapsible. Only applies if the legend orientation is vertical.
   * @expose
   * @name collapsible
   * @memberof! oj.ojLegendSection
   * @instance
   * @type {string=}
   * @ojdeprecated {since: '16.0.0', description: 'Collapsible legend sections are not recommended in the Redwood theme.'}
   * @ojvalue {string} "on" The legend section will be collapsible.
   * @ojvalue {string} "off" The legend section will not be collapsible.
   * @default "off"
   */

});


define('ojs/ojgauge',['ojs/ojcomponentcore', 'ojs/ojcore-base', 'ojs/ojdvt-base', 'jquery', 'ojs/ojlogger', 'ojs/ojconverterutils-i18n', 'ojs/ojconverter-number', 'ojs/ojlabelledbyutils', 'ojs/ojgauge-toolkit'], function (ojcomponentcore, oj, DvtAttributeUtils, $, Logger, ConverterUtils, NumberConverter, LabelledByUtils, ojgaugeToolkit) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  DvtAttributeUtils = DvtAttributeUtils && Object.prototype.hasOwnProperty.call(DvtAttributeUtils, 'default') ? DvtAttributeUtils['default'] : DvtAttributeUtils;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  LabelledByUtils = LabelledByUtils && Object.prototype.hasOwnProperty.call(LabelledByUtils, 'default') ? LabelledByUtils['default'] : LabelledByUtils;

  /**
   * Ignore tag only needed for DVTs that have jsDoc in separate _doc.js files.
   * @ignore
   */
var __oj_led_gauge_metadata = 
{
  "properties": {
    "borderColor": {
      "type": "string"
    },
    "color": {
      "type": "string"
    },
    "label": {
      "type": "object",
      "properties": {
        "style": {
          "type": "object",
          "value": {}
        },
        "text": {
          "type": "string",
          "value": ""
        }
      }
    },
    "markerSize": {
      "type": "string",
      "enumValues": [
        "fit",
        "lg",
        "md",
        "sm"
      ],
      "value": "fit"
    },
    "max": {
      "type": "number",
      "value": 100
    },
    "metricLabel": {
      "type": "object",
      "properties": {
        "converter": {
          "type": "object"
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "off",
            "on"
          ],
          "value": "off"
        },
        "scaling": {
          "type": "string",
          "enumValues": [
            "auto",
            "billion",
            "million",
            "none",
            "quadrillion",
            "thousand",
            "trillion"
          ],
          "value": "auto"
        },
        "style": {
          "type": "object",
          "value": {}
        },
        "text": {
          "type": "string",
          "value": ""
        },
        "textType": {
          "type": "string",
          "enumValues": [
            "number",
            "percent"
          ],
          "value": "number"
        }
      }
    },
    "min": {
      "type": "number",
      "value": 0
    },
    "rotation": {
      "type": "number",
      "enumValues": [
        "0",
        "180",
        "270",
        "90"
      ],
      "value": 0
    },
    "size": {
      "type": "number",
      "value": 1
    },
    "svgClassName": {
      "type": "string",
      "value": ""
    },
    "svgStyle": {
      "type": "object",
      "value": {}
    },
    "thresholds": {
      "type": "Array<Object>",
      "value": []
    },
    "tooltip": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        }
      }
    },
    "trackResize": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "on"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleContainsControls": {
          "type": "string"
        },
        "componentName": {
          "type": "string"
        },
        "labelAndValue": {
          "type": "string"
        },
        "labelClearSelection": {
          "type": "string"
        },
        "labelCountWithTotal": {
          "type": "string"
        },
        "labelDataVisualization": {
          "type": "string"
        },
        "labelInvalidData": {
          "type": "string"
        },
        "labelNoData": {
          "type": "string"
        },
        "stateCollapsed": {
          "type": "string"
        },
        "stateDrillable": {
          "type": "string"
        },
        "stateExpanded": {
          "type": "string"
        },
        "stateHidden": {
          "type": "string"
        },
        "stateIsolated": {
          "type": "string"
        },
        "stateMaximized": {
          "type": "string"
        },
        "stateMinimized": {
          "type": "string"
        },
        "stateSelected": {
          "type": "string"
        },
        "stateUnselected": {
          "type": "string"
        },
        "stateVisible": {
          "type": "string"
        }
      }
    },
    "type": {
      "type": "string",
      "value": "circle"
    },
    "value": {
      "type": "number",
      "writeback": true
    },
    "visualEffects": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getMetricLabel": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_led_gauge_metadata:false */

  (function () {
    __oj_led_gauge_metadata.extension._WIDGET_NAME = 'ojLedGauge';
    // Supported marker shapes for gauges
    var _LED_GAUGE_SHAPE_ENUMS = {
      arrow: true,
      square: true,
      rectangle: true,
      circle: true,
      diamond: true,
      triangle: true,
      human: true,
      star: true
    };
    oj.CustomElementBridge.register('oj-led-gauge', {
      metadata: __oj_led_gauge_metadata,
      parseFunction: DvtAttributeUtils.shapeParseFunction({ type: true }, _LED_GAUGE_SHAPE_ENUMS)
    });
  })();

var __oj_rating_gauge_metadata = 
{
  "properties": {
    "changed": {
      "type": "boolean",
      "writeback": true,
      "value": false
    },
    "changedState": {
      "type": "object",
      "properties": {
        "borderColor": {
          "type": "string",
          "value": ""
        },
        "color": {
          "type": "string"
        },
        "shape": {
          "type": "string",
          "value": "star"
        },
        "source": {
          "type": "string",
          "value": ""
        },
        "svgClassName": {
          "type": "string",
          "value": ""
        },
        "svgStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "hoverState": {
      "type": "object",
      "properties": {
        "borderColor": {
          "type": "string",
          "value": ""
        },
        "color": {
          "type": "string"
        },
        "shape": {
          "type": "string",
          "value": "star"
        },
        "source": {
          "type": "string",
          "value": ""
        },
        "svgClassName": {
          "type": "string",
          "value": ""
        },
        "svgStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "labelledBy": {
      "type": "string"
    },
    "max": {
      "type": "number",
      "value": 5
    },
    "min": {
      "type": "number",
      "value": 0
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "horizontal"
    },
    "preserveAspectRatio": {
      "type": "string",
      "enumValues": [
        "meet",
        "none"
      ],
      "value": "meet"
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "selectedState": {
      "type": "object",
      "properties": {
        "borderColor": {
          "type": "string",
          "value": ""
        },
        "color": {
          "type": "string"
        },
        "shape": {
          "type": "string",
          "value": "star"
        },
        "source": {
          "type": "string",
          "value": ""
        },
        "svgClassName": {
          "type": "string",
          "value": ""
        },
        "svgStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "size": {
      "type": "string",
      "enumValues": [
        "fit",
        "large",
        "lg",
        "md",
        "medium",
        "sm",
        "small"
      ],
      "value": "fit"
    },
    "step": {
      "type": "number",
      "value": 1
    },
    "thresholds": {
      "type": "Array<Object>",
      "value": []
    },
    "tooltip": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        }
      }
    },
    "trackResize": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "on"
    },
    "transientValue": {
      "type": "number",
      "writeback": true,
      "readOnly": true
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleContainsControls": {
          "type": "string"
        },
        "componentName": {
          "type": "string"
        },
        "labelAndValue": {
          "type": "string"
        },
        "labelClearSelection": {
          "type": "string"
        },
        "labelCountWithTotal": {
          "type": "string"
        },
        "labelDataVisualization": {
          "type": "string"
        },
        "labelInvalidData": {
          "type": "string"
        },
        "labelNoData": {
          "type": "string"
        },
        "stateCollapsed": {
          "type": "string"
        },
        "stateDrillable": {
          "type": "string"
        },
        "stateExpanded": {
          "type": "string"
        },
        "stateHidden": {
          "type": "string"
        },
        "stateIsolated": {
          "type": "string"
        },
        "stateMaximized": {
          "type": "string"
        },
        "stateMinimized": {
          "type": "string"
        },
        "stateSelected": {
          "type": "string"
        },
        "stateUnselected": {
          "type": "string"
        },
        "stateVisible": {
          "type": "string"
        }
      }
    },
    "unselectedState": {
      "type": "object",
      "properties": {
        "borderColor": {
          "type": "string",
          "value": ""
        },
        "color": {
          "type": "string"
        },
        "shape": {
          "type": "string",
          "value": "star"
        },
        "source": {
          "type": "string",
          "value": ""
        },
        "svgClassName": {
          "type": "string",
          "value": ""
        },
        "svgStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "value": {
      "type": "number",
      "writeback": true
    },
    "visualEffects": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_rating_gauge_metadata:false */
  (function () {
    __oj_rating_gauge_metadata.extension._WIDGET_NAME = 'ojRatingGauge';
    __oj_rating_gauge_metadata.extension._ALIASED_PROPS = { transientValue: 'rawValue' };

    // Consider a string with at least one digit a valid SVG path
    var _SHAPE_REGEXP = /\d/;
    var _RATING_GAUGE_SHAPE_ENUMS = {
      circle: true,
      square: true,
      diamond: true,
      triangle: true,
      human: true,
      star: true
    };
    var _UNSELECTED_RATING_GAUGE_SHAPE_ENUMS = {
      circle: true,
      square: true,
      diamond: true,
      triangle: true,
      human: true,
      star: true,
      dot: true,
      none: true
    };
    var _RATING_GAUGE_SHAPE_PROPS = {
      'changed-state.shape': true,
      'hover-state.shape': true,
      'selected-state.shape': true,
      'unselected-state.shape': true
    };
    function shapePropertyParser(value, name, meta, defaultParseFunction) {
      if (_RATING_GAUGE_SHAPE_PROPS[name] || name === 'unselected-state.shape') {
        if (_SHAPE_REGEXP.test(value)) {
          return value;
        } else if (_RATING_GAUGE_SHAPE_PROPS[name] && !_RATING_GAUGE_SHAPE_ENUMS[name]) {
          throw new Error('Found: ' + value + '. Expected: ' + _RATING_GAUGE_SHAPE_ENUMS.toString());
        } else if (name === 'unselected-state.shape' && !_UNSELECTED_RATING_GAUGE_SHAPE_ENUMS[name]) {
          throw new Error(
            'Found: ' + value + '. Expected: ' + _UNSELECTED_RATING_GAUGE_SHAPE_ENUMS.toString()
          );
        } else {
          return value;
        }
      }
      return defaultParseFunction(value);
    }
    oj.CustomElementBridge.register('oj-rating-gauge', {
      metadata: __oj_rating_gauge_metadata,
      parseFunction: shapePropertyParser
    });
  })();

var __oj_status_meter_gauge_metadata = 
{
  "properties": {
    "angleExtent": {
      "type": "number",
      "value": 360
    },
    "animationDuration": {
      "type": "number"
    },
    "animationOnDataChange": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "none"
    },
    "animationOnDisplay": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "none"
    },
    "borderColor": {
      "type": "string"
    },
    "borderRadius": {
      "type": "string",
      "value": "auto"
    },
    "center": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        }
      }
    },
    "color": {
      "type": "string"
    },
    "describedBy": {
      "type": "string"
    },
    "indicatorSize": {
      "type": "number",
      "value": 1
    },
    "innerRadius": {
      "type": "number",
      "value": 0.7
    },
    "label": {
      "type": "object",
      "properties": {
        "position": {
          "type": "string",
          "enumValues": [
            "auto",
            "center",
            "start"
          ],
          "value": "auto"
        },
        "style": {
          "type": "object",
          "value": {}
        },
        "text": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelledBy": {
      "type": "string"
    },
    "max": {
      "type": "number",
      "value": 100
    },
    "metricLabel": {
      "type": "object",
      "properties": {
        "converter": {
          "type": "object"
        },
        "position": {
          "type": "string",
          "enumValues": [
            "auto",
            "center",
            "insideIndicatorEdge",
            "outsideIndicatorEdge",
            "outsidePlotArea",
            "withLabel"
          ],
          "value": "auto"
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "auto",
            "off",
            "on"
          ],
          "value": "auto"
        },
        "scaling": {
          "type": "string",
          "enumValues": [
            "auto",
            "billion",
            "million",
            "none",
            "quadrillion",
            "thousand",
            "trillion"
          ],
          "value": "auto"
        },
        "style": {
          "type": "object",
          "value": {}
        },
        "text": {
          "type": "string",
          "value": ""
        },
        "textType": {
          "type": "string",
          "enumValues": [
            "number",
            "percent"
          ],
          "value": "number"
        }
      }
    },
    "min": {
      "type": "number",
      "value": 0
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "circular",
        "horizontal",
        "vertical"
      ],
      "value": "horizontal"
    },
    "plotArea": {
      "type": "object",
      "properties": {
        "borderColor": {
          "type": "string"
        },
        "borderRadius": {
          "type": "string",
          "value": "auto"
        },
        "color": {
          "type": "string"
        },
        "rendered": {
          "type": "string",
          "enumValues": [
            "auto",
            "off",
            "on"
          ],
          "value": "auto"
        },
        "svgClassName": {
          "type": "string",
          "value": ""
        },
        "svgStyle": {
          "type": "object",
          "value": {}
        }
      }
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "referenceLines": {
      "type": "Array<Object>",
      "value": []
    },
    "size": {
      "type": "string",
      "enumValues": [
        "fit",
        "lg",
        "md",
        "sm"
      ],
      "value": "fit"
    },
    "startAngle": {
      "type": "number",
      "value": 90
    },
    "step": {
      "type": "number"
    },
    "svgClassName": {
      "type": "string",
      "value": ""
    },
    "svgStyle": {
      "type": "object",
      "value": {}
    },
    "thresholdDisplay": {
      "type": "string",
      "enumValues": [
        "all",
        "currentOnly",
        "onIndicator"
      ],
      "value": "onIndicator"
    },
    "thresholds": {
      "type": "Array<Object>",
      "value": []
    },
    "tooltip": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        }
      }
    },
    "trackResize": {
      "type": "string",
      "enumValues": [
        "off",
        "on"
      ],
      "value": "on"
    },
    "transientValue": {
      "type": "number",
      "writeback": true,
      "readOnly": true
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleContainsControls": {
          "type": "string"
        },
        "componentName": {
          "type": "string"
        },
        "labelAndValue": {
          "type": "string"
        },
        "labelClearSelection": {
          "type": "string"
        },
        "labelCountWithTotal": {
          "type": "string"
        },
        "labelDataVisualization": {
          "type": "string"
        },
        "labelInvalidData": {
          "type": "string"
        },
        "labelNoData": {
          "type": "string"
        },
        "stateCollapsed": {
          "type": "string"
        },
        "stateDrillable": {
          "type": "string"
        },
        "stateExpanded": {
          "type": "string"
        },
        "stateHidden": {
          "type": "string"
        },
        "stateIsolated": {
          "type": "string"
        },
        "stateMaximized": {
          "type": "string"
        },
        "stateMinimized": {
          "type": "string"
        },
        "stateSelected": {
          "type": "string"
        },
        "stateUnselected": {
          "type": "string"
        },
        "stateVisible": {
          "type": "string"
        }
      }
    },
    "value": {
      "type": "number",
      "writeback": true
    },
    "visualEffects": {
      "type": "string",
      "enumValues": [
        "auto",
        "none"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getMetricLabel": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_status_meter_gauge_metadata:false */
  (function () {
    __oj_status_meter_gauge_metadata.extension._WIDGET_NAME = 'ojStatusMeterGauge';
    __oj_status_meter_gauge_metadata.extension._ALIASED_PROPS = { transientValue: 'rawValue' };
    oj.CustomElementBridge.register('oj-status-meter-gauge', {
      metadata: __oj_status_meter_gauge_metadata
    });
  })();

  /**
   * @ojcomponent oj.dvtBaseGauge
   * @augments oj.dvtBaseComponent
   * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
   * @since 0.7.0
   * @abstract
   */
  oj.__registerWidget(
    'oj.dvtBaseGauge',
    $.oj.dvtBaseComponent,
    {
      /**
       * If custom element, get the labelledBy option, and set this
       * onto the root dom element as aria-labelledby. We append "|label" so it matches the id that
       * is on the oj-label's label element.
       * @memberof oj.dvtBaseGauge
       * @instance
       * @private
       *
       */
      _labelledByUpdatedForSet: LabelledByUtils._labelledByUpdatedForSet,
      /**
       * When describedBy changes, we need to update the aria-described attribute.
       * @memberof oj.dvtBaseGauge
       * @instance
       * @private
       */
      _describedByUpdated: LabelledByUtils._describedByUpdated,
      /**
       * @override
       * @memberof oj.dvtBaseGauge
       * @protected
       */
      _ComponentCreate: function () {
        this._SetSizeClass();
        this._super();
        this._SetLocaleHelpers(NumberConverter, ConverterUtils);
      },

      _OptionChangeHandler: function (options) {
        this._SetSizeClass();
        this._super(options);
      },

      _GetSizeClass: function () {
        // subcomponents should override
      },

      _SetSizeClass: function () {
        var newClass = this._GetSizeClass();
        if (newClass !== this._sizeClass) {
          this.element.removeClass(this._sizeClass);
          this._sizeClass = newClass;
          this.element.addClass(newClass);
        }
      },

      _ProcessStyles: function (optionsCopy) {
        var options = optionsCopy;
        // The superclass evaluates the style classes, including those in _GetChildStyleClasses
        this._super(options);

        // Transfer the threshold colors to the correct location
        options._thresholdColors = [options._threshold1, options._threshold2, options._threshold3];
        options._threshold1 = null;
        options._threshold2 = null;
        options._threshold3 = null;
      },
      _AfterCreate: function () {
        this._super();
        var flags = {
          _context: { writeback: true, internalSet: true, readOnly: true }
        };
        this.option('rawValue', this.options.value, flags);
        if (this._SupportsOjLabel()) {
          var labelledBy = this.options.labelledBy;
          var describedBy = this.options.describedBy;
          this._labelledByUpdatedForSet(this.element[0].id, null, labelledBy, this.element);
          this._describedByUpdated(null, describedBy, this.element);
        }
      },
      _GetContentElement: function () {
        return this.element;
      },

      _GetChildStyleClasses: function () {
        var styleClasses = this._super();
        styleClasses['oj-gauge-metric-label'] = { path: 'metricLabel/style', property: 'TEXT' };
        styleClasses['oj-gauge-label'] = { path: 'label/style', property: 'TEXT' };
        styleClasses['oj-gauge-threshold1'] = { path: '_threshold1', property: 'color' };
        styleClasses['oj-gauge-threshold2'] = { path: '_threshold2', property: 'color' };
        styleClasses['oj-gauge-threshold3'] = { path: '_threshold3', property: 'color' };
        return styleClasses;
      },

      _GetEventTypes: function () {
        return ['input', 'optionChange'];
      },

      _HandleEvent: function (event) {
        var type = event.type;
        if (type === 'valueChange') {
          var newValue = event.newValue;
          if (event.complete) {
            this._UserOptionChange('value', newValue);
          } else {
            // Fired during the value change interaction for each change
            this._trigger('input', null, { value: newValue });
            this._UserOptionChange('rawValue', newValue);
          }
        } else {
          this._super(event);
        }
      },

      /**
       * @protected
       * @memberof oj.dvtBaseGauge
       */
      _SupportsOjLabel: function () {
        return false;
      },

      /**
       * @override
       * @private
       * @inheritdoc
       */
      _setOption: function (key, value, flags) {
        var oldValue = this.options[key];
        if (key === 'rawValue') {
          // rawValue is a read-only option
          Logger.error("'rawValue' is a read-only option and cannot be set");
          return;
        }

        if (key === 'value') {
          var rawValueFlags = {
            _context: { writeback: true, internalSet: true, readOnly: true }
          };
          this.option('rawValue', value, rawValueFlags);
        }

        if (this._SupportsOjLabel()) {
          var elem;

          if (key === 'labelledBy') {
            elem = this.element;
            this._labelledByUpdatedForSet(elem[0].id, oldValue, value, elem);
          }

          if (key === 'describedBy') {
            // This sets the aria-describedby on the correct dom node
            this._describedByUpdated(oldValue, value);
          }
        }
        this._super(key, value, flags);
      },

      _ConvertLocatorToSubId: function (locator) {
        var subId = locator.subId;

        // Convert the supported locators
        if (
          subId === 'oj-ledgauge-tooltip' ||
          subId === 'oj-ratinggauge-tooltip' ||
          subId === 'oj-statusmetergauge-tooltip'
        ) {
          subId = 'tooltip';
        }
        if (subId === 'oj-ratinggauge-item' && locator.index != null) {
          subId = 'item[' + locator.index + ']';
        }

        // Return the converted result or the original subId if a supported locator wasn't recognized. We will remove
        // support for the old subId syntax in 1.2.0.
        return subId;
      }
    },
    true
  );

  /**
   * @ojcomponent oj.ojLedGauge
   * @ojdeprecated {since: '13.1.0', description: 'Use <a href="Badge.html">Badge</a> classes or icons instead.'}
   * @augments oj.dvtBaseGauge
   * @since 0.7.0
   *
   * @ojshortdesc A LED gauge displays information graphically, highlighting a specific metric value in relation to its thresholds.
   * @ojrole img
   * @ojrole application
   *
   * @ojpropertylayout [ {propertyGroup: "common", items: ["type", "rotation", "metricLabel.rendered", "metricLabel.textType", "color", "style"]},
   *                     {propertyGroup: "data", items: ["value", "thresholds"]} ]
   * @ojvbdefaultcolumns 2
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-gauge-led'
   *
   * @classdesc
   * <h3 id="ledGaugeOverview-section">
   *   JET LED Gauge
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ledGaugeOverview-section"></a>
   * </h3>
   *
   * <p>LED gauges are used to highlight a specific metric value in relation to its
   * thresholds.<p>
   *
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-led-gauge
   *   value='63'
   *   min='0'
   *   max='100'
   *   thresholds='[{"max": 33}, {"max": 67}, {}]'>
   * &lt;/oj-led-gauge>
   * </code>
   * </pre>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"fragment_trackResize"}
   *
   * {@ojinclude "name":"a11y"}
   *
   * {@ojinclude "name":"rtl"}
   */
  oj.__registerWidget('oj.ojLedGauge', $.oj.dvtBaseGauge, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * The border color of the gauge. Only applies when thresholds are not defined. The default value varies based on theme.
       * @expose
       * @name borderColor
       * @memberof oj.ojLedGauge
       * @instance
       * @type {string=}
       * @ojformat color
       */
      borderColor: '',

      /**
       * The color of the gauge. Only applies when thresholds are not defined. The default value varies based on theme.
       * @expose
       * @name color
       * @memberof oj.ojLedGauge
       * @instance
       * @type {string=}
       * @ojformat color
       */
      color: '#393737',

      /**
       * An object defining the label.
       * @expose
       * @name label
       * @memberof oj.ojLedGauge
       * @instance
       * @ojdeprecated {since: '12.1.0', description: 'Use metric-label instead.'}
       * @type {Object=}
       */
      label: {
        /**
         * The CSS style object defining the style of the label.
         * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
         * @expose
         * @name label.style
         * @ojshortdesc The CSS style object defining the style of the label.
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        style: {},

        /**
         * The text for the label.
         * @expose
         * @name label.text
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         * @ojtranslatable
         */
        text: ''
      },

      /**
       * An object defining the value label.
       * @expose
       * @name metricLabel
       * @memberof oj.ojLedGauge
       * @instance
       * @type {Object=}
       */
      metricLabel: {
        /**
         * The converter used to format the labels. When using a converter, scaling should be set to none, as the formatted result may not be compatible with the scaling suffixes.
         * @expose
         * @name metricLabel.converter
         * @ojshortdesc The converter used to format the labels. See the Help documentation for more information.
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {Object}
         * @ojsignature {target: "Type", value: "?oj.Converter<string>"}
         * @default null
         */
        converter: null,

        /**
         * Defines if the label is rendered.
         * @expose
         * @name metricLabel.rendered
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "on"
         * @ojvalue {string} "off"
         * @default "off"
         */
        rendered: 'off',

        /**
         * The scaling behavior of the labels. When using a converter, scaling should be set to none, as the formatted result may not be compatible with the scaling suffixes.
         * @expose
         * @name metricLabel.scaling
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "none"
         * @ojvalue {string} "thousand"
         * @ojvalue {string} "million"
         * @ojvalue {string} "billion"
         * @ojvalue {string} "trillion"
         * @ojvalue {string} "quadrillion"
         * @ojvalue {string} "auto"
         * @default "auto"
         */
        scaling: 'auto',

        /**
         * The CSS style object defining the style of the label.
         * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
         * @expose
         * @name metricLabel.style
         * @ojshortdesc The CSS style object defining the style of the label.
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        style: {},

        /**
         * The text for the label. If specified, text will overwrite the numeric value that is displayed by default. The converter, scaling, and textType attributes are ignored when text is specified.
         * @expose
         * @name metricLabel.text
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         * @ojtranslatable
         */
        text: '',

        /**
         * Defines whether the label is a number or a percentage of the total value.
         * @expose
         * @name metricLabel.textType
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "percent"
         * @ojvalue {string} "number"
         * @default "number"
         */
        textType: 'number'
      },

      /** Specifies the size of the led gauge.
       * @expose
       * @name markerSize
       * @memberof oj.ojLedGauge
       * @ojshortdesc Specifies the led size.
       * @instance
       * @type {string=}
       * @ojvalue {string} "sm" {"description": "Small size, as determined by the theme, will be used for the gauge."}
       * @ojvalue {string} "md" {"description": "Medium size, as determined by the theme, will be used for the gauge."}
       * @ojvalue {string} "lg" {"description": "Large size, as determined by the theme, will be used for the gauge."}
       * @ojvalue {string} "fit" {"description": "The size of the led will be determined based on application styling. If no explicit component size is specified, a default size will be used."}
       * @default "fit"
       */
      markerSize: 'fit',

      /**
       * The maximum value of the gauge.
       * @expose
       * @name max
       * @memberof oj.ojLedGauge
       * @instance
       * @type {number=}
       * @default 100
       */
      max: 100,

      /**
       * The minimum value of the gauge.
       * @expose
       * @name min
       * @memberof oj.ojLedGauge
       * @instance
       * @type {number=}
       * @default 0
       */
      min: 0,

      /**
       * The rotation angle for the gauge. Useful for changing the direction of triangle or arrow gauges.
       * @expose
       * @name rotation
       * @memberof oj.ojLedGauge
       * @instance
       * @type {number=}
       * @ojvalue {number} 90
       * @ojvalue {number} 180
       * @ojvalue {number} 270
       * @ojvalue {number} 0
       * @ojunits degrees
       * @default 0
       */
      rotation: 0,

      /**
       * Fraction of area to use. Values range from 0 to 1.
       * @expose
       * @name size
       * @memberof oj.ojLedGauge
       * @instance
       * @type {number=}
       * @default 1
       * @ojmin 0
       * @ojmax 1
       */
      size: 1,

      /**
       * The CSS style class to apply to the gauge. The style class and inline style will override any other styling specified through the properties. For tooltip interactivity, it's recommended to also pass a representative color to the color attribute.
       * @expose
       * @name svgClassName
       * @memberof oj.ojLedGauge
       * @ojshortdesc The CSS style class to apply to the gauge. See the Help documentation for more information.
       * @instance
       * @type {string=}
       * @default ""
       */
      svgClassName: '',

      /**
       * The inline style to apply to the gauge. The style class and inline style will override any other styling specified through the properties. For tooltip interactivity, it's recommended to also pass a representative color to the color attribute.
       * Only SVG CSS style properties are supported.
       * @expose
       * @name svgStyle
       * @memberof oj.ojLedGauge
       * @ojshortdesc The inline style to apply to the gauge. See the Help documentation for more information.
       * @instance
       * @type {Object=}
       * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
       * @default {}
       */
      svgStyle: {},

      /**
       * An array of objects with the following properties defining the thresholds for the gauge.
       * @expose
       * @name thresholds
       * @memberof oj.ojLedGauge
       * @ojshortdesc An array of objects specifying the gauge thresholds.
       * @instance
       * @type {(Array.<Object>)=}
       * @ojsignature {target: "Type", value: "Array<oj.ojLedGauge.Threshold>", jsdocOverride: true}
       * @default []
       */
      thresholds: [],

      /**
       *  An object containing an optional callback function for tooltip customization.
       * @expose
       * @name tooltip
       * @memberof oj.ojLedGauge
       * @instance
       * @type {Object=}
       */
      tooltip: {
        /**
         * A function that returns a custom tooltip. The function takes a tooltip context argument,
         * provided by the gauge, and should return an object that contains only one of the two properties:
         *  <ul>
         *    <li>insert: HTMLElement | string - An HTML element, which will be appended to the tooltip, or a tooltip string.</li>
         *    <li>preventDefault: <code>true</code> - Indicates that the tooltip should not be displayed. It is not necessary to return {preventDefault:false} to display tooltip, since this is a default behavior.</li>
         *  </ul>
         * @expose
         * @name tooltip.renderer
         * @ojshortdesc A function that returns a custom tooltip for a gauge. The function takes a context argument, provided by the gauge. See the Help documentation for more information.
         * @memberof! oj.ojLedGauge
         * @instance
         * @type {function(Object):Object|null}
         * @ojsignature {target: "Type", value: "((context: oj.ojLedGauge.TooltipContext) => ({insert: Element|string}|{preventDefault: boolean}))", jsdocOverride: true}
         * @default null
         */
        renderer: null
      },

      /**
       * The shape of the LED gauge. Can take the name of a built-in shape or the SVG path commands for a custom shape.
       * @expose
       * @name type
       * @memberof oj.ojLedGauge
       * @instance
       * @type {string=}
       * @ojvalue {string=} "arrow"
       * @ojvalue {string=} "diamond"
       * @ojvalue {string=} "square"
       * @ojvalue {string=} "rectangle"
       * @ojvalue {string=} "triangle"
       * @ojvalue {string=} "star"
       * @ojvalue {string=} "human"
       * @ojvalue {string=} "circle"
       * @default "circle"
       */
      type: 'circle',

      /**
       * The metric value.
       * @expose
       * @name value
       * @memberof oj.ojLedGauge
       * @instance
       * @type {number|null}
       * @ojwriteback
       * @ojeventgroup common
       */
      value: null,

      /**
       * Defines whether the theme specific visual effects such as overlays and gradients are applied to the gauge.
       * @expose
       * @name visualEffects
       * @memberof oj.ojLedGauge
       * @instance
       * @ojdeprecated {since: '12.1.0', description: 'Overlays and gradients are not supported in Redwood theme and are not recommended.'}
       * @type {string=}
       * @ojvalue {string} "none"
       * @ojvalue {string} "auto"
       * @default "auto"
       */
      visualEffects: 'auto'
    },

    _CreateDvtComponent: function (context, callback, callbackObj) {
      this._focusable({ element: this.element, applyHighlight: true });
      return new ojgaugeToolkit.LedGauge(context, callback, callbackObj);
    },

    _ConvertSubIdToLocator: function (subId) {
      var locator = {};

      if (subId === 'tooltip') {
        locator.subId = 'oj-ledgauge-tooltip';
      }
      return locator;
    },

    _GetComponentStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses.push('oj-ledgauge');
      styleClasses.push(this._sizeClass);
      return styleClasses;
    },

    _GetSizeClass: function () {
      // class is added to elemet in _GetComponentStyleClasses
      return `oj-ledgauge-${this.options.markerSize}`;
    },

    _Render: function () {
      // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
      if (this.element.attr('title')) {
        this.options.shortDesc = this.element.attr('title');
        this.element.data(this.element, 'title', this.element.attr('title'));
        this.element.removeAttr('title');
      } else if (this.element.data('title')) {
        this.options.shortDesc = this.element.data('title');
      }

      // Call the super to render
      this._super();
    },

    /**
     * Returns the gauge's formatted metric label.
     * @return {string} The formatted metric label.
     * @expose
     * @instance
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @memberof oj.ojLedGauge
     */
    getMetricLabel: function () {
      var auto = this._component.getAutomation();
      return auto.getMetricLabel();
    }
  });

  /**
   * @ojcomponent oj.ojRatingGauge
   * @augments oj.dvtBaseGauge
   * @since 0.7.0
   *
   * @ojshortdesc A rating gauge displays information graphically, typically displaying or accepting user feedback on a product or service.
   * @ojrole img
   * @ojrole application
   *
   * @ojpropertylayout [ {propertyGroup: "common", items: ["style"]},
   *                     {propertyGroup: "data", items: ["value", "max", "step"]} ]
   * @ojvbdefaultcolumns 4
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-gauge-rating'
   * @ojuxspecs ['gauge']
   * @ojdeprecated [
   *  {
   *    type: "maintenance",
   *    since: "15.0.0",
   *    value: ["oj-c-rating-gauge"]
   *  }
   * ]
   *
   * @classdesc
   * <h3 id="ratingGaugeOverview-section">
   *   JET Rating Gauge
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ratingGaugeOverview-section"></a>
   * </h3>
   *
   * <p>Rating gauges are typically used to display or accept user feedback on a product
   * or service.</p>
   *
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-rating-gauge
   *   value='4' >
   * &lt;/oj-rating-gauge>
   * </code>
   * </pre>
   * {@ojinclude "name":"a11y"}
   *
   * {@ojinclude "name":"migrationDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"fragment_trackResize"}
   *
   * {@ojinclude "name":"rtl"}
   */
  const OJ_RATING_GUAGE_FIT = 'oj-rating-gauge-fit';
  oj.__registerWidget('oj.ojRatingGauge', $.oj.dvtBaseGauge, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * Whether there has been a value entered by the user.
       * @expose
       * @name changed
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {boolean=}
       * @default false
       * @ojwriteback
       */
      changed: false,

      /**
       * The changed shape for the gauge. Displayed after the user has set a value, or when the changed attribute of the data object is set to true.
       * @expose
       * @name changedState
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {Object=}
       */
      changedState: {
        /**
         * The border color for changed state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name changedState.borderColor
         * @memberof! oj.ojRatingGauge
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        borderColor: '',

        /**
         * The color for changed state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name changedState.color
         * @ojshortdesc The color for changed state. Does not apply if a custom image is specified.
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The color for changed state. Does not apply if a custom image is specified. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         */
        color: '',

        /**
         * The shape to be used. Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
         * @expose
         * @name changedState.shape
         * @memberof! oj.ojRatingGauge
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {"circle"|"diamond"|"human"|"square"|"star"|"triangle"|string}
         * @ojsignature {target: "Type", value: "?"}
         * @default "star"
         */
        shape: 'star',

        /**
         * The URI of the custom image. If specified, it takes precedence over shape. For SVG images, the width and height must be defined on the SVG element as pixels.
         * @expose
         * @name changedState.source
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The URI of the custom image. If specified, it takes precedence over shape. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        source: '',

        /**
         * The CSS style class to apply to the changed state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * @expose
         * @name changedState.svgClassName
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The CSS style class to apply to the changed state. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        svgClassName: '',

        /**
         * The inline style to apply to the changed state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * Only SVG CSS style properties are supported.
         * @expose
         * @name changedState.svgStyle
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The inline style to apply to the changed state. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        svgStyle: {}
      },

      /**
       * The shape that displays on hover.
       * @expose
       * @name hoverState
       * @memberof oj.ojRatingGauge
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {Object=}
       */
      hoverState: {
        /**
         * The border color for hover state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name hoverState.borderColor
         * @memberof! oj.ojRatingGauge
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        borderColor: '',

        /**
         * The color for hover state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name hoverState.color
         * @ojshortdesc The color for hover state. Does not apply if a custom image is specified.
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The color for hover state. Does not apply if a custom image is specified. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         */
        color: '',

        /**
         * The shape to be used. Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
         * @expose
         * @name hoverState.shape
         * @memberof! oj.ojRatingGauge
         * @instance
         * @type {"circle"|"diamond"|"human"|"square"|"star"|"triangle"|string}
         * @ojsignature {target: "Type", value: "?"}
         * @default "star"
         */
        shape: 'star',

        /**
         * The URI of the custom image. If specified, it takes precedence over shape. For SVG images, the width and height must be defined on the SVG element as pixels.
         * @expose
         * @name hoverState.source
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The URI of the custom image. If specified, it takes precedence over shape. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        source: '',

        /**
         * The CSS style class to apply to the hover state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * @expose
         * @name hoverState.svgClassName
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The CSS style class to apply to the hover state. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        svgClassName: '',

        /**
         * The inline style to apply to the hover state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * Only SVG CSS style properties are supported.
         * @expose
         * @name hoverState.svgStyle
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The inline style to apply to the hover state. See the Help documentation for more information.
         * @instance
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        svgStyle: {}
      },

      /**
       * It is used to establish a relationship between this component and another element.
       * A common use is to tie the oj-label and the oj-rating-gauge together for accessibility.
       * The oj-label custom element has an id, and you use the labelled-by attribute
       * to tie the two components together to facilitate correct screen reader behavior.
       * @expose
       * @name labelledBy
       * @memberof oj.ojRatingGauge
       * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documentation for more information.
       * @type {(string|null)=}
       * @public
       * @instance
       * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
       * // getter
       * var labelId = myRatingGauge.labelledBy;
       *
       * // setter
       * myRatingGauge.labelledBy = "labelId";
       *
       */
      labelledBy: null,

      /**
       * It is used to establish a relationship between this component and another element.
       * Typically this is not used by the application developer, but by the oj-label custom element's
       * code. One use case is where the oj-label custom element code writes described-by
       * on its form component for accessibility reasons.
       * To facilitate correct screen reader behavior, the described-by attribute is
       * copied to the aria-describedby attribute on the component's dom element.
       * @expose
       * @name describedBy
       * @memberof oj.ojRatingGauge
       * @ojshortdesc Specifies a relationship between this component and another element.
       * @type {(string|null)=}
       * @public
       * @instance
       * @example <caption>Get or set the <code class="prettyprint">describedBy</code> property after initialization:</caption>
       * // getter
       * var descById = myRatingGauge.describedBy;
       *
       * // setter
       * myRatingGauge.describedBy = "someId";
       *
       */
      describedBy: null,

      /**
       * Integer value specifying the maximum value of the gauge, which determines the number of shapes or images that are displayed.
       * @expose
       * @name max
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {number=}
       * @default 5
       * @ojmin 0
       */
      max: 5,

      /**
       * The minimum value that can be set on the gauge by the end user. Does not affect the value set on the gauge by API.
       * @expose
       * @name min
       * @memberof oj.ojRatingGauge
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {number=}
       * @default 0
       * @ojmin 0
       */
      min: 0,

      /**
       * Defines the type of rating gauge to be rendered.
       * @expose
       * @name orientation
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {string=}
       * @ojvalue {string} "vertical"
       * @ojvalue {string} "horizontal"
       * @default "horizontal"
       * @ojdeprecated {since: '9.0.0', description: 'Usage of vertical rating gauges is not recommended.'}
       */
      orientation: 'horizontal',

      /**
       * Specifies whether the images provided should show up at their defined aspect ratios. With 'none', the space is allocated evenly, and shapes could be stretched. With 'meet', The aspect ratio of the shape or image is taken into account when space is allocated. When aspect ratios conflict, the aspect ratio of the selectedState will be used.
       * @expose
       * @name preserveAspectRatio
       * @memberof oj.ojRatingGauge
       * @ojshortdesc Specifies whether the images provided should show up at their defined aspect ratios. See the Help documentation for more information.
       * @instance
       * @type {string=}
       * @ojvalue {string} "none"
       * @ojvalue {string} "meet"
       * @default "meet"
       */
      preserveAspectRatio: 'meet',

      /**
       * <p>The <code class="prettyprint">transientValue</code> is the read-only property for retrieving
       * the transient value from the rating gauge. It is triggered when hovering over the rating gauge.</p>
       *
       * <p>This is a read-only property so page authors cannot set or change it directly.</p>
       * @expose
       * @alias transientValue
       * @instance
       * @type {(number|null)=}
       * @memberof oj.ojRatingGauge
       * @ojshortdesc Read-only property used for retrieving the transient value from the component. See the Help documentation for more information.
       * @since 4.2.0
       *
       * @readonly
       * @ojwriteback
       */
      rawValue: null,

      /**
       * Defines whether the value of the gauge can be changed by the end user.
       * @expose
       * @name readonly
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {boolean=}
       * @default false
       */
      readonly: false,

      /**
       * Defines whether the gauge is disabled or not. User interaction is prevented if set to <code>true</code>. Visual indication will not be present when custom image source is used. Other state specific <code>svg-class-name</code> and <code>svg-style</code> will be overridden by disabled default style.
       * @expose
       * @name disabled
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {boolean=}
       * @default false
       */
      disabled: false,

      /** Specifies the size of the individual rating gauge shapes. Note that small, medium and large were deprecated in 12.0.0. Use sm, md and lg instead.
       * @expose
       * @name size
       * @memberof oj.ojRatingGauge
       * @ojshortdesc Specifies the size of the rating gauge item. See the Help documentation for more information.
       * @instance
       * @type {string=}
       * @ojvalue {string} "sm" {"description": "Small size, as determined by the theme, will be used for the rating gauge shapes. The component size will be computed to fit the individual shapes. Not recommended for editable gauges."}
       * @ojvalue {string} "md" {"description": "Medium size, as determined by the theme, will be used for the rating gauge shapes. The component size will be computed to fit the individual shapes. Not recommended for editable gauges."}
       * @ojvalue {string} "lg" {"description": "Large size, as determined by the theme, will be used for the rating gauge shapes. The component size will be computed to fit the individual shapes."}
       * @ojvalue {string} "fit" {"description": "The size of the individual rating gauge shapes will be determined based on the component size and the value of <code>max</code>. If no explicit component size is specified, a theme-specific default will be used."}
       * @ojvalue {string} "small" {"description": "Small size, as determined by the theme, will be used for the rating gauge shapes. Deprecated in 12.0.0. Use sm instead."}
       * @ojvalue {string} "medium" {"description": "Medium size, as determined by the theme, will be used for the rating gauge shapes. Deprecated in 12.0.0. Use md instead."}
       * @ojvalue {string} "large" {"description": "Large size, as determined by the theme, will be used for the rating gauge shapes. Deprecated in 12.0.0. Use lg instead."}
       * @ojdeprecated [{target:'propertyValue', for:"small", since: "12.0.0", description: "This value will be removed in the future. Please use sm."},
       *                {target:'propertyValue', for:"medium", since: "12.0.0", description: "This value will be removed in the future. Please use md."},
       *                {target:'propertyValue', for:"large", since: "12.0.0", description: "This value will be removed in the future. Please use lg."}]
       * @default "fit"
       */
      size: 'fit',

      /**
       * The selected shape for the gauge.
       * @expose
       * @name selectedState
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {Object=}
       */
      selectedState: {
        /**
         * The border color for selected state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name selectedState.borderColor
         * @memberof! oj.ojRatingGauge
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        borderColor: '',

        /**
         * The color for selected state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name selectedState.color
         * @ojshortdesc The color for selected state. Does not apply if a custom image is specified.
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The color for selected state. Does not apply if a custom image is specified. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         */
        color: '',

        /**
         * The shape to be used. Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
         * @expose
         * @name selectedState.shape
         * @memberof! oj.ojRatingGauge
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {"circle"|"diamond"|"human"|"square"|"star"|"triangle"|string}
         * @ojsignature {target: "Type", value: "?"}
         * @default "star"
         */
        shape: 'star',

        /**
         * The URI of the custom image. If specified, it takes precedence over shape. For SVG images, the width and height must be defined on the SVG element as pixels.
         * @expose
         * @name selectedState.source
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The URI of the custom image. If specified, it takes precedence over shape. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        source: '',

        /**
         * The CSS style class to apply to the selected state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * @expose
         * @name selectedState.svgClassName
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The CSS style class to apply to the selected state. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        svgClassName: '',

        /**
         * The inline style to apply to the selected state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * Only SVG CSS style properties are supported.
         * @expose
         * @name selectedState.svgStyle
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The inline style to apply to the selected state. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        svgStyle: {}
      },

      /**
       * Specifies the increment by which values can be specified by the end user.
       * @expose
       * @name step
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {number=}
       * @ojvalue {number=} 0.5
       * @ojvalue {number=} 1
       * @default 1
       */
      step: 1,

      /**
       * An array of objects with the following properties defining the thresholds for the gauge.
       * @expose
       * @name thresholds
       * @memberof oj.ojRatingGauge
       * @ojshortdesc An array of objects specifying the gauge thresholds.
       * @instance
       * @type {(Array.<Object>)=}
       * @ojsignature {target: "Type", value: "Array<oj.ojRatingGauge.Threshold>", jsdocOverride: true}
       * @default []
       */
      thresholds: [],

      /**
       * An object containing an optional callback function for tooltip customization.
       * @expose
       * @name tooltip
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {Object=}
       */
      tooltip: {
        /**
         * A function that returns a custom tooltip. The function takes a tooltip context argument,
         * provided by the gauge, and should return an object that contains only one of the two properties:
         *  <ul>
         *    <li>insert: HTMLElement | string - An HTML element, which will be appended to the tooltip, or a tooltip string.</li>
         *    <li>preventDefault: <code>true</code> - Indicates that the tooltip should not be displayed. It is not necessary to return {preventDefault:false} to display tooltip, since this is a default behavior.</li>
         *  </ul>
         * @expose
         * @name tooltip.renderer
         * @ojshortdesc A function that returns a custom tooltip for a gauge. The function takes a context argument, provided by the gauge. See the Help documentation for more information.
         * @memberof! oj.ojRatingGauge
         * @instance
         * @type {function(Object):Object|null}
         * @ojsignature {target: "Type", value: "((context: oj.ojRatingGauge.TooltipContext) => ({insert: Element|string}|{preventDefault: boolean}))", jsdocOverride: true}
         * @default null
         */
        renderer: null
      },

      /**
       * The unselected shape for the gauge.
       * @expose
       * @name unselectedState
       * @memberof oj.ojRatingGauge
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {Object=}
       */
      unselectedState: {
        /**
         * The border color for unselected state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name unselectedState.borderColor
         * @memberof! oj.ojRatingGauge
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        borderColor: '',

        /**
         * The color for unselected state. Does not apply if a custom image is specified. The default value comes from the CSS and varies based on theme.
         * @expose
         * @name unselectedState.color
         * @ojshortdesc The color for unselected state. Does not apply if a custom image is specified.
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The color for unselected state. Does not apply if a custom image is specified. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         */
        color: '',

        /**
         * The shape to be used. Can take the name of a built-in shape or the SVG path commands for a custom shape. Does not apply if a custom image is specified.
         * @expose
         * @name unselectedState.shape
         * @memberof! oj.ojRatingGauge
         * @instance
         * @type {"circle"|"diamond"|"human"|"square"|"star"|"triangle"|string}
         * @ojsignature {target: "Type", value: "?"}
         * @default "star"
         */
        shape: 'star',

        /**
         * The URI of the custom image. If specified, it takes precedence over shape. For SVG images, the width and height must be defined on the SVG element as pixels.
         * @expose
         * @name unselectedState.source
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The URI of the custom image. If specified, it takes precedence over shape. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        source: '',

        /**
         * The CSS style class to apply to the unselected state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * @expose
         * @name unselectedState.svgClassName
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The CSS style class to apply to the unselected state. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        svgClassName: '',

        /**
         * The inline style to apply to the unselected state. The style class and inline style will override any other styling specified through the properties. Does not apply if custom image is specified.
         * Only SVG CSS style properties are supported.
         * @expose
         * @name unselectedState.svgStyle
         * @memberof! oj.ojRatingGauge
         * @ojshortdesc The inline style to apply to the unselected state. See the Help documentation for more information.
         * @instance
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        svgStyle: {}
      },

      /**
       * The value set on the gauge.
       * @expose
       * @name value
       * @memberof oj.ojRatingGauge
       * @instance
       * @type {number|null}
       * @ojwriteback
       * @ojmin 0
       * @ojeventgroup common
       */
      value: null,

      /**
       * Defines whether theme specific visual effects such as overlays and gradients are applied to the gauge.
       * @expose
       * @name visualEffects
       * @memberof oj.ojRatingGauge
       * @instance
       * @ojdeprecated {since: '12.1.0', description: 'Overlays and gradients are not supported in Redwood theme and are not recommended.'}
       * @type {string=}
       * @ojvalue {string} "none"
       * @ojvalue {string} "auto"
       * @default "auto"
       */
      visualEffects: 'auto'
    },

    _CreateDvtComponent: function (context, callback, callbackObj) {
      this._focusable({ element: this.element, applyHighlight: true });
      return new ojgaugeToolkit.RatingGauge(context, callback, callbackObj);
    },

    _ConvertSubIdToLocator: function (subId) {
      var locator = {};

      if (subId === 'tooltip') {
        locator.subId = 'oj-ratinggauge-tooltip';
      } else if (subId.indexOf('item') === 0) {
        locator.subId = 'oj-ratinggauge-item';
        locator.index = this._GetFirstIndex(subId);
      }
      return locator;
    },

    _GetComponentStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses.push('oj-ratinggauge');
      if (this.options.size === 'fit') {
        styleClasses.push(OJ_RATING_GUAGE_FIT);
      }
      // TODO  Add style classes for rating gauge selected/hover/unselected/changed
      return styleClasses;
    },

    _GetChildStyleClasses: function () {
      var styleClasses = this._super();

      styleClasses['oj-rating-gauge-hover'] = [
        { path: 'hoverState/color', property: 'fill' },
        { path: 'hoverState/borderColor', property: 'stroke' }
      ];

      styleClasses[
        `oj-rating-gauge-selected ${this.options.readonly ? 'oj-rating-gauge-readonly' : ''}`
      ] = [
        { path: 'selectedState/color', property: 'fill' },
        { path: 'selectedState/borderColor', property: 'stroke' }
      ];

      styleClasses[
        `oj-rating-gauge-unselected ${this.options.readonly ? 'oj-rating-gauge-readonly' : ''}`
      ] = [
        { path: 'unselectedState/color', property: 'fill' },
        { path: 'unselectedState/borderColor', property: 'stroke' }
      ];

      styleClasses['oj-rating-gauge-changed'] = [
        { path: 'changedState/color', property: 'fill' },
        { path: 'changedState/borderColor', property: 'stroke' }
      ];

      styleClasses['oj-rating-gauge-shape-sm'] = {
        path: '_shapeSize/sm',
        property: 'width'
      };
      styleClasses['oj-rating-gauge-shape-md'] = {
        path: '_shapeSize/md',
        property: 'width'
      };

      styleClasses['oj-rating-gauge-shape-lg'] = {
        path: '_shapeSize/lg',
        property: 'width'
      };
      return styleClasses;
    },

    _Render: function () {
      // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
      if (this.element.attr('title')) {
        this.options.shortDesc = this.element.attr('title');
        this.element.data(this.element, 'title', this.element.attr('title'));
        this.element.removeAttr('title');
      } else if (this.element.data('title')) {
        this.options.shortDesc = this.element.data('title');
      }

      // Call the super to render
      this._super();
    },

    /**
     * @private
     */
    _SupportsOjLabel: function () {
      return this._IsCustomElement();
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojRatingGauge
     */
    _GetTranslationsSectionName: function () {
      return 'oj-ojRatingGauge';
    },

    _ProcessStyles: function (optionsCopy) {
      var options = optionsCopy;
      this._super(options);
      var aliasedSizeValues = { small: 'sm', medium: 'md', large: 'lg' };
      var size = aliasedSizeValues[options.size] || options.size;
      if (size !== 'fit') {
        var shapeDim = parseInt(options._shapeSize[size], 10);
        var isHoriz = options.orientation === 'horizontal';
        options._width = isHoriz ? shapeDim * options.max : shapeDim;
        options._height = isHoriz ? shapeDim : shapeDim * options.max;
        this._width = options._width;
        this._height = options._height;
      }
    },

    _ProcessOptions: function () {
      this._super();

      if (this.options.size === 'fit') {
        this.element.addClass(OJ_RATING_GUAGE_FIT);
      } else {
        this.element.removeClass(OJ_RATING_GUAGE_FIT);
      }
    },

    // eslint-disable-next-line no-unused-vars
    _UserOptionChange: function (key, value) {
      this._superApply(arguments);

      // If this was a value change, also update the changed value
      if (key === 'value') {
        this._UserOptionChange('changed', true);
      }
    }
  });

  /**
   * @ojcomponent oj.ojStatusMeterGauge
   * @augments oj.dvtBaseGauge
   * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
   * @since 0.7.0
   *
   * @ojshortdesc A status meter gauge displays information graphically, highlighting a specific metric value's progress in relation to its thresholds.  Horizontal, vertical, and circular formats are supported.
   * @ojrole img
   * @ojrole application
   *
   * @ojdeprecated [
   *  {
   *    type: "maintenance",
   *    since: "15.0.0",
   *    value: ["oj-c-meter-bar", "oj-c-meter-circle"]
   *  }
   * ]
   *
   * @ojpropertylayout [ {propertyGroup: "common", items: ["orientation", "metricLabel.rendered", "metricLabel.textType", "metricLabel.text", "thresholdDisplay",
   *                                                       "animationOnDataChange", "animationOnDisplay", "plotArea.rendered", "color", "style"]},
   *                     {propertyGroup: "data", items: ["value", "min", "max", "step", "thresholds", "referenceLines"]} ]
   * @ojvbdefaultcolumns 4
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-linear-status'
   * @ojuxspecs ['gauge']
   *
   * @classdesc
   * <h3 id="statusMeterGaugeOverview-section">
   *   JET Status Meter Gauge
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#statusMeterGaugeOverview-section"></a>
   * </h3>
   *
   * <p>Status meter gauges support horizontal and circular status meters.</p>
   *
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-status-meter-gauge
   *   value='63'
   *   min='0'
   *   max='100'
   *   thresholds='[{"max": 33}, {"max": 67}, {}]'>
   * &lt;/oj-status-meter-gauge>
   * </code>
   * </pre>
   *
   * {@ojinclude "name":"a11yKeyboard"}
   * {@ojinclude "name":"migrationDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"fragment_trackResize"}
   *
   * {@ojinclude "name":"rtl"}
   */
  oj.__registerWidget('oj.ojStatusMeterGauge', $.oj.dvtBaseGauge, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * Specifies the angle extent of a gauge with circular orientation. Value should be provided in degrees.
       * @expose
       * @name angleExtent
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @default 360
       * @ojunits degrees
       * @ojmin 0
       * @ojmax 360
       */
      angleExtent: 360,

      /**
       * Defines the animation that is applied on data changes.
       * @expose
       * @name animationOnDataChange
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {string=}
       * @ojvalue {string} "auto"
       * @ojvalue {string} "none"
       * @default "none"
       */
      animationOnDataChange: 'none',

      /**
       * Defines the animation that is shown on initial display.
       * @expose
       * @name animationOnDisplay
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {string=}
       * @ojvalue {string} "auto"
       * @ojvalue {string} "none"
       * @default "none"
       */
      animationOnDisplay: 'none',

      /**
       * The duration of the animations in milliseconds. The default value comes from the CSS and varies based on theme.
       * @expose
       * @name animationDuration
       * @ojshortdesc The duration of the animations in milliseconds.
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @ojsignature {target: "Type", value: "?"}
       * @ojunits milliseconds
       * @ojmin 0
       */
      animationDuration: undefined,

      /**
       * The border color of the gauge. Only applies when thresholds are not defined. The default value varies based on theme.
       * @expose
       * @name borderColor
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {string=}
       * @ojformat color
       */
      borderColor: '',

      /**
       * Defines the border radius of the indicator and plot area. When set to "auto", the border radius is set to a built-in default. Acceptable input follows CSS border-radius attribute specifications. The plot area border radius can be overwritten with the plotArea borderRadius atribute.
       * @expose
       * @name borderRadius
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc Specifies the border radius of the indicator and plot area. See the Help documentation for more information.
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {string=}
       * @default "auto"
       */
      borderRadius: 'auto',

      /**
       * An object defining the center content of a status meter with circular orientation.
       * @expose
       * @name center
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {Object=}
       */
      center: {
        /**
         * A function that returns custom center content. The function takes a center context argument,
         * provided by the gauge, and should return an object with the following property:
         * <ul>
         *   <li>insert: HTMLElement - HTML element, which will be overlaid on top of the gauge.
         *   This HTML element will block interactivity of the gauge by default, but the CSS pointer-events property
         *   can be set to 'none' on this element if the gauge's interactivity is desired.
         *   </li>
         * </ul>
         * @expose
         * @name center.renderer
         * @ojshortdesc A function that returns custom center content. The function takes a context argument, provided by the gauge. See the Help documentation for more information.
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {function(Object):Object|null}
         * @ojsignature {target: "Type", value: "((context: oj.ojStatusMeterGauge.CenterContext) => ({insert: Element|string}|{preventDefault: boolean}))", jsdocOverride: true}
         * @default null
         */
        renderer: null
      },

      /**
       * The color of the gauge. Only applies when thresholds are not defined. The default value varies based on theme.
       * @expose
       * @name color
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {string=}
       * @ojformat color
       */
      color: '#393737',

      /**
       * Defines the ratio of relative thickness of the indicator to the plot area.
       * @expose
       * @name indicatorSize
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @default 1
       * @ojmin 0
       */
      indicatorSize: 1,

      /**
       * Specifies the inner radius of a gauge with circular orientation, defined by the distance from the center of the gauge to the innermost edge of the indicator and plot area. Valid values are a percent or ratio from 0 to 1.
       * @expose
       * @name innerRadius
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @default .7
       * @ojmin 0
       * @ojmax 1
       */
      innerRadius: 0.7,

      /**
       * An object defining the label.
       * @expose
       * @name label
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @ojdeprecated {since: '12.1.0', description: 'Use metric-label instead.'}
       * @type {Object=}
       */
      label: {
        /**
         * Defines the position of the label for horizontal and vertical gauges. The default position for horizontal gauges is 'start' and for vertical gauges is 'center'.
         * @expose
         * @name label.position
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc Specifies the label position for horizontal and vertical gauges. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "center"
         * @ojvalue {string} "start"
         * @ojvalue {string} "auto"
         * @default "auto"
         */
        position: 'auto',

        /**
         * The CSS style object defining the style of the label.
         * @expose
         * @name label.style
         * @ojshortdesc The CSS style object to apply to the label.
         * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        style: {},

        /**
         * The text for the label.
         * @expose
         * @name label.text
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         * @ojtranslatable
         */
        text: ''
      },

      /**
       * It is used to establish a relationship between this component and another element.
       * A common use is to tie the oj-label and the oj-status-meter-gauge together for accessibility.
       * The oj-label custom element has an id, and you use the labelled-by attribute
       * to tie the two components together to facilitate correct screen reader behavior.
       * @expose
       * @name labelledBy
       * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documentation for more information.
       * @memberof oj.ojStatusMeterGauge
       * @public
       * @instance
       * @type {(string|null)=}
       * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
       * // getter
       * var labelId = myStatusMeterGauge.labelledBy;
       *
       * // setter
       * myStatusMeterGauge.labelledBy = "labelId";
       *
       */
      labelledBy: null,

      /**
       * @expose
       * It is used to establish a relationship between this component and another element.
       * Typically this is not used by the application developer, but by the oj-label custom element's
       * code. One use case is where the oj-label custom element code writes described-by
       * on its form component for accessibility reasons.
       * To facilitate correct screen reader behavior, the described-by attribute is
       * copied to the aria-describedby attribute on the component's dom element.
       * @name describedBy
       * @ojshortdesc Specifies a relationship between this component and another element.
       * @memberof oj.ojStatusMeterGauge
       * @public
       * @instance
       * @type {(string|null)=}
       *
       * @example <caption>Get or set the <code class="prettyprint">describedBy</code> property after initialization:</caption>
       * // getter
       * var descById = myStatusMeterGauge.describedBy;
       *
       * // setter
       * myStatusMeterGauge.describedBy = "someId";
       *
       */
      describedBy: null,

      /**
       * The maximum value of the gauge.
       * @expose
       * @name max
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @default 100
       */
      max: 100,

      /**
       * An object defining the value label.
       * @expose
       * @name metricLabel
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @ojdeprecated {since: '18.0.0', description: 'This component is superceded by oj-c-meter-bar and oj-c-meter-circle. Applications with this use case should instead create their own labels that also satisfy accessibility requirements.'}
       * @type {Object=}
       */
      metricLabel: {
        /**
         * The converter used to format the labels. When using a converter, scaling should be set to none, as the formatted result may not be compatible with the scaling suffixes.
         * @expose
         * @name metricLabel.converter
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc The converter used to format the labels. See the Help documentation for more information.
         * @instance
         * @type {Object}
         * @ojsignature {target: "Type", value: "?oj.Converter<string|number>"}
         * @default null
         */
        converter: null,

        /**
         * Defines the position of the metric label for horizontal and vertical gauges. The default position of the metric label is outside of the plot area. If the label is not rendered, then 'withLabel' will render the metric label outside the plot area. When the label is rendered, all positions are treated as 'withLabel' except 'auto' and 'outsidePlotArea' which render the metric label outside the plot area. When the metric label is rendered 'withLabel', the metric label is displayed with the same style as the label. The position in the 'withLabel' case is specified by the label position attribute.
         * @expose
         * @name metricLabel.position
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc Specifies the metric label position for horizontal and vertical gauges. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "center"
         * @ojvalue {string} "insideIndicatorEdge"
         * @ojvalue {string} "outsideIndicatorEdge"
         * @ojvalue {string} "outsidePlotArea"
         * @ojvalue {string} "withLabel"
         * @ojvalue {string} "auto"
         * @default "auto"
         */
        position: 'auto',

        /**
         * Defines if the label is rendered. If set to auto, the label is rendered if the orientation is circular.
         * @expose
         * @name metricLabel.rendered
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "on"
         * @ojvalue {string} "off"
         * @ojvalue {string} "auto"
         * @default "auto"
         */
        rendered: 'auto',

        /**
         * The scaling behavior of the labels. When using a converter, scaling should be set to none, as the formatted result may not be compatible with the scaling suffixes.
         * @expose
         * @name metricLabel.scaling
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "none"
         * @ojvalue {string} "thousand"
         * @ojvalue {string} "million"
         * @ojvalue {string} "billion"
         * @ojvalue {string} "trillion"
         * @ojvalue {string} "quadrillion"
         * @ojvalue {string} "auto"
         * @default "auto"
         */
        scaling: 'auto',

        /**
         * The CSS style object defining the style of the label.
         * The following style properties are supported: color, cursor, fontFamily, fontSize, fontStyle, fontWeight, textDecoration.
         * @expose
         * @name metricLabel.style
         * @ojshortdesc The CSS style object to apply to the label.
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        style: {},

        /**
         * The text for the label. If specified, text will overwrite the numeric value that is displayed by default. The converter, scaling, and textType attributes are ignored when text is specified.
         * @expose
         * @name metricLabel.text
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc The text for the label. If specified, text will overwrite the numeric value that is displayed by default. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         * @ojtranslatable
         */
        text: '',

        /**
         * Defines whether the label is a number or a percentage of the total value.
         * @expose
         * @name metricLabel.textType
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "percent"
         * @ojvalue {string} "number"
         * @default "number"
         */
        textType: 'number'
      },

      /**
       * The minimum value of the gauge.
       * @expose
       * @name min
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @default 0
       */
      min: 0,

      /**
       * Defines the type of status meter to be rendered.
       * @expose
       * @name orientation
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {string=}
       * @ojvalue {string} "circular"
       * @ojvalue {string} "vertical"
       * @ojvalue {string} "horizontal"
       * @default "horizontal"
       */
      orientation: 'horizontal',

      /** Specifies the size of the status meter gauge.
       * @expose
       * @name size
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc Specifies the gauge size.
       * @instance
       * @type {string=}
       * @ojvalue {string} "sm" {"description": "Small size, as determined by the theme, will be used for the size of the gauge."}
       * @ojvalue {string} "md" {"description": "Medium size, as determined by the theme, will be used for the size of the gauge."}
       * @ojvalue {string} "lg" {"description": "Large size, as determined by the theme, will be used for the size of the gauge."}
       * @ojvalue {string} "fit" {"description": "The size of the gauge will be determined based on the application styling. If no explicit component size is specified, a default size will be used."}
       * @default "fit"
       */
      size: 'fit',

      /**
       * Plot Area for Status Meter Gauge
       * @expose
       * @name plotArea
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {Object=}
       */
      plotArea: {
        /**
         * The border color of the plot area.
         * @expose
         * @name plotArea.borderColor
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         */
        borderColor: undefined,

        /**
         * Defines the border radius of the plot area shape. When set to "auto", the border radius is the same as the top level border radius. Acceptable input follows CSS border-radius attribute specifications.
         * @expose
         * @name plotArea.borderRadius
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc Specifies the border radius of the plot area shape. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default "auto"
         */
        borderRadius: 'auto',

        /**
         * The color of the plot area.
         * @expose
         * @name plotArea.color
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {string}
         * @ojformat color
         * @ojsignature {target: "Type", value: "?"}
         */
        color: undefined,

        /**
         * Defines if the plot area is to be rendered. If set to auto, the plot area is rendered if the orientation is circular or if the thresholdDisplay is not onIndicator.
         * @expose
         * @name plotArea.rendered
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc Specifies whether to render the plot area. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @ojvalue {string} "on"
         * @ojvalue {string} "off"
         * @ojvalue {string} "auto"
         * @default "auto"
         */
        rendered: 'auto',

        /**
         * The CSS style class to apply to the plot area. The style class and inline style will override any other styling specified through the properties.
         * @expose
         * @name plotArea.svgClassName
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc The CSS style class to apply to the plot area. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {string}
         * @ojsignature {target: "Type", value: "?"}
         * @default ""
         */
        svgClassName: '',

        /**
         * The inline style to apply to the plot area. The style class and inline style will override any other styling specified through the properties.
         * Only SVG CSS style properties are supported.
         * @expose
         * @name plotArea.svgStyle
         * @memberof! oj.ojStatusMeterGauge
         * @ojshortdesc The inline style to apply to the plot area. See the Help documentation for more information.
         * @instance
         * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
         * @type {Object=}
         * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
         * @default {}
         */
        svgStyle: {}
      },

      /**
       * <p>The <code class="prettyprint">transientValue</code> is the read-only property for retrieving
       * the transient value from the status meter gauge. It is triggered when dragging over the status meter gauge.</p>
       *
       * <p>This is a read-only property so page authors cannot set or change it directly.</p>
       * @expose
       * @alias transientValue
       * @instance
       * @type {(number|null)=}
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc Read-only property used for retrieving the transient value from the component. See the Help documentation for more information.
       * @since 4.2.0
       *
       * @readonly
       * @ojwriteback
       */
      rawValue: null,

      /**
       * Defines whether the value of the gauge can be changed by the end user.
       * @expose
       * @name readonly
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {boolean=}
       * @default false
       */
      readonly: false,

      /**
       * An array of objects with the following properties defining the reference lines for the gauge.
       * @expose
       * @name referenceLines
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc An array of objects specifying the reference lines for the gauge.
       * @instance
       * @type {Array.<Object>=}
       * @ojsignature {target: "Type", value: "Array<oj.ojStatusMeterGauge.ReferenceLine>", jsdocOverride: true}
       * @default []
       */
      referenceLines: [],

      /**
       * Specifies the start angle of a gauge with circular orientation. Value should be provided in degrees.
       * @expose
       * @name startAngle
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number=}
       * @default 90
       * @ojunits degrees
       * @ojmin 0
       * @ojmax 360
       */
      startAngle: 90,

      /**
       * Specifies the increment by which values can be changed by the end user when readonly is false. The step must be a positive value that is smaller than the difference between the min and max. If not specified, the default step is 1/100 if the difference between the min and max.
       * @expose
       * @name step
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc Specifies the increment by which values can be changed by the end user. See the Help documentation for more information.
       * @instance
       * @type {(number|null)=}
       * @ojexclusivemin 0
       */
      step: null,

      /**
       * The CSS style class to apply to the gauge indicator. The style class and inline style will override any other styling specified through the properties. For tooltip interactivity, it's recommended to also pass a representative color to the color attribute.
       * @expose
       * @name svgClassName
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc The CSS style class to apply to the gauge indicator. See the Help documentation for more information.
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {string=}
       * @default ""
       */
      svgClassName: '',

      /**
       * The inline style to apply to the gauge indicator. The style class and inline style will override any other styling specified through the properties. For tooltip interactivity, it's recommended to also pass a representative color to the color attribute.
       * Only SVG CSS style properties are supported.
       * @expose
       * @name svgStyle
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc The inline style to apply to the gauge indicator. See the Help documentation for more information.
       * @instance
       * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system.'}
       * @type {Object=}
       * @ojsignature {target: "Type", value: "Partial<CSSStyleDeclaration>", jsdocOverride: true}
       * @default {}
       */
      svgStyle: {},

      /**
       * An object containing an optional callback function for tooltip customization.
       * @expose
       * @name tooltip
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {Object=}
       */
      tooltip: {
        /**
         * A function that returns a custom tooltip. The function takes a tooltip context argument,
         * provided by the gauge, and should return an object that contains only one of the two properties:
         *  <ul>
         *    <li>insert: HTMLElement | string - An HTML element, which will be appended to the tooltip, or a tooltip string.</li>
         *    <li>preventDefault: <code>true</code> - Indicates that the tooltip should not be displayed. It is not necessary to return {preventDefault:false} to display tooltip, since this is a default behavior.</li>
         *  </ul>
         * @expose
         * @name tooltip.renderer
         * @ojshortdesc A function that returns a custom tooltip for a gauge. The function takes a context argument, provided by the gauge. See the Help documentation for more information.
         * @memberof! oj.ojStatusMeterGauge
         * @instance
         * @type {function(Object):Object|null}
         * @ojsignature {target: "Type", value: "((context: oj.ojStatusMeterGauge.TooltipContext) => ({insert: Element|string}|{preventDefault: boolean}))", jsdocOverride: true}
         * @default null
         */
        renderer: null
      },

      /**
       * Controls whether the current threshold is displayed on the indicator, in the plotArea, or if all the thresholds are displayed in the plot area.
       * @expose
       * @name thresholdDisplay
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {string=}
       * @ojvalue {string} "currentOnly"
       * @ojvalue {string} "all"
       * @ojvalue {string} "onIndicator"
       * @default "onIndicator"
       */
      thresholdDisplay: 'onIndicator',

      /**
       * An array of objects with the following properties defining the thresholds for the gauge.
       * @expose
       * @name thresholds
       * @memberof oj.ojStatusMeterGauge
       * @ojshortdesc An array of objects specifying the gauge thresholds.
       * @instance
       * @type {(Array.<Object>)=}
       * @ojsignature {target: "Type", value: "Array<oj.ojStatusMeterGauge.Threshold>", jsdocOverride: true}
       * @default []
       */
      thresholds: [],

      /**
       * The metric value.
       * @expose
       * @name value
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @type {number|null}
       * @ojwriteback
       * @ojeventgroup common
       */
      value: null,

      /**
       * Defines whether the theme specific visual effects such as overlays and gradients are applied to the gauge.
       * @expose
       * @name visualEffects
       * @memberof oj.ojStatusMeterGauge
       * @instance
       * @ojdeprecated {since: '12.1.0', description: 'Overlays and gradients are not supported in Redwood theme and are not recommended.'}
       * @type {string=}
       * @ojvalue {string} "none"
       * @ojvalue {string} "auto"
       * @default "auto"
       */
      visualEffects: 'auto'
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojStatusMeterGauge
     */
    _GetTranslationsSectionName: function () {
      return 'oj-ojStatusMeterGauge';
    },

    _CreateDvtComponent: function (context, callback, callbackObj) {
      this._focusable({ element: this.element, applyHighlight: true });
      return new ojgaugeToolkit.StatusMeterGauge(context, callback, callbackObj);
    },

    _ConvertSubIdToLocator: function (subId) {
      var locator = {};

      if (subId === 'tooltip') {
        locator.subId = 'oj-statusmetergauge-tooltip';
      }
      return locator;
    },

    _GetComponentStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses.push('oj-statusmetergauge');
      styleClasses.push(this._sizeClass);
      return styleClasses;
    },

    _GetSizeClass: function () {
      // class is added to elemet in _GetComponentStyleClasses
      return `oj-statusmetergauge-${this.options.orientation}-${this.options.size}`;
    },

    _GetComponentRendererOptions: function () {
      return [
        { path: 'tooltip/renderer', slot: 'tooltipTemplate' },
        { path: 'center/renderer', slot: 'centerTemplate' }
      ];
    },

    /**
     * @private
     */
    _SupportsOjLabel: function () {
      return this._IsCustomElement();
    },

    _ProcessOptions: function () {
      this._super();
      var center = this.options.center;
      if (center && center._renderer) {
        center.renderer = this._GetTemplateRenderer(center._renderer, 'center');
      }
    },

    // @inheritdoc
    _GetChildStyleClasses: function () {
      var styleClasses = this._super();
      styleClasses['oj-dvtbase oj-statusmetergauge'] = {
        path: 'animationDuration',
        property: 'ANIM_DUR'
      };
      styleClasses['oj-statusmeter-gauge-plotarea'] = [
        { path: 'plotArea/borderColor', property: 'border-color' },
        { path: 'plotArea/color', property: 'color' }
      ];
      return styleClasses;
    },

    _Render: function () {
      // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
      if (this.element.attr('title')) {
        this.options.shortDesc = this.element.attr('title');
        this.element.data(this.element, 'title', this.element.attr('title'));
        this.element.removeAttr('title');
      } else if (this.element.data('title')) {
        this.options.shortDesc = this.element.data('title');
      }

      // Call the super to render
      this._super();
    },

    /**
     * Returns the gauge's formatted metric label.
     * @return {string} The formatted metric label.
     * @expose
     * @instance
     * @ojdeprecated {since: '7.0.0', description: 'The use of this function is no longer recommended.'}
     * @ojtsignore
     * @memberof oj.ojStatusMeterGauge
     */
    getMetricLabel: function () {
      var auto = this._component.getAutomation();
      return auto.getMetricLabel();
    }
  });

  /**
   * <p>This element has no touch interaction.  </p>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojLedGauge
   */

  /**
   * <p>This element has no keyboard interaction.  </p>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojLedGauge
   */

  // TYPEDEFS

  /**
   * @typedef {Object} oj.ojLedGauge.Threshold
   * @property {string} [borderColor] The border color of the threshold.
   * @property {string} [color] The color of the threshold.
   * @property {number} [max] The upper bound of the threshold. This value is ignored for the final threshold, which uses the maximum value of the gauge.
   * @property {string} [shortDesc] Specific description for the threshold and overwrites the shortDesc specified on gauge. This is used for accessibility and also for customizing the tooltip text.
   */
  /**
   * @typedef {Object} oj.ojLedGauge.TooltipContext
   * @property {string} color The indicator color of the gauge.
   * @property {Element} componentElement The LED gauge HTML element.
   * @property {string} label The computed metric label.
   * @property {Element} parentElement The tooltip element. The function can directly modify or append content to this element.
   */

  // SubId Locators **************************************************************

  /**
   * <p>Sub-ID for the the LED gauge tooltip.</p>
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.</p>
   *
   * @ojsubid
   * @member
   * @name oj-ledgauge-tooltip
   * @memberof oj.ojLedGauge
   * @instance
   *
   * @example <caption>Get the tooltip object of the gauge, if displayed:</caption>
   * var nodes = myLedGauge.getNodeBySubId({'subId': 'oj-ledgauge-tooltip'});
   */

  /**
   * <p>The <code class="prettyprint">tooltipTemplate</code> slot is used to specify custom tooltip content. The slot content must be a single &lt;template> element.
   * This slot takes precedence over the tooltip.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the gauge. (See [oj.ojLedGauge.TooltipContext]{@link oj.ojLedGauge.TooltipContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot tooltipTemplate
   * @ojmaxitems 1
   * @ojtemplateslotprops oj.ojLedGauge.TooltipContext
   * @memberof oj.ojLedGauge
   * @ojshortdesc The tooltipTemplate slot is used to specify custom tooltip content. See the Help documentation for more information.
   *
   * @example <caption>Initialize the LedGauge with a tooltip template specified:</caption>
   * &lt;oj-led-gauge>
   *  &lt;template slot="tooltipTemplate">
   *    &lt;span class="label">&lt;oj-bind-text value="[[$current.label]]">&lt;/oj-bind-text>&lt;/span>
   *  &lt;/template>
   * &lt;/oj-led-gauge>
   */
  //-----------------------------------------------------
  //                   Styling
  //-----------------------------------------------------
  /**
   * @ojstylevariableset oj-led-gauge-css-set1
   * @ojdisplayname metricLabel
   * @ojstylevariable --oj-gauge-metric-label-font-weight {description: "Font weight for metric label.", formats: ["font_weight"], help: "oj-led-gauge-css-set1"}
   * @memberof oj.ojLedGauge
   */
  /**
   * @ojstylevariableset oj-led-gauge-css-set2
   * @ojdisplayname markerSize
   * @ojstylevariable oj-led-gauge-sm-size {description: "Led gauge small size", formats: ["length"], help: "oj-led-gauge-css-set2"}
   * @ojstylevariable oj-led-gauge-md-size {description: "Led gauge medium size",formats: ["length"], help: "oj-led-gauge-css-set2"}
   * @ojstylevariable oj-led-gauge-lg-size {description: "Led gauge large size", formats: ["length"], help: "oj-led-gauge-css-set2"}
   * @memberof oj.ojLedGauge
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display tooltip.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Drag</kbd></td>
   *       <td>Value change when <code class="prettyprint">readonly</code> is <code class="prettyprint">false</code>.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojRatingGauge
   */

  /**
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>The application is responsible for providing a meaningful tooltip using <i>tooltip.renderer</i> function on the element as the oj-rating-gauge element does not provide a default tooltip and also ensuring that an accessible label is included that matches the tooltip's content.
   * Since component terminology for keyboard and touch shortcuts can conflict with those of the application, it is the application's responsibility to provide these shortcuts, possibly via a help popup.</p>
   *
   * @ojfragment a11y
   * @memberof oj.ojRatingGauge
   */
  /**
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * To migrate from oj-rating-gauge to oj-c-rating-gauge, you need to revise the import statement and references to oj-rating-gauge in your app. Please note the changes between the two components below.
   * <h5>No data to display </h5>
   * <p>
   * oj-c-rating-gauge will not support showing "No Data to Display" (translated string) to meet Redwood theme design.
   * </p>
   * <h5>selected-state.color and changed-state.color attributes are no longer supported. </h5>
   * <p>
   * oj-c-rating-gauge will not support state attributes. Use the color API in oj-c-rating-gauge instead of selected-state.color. changed-state.color can be achived by using the changed and color API.
   * </p>
   * <h5>size attribute enums</h5>
   * <p>
   * size attribute will only support standard sm, md and lg enums and <i>fit</i> is no longer supported.
   * </p>
   * <h5>track-resize attribute</h5>
   * <p>track-resize attribute is no longer supported. Rating gauges now have fixed sizes. Since we are not supporting the 'fit' enum value for the 'size' api, we no longer need 'track-resize'. </p>
   * <h5>tooltip attribute and tooltipTemplate slot </h5>
   * <p> The support for this feature has been split into two attributes, tooltip and datatip. The datatip will be used for interactive gauges only and it will be a function that takes DatatipContext as argument.
   * Tooltip attribute, which will be a string instead of a function, will be used for readonly rating gauge. To get the preventDefault as true behaviour, do not set tooltip or datatip properties
   * </p>
   * <h5>title support</h5>
   * <p>title will no longer be required to make your rating gauge accessible. Use aria-label attribute instead for text to be used by screen readers, and datatip or tooltip for text to be shown on hover or focus.
   * The tooltip attribute is for readonly rating gauge only. If aria-label is not present for readonly rating gauge, tooltip will be used as aria-label. Note the datatip should be used for interactive gauges only and it takes a function.
   * </p>
   * <h5>thresholds[].shortDesc attribute </h5>
   * <p>
   * thresholds[].shortDesc is replaced by thresholds[].accessibleLabel in oj-c-rating-gauge.
   * <h5>thresholds[].max attribute </h5>
   * <p>
   * thresholds[].max is optional in oj-rating-gauge but required in oj-c-rating-gauge.
   * @ojfragment migrationDoc
   * @memberof oj.ojRatingGauge
   */
  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Submit the current value of the gauge.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Move focus to next element and submit the current value of the gauge.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + Tab</kbd></td>
   *       <td>Move focus to previous element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Increase the gauge's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Decrease the gauge's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>Decrease the gauge's transient value in left-to-right locales. Increase the gauge's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>Increase the gauge's transient value in left-to-right locales. Decrease the gauge's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojRatingGauge
   */

  // TYPEDEFS

  /**
   * @typedef {Object} oj.ojRatingGauge.Threshold
   * @property {string} [borderColor] The border color of the threshold.
   * @property {string} [color] The color of the threshold.
   * @property {number} [max] The upper bound of the threshold. This value is ignored for the final threshold, which uses the maximum value of the gauge.
   * @property {string} [shortDesc] Specific description for the threshold and overwrites the shortDesc specified on gauge. This is used for accessibility and also for customizing the tooltip text.
   * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system', target: 'property', for: 'borderColor' }
   */
  /**
   * @typedef {Object} oj.ojRatingGauge.TooltipContext
   * @property {string} color The indicator color of the gauge.
   * @property {Element} componentElement The rating gauge HTML element.
   * @property {string} label The computed metric label.
   * @property {Element} parentElement The tooltip element. The function can directly modify or append content to this element.
   */

  // DEPRECATED OPTIONS FOR WIDGET SYNTAX

  /**
   * Defines whether the value of the gauge can be changed by the end user.
   * @ignore
   * @expose
   * @name readOnly
   * @memberof oj.ojRatingGauge
   * @instance
   * @type {boolean}
   * @default true
   */

  // SubId Locators **************************************************************

  /**
   * <p>Sub-ID for the the rating guage tooltip.</p>
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.</p>
   *
   * @ojsubid
   * @member
   * @name oj-ratinggauge-tooltip
   * @memberof oj.ojRatingGauge
   * @instance
   *
   * @example <caption>Get the tooltip object of the gauge, if displayed:</caption>
   * var nodes = myRatingGauge.getNodeBySubId('subId': 'oj-ratinggauge-tooltip'});
   */

  /**
   * <p>Sub-ID for a rating gauge item indexed by its position.</p>
   *
   * @property {number} index The index of the item within the gauge.
   *
   * @ojsubid oj-ratinggauge-item
   * @memberof oj.ojRatingGauge
   *
   * @example <caption>Get the first item from the rating gauge:</caption>
   * var nodes = myRatingGauge.getNodeBySubId('subId': 'oj-ratinggauge-item', index: 0});
   */

  /**
   * <p>The <code class="prettyprint">tooltipTemplate</code> slot is used to specify custom tooltip content.
   * This slot takes precedence over the tooltip.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the gauge. (See [oj.ojRatingGauge.TooltipContext]{@link oj.ojRatingGauge.TooltipContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot tooltipTemplate
   * @ojtemplateslotprops oj.ojRatingGauge.TooltipContext
   * @memberof oj.ojRatingGauge
   * @ojshortdesc The tooltipTemplate slot is used to specify custom tooltip content. See the Help documentation for more information.
   *
   * @example <caption>Initialize the RatingGauge with a tooltip template specified:</caption>
   * &lt;oj-rating-gauge>
   *  &lt;template slot="tooltipTemplate">
   *    &lt;span class="label">&lt;oj-bind-text value="[[$current.label]]">&lt;/oj-bind-text>&lt;/span>
   *  &lt;/template>
   * &lt;/oj-rating-gauge>
   */
  //-----------------------------------------------------
  //                   Styling
  //-----------------------------------------------------
  /**
   * @ojstylevariableset oj-rating-gauge-css-set1
   * @ojstylevariable oj-rating-gauge-sm-size {description: "Rating gauge small size", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-rating-gauge-md-size {description: "Rating gauge medium size",formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-rating-gauge-lg-size {description: "Rating gauge large size", formats: ["length"], help: "#css-variables"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set2
   * @ojdisplayname Hovered
   * @ojstylevariable oj-rating-gauge-border-color-hover {description: "Rating gauge border color when hovered", formats: ["color"], help: "#oj-rating-gauge-css-set2"}
   * @ojstylevariable oj-rating-gauge-color-hover {description: "Rating gauge color when hovered", formats: ["color"], help: "#oj-rating-gauge-css-set2"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set3
   * @ojdisplayname Unselected
   * @ojstylevariable oj-rating-gauge-border-color-unselected {description: "Rating gauge border color when unselected", formats: ["color"], help: "#oj-rating-gauge-css-set3"}
   * @ojstylevariable oj-rating-gauge-color-unselected {description: "Rating gauge color when unselected", formats: ["color"], help: "oj-rating-gauge-css-set3"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set4
   * @ojdisplayname Selected
   * @ojstylevariable oj-rating-gauge-border-color-selected {description: "Rating gauge border color when selected", formats: ["color"], help: "#oj-rating-gauge-css-set4"}
   * @ojstylevariable oj-rating-gauge-color-selected {description: "Rating gauge color when selected", formats: ["color"], help: "oj-rating-gauge-css-set4"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set5
   * @ojdisplayname Changed
   * @ojstylevariable oj-rating-gauge-border-color-changed {description: "Rating gauge border color when changed", formats: ["color"], help: "#oj-rating-gauge-css-set5"}
   * @ojstylevariable oj-rating-gauge-color-changed {description: "Rating gauge color when changed", formats: ["color"], help: "oj-rating-gauge-css-set5"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set6
   * @ojdisplayname Selected and disabled
   * @ojstylevariable oj-rating-gauge-color-selected-disabled {description: "Rating gauge color when selected and disabled", formats: ["color"], help: "oj-rating-gauge-css-set6"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set7
   * @ojdisplayname Unselected and disabled
   * @ojstylevariable oj-rating-gauge-color-unselected-disabled {description: "Rating gauge color when unselected and disabled", formats: ["color"], help: "oj-rating-gauge-css-set7"}
   * @memberof oj.ojRatingGauge
   */

  /**
   * @ojstylevariableset oj-rating-gauge-css-set8
   * @ojdisplayname Selected and readonly
   * @ojstylevariable oj-rating-gauge-color-selected-readonly {description: "Rating gauge color when selected and readonly", formats: ["color"], help: "oj-rating-gauge-css-set8"}
   * @ojstylevariable oj-rating-gauge-border-color-selected-readonly {description: "Rating gauge border color when selected and readonly", formats: ["color"], help: "oj-rating-gauge-css-set8"}
   * @memberof oj.ojRatingGauge
   */
  /**
   * @ojstylevariableset oj-rating-gauge-css-set9
   * @ojdisplayname Unselected and readonly
   * @ojstylevariable oj-rating-gauge-color-unselected-readonly {description: "Rating gauge color when unselected and readonly", formats: ["color"], help: "oj-rating-gauge-css-set9"}
   * @ojstylevariable oj-rating-gauge-border-color-unselected-readonly {description: "Rating gauge border color when unselected and readonly", formats: ["color"], help: "oj-rating-gauge-css-set9"}
   * @memberof oj.ojRatingGauge
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display tooltip.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Drag</kbd></td>
   *       <td>Value change when <code class="prettyprint">readonly</code> is <code class="prettyprint">false</code>.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojStatusMeterGauge
   */
  /**
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * To migrate from oj-status-meter-gauge to oj-c-meter-bar or oj-c-meter-circle, you need to revise the import statement and references to oj-status-meter-gauge in your app.
   * oj-c-meter-bar is analogous to oj-status-meter-gauge with horizontal and vertical orientation while oj-c-meter-circle is analogous to oj-status-meter-gauge with circular orientation.
   * <h5>No data to display </h5>
   * <p>
   * oj-c-meter-bar and oj-c-meter-circle will not support showing "No Data to Display" (translated string) to meet Redwood theme design.
   * </p>
   * <h5>orientation attribute </h5>
   * <p>
   * oj-c-meter-bar will only support "horizontal" and "vertical" enums while oj-c-meter circle will not include the orientation attribute.
   * </p>
   * <h5>center attribute </h5>
   * <p>
   * oj-c-meter-bar and oj-c-meter-circle will not support center attribute. However, oj-c-meter-circle will continue to support centerTemplate. Use this instead.
   * </p>
   * <h5>reference-lines[].value attribute </h5>
   * <p>
   * reference-lines[].value is optional in oj-status-meter-gauge but required in oj-c-meter-bar and oj-c-meter-circle.
   * </p>
   * <h5>thresholds[].shortDesc attribute </h5>
   * <p>
   * thresholds[].shortDesc is replaced by thresholds[].accessibleLabel in oj-c-meter-bar and oj-c-meter-circle.
   * </p>
   * <h5>thresholds[].max attribute </h5>
   * <p>
   * thresholds[].max is optional in oj-status-meter-gauge but required in oj-c-meter-bar and oj-c-meter-circle.
   * </p>
   * <h5>thresholds-display enums </h5>
   * <p>
   *  "currentOnly" and "onIndicator" enums are replaced by new , more intuitive and descriptive names. "currentOnly" will be "plotArea" and "onIndicator" will just be "indicator".
   * </p>
   * <h5>step attribute </h5>
   * <p>
   * The default step value for oj-c-meter-bar and oj-c-meter-circle is 1 which is different from oj-status-meter-gauge which is 1/100.
   * </p>
   * <h5>inner-radius attribute </h5>
   * <p>
   * oj-c-meter-circle's default inner radius value is dependent on the size API which is different from the 0.7 value in oj-status-meter-gauge.
   * </p>
   * <h5>plot-area attribute </h5>
   * <p>
   * The 'auto' enum for plot-area.rendered will not be supported. Use the 'on' or 'off' enum values instead. 'on' is the default value for oj-c-meter-bar and oj-c-meter-circle.
   * </p>
   * <h5>start-angle attribute </h5>
   * <p>
   *  start-angle will only be supported in oj-c-meter-circle and will not be included in oj-c-meter-bar.
   * </p>
   * <h5>angle-extent attribute </h5>
   * <p>
   *  angle extent will only be supported in oj-c-meter-circle and will not be included in oj-c-meter-bar.
   * </p>
   * <h5>track-resize attribute</h5>
   * <p>track-resize attribute is no longer supported. The component will itself resize on change in dimension when size is set to fit.
   * </p>
   * <h5>tooltip attribute and tooltipTemplate slot</h5>
   * <p> tooltip attribute and the tooltipTemplate slot are no longer supported. datatip attribute has been introduced to support this feature. The datatip attribute takes a function that provides datatipContext as argument. To get the preventDefault as true behaviour, the datatip function should return null.
   * </p>
   * <h5>indicator-size attribute </h5>
   * <p>
   * indicator-size attribute will no longer support values greater than 1 in oj-c-meter-bar and oj-c-meter-circle.
   * </p>
   * <h5>min height for vertical meter bar</h5>
   * <p>
   * The vertical oj-c-meter-bar now has a default min-height which is theme driven.
   * </p>
   * <h5>animaton-on-data-change attribute</h5>
   * <p>
   * For oj-c-meter-bar and oj-c-meter-circle, animaton-on-data-change attribute is not supported. We plan on addressing this use case in a future release.
   * </p>
   * <h5>animation-on-display attribute</h5>
   * <p>
   * For oj-c-meter-bar and oj-c-meter-circle, animation-on-diaplay attribute is not supported. We plan on addressing this use case in a future release.
   * </p>
   * <h5>animation-duration attribute</h5>
   * <p>
   * For oj-c-meter-bar and oj-c-meter-circle, animation-duration attribute is not supported. We plan on supporting this use case in a future release.
   * </p>
   * @ojfragment migrationDoc
   * @memberof oj.ojStatusMeterGauge
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Submit the current value of the gauge.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Move focus to next element and submit the current value of the gauge.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift + Tab</kbd></td>
   *       <td>Move focus to previous element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Increase the gauge's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Decrease the gauge's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>Decrease the gauge's transient value in left-to-right locales. Increase the gauge's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>Increase the gauge's transient value in left-to-right locales. Decrease the gauge's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojStatusMeterGauge
   */

  // TYPEDEFS

  /**
   * @typedef {Object} oj.ojStatusMeterGauge.ReferenceLine
   * @property {string} [color]  The color of the reference line.
   * @property {number} [value] The value of the reference line.
   * @property {number=} lineWidth=2  The width of the reference line.
   * @property {("dashed"|"dotted"|"solid")=} lineStyle="solid" The line style of the reference line.
   * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system', target: 'property', for: 'lineStyle' }
   * @ojdeprecated {since: '14.1.0', description: 'This is not recommended in the Redwood design system', target: 'property', for: 'lineWidth' }
   */
  /**
   * @typedef {Object} oj.ojStatusMeterGauge.Threshold
   * @property {string} [borderColor] The border color of the threshold.
   * @property {string} [color] The color of the threshold.
   * @property {number} [max] The upper bound of the threshold. This value is ignored for the final threshold, which uses the maximum value of the gauge.
   * @property {string} [shortDesc] Specific description for the threshold and overwrites the shortDesc specified on gauge. This is used for accessibility and also for customizing the tooltip text.
   * @ojdeprecated {since: '14.0.0', description: 'This is not recommended in the Redwood design system', target: 'property', for: 'borderColor' }
   */
  /**
   * @typedef {Object} oj.ojStatusMeterGauge.TooltipContext
   * @property {string} color The indicator color of the gauge.
   * @property {Element} componentElement The status meter gauge HTML element.
   * @property {string} label The computed metric label.
   * @property {Element} parentElement The tooltip element. The function can directly modify or append content to this element.
   */
  /**
   * @typedef {Object} oj.ojStatusMeterGauge.CenterContext
   * @property {Element} componentElement The status meter gauge HTML element.
   * @property {oj.ojStatusMeterGauge.Bounds} innerBounds Object containing (x, y, width, height) of the rectangle inscribed in the center area. The inner bounds are useful for inserting content that is guaranteed to fit within the center area. If the angleExtent isn't 360 then we will provide the clipped square.
   * @property {string} metricLabel The computed metric label.
   * @property {oj.ojStatusMeterGauge.Bounds} outerBounds Object containing (x, y, width, height) of the rectangle circumscribing the center area. The outer bounds are useful for creating background for the entire center area when used with a CSS border-radius. If the angleExtent isn't 360 then we will provide the clipped square.
   */
  /**
   * @typedef {Object} oj.ojStatusMeterGauge.Bounds
   * @property {number} x The x position of the bounding rectangle.
   * @property {number} y The y position of the bounding rectangle.
   * @property {number} width The width of the bounding rectangle.
   * @property {number} height The height of the bounding rectangle.
   */

  // DEPRECATED OPTIONS FOR WIDGET SYNTAX

  /**
   * Defines whether the value of the gauge can be changed by the end user.
   * @ignore
   * @expose
   * @name readOnly
   * @memberof oj.ojStatusMeterGauge
   * @instance
   * @type {boolean}
   * @default true
   */

  // SubId Locators **************************************************************

  /**
   * <p>Sub-ID for the the status meter guage tooltip.</p>
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.</p>
   *
   * @ojsubid
   * @member
   * @name oj-statusmetergauge-tooltip
   * @memberof oj.ojStatusMeterGauge
   * @instance
   *
   * @example <caption>Get the tooltip object of the gauge, if displayed:</caption>
   * var nodes = myStatusMeterGauge.getNodeBySubId({'subId': 'oj-statusmetergauge-tooltip'});
   */

  // Slots ***********************************************************************

  /**
   * <p>The <code class="prettyprint">centerTemplate</code> slot is used to specify custom center content
   * for a circular status meter gauge.  This slot takes precedence over the center.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the gauge center. (See [oj.ojStatusMeterGauge.CenterContext]{@link oj.ojStatusMeterGauge.CenterContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot centerTemplate
   * @ojtemplateslotprops oj.ojStatusMeterGauge.CenterContext
   * @memberof oj.ojStatusMeterGauge
   * @ojshortdesc The centerTemplate slot is used to specify custom center content for a circular status meter gauge. This slot takes precedence over the center.renderer property if specified. See the Help documentation for more information.
   *
   * @example <caption>Initialize the Status Meter Gauge with a center template specified:</caption>
   * &lt;oj-status-meter-gauge orientation="circular">
   *  &lt;template slot="centerTemplate">
   *    &lt;div :style="[[{position: 'absolute',
   *                       top: $current.innerBounds.y + 'px',
   *                       left: $current.innerBounds.x + 'px',
   *                       height: $current.innerBounds.height + 'px',
   *                       width: $current.innerBounds.width + 'px'}]]">
   *      &lt;span class="metric">&lt;oj-bind-text value="[[$current.metricLabel]]">&lt;/oj-bind-text>&lt;/span>
   *    &lt;/div>
   *  &lt;/template>
   * &lt;/oj-status-meter-gauge>
   */

  /**
   * <p>The <code class="prettyprint">tooltipTemplate</code> slot is used to specify custom tooltip content.
   * This slot takes precedence over the tooltip.renderer property if specified.
   * <p>When the template is executed, the component's binding context is extended with the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the gauge. (See [oj.ojStatusMeterGauge.TooltipContext]{@link oj.ojStatusMeterGauge.TooltipContext} or the table below for a list of properties available on $current) </li>
   * </ul>
   *
   *
   * @ojslot tooltipTemplate
   * @ojtemplateslotprops oj.ojStatusMeterGauge.TooltipContext
   * @memberof oj.ojStatusMeterGauge
   * @ojshortdesc The tooltipTemplate slot is used to specify custom tooltip content. See the Help documentation for more information.
   *
   * @example <caption>Initialize the StatusMeterGauge with a tooltip template specified:</caption>
   * &lt;oj-status-meter-gauge>
   *  &lt;template slot="tooltipTemplate">
   *    &lt;span class="label">&lt;oj-bind-text value="[[$current.label]]">&lt;/oj-bind-text>&lt;/span>
   *  &lt;/template>
   * &lt;/oj-status-meter-gauge>
   */

  //-----------------------------------------------------
  //                   Styling
  //-----------------------------------------------------
  /**
   * @ojstylevariableset oj-status-meter-gauge-css-set1
   * @ojdisplayname metricLabel
   * @ojstylevariable --oj-gauge-metric-label-font-weight {description: "Font weight for metric label.", formats: ["font_weight"], help: "oj-status-meter-gauge-css-set1"}
   * @memberof oj.ojStatusMeterGauge
   */

  /**
   * @ojstylevariableset oj-statusmeter-gauge-css-set2
   * @ojdisplayname Horizontal and Vertical Status Meter Gauge Size
   * @ojstylevariable oj-statusmeter-gauge-bar-sm-size {description: "Vertical and horizontal status meter gauge small size", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-statusmeter-gauge-bar-md-size {description: "Vertical and horizontal status meter gauge medium size",formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-statusmeter-gauge-bar-lg-size {description: "Vertical and horizontal status meter gauge large size", formats: ["length"], help: "#css-variables"}
   * @memberof oj.ojStatusMeterGauge
   */

  /**
   * @ojstylevariableset oj-statusmeter-gauge-css-set2
   * @ojdisplayname Circular Status Meter Gauge Size
   * @ojstylevariable oj-statusmeter-gauge-circular-sm-size {description: "Circular status meter gauge small size", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-statusmeter-gauge-circular-md-size {description: "Circular status meter gauge medium size",formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-statusmeter-gauge-circular-lg-size {description: "Circular status meter gauge large size", formats: ["length"], help: "#css-variables"}
   * @memberof oj.ojStatusMeterGauge
   */

  /**
   * @ojstylevariableset oj-statusmeter-gauge-css-set3
   * @ojdisplayname Plot Area
   * @ojstylevariable --oj-statusmeter-gauge-bar-plotarea-border-color {description: "Border color for plot area in vertical and horizontal status meter gauges.", formats: ["color"], help: "#css-variables"}
   * @ojstylevariable --oj-statusmeter-gauge-bar-plotarea-color {description: "Color for plot area in vertical and horizontal status meter gauges.", formats: ["color"], help: "#css-variables"}
   * @memberof oj.ojStatusMeterGauge
   */

});


define("bundles/ojchartbundle", function(){});
